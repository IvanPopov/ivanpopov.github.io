{"version":3,"file":"LanguageServiceProvider.904af4e6f0129f42227d.worker.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACa;AACN;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F;AAC3F;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAA6C,IAAI;AAClF;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD,gBAAgB,oCAAoC;AACpD;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AAC1C;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;;;;;;;;;;;;;;;;AC/pE2B;AAC5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;;GAEG;AACI,IAAI,IAAI,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5C;;GAEG;AACI,IAAI,OAAO,GAAG,CAAC,KAAa,EAAE,GAAW,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AAChF;;;GAGG;AACI,IAAI,OAAO,GAAG,CAAC,KAAa,EAAE,GAAW,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AAClF;;;GAGG;AACI,IAAI,OAAO,GAAG,CAAC,KAAa,EAAE,GAAW,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB,kBAAkB,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,yDAAyD,gBAAgB,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;AACtH;;;;;;;UC5SA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;;;;;WCVA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNyD;AACuB;AAKL;AAExC;AAC0H;AAE7J,4BAA4B;AAC5B,6BAA6B;AAC7B,0BAA0B;AAC1B,8BAA8B;AAE9B,kEAAkE;AAClE,kDAAkD;AAClD,8BAA8B;AAG9B,SAAS,cAAc,CAAC,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAE,IAAI,EAAE,QAAQ,EAAE;IAC3E,OAAO,4EAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;AACtE,CAAC;A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","sources":["webpack://influx/./node_modules/vscode-languageserver-types/lib/esm/main.js","webpack://influx/./src/lib/fx/HLSL.js","webpack://influx/./src/lib/bf/bf.ts","webpack://influx/./src/lib/bf/index.ts","webpack://influx/./src/lib/common.ts","webpack://influx/./src/lib/fx/AnalyzerDiagnostics.ts","webpack://influx/./src/lib/fx/FXSLDocument.ts","webpack://influx/./src/lib/fx/SLASTDocument.ts","webpack://influx/./src/lib/fx/SLParser.ts","webpack://influx/./src/lib/fx/TextDocument.ts","webpack://influx/./src/lib/fx/Visitors.ts","webpack://influx/./src/lib/fx/analisys/Analyzer.ts","webpack://influx/./src/lib/fx/analisys/FxAnalyzer.ts","webpack://influx/./src/lib/fx/analisys/ProgramScope.ts","webpack://influx/./src/lib/fx/analisys/SystemScope.ts","webpack://influx/./src/lib/fx/analisys/helpers/expression.ts","webpack://influx/./src/lib/fx/analisys/helpers/fn.ts","webpack://influx/./src/lib/fx/analisys/helpers/index.ts","webpack://influx/./src/lib/fx/analisys/helpers/instruction.ts","webpack://influx/./src/lib/fx/analisys/helpers/types.ts","webpack://influx/./src/lib/fx/analisys/helpers/variable.ts","webpack://influx/./src/lib/fx/analisys/instructions/AnnotationInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/AttributeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BitwiseExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BoolInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CastExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CbufferInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CompileExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/CompileShader11Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/DeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FloatInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ForStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IdExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IdInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/IfStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/InitExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/InstructionCollector.ts","webpack://influx/./src/lib/fx/analisys/instructions/IntInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/NullInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PassInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Preset.ts","webpack://influx/./src/lib/fx/analisys/instructions/PresetProperty.ts","webpack://influx/./src/lib/fx/analisys/instructions/ProvideInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StateBlockInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/StringInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/Technique11Instruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TechniqueInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypedInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/TypedefInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/DrawInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts","webpack://influx/./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts","webpack://influx/./src/lib/fx/analisys/system/AppendStructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/BufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWStructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWTexture1DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/RWTexture2DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/StructuredBufferTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture2DArrayTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture2DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/Texture3DTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TextureCubeArrayTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TextureCubeTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TriMeshTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/TypeTemplate.ts","webpack://influx/./src/lib/fx/analisys/system/api.ts","webpack://influx/./src/lib/fx/analisys/system/builtin.ts","webpack://influx/./src/lib/fx/analisys/system/matrix.ts","webpack://influx/./src/lib/fx/analisys/system/scalar.ts","webpack://influx/./src/lib/fx/analisys/system/utils.ts","webpack://influx/./src/lib/fx/analisys/system/vector.ts","webpack://influx/./src/lib/fx/translators/BaseEmitter.ts","webpack://influx/./src/lib/fx/translators/CodeEmitter.ts","webpack://influx/./src/lib/fx/translators/Output.ts","webpack://influx/./src/lib/idl/EAnalyzerErrors.ts","webpack://influx/./src/lib/idl/EAnalyzerWarnings.ts","webpack://influx/./src/lib/idl/ERenderStateValues.ts","webpack://influx/./src/lib/idl/ERenderStates.ts","webpack://influx/./src/lib/idl/IDiagnostics.ts","webpack://influx/./src/lib/idl/IInstruction.ts","webpack://influx/./src/lib/idl/parser/IParser.ts","webpack://influx/./src/lib/idl/part/IPartFx.ts","webpack://influx/./src/lib/language-service/LanguageService.ts","webpack://influx/./src/lib/language-service/services/fx/codeLenses.ts","webpack://influx/./src/lib/language-service/services/signatureHelp.ts","webpack://influx/./src/lib/parser/ASTDocument.ts","webpack://influx/./src/lib/parser/AbstractParser.ts","webpack://influx/./src/lib/parser/CachingLexer.ts","webpack://influx/./src/lib/parser/Item.ts","webpack://influx/./src/lib/parser/Lexer.ts","webpack://influx/./src/lib/parser/Macros.ts","webpack://influx/./src/lib/parser/ParseTree.ts","webpack://influx/./src/lib/parser/Preprocessor.ts","webpack://influx/./src/lib/parser/State.ts","webpack://influx/./src/lib/parser/symbols.ts","webpack://influx/./src/lib/parser/util.ts","webpack://influx/./src/lib/path/path.ts","webpack://influx/./src/lib/uri/uri.ts","webpack://influx/./src/lib/util/Diagnostics.ts","webpack://influx/./src/lib/util/StringRef.ts","webpack://influx/./src/lib/util/s3d/type.ts","webpack://influx/./node_modules/comlink/dist/esm/comlink.mjs","webpack://influx/webpack/bootstrap","webpack://influx/webpack/runtime/define property getters","webpack://influx/webpack/runtime/harmony module decorator","webpack://influx/webpack/runtime/hasOwnProperty shorthand","webpack://influx/webpack/runtime/make namespace object","webpack://influx/./src/sandbox/containers/editor/LanguageServiceProvider.ts"],"sourcesContent":["/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === 'string';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * [Position](#Position) literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Position](#Position) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * [Range](#Range) literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * [Location](#Location) literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * [LocationLink](#LocationLink) literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [Color](#Color) literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * [ColorInformation](#ColorInformation) literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [ColorPresentation](#ColorPresentation) literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = 'comment';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = 'imports';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = 'region';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * [FoldingRange](#FoldingRange) literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * [Diagnostic](#Diagnostic) literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\n     */\n    function is(value) {\n        var _a;\n        var candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * [Command](#Command) literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        var result = { label: label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range: range, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range: range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'create',\n            uri: uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        var result = {\n            kind: 'rename',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'delete',\n            uri: uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.delete = function (range, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n        if (value === undefined) {\n            throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        }\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A helper class\n */\nvar ChangeAnnotations = /** @class */ (function () {\n    function ChangeAnnotations(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    ChangeAnnotations.prototype.all = function () {\n        return this._annotations;\n    };\n    Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n        var id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(\"Id \".concat(id, \" is already in use.\"));\n        }\n        if (annotation === undefined) {\n            throw new Error(\"No annotation provided for id \".concat(id));\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    };\n    ChangeAnnotations.prototype.nextId = function () {\n        this._counter++;\n        return this._counter.toString();\n    };\n    return ChangeAnnotations;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n        /**\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            this.initDocumentChanges();\n            if (this._changeAnnotations !== undefined) {\n                if (this._changeAnnotations.size === 0) {\n                    this._workspaceEdit.changeAnnotations = undefined;\n                }\n                else {\n                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var textDocument = { uri: key.uri, version: key.version };\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.initDocumentChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    };\n    WorkspaceChange.prototype.initChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    return WorkspaceChange;\n}());\nexport { WorkspaceChange };\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param version The document's version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * [TextDocumentItem](#TextDocumentItem) literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n    /**\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        var candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * [ParameterInformation](#ParameterInformation) literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * [SignatureInformation](#SignatureInformation) literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * [DocumentHighlight](#DocumentHighlight) literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name: name, kind: kind, location: { uri: uri, range: range } }\n            : { name: name, kind: kind, location: { uri: uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * [CodeActionContext](#CodeActionContext) literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        var result = { diagnostics: diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        var result = { title: title };\n        var checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * [CodeLens](#CodeLens) literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * [FormattingOptions](#FormattingOptions) literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * [DocumentLink](#DocumentLink) literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"method\"] = \"method\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range: range, text: text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range: range, expression: expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * [InlineValueContext](#InlineValueContext) literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId: frameId, stoppedLocation: stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the [InlineValueContext](#InlineValueContext) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value: value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        var result = { position: position, label: label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport var EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId The document's language Id.\n     * @param version The document's version.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n","export { default as HLSL } from './HLSL.gr';\r\n\r\n","/**\r\n * Сдвиг единицы на @a x позиций влево.\r\n */\r\nexport var flag = (x: number) => (1 << (x));\r\n/**\r\n * Проверка того что у @a value бит под номером @a bit равен единице.\r\n */\r\nexport var testBit = (value: number, bit: number) => ((value & flag(bit)) != 0);\r\n/**\r\n * Проверка того что у @a value равны единице все биты,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAll = (value: number, set: number) => (((value) & (set)) == (set));\r\n/**\r\n * Проверка того что у @a value равны единице хотя бы какие то из битов,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAny = (value: number, set: number) => (((value) & (set)) != 0);\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным единице\r\n */\r\nexport var setBit = (value: number, bit: number, setting: boolean = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));\r\n/**\r\n *\r\n */\r\nexport var clearBit = (value: number, bit: number) => ((value) &= ~flag((bit)));\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным нулю\r\n */\r\nexport var setAll = (value: number, set: number, setting: boolean = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var clearAll = (value: number, set: number) => ((value) &= ~(set));\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var equal = (value: number, src: number) => { value = src; };\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var isEqual = (value: number, src: number) => value == src;\r\n/**\r\n * Если число @a value равно числу @a src возвращается true\r\n */\r\nexport var isNotEqaul = (value: number, src: number) => value != src;\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var set = (value: number, src: number) => { value = src; };\r\n/**\r\n * Обнуляет число @a value\r\n */\r\nexport var clear = (value: number) => { value = 0; };\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var setFlags = (value: number, src: number) => (value |= src);\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var clearFlags = (value: number, src: number) => value &= ~src;\r\n/**\r\n * Проверяет равно ли число @a value нулю. Если равно возвращает true.\r\n * Если не равно возвращает false.\r\n */\r\nexport var isEmpty = (value: number) => (value == 0);\r\n/**\r\n * Возвращает общее количество бит числа @a value.\r\n * На самом деле возвращает всегда 32.\r\n */\r\nexport var totalBits = (value: number) => 32;\r\n\r\n\r\n/**\r\n * Возвращает общее количество ненулевых бит числа @a value.\r\n */\r\nexport var totalSet = (value: number): number => {\r\n    var count: number = 0;\r\n    var total: number = totalBits(value);\r\n\r\n    for (var i: number = total; i; --i) {\r\n        count += (value & 1);\r\n        value >>= 1;\r\n    }\r\n\r\n    return (count);\r\n}\r\n","import * as bf from './bf';\r\nexport default bf;\r\n","import { isEqual } from \"./bf/bf\";\r\nimport { IMap } from \"./idl/IMap\";\r\n\r\nexport let typeOf: (x: any) => string = (x: any): string => {\r\n    const s: string = typeof x;\r\n\r\n    if (s === 'object') {\r\n        if (x) {\r\n            if (x instanceof Array) {\r\n                return 'array';\r\n            } else if (x instanceof Object) {\r\n                return s;\r\n            }\r\n\r\n            const sClassName: string = Object.prototype.toString.call(x);\r\n\r\n            if (sClassName === '[object Window]') {\r\n                return 'object';\r\n            }\r\n\r\n            if ((sClassName === '[object Array]' ||\r\n                (typeof x.length) === 'number' &&\r\n                (typeof x.splice) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('splice')\r\n\r\n            )) {\r\n                return 'array';\r\n            }\r\n\r\n            if ((sClassName === '[object Function]' ||\r\n                (typeof x.call) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('call'))) {\r\n                return 'function';\r\n            }\r\n        } else {\r\n            return 'null';\r\n        }\r\n    } else if (s === 'function' && (typeof x.call) === 'undefined') {\r\n        return 'object';\r\n    }\r\n\r\n    return s;\r\n};\r\n\r\nexport let isDef = (x: any): boolean => x !== undefined;\r\nexport let isDefAndNotNull = (x: any): boolean => x != null;\r\nexport let isEmpty = (x: any): boolean => x.length === 0;\r\nexport let isNull = (x: any): boolean => x === null;\r\nexport let isBoolean = (x: any): boolean => typeof x === 'boolean';\r\nexport let isString = (x: any): boolean => typeof x === 'string';\r\nexport let isNumber = (x: any): boolean => typeof x === 'number';\r\nexport let isFloat = isNumber;\r\nexport let isInt = (x: any): boolean => isNumber(x) && (~~x === x);\r\nexport let isUint = (x: any): boolean => isInt(x) && x > 0;\r\nexport let isFunction = (x: any): boolean => typeOf(x) === 'function';\r\nexport let isObject = (x: any): boolean => {\r\n    const T: string = typeOf(x);\r\n    return T === 'object' || T === 'array' || T === 'function';\r\n};\r\nexport let isArrayBuffer = (x: any): boolean => x instanceof ArrayBuffer;\r\nexport let isTypedArray = (x: any): boolean => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';\r\nexport let isBlob = (x: any): boolean => x instanceof Blob;\r\nexport let isArray = (x: any): boolean => typeOf(x) === 'array';\r\n// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);\r\nexport let deepEqual = (a: Object, b: Object) => JSON.stringify(a) === JSON.stringify(b);\r\n\r\n\r\nexport type Nullable<T> = {[P in keyof T]: T[P] | null } | null;\r\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\nexport type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\r\nexport type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\r\nexport type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\r\nexport type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\r\n/** For ex: retrieve the properties of the child that the parent does not have. */\r\nexport type Diff<T1, T2> = Pick<T1, Exclude<keyof T1, keyof T2>>;\r\nexport type NonFunctionDiff<T1, T2> = NonFunctionProperties<Diff<T1, T2>>;\r\nexport type PropertiesDiff<T1, T2> = Writeable<NonFunctionDiff<T1, T2>>;\r\nexport type MakeOptional<T> = { [P in keyof T]?: T[P]; };\r\n\r\nexport const assert = console.assert.bind(console);\r\nexport const verbose = console.log.bind(console);\r\n\r\n/** 'ForEach' for maps. */\r\nexport function mwalk<T>(map: IMap<T>, cb: (element: T, key?: string, i?: number) => boolean | void) {\r\n    let i = 0;\r\n    for (const key in map) {\r\n        if (cb(map[key], key, i++) === false) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n","import { isDefAndNotNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IFile, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\ninterface IDiagDesc {\r\n    file: IFile;\r\n    loc: IRange;\r\n    info: any; // TODO: fixme\r\n}\r\n\r\n\r\nexport class AnalyzerDiagnostics extends Diagnostics<IDiagDesc> {\r\n    constructor() {\r\n        super(\"Analyzer Diagnostics\", 'A');\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IDiagDesc): string {\r\n        return desc.file.toString();\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IDiagDesc): IRange {\r\n        return desc.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        // TODO: fill all errors.\r\n        // TODO: add support for warnings\r\n        return {\r\n            [EErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \\'*type*\\' type expected.', // TODO: specify type\r\n            [EErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \\'void\\' type expected.',\r\n            [EErrors.FunctionRedefinition]: 'Function redefinition. Function with name \\'{info.funcName}\\' already declared.', // TODO: add location where function declared before\r\n            [EErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \\'{info.funcName}\\' but another type already declared.', // TODO: specify prev type and location\r\n            [EErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.', // TODO: specify func name and return type details.\r\n            [EErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',\r\n            [EErrors.InvalidComplexNotFunction]: ({ info }: IDiagDesc) => \r\n                `Function definition for \"${info.funcName}(${info.args.join(', ')})\" has not been found.`\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IDiagDesc): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n","import { isNumber, isString } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IncludeResolver } from \"@lib/idl/parser/IParser\";\r\nimport { IKnownDefine } from \"@lib/parser/Preprocessor\";\r\nimport { IExprSubstCallback } from \"./analisys/Analyzer\";\r\n\r\nimport { FxAnalyzer } from \"./analisys/FxAnalyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\ntype Opts = { flags?: number, includeResolver?: IncludeResolver };\r\n\r\nexport interface IFXSLOptions {\r\n    flags?: number;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n};\r\n\r\nexport async function createFXSLDocument(document: ISLASTDocument | ITextDocument, \r\n    opts : IFXSLOptions = {}, parent: ISLDocument = null): Promise<ISLDocument> {\r\n    let textDocument: ITextDocument;\r\n    let slastDocument: ISLASTDocument;\r\n\r\n    if (isString((document as ITextDocument).source)) {    \r\n        textDocument = <ITextDocument>document;\r\n        slastDocument = await createSLASTDocument(textDocument, opts);\r\n    } else {\r\n        slastDocument = <ISLASTDocument>document;\r\n    }\r\n\r\n    const timeLabel = `createFXSLDocument(${slastDocument.uri})`;\r\n    console.time(timeLabel);\r\n\r\n    const analyzer = new FxAnalyzer;\r\n    const slDocument = await analyzer.parse(slastDocument, parent);\r\n    \r\n    console.timeEnd(timeLabel);\r\n\r\n    return slDocument;\r\n}\r\n\r\nexport async function extendFXSLDocument(textAddition: ITextDocument, base: ISLDocument, expressions?: IMap<IExprSubstCallback>, \r\n    opts: IFXSLOptions = {}): Promise<ISLDocument> {\r\n    let addition = null;\r\n    if (textAddition)\r\n    {\r\n        const knownTypes = Object.keys(base.root.scope.types);\r\n        const { flags, includeResolver } = opts;\r\n        addition = await createSLASTDocument(textAddition, { flags, knownTypes, includeResolver });\r\n    }\r\n    const analyzer = new FxAnalyzer;\r\n    const slDocument = analyzer.extend(addition, base, expressions);\r\n    return slDocument;\r\n}\r\n\r\n","import { IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { IMacro } from '@lib/idl/parser/IMacro';\r\nimport { EOperationType, IASTConfig, IFile, IncludeResolver, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { ASTDocument } from \"@lib/parser/ASTDocument\";\r\nimport { IKnownDefine, Preprocessor } from '@lib/parser/Preprocessor';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\nimport { defaultSLParser } from './SLParser';\r\n\r\n// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));\r\n\r\nconst PREDEFINED_TYPES = [\r\n    'half2', 'half3', 'half4',\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float2x3', 'float2x4', \r\n    'float3x2', 'float3x3', 'float3x4', \r\n    'float4x2', 'float4x3', 'float4x4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'bool2', 'bool3', 'bool4',\r\n    'auto'\r\n];\r\n\r\n\r\nexport class SLASTDocument extends ASTDocument implements ISLASTDocument {\r\n    protected preprocessor: Preprocessor;\r\n\r\n    constructor({ parser = defaultSLParser(), knownTypes = new Set(), ...settings }: IASTConfig = {}) {\r\n        super({ parser, knownTypes: new Set([...PREDEFINED_TYPES, ...knownTypes]), ...settings });\r\n    }\r\n\r\n\r\n    get includes(): Map<string, IRange> {\r\n        return this.preprocessor.includeMap;\r\n    }\r\n\r\n\r\n    get unreachableCode(): IRange[] {\r\n        return this.preprocessor.unreachableCodeList;\r\n    }\r\n\r\n\r\n    get macros(): IMacro[] {\r\n        return [ ...this.preprocessor.macros ];\r\n    }\r\n\r\n\r\n    get unresolvedMacros(): IMacro[] {\r\n        return this.preprocessor.unresolvedMacros;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        return this.preprocessor.uri;\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let preprocessorReport = this.preprocessor.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([preprocessorReport, parserReport]);\r\n    }\r\n\r\n\r\n    protected init(config: IASTConfig) {\r\n        super.init(config);\r\n        const { knownTypes } = this;\r\n        const { includeResolver, defines } = config;\r\n        this.preprocessor = new Preprocessor(this.parser.lexerEngine, { knownTypes, includeResolver, defines });\r\n\r\n        this.ruleFunctions.set('addType', this._addType.bind(this));\r\n        this.ruleFunctions.set('addTypeDef', this._addTypeDef.bind(this));\r\n        this.ruleFunctions.set('print', this._print.bind(this));\r\n    }\r\n\r\n\r\n    private _addType(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private _addTypeDef(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.children[0].value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private _print(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        console.log(node);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    protected setTextDocument(textDocument: ITextDocument): void {\r\n        this.preprocessor.setTextDocument(textDocument);\r\n    }\r\n\r\n\r\n    protected async readToken(): Promise<IToken> {\r\n        const token = await this.preprocessor.readToken();\r\n        \r\n        // replacement of the original token location with the macro location\r\n        const macroLoc = this.preprocessor.macroLocation();\r\n        if (macroLoc) { \r\n            token.loc = macroLoc; \r\n        }\r\n\r\n        return token;\r\n    }\r\n}\r\n\r\n\r\nexport interface ISLASTOptions {\r\n    flags?: number;\r\n    knownTypes?: string[];\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n};\r\n\r\nexport async function createSLASTDocument(textDocument: ITextDocument, opts : ISLASTOptions = {}): Promise<ISLASTDocument> {\r\n    const { flags, knownTypes, includeResolver, defines } = opts;\r\n    const document = new SLASTDocument({ knownTypes: new Set([...(knownTypes || [])]), includeResolver, defines });\r\n    // const timeLabel = `createSLASTDocument(${textDocument.uri})`;\r\n    // console.time(timeLabel);\r\n    await document.parse(textDocument, flags);\r\n    // console.timeEnd(timeLabel);\r\n    return document;\r\n}\r\n","import { deepEqual } from \"@lib/common\";\r\nimport { EParserFlags, EParserType, IParserParams } from \"@lib/idl/parser/IParser\";\r\nimport { IParser } from \"@lib/idl/parser/IParser\"\r\nimport { AbstractParser } from \"@lib/parser/AbstractParser\";\r\n\r\n// import slGrammar from 'raw-loader!./HLSL.gr';\r\nimport { HLSL as slGrammar } from './HLSL';\r\n\r\nexport class SLParser extends AbstractParser {\r\n    protected init({ grammar = slGrammar, type = EParserType.k_LALR, flags = EParserFlags.k_Default }: IParserParams) {\r\n        super.init({ grammar, type, flags });\r\n    }\r\n}\r\n\r\nlet paramsDefault: IParserParams = null;\r\nlet parserDefault: IParser = null;\r\n\r\nexport function defaultSLGrammar(): string {\r\n    return slGrammar;\r\n}\r\n\r\nexport function defaultSLParser(): IParser {\r\n    if (!parserDefault) {\r\n        createDefaultSLParser();\r\n    }\r\n    return parserDefault;\r\n}\r\n\r\n/**\r\n * Internal debugging functionality, no need to use without necessary.\r\n */\r\nexport function createDefaultSLParser(params: IParserParams = { grammar: slGrammar }) {\r\n    if (deepEqual(paramsDefault, params)) {\r\n        return;\r\n    }\r\n    paramsDefault = params;\r\n    parserDefault = new SLParser(params);\r\n}\r\n","import { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IPosition } from \"@lib/idl/parser/IParser\";\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport async function createTextDocument(uri: string | StringRef, source: string, offset: IPosition = null): Promise<ITextDocument> {\r\n    uri = StringRef.make(uri);\r\n    return { uri, source, offset };\r\n}\r\n","import { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, ISamplerStateBlockInstruction, IStmtBlockInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IWhileStmtInstruction, IBitwiseExprInstruction, ICompileShader11Instruction } from \"@lib/idl/IInstruction\";\r\n\r\n// TODO: move it to helpers\r\nexport function visitor(owner: IInstruction, cb: (instr: IInstruction, owner?: IInstruction) => void) {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n\r\n    const visit = (instr: IInstruction) => { \r\n        if (instr) {\r\n            cb(instr, owner); \r\n            visitor(instr, cb) \r\n        }\r\n    };\r\n\r\n    switch (owner.instructionType) {\r\n\r\n        //\r\n        // Stmt\r\n        //\r\n\r\n        case EInstructionTypes.k_ReturnStmt:\r\n            visit((owner as IReturnStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_DeclStmt:\r\n            (owner as IDeclStmtInstruction).declList.forEach(decl => visit(decl));\r\n            break;\r\n        case EInstructionTypes.k_ExprStmt:\r\n            visit((owner as IExprStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_IfStmt:\r\n            visit((owner as IIfStmtInstruction).cond);\r\n            visit((owner as IIfStmtInstruction).conseq);\r\n            visit((owner as IIfStmtInstruction).contrary);\r\n            break;\r\n        case EInstructionTypes.k_StmtBlock:\r\n            (owner as IStmtBlockInstruction).stmtList.forEach(stmt => visit(stmt));\r\n            break;\r\n        case EInstructionTypes.k_ForStmt:\r\n            visit((owner as IForStmtInstruction).init);\r\n            visit((owner as IForStmtInstruction).cond);\r\n            visit((owner as IForStmtInstruction).body);\r\n            visit((owner as IForStmtInstruction).step);\r\n            break;\r\n        case EInstructionTypes.k_WhileStmt:\r\n            visit((owner as IWhileStmtInstruction).cond);\r\n            visit((owner as IWhileStmtInstruction).body);\r\n            break;\r\n\r\n        //\r\n        // Expr\r\n        //\r\n\r\n        case EInstructionTypes.k_ArithmeticExpr:\r\n            visit((owner as IArithmeticExprInstruction).left);\r\n            visit((owner as IArithmeticExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_AssignmentExpr:\r\n            visit((owner as IAssignmentExprInstruction).left);\r\n            visit((owner as IAssignmentExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_BitwiseExpr:\r\n            visit((owner as IBitwiseExprInstruction).left);\r\n            visit((owner as IBitwiseExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_CastExpr:\r\n            visit((owner as ICastExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_CompileExpr:\r\n            (owner as ICompileExprInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as ICompileExprInstruction).function);\r\n            break;\r\n        case EInstructionTypes.k_CompileShader11Expr:\r\n            visit((owner as ICompileShader11Instruction).func);\r\n            (owner as ICompileShader11Instruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_ComplexExpr:\r\n            visit((owner as IComplexExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_ConditionalExpr:\r\n            visit((owner as IConditionalExprInstruction).left);\r\n            visit((owner as IConditionalExprInstruction).right);\r\n            visit((owner as IConditionalExprInstruction).condition);\r\n            break;\r\n        case EInstructionTypes.k_ConstructorCallExpr:\r\n            (owner as IConstructorCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IConstructorCallInstruction).ctor);\r\n            break;\r\n        case EInstructionTypes.k_FunctionCallExpr:\r\n            (owner as IFunctionCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IFunctionCallInstruction).decl);\r\n            break;\r\n        case EInstructionTypes.k_IdExpr:\r\n            visit((owner as IIdExprInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_InitExpr:\r\n            (owner as IInitExprInstruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_StateBlockExpr:\r\n            console.assert(false, 'not implemented');\r\n            break;\r\n        case EInstructionTypes.k_IntExpr:\r\n        case EInstructionTypes.k_FloatExpr:\r\n        case EInstructionTypes.k_BoolExpr:\r\n        case EInstructionTypes.k_StringExpr:\r\n        case EInstructionTypes.k_NullExpr:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_LogicalExpr:\r\n            visit((owner as ILogicalExprInstruction).left);\r\n            visit((owner as ILogicalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            visit((owner as IPostfixArithmeticInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_PostfixIndexExpr:\r\n            visit((owner as IPostfixIndexInstruction).element);\r\n            visit((owner as IPostfixIndexInstruction).index);\r\n            break;\r\n        case EInstructionTypes.k_PostfixPointExpr:\r\n            visit((owner as IPostfixPointInstruction).element);\r\n            visit((owner as IPostfixPointInstruction).postfix);\r\n            break;\r\n        case EInstructionTypes.k_RelationalExpr:\r\n            visit((owner as IRelationalExprInstruction).left);\r\n            visit((owner as IRelationalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_SamplerStateBlockExpr:\r\n            (owner as ISamplerStateBlockInstruction).params.forEach(param => visit(param));\r\n            visit((owner as ISamplerStateBlockInstruction).texture);\r\n            break;\r\n        case EInstructionTypes.k_UnaryExpr:\r\n            visit((owner as IUnaryExprInstruction).expr);\r\n            break;\r\n\r\n        //\r\n        // Others\r\n        //\r\n        case EInstructionTypes.k_ComplexType:\r\n            (owner as ITypeInstruction).fields.forEach(field => visit(field));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDef:\r\n            visit((owner as IFunctionDefInstruction).returnType);\r\n            visit((owner as IFunctionDefInstruction).id);\r\n            (owner as IFunctionDefInstruction).params.forEach(param => visit(param));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDecl:\r\n            visit((owner as IFunctionDeclInstruction).def);\r\n            visit((owner as IFunctionDeclInstruction).impl);\r\n            break;\r\n        case EInstructionTypes.k_VariableDecl:\r\n            visit((owner as IVariableDeclInstruction).type);\r\n            visit((owner as IVariableDeclInstruction).initExpr);\r\n            visit((owner as IVariableDeclInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_VariableType:\r\n            visit((owner as IVariableTypeInstruction).subType);\r\n            break;\r\n        case EInstructionTypes.k_Id:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_SystemFunctionDecl:\r\n        case EInstructionTypes.k_SystemType:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_BreakStmt:\r\n            break;\r\n\r\n        case EInstructionTypes.k_SpawnStmt:\r\n            // nothing todo?\r\n            break;\r\n\r\n        default:\r\n            console.error('unsupported instruction type found');\r\n    }\r\n}\r\n\r\nexport const Visitor = {\r\n    each: visitor\r\n};\r\n\r\n","import { assert, isDef, isDefAndNotNull, isNull, mwalk } from '@lib/common';\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport {\r\n    EInstructionTypes, EScopeType, ETechniqueType,\r\n    IAnnotationInstruction, IArithmeticOperator, IAttributeInstruction, IBitwiseOperator, ICbufferInstruction,\r\n    ICompileShader11Instruction, IConstructorCallInstruction, IDeclInstruction, IDoWhileOperator, IExprInstruction,\r\n    IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIdInstruction,\r\n    IInstruction, IInstructionCollector, ILiteralInstruction, ILogicalOperator, IPass11Instruction, IPassInstruction,\r\n    IPresetInstruction, IPresetPropertyInstruction, IProvideInstruction, IScope, IStateBlockInstruction, IStmtBlockInstruction,\r\n    IStmtInstruction, ITechnique11Instruction, ITechniqueInstruction, ITypeDeclInstruction, ITypedefInstruction,\r\n    ITypedInstruction, ITypeInstruction, IUnaryOperator, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage\r\n} from '@lib/idl/IInstruction';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IFile, IParseNode, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { isNumber } from '@lib/util/s3d/type';\r\nimport { AnalyzerDiagnostics } from '@lib/fx/AnalyzerDiagnostics';\r\nimport { visitor } from '@lib/fx/Visitors';\r\nimport { expression, instruction, types } from './helpers';\r\nimport { AnnotationInstruction } from './instructions/AnnotationInstruction';\r\nimport { ArithmeticExprInstruction } from './instructions/ArithmeticExprInstruction';\r\nimport { AssigmentOperator, AssignmentExprInstruction } from \"./instructions/AssignmentExprInstruction\";\r\nimport { AttributeInstruction } from './instructions/AttributeInstruction';\r\nimport { BitwiseExprInstruction } from './instructions/BitwiseExprInstruction';\r\nimport { BoolInstruction } from './instructions/BoolInstruction';\r\nimport { BreakOperator, BreakStmtInstruction } from './instructions/BreakStmtInstruction';\r\nimport { CastExprInstruction } from './instructions/CastExprInstruction';\r\nimport { CbufferInstruction } from './instructions/CbufferInstruction';\r\nimport { CompileExprInstruction } from './instructions/CompileExprInstruction';\r\nimport { CompileShader11Instruction } from './instructions/CompileShader11Instruction';\r\nimport { ComplexExprInstruction } from './instructions/ComplexExprInstruction';\r\nimport { ComplexTypeInstruction } from './instructions/ComplexTypeInstruction';\r\nimport { ConditionalExprInstruction } from './instructions/ConditionalExprInstruction';\r\nimport { ConstructorCallInstruction } from './instructions/ConstructorCallInstruction';\r\nimport { DeclStmtInstruction } from './instructions/DeclStmtInstruction';\r\nimport { ExprStmtInstruction } from './instructions/ExprStmtInstruction';\r\nimport { FloatInstruction } from './instructions/FloatInstruction';\r\nimport { ForStmtInstruction } from './instructions/ForStmtInstruction';\r\nimport { FunctionCallInstruction } from './instructions/FunctionCallInstruction';\r\nimport { FunctionDeclInstruction } from './instructions/FunctionDeclInstruction';\r\nimport { FunctionDefInstruction } from './instructions/FunctionDefInstruction';\r\nimport { IdExprInstruction } from './instructions/IdExprInstruction';\r\nimport { IdInstruction } from './instructions/IdInstruction';\r\nimport { IfStmtInstruction } from './instructions/IfStmtInstruction';\r\nimport { InitExprInstruction } from './instructions/InitExprInstruction';\r\nimport { Instruction } from './instructions/Instruction';\r\nimport { InstructionCollector } from './instructions/InstructionCollector';\r\nimport { IntInstruction } from './instructions/IntInstruction';\r\nimport { LogicalExprInstruction } from './instructions/LogicalExprInstruction';\r\nimport { NullInstruction } from './instructions/NullInstruction';\r\nimport { PassInstruction } from './instructions/PassInstruction';\r\nimport { PostfixArithmeticInstruction, PostfixOperator } from './instructions/PostfixArithmeticInstruction';\r\nimport { PostfixIndexInstruction } from './instructions/PostfixIndexInstruction';\r\nimport { PostfixPointInstruction } from './instructions/PostfixPointInstruction';\r\nimport { PresetInstruction } from './instructions/Preset';\r\nimport { PresetProperty } from './instructions/PresetProperty';\r\nimport { ProvideInstruction } from \"./instructions/ProvideInstruction\";\r\nimport { ProxyTypeInstruction } from './instructions/ProxyTypeInstruction';\r\nimport { RelationalExprInstruction, RelationOperator } from './instructions/RelationalExprInstruction';\r\nimport { ReturnStmtInstruction } from './instructions/ReturnStmtInstruction';\r\nimport { SemicolonStmtInstruction } from './instructions/SemicolonStmtInstruction';\r\nimport { StateBlockInstruction } from './instructions/StateBlockInstruction';\r\nimport { StmtBlockInstruction } from './instructions/StmtBlockInstruction';\r\nimport { StringInstruction } from './instructions/StringInstruction';\r\nimport { SystemTypeInstruction } from './instructions/SystemTypeInstruction';\r\nimport { Technique11Instruction } from './instructions/Technique11Instruction';\r\nimport { TechniqueInstruction } from './instructions/TechniqueInstruction';\r\nimport { TypeDeclInstruction } from './instructions/TypeDeclInstruction';\r\nimport { TypedefInstruction } from './instructions/TypedefInstruction';\r\nimport { UnaryExprInstruction } from './instructions/UnaryExprInstruction';\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from './instructions/VariableDeclInstruction';\r\nimport { VariableTypeInstruction } from './instructions/VariableTypeInstruction';\r\nimport { WhileStmtInstruction } from './instructions/WhileStmtInstruction';\r\nimport { ProgramScope, ProgramScopeEx } from './ProgramScope';\r\nimport { parseUintLiteral } from './system/utils';\r\nimport * as SystemScope from './SystemScope';\r\nimport {\r\n    T_BOOL, T_BOOL2, T_BOOL3, T_BOOL4, T_COMPUTE_SHADER, T_FLOAT4, T_GEOMETRY_SHADER, T_INT, T_PIXEL_SHADER, T_UINT, T_VERTEX_SHADER, T_VOID\r\n} from './SystemScope';\r\n\r\n\r\ntype IErrorInfo = IMap<any>;\r\ntype IWarningInfo = IMap<any>;\r\n\r\nexport type IExprSubstCallback = (context: Context, program: ProgramScope, sourceNode: IParseNode) => IExprInstruction;\r\n\r\n// TODO: refactor it\r\nfunction findConstructor(type: ITypeInstruction, args: IExprInstruction[]): IVariableTypeInstruction {\r\n    return new VariableTypeInstruction({ type, scope: null });\r\n}\r\n\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\n\r\n// FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n// relax only uint => int\r\nconst asRelaxedType = (instr: ITypedInstruction | ITypeInstruction): ITypeInstruction | RegExp => {\r\n    if (!instr) {\r\n        return null;\r\n    }\r\n\r\n    const type = ((instr as any).getField) ? <ITypeInstruction>instr : (<ITypedInstruction> instr).type;\r\n    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    //          hacky way to check if \"type\" instruction (not \"typed\")\r\n\r\n    // hack to NULL expression to any type\r\n    if (types.equals(type, SystemScope.T_NULL)) {\r\n        return /^.*$/;\r\n    }\r\n\r\n    // allow \"int\" => \"float\" substitution\r\n    if (SystemScope.isIntBasedType(type) || SystemScope.isUintBasedType(type) || SystemScope.isBoolBasedType(type)) {\r\n        // temp workaround in order to match int to uint and etc. \r\n        const n = `${type.length > 1 ? type.length : ''}`;\r\n        return new RegExp(`^int${n}$|^uint${n}$|^bool${n}$|^float${n}$`, \"g\")\r\n    }\r\n\r\n    return type;\r\n};\r\n\r\n// TODO: rework 'auto' api\r\nfunction tryResolveProxyType(type: IVariableTypeInstruction, host: ITypeInstruction) {\r\n    if (type.subType && type.subType.instructionType === EInstructionTypes.k_ProxyType) {\r\n        const proxy = <ProxyTypeInstruction>type.subType;\r\n        if (!proxy.isResolved()) {\r\n            proxy.resolve(host);\r\n        }\r\n    }\r\n}\r\n\r\n/** @deprecated */\r\nfunction getRenderStateValue(state: ERenderStates, value: string): ERenderStateValues {\r\n    let eValue: ERenderStateValues = ERenderStateValues.UNDEF;\r\n\r\n    switch (state) {\r\n        case ERenderStates.ALPHABLENDENABLE:\r\n        case ERenderStates.ALPHATESTENABLE:\r\n            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');\r\n            return ERenderStateValues.UNDEF;\r\n\r\n        case ERenderStates.BLENDENABLE:\r\n        case ERenderStates.CULLFACEENABLE:\r\n        case ERenderStates.ZENABLE:\r\n        case ERenderStates.ZWRITEENABLE:\r\n        case ERenderStates.DITHERENABLE:\r\n        case ERenderStates.SCISSORTESTENABLE:\r\n        case ERenderStates.STENCILTESTENABLE:\r\n        case ERenderStates.POLYGONOFFSETFILLENABLE:\r\n            switch (value) {\r\n                case 'TRUE':\r\n                    eValue = ERenderStateValues.TRUE;\r\n                    break;\r\n                case 'FALSE':\r\n                    eValue = ERenderStateValues.FALSE;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '\r\n                        + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.CULLFACE:\r\n            switch (value) {\r\n                case 'FRONT':\r\n                    eValue = ERenderStateValues.FRONT;\r\n                    break;\r\n                case 'BACK':\r\n                    eValue = ERenderStateValues.BACK;\r\n                    break\r\n                case 'FRONT_AND_BACK':\r\n                    eValue = ERenderStateValues.FRONT_AND_BACK;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.FRONTFACE:\r\n            switch (value) {\r\n                case 'CW':\r\n                    eValue = ERenderStateValues.CW;\r\n                    break;\r\n                case 'CCW':\r\n                    eValue = ERenderStateValues.CCW;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.SRCBLEND:\r\n        case ERenderStates.DESTBLEND:\r\n        case ERenderStates.SRCBLENDALPHA:\r\n        case ERenderStates.DESTBLENDALPHA:\r\n        case ERenderStates.SRCBLENDCOLOR:\r\n        case ERenderStates.DESTBLENDCOLOR:\r\n        case ERenderStates.BLENDFUNC:\r\n        case ERenderStates.BLENDFUNCSEPARATE:\r\n            switch (value) {\r\n                case 'ZERO':\r\n                    eValue = ERenderStateValues.ZERO;\r\n                    break;\r\n                case 'ONE':\r\n                    eValue = ERenderStateValues.ONE;\r\n                    break;\r\n                case 'SRCCOLOR':\r\n                    eValue = ERenderStateValues.SRCCOLOR;\r\n                    break;\r\n                case 'INVSRCCOLOR':\r\n                    eValue = ERenderStateValues.INVSRCCOLOR;\r\n                    break;\r\n                case 'SRCALPHA':\r\n                    eValue = ERenderStateValues.SRCALPHA;\r\n                    break;\r\n                case 'INVSRCALPHA':\r\n                    eValue = ERenderStateValues.INVSRCALPHA;\r\n                    break;\r\n                case 'DESTALPHA':\r\n                    eValue = ERenderStateValues.DESTALPHA;\r\n                    break;\r\n                case 'INVDESTALPHA':\r\n                    eValue = ERenderStateValues.INVDESTALPHA;\r\n                    break;\r\n                case 'DESTCOLOR':\r\n                    eValue = ERenderStateValues.DESTCOLOR;\r\n                    break;\r\n                case 'INVDESTCOLOR':\r\n                    eValue = ERenderStateValues.INVDESTCOLOR;\r\n                    break;\r\n                case 'SRCALPHASAT':\r\n                    eValue = ERenderStateValues.SRCALPHASAT;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.BLENDEQUATION:\r\n        case ERenderStates.BLENDEQUATIONSEPARATE:\r\n        case ERenderStates.BLENDEQUATIONCOLOR:\r\n        case ERenderStates.BLENDEQUATIONALPHA:\r\n            switch (value) {\r\n                case 'FUNCADD':\r\n                case 'ADD':\r\n                    eValue = ERenderStateValues.FUNCADD;\r\n                    break;\r\n                case 'FUNCSUBTRACT':\r\n                case 'SUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCSUBTRACT;\r\n                    break;\r\n                case 'FUNCREVERSESUBTRACT':\r\n                case 'REVERSESUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCREVERSESUBTRACT;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.ZFUNC:\r\n            switch (value) {\r\n                case 'NEVER':\r\n                    eValue = ERenderStateValues.NEVER;\r\n                    break;\r\n                case 'LESS':\r\n                    eValue = ERenderStateValues.LESS;\r\n                    break;\r\n                case 'EQUAL':\r\n                    eValue = ERenderStateValues.EQUAL;\r\n                    break;\r\n                case 'LESSEQUAL':\r\n                    eValue = ERenderStateValues.LESSEQUAL;\r\n                    break;\r\n                case 'GREATER':\r\n                    eValue = ERenderStateValues.GREATER;\r\n                    break;\r\n                case 'NOTEQUAL':\r\n                    eValue = ERenderStateValues.NOTEQUAL;\r\n                    break;\r\n                case 'GREATEREQUAL':\r\n                    eValue = ERenderStateValues.GREATEREQUAL;\r\n                    break;\r\n                case 'ALWAYS':\r\n                    eValue = ERenderStateValues.ALWAYS;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n        case ERenderStates.PRIMITIVETOPOLOGY:\r\n            switch (value) {\r\n                case 'TRIANGLELIST':\r\n                    eValue = ERenderStateValues.TRIANGLELIST;\r\n                    break;\r\n                case 'LINELIST':\r\n                    eValue = ERenderStateValues.LINELIST;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n    }\r\n\r\n    return eValue;\r\n}\r\n\r\n\r\n\r\n\r\nfunction addTypeDecl(context: Context, scope: IScope, typeDecl: ITypeDeclInstruction): void {\r\n    if (SystemScope.findType(typeDecl.name)) {\r\n        context.error(typeDecl.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n\r\n    let isAdded = scope.addType(typeDecl.type);\r\n    if (!isAdded) {\r\n        context.error(typeDecl.sourceNode, EErrors.TypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n}\r\n\r\n// TODO: rework to support complex typ defenitions like \r\n//  typedef const float4 TYPE_T;\r\n//          ^^^^^^\r\n// IP: at the moment type defenitions are not supported\r\nfunction addTypeAlias(context: Context, scope: IScope, typedef: ITypedefInstruction): void {\r\n    if (SystemScope.findType(typedef.alias)) {\r\n        context.error(typedef.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typedef.name });\r\n    }\r\n\r\n    let isAdded = scope.addTypeAlias(typedef.type, typedef.alias);\r\n    if (!isAdded) {\r\n        context.error(typedef.sourceNode, EErrors.TypeRedefinition, { typeName: typedef.alias });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction checkFunctionForRecursion(context: Context, func: IFunctionDeclInstruction, stack: number[]): boolean {\r\n    if (stack.indexOf(func.instructionID) !== -1) {\r\n        context.error(func.sourceNode,\r\n            EErrors.InvalidFunctionRecursionNotAllowed,\r\n            { funcName: func.name });\r\n        return false;\r\n    }\r\n\r\n    let recursionFound = false;\r\n\r\n    stack = [...stack, func.instructionID];\r\n    const recursionChecker = (instr: IInstruction) => {\r\n        if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n            let fcall = (instr as IFunctionCallInstruction);\r\n            let fdecl = fcall.decl;\r\n            if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                return;\r\n            }\r\n\r\n            // NOTE: it is possible that the declaration was not complete \r\n            //       at the time of the call, so you need to look for a \r\n            //       version with implementation\r\n            fdecl = fdecl.scope.findFunctionInScope(fdecl);\r\n            if (isNull(fdecl.impl)) {\r\n                if (fdecl.attrs.find(attr => attr.name === 'extern')) {\r\n                    // todo: use context info\r\n                    context.warn(instr.sourceNode, EWarnings.ExternCall);\r\n                } else {\r\n                    context.error(instr.sourceNode,\r\n                        EErrors.InvalidFunctionImplementationNotFound,\r\n                        { funcName: fdecl.name });\r\n                }\r\n                return;\r\n            }\r\n\r\n            // visitor(fdecl.impl, recursionChecker);\r\n            recursionFound = recursionFound ||\r\n                checkFunctionForRecursion(context, fdecl, stack);\r\n        }\r\n    };\r\n\r\n    visitor(func.impl, recursionChecker);\r\n\r\n    return !recursionFound;\r\n}\r\n\r\nfunction checkFunctionsForRecursion(context: Context, program: ProgramScope) {\r\n    const gs = program.globalScope;\r\n\r\n    let recusrionFound = false;\r\n    mwalk(gs.functions, funcOverloads => {\r\n        funcOverloads.forEach(func => {\r\n            recusrionFound = recusrionFound ||\r\n                !checkFunctionForRecursion(context, func, []);\r\n        })\r\n    });\r\n\r\n    return !recusrionFound;\r\n}\r\n\r\n\r\n\r\nfunction checkForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nfunction checkReturnTypeForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    const returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (types.equals(returnType, T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    if (returnType.isComplex()) {\r\n        if (returnType.hasFieldWithoutSemantics()) {\r\n            // todo: emit warning\r\n            // return false;\r\n        }\r\n\r\n        if (!returnType.hasAllUniqueSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        // Forbid fileds with user-defined types\r\n        // or any other complex types?\r\n        // if (returnType.isContainComplexType()) \r\n        {\r\n            //return false;\r\n        }\r\n    } else {\r\n        if (!types.equals(returnType, T_FLOAT4)) {\r\n            return false;\r\n        }\r\n\r\n        if (funcDef.semantic !== \"POSITION\") {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// todo: add support for dual source blending\r\n// todo: add support for MRT\r\nfunction checkReturnTypeForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (types.equals(returnType, T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    // TODO: add MRT support\r\n    if (!SystemScope.isBase(returnType)) {\r\n        return false;\r\n    }\r\n\r\n    if (!types.equals(returnType, T_FLOAT4)) {\r\n        return false;\r\n    }\r\n\r\n    if (funcDef.semantic !== \"COLOR\") {\r\n        // todo: emit warning\r\n        // return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isAttributeByStruct = false;\r\n    let isAttributeByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (isNull(param.semantic)) {\r\n                if (SystemScope.isBase(param.type) ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByStruct = true;\r\n            } else if (!isNull(param.semantic)) {\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        } else if (isAttributeByStruct) {\r\n            return false;\r\n        } else if (isAttributeByParams) {\r\n            if (isNull(param.semantic)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isVaryingsByStruct = false;\r\n    let isVaryingsByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param: IVariableDeclInstruction = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (param.semantic === \"\") {\r\n                if (SystemScope.isBase(param.type) ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    // todo: check that there are no samplers in properties\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByStruct = true;\r\n            } else if (param.semantic !== \"\") {\r\n                // todo: check that there are no samplers in properties\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        }\r\n        else if (isVaryingsByStruct) {\r\n            return false;\r\n        }\r\n        else if (isVaryingsByParams) {\r\n            if (param.semantic === \"\") {\r\n                // todo: emit warning\r\n                // return false;\r\n            }\r\n\r\n            // todo: check that there are no samplers in properties\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nexport interface ICompileValidator {\r\n    // validate with custom arguments ignoring statements inside compile expression.\r\n    args?: (RegExp | ITypeInstruction)[];\r\n    ret?: ITypeInstruction;\r\n}\r\n\r\n\r\n\r\nexport class Context {\r\n    readonly uri: IFile;\r\n    readonly diagnostics: AnalyzerDiagnostics;\r\n\r\n    /** driven from provide declaration */\r\n    moduleName: string | null;\r\n\r\n    // funct states\r\n    func: boolean;                              // Are we inside a function analysis?\r\n    funcDef: IFunctionDefInstruction | null;    // Current function definition.\r\n    haveCurrentFunctionReturnOccur: boolean;    // TODO: replace with array of return statements.\r\n\r\n    cbuffer: boolean;\r\n\r\n    renderStates: IMap<ERenderStateValues>;\r\n\r\n    // graph needs extensions\r\n    expressions: IMap<IExprSubstCallback>;\r\n\r\n    constructor(uri: IFile, expressions?: IMap<IExprSubstCallback>) {\r\n        this.diagnostics = new AnalyzerDiagnostics;\r\n        this.uri = uri;\r\n        this.moduleName = null;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.expressions = expressions || {};\r\n    }\r\n\r\n    beginCbuffer(): void { this.cbuffer = true; }\r\n    endCbuffer(): void { this.cbuffer = false; }\r\n\r\n    beginFunc(): void {\r\n        this.func = true;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.funcDef = null; // << will be set inside analyzeFunctionDecl();\r\n    }\r\n\r\n    endFunc(): void {\r\n        this.func = false\r\n    }\r\n\r\n\r\n    beginPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n    endPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n\r\n    error(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.error(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    critical(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.critical(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    warn(sourceNode: IParseNode, code: number, info: IWarningInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.warning(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    private resolveNodeSourceLocation(sourceNode: IParseNode): IRange {\r\n        if (!isDefAndNotNull(sourceNode)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(sourceNode.loc)) {\r\n            return sourceNode.loc;\r\n        }\r\n\r\n        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Analyzer {\r\n\r\n\r\n    protected analyzeUseDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): void {\r\n        program.currentScope.strictMode = true;\r\n    }\r\n\r\n\r\n    protected analyzeComplexName(sourceNode: IParseNode): string {\r\n        const children = sourceNode.children;\r\n        let name: string = '';\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            name += children[i].value;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ProvideDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_PROVIDE = 'provide'\r\n     */\r\n    protected analyzeProvideDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IProvideInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children.length === 3) {\r\n            let moduleName = this.analyzeComplexName(children[1]);;\r\n            if (!isNull(context.moduleName)) {\r\n                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);\r\n            }\r\n            context.moduleName = moduleName;\r\n            assert(children[2].name === 'T_KW_PROVIDE');\r\n            return new ProvideInstruction({ sourceNode, moduleName, scope });\r\n        }\r\n\r\n        context.error(sourceNode, EErrors.UnsupportedProvideAs);\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     *    InitExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeInitExprChildren(context: Context, program: ProgramScope, sourceNode: IParseNode, children: IParseNode[], expectedType: ITypeInstruction, exprSourceNode: IParseNode = null): IExprInstruction {\r\n        const scope = program.currentScope;\r\n\r\n\r\n        // raw value like \"int a = 1\"\r\n        if (children.length === 1) {\r\n            const initExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n            if (!initExpr) {\r\n                return null;\r\n            }\r\n\r\n            // NOTE: exprSourceNode => source node of the whole expression like \"const float name = value\" for better error highlighting.\r\n            //                                                                               ^^^^^^^^^^^^\r\n            //       sourceNode => source node of the init expr: const float3 name = { 1, 2, 3 };\r\n            //                                                                    ^^^^^^^^^^^^^\r\n            //       sourceNode => source node of the init expr: const float3[1] name = { { 1, 2, 3 } };\r\n            //                                                                            ^^^^^^^^^^^\r\n\r\n            const resType = Analyzer.checkTwoOperandExprTypes(context, '=', expectedType, initExpr.type,\r\n                sourceNode/* Use correct source node! */, initExpr.sourceNode, exprSourceNode || sourceNode, { isInitializing: true });\r\n\r\n            if (!resType) {\r\n                // omit error, all errors must be already fired above (inside checkTwoOperandExprTypes)\r\n                return null;\r\n            }\r\n\r\n            ////////////////////////////////////////////////\r\n            // IP: quick hack to avoid future conversions\r\n            ////////////////////////////////////////////////\r\n\r\n            // cast uint <=> int constant if possible\r\n            // if (initExpr.instructionType === EInstructionTypes.k_IntExpr && !types.equals(initExpr.type, expectedType)) {\r\n            //     let { scope, sourceNode, base, exp, signed, heximal } = <IntInstruction>initExpr;\r\n            //     signed = expectedType.name === 'int';\r\n            //     return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n            // }\r\n\r\n            // if (!types.equals(initExpr.type, expectedType)) {\r\n            //     return new CastExprInstruction({scope, sourceNode, sourceExpr: initExpr, type: expectedType});\r\n            // }\r\n\r\n            ////////////////////////////////////////////////\r\n            ////////////////////////////////////////////////\r\n\r\n            return initExpr;\r\n        }\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        else if ((expectedType.isNotBaseArray() && expectedType.scope.type <= EScopeType.k_Global) ||\r\n            expectedType.isArray()) {\r\n            const args = <IExprInstruction[]>[];\r\n            const numArgs = (children.length - 1) / 2;\r\n\r\n            if (expectedType.length === instruction.UNDEFINE_LENGTH ||\r\n                (expectedType.isNotBaseArray() && numArgs !== expectedType.length) ||\r\n                (!expectedType.isNotBaseArray() && numArgs !== expectedType.baseType.length)) {\r\n                context.error(sourceNode, EErrors.InvalidVariableInitializingEx, {\r\n                    tooltip: `attemp to init an array with invalid number of arguments. expected: ${expectedType.length}, given: ${numArgs}`\r\n                });\r\n                return null;\r\n            }\r\n\r\n            const arrayElementType = <IVariableTypeInstruction>expectedType.arrayElementType;\r\n            /**\r\n             * AST example:\r\n             *    InitExpr\r\n             *         T_PUNCTUATOR_125 = '}'\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_44 = ','\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_123 = '{'\r\n             */\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    const initExpr = this.analyzeInitExpr(context, program, children[i], arrayElementType);\r\n\r\n                    if (isNull(initExpr)) {\r\n                        // omit error because it was already produced by the call above\r\n                        return null;\r\n                    }\r\n\r\n                    args.push(initExpr);\r\n                }\r\n            }\r\n\r\n            assert(expectedType.instructionType === EInstructionTypes.k_VariableType);\r\n            return new InitExprInstruction({ scope, sourceNode, args, type: <IVariableTypeInstruction>expectedType });\r\n        } else if (expectedType.isComplex()) {\r\n            const numArgs = (children.length - 1) / 2;\r\n            const fieldNameList = expectedType.fields.map(f => f.name);\r\n            const args = <IExprInstruction[]>[];\r\n\r\n            if (numArgs !== fieldNameList.length) {\r\n                // TODO: emit error (invalid number of arguments)\r\n                return null;\r\n            }\r\n\r\n            /**\r\n             * AST example:\r\n             *    InitExpr\r\n             *         T_PUNCTUATOR_125 = '}'\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_44 = ','\r\n             *       + InitExpr \r\n             *         T_PUNCTUATOR_123 = '{'\r\n             */\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    const fieldType = expectedType.getField(fieldNameList[i]).type;\r\n                    const initExpr = this.analyzeInitExpr(context, program, children[i], fieldType);\r\n\r\n                    if (isNull(initExpr)) {\r\n                        // omit error because it was already produced by the call above\r\n                        return null;\r\n                    }\r\n\r\n                    args.push(initExpr);\r\n                }\r\n            }\r\n            assert(expectedType.instructionType === EInstructionTypes.k_VariableType);\r\n            return new InitExprInstruction({ scope, sourceNode, args, type: <IVariableTypeInstruction>expectedType });\r\n        } else {\r\n            const numArgs = (children.length - 1) / 2;\r\n\r\n            // handle cases like: int a = { 1 };\r\n            if (numArgs !== 1) {\r\n                // TODO: emit error (invalid number of arguments)\r\n                return null;\r\n            }\r\n\r\n            const exprNode = children[children.length - 2];\r\n\r\n            let initExpr = null;\r\n            if (exprNode.name === 'InitExpr')\r\n                initExpr = this.analyzeInitExpr(context, program, exprNode, expectedType);\r\n            else\r\n                initExpr = this.analyzeExpr(context, program, children[children.length - 2]);\r\n            \r\n\r\n            // TODO: use checkTwoOperandTypes() function instead\r\n            if (!types.equals(expectedType, initExpr.type)) {\r\n                // TODO: emit error\r\n                return null;\r\n            }\r\n\r\n            return initExpr;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     *    InitExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeInitExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, expectedType: ITypeInstruction): IExprInstruction {\r\n        return this.analyzeInitExprChildren(context, program, sourceNode, sourceNode.children, expectedType);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    SamplerStateDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StateBlock \r\n     *         T_NON_TYPE_ID = 'MeshTextureSampler'\r\n     *         T_KW_SAMPLER_STATE = 'SamplerState'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzeSamplerStateDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVariableDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);\r\n        const vars: IVariableDeclInstruction[] = [];\r\n\r\n        if (isNull(generalType)) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars.push(this.analyzeVariable(context, program, children[i], generalType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UsageType\r\n     *       + Type \r\n     *       + Usage \r\n     */\r\n    protected analyzeUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        let usagesRaw: IVariableUsage[] = [];\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                // basically, just get type from scope\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null\r\n                }\r\n            }\r\n            else if (children[i].name === 'Usage') {\r\n                usagesRaw.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        const usageIn = usagesRaw.includes('in');\r\n        const usageOut = usagesRaw.includes('out');\r\n        const usageInout = usagesRaw.includes('inout');\r\n        const usageConst = usagesRaw.includes('const');\r\n        const usageUniform = usagesRaw.includes('uniform');\r\n        const usageUnsigned = usagesRaw.includes('unsigned');\r\n        const usageStatic = usagesRaw.includes('static');\r\n\r\n        // TODO: emit errors in case of inconsistent usages\r\n        // TODO: remplace with bitflags\r\n        let usages: IVariableUsage[] = [];\r\n        if (usageInout) {\r\n            usages.push('inout');\r\n            // emit error in case of uniform\r\n            // emit error in case of const\r\n        } else {\r\n            if (usageIn && usageOut) {\r\n                usages.push('inout');\r\n                // emit error in case of uniform\r\n                // emit error in case of const\r\n            } else {\r\n                if (usageIn) {\r\n                    usages.push('in');\r\n                }\r\n                if (usageOut) {\r\n                    usages.push('out');\r\n                    // emit error in case of const\r\n                    // emit error in case of uniform\r\n                } else {\r\n                    if (usageConst) usages.push('const');\r\n                    if (usageUniform) usages.push('uniform');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (usageStatic) {\r\n            usages.push('static');\r\n        }\r\n\r\n        if (usageUnsigned && !SystemScope.isIntBasedType(type)) {\r\n            console.error('invalid unsigned usage');\r\n        }\r\n\r\n        // wrap type with usages\r\n        return new VariableTypeInstruction({ scope, sourceNode, type, usages })\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Type\r\n     *         T_TYPE_ID = 'float3'\r\n     */\r\n    protected analyzeType(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n\r\n        switch (sourceNode.name) {\r\n            case 'T_TYPE_ID':\r\n                if (sourceNode.value === 'auto') {\r\n                    type = new ProxyTypeInstruction({ scope });\r\n                    break;\r\n                }\r\n\r\n                type = scope.findType(sourceNode.value);\r\n\r\n                if (isNull(type)) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });\r\n                }\r\n                break;\r\n            case 'Struct':\r\n                type = this.analyzeStruct(context, program, sourceNode);\r\n                break;\r\n\r\n            case 'T_KW_VOID':\r\n                type = T_VOID;\r\n                break;\r\n\r\n            case 'ScalarType':\r\n            case 'ObjectType':\r\n                {\r\n                    let typeName = children[children.length - 1].value;\r\n\r\n                    if (children.length !== 1) {\r\n                        assert(children[children.length - 2].value === '<' && children[0].value === '>');\r\n                        const tplName = typeName;\r\n                        const args = children\r\n                            .slice(1, -2)\r\n                            .reverse()\r\n                            .filter((v, i) => i % 2 == 0)\r\n                            .map(sourceNode => this.analyzeType(context, program, sourceNode));\r\n\r\n                        const template = scope.findTypeTemplate(typeName);\r\n\r\n                        if (isNull(template)) {\r\n                            context.error(sourceNode, EErrors.InvalidTypeNameTemplateNotFound,\r\n                                { tplName, args: args.map(arg => arg.toCode()) });\r\n                            return null;\r\n                        }\r\n\r\n                        // TODO: validate register\r\n                        // TODO: use ESystemTypes enumeration\r\n                        const SYSTEM_TYPES = [\r\n                            'Buffer',\r\n                            'RWBuffer',\r\n                            'RWStructuredBuffer',\r\n                            'AppendStructuredBuffer',\r\n                            'RWTexture1D',\r\n                            'RWTexture2D',\r\n                            'RWTexture3D',\r\n                            'Texture1D',\r\n                            'Texture2D',\r\n                            'Texture3D',\r\n                            'Texture2DArray',\r\n                            'TextureCubeArray',\r\n                        ];\r\n                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {\r\n                            if (scope.type != EScopeType.k_Global) {\r\n                                context.error(sourceNode, EErrors.InvalidTypeScope,\r\n                                    { typeName: template.name, tooltip: 'only global scope allowed' });\r\n                                return null;\r\n                            }\r\n                        }\r\n\r\n                        typeName = template.typeName(args);\r\n                        type = scope.findType(typeName);\r\n\r\n                        if (isNull(type)) {\r\n                            type = template.produceType(scope, args);\r\n                            if (isNull(type)) {\r\n                                context.error(sourceNode, EErrors.CannotProduceType, { typeName });\r\n                                return null;\r\n                            }\r\n                            scope.addType(type);\r\n                        }\r\n                    } else {\r\n                        type = scope.findType(typeName);\r\n                    }\r\n\r\n                    if (isNull(type)) {\r\n                        context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName });\r\n                        return null;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case 'VectorType':\r\n            case 'MatrixType':\r\n                context.error(sourceNode, EErrors.InvalidTypeVectorMatrix);\r\n                break;\r\n\r\n            case 'BaseType':\r\n            case 'Type':\r\n                return this.analyzeType(context, program, children[0]);\r\n        }\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    protected analyzeUsage(sourceNode: IParseNode): IVariableUsage {\r\n        sourceNode = sourceNode.children[0];\r\n        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout', 'static', 'unsigned', 'precise', 'inline'];\r\n        assert(supportedUsages.indexOf(sourceNode.value) !== -1, sourceNode.value);\r\n        return <IVariableUsage>sourceNode.value;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CbufferDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VarStructDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *       + Annotation \r\n     *       + Semantic \r\n     *         T_NON_TYPE_ID = 'NAME'\r\n     *         T_KW_CBUFFER = 'cbuffer'\r\n     * \r\n     * AST example:\r\n     *    CbufferDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VarStructDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_CBUFFER = 'cbuffer'\r\n     */\r\n    protected analyzeCbufferDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ICbufferInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation = <IAnnotationInstruction>null;\r\n        let semantic = '';\r\n        let id = <IIdInstruction>null;\r\n\r\n        context.beginCbuffer();\r\n\r\n        let ic = children.length - 2;\r\n        if (children[ic].name === 'T_NON_TYPE_ID') {\r\n            id = new IdInstruction({ scope, sourceNode: children[ic], name: children[ic].value });\r\n            ic--;\r\n        }\r\n\r\n        if (children[ic].name === 'Semantic') {\r\n            semantic = this.analyzeSemantic(children[ic]);\r\n\r\n            const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n            if (match) {\r\n                const rtype = match[1];\r\n                if (rtype !== 'b') {\r\n                    context.warn(children[ic], EWarnings.InvalidCbufferRegister);\r\n                }\r\n            }\r\n\r\n            ic--;\r\n        }\r\n\r\n        if (children[ic].name === 'Annotation') {\r\n            annotation = this.analyzeAnnotation(context, program, children[ic]);\r\n            ic--;\r\n        }\r\n\r\n        ic--;\r\n\r\n        // program.push(EScopeType.k_Cbuffer);\r\n\r\n        let fields = <IVariableDeclInstruction[]>[];\r\n        for (let i = ic; i >= 2; i--) {\r\n            switch (children[i].name) {\r\n                case 'VariableDecl':\r\n                    fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n                    break;\r\n                case 'VarStructDecl':\r\n                    fields = fields.concat(this.analyzeVarStructDecl(context, program, children[i]));\r\n                    break;\r\n                default:\r\n                    context.error(children[i], EErrors.UnknownInstruction, {});\r\n            }\r\n        }\r\n\r\n        // program.pop();\r\n\r\n        context.endCbuffer();\r\n\r\n        const aligment = T_FLOAT4.size; // float4 aligment!\r\n        const name = id.name;\r\n        const type = new ComplexTypeInstruction({ scope, sourceNode, name, fields, aligment });\r\n\r\n        {\r\n            let isAdded = scope.addType(type);\r\n            if (!isAdded) {\r\n                context.error(sourceNode, EErrors.TypeRedefinition, { typeName: name });\r\n            }\r\n        }\r\n\r\n        const cbuf = new CbufferInstruction({ id, type, sourceNode, semantic, annotation, scope });\r\n\r\n        {\r\n            let isAdded = scope.addCbuffer(cbuf);\r\n            if (!isAdded) {\r\n                context.error(sourceNode, EErrors.CbufferRedefinition, { typeName: name });\r\n            }\r\n        }\r\n\r\n        return cbuf;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Variable\r\n     *       + Initializer \r\n     *       + Semantic \r\n     *       + VariableDim\r\n     *              T_PUNCTUATOR_93 = ']'\r\n     *              T_NON_TYPE_ID = 'N'\r\n     *              T_PUNCTUATOR_91 = '['\r\n     *            + VariableDim\r\n     *                   T_NON_TYPE_ID = 'x'\r\n     *                   ^^^^^^^^^^^^^^^^^^\r\n     */\r\n    protected analyzeVariable(context: Context, program: ProgramScope, sourceNode: IParseNode, generalType: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let init: IExprInstruction = null;\r\n        let semantic = '';\r\n        let usageFlags = 0;\r\n\r\n        if (!context.func) {\r\n            if (scope.type !== EScopeType.k_Struct) {\r\n                usageFlags |= EVariableUsageFlags.k_Global;\r\n            }\r\n            if (context.cbuffer) {\r\n                usageFlags |= EVariableUsageFlags.k_Cbuffer;\r\n            }\r\n        } else {\r\n            // All variables found inside function definition are arguments.\r\n            if (!context.funcDef) {\r\n                usageFlags |= EVariableUsageFlags.k_Argument;\r\n            }\r\n            usageFlags |= EVariableUsageFlags.k_Local;\r\n        }\r\n\r\n\r\n        let id = <IIdInstruction>null;\r\n        let arrayIndex = <IExprInstruction>null;\r\n        let type = <IVariableTypeInstruction>null;\r\n\r\n        let vdimNode = children[children.length - 1];\r\n        do {\r\n            let vdimChildren = vdimNode.children;\r\n\r\n            if (vdimChildren.length === 1) {\r\n                const name = vdimChildren[0].value;\r\n                id = new IdInstruction({ scope, sourceNode, name });\r\n                break;\r\n            }\r\n\r\n            assert(vdimChildren.length == 4);\r\n\r\n            if (!isNull(arrayIndex)) {\r\n                // usage of generalType.source node instead of sourceNode was done for more clear debugging\r\n                generalType = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n            }\r\n\r\n            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);\r\n            vdimNode = vdimChildren[vdimChildren.length - 1];\r\n        } while (true);\r\n\r\n        // using generalType.source node instead of sourceNode was done for more clear debugging\r\n        type = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n        /**\r\n         * (state block initializer)\r\n         * AST example:\r\n         *    Initializer\r\n         *       + StateBlock \r\n         */\r\n        /**\r\n         * (list initializer)\r\n         * AST example:\r\n         *    Initializer\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_61 = '='\r\n         */\r\n        const doInitUsingList = (sourceNode: IParseNode) => \r\n            sourceNode.children[sourceNode.children.length - 1]?.value == '=';\r\n\r\n        for (let i = children.length - 2; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else if (children[i].name === 'Initializer') {\r\n                \r\n                if (doInitUsingList(children[i])) {\r\n                    init = this.analyzeInitializer(context, program, children[i], type, sourceNode);\r\n                } else {\r\n                    init = this.analyzeStateBlock(context, program, children[i].children[0], type);\r\n                }\r\n\r\n                switch (type.name) {\r\n                    case 'BlendState':\r\n                    case 'SamplerState':\r\n                    case 'SamplerComparisonState':\r\n                    case 'DepthStencilState':\r\n                    case 'RasterizerState':\r\n                        // todo: validate properties\r\n                        console.assert(!doInitUsingList(children[i]));\r\n                        console.assert(!type.isNotBaseArray() || type.length == (<IStateBlockInstruction>init).blocks.length);\r\n                        break;\r\n                    default:\r\n                        console.assert(doInitUsingList(children[i]));\r\n                }\r\n\r\n                if (!init) {\r\n                    // TODO: make it warning\r\n                    context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n                }\r\n            }\r\n        }\r\n\r\n        const varDecl = new VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });\r\n        assert(scope.type != EScopeType.k_System);\r\n\r\n        if (SystemScope.hasVariable(varDecl.name)) {\r\n            context.error(sourceNode, EErrors.SystemVariableRedefinition, { varName: varDecl.name });\r\n        }\r\n\r\n        const isAdded = scope.addVariable(varDecl);\r\n        if (!isAdded) {\r\n            switch (scope.type) {\r\n                case EScopeType.k_Global:\r\n                case EScopeType.k_Default:\r\n                    context.error(sourceNode, EErrors.VariableRedefinition, { varName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Struct:\r\n                    context.error(sourceNode, EErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Annotation:\r\n                    context.error(sourceNode, EErrors.InvalidNewAnnotationVar, { varName: varDecl.name });\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return varDecl;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AnnotationDecls\r\n     *       + AnnotationDecls \r\n     *       + VariableDecl \r\n     */\r\n    protected analyzeAnnotationDecls(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        let decls = [];\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'AnnotationDecls':\r\n                    decls.push(...this.analyzeAnnotationDecls(context, program, children[i]));\r\n                    break;\r\n                case 'VariableDecl':\r\n                    decls.push(...this.analyzeVariableDecl(context, program, children[i]));\r\n                    break;\r\n            }\r\n        }\r\n        return decls;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Annotation\r\n     *         T_PUNCTUATOR_62 = '>'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     */\r\n    protected analyzeAnnotation(context: Context, $program: ProgramScope, sourceNode: IParseNode): IAnnotationInstruction {\r\n        // IP: hucky way to not add annotation variables to real scope\r\n        const program = new ProgramScope(SystemScope.SCOPE); \r\n        const scope = program.currentScope;\r\n        program.push(EScopeType.k_Annotation);\r\n        const decls = [\r\n            ...sourceNode.children.filter(node => node.name == 'AnnotationDecls').map(node => this.analyzeAnnotationDecls(context, program, node)).flat(),\r\n            ...sourceNode.children.filter(node => node.name == 'VariableDecl').map(node => this.analyzeVariableDecl(context, program, node)).flat()\r\n        ];\r\n        program.pop();\r\n        if (!decls || !decls.length) return null;\r\n        return new AnnotationInstruction({ scope, sourceNode, decls });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_NON_TYPE_ID = 'SEMANTIC'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'u2'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_REGISTER = 'register'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    protected analyzeSemantic(sourceNode: IParseNode): string {\r\n        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Initializer\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *       + CastExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     */\r\n    protected analyzeInitializer(context: Context, program: ProgramScope, sourceNode: IParseNode, expectedType: ITypeInstruction, exprSourceNode: IParseNode = null): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        // IP: hacky varification to be sure that it's not a \r\n        if (children[children.length - 1]?.value == '=') {\r\n            console.assert(children[children.length - 1].name === 'T_PUNCTUATOR_61');\r\n            return this.analyzeInitExprChildren(context, program, sourceNode, children.slice(0, -1), expectedType, exprSourceNode);\r\n        }\r\n        console.assert(false, 'not valid branch');\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n\r\n        switch (name) {\r\n            case 'ObjectExpr':\r\n                return this.analyzeObjectExpr(context, program, sourceNode);\r\n            case 'ComplexExpr':\r\n                return this.analyzeComplexExpr(context, program, sourceNode);\r\n            case 'PostfixExpr':\r\n                return this.analyzePostfixExpr(context, program, sourceNode);\r\n            case 'UnaryExpr':\r\n                return this.analyzeUnaryExpr(context, program, sourceNode);\r\n            case 'CastExpr':\r\n                return this.analyzeCastExpr(context, program, sourceNode);\r\n            case 'ConditionalExpr':\r\n                return this.analyzeConditionalExpr(context, program, sourceNode);\r\n            case 'MulExpr':\r\n            case 'AddExpr':\r\n                return this.analyzeArithmeticExpr(context, program, sourceNode);\r\n            case 'RelationalExpr':\r\n            case 'EqualityExpr':\r\n                return this.analyzeRelationExpr(context, program, sourceNode);\r\n            case 'LogicalAndExpr':\r\n            case 'LogicalOrExpr':\r\n                return this.analyzeLogicalExpr(context, program, sourceNode);\r\n            case 'AssignmentExpr':\r\n                return this.analyzeAssignmentExpr(context, program, sourceNode);\r\n            case 'AndExpr':\r\n            case 'ShiftExpr':\r\n            case 'InclusiveOrExpr':\r\n            case 'ExclusiveOrExpr':\r\n                return this.analyzeBitwiseExpr(context, program, sourceNode);\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeIdExpr(context, program, sourceNode);\r\n            case 'T_STRING':\r\n            case 'T_UINT':\r\n            case 'T_FLOAT':\r\n            case 'T_KW_TRUE':\r\n            case 'T_KW_FALSE':\r\n                return this.analyzeSimpleExpr(context, program, sourceNode);\r\n            default:\r\n                context.error(sourceNode, EErrors.UnsupportedExpr, { exprName: name });\r\n                break;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'fs_skybox'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeObjectExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        let name = sourceNode.children[sourceNode.children.length - 1].name;\r\n\r\n        switch (name) {\r\n            /** @deprecated */\r\n            case 'T_KW_COMPILE':\r\n                return this.analyzeCompileExpr(context, program, sourceNode);\r\n            case 'T_KW_COMPILE_SHADER':\r\n                return this.analyzeCompileShader11(context, program, sourceNode);\r\n                return null;\r\n            default:\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ComplexExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'vs_4_0_level_9_1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_COMPILE_SHADER = 'CompileShader'\r\n     */\r\n    protected analyzeCompileShader11(context: Context, program: ProgramScope, sourceNode: IParseNode): ICompileShader11Instruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        // CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )\r\n        const shaderNode = children[1];     // RenderSceneVS( 1, true, true )\r\n        const versionNode = children[3];    // vs_4_0_level_9_1\r\n        const ver = versionNode.value;\r\n        const entryNode = shaderNode.children[shaderNode.children.length - 1]; // RenderSceneVS\r\n        const funcName = entryNode.value;\r\n        const args = [];\r\n        for (let i = shaderNode.children.length - 3; i > 0; i--) {\r\n            if (shaderNode.children[i].value !== ',') {\r\n                args.push(this.analyzeExpr(context, program, shaderNode.children[i]));\r\n            }\r\n        }\r\n    \r\n        //findFunction(funcName, args);\r\n        const func = program.globalScope.functions[funcName][0]; // todo: get suitable?\r\n        const shaderType = ver.substring(0, 2);\r\n        const sh = {\r\n            'vs': T_VERTEX_SHADER,\r\n            'ps': T_PIXEL_SHADER,\r\n            'gs': T_GEOMETRY_SHADER,\r\n            'cs': T_COMPUTE_SHADER\r\n        };\r\n\r\n        const type: ITypeInstruction = sh[shaderType];\r\n        assert(isDef(type), `unknown shader type '${shaderType} (${ver})' has been used`);\r\n        return new CompileShader11Instruction({ scope, sourceNode, ver, args, func, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'main'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeCompileExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, validators?: ICompileValidator[]): CompileExprInstruction {\r\n        const children = sourceNode.children;\r\n        const shaderFuncName = children[children.length - 2].value;\r\n        const scope = program.currentScope;\r\n\r\n        let compileArgs: IExprInstruction[] = null;\r\n        let retType: ITypeInstruction = null;\r\n        let args: (RegExp | ITypeInstruction)[] = null;\r\n\r\n        if (children.length > 4) {\r\n            compileArgs = [];\r\n            for (let i = children.length - 4; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    compileArgs.push(this.analyzeExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        args = compileArgs ? compileArgs.map(asType) : null;\r\n\r\n        let func: IFunctionDeclInstruction = null;\r\n\r\n        if (validators) {\r\n            for (let validator of validators) {\r\n                args = compileArgs ? compileArgs.map(asType) : null;\r\n                retType = null;\r\n\r\n                args = validator.args || args;\r\n                retType = validator.ret || retType;\r\n\r\n                func = program.globalScope.findFunction(shaderFuncName, args);\r\n                if (func) {\r\n                    // skip function if validator is not suitable\r\n                    if (validator.ret && !types.equals(validator.ret, func.def.returnType))\r\n                    {\r\n                        // skip this function\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            func = program.globalScope.findFunction(shaderFuncName, args);\r\n        }\r\n\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });\r\n            return null;\r\n        }\r\n\r\n        if (retType) {\r\n            // show error if we found some variant of function but return type mismath\r\n            if (!types.equals(func.def.returnType, retType)) {\r\n                context.error(sourceNode, EErrors.InvalidCompileFunctionNotValid, {\r\n                    funcName: shaderFuncName,\r\n                    funcType: retType.toCode(),\r\n                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `\r\n                });\r\n                return null;\r\n            }\r\n        }\r\n\r\n        let type = VariableTypeInstruction.wrap(<IVariableTypeInstruction>func.def.returnType, scope);\r\n\r\n        return new CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });\r\n    }\r\n\r\n\r\n    // /**\r\n    //  * AST example:\r\n    //  *    ObjectExpr\r\n    //  *       + StateBlock \r\n    //  *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n    //  */\r\n    // protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n    //     sourceNode = sourceNode.children[0];\r\n\r\n    //     let scope = program.currentScope;\r\n    //     let children = sourceNode.children;\r\n    //     let operator: SamplerOperator = \"sampler_state\";\r\n    //     let texture = null;\r\n    //     let params = <ISamplerStateInstruction[]>[];\r\n\r\n    //     for (let i = children.length - 2; i >= 1; i--) {\r\n    //         let param = this.analyzeSamplerState(context, program, children[i]);\r\n    //         if (!isNull(param)) {\r\n    //             params.push(param);\r\n    //         }\r\n    //     }\r\n\r\n    //     return new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });\r\n    // }\r\n\r\n\r\n    // /**\r\n    //  * AST example:\r\n    //  *    State\r\n    //  *         T_PUNCTUATOR_59 = ';'\r\n    //  *         StateExpr\r\n    //  *              T_PUNCTUATOR_62 = '>'\r\n    //  *              T_NON_TYPE_ID = 'tex0'\r\n    //  *              T_PUNCTUATOR_60 = '<'\r\n    //  *         T_PUNCTUATOR_61 = '='\r\n    //  *         T_NON_TYPE_ID = 'Texture'\r\n    //  */\r\n    // protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {\r\n\r\n    //     const children = sourceNode.children;\r\n    //     const scope = program.currentScope;\r\n\r\n    //     if (children[children.length - 2].name === 'StateIndex') {\r\n    //         context.error(sourceNode, EErrors.UnsupportedStateIndex);\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let stateExprNode = children[children.length - 3];\r\n    //     let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n    //     let stateType = children[children.length - 1].value.toUpperCase();\r\n    //     let stateValue = '';\r\n\r\n    //     if (isNull(subStateExprNode.value)) {\r\n    //         context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n    //         return null;\r\n    //     }\r\n\r\n    //     switch (stateType) {\r\n    //         case 'TEXTURE':\r\n    //             if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {\r\n    //                 context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n    //                 return null;\r\n    //             }\r\n\r\n    //             let texNameNode = stateExprNode.children[1];\r\n    //             let texName = texNameNode.value;\r\n    //             if (isNull(texName) || !scope.findVariable(texName)) {\r\n    //                 context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);\r\n    //                 return null;\r\n    //             }\r\n\r\n    //             let texDecl = scope.findVariable(texName);\r\n    //             let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });\r\n    //             let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });\r\n\r\n    //             return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });\r\n    //         case 'ADDRESSU': /* WRAP_S */\r\n    //         case 'ADDRESSV': /* WRAP_T */\r\n    //             stateValue = subStateExprNode.value.toUpperCase();\r\n    //             switch (stateValue) {\r\n    //                 case 'WRAP':\r\n    //                 case 'CLAMP':\r\n    //                 case 'MIRROR':\r\n    //                     break;\r\n    //                 default:\r\n    //                     // TODO: move to errors\r\n    //                     // console.warn('Webgl don`t support this wrapmode: ' + stateValue);\r\n    //                     return null;\r\n    //             }\r\n    //             break;\r\n\r\n    //         case 'MAGFILTER':\r\n    //         case 'MINFILTER':\r\n    //             stateValue = subStateExprNode.value.toUpperCase();\r\n    //             switch (stateValue) {\r\n    //                 case 'POINT':\r\n    //                     stateValue = 'NEAREST';\r\n    //                     break;\r\n    //                 case 'POINT_MIPMAP_POINT':\r\n    //                     stateValue = 'NEAREST_MIPMAP_NEAREST';\r\n    //                     break;\r\n    //                 case 'LINEAR_MIPMAP_POINT':\r\n    //                     stateValue = 'LINEAR_MIPMAP_NEAREST';\r\n    //                     break;\r\n    //                 case 'POINT_MIPMAP_LINEAR':\r\n    //                     stateValue = 'NEAREST_MIPMAP_LINEAR';\r\n    //                     break;\r\n\r\n    //                 case 'NEAREST':\r\n    //                 case 'LINEAR':\r\n    //                 case 'NEAREST_MIPMAP_NEAREST':\r\n    //                 case 'LINEAR_MIPMAP_NEAREST':\r\n    //                 case 'NEAREST_MIPMAP_LINEAR':\r\n    //                 case 'LINEAR_MIPMAP_LINEAR':\r\n    //                     break;\r\n    //                 default:\r\n    //                     // TODO: move to erros api\r\n    //                     // console.warn('Webgl don`t support this texture filter: ' + stateValue);\r\n    //                     return null;\r\n    //             }\r\n    //             break;\r\n\r\n    //         default:\r\n    //             // TODO: move to erros api\r\n    //             console.warn('Don`t support this texture param: ' + stateType);\r\n    //             return null;\r\n    //     }\r\n\r\n    //     return new SamplerStateInstruction({\r\n    //         sourceNode,\r\n    //         scope,\r\n    //         name: stateType,\r\n    //         value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })\r\n    //     });\r\n    // }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_FLOAT = '2.'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_FLOAT = '1.'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_TYPE_ID = 'float4'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + PostfixPointExpr \r\n     */\r\n    protected analyzeComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'PostfixPointExpr':\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeFunctionCallExpr(context, program, sourceNode);\r\n            case 'BaseType':\r\n            case 'T_TYPE_ID':\r\n                return this.analyzeConstructorCallExpr(context, program, sourceNode);\r\n            default:\r\n                return this.analyzeSimpleComplexExpr(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    protected analyzeCallee(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        return this.analyzeExpr(context, program, children[children.length - 1]);\r\n    }\r\n\r\n\r\n    protected createTracePseudoDeclaration(context: Context, program: ProgramScope, args: IExprInstruction[]): IFunctionDeclInstruction {\r\n        const scope = program.globalScope; // global scope (!)\r\n        const attrs = [new AttributeInstruction({ scope, name: \"extern\", args: null })];\r\n        const impl = null;\r\n        const returnType = VariableTypeInstruction.wrap(T_VOID, scope);\r\n        const id = new IdInstruction({ scope, name: \"trace\" });\r\n        const paramList = args.map((arg, i) => {\r\n            // todo: fully deduce base type \r\n            const type = VariableTypeInstruction.wrapAsConst(arg.type.baseType, scope);\r\n            const id = new IdInstruction({ scope, name: `p${i}` });\r\n            const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n            return new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n        });\r\n        const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n        const traceFunc = new FunctionDeclInstruction({ scope, def, impl, attrs });\r\n        scope.addFunction(traceFunc);\r\n        return traceFunc;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'a'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'foo'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PostfixPointExpr\r\n     *         T_NON_TYPE_ID = 'IncrementCounter'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *       + PostfixExpr \r\n     */\r\n    protected analyzeFunctionCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        let funcName: string = null;\r\n        let func: IFunctionDeclInstruction = null;\r\n        let callee: IExprInstruction = null;\r\n        let args: IExprInstruction[] = [];\r\n\r\n        switch (firstNodeName) {\r\n            // call as function\r\n            case 'T_NON_TYPE_ID':\r\n                {\r\n                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address\r\n                    funcName = children[children.length - 1].value;\r\n\r\n                    if (children.length > 3) {\r\n                        for (let i = children.length - 3; i > 0; i--) {\r\n                            if (children[i].value !== ',') {\r\n                                const arg = this.analyzeExpr(context, program, children[i]);\r\n                                args.push(arg);\r\n                            }\r\n                        }\r\n                    }            \r\n\r\n                    const noStrictTypeWereProvided = args.every(arg => arg?.type != asRelaxedType(arg));\r\n                    // don't relax all types because it's useless\r\n                    // like: (0, 0, 0) => (float|int, float|int)\r\n                    // relax only uint => int if not strict types were provided \r\n                    func = globalScope.findFunction(funcName, args.map(arg => arg?.type || null));\r\n                    // still not found?\r\n                    if (!func) {\r\n                        // last resort for cases like: \"sqrt(2)\"\r\n                        func = globalScope.findFunction(funcName, args.map(asRelaxedType));\r\n                    }\r\n\r\n                    // special case for debug \"void trace(...)\" function\r\n                    if (isNull(func) && funcName === 'trace') {\r\n                         func = this.createTracePseudoDeclaration(context, program, args);\r\n                    }\r\n                }\r\n                break;\r\n            // call as method\r\n            case 'PostfixPointExpr':\r\n                {\r\n                    callee = this.analyzeCallee(context, program, children[children.length - 1]);\r\n                    funcName = children[children.length - 1].children[0].value; // method name\r\n\r\n                    if (children.length > 3) {\r\n                        for (let i = children.length - 3; i > 0; i--) {\r\n                            if (children[i].value !== ',') {\r\n                                const arg = this.analyzeExpr(context, program, children[i]);\r\n                                args.push(arg);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotFunction, { funcName, args: args.map(arg => types.signature(arg?.type)) });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n        if (args.includes(null)) {\r\n            return null;\r\n        }\r\n\r\n        if (func.def.params.filter(p => !p.initExpr).length > args.length) {\r\n            context.error(sourceNode, EErrors.UnsupportedExpr, { funcName });\r\n            return null;\r\n        }\r\n\r\n        args.forEach((x, i) => {\r\n            const param = func.def.params[i];\r\n            const arg = args[i];\r\n            if (!types.equals(param.type, arg.type)) {\r\n                context.warn(arg.sourceNode, EWarnings.ImplicitTypeConversion, { info: `${arg.type.toCode()} => ${param.type.toCode()}` });\r\n            }\r\n        });\r\n\r\n        if (func.instructionType !== EInstructionTypes.k_FunctionDecl &&\r\n            func.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            console.error(\"@undefined_behavior\");\r\n            return null;\r\n        }\r\n\r\n\r\n\r\n        const params = func.def.params;\r\n\r\n        for (let i = 0; i < args.length; i++) {\r\n            if (isNull(args[i])) {\r\n                continue;\r\n            }\r\n            if (params[i].type.usages.includes('out')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                }\r\n            } else if (params[i].type.usages.includes('inout')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                }\r\n\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            } else {\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            const type = VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?\r\n            return new FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + BaseType \r\n     */\r\n    protected analyzeConstructorCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IConstructorCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const ctorType = this.analyzeType(context, program, children[children.length - 1]);\r\n\r\n        if (isNull(ctorType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotType);\r\n            return null;\r\n        }\r\n\r\n        let args: IExprInstruction[] = null;\r\n        if (children.length > 3) {\r\n            let argumentExpr: IExprInstruction = null;\r\n\r\n            args = [];\r\n\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: add correct implementation! \r\n        const exprType = findConstructor(ctorType, args);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(args)) {\r\n            for (let i = 0; i < args.length; i++) {\r\n                if (!args[i] || !args[i].type.readable) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });\r\n    }\r\n\r\n\r\n    // TODO: add comment!\r\n    protected analyzeSimpleComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[1]);\r\n        if (isNull(expr)) {\r\n            return null\r\n        }\r\n\r\n        return new ComplexExprInstruction({ scope, sourceNode, expr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const symbol = children[children.length - 2].value;\r\n\r\n        switch (symbol) {\r\n            case '[':\r\n                return this.analyzePostfixIndex(context, program, sourceNode);\r\n            case '.':\r\n                return this.analyzePostfixPoint(context, program, sourceNode);\r\n            case '++':\r\n            case '--':\r\n                return this.analyzePostfixArithmetic(context, program, sourceNode);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixIndex(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(postfixExpr)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        if (!postfixExprType.isArray()) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });\r\n            return null;\r\n        }\r\n\r\n        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const indexExprType = indexExpr.type;\r\n\r\n        if (!(types.equals(indexExprType, T_INT) || types.equals(indexExprType, T_UINT))) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     * @param fieldName \r\n     */\r\n    static createFieldDecl(elementType: IVariableTypeInstruction, fieldName: string): IVariableDeclInstruction {\r\n        if (!elementType.getField(fieldName)) {\r\n            return null;\r\n        }\r\n\r\n        const decl =\r\n            // FIXME: remove 'logical OR' operation, always use subType\r\n            (elementType.subType || elementType).getField(fieldName); // arrayIndex\r\n\r\n        const { type } = decl;\r\n\r\n        // in case of typical postfix exp. like \"element.postfix\":\r\n        //      elementType => type derived from the parameter or variable declaration or derived from another expr\r\n        //      elementType.subType => original complex (structure) type\r\n        // in case of something else, like ccall with postfix \"float2(1.0, 2.0).yx\":\r\n        //      elementType => original system type\r\n\r\n        const fieldType = new VariableTypeInstruction({ \r\n            scope: type.scope, \r\n            sourceNode: type.sourceNode, \r\n            type, \r\n            readable: elementType.readable, \r\n            writable: elementType.writable, \r\n            /*aligment,*/\r\n            padding: type.padding \r\n        });\r\n\r\n\r\n        const fieldId = new IdInstruction({ scope: decl.scope, name: decl.id.name, sourceNode: decl.id.sourceNode });\r\n\r\n        const field = new VariableDeclInstruction({ \r\n            semantic: decl.semantic,\r\n            scope: decl.scope, \r\n            type: fieldType, \r\n            sourceNode: decl.sourceNode, \r\n            id: fieldId,\r\n            usageFlags: decl.usageFlags\r\n        });\r\n\r\n        \r\n        return Instruction.$withParent(field, elementType);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     */\r\n    protected analyzePostfixPointField(context: Context, program: ProgramScope, sourceNode: IParseNode, elementType: IVariableTypeInstruction): IIdExprInstruction {\r\n        if (isNull(elementType)) {\r\n            return null;\r\n        }\r\n\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;                             // fiedl name\r\n        const decl = Analyzer.createFieldDecl(elementType, name);       // field decl\r\n        // const decl = elementType.getField(name);\r\n        \r\n        if (isNull(decl)) {\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    /** \r\n     * Expressions like: \r\n     *      **(element.postfix)** \r\n     */\r\n    protected analyzePostfixPoint(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const element = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(element)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);\r\n\r\n        if (isNull(postfix)) {\r\n            const fieldName = children[children.length - 3].value;\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixPointInstruction({ sourceNode, scope, element, postfix });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     */\r\n    protected analyzePostfixArithmetic(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <PostfixOperator>children[0].value;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[1]);\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixArithmetic, {\r\n                operator: operator,\r\n                typeName: String(postfixExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UnaryExpr\r\n     *         T_NON_TYPE_ID = 'x'\r\n     *         T_PUNCTUATOR_33 = '!'\r\n     */\r\n    protected analyzeUnaryExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const operator = <IUnaryOperator>children[1].value;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[0]);\r\n        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidUnaryOperation, {\r\n                operator: operator,\r\n                tyename: String(expr.type)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        let unaryExpr: IExprInstruction = null;\r\n\r\n        // shortcut for replacment of unary expressions with literals\r\n        if (operator === '-' || operator === '+') {\r\n            if (instruction.isLiteral(expr)) {\r\n                switch (expr.instructionType) {\r\n                    case EInstructionTypes.k_IntExpr:\r\n                        {\r\n                            let lit = <IntInstruction>expr;\r\n                            let { base, signed, heximal, exp } = lit;\r\n                            signed = operator === '-' || lit.signed;\r\n                            // TODO: emit warning in case of '-100u' expr.\r\n                            base = operator === '-' ? -base : base;\r\n                            unaryExpr = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n                        }\r\n                        break;\r\n                    case EInstructionTypes.k_FloatExpr:\r\n                        unaryExpr = new FloatInstruction({ scope, sourceNode, value: Number(`${operator}${(<ILiteralInstruction<number>>expr).value}`) });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!unaryExpr) {\r\n            unaryExpr = new UnaryExprInstruction({ scope, sourceNode, expr, operator });\r\n        }\r\n\r\n        return unaryExpr;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CastExpr\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ConstType \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeCastExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n\r\n        if (!SystemScope.isBase(type)) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeNotBase, { typeName: String(type) });\r\n        }\r\n\r\n        const sourceExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(sourceExpr)) {\r\n            return null;\r\n        }\r\n\r\n        if (!(<IVariableTypeInstruction>sourceExpr.type).readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        return new CastExprInstruction({ scope, sourceNode, sourceExpr, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConditionalExpr\r\n     *         T_KW_FALSE = 'false'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_63 = '?'\r\n     *         T_NON_TYPE_ID = 'isOk'\r\n     */\r\n    protected analyzeConditionalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n\r\n        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const rightExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(conditionExpr)) {\r\n            context.error(children[children.length - 1], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        if (isNull(leftExpr)) {\r\n            context.error(children[children.length - 3], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        if (isNull(rightExpr)) {\r\n            context.error(children[0], EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        const conditionType = <IVariableTypeInstruction>conditionExpr.type;\r\n        const leftExprType = <IVariableTypeInstruction>leftExpr.type;\r\n        const rightExprType = <IVariableTypeInstruction>rightExpr.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!types.equals(conditionType, boolType)) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidConditionType, { typeName: String(conditionType) });\r\n            return null;\r\n        }\r\n\r\n        if (!types.equals(leftExprType, rightExprType)) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidConditonValueTypes, {\r\n                leftTypeName: String(leftExprType),\r\n                rightTypeName: String(rightExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!conditionType.readable) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${conditionExpr.toCode()}` });\r\n        }\r\n\r\n        if (!leftExprType.readable) {\r\n            context.error(leftExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${leftExpr.toCode()}` });\r\n        }\r\n\r\n        if (!rightExprType.readable) {\r\n            context.error(rightExpr.sourceNode, EErrors.InvalidTypeForReading, { tooltip: `${rightExpr.toCode()}` });\r\n        }\r\n\r\n        return new ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AddExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_43 = '+'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeArithmeticExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope\r\n        const operator = <IArithmeticOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: '[unknown]',\r\n                rightTypeName: '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType,\r\n            rightType, left.sourceNode, right.sourceNode, sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    RelationalExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeRelationExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <RelationOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = left && left.type;\r\n        const rightType = right && right.type;\r\n\r\n        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left && left.sourceNode, right && right.sourceNode,\r\n            sourceNode);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidRelationalOperation, {\r\n                operator: operator,\r\n                leftTypeName: leftType ? types.signature(leftType) : '[unknown]',\r\n                rightTypeName: rightType ? types.signature(rightType) : '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        return new RelationalExprInstruction({ sourceNode, scope, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    LogicalOrExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_OP_OR = '||'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeLogicalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <ILogicalOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!types.equals(leftType, boolType)) {\r\n            context.error(leftType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(leftType)\r\n            });\r\n            return null;\r\n        }\r\n        if (!types.equals(rightType, boolType)) {\r\n            context.error(rightType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!leftType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        if (!rightType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n        return new LogicalExprInstruction({ scope, sourceNode, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InclusiveOrExpr\r\n     *       + ComplexExpr \r\n     *         T_PUNCTUATOR_124 = '|'\r\n     *       + ComplexExpr \r\n     */\r\n    protected analyzeBitwiseExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <IBitwiseOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left.sourceNode, right.sourceNode,\r\n            sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidBitwiseOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        return new BitwiseExprInstruction({ scope, sourceNode, left, right, type, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AssignmentExpr\r\n     *         T_UINT = '10'\r\n     *         T_OP_AE = '+='\r\n     *         T_NON_TYPE_ID = 'x'\r\n     */\r\n    protected analyzeAssignmentExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <AssigmentOperator>children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n\r\n        if (!expression.unwind(left)) {\r\n            // Invalid left-hand side in assignment\r\n            context.error(sourceNode, EErrors.InvalidLeftHandSideInAssignment, {\r\n                operator: operator\r\n            });\r\n        }\r\n\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(left) || isNull(right)) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        let exprType = <ITypeInstruction>null;\r\n\r\n        if (operator !== '=') {\r\n            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);\r\n            if (isNull(exprType)) {\r\n                context.error(sourceNode, EErrors.InvalidArithmeticAssigmentOperation, {\r\n                    operator: operator,\r\n                    leftTypeName: types.signature(leftType),\r\n                    rightTypeName: types.signature(rightType)\r\n                });\r\n            }\r\n        } else {\r\n            exprType = rightType;\r\n        }\r\n\r\n        // FIXME: show corrent source nodes for left and right expression.\r\n        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType, left.sourceNode, null, sourceNode);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidAssigmentOperation, {\r\n                leftTypeName: types.signature(leftType),\r\n                rightTypeName: types.signature(rightType)\r\n            });\r\n        }\r\n\r\n        return new AssignmentExprInstruction({ scope, sourceNode, left, right, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    T_NON_TYPE_ID = 'name'\r\n     */\r\n    protected analyzeIdExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;\r\n\r\n\r\n        // beginning-of-hack\r\n        // hack to support pseudo-dynamic expression\r\n        //\r\n\r\n        const exprSubst = context.expressions[name];\r\n        if (exprSubst)\r\n        {\r\n            return exprSubst(context, program, sourceNode);\r\n        }\r\n\r\n        // end-of-hack\r\n\r\n        // explicit support of built in HLSL 'NULL' define\r\n        if (name === 'NULL') {\r\n            // const { base, signed, heximal, exp } = parseUintLiteral('0');\r\n            // return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal }); \r\n            return new NullInstruction({ scope, sourceNode });\r\n        }\r\n\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        return new IdExprInstruction({ scope, sourceNode, id, decl });\r\n    }\r\n\r\n\r\n    protected analyzeSimpleExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n        const value = sourceNode.value;\r\n        const scope = program.currentScope;\r\n\r\n        switch (name) {\r\n            case 'T_UINT':\r\n                {\r\n                    const { base, signed, heximal, exp } = parseUintLiteral(value);\r\n\r\n                    return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n                }\r\n            case 'T_FLOAT':\r\n                return new FloatInstruction({ scope, sourceNode, value: Number(value) });\r\n            case 'T_STRING':\r\n                return new StringInstruction({ scope, sourceNode, value });\r\n            case 'T_KW_TRUE':\r\n                return new BoolInstruction({ scope, sourceNode, value: true });\r\n            case 'T_KW_FALSE':\r\n                return new BoolInstruction({ scope, sourceNode, value: false });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConstType\r\n     *       + Type \r\n     */\r\n    protected analyzeConstTypeDim(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length > 1) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeUsage);\r\n            return null;\r\n        }\r\n\r\n        const type = <IVariableTypeInstruction>(this.analyzeType(context, program, children[0]));\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVarStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n\r\n        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);\r\n        let vars: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    protected analyzeUsageStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'StructDecl') {\r\n                type = this.analyzeStructDecl(context, program, children[i]);\r\n                const typeDecl = new TypeDeclInstruction({ scope, sourceNode: children[i], type });\r\n                addTypeDecl(context, scope, typeDecl);\r\n            } else if (children[i].name === 'Usage') {\r\n                const usage = this.analyzeUsage(children[i]);\r\n                usages.push(usage);\r\n            }\r\n        }\r\n\r\n        assert(!isNull(type));\r\n        return new VariableTypeInstruction({ scope, sourceNode, usages, type });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     *    Struct\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStruct(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let name: string = null;\r\n        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {\r\n            name = children[children.length - 2].value;\r\n        }\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let aligment = 1;\r\n\r\n        if (context.cbuffer) {\r\n            aligment = T_FLOAT4.size;\r\n        }\r\n\r\n        return new ComplexTypeInstruction({ scope, sourceNode, fields, name, aligment });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + Annotation \r\n     *       + FunctionDef \r\n     */\r\n    protected analyzeFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        const lastNodeValue = children[0].value;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let impl: IStmtBlockInstruction = null;\r\n\r\n        program.push(EScopeType.k_Default);\r\n\r\n        const attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        const def = this.analyzeFunctionDef(context, program, children[children.length - 1 - attrs.length]);\r\n\r\n        if (isNull(def)) {\r\n            // TODO: emit proper error\r\n            context.error(sourceNode, EErrors.UnknownInstruction, {});\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)\r\n        let func = globalScope.findFunction(def.name, def.params.map(asType));\r\n\r\n        // undedined means that there are more than one instance \r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName: def.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        // todo: handle the case when definition without implementation is occured later than the found function with implementation\r\n        if (!isNull(func) && func.impl) {\r\n            context.error(sourceNode, EErrors.FunctionRedefinition, { funcName: def.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func)) {\r\n            if (!types.equals(func.def.returnType, def.returnType)) {\r\n                context.error(sourceNode, EErrors.InvalidFuncDefenitionReturnType, { funcName: def.name });\r\n                program.pop();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        assert(context.funcDef === null);\r\n\r\n        // TODO: rewrite context ?\r\n        context.funcDef = def;\r\n\r\n        if (children.length === 3) {\r\n            annotation = this.analyzeAnnotation(context, program, children[1]);\r\n        }\r\n\r\n        if (lastNodeValue !== ';') {\r\n            // TODO: do to increase scope depth inside stmt block!!\r\n            impl = this.analyzeStmtBlock(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let hasVoidType = types.equals(def.returnType, T_VOID);\r\n\r\n        // validate unreachable code.\r\n        if (!isNull(impl)) {\r\n            let stmtList = impl.stmtList;\r\n\r\n            // stmtList = stmtList.slice().reverse();\r\n            for (let i = stmtList.length - 1; i >= 0; --i) {\r\n                if (stmtList[i].instructionType == EInstructionTypes.k_ReturnStmt) {\r\n                    if (i != stmtList.length - 1) {\r\n                        context.error(stmtList[i + 1].sourceNode, EErrors.UnreachableCode);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        assert(scope == globalScope);\r\n        func = new FunctionDeclInstruction({ sourceNode, scope, def, impl, annotation, attrs: attrs });\r\n\r\n        // NOTE: possible implicit replacement of function \r\n        //       without implementaion inside addFunction() call.\r\n        if (!globalScope.addFunction(func)) {\r\n            context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: def.name });\r\n        }\r\n\r\n        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !isNull(impl)) {\r\n            context.error(sourceNode, EErrors.InvalidFunctionReturnStmtNotFound, { funcName: def.name });\r\n        }\r\n\r\n        return func;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDef\r\n     *       + ParamList \r\n     *         T_NON_TYPE_ID = 'bar'\r\n     *       + UsageType \r\n     */\r\n    protected analyzeFunctionDef(context: Context, program: ProgramScope, sourceNode: IParseNode): FunctionDefInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const nameNode = children[children.length - 2];\r\n        const name = nameNode.value;\r\n\r\n        const retTypeNode = children[children.length - 1];\r\n        let returnType = this.analyzeUsageType(context, program, retTypeNode);\r\n\r\n        // TODO: is it really needed?\r\n        if (!returnType) {\r\n            context.error(retTypeNode, EErrors.InvalidFunctionReturnType, { funcName: name });\r\n            return null;\r\n        }\r\n\r\n        let id = new IdInstruction({ scope, name, sourceNode: nameNode });\r\n\r\n        let semantic: string = null;\r\n        if (children.length === 4) {\r\n            semantic = this.analyzeSemantic(children[0]);\r\n        }\r\n\r\n        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);\r\n        return new FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamList\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeParamList(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n\r\n        const children = sourceNode.children;\r\n        let paramList: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'ParameterDecl') {\r\n                let param = this.analyzeParameterDecl(context, program, children[i]);\r\n                paramList.push(param);\r\n            }\r\n        }\r\n\r\n        return paramList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParameterDecl\r\n     *       + Variable \r\n     *       + ParamUsageType \r\n     */\r\n    protected analyzeParameterDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        const type = this.analyzeParamUsageType(context, program, children[1]);\r\n\r\n        if (isNull(type)) {\r\n            return null;\r\n        }\r\n\r\n        const param = this.analyzeVariable(context, program, children[0], type);\r\n\r\n        return param;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamUsageType\r\n     *       + Type \r\n     *       + ParamUsage \r\n     */\r\n    protected analyzeParamUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (children[i].name === 'ParamUsage') {\r\n                usages.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        return new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    StmtBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Stmt \r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStmtBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtBlockInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!children) {\r\n            return null;\r\n        }\r\n\r\n        let stmtList: IStmtInstruction[] = [];\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            let stmt = this.analyzeStmt(context, program, children[i]);\r\n            if (!isNull(stmt)) {\r\n                stmtList.push(stmt);\r\n            }\r\n        }\r\n\r\n        return new StmtBlockInstruction({ sourceNode, scope, stmtList });\r\n    }\r\n\r\n\r\n    protected analyzeStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        let nonAttrNode = children.length;\r\n        let nonAttrNodeName: string;\r\n\r\n        do {\r\n            nonAttrNodeName = children[--nonAttrNode].name;\r\n        } while (nonAttrNodeName === 'Attribute');\r\n\r\n        switch (nonAttrNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, children[0]);\r\n                return null;\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n            case 'T_KW_IF':\r\n                return this.analyzeIfStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeSimpleStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_RETURN':\r\n                return this.analyzeReturnStmt(context, program, sourceNode);\r\n\r\n            case 'T_KW_DO':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n\r\n            case 'StmtBlock':\r\n                {\r\n                    program.push(EScopeType.k_Default);\r\n                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);\r\n                    program.pop();\r\n                    return stmtBlock;\r\n                }\r\n            case 'T_KW_DISCARD':\r\n            case 'T_KW_BREAK':\r\n            case 'T_KW_CONTINUE':\r\n                return this.analyzeBreakStmt(context, program, sourceNode);\r\n\r\n            case 'TypeDecl':\r\n            case 'VariableDecl':\r\n            case 'VarStructDecl':\r\n                return this.analyzeDeclStmt(context, program, children[0]);\r\n\r\n            default:\r\n                if (children.length === 2) {\r\n                    return this.analyzeExprStmt(context, program, sourceNode);\r\n                }\r\n\r\n                return new SemicolonStmtInstruction({ sourceNode, scope });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_KW_RETURN = 'return'\r\n     */\r\n    protected analyzeReturnStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        assert(context.func);\r\n\r\n        const funcReturnType = context.funcDef.returnType;\r\n        context.haveCurrentFunctionReturnOccur = true;\r\n\r\n        if (children.length === 2) {\r\n            tryResolveProxyType(funcReturnType, T_VOID);\r\n        }\r\n\r\n        if (types.equals(funcReturnType, T_VOID) && children.length === 3) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtVoid);\r\n            return null;\r\n        }\r\n        else if (!types.equals(funcReturnType, T_VOID) && children.length === 2) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtEmpty);\r\n            return null;\r\n        }\r\n\r\n        let expr: IExprInstruction = null;\r\n        if (children.length === 3) {\r\n            expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n            if (isNull(expr)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n\r\n            tryResolveProxyType(funcReturnType, expr.type); // auto foo() { return typedExpr; }\r\n            tryResolveProxyType(expr.type, funcReturnType); // typedFunc foo() { return auto; }\r\n            \r\n            if (!types.equals(expr.type, funcReturnType)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return new ReturnStmtInstruction({ sourceNode, scope, expr });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_KW_BREAK = 'break'\r\n     */\r\n    protected analyzeBreakStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const operator: BreakOperator = <BreakOperator>children[1].value;\r\n\r\n        if (operator === 'discard' && !isNull(context.funcDef)) {\r\n            // context.currentFunction.vertex = (false);\r\n        }\r\n\r\n        return new BreakStmtInstruction({ sourceNode, scope, operator });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeDeclStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const nodeName = sourceNode.name;\r\n\r\n        let declList: IDeclInstruction[] = [];\r\n\r\n        switch (nodeName) {\r\n            case 'TypeDecl':\r\n                declList.push(this.analyzeTypeDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VariableDecl':\r\n                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VarStructDecl':\r\n                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));\r\n                break;\r\n        }\r\n\r\n        return new DeclStmtInstruction({ sourceNode, scope, declList });\r\n    }\r\n\r\n\r\n    protected analyzeExprStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const expr = this.analyzeExpr(context, program, children[1]);\r\n        return new ExprStmtInstruction({ sourceNode, scope, expr });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *       + Stmt \r\n     *         T_KW_DO = 'do'\r\n     */\r\n    protected analyzeWhileStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isDoWhile = (children[children.length - 1].value === 'do');\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;\r\n        const boolType = T_BOOL;\r\n\r\n\r\n        let cond: IExprInstruction = null;\r\n        let conditionType: IVariableTypeInstruction = null;\r\n        let body: IStmtInstruction = null;\r\n        let operator: IDoWhileOperator = \"do\";\r\n\r\n        if (isDoWhile) {\r\n            operator = \"do\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!types.equals(conditionType, boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            operator = \"while\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!types.equals(conditionType, boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            if (isNonIfStmt) {\r\n                body = this.analyzeNonIfStmt(context, program, children[0]);\r\n            }\r\n            else {\r\n                body = this.analyzeStmt(context, program, children[0]);\r\n            }\r\n        }\r\n\r\n        return new WhileStmtInstruction({ sourceNode, scope, cond, body, operator });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Attribute\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '3'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '2'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'loop'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     */\r\n    protected analyzeAttribute(context: Context, program: ProgramScope, sourceNode: IParseNode): IAttributeInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const name = children[children.length - 2].value;\r\n\r\n        let args: ILiteralInstruction<number | boolean>[] = null;\r\n\r\n        if (children.length > 3) {\r\n            let argumentExpr: ILiteralInstruction<boolean | number> = null;\r\n\r\n            args = [];\r\n            for (let i = children.length - 4; i > 1; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = <ILiteralInstruction<number | boolean>>this.analyzeSimpleExpr(context, program, children[i]);\r\n\r\n                    // TODO: emit diagnostics error\r\n                    assert(\r\n                        argumentExpr.instructionType === EInstructionTypes.k_BoolExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_FloatExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_IntExpr);\r\n\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new AttributeInstruction({ scope, sourceNode, name, args });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_KW_ELSE = 'else'\r\n     *       + NonIfStmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_IF = 'if'\r\n     *       + Attribute \r\n     *       + Attribute \r\n     */\r\n    protected analyzeIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n\r\n        let attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        const isIfElse = (children.length - attrs.length === 7);\r\n\r\n        const condNode = children[children.length - 3 - attrs.length];\r\n        const cond = this.analyzeExpr(context, program, condNode);\r\n\r\n        if (!cond || !types.equals(asRelaxedType(cond.type), T_BOOL)) {\r\n            context.error(condNode, EErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });\r\n        } else if (!types.equals(cond.type, T_BOOL)) {\r\n            context.warn(condNode, EWarnings.ImplicitTypeConversion, { tooltip: `${cond.type.name} => bool` });\r\n        }\r\n\r\n        let conseq: IStmtInstruction = null;\r\n        let contrary: IStmtInstruction = null;\r\n\r\n        if (isIfElse) {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[2]);\r\n            contrary = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n\r\n        if (!cond) {\r\n            return null;\r\n        }\r\n\r\n        return new IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attrs: attrs });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    NonIfStmt\r\n     *       + SimpleStmt \r\n     */\r\n    protected analyzeNonIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeForStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');\r\n\r\n        let body: IStmtInstruction = null;\r\n        let init: ITypedInstruction = null;\r\n        let cond: IExprInstruction = null;\r\n        let step: IExprInstruction = null;\r\n\r\n        let attrs = [];\r\n        while (children[children.length - 1 - attrs.length].name === 'Attribute') {\r\n            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));\r\n        }\r\n\r\n        if (children[1].name === 'ERROR') {\r\n            return null;\r\n        }\r\n\r\n        program.push();\r\n\r\n        const initSourceNode = children[children.length - 3 - attrs.length];\r\n        const condSourceNode = children[children.length - 4 - attrs.length];\r\n\r\n        init = this.analyzeForInit(context, program, initSourceNode);\r\n        cond = this.analyzeForCond(context, program, condSourceNode);\r\n        step = null;\r\n\r\n        const isEmptyInit = initSourceNode.children[0].name == 'T_PUNCTUATOR_59';\r\n        if (isNull(init) && !isEmptyInit) {\r\n            context.error(initSourceNode, EErrors.InvalidForInitEmptyIterator);\r\n        } else if (init.instructionType !== EInstructionTypes.k_VariableDecl) {\r\n            // EAnalyzerErrors.InvalidForInitExpr\r\n        }\r\n\r\n        if (isNull(cond)) {\r\n            context.error(condSourceNode, EErrors.InvalidForConditionEmpty);\r\n        } else if (cond.instructionType !== EInstructionTypes.k_RelationalExpr) {\r\n            // EAnalyzerErrors.InvalidForConditionRelation\r\n        }\r\n\r\n        if (children.length === 7 + attrs.length) {\r\n            step = this.analyzeForStep(context, program, children[2]);\r\n            if (isNull(step)) {\r\n                context.error(children[2], EErrors.InvalidForStepEmpty);\r\n            }\r\n        }\r\n\r\n        if (isNonIfStmt) {\r\n            body = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n\r\n        //     if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||\r\n        //         this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||\r\n        //         this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {\r\n\r\n        //         // todo: rewrite this check!!\r\n        //         // var sOperator: string = this._step.operator;\r\n        //         // if (sOperator !== \"++\" && sOperator !== \"--\" &&\r\n        //         //     sOperator !== \"+=\" && sOperator !== \"-=\") {\r\n        //         //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });\r\n        //         //     return false;\r\n        //         // }\r\n        //     }\r\n        //     else {\r\n        //         this._setError(EAnalyzerErrors.InvalidForStepExpr);\r\n        //         return false;\r\n        //     }\r\n\r\n        program.pop();\r\n\r\n        return new ForStmtInstruction({ sourceNode, scope, init, cond, step, body });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + AssignmentExpr \r\n     *    ForInit\r\n     *       + VariableDecl \r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Expr \r\n     */\r\n    protected analyzeForInit(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypedInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'VariableDecl':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeVariableDecl(context, program, children[0])[0] || null;\r\n            case 'Expr':\r\n            case 'AssignmentExpr':\r\n                return this.analyzeExpr(context, program, children[1]);\r\n        }\r\n\r\n        // ForInit : ';'\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForCond\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + RelationalExpr \r\n     */\r\n    protected analyzeForCond(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length === 1) {\r\n            return null;\r\n        }\r\n\r\n        return this.analyzeExpr(context, program, children[1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForStep\r\n     *       + UnaryExpr \r\n     */\r\n    protected analyzeForStep(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        if (children.length == 0) {\r\n            return null;\r\n        }\r\n        const step = this.analyzeExpr(context, program, children[0]);\r\n        return step;\r\n    }\r\n\r\n\r\n\r\n    protected analyzePresetProperty(context: Context, program: ProgramScope, sourceNode: IParseNode): IPresetPropertyInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const nameNode = children[children.length - 1];\r\n        const propName = nameNode.value;\r\n        const propExprNode = children[children.length - 3];\r\n        const exprNode = propExprNode.children[propExprNode.children.length - 1];\r\n        const scope = program.currentScope;\r\n\r\n        if (isNull(exprNode.value) || isNull(propName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return null;\r\n        }\r\n\r\n        const decl = scope.findVariable(propName);\r\n        if (isNull(decl)) {\r\n            context.warn(sourceNode, EWarnings.PartFx_PresetPropertyHasNotBeenFound);\r\n            return null;\r\n        }\r\n\r\n        const type = decl.type;\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n            const args: IExprInstruction[] =[];\r\n            if (exprNode.value === '{' && propExprNode.children.length > 3) {\r\n                for (let i = propExprNode.children.length - 2; i >= 1; i -= 2) {\r\n                    const expr = this.analyzeExpr(context, program, propExprNode.children[i]);\r\n                    // todo: use more strict check same as for InitExpr analyze\r\n                    if (!types.equals(expr.type, type.arrayElementType)) {\r\n                        context.warn(propExprNode.children[i], EWarnings.ImplicitTypeConversion, \r\n                            { tooltip: `${expr.type.name} => ${type.arrayElementType.name}` });\r\n                    }\r\n                    args.push(expr);\r\n                }\r\n            } else {\r\n                if (exprNode.value === '{') {\r\n                    args.push(this.analyzeExpr(context, program, propExprNode.children[1]));\r\n                } else {\r\n                    args.push(this.analyzeExpr(context, program, exprNode));\r\n                }\r\n            }\r\n            \r\n            const id = new IdInstruction({ name: propName, scope, sourceNode: nameNode });\r\n            return new PresetProperty({ scope, sourceNode, id, args });\r\n        }\r\n \r\n \r\n    protected analyzePresetStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IPresetPropertyInstruction[] {\r\n        const children = sourceNode.children;\r\n        let props = []\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            props.push(this.analyzePresetProperty(context, program, children[i]));\r\n        }\r\n        return props;\r\n    }\r\n\r\n    \r\n    /**\r\n     * AST example:\r\n     *    PresetDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'X'\r\n     *         T_KW_PRESET = 'preset'\r\n     */\r\n    protected analyzePresetDecl(context: Context, program: ProgramScope, sourceNode: IParseNode) {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        const props = this.analyzePresetStateBlock(context, program, children[0]);\r\n\r\n        const preset = new PresetInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n            props\r\n        });\r\n\r\n        return preset;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeTechnique11Decl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechnique11Instruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passes: IPass11Instruction[] = null;\r\n        let presets: IPresetInstruction[] = null;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                [ passes ] = this.analyzeTechnique11(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new Technique11Instruction({ sourceNode, name, semantic, annotation, passes, scope, presets });\r\n        Analyzer.addTechnique11(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    protected analyzeTechniqueDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechniqueInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        context.warn(sourceNode, EWarnings.Deprecated);\r\n\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passes: IPassInstruction[] = null;\r\n        let presets: IPresetInstruction[] = null;\r\n        let techniqueType: ETechniqueType = ETechniqueType.k_BasicFx;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(context, program, children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                [passes, presets] = this.analyzeTechnique(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passes, scope, presets });\r\n        Analyzer.addTechnique(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    TechniqueBody\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassDecl \r\n     *       + PassDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzeTechnique(context: Context, program: ProgramScope, sourceNode: IParseNode): [IPassInstruction[], IPresetInstruction[]] {\r\n        const children = sourceNode.children;\r\n        let passes: IPassInstruction[] = [];\r\n        let presets: IPresetInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            // IP: hack to support preset extension\r\n            if (children[i].children[0].name === 'PresetDecl') {\r\n                let preset = this.analyzePresetDecl(context, program, children[i].children[0]);\r\n                assert(!isNull(preset));\r\n                presets.push(preset);\r\n                continue;\r\n            }\r\n\r\n            let pass = this.analyzePassDecl(context, program, children[i]);\r\n            assert(!isNull(pass));\r\n            passes.push(pass);\r\n        }\r\n\r\n        return [ passes, presets ];\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Technique11Body\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Pass11Decl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // todo: add preset support (!)\r\n    // see analyzeTechnique() for example.\r\n    protected analyzeTechnique11(context: Context, program: ProgramScope, sourceNode: IParseNode): [IPass11Instruction[]] {\r\n        const children = sourceNode.children;\r\n        let passes: IPass11Instruction[] = [];\r\n        let iPass = 0;\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let pass = this.analyzePass11Decl(context, program, children[i], iPass);\r\n            assert(!isNull(pass));\r\n            passes.push(pass);\r\n        }\r\n\r\n        return [ passes ];\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *       + Annotation \r\n     *         T_NON_TYPE_ID = 'name'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            renderStates,\r\n            id,\r\n            pixelShader: entry.pixel,\r\n            vertexShader: entry.vertex\r\n        });\r\n        //TODO: add annotation and id\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Pass11Decl\r\n     *       + StmtBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePass11Decl(context: Context, program: ProgramScope, sourceNode: IParseNode, iPass: number = 0): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        \r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name, sourceNode: children[i] });\r\n            }\r\n        }\r\n\r\n        if (!id) {\r\n            // create fake pass name for better readability\r\n            id = new IdInstruction({ scope, name: `auto_pass_${iPass}` });\r\n        }\r\n        \r\n        const impl = this.analyzeStmtBlock(context, program, children[0]);\r\n        const returnType = VariableTypeInstruction.wrap(T_VOID, scope);\r\n        const def = new FunctionDefInstruction({ scope, id, returnType });\r\n        const pass11 = new FunctionDeclInstruction({ scope, sourceNode, impl, def });\r\n\r\n        //TODO: add annotation and id\r\n        return pass11;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'VertexShader'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassStateBlockForShaders(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode): { vertex: IFunctionDeclInstruction; pixel: IFunctionDeclInstruction; } {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        let pixel: IFunctionDeclInstruction = null;\r\n        let vertex: IFunctionDeclInstruction = null;\r\n\r\n        const supportedTypeNames = ['vertexshader', 'pixelshader'];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let func: IFunctionDeclInstruction = null;\r\n\r\n            const childrenIth = children[i].children;\r\n            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();\r\n\r\n            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);\r\n\r\n            if (!isNull(func)) {\r\n                switch (shaderTypeName) {\r\n                    case 'vertexshader':\r\n                        assert(vertex == null);\r\n                        vertex = func;\r\n                        break;\r\n                    case 'pixelshader':\r\n                        assert(pixel == null);\r\n                        pixel = func;\r\n                        break;\r\n                    default:\r\n                        // TODO: make error!\r\n                        console.error('function is not suitable as shader entry point');\r\n                }\r\n            }\r\n        }\r\n\r\n        return { vertex, pixel };\r\n    }\r\n\r\n\r\n    protected analyzePassStateForShader(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode, shaderType: string): IFunctionDeclInstruction {\r\n\r\n        assert(shaderType === 'vertexshader' || shaderType === 'pixelshader');\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        const compileExpr = <CompileExprInstruction>this.analyzeExpr(context, program, exprNode);\r\n\r\n        if (!compileExpr) {\r\n            return null;\r\n        }\r\n\r\n        const shaderFunc = compileExpr.function;\r\n\r\n        if (shaderType === 'vertexshader') {\r\n            if (!checkForVertexUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n        else {\r\n            if (!checkForPixelUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n\r\n        return shaderFunc;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + State \r\n     *       + State \r\n     *       + State \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    StateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + StateBlock \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + StateBlock \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode, type: ITypeInstruction): IStateBlockInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!type.isNotBaseArray()) {\r\n            let props: Object = {}\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                props = { ...props, ...this.analyzeState(context, program, children[i]) };\r\n            }\r\n            return new StateBlockInstruction({ scope, sourceNode, type, props });\r\n        } else {\r\n            let blocks = [];\r\n            for (let i = children.length - 2; i >= 1; i--) {\r\n                if (children[i].value === ',') continue;\r\n                blocks = [ ...blocks, this.analyzeStateBlock(context, program, children[i], (<IVariableTypeInstruction>type).subType) ];\r\n            }\r\n            return new StateBlockInstruction({ scope, sourceNode, type, blocks });\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    State\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzeState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<any> {\r\n        const children = sourceNode.children;\r\n        const stateName = children[children.length - 1].value;\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let states: IMap<any> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: any[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = stateExprNode.children[i].value;\r\n            }\r\n\r\n            // todo: convert values to native types\r\n            states[stateName] = values;\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value;\r\n            }\r\n            else {\r\n                value = exprNode.value;\r\n            }\r\n\r\n            // todo: convert value to native type\r\n            states[stateName] = value;\r\n        }\r\n        return states;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassStateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassState \r\n     *       + PassState \r\n     *       + PassState \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    /** @deprecated */\r\n    protected analyzePassStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n        const children = sourceNode.children;\r\n        let states: IMap<ERenderStateValues> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePassState(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzePassState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateType = children[children.length - 1].value.toUpperCase();\r\n        const stateName = ERenderStates[stateType];\r\n\r\n        if (!isNumber(stateName)) {\r\n            return {};\r\n        }\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let renderStates: IMap<ERenderStateValues> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: ERenderStateValues[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ERenderStates.BLENDFUNC:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDFUNCSEPARATE:\r\n                    if (values.length !== 4) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[2];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[3];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDEQUATIONSEPARATE:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.BLENDEQUATIONCOLOR] = values[0];\r\n                    renderStates[ERenderStates.BLENDEQUATIONALPHA] = values[1];\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Pass state is incorrect.');\r\n                    return {};\r\n            }\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            const stateValue = getRenderStateValue(stateName, value);\r\n\r\n            if (stateValue !== ERenderStateValues.UNDEF) {\r\n                switch (stateName) {\r\n                    case ERenderStates.SRCBLEND:\r\n                        renderStates[ERenderStates.SRCBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.SRCBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.DESTBLEND:\r\n                        renderStates[ERenderStates.DESTBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.DESTBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.BLENDEQUATION:\r\n                        renderStates[ERenderStates.BLENDEQUATIONCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.BLENDEQUATIONALPHA] = stateValue;\r\n                        break;\r\n                    default:\r\n                        renderStates[stateName] = stateValue;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return renderStates;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ImportDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_IMPORT = 'import'\r\n     */\r\n    // TODO: restore functionality! \r\n    protected analyzeImportDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): null {\r\n        const children = sourceNode.children;\r\n        const componentName = this.analyzeComplexName(children[children.length - 2]);\r\n\r\n        // if (!isNull(technique)) {\r\n        //     //We can import techniques from the same file, but on this stage they don`t have component yet.\r\n        //     //So we need special mehanism to add them on more belated stage\r\n        //     // let sShortedComponentName: string = componentName;\r\n        //     if (!isNull(context.moduleName)) {\r\n        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + \".\", \"\");\r\n        //     }\r\n\r\n        //     throw null;\r\n        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];\r\n        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {\r\n        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);\r\n        //     //     return;\r\n        //     // }\r\n        // }\r\n\r\n        const sourceTechnique: ITechniqueInstruction = null;//fx.techniques[componentName];\r\n        if (!sourceTechnique) {\r\n            context.error(sourceNode, EErrors.ImportedComponentNotExists, { componentName: componentName });\r\n            return null;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const name = children[children.length - 2].value;\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        return new ComplexTypeInstruction({ scope, sourceNode, name, fields });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + VariableDim \r\n     *       + ConstType \r\n     *         T_KW_TYPEDEF = 'typedef'\r\n     */\r\n    protected analyzeTypedefDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        // TODO: rework to support complex typ defenitions like \r\n        //  typedef const float4 TYPE_T;\r\n        //          ^^^^^^\r\n        // IP: at the moment type defenitions are not supported\r\n\r\n        const vdimNode = children[1];\r\n        const alias = vdimNode.children[0].value;\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n        // this.analyzeConstTypeDim() <= doesn't support 'const float' like expressions with modifiers\r\n\r\n        // const type = new TypeAlias()\r\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n        // add support for typealiases\r\n\r\n        const typedef = new TypedefInstruction({ scope, sourceNode, type, alias });\r\n        addTypeAlias(context, scope, typedef);\r\n        \r\n        return typedef;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StructDecl \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + VariableDim \r\n     *       + ConstType \r\n     *         T_KW_TYPEDEF = 'typedef'\r\n     */\r\n    protected analyzeTypeDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        if (children.length === 2) {\r\n            type = this.analyzeStructDecl(context, program, children[1]);\r\n        }\r\n        else if (children.length === 4) {\r\n           return this.analyzeTypedefDecl(context, program, sourceNode);\r\n        }\r\n        else {\r\n            context.error(sourceNode, EErrors.UnsupportedTypeDecl);\r\n        }\r\n\r\n\r\n        const typeDecl = new TypeDeclInstruction({ scope, sourceNode, type });\r\n        addTypeDecl(context, scope, typeDecl);\r\n        return typeDecl;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'TechniqueDecl':\r\n                return [this.analyzeTechniqueDecl(context, program, sourceNode)];\r\n            case 'Technique11Decl':\r\n                return [this.analyzeTechnique11Decl(context, program, sourceNode)];\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!\r\n                return null;\r\n            case 'ImportDecl':\r\n                return [this.analyzeImportDecl(context, program, sourceNode)];\r\n            case 'ProvideDecl':\r\n                return [this.analyzeProvideDecl(context, program, sourceNode)];\r\n            case 'TypeDecl':\r\n                return [this.analyzeTypeDecl(context, program, sourceNode)];\r\n            case 'VariableDecl':\r\n                return this.analyzeVariableDecl(context, program, sourceNode);\r\n            case 'VarStructDecl':\r\n                return this.analyzeVarStructDecl(context, program, sourceNode);\r\n            case 'FunctionDecl':\r\n                assert(program.currentScope == program.globalScope);\r\n                let fdecl = null;\r\n                context.beginFunc();\r\n                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);\r\n                context.endFunc();\r\n                return [fdecl];\r\n            case 'CbufferDecl':\r\n                return [this.analyzeCbufferDecl(context, program, sourceNode)];\r\n            case 'SamplerStateDecl':\r\n                return [this.analyzeSamplerStateDecl(context, program, sourceNode)];\r\n            case 'T_PUNCTUATOR_59':\r\n                context.warn(sourceNode, EWarnings.EmptySemicolon);\r\n                return null;\r\n            default:\r\n                context.error(sourceNode, EErrors.UnknownInstruction, { name });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeGlobals(context: Context, program: ProgramScope, slastDocument: ISLASTDocument): IInstruction[] {\r\n        if (isNull(slastDocument) || isNull(slastDocument.root)) {\r\n            return null;\r\n        }\r\n\r\n        const children = slastDocument.root.children;\r\n        let globals: IInstruction[] = [];\r\n\r\n        if (isNull(children)) {\r\n            return [];\r\n        }\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));\r\n        }\r\n\r\n        return globals.filter(decl => !!decl);\r\n    }\r\n\r\n\r\n    protected createContext(uri: IFile, expressions?: IMap<IExprSubstCallback>): Context {\r\n        return new Context(uri, expressions);\r\n    }\r\n\r\n    // create new scope\r\n    protected createProgram(document: ISLDocument = null): ProgramScope {\r\n        let parent = <IScope>SystemScope.SCOPE;\r\n        if (!isNull(document)) {\r\n            parent = document.root.scope;\r\n        }\r\n        return new ProgramScope(parent);\r\n    }\r\n\r\n    // extends existing scoope\r\n    protected createProgramEx(document: ISLDocument = null): ProgramScope {\r\n        if (isNull(document)) {\r\n            return this.createProgram();\r\n        }\r\n        return new ProgramScopeEx(document.root.scope);\r\n    }\r\n\r\n    /**\r\n     * Post-analysis validation.\r\n     */\r\n    protected validate(context: Context, program: ProgramScope, root: IInstructionCollector) {\r\n        checkFunctionsForRecursion(context, program);\r\n        program.validate();\r\n    }\r\n\r\n    /**\r\n     * Create a new standalone document.\r\n     * @param slastDocument \r\n     * @param document Context source. The scope of the parent document will be used when creating a new one.\r\n     * @returns \r\n     */\r\n    parse(slastDocument: ISLASTDocument, document?: ISLDocument): ISLDocument {\r\n        const uri = slastDocument.uri;\r\n        const program = this.createProgram(document);\r\n        const context = this.createContext(uri);\r\n\r\n        let instructions: IInstruction[] = null;\r\n        try {\r\n            instructions = this.analyzeGlobals(context, program, slastDocument);\r\n        } catch (e) {\r\n            // critical errors were occured\r\n            // throw e;\r\n            console.error(e);\r\n        }\r\n\r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n\r\n        const diagnosticReport = Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n    /**\r\n     * Extend existing document. (Base document stay unchanged (!))\r\n     * @param slastAddition Extension. (Can be null if just copy of base document is needed.)\r\n     * @param slBase Original document to be extneded.\r\n     * @param options \r\n     * @returns \r\n     * \r\n     * The idea is to create new documents which references to existings scope and extends \r\n     * existings instruction list, but leave parent document unchanged. \r\n     */\r\n    extend(\r\n        slastAddition: ISLASTDocument, \r\n        slBase: ISLDocument,\r\n        expressions?: IMap<IExprSubstCallback>\r\n        ): ISLDocument {\r\n        let uri = slBase.uri;\r\n\r\n        // new program (scope chain) holds links to known variales, types etc of parent document\r\n        let program = this.createProgramEx(slBase);\r\n        // context is absolutely new (!)\r\n        let context = this.createContext(uri, expressions);\r\n        let instructions = slBase.root.instructions;\r\n        let diagnosticReport = slBase.diagnosticReport;\r\n\r\n        if (slastAddition)\r\n        {\r\n            uri = slastAddition.uri;\r\n            try {\r\n                // new list holds links to existings instructions (!)\r\n                instructions = instructions.concat(this.analyzeGlobals(context, program, slastAddition));\r\n            } catch (e) {\r\n                // critical errors were occured\r\n                // throw e;\r\n                console.error(e);\r\n            }\r\n\r\n            diagnosticReport = Diagnostics.mergeReports([diagnosticReport, slastAddition.diagnosticReport, context.diagnostics.resolve()]);\r\n        }\r\n        \r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n\r\n    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {\r\n    //     if (isSystemFunction(func)) {\r\n    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });\r\n    //     }\r\n\r\n    //     let isFunctionAdded: boolean = program.addFunction(func);\r\n\r\n    //     if (!isFunctionAdded) {\r\n    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });\r\n    //     }\r\n    // }\r\n\r\n\r\n    protected static addTechnique11(context: Context, program: ProgramScope, technique: ITechnique11Instruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique11(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique11(technique);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    protected static addTechnique(context: Context, program: ProgramScope, technique: ITechniqueInstruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique(technique);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * Check the possibility of using the operator between the two types.\r\n    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =\r\n     * @leftType {ITypeInstruction} Type of the left side of the expression.\r\n     * @rightType {ITypeInstruction} Type of the right side of the expression.\r\n     */\r\n    static checkTwoOperandExprTypes(\r\n        context: Context,\r\n        operator: string,\r\n        leftType: ITypeInstruction,\r\n        rightType: ITypeInstruction,\r\n        leftSourceNode: IParseNode = null,\r\n        rightSourceNode: IParseNode = null,\r\n        exprSourceNode: IParseNode = null, \r\n        { isInitializing = false } = {}): ITypeInstruction {\r\n\r\n        if (!leftType || !rightType) {\r\n            return null;\r\n        }\r\n\r\n        leftSourceNode = leftSourceNode || leftType.sourceNode;\r\n        rightSourceNode = rightSourceNode || rightType.sourceNode;\r\n\r\n        const isComplex = leftType.isComplex() || rightType.isComplex();\r\n        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();\r\n        // const isSampler = isSamplerType(leftType) || isSamplerType(rightType);\r\n\r\n        \r\n        const constBoolType = (len: number) => {\r\n            if (len >= 1 && len <= 4) {\r\n                let ba = [ T_BOOL, T_BOOL2, T_BOOL3, T_BOOL4 ];\r\n                return VariableTypeInstruction.wrapAsConst(ba[len - 1], SystemScope.SCOPE);\r\n            }\r\n            console.error('unsupported code branch');\r\n            return null;\r\n        }\r\n\r\n        if (isArray/* || isSampler*/) {\r\n            // TODO: allow expressions like: arr1 = arr2; ??\r\n            return null;\r\n        }\r\n\r\n        if (Analyzer.isAssignmentOperator(operator)) {\r\n            if (!leftType.writable && !isInitializing) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForWriting);\r\n            }\r\n\r\n            if (!rightType.readable) {                \r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n\r\n            if (operator !== '=' && !leftType.readable) {\r\n                // temp solution for cases like:\r\n                // void f(out int x) \r\n                // {\r\n                //      x = 10;\r\n                //      x |= 1; // << allow to write here\r\n                // }\r\n                context.error(exprSourceNode, EErrors.InvalidTypeForReading, { tooltip: `lvalue is not readable` });\r\n            }\r\n        }\r\n        else {\r\n            if (!leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n        }\r\n\r\n        if (isComplex) {\r\n            if (operator === '=' && types.equals(leftType, rightType)) {\r\n                return <IVariableTypeInstruction>leftType;\r\n            }\r\n            // samplers and arrays can't be compared directly\r\n            else if (Analyzer.isEqualityOperator(operator) && !leftType.isComplex()) {\r\n                return constBoolType(1);\r\n            }\r\n\r\n            // TODO: emit error (unsupported operation on complex values)\r\n            return null;\r\n        }\r\n\r\n        // FIXME: use operands' scope instead of system scope?\r\n        let leftBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>leftType.baseType, SystemScope.SCOPE);\r\n        let rightBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>rightType.baseType, SystemScope.SCOPE);\r\n\r\n\r\n        if (Analyzer.isBitwiseOperator(operator)) {\r\n            if (!SystemScope.isIntBasedType(leftType) && \r\n                !SystemScope.isUintBasedType(leftType)) {\r\n                if (!SystemScope.isBoolBasedType(leftType)) {\r\n                    // todo: use correct error\r\n                    context.error(leftSourceNode, EErrors.InvalidCastUnknownType, { tooltip: `${leftType.name} => int` });\r\n                } else {\r\n                    context.warn(leftSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });\r\n                }\r\n                leftBaseType = VariableTypeInstruction.wrap(T_INT, SystemScope.SCOPE);\r\n            }\r\n\r\n            if (!SystemScope.isIntBasedType(rightType) && \r\n                !SystemScope.isUintBasedType(rightType)) {\r\n                if (!SystemScope.isBoolBasedType(rightType)) {\r\n                    // todo: use correct error\r\n                    context.error(rightSourceNode, EErrors.InvalidCastUnknownType, { tooltip: `${rightType.name} => int` });\r\n                } else {\r\n                    context.warn(rightSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });\r\n                }\r\n                rightBaseType = VariableTypeInstruction.wrap(T_INT, SystemScope.SCOPE);\r\n            }\r\n\r\n            switch (operator) {\r\n                case '&':\r\n                case '|':\r\n                case '^':\r\n                    if (!types.equals(leftBaseType, rightType)) {\r\n                        // TODO: emit warning (bitwise between int and uint)\r\n                    }\r\n            }\r\n\r\n            return leftBaseType;\r\n        }\r\n\r\n        // hack to allow int/uint comparisson\r\n        if (types.equals(leftType, asRelaxedType(rightType))) {\r\n            if (!types.equals(leftType, rightType)) {\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, { tooltip: `${leftType.name} [${operator}] ${rightType.name}` });\r\n            }\r\n\r\n            if (Analyzer.isArithmeticalOperator(operator)) {\r\n                if (!SystemScope.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {\r\n                    return leftBaseType;\r\n                }\r\n\r\n                // TODO: emit error (cannot perfome devision with matrices)\r\n                return null;\r\n            }\r\n            else if (Analyzer.isRelationalOperator(operator)) {\r\n                if (SystemScope.isScalarType(leftType) || SystemScope.isVectorType(leftType)) {\r\n                    return constBoolType(leftType.length);\r\n                }\r\n\r\n                // TODO: allow vectors? for ex: vec3 < vec3 => bool3\r\n                // TODO: emit error (cannot perfome comparison with non-scalar)\r\n                return null;\r\n            }\r\n            else if (Analyzer.isEqualityOperator(operator)) {\r\n                return constBoolType(leftType.length);\r\n            }\r\n            else if (operator === '=') {\r\n                return leftBaseType;\r\n            }\r\n\r\n            // TODO: emit error (unknonw operation)\r\n            return null;\r\n        }\r\n\r\n        // op: \"+\", \"-\", \"*\", \"/\"\r\n        //     \"+=\", \"-=\", \"*=\", \"/=\", \"%=\"\r\n        if (Analyzer.isArithmeticalOperator(operator)) {\r\n\r\n            // op: \"+\", \"-\", \"*\", \"/\", \"%\"\r\n\r\n            const length =\r\n                SystemScope.isScalarType(leftType) \r\n                    ? rightType.length \r\n                    : SystemScope.isScalarType(rightType) \r\n                        ? leftType.length \r\n                        : Math.min(leftType.length, rightType.length);\r\n\r\n            const baseType = SystemScope.determMostPreciseBaseType(leftType, rightType);\r\n            const resultType = SystemScope.findType(`${baseType.name}${length === 1 ? '' : length}`);\r\n\r\n            if (!resultType) {\r\n                assert(false, `cannot determ result type for \"${leftType.toCode()} ${operator} ${rightType.toCode()}\"`);\r\n                return null;\r\n            }\r\n\r\n\r\n            // op: \"+=\", \"-=\", \"*=\", \"/=\", \"%=\"\r\n            if (Analyzer.isAssignmentOperator(operator)) {\r\n                if (!types.equals(leftType, resultType)) {\r\n                    // TODO: add support for imlicit conversions\r\n                    // TODO: emit error (operator cannot be used with a given lvalue)\r\n                    context.error(exprSourceNode, EErrors.OperatorCannotBeUsedWithGivenLValue, {});\r\n                    return null;\r\n                }\r\n            }\r\n\r\n\r\n            if (resultType.length < leftType.length || resultType.length < rightType.length) {\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeTruncation, {\r\n                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`\r\n                });\r\n            }\r\n\r\n            if (!types.equals(SystemScope.determBaseType(leftType), SystemScope.determBaseType(rightType))) {\r\n                // do not emit errors for expr like: float2 * float, int2 + int etc..\r\n                context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`\r\n                });\r\n            }\r\n\r\n            /**\r\n             * Special case for matrices\r\n             */\r\n            if (operator === '*' || operator === '*=') {\r\n                if (SystemScope.isMatrixType(leftType) && SystemScope.isVectorType(rightType)) {\r\n                    if (leftType.length === rightType.length) {\r\n                        return rightBaseType;\r\n                    }\r\n                    return null;\r\n                }\r\n                else if (SystemScope.isMatrixType(rightType) && SystemScope.isVectorType(leftType)) {\r\n                    if (leftType.length === rightType.length) {\r\n                        return leftBaseType;\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return <IVariableTypeInstruction>resultType;\r\n        }\r\n\r\n        if (operator === '=') {\r\n            if (SystemScope.isScalarType(rightType)) {\r\n                if (SystemScope.determTypePrecision(leftType) > SystemScope.determTypePrecision(rightType)) {\r\n                    context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`\r\n                    });\r\n                    return leftType;\r\n                }\r\n\r\n                if (SystemScope.isIntegerType(leftType) && SystemScope.isIntegerType(rightType)) {\r\n                    context.warn(exprSourceNode, EWarnings.ImplicitTypeConversion, {\r\n                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`\r\n                    });\r\n                    return leftType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check the ability to use the operator to the data type.\r\n     * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - ! ++ --\r\n     * @leftType {IVariableTypeInstruction} Operand type\r\n     */\r\n    protected static checkOneOperandExprType(context: Context, sourceNode: IParseNode, operator: string,\r\n        type: IVariableTypeInstruction): IVariableTypeInstruction {\r\n\r\n        const isComplex = type.isComplex();\r\n        const isArray = type.isNotBaseArray();\r\n        // const isSampler = isSamplerType(type);\r\n\r\n        if (isComplex || isArray/* || isSampler*/) {\r\n            return null;\r\n        }\r\n\r\n        if (!type.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n        }\r\n\r\n\r\n        if (operator === '++' || operator === '--') {\r\n            if (!type.writable) {\r\n                context.error(sourceNode, EErrors.InvalidTypeForWriting);\r\n            }\r\n\r\n            return type;\r\n        }\r\n\r\n        if (operator === '!') {\r\n            const boolType = <IVariableTypeInstruction>T_BOOL;\r\n            // validate(boolType, EInstructionTypes.k_VariableDecl);\r\n\r\n            if (types.equals(type, boolType)) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (SystemScope.isBoolBasedType(type)) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (<SystemTypeInstruction>type.baseType) as any; // << TODO: fixme!!!! remove \"any\"!\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected static isAssignmentOperator(operator: string): boolean {\r\n        return operator === '+=' || operator === '-=' ||\r\n            operator === '*=' || operator === '/=' ||\r\n            operator === '%=' || operator === '=' || \r\n            operator === '|=' || operator === '&=' || \r\n            operator === '>>=' || operator === '<<=' || operator === '^=';\r\n    }\r\n\r\n    protected static isBitwiseOperator(operator: string): boolean {\r\n        return operator === '>>' || operator === '<<' ||\r\n            operator === '|' || operator === '&' || operator === '^' || \r\n            operator === '|=' || operator === '&=' ||\r\n            operator === '>>=' || operator === '<<=' || operator === '^=';\r\n    }\r\n\r\n    protected static isArithmeticalOperator(operator: string): boolean {\r\n        return operator === '+' || operator === '+=' ||\r\n            operator === '-' || operator === '-=' ||\r\n            operator === '*' || operator === '*=' ||\r\n            operator === '/' || operator === '/=' ||\r\n            operator === '%' || operator === '%=';\r\n    }\r\n\r\n\r\n    protected static isRelationalOperator(operator: string): boolean {\r\n        return operator === '>' || operator === '>=' ||\r\n            operator === '<' || operator === '<=';\r\n    }\r\n\r\n\r\n    protected static isEqualityOperator(operator: string): boolean {\r\n        return operator === '==' || operator === '!=';\r\n    }\r\n}\r\n\r\n\r\n","import { assert, isBoolean, isNull, isNumber, PropertiesDiff } from \"@lib/common\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EInstructionTypes, IAnnotationInstruction, ICompileExprInstruction, IDeclInstruction, IExprInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IInstruction, IInstructionCollector, IPassInstruction, IStmtInstruction, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IFile, IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { EPassDrawMode, IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { Analyzer, Context, ICompileValidator } from \"./Analyzer\";\r\nimport { IdInstruction } from \"./instructions/IdInstruction\";\r\nimport { DrawInstruction } from \"./instructions/part/DrawInstruction\";\r\nimport { PartFxInstruction } from \"./instructions/part/PartFxInstruction\";\r\nimport { PartFxPassInstruction } from \"./instructions/part/PartFxPassInstruction\";\r\nimport { SpawnInstruction } from \"./instructions/part/SpawnInstruction\";\r\nimport { ProgramScope } from \"./ProgramScope\";\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_VOID } from \"./SystemScope\";\r\n\r\ntype IPartFxPassProperties = PropertiesDiff<IPartFxPassInstruction, IPassInstruction>;\r\n// type is internal property which is always ETechniqueType.k_PartFx for particle fx's,\r\n// so we can omit it.\r\ntype IPartFxProperties = Omit<PropertiesDiff<IPartFxInstruction, IDeclInstruction>, \"type\">;\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\nexport class FxContext extends Context {\r\n    /** Main particle structure type describing particle's simulation. */\r\n    particleCore: ITypeInstruction;\r\n    /** Particle instance structure type which describe per pass render instance of the particle. */\r\n    particleInstance: ITypeInstruction;\r\n\r\n    spawnStmts: SpawnInstruction[] = [];\r\n    drawStmts: { instr: DrawInstruction, ctx: IFunctionDefInstruction }[] = [];\r\n\r\n    // beginFunc(): void {\r\n    //     super.beginFunc();\r\n    // }\r\n\r\n    // endFunc(): void {\r\n    //     super.endFunc();\r\n    // }\r\n\r\n    beginPartFxPass(): void {\r\n        this.beginPass();\r\n        this.particleInstance = null;\r\n    }\r\n\r\n\r\n    endPartFxPass(): void {\r\n        this.particleInstance = null;\r\n        this.endPass();\r\n    }\r\n\r\n\r\n    beginPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n\r\n\r\n    endPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n}\r\n\r\n\r\nfunction sliceNode(source: IParseNode, from: number, to?: number): IParseNode {\r\n    const { children, parent, name, value, loc } = source;\r\n    return {\r\n        children: children.slice(from, to),\r\n        parent,\r\n        name,\r\n        value,\r\n        loc\r\n    };\r\n}\r\n\r\n\r\nexport class FxAnalyzer extends Analyzer {\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'Init'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_SPAWN = 'spawn'\r\n     */\r\n    protected analyzeSpawnStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const name = children.slice(-5, -4)[0].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 7; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        // const { base, signed, heximal, exp } = parseUintLiteral(children.slice(-3, -2)[0].value);\r\n        // const count = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });\r\n\r\n        const count = this.analyzeExpr(context, program, children.slice(-3, -2)[0]);\r\n        \r\n        // find function name(args)\r\n\r\n        const spawnStmt = new SpawnInstruction({ sourceNode, scope, name, args, count });\r\n        context.spawnStmts.push(spawnStmt);\r\n\r\n        return spawnStmt;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'part'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_DRAW = 'draw'\r\n     */\r\n     protected analyzeDrawStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const name = children[children.length - 2].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 4; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        const instr = new DrawInstruction({ sourceNode, scope, name, args });\r\n        const ctx = context.funcDef;\r\n        context.drawStmts.push({ instr, ctx });\r\n        \r\n        return instr;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeSimpleStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_SPAWN':\r\n                return this.analyzeSpawnStmt(context, program, sourceNode);\r\n            case 'T_KW_DRAW':\r\n                return this.analyzeDrawStmt(context, program, sourceNode);\r\n            default:\r\n                return super.analyzeSimpleStmt(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePartFXPassDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxPassInstruction {\r\n\r\n        context.beginPartFxPass();\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        // temp solution in order to not highlight useless pass states in the next analysis call.\r\n        context.renderStates = renderStates;\r\n\r\n        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);\r\n\r\n        let sorting = isBoolean(fxStates.sorting) ? fxStates.sorting : false;\r\n        const prerenderRoutine = fxStates.prerenderRoutine || null;\r\n        const geometry = fxStates.geometry || null;\r\n        const instanceCount = fxStates.instanceCount || 1;\r\n\r\n        if (sorting && prerenderRoutine && types.equals(prerenderRoutine.function.def.returnType, T_VOID))\r\n        {\r\n            context.warn(sourceNode, EWarnings.PartFx_SortingCannotBeApplied);\r\n            context.warn(prerenderRoutine.function.def.sourceNode, EWarnings.PartFx_SortingCannotBeApplied);\r\n        }\r\n\r\n        //\r\n        // Validation of the shader input\r\n        //\r\n\r\n        let pixelShader = entry.pixel;\r\n\r\n        /**\r\n         * Vertex shader validation pattern:\r\n         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);\r\n         */\r\n\r\n        let vertexShader = entry.vertex;\r\n        if (vertexShader) {\r\n            const requiredSemantics = ['POSITION', 'POSITION0'];\r\n            let hasInstance = false;\r\n            let hasRequiredSemantics = false;\r\n            for (const param of vertexShader.def.params) {\r\n                hasInstance = hasInstance ||\r\n                    param.type.subType === context.particleInstance;\r\n                hasRequiredSemantics = hasRequiredSemantics ||\r\n                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));\r\n            }\r\n\r\n            if (!hasInstance) {\r\n                context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n                    { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });\r\n                vertexShader = pixelShader = null;\r\n            }\r\n\r\n            // if (!hasRequiredSemantics) {\r\n            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n            //         { tooltip: 'doesn\\'t have requiredsemantics.' });\r\n            //     vertexShader = pixelShader = null;\r\n            // }\r\n        }\r\n\r\n        //\r\n        // Rest\r\n        //\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        let drawMode = EPassDrawMode.k_Auto;\r\n        if (id) {\r\n            if (context.drawStmts.find(x => x.instr.name == id.name)) {\r\n                drawMode = EPassDrawMode.k_Manual;\r\n            }\r\n        }\r\n\r\n\r\n        const pass = new PartFxPassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n\r\n            sorting,\r\n            geometry,\r\n            instanceCount,\r\n            prerenderRoutine,\r\n            drawMode,\r\n\r\n            renderStates,\r\n            pixelShader,\r\n            vertexShader\r\n        });\r\n\r\n        //TODO: add annotation and id\r\n\r\n        context.endPartFxPass();\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    // TODO: use explicit return type\r\n    protected analyzePartFxStateBlock(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n        const children = sourceNode.children;\r\n        let states: Partial<IPartFxPassProperties> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n    * AST example:\r\n    *    PassState\r\n    *         T_PUNCTUATOR_59 = ';'\r\n    *       + PassStateExpr \r\n    *         T_PUNCTUATOR_61 = '='\r\n    *         T_NON_TYPE_ID = 'STATE_ONE'\r\n    */\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'STATE_TWO'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassStateExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // TODO: add explicit type for fx statess\r\n    protected analyzePartFXPassProperies(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateName: string = children[children.length - 1].value.toUpperCase();\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        let fxStates: Partial<IPartFxPassProperties> = {};\r\n\r\n        if (isNull(exprNode.value) || isNull(stateName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            // TODO: return correct state list\r\n            return fxStates;\r\n        }\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: string[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                // TODO: validate values with names\r\n                values[j] = stateExprNode.children[i].value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                // case ERenderStates.BLENDFUNC:\r\n                //     if (values.length !== 2) {\r\n                //         console.warn('Pass state are incorrect.');\r\n                //         return {};\r\n                //     }\r\n                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                //     break;\r\n                default:\r\n                    console.warn('Pass fx state is incorrect.');\r\n                    return fxStates;\r\n            }\r\n        }\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_NON_TYPE_ID = 'FALSE'\r\n         */\r\n        else {\r\n            let value: string = null;\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ('InstanceCount'.toUpperCase()):\r\n                    fxStates.instanceCount = Number(value) || 1;\r\n                    break;\r\n                case ('Geometry'.toUpperCase()):\r\n                    // Geometry = \"sfx_leaves\";\r\n                    if (exprNode.name == \"T_STRING\")\r\n                    {\r\n                        value = value.replace(/^\"(.+)\"$/,'$1');\r\n                    }\r\n                    // Geometry = Sphere;\r\n                    else\r\n                    {\r\n                        console.assert(exprNode.name === 'T_NON_TYPE_ID');\r\n                    }\r\n                    fxStates.geometry = value.toLowerCase();\r\n                    break;\r\n                case ('Sorting'.toUpperCase()):\r\n                    // TODO: use correct validation with diag error output\r\n                    assert(value == 'TRUE' || value == 'FALSE');\r\n                    fxStates.sorting = (value === 'TRUE');\r\n                    break;\r\n                case ('PrerenderRoutine'.toUpperCase()):\r\n                    {\r\n                        /**\r\n                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.\r\n                        */\r\n                        let validators: ICompileValidator[] = [\r\n                            /* void prerender(in Part part, inout PartInstance instance) */\r\n                            { ret: T_VOID, args: [context.particleCore, null] },\r\n                            /* void prerender(in Part part, inout PartInstance instance, int instanceId) */\r\n                            { ret: T_VOID, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                            /* int prerender(in Part part, inout PartInstance instance) */\r\n                            { ret: T_INT, args: [context.particleCore, null] },\r\n                            /* int prerender(in Part part, inout PartInstance instance, int instanceId) */\r\n                            { ret: T_INT, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                        ];\r\n\r\n                        //\r\n                        // TODO: add string-based validators like this:\r\n                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);\r\n                        //\r\n\r\n                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);\r\n\r\n                        if (!prerenderRoutine) {\r\n                            break;\r\n                        }\r\n\r\n                        //\r\n                        // check arguments\r\n                        //\r\n\r\n                        let fn = prerenderRoutine.function;\r\n\r\n                        /** first argument's type */\r\n                        let argv = fn.def.params.map(param => param.type);\r\n\r\n                        if (argv.length < 2) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        if (!argv[0].readable || argv[0].subType !== context.particleCore ||\r\n                            argv[0].isNotBaseArray() ||\r\n                            !(argv[1].usages.includes('out') || argv[1].usages.includes('inout')) || !argv[1].writable || argv[1].isNotBaseArray()) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        //         argv[1]: \"out PartInstance\"\r\n                        // argv[1].subType: \"PartInstance\"\r\n                        context.particleInstance = argv[1].subType;\r\n                        fxStates.prerenderRoutine = prerenderRoutine;\r\n                    }\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n\r\n        return fxStates;\r\n    }\r\n\r\n\r\n    protected analyzePartFXBody(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxProperties {\r\n        let passes: IPartFxPassInstruction[] = [];\r\n        let spawnRoutine: ICompileExprInstruction = null;\r\n        let initRoutine: ICompileExprInstruction = null;\r\n        let updateRoutine: ICompileExprInstruction = null;\r\n        let particle: ITypeInstruction = null;\r\n        let capacity: number = null;\r\n\r\n        const children = sourceNode.children;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassState':\r\n                    {\r\n                        let sourceNode = children[i];\r\n                        let stateName = sourceNode.children[3].value; // \"T_NON_TYPE_ID\"\r\n                        switch (stateName.toUpperCase()) {\r\n                            case ('Capacity'.toUpperCase()):\r\n                                {\r\n                                    // TODO: make correct validation of the capacity value and emit errors\r\n                                    //       through diagnostics system. \r\n                                    const snum = sourceNode.children[1].children[0].value;\r\n                                    assert(isNumber(Number(snum)));\r\n                                    capacity = Number(snum) || -1;\r\n                                    // capacity must be multiple of 64 because of group size is 64\r\n                                    // and we run thread for every alive particle\r\n                                    // todo: fix it usind condition in the beginning of the shader\r\n                                    capacity = Math.floor((capacity + 63) / 64) * 64;\r\n                                    break;\r\n                                }\r\n                            case ('SpawnRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Spawn routine expected as 'int spawn(void)'.\r\n                                     */\r\n                                    let validators = [\r\n                                        { ret: T_INT, args: [] },       // int f(void)\r\n                                        { ret: T_VOID, args: [/.*/] },  // void f(EMITTER emit)\r\n                                        { ret: T_VOID, args: [] },      // void f(void)\r\n                                    ];\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    const params = spawnRoutine.function.def.params;\r\n                                    if (params.length > 0) {\r\n                                        if (!params[0].type.usages.includes('inout')) {\r\n                                            context.warn(params[0].type.sourceNode, EWarnings.PartFx_EmitterPersistentDataMustBeMarkedAsInout);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case ('InitRoutine'.toUpperCase()):\r\n                                {\r\n                                    /** Init routine expected as 'void init(in Part part)'. */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_VOID, args: [null, /u?int/] },          /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null, /u?int/, /u?int/] }, /* init(PART part, int partId, int spawnId) */\r\n                                        { ret: T_VOID, args: [null] },                   /* init(PART part) */\r\n                                    ];\r\n\r\n                                    // TODO: show error in case of both functions are found\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!initRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    let fn = initRoutine.function;\r\n                                    /** first argument's type */\r\n                                    let type = fn.def.params[0].type;\r\n\r\n                                    if ((!type.usages.includes('out') && !type.usages.includes('inout')) || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        initRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                            case ('UpdateRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Update routine expected as 'void update(inout Part part)'.\r\n                                     */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_BOOL, args: [null, T_INT] }, /* update(PART part, int partId) */\r\n                                        { ret: T_BOOL, args: [null] },        /* update(PART part) */\r\n                                    ];\r\n\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    const fn = updateRoutine.function;\r\n                                    const fdef = fn.def;\r\n                                    const paramList = fdef.params;\r\n\r\n                                    if (paramList.length < 1 || paramList.length > 2) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    /** first argument's type */\r\n                                    let type = paramList[0].type;\r\n\r\n                                    if (!type.usages.includes('out') && !type.usages.includes('inout') || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    //\r\n                                    // Check return type\r\n                                    //\r\n\r\n                                    if (!types.equals(fdef.returnType, T_BOOL)) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Note: all fx properties should be parsed prior to pass declaraion analysis\r\n        // because some of them are critical for pass validation\r\n        context.particleCore = particle;\r\n\r\n        const presets = [];\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassDecl':\r\n                    {\r\n                        // hack to support presets extension\r\n                        if (children[i].children[0].name === 'PresetDecl') {\r\n                            presets.push(this.analyzePresetDecl(context, program, children[i].children[0]));\r\n                            break;\r\n                        }\r\n\r\n                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);\r\n\r\n                        if (!pass.isValid()) {\r\n                            context.warn((pass.id && pass.id.sourceNode) || children[i], EWarnings.IncompletePass, {\r\n                                techniqueName: pass.name,\r\n                                tooltip: `The pass is not completed. Not all required parameters are specified.`\r\n                            });\r\n                        }\r\n\r\n                        assert(!isNull(pass));\r\n                        passes.push(pass);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        return { passes, spawnRoutine, initRoutine, updateRoutine, particle, capacity, presets };\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PartFxDecl\r\n     *       + PartFxBody \r\n     *       + Annotation \r\n     *       + Semantic \r\n     *       + ComplexNameOpt \r\n     *         T_KW_FXPART = 'partFx'\r\n     */\r\n    protected analyzePartFXDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let props: IPartFxProperties = null;\r\n\r\n        context.beginPartFx();\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n\r\n            switch (children[i].name) {\r\n                case 'Annotation':\r\n                    annotation = this.analyzeAnnotation(context, program, children[i]);\r\n                    break;\r\n                case 'Semantic':\r\n                    semantic = this.analyzeSemantic(children[i]);\r\n                    break;\r\n                case 'PartFxBody':\r\n                    props = this.analyzePartFXBody(context, program, children[i]);\r\n                    break;\r\n\r\n            }\r\n\r\n        }\r\n        //\r\n        // draw operator finalization\r\n        //\r\n\r\n        for (const stmt of context.drawStmts) {\r\n            const { instr, ctx } = stmt;\r\n            const pass = props.passes.find(pass => pass.id.name == instr.name);\r\n            if (!pass) {\r\n                // emit warning not an error\r\n                // because in some cases it may be useful to have several effects with\r\n                // common update routine but different pass set\r\n                context.warn(instr.sourceNode, EWarnings.PartFx_RenderPassWasNotFound, { \r\n                    techniqueName: name,\r\n                    tooltip: `The technique doesn't have pass with name <${instr.name}>`\r\n                 });\r\n            }\r\n\r\n            const p0Type = ctx.params[0].type;\r\n            if (!types.equals(p0Type, context.particleCore) || !p0Type.readable) {\r\n                context.error(instr.sourceNode, EErrors.PartFx_DrawOpOnlyAllowedWithinUpdateRoutine,\r\n                    { tooltip: 'Draw operator only allowed within update routine' });\r\n            }\r\n        }\r\n\r\n        context.endPartFx();\r\n\r\n        const partFx = new PartFxInstruction({\r\n            sourceNode, name, semantic, annotation, scope, ...props\r\n        });\r\n\r\n        if (!partFx.isValid()) {\r\n            // highlight name only\r\n            context.warn(children[children.length - 2], EWarnings.IncompleteTechnique, {\r\n                techniqueName: partFx.name,\r\n                tooltip: `The technique is not completed. Not all required parameters are specified.`\r\n            });\r\n        }\r\n\r\n        FxAnalyzer.addTechnique(context, program, partFx);\r\n        return partFx;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'PartFxDecl':\r\n                return [this.analyzePartFXDecl(context, program, sourceNode)];\r\n            default:\r\n                return super.analyzeUnknDecl(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    protected createContext(uri: IFile): FxContext {\r\n        return new FxContext(uri);\r\n    }\r\n\r\n\r\n    protected validate(context: FxContext, program: ProgramScope, root: IInstructionCollector) {\r\n        super.validate(context, program, root);\r\n\r\n        const scope = program.globalScope;\r\n\r\n        if (!root.instructions) {\r\n            return;\r\n        }\r\n\r\n        // NOTE: all effects are assumed to be valid\r\n        const fxList = <IPartFxInstruction[]>root.instructions.filter(instr => instr.instructionType === EInstructionTypes.k_PartFxDecl);\r\n\r\n\r\n        //\r\n        // spawn operator validation\r\n        //\r\n\r\n        for (const spawnStmt of context.spawnStmts) {\r\n            const bImportedEffect = false;\r\n            //parse as the spawn from the same effect\r\n\r\n            assert(!bImportedEffect, 'unsupported');\r\n\r\n            if (!bImportedEffect) {\r\n\r\n                let initializer = <IFunctionDeclInstruction>null;\r\n                for (const fx of fxList) {\r\n                    // looking for:\r\n                    // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)\r\n                    // Init(out Part part, int partId: PART_ID, ...parameters)\r\n                    // Init(out Part part, ...parameters)\r\n                    let argsList = [[/u?int/, /u?int/], [/u?int/], []]\r\n                        .map(v => [ fx.particle, ...v, ...spawnStmt.args.map(asType) ]);\r\n\r\n                    for (const args of argsList) {\r\n                        initializer = scope.findFunction(spawnStmt.name, args);\r\n                        if (initializer) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (initializer) {\r\n                        // spawnStmt.$resolve(fx, initializer);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!initializer) {\r\n                    context.error(spawnStmt.sourceNode, EErrors.PartFx_InvalidSpawnStmtInitializerNotFound,\r\n                        { tooltip: 'Invalid spawn statement. Effect initializer not found.' });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","import { assert, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EScopeType, ICbufferInstruction, IFunctionDeclInstruction, IScope, ITechnique11Instruction, ITechniqueInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { isString } from \"@lib/util/s3d/type\";\r\n\r\nimport { fn } from \"./helpers\";\r\n\r\nexport interface IScopeSettings {\r\n    type?: EScopeType;\r\n    parent?: IScope;\r\n    strictMode?: boolean;\r\n}\r\n\r\n\r\n\r\nexport class Scope implements IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly techniques11: IMap<ITechnique11Instruction>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    readonly cbuffers: IMap<ICbufferInstruction>;\r\n\r\n    constructor(scope: Scope);\r\n    constructor(settings: IScopeSettings);\r\n    constructor(params) {\r\n        let type: EScopeType;\r\n        let strictMode: boolean;\r\n        let parent: IScope;\r\n\r\n        if (params instanceof Scope)\r\n        {\r\n            let scope = params as Scope;\r\n            ({ type = EScopeType.k_Default, parent = null, strictMode = false } = scope);\r\n\r\n            this.variables = { ...(scope.variables) };\r\n            this.types = { ...scope.types };\r\n            this.functions = { ...scope.functions };\r\n            this.techniques = { ...scope.techniques };\r\n            this.techniques11 = { ...scope.techniques11 };\r\n            this.typeTemplates = { ...scope.typeTemplates };\r\n            this.cbuffers = { ...scope.cbuffers };\r\n        } \r\n        else \r\n        {\r\n            let settings = params as IScopeSettings;\r\n            ({ type = EScopeType.k_Default, parent = null, strictMode = false } = settings);\r\n\r\n            this.variables = {};\r\n            this.types = {};\r\n            this.functions = {};\r\n            this.techniques = {};\r\n            this.techniques11 = { };\r\n            this.typeTemplates = {};\r\n            this.cbuffers = {};\r\n        }\r\n\r\n        this.type = type;\r\n        this.parent = parent;\r\n        this.strictMode = strictMode;\r\n    }\r\n\r\n\r\n    isStrict(): boolean {\r\n        return this.filter(scope => scope.strictMode);\r\n    }\r\n\r\n\r\n    findVariable(varName: string): IVariableDeclInstruction {\r\n        return this.filter(scope => scope.variables[varName] || null);\r\n    }\r\n\r\n\r\n    findTypeTemplate(typeName: string): ITypeTemplate {\r\n        return this.filter(scope => scope.typeTemplates[typeName] || null);\r\n    }\r\n\r\n\r\n    findType(typeName: string): ITypeInstruction {\r\n        return this.filter(scope => scope.types[typeName] || null);\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp> = null): IFunctionDeclInstruction | null | undefined {\r\n        return this.filter(scope => fn.matchList(scope.functions[funcName], args))\r\n    }\r\n\r\n\r\n    findTechnique(techName: string): ITechniqueInstruction {\r\n        return this.filter(scope => scope.techniques[techName] || null);\r\n    }\r\n\r\n\r\n    findTechnique11(techName: string): ITechnique11Instruction {\r\n        return this.filter(scope => scope.techniques11[techName] || null);\r\n    }\r\n\r\n\r\n    findCbuffer(cbufName: string): ICbufferInstruction {\r\n        return this.filter(scope => scope.cbuffers[cbufName] || null);\r\n    }\r\n\r\n\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction {\r\n        let res = fn.matchList(this.functions[func.name], func.def.params.map(param => param? param.type : null));\r\n        assert(res !== undefined);\r\n        return res;\r\n    }\r\n\r\n    \r\n    addVariable(variable: IVariableDeclInstruction): boolean {\r\n        let variableMap = this.variables;\r\n        let varName = variable.name;\r\n\r\n        if (!this.variables[varName]) {\r\n            variableMap[varName] = variable;\r\n            assert(variable.scope === this);\r\n        }\r\n        else {\r\n            // console.error(`letiable '${varName}' already exists in scope:`, this);\r\n            return false;\r\n        }\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeTemplate(template: ITypeTemplate): boolean {\r\n        if (isDefAndNotNull(this.typeTemplates[template.name])) {\r\n            return false;\r\n        }\r\n\r\n        this.typeTemplates[template.name] = template;\r\n        return true;\r\n    }\r\n\r\n    // todo: remove scopeId from argumts, use type.scope instead.\r\n    addType(type: ITypeInstruction): boolean {\r\n        if (this.types[type.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.types[type.name] = type;\r\n        console.assert(type.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeAlias(t: string | ITypeInstruction, aliasName: string): boolean {\r\n        let typeName = null;\r\n        let type = null;\r\n\r\n        if (isString(t)) {\r\n            typeName = t;\r\n            type = this.findType(typeName);\r\n        } else {\r\n            type = t;\r\n            typeName = type.name;\r\n        }\r\n        \r\n        const alias = this.findType(aliasName);\r\n\r\n        if (alias) {\r\n            return false;\r\n        }\r\n\r\n        if (!type) {\r\n            return false;\r\n        }\r\n\r\n        // original type must be part of this scope?\r\n        if (!this.findType(typeName)) {\r\n            return false;\r\n        }\r\n\r\n        this.types[aliasName] = type;\r\n        return true;\r\n    }\r\n\r\n\r\n    addFunction(func: IFunctionDeclInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n        assert(func.scope === this);\r\n\r\n        let funcMap = this.functions;\r\n        let funcName = func.name;\r\n\r\n        funcMap[funcName] = funcMap[funcName] || [];\r\n        const funcOverloads = funcMap[funcName];\r\n\r\n        let targetFunc = this.findFunctionInScope(func);\r\n\r\n        if (!targetFunc) {\r\n            funcOverloads.push(func);\r\n        } else {\r\n            assert(!isNull(func.impl));\r\n            assert(isNull(targetFunc.impl));\r\n            let i = funcOverloads.indexOf(targetFunc);\r\n            funcOverloads[i] = func;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique(technique: ITechniqueInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques[technique.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques[technique.name] = technique;\r\n        assert(technique.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique11(technique11: ITechnique11Instruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques11[technique11.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques11[technique11.name] = technique11;\r\n        assert(technique11.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addCbuffer(cbuf: ICbufferInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.cbuffers[cbuf.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.cbuffers[cbuf.name] = cbuf;\r\n        assert(cbuf.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    private filter<T>(cb: (scope: IScope) => T | null): T \r\n    {\r\n        let scope: IScope = this;\r\n        while (!isNull(scope)) {\r\n            let res = cb(scope);\r\n            if (!isNull(res)) {\r\n                return res;\r\n            }\r\n            scope = scope.parent;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class ProgramScope {\r\n    globalScope: IScope;\r\n    currentScope: IScope;\r\n\r\n\r\n    constructor(parent: IScope) {\r\n        if (!isNull(parent))\r\n        {\r\n            let type = EScopeType.k_Global;\r\n            this.globalScope = new Scope({ parent, type });\r\n            this.currentScope = this.globalScope;\r\n        }\r\n    }\r\n\r\n\r\n    validate(): void {\r\n        assert(this.currentScope === this.globalScope);\r\n    }\r\n\r\n\r\n    push(type: EScopeType = EScopeType.k_Default): void {\r\n        assert(this.currentScope !== null);\r\n        assert(type >= EScopeType.k_Default);\r\n\r\n        let parent = this.currentScope;\r\n        let scope = new Scope({ parent, type });\r\n\r\n        this.currentScope = scope;\r\n    }\r\n\r\n\r\n    pop(): void {\r\n        assert(this.currentScope !== null);\r\n        this.currentScope = this.currentScope.parent;\r\n        assert(this.currentScope !== null);\r\n    }\r\n}\r\n\r\n\r\nexport class ProgramScopeEx extends ProgramScope {\r\n    constructor(parent: IScope) {\r\n        super(null);\r\n        this.globalScope = new Scope(parent); // clone scope\r\n        this.currentScope = this.globalScope;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { Scope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { EScopeType, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { addSystemFunctions } from \"./system/api\";\r\nimport { addSystemTypeBuiltin } from \"./system/builtin\";\r\nimport { addSystemTypeMatrix } from \"./system/matrix\";\r\nimport { addSystemTypeScalar } from \"./system/scalar\";\r\nimport {\r\n    isBoolBasedType, isFloatBasedType, isHalfBasedType, isIntBasedType, isMatrixType, isScalarType, isUintBasedType,\r\n    isVectorType\r\n} from \"./system/utils\";\r\nimport { addSystemTypeVector } from \"./system/vector\";\r\nexport {\r\n    isBase, isBlendState, isBoolBasedType, isBuffer, isDepthStencilState, isFloatBasedType, isFloatType, isHalfBasedType,\r\n    isIntBasedType, isIntegerType, isMatrixType, isPipelineState, isRasterizerState, isSamplerState, isScalarType,\r\n    isTexture, isUAV, isUintBasedType, isVectorType, resolveRegister\r\n} from './system/utils';\r\n\r\nconst scope = new Scope({ type: EScopeType.k_System });\r\n\r\naddSystemTypeScalar(scope);\r\naddSystemTypeVector(scope);\r\naddSystemTypeMatrix(scope);\r\naddSystemTypeBuiltin(scope);\r\naddSystemFunctions(scope);\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n export const findType = (typeName: string) => scope.findType(typeName);\r\n export const findVariable = (varName: string) => scope.findVariable(varName);\r\n export const findTechnique = (techName: string) => scope.findTechnique(techName);\r\n export const findFunction = (funcName: string, args?: ITypeInstruction[]) => scope.findFunction(funcName, args);\r\n \r\n export const hasType = (typeName: string) => !isNull(scope.findType(typeName));\r\n export const hasVariable = (varName: string) => !isNull(scope.findVariable(varName));\r\n export const hasTechnique = (techName: string) => !isNull(scope.findTechnique(techName));\r\n\r\nexport const SCOPE = scope;\r\n\r\nexport const T_VOID = scope.findType(\"void\");\r\nexport const T_STRING = scope.findType(\"string\");\r\nexport const T_NULL = scope.findType(\"null_t\");\r\n\r\nexport const T_SAMPLER_STATE = scope.findType(\"SamplerState\");\r\nexport const T_BLEND_STATE = scope.findType(\"BlendState\");\r\nexport const T_DEPTH_STENCIL_STATE = scope.findType(\"DepthStencilState\");\r\n\r\nexport const T_FLOAT = scope.findType(\"float\");\r\nexport const T_FLOAT2 = scope.findType(\"float2\");\r\nexport const T_FLOAT3 = scope.findType(\"float3\");\r\nexport const T_FLOAT4 = scope.findType(\"float4\");\r\n\r\nexport const T_HALF = scope.findType(\"half\");\r\nexport const T_HALF2 = scope.findType(\"half2\");\r\nexport const T_HALF3 = scope.findType(\"half3\");\r\nexport const T_HALF4 = scope.findType(\"half4\");\r\n\r\nexport const T_FLOAT2X2 = scope.findType(\"float2x2\");\r\nexport const T_FLOAT2X3 = scope.findType(\"float2x3\");\r\nexport const T_FLOAT2X4 = scope.findType(\"float2x4\");\r\nexport const T_FLOAT3X2 = scope.findType(\"float3x2\");\r\nexport const T_FLOAT3X3 = scope.findType(\"float3x3\");\r\nexport const T_FLOAT3X4 = scope.findType(\"float3x4\");\r\nexport const T_FLOAT4X2 = scope.findType(\"float4x2\");\r\nexport const T_FLOAT4X3 = scope.findType(\"float4x3\");\r\nexport const T_FLOAT4X4 = scope.findType(\"float4x4\");\r\n\r\nexport const T_BOOL = scope.findType(\"bool\");\r\nexport const T_BOOL2 = scope.findType(\"bool2\");\r\nexport const T_BOOL3 = scope.findType(\"bool3\");\r\nexport const T_BOOL4 = scope.findType(\"bool4\");\r\n\r\nexport const T_BOOL2X2 = scope.findType(\"bool2x2\");\r\nexport const T_BOOL3X3 = scope.findType(\"bool3x3\");\r\nexport const T_BOOL4X4 = scope.findType(\"bool4x4\");\r\n\r\nexport const T_INT = scope.findType(\"int\");\r\nexport const T_INT2 = scope.findType(\"int2\");\r\nexport const T_INT3 = scope.findType(\"int3\");\r\nexport const T_INT4 = scope.findType(\"int4\");\r\n\r\nexport const T_UINT = scope.findType(\"uint\");\r\nexport const T_UINT2 = scope.findType(\"uint2\");\r\nexport const T_UINT3 = scope.findType(\"uint3\");\r\nexport const T_UINT4 = scope.findType(\"uint4\");\r\n\r\nexport const T_INT2X2 = scope.findType(\"int2x2\");\r\nexport const T_INT3X3 = scope.findType(\"int3x3\");\r\nexport const T_INT4X4 = scope.findType(\"int4x4\");\r\n\r\n// export const T_SAMPLER = scope.findType(\"sampler\");\r\n// export const T_SAMPLER_2D = scope.findType(\"sampler2D\");\r\n// export const T_SAMPLER_CUBE = scope.findType(\"samplerCUBE\");\r\n\r\nexport const T_VERTEX_SHADER = scope.findType(\"VertexShader\");\r\nexport const T_PIXEL_SHADER = scope.findType(\"PixelShader\");\r\nexport const T_COMPUTE_SHADER = scope.findType(\"ComputeShader\");\r\nexport const T_GEOMETRY_SHADER = scope.findType(\"GeometryShader\");\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function determBaseType(type: ITypeInstruction): ITypeInstruction {\r\n    if (isScalarType(type)) {\r\n        return type;\r\n    }\r\n\r\n    if (isVectorType(type) || isMatrixType(type)) {\r\n        if (isFloatBasedType(type)) {\r\n            return T_FLOAT;\r\n        }\r\n\r\n        if (isIntBasedType(type)) {\r\n            return T_INT;\r\n        }\r\n\r\n        if (isUintBasedType(type)) {\r\n            return T_UINT;\r\n        }\r\n\r\n        if (isHalfBasedType(type)) {\r\n            return T_HALF;\r\n        }\r\n\r\n        if (isBoolBasedType(type)) {\r\n            return T_BOOL;\r\n        }\r\n    }\r\n\r\n    assert(false, `cannot determ base type of ${type.name}`);\r\n    return null;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nenum ETypePrecision {\r\n    k_Bool,\r\n    k_Uint,\r\n    k_Int,\r\n    k_Half,\r\n    k_Float,\r\n    k_Unknown = NaN\r\n};\r\n\r\nexport function determTypePrecision(type: ITypeInstruction): ETypePrecision {\r\n    if (isFloatBasedType(type)) return ETypePrecision.k_Float;\r\n    if (isHalfBasedType(type)) return ETypePrecision.k_Half;\r\n    if (isIntBasedType(type)) return ETypePrecision.k_Int;\r\n    if (isUintBasedType(type)) return ETypePrecision.k_Uint;\r\n    if (isBoolBasedType(type)) return ETypePrecision.k_Bool;\r\n    return ETypePrecision.k_Unknown;\r\n}\r\n\r\n\r\nexport function typePrecisionAsType(precision: ETypePrecision): ITypeInstruction {\r\n    switch (precision) {\r\n        case ETypePrecision.k_Float: return T_FLOAT;\r\n        case ETypePrecision.k_Half: return T_HALF;\r\n        case ETypePrecision.k_Int: return T_INT;\r\n        case ETypePrecision.k_Uint: return T_UINT;\r\n        case ETypePrecision.k_Bool: return T_BOOL;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Determining the most precise type of two types.\r\n * Type hierarchy: \r\n *  float => half => int => uint => bool\r\n */\r\nexport function determMostPreciseBaseType(left: ITypeInstruction, right: ITypeInstruction) {\r\n    assert(isScalarType(left) || isVectorType(left));\r\n    assert(isScalarType(right) || isVectorType(right));\r\n\r\n    const type = typePrecisionAsType(Math.max(determTypePrecision(left), determTypePrecision(right)));\r\n\r\n    assert(type !== null, 'cannot determ base type');\r\n    return type;\r\n}\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IInstruction, ILiteralInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"./instruction\";\r\n\r\nexport namespace expression {\r\n    /**\r\n     * unwind operation returns declaration in case of correct l-value expression;\r\n     */\r\n    export function unwind(expr: IExprInstruction): IVariableDeclInstruction {\r\n        if (isNull(expr)) {\r\n            return null;\r\n        }\r\n\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return unwind((<IPostfixPointInstruction>expr).element);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return unwind((<IPostfixIndexInstruction>expr).element);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return (<IIdExprInstruction>expr).decl;\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                // arithmetic expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_InitExpr:\r\n                assert(false, 'init expression doesn\\'t support unwind operation');\r\n                return null;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                // todo: reseach how it work in HLSL\r\n                //// assigment expression returns right-hand value;\r\n                return unwind((<IAssignmentExprInstruction>expr).left);\r\n            case EInstructionTypes.k_CastExpr:\r\n                // cast expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // unary expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                // relation expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                // ctor call expression is not allowed as l-value;\r\n                // todo: allow it?\r\n                return null;\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return unwind((<IComplexExprInstruction>expr).expr);\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n                // literal cannot be a left-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                // function call expression returns right-hand value;\r\n                return null;\r\n            default:\r\n                assert(false, \"unsupported expr found\");\r\n                return null;\r\n        }\r\n    }\r\n\r\n    \r\n    function evalVal(val: IInstruction) {\r\n        if (!val) {\r\n            return 0;\r\n        }\r\n\r\n        if (instruction.isLiteral(val)) {\r\n            return (<ILiteralInstruction<number>>val).value;\r\n        } \r\n            \r\n        if (val.instructionType === EInstructionTypes.k_CastExpr) {\r\n            return evalConst((<ICastExprInstruction>val).expr);\r\n        }\r\n\r\n        if (val.instructionType === EInstructionTypes.k_IdExpr) {\r\n            const idExpr = (<IIdExprInstruction>val);\r\n            if (idExpr.decl.isGlobal()) { // and is constant?\r\n                console.assert(idExpr.decl.initExpr.instructionType !== EInstructionTypes.k_InitExpr);\r\n                return evalConst(idExpr.decl.initExpr);\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n\r\n    // simples possible evalator for minimal compartibility\r\n    export function evalConst(expr: IExprInstruction): number\r\n    {\r\n        const val = evalVal(expr);\r\n        if (val >= 0) {\r\n            return val;\r\n        }\r\n\r\n        if (expr.instructionType !== EInstructionTypes.k_ArithmeticExpr) {\r\n            console.error(`expr \"${expr.toCode()}\" could not be evaluated`);\r\n            return -1;\r\n        }\r\n\r\n        const { left, right, operator } = <IArithmeticExprInstruction>expr;\r\n        const lval = evalConst(left);\r\n        const rval = evalConst(right);\r\n        \r\n        if (lval >= 0 && rval >= 0) {\r\n            switch (operator) {\r\n                // todo: use round ? check if integers only\r\n                case '*': return rval * lval;\r\n                case '/': return rval / lval;\r\n                case '+': return rval + lval;\r\n                case '-': return rval - lval;\r\n                default:\r\n                    console.error('unsupported operator');\r\n            }\r\n        }\r\n\r\n        console.error(`expr \"${expr.toCode()}\" could not be evaluated`);\r\n        return -1;\r\n    }\r\n\r\n}\r\n","import { IFunctionDefInstruction, IVariableDeclInstruction, ITypeInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types } from \"@lib/fx/analisys/helpers\";\r\nimport { isNull } from \"@lib/common\";\r\n\r\nexport namespace fn {\r\n\r\n    function signatureParam(param: IVariableDeclInstruction, strong: boolean): string {\r\n        return `${types.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;\r\n    }\r\n\r\n    export function signature(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, params } = def;\r\n        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n    export function signatureEx(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, returnType, params } = def;\r\n        return `${types.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n\r\n    export function numArgsRequired(def: IFunctionDefInstruction): number {\r\n        return def.params.filter((param) => !param || !param.initExpr).length;\r\n    }\r\n\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function match(def: IFunctionDefInstruction, args: Array<ITypeInstruction | RegExp>, strong: boolean = false): boolean {\r\n        if (!strong && isNull(args)) {\r\n            return true;\r\n        }\r\n\r\n        if (args.length > def.params.length || numArgsRequired(def) > args.length) {\r\n            return false;\r\n        }\r\n\r\n        return args.every((arg, i) => \r\n            (!strong && isNull(arg)) ||\r\n            (!strong && isNull(def.params[i].type)) ||\r\n            types.equals(arg, def.params[i].type, strong)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function matchList(funcList: IFunctionDeclInstruction[],\r\n        args: Array<ITypeInstruction | RegExp>,\r\n        strong: boolean = false): IFunctionDeclInstruction | null | undefined {\r\n\r\n        if (!funcList) {\r\n            return null;\r\n        }\r\n\r\n        const res = funcList.filter(func => fn.match(func.def, args, strong));\r\n        if (res.length > 1) {\r\n            return undefined;\r\n        }\r\n\r\n        if (res.length === 1) {\r\n            return res[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","export { expression } from './expression';\r\nexport { fn } from './fn';\r\nexport { instruction } from './instruction';\r\nexport { types } from './types';\r\nexport { variable } from './variable';\r\n\r\n","import { EInstructionTypes, IInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace instruction {\r\n    export const UNDEFINE_LENGTH: number = 0xffffff;\r\n    export const UNDEFINE_SIZE: number = 0xffffff;\r\n    export const UNDEFINE_PADDING: number = 0xffffff;\r\n    export const UNDEFINE_NAME: string = \"undef\";\r\n\r\n    export function isExpression(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n            case EInstructionTypes.k_InitExpr:\r\n            case EInstructionTypes.k_IdExpr:\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n            case EInstructionTypes.k_ComplexExpr:\r\n            case EInstructionTypes.k_CastExpr:\r\n            case EInstructionTypes.k_UnaryExpr:\r\n            case EInstructionTypes.k_RelationalExpr:\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isStatement(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_Stmt:\r\n            case EInstructionTypes.k_DeclStmt:\r\n            case EInstructionTypes.k_ReturnStmt:\r\n            case EInstructionTypes.k_IfStmt:\r\n            case EInstructionTypes.k_StmtBlock:\r\n            case EInstructionTypes.k_ExprStmt:\r\n            case EInstructionTypes.k_WhileStmt:\r\n            case EInstructionTypes.k_ForStmt:\r\n            case EInstructionTypes.k_BreakStmt:\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isLiteral(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { isDefAndNotNull } from \"@lib/util/s3d/type\";\r\nimport { instruction } from \"./instruction\";\r\nimport { variable } from \"./variable\";\r\n\r\nexport namespace types {\r\n\r\n    // todo: rename it\r\n    /** @deprecated */\r\n    export function isInheritedFromVariableDecl(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n        const parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return true;\r\n        }\r\n        else if (parentType === EInstructionTypes.k_VariableType) {\r\n            return isInheritedFromVariableDecl(<IVariableTypeInstruction>type.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function isTypeOfField(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n\r\n        if (type.parent.instructionType === EInstructionTypes.k_VariableDecl) {\r\n            let pParentDecl: IVariableDeclInstruction = <IVariableDeclInstruction>type.parent;\r\n            return pParentDecl.isField();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentContainer(type: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {\r\n            return null;\r\n        }\r\n\r\n        let containerType: IVariableTypeInstruction = <IVariableTypeInstruction>findParentVariableDecl(type).parent;\r\n        if (!isInheritedFromVariableDecl(containerType)) {\r\n            return null;\r\n        }\r\n\r\n        return findParentVariableDecl(containerType);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDecl(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType: EInstructionTypes = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return <IVariableDeclInstruction>type.parent;\r\n        }\r\n\r\n        return findParentVariableDecl(<IVariableTypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDeclName(type: ITypeInstruction): string {\r\n        let varDecl = findParentVariableDecl(type)\r\n        return isNull(varDecl) ? null : varDecl.name;\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDecl(type: ITypeInstruction): ITypeDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_TypeDecl) {\r\n            return <ITypeDeclInstruction>type.parent;\r\n        }\r\n        return finParentTypeDecl(<ITypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDeclName(type: IVariableTypeInstruction): string {\r\n        let typeDecl = finParentTypeDecl(type);\r\n        return isNull(typeDecl) ? null : typeDecl.name;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function resolveVariableDeclFullName(type: ITypeInstruction): string {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            console.error(\"Not from variable decl\");\r\n            return null;\r\n        }\r\n\r\n        return variable.fullName(findParentVariableDecl(type));\r\n    }\r\n\r\n\r\n    // todo: add comment\r\n    // todo: review this code\r\n    /** @deprecated */\r\n    export function findMainVariable(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        if (isTypeOfField(type)) {\r\n            return findMainVariable(<IVariableTypeInstruction>type.parent.parent);\r\n        }\r\n        return findParentVariableDecl(type);\r\n    }\r\n\r\n    //\r\n    // Signatures\r\n    //\r\n\r\n    function signatureVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let prefix = '';\r\n        if (strong) {\r\n            if (vtype.usages.length > 0) {\r\n                prefix = `${vtype.usages.join('_')}_`;\r\n            }\r\n        }\r\n        let postfix = '';\r\n        if (vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n        // skip all variable type wrappers\r\n        // is it safe?\r\n        let subType = vtype.subType;\r\n        while (subType.instructionType == EInstructionTypes.k_VariableType)\r\n            subType = (<IVariableTypeInstruction>subType).subType;\r\n        return `${prefix}${signature(subType)}${postfix}`;\r\n    }\r\n\r\n\r\n    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)\r\n\r\n\r\n    export function signature(type: ITypeInstruction, strong: boolean = false): string {\r\n        if (!isDefAndNotNull(type)) {\r\n            assert(!strong);\r\n            return '*';\r\n        }\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return signatureVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return `${type.name}${type.instructionID}`;\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? signature(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    // export function relaxType(type: ITypeInstruction): ITypeInstruction | RegExp {\r\n    //     if (!type) {\r\n    //         return null;\r\n    //     }\r\n\r\n\r\n    //     if (types.equals(type, T_INT) || types.equals(type, T_UINT)) {\r\n    //         // temp workaround in order to match int to uint and etc. \r\n    //         return /^int$|^uint$/g;\r\n    //     }\r\n\r\n    //     return type;\r\n    // }\r\n\r\n\r\n    // // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    // export function asRelaxedType(instr: ITypedInstruction): ITypeInstruction | RegExp {\r\n    //     if (!instr) {\r\n    //         return null;\r\n    //     }\r\n\r\n    //     return relaxType(instr.type);\r\n    // };\r\n\r\n    //\r\n    // hash\r\n    //\r\n\r\n    function hashVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let postfix = '';\r\n        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${hash(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n    function hashComplex(ctype: ITypeInstruction, strong: boolean): string {\r\n        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;\r\n    }\r\n\r\n    export function hash(type: ITypeInstruction, strong: boolean = false): string {\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return hashVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return hashComplex(type, strong);\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? hash(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    export function compareRelaxed(a: ITypeInstruction, b: ITypeInstruction, strong: boolean = false): boolean {\r\n        return hash(a, strong) === hash(b, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function compare(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        if (isNull(a) || isNull(b)) {\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp && b instanceof RegExp) {\r\n            assert(false);\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp) {\r\n            let ra = <RegExp>a;\r\n            let sb = signature(<ITypeInstruction>b, strong);\r\n            return !!sb.match(ra);\r\n        }\r\n\r\n        if (b instanceof RegExp) {\r\n            let sa = signature(<ITypeInstruction>a, strong);\r\n            let rb = <RegExp>b;\r\n            return !!sa.match(rb);\r\n        }\r\n\r\n        let ta = <ITypeInstruction>a;\r\n        let tb = <ITypeInstruction>b;\r\n        if (ta.isArray() && tb.isArray()) {\r\n            if (ta.length === instruction.UNDEFINE_LENGTH ||\r\n                tb.length === instruction.UNDEFINE_LENGTH) {\r\n                \r\n                // wnen both types are undefined is valid \r\n                if (ta.length !== tb.length) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return signature(ta, strong) === signature(tb, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function equals(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        return compare(a, b, strong);\r\n    }\r\n\r\n    //\r\n    // utils\r\n    //\r\n\r\n    export function alignSize(size: number, aligment: number): number {\r\n        if (size === instruction.UNDEFINE_SIZE) {\r\n            return size;\r\n        }\r\n        \r\n        const unaligned = size % aligment;\r\n        return unaligned !== 0 ? size + aligment - unaligned : size;\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { types } from \"./types\";\r\n\r\nexport namespace variable {\r\n    /**\r\n     * @param decl Variable declaraion (decl.isParameter() must be true).\r\n     * @returns Serial number of the declaration among the function parameters or -1 otherwise.\r\n     */\r\n    export function parameterIndex(decl: IVariableDeclInstruction): number {\r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return -1;\r\n        }\r\n        // all parameters must be a children on function definition!\r\n        assert(decl.parent.instructionType === EInstructionTypes.k_FunctionDef);\r\n        return (<IFunctionDefInstruction>decl.parent).params.indexOf(decl);\r\n    }\r\n\r\n    /**\r\n     * @returns Offset in bytes from the beginning of the parameters' list.\r\n     */\r\n    export function parameterOffset(decl: IVariableDeclInstruction): number {\r\n        // todo: add support for 'inout', 'out' usages \r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return 0;\r\n        }\r\n\r\n        let idx = parameterIndex(decl);\r\n        let offset = 0;\r\n        for (let i = 0; i < idx; ++i) {\r\n            offset += (<IFunctionDefInstruction>decl.parent).params[i].type.size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    /**\r\n     * Helper:\r\n     *  Returns 'structName.fieldName' for structs;\r\n     *  Returns 'varName' for variables;\r\n     */\r\n    export function fullName(decl: IVariableDeclInstruction) {\r\n        if (decl.isField() &&\r\n            types.findParentVariableDecl(<IVariableTypeInstruction>decl.parent)) {\r\n\r\n            let name = '';\r\n            let parentType = decl.parent.instructionType;\r\n\r\n            if (parentType === EInstructionTypes.k_VariableType) {\r\n                name = types.resolveVariableDeclFullName(<IVariableTypeInstruction>decl.parent);\r\n            }\r\n\r\n            name += '.' + decl.name;\r\n            return name;\r\n        }\r\n        return decl.name;\r\n    }\r\n}","import { EInstructionTypes, IAnnotationInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAnnotationSettings extends IInstructionSettings {\r\n    decls: IVariableDeclInstruction[];\r\n}\r\n\r\nexport class AnnotationInstruction extends Instruction implements IAnnotationInstruction {\r\n    \r\n    readonly decls: IVariableDeclInstruction[];\r\n\r\n    constructor({ decls, ...settings }: IAnnotationSettings) {\r\n        super({ instrType: EInstructionTypes.k_Annotation, ...settings });\r\n\r\n        this.decls = decls;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IArithmeticOperator, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IArithmeticExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: IArithmeticOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr + / - * % someExpr\r\n * (+|-|*|/|%) Instruction Instruction\r\n */\r\nexport class ArithmeticExprInstruction extends ExprInstruction implements IArithmeticExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: IArithmeticOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IArithmeticExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ArithmeticExpr, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n    get operator(): IArithmeticOperator {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this._leftOperand.toCode();\r\n        sCode += ` ${this.operator} `;\r\n        sCode += this._rightOperand.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IAssignmentExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type AssigmentOperator = \"=\" | \"+=\" | \"-=\" | \"/=\" | \"*=\" | \"%=\" | \"|=\" | \"&=\" | \">>=\" | \"<<=\" | \"^=\";\r\n\r\nexport interface IAssignmentExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: ITypedInstruction;\r\n    operator: AssigmentOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr = += -= /= *= %= someExpr\r\n * (=|+=|-=|*=|/=|%=) Instruction Instruction\r\n */\r\nexport class AssignmentExprInstruction extends ExprInstruction implements IAssignmentExprInstruction {\r\n    protected _leftValue: IExprInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n    protected _operator: AssigmentOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IAssignmentExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });\r\n\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IAttributeInstruction, IInstruction, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAttributeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args?: ILiteralInstruction<boolean | number>[];\r\n}\r\n\r\n/**\r\n * Represent attributes:\r\n *  [numthreads(1, 2, 3)]\r\n *  [loop]\r\n *  [branch]\r\n */\r\nexport class AttributeInstruction extends Instruction implements IAttributeInstruction {\r\n    \r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n\r\n    constructor({ name, args = null, ...settings }: IAttributeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Attribute, ...settings });\r\n\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `[${this.name}${ this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})`: `` }]`;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IBitwiseExprInstruction, IBitwiseOperator, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IBitwiseExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: IBitwiseOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr >> << | & ^ someExpr\r\n * (>>,<<,|,&,^) Instruction Instruction\r\n */\r\nexport class BitwiseExprInstruction extends ExprInstruction implements IBitwiseExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: IBitwiseOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IBitwiseExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BitwiseExpr, ...settings });\r\n\r\n        this.left = Instruction.$withParent(left, this);\r\n        this.right = Instruction.$withParent(right, this);\r\n        this.operator = operator;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return `${this.left.toCode()} ${this.operator} ${this.right.toCode()}`;\r\n    }\r\n\r\n    // FIXME: use isConstExpr instead!\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_BOOL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IBoolInstructionSettings extends IInstructionSettings {\r\n    value: boolean;\r\n}\r\n\r\nexport class BoolInstruction extends ExprInstruction implements ILiteralInstruction<boolean> {\r\n    readonly value: boolean;\r\n\r\n    constructor({ value, scope, ...settings }: IBoolInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BoolExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.value ? \"true\" : \"false\";\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\n\r\nexport type BreakOperator = \"break\" | \"discard\";\r\n\r\nexport interface IBreakStmtInstructionSettings extends IInstructionSettings {\r\n    operator?: BreakOperator;\r\n}\r\n\r\n/**\r\n * Reprsernt continue; break; discard;\r\n * (continue || break || discard) \r\n */\r\nexport class BreakStmtInstruction extends StmtInstruction {\r\n    protected _operator: BreakOperator;\r\n\r\n    constructor({ operator = \"break\", ...settings }: IBreakStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BreakStmt, ...settings });\r\n        this._operator = operator;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    // todo: validate operator's name\r\n    toCode(): string {\r\n        console.assert(this.operator == \"break\");\r\n        return this.operator + \";\";\r\n    }\r\n}\r\n","import { types } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, ICastExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICastExprInstructionSettings extends IExprInstructionSettings {\r\n    sourceExpr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (type) expr\r\n * EMPTY_OPERATOR VariableTypeInstruction Instruction\r\n */\r\nexport class CastExprInstruction extends ExprInstruction implements ICastExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    constructor({ sourceExpr, ...settings }: ICastExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CastExpr, ...settings });\r\n        this.expr = Instruction.$withParent(sourceExpr, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `(${this.type.toCode()})(${this.expr.toCode()})`;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isUseless() {\r\n        return types.equals(this.type, this.expr.type);\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { EInstructionTypes, ICbufferInstruction, IIdInstruction, ITypeInstruction, IVariableTypeInstruction, IRegister } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\nimport { variable } from \"../helpers\";\r\n\r\nexport interface ICbufferDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: ITypeInstruction;\r\n}\r\n\r\nexport class CbufferInstruction extends DeclInstruction implements ICbufferInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ id, type, ...settings }: ICbufferDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CbufferDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withParent(type, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileExprInstruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\n\r\nexport interface ICompileExprInstructionSettings extends IExprInstructionSettings {\r\n    operand: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n * Represents compile vs_func(...args)\r\n * compile IdExprInstruction ExprInstruction ... ExprInstruction\r\n */\r\n/** @deprecated */\r\nexport class CompileExprInstruction extends ExprInstruction implements ICompileExprInstruction {\r\n    protected _operand: IFunctionDeclInstruction;\r\n    protected _args: IExprInstruction[];\r\n\r\n\r\n    constructor({ operand, args = null, ...settings }: ICompileExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileExpr, ...settings });\r\n\r\n        this._operand = operand;//Instruction.$withParent(operand, this);\r\n        this._args = args;//(args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    \r\n    get function(): IFunctionDeclInstruction {\r\n        return <IFunctionDeclInstruction>this._operand;\r\n    }\r\n\r\n    \r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileShader11Instruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICompileShader11InstructionSettings extends IExprInstructionSettings {\r\n    ver: string;\r\n    func: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n * Represents CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )\r\n */\r\nexport class CompileShader11Instruction extends ExprInstruction implements ICompileShader11Instruction {\r\n    readonly ver: string;\r\n    readonly func: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    constructor({ ver, func, args, ...settings }: ICompileShader11InstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileShader11Expr, ...settings });\r\n\r\n        this.func = Instruction.$withNoParent(func);\r\n        this.ver = ver;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IComplexExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IComplexExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (expr)\r\n * EMPTY_OPERATOR ExprInstruction\r\n */\r\nexport class ComplexExprInstruction extends ExprInstruction implements IComplexExprInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, ...settings }: IComplexExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return \"(\" + this.expr.toCode() + \")\";\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { instruction, types } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IComplexTypeInstructionSettings extends IInstructionSettings {\r\n    name?: string;\r\n    fields: IVariableDeclInstruction[]; // << todo: replace this Array<Instruction>;\r\n    aligment?: number;\r\n}\r\n\r\n// todo: merge with system tpye ?\r\nexport class ComplexTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _fields: IMap<IVariableDeclInstruction>;\r\n    protected _aligment: number;\r\n\r\n    constructor({ name = null, fields, aligment = 1 /* byte */, ...settings }: IComplexTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexType, ...settings });\r\n\r\n        this._name = name;\r\n        this._fields = {};\r\n        this._aligment = aligment;\r\n\r\n        this.addFields(fields.filter(field => !isNull(field)).map(field => Instruction.$withParent(field, this)));\r\n    }\r\n\r\n    \r\n    get writable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.calculatePaddings(false);\r\n    }\r\n\r\n\r\n    get aligment(): number {\r\n        return this._aligment;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return 0;\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return Object.values(this._fields);\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || types.hash(this);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        var code: string = \"struct \" + this._name + \"{\";\r\n\r\n        for (var i: number = 0; i < this.fields.length; i++) {\r\n            code += \"\\t\" + this.fields[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    private addField(variable: IVariableDeclInstruction): void {\r\n        this._fields[variable.name] = variable;\r\n    }\r\n\r\n    private addFields(fields: IVariableDeclInstruction[]): void {\r\n        for (var i = 0; i < fields.length; i++) {\r\n            this.addField(fields[i]);\r\n        }\r\n\r\n        this.calculatePaddings();\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return !!this.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields[fieldName] || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            if (semantic == field.semantic) {\r\n                return field;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            if (semantic == null || semantic == '') {\r\n                return true;\r\n            }\r\n            if (field.type.hasFieldWithoutSemantics()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        let fieldBySemantics: IMap<IVariableDeclInstruction> = {};\r\n\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            \r\n            if (isDefAndNotNull(fieldBySemantics[semantic])) {\r\n                return false;\r\n            }\r\n\r\n            fieldBySemantics[semantic] = field;\r\n\r\n            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private calculatePaddings(override = true): number {\r\n        const aligment = this._aligment;\r\n        let padding = 0;\r\n\r\n        let aligned = (offset, align) => (offset + (align - 1)) & ~(align - 1);\r\n\r\n        for (let i = 0; i < this.fields.length; i++) {\r\n            const varType = this.fields[i].type;\r\n            const varSize = varType.size;\r\n\r\n            if (varSize === instruction.UNDEFINE_SIZE) {\r\n                assert(false, 'cannot calc padding');\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n\r\n            let a = aligned(padding, aligment);\r\n            let b = aligned(padding + varSize, aligment);\r\n            if (b > a) {\r\n                padding = a;   \r\n            }\r\n            if (override)\r\n                varType.$overwritePadding(padding, aligment);\r\n            padding += varSize;   \r\n        }\r\n\r\n        return aligned(padding, aligment);\r\n    }\r\n}\r\n","import { EInstructionTypes, IConditionalExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types } from '@lib/fx/analisys/helpers';\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConditionalExprInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    left: ITypedInstruction;\r\n    right: ITypedInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represen boolExpr ? someExpr : someExpr\r\n * EMPTY_OPERATOR Instruction Instruction Instruction \r\n */\r\nexport class ConditionalExprInstruction extends ExprInstruction implements IConditionalExprInstruction {\r\n    protected _cond: IExprInstruction;\r\n    protected _leftValue: ITypedInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n\r\n    constructor({ cond, left, right, ...settings }: IConditionalExprInstructionSettings) {\r\n        // todo: do not use {left.type} here\r\n        super({ instrType: EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings});\r\n\r\n        console.assert(types.equals(left.type, right.type));\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n    }\r\n\r\n\r\n    get condition(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n    \r\n    get left(): ITypedInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '(';\r\n        code += this.condition.toCode();\r\n        code += '?';\r\n        code += this.left.toCode();\r\n        code += ':';\r\n        code += this.right.toCode();\r\n        code += ')';\r\n        return code;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.condition).isConst() &&\r\n            (<IExprInstruction>this.left).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IConstructorCallInstruction, IExprInstruction, IInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConstructorCallInstructionSettings extends IInstructionSettings {\r\n    ctor: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Resresnt ctor(arg1,..., argn)\r\n * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class ConstructorCallInstruction extends ExprInstruction implements IConstructorCallInstruction {\r\n    protected _args: IInstruction[];\r\n    protected _ctor: IVariableTypeInstruction;\r\n    \r\n\r\n    constructor({ ctor, args = null, ...settings }: IConstructorCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });\r\n\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this._ctor = Instruction.$withParent(ctor, this);\r\n    }\r\n\r\n    \r\n    get args() : IInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n    \r\n    get ctor(): IVariableTypeInstruction {\r\n        return this._ctor;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n\r\n        code += this.ctor.toCode();\r\n        code += \"(\";\r\n\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            if (!(<IExprInstruction>this.args[i]).isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IAnnotationInstruction, IDeclInstruction, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IDeclInstructionSettings extends IInstructionSettings {\r\n    readonly semantic?: string;\r\n    readonly annotation?: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport class DeclInstruction extends Instruction implements IDeclInstruction {\r\n    protected _semantic: string\r\n    protected _annotation: IAnnotationInstruction;\r\n    \r\n    constructor({ semantic = null, annotation = null, ...settings }: IDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Decl, ...settings });\r\n\r\n        this._semantic = semantic;\r\n        this._annotation = Instruction.$withParent(annotation, this);\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this._semantic;\r\n    }\r\n\r\n\r\n    get annotation(): IAnnotationInstruction {\r\n        return this._annotation;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return null;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return null;\r\n    }\r\n}\r\n","import { EInstructionTypes, IDeclInstruction, IDeclStmtInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IDeclStmtInstructionSettings extends IInstructionSettings {\r\n    declList?: IDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent TypeDecl or VariableDecl or VarStructDecl\r\n * EMPTY DeclInstruction\r\n */\r\nexport class DeclStmtInstruction extends StmtInstruction implements IDeclStmtInstruction {\r\n    private _declList: IDeclInstruction[];\r\n\r\n    \r\n    constructor({ declList = null, ...settings }: IDeclStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DeclStmt, ...settings });\r\n        \r\n        this._declList = (declList || []).map(decl => Instruction.$withParent(decl, this));\r\n    }\r\n\r\n\r\n    get declList(): IDeclInstruction[] {\r\n        return this._declList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code = '';\r\n        var declList = <IVariableDeclInstruction[]>this.declList;\r\n\r\n        for (var i: number = 0; i < this.declList.length; i++) {\r\n            code += declList[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { ITypedInstructionSettings, TypedInstruction } from \"@lib/fx/analisys/instructions/TypedInstruction\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprInstructionSettings extends ITypedInstructionSettings {\r\n    \r\n}\r\n\r\nexport class ExprInstruction extends TypedInstruction implements IExprInstruction {\r\n    protected _evalResult: any;\r\n\r\n    constructor({ ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Expr, ...settings });\r\n        this._evalResult = null;\r\n    }\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>super.type;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        // console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    isConstExpr(): boolean {\r\n        // todo: implement it properly\r\n        return true;\r\n    }\r\n}\r\n","import { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\nimport { EInstructionTypes, IExprInstruction, IExprStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprStmtInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Represent expr;\r\n * EMPTY_OPERTOR ExprInstruction \r\n */\r\nexport class ExprStmtInstruction extends StmtInstruction implements IExprStmtInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr, ...settings }: IExprStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ExprStmt, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n    toCode(): string {\r\n        return (this._expr ? this._expr.toCode() : '') + ';';\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_FLOAT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IFloatInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n}\r\n\r\nexport class FloatInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, scope, ...settings }: IFloatInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FloatExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_FLOAT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.value}${this.value % 1 === 0? '.': ''}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ECheckStage, EInstructionTypes, IExprInstruction, IForStmtInstruction, IStmtInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IForStmtInstructionSettings extends IInstructionSettings {\r\n    init?: ITypedInstruction;\r\n    cond?: IExprInstruction;\r\n    step?: IExprInstruction;\r\n    body?: IStmtInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent for(forInit forCond ForStep) stmt\r\n * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction\r\n */\r\nexport class ForStmtInstruction extends StmtInstruction implements IForStmtInstruction {\r\n    protected _init: ITypedInstruction;\r\n    protected _cond: IExprInstruction;\r\n    protected _step: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    constructor({ init = null, cond = null, step = null, body = null, ...settings }: IForStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ForStmt, ...settings });\r\n\r\n        this._init = Instruction.$withParent(init, this);\r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._step = Instruction.$withParent(step, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n    }\r\n\r\n\r\n    get init(): ITypedInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n\r\n    get step(): IExprInstruction {\r\n        return this._step;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"for(\";\r\n\r\n        code += this._init.toCode() + \";\";\r\n        code += this._cond.toCode() + \";\";\r\n        code += this._step.toCode() + \")\";\r\n        code += this._body.toCode();\r\n\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionCallInstructionSettings extends IExprInstructionSettings {\r\n    decl: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n    callee?: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Respresnt func(arg1,..., argn)\r\n * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class FunctionCallInstruction extends ExprInstruction implements IFunctionCallInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // helpers\r\n    readonly decl: IFunctionDeclInstruction; // << move to resolveDecl() method.\r\n    \r\n    constructor({ decl, args, callee, ...settings }: IFunctionCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionCallExpr, ...settings });\r\n        \r\n        this.callee = callee;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n\r\n    toCode(): string {\r\n        const { callee, decl: { def }, args } = this;\r\n        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IAttributeInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IStmtBlockInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionDeclInstructionSettings extends IDeclInstructionSettings {\r\n    def: IFunctionDefInstruction;\r\n    impl?: IStmtBlockInstruction;\r\n    attrs?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]\r\n * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction\r\n */\r\nexport class FunctionDeclInstruction extends DeclInstruction implements IFunctionDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n    \r\n\r\n    constructor({ def, impl = null, attrs = null, ...settings }: IFunctionDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDecl, ...settings });\r\n\r\n        this.def = Instruction.$withParent(def, this);\r\n        this.impl = Instruction.$withParent(impl, this);\r\n        this.attrs = (attrs || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.def.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this.def.id;\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this.def.semantic;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code = '';\r\n        code += this.def.toCode();\r\n        if (this.impl) {\r\n            code += this.impl.toCode();\r\n        } else {\r\n            code += ';';\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { DeclInstruction, IDeclInstructionSettings } from \"@lib/fx/analisys/instructions/DeclInstruction\";\r\nimport { Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { fn, types } from \"@lib/fx/analisys/helpers\";\r\n\r\nexport interface IFunctionDefInstructionSettings extends IDeclInstructionSettings {\r\n    returnType: IVariableTypeInstruction;\r\n    id: IIdInstruction;\r\n    paramList?: IVariableDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic]\r\n * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction\r\n */\r\nexport class FunctionDefInstruction extends DeclInstruction implements IFunctionDefInstruction {\r\n    readonly params: IVariableDeclInstruction[];\r\n    readonly returnType: IVariableTypeInstruction;\r\n    \r\n    protected _id: IIdInstruction;\r\n\r\n    constructor({ returnType, id, paramList = [], ...settings }: IFunctionDefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDef, ...settings });\r\n\r\n        this.params = paramList.map(param => Instruction.$withParent(param, this));\r\n        this.returnType = Instruction.$withParent(returnType, this);\r\n        this._id = Instruction.$withParent(id, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n    \r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        let def = types.signature(this.returnType) + \" \" + this.name + \"(\";\r\n\r\n        for (let i: number = 0; i < this.params.length; i++) {\r\n            def += types.signature(this.params[i].type) + \",\";\r\n        }\r\n\r\n        def += \")\";\r\n        // TODO: add semantic\r\n        return def;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        const { _id: id, returnType, params } = this;\r\n        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;\r\n    }\r\n}\r\n","import { EInstructionTypes, IIdExprInstruction, IIdInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdExprInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport class IdExprInstruction extends ExprInstruction implements IIdExprInstruction {\r\n    readonly id: IIdInstruction;\r\n    // helpers\r\n    readonly decl: IVariableDeclInstruction; // << move to resolveDecl() method.\r\n\r\n    constructor({ id, decl, ...settings }: IIdExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IdExpr, type: decl.type, ...settings });\r\n\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.type.isConst();\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this.decl.id.toCode();\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n}\r\n\r\nexport class IdInstruction extends Instruction implements IIdInstruction {\r\n    readonly name: string;\r\n\r\n    constructor({ name, ...settings }: IIdInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Id, ...settings });\r\n        this.name = name;\r\n    }\r\n    \r\n    \r\n    toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAttributeInstruction, IExprInstruction, IIfStmtInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IIfStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    conseq: IStmtInstruction;\r\n    contrary?: IStmtInstruction;\r\n    attrs?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent if(expr) stmt or if(expr) stmt else stmt\r\n * ( if || if_else ) Expr Stmt [Stmt]\r\n */\r\nexport class IfStmtInstruction extends StmtInstruction implements IIfStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n    \r\n    constructor({ cond, conseq, attrs = null, contrary = null, ...settings }: IIfStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IfStmt, ...settings });\r\n\r\n        this.cond = Instruction.$withParent(cond, this);\r\n        this.conseq = Instruction.$withParent(conseq, this);\r\n        this.contrary = Instruction.$withParent(contrary, this);\r\n        this.attrs = (attrs || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        if (isNull(this.contrary)) {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \")\";\r\n            code += this.conseq.toCode();\r\n        }\r\n        else {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \") \";\r\n            code += this.conseq.toCode();\r\n            code += \"else \";\r\n            code += this.contrary.toCode();\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { instruction, types } from \"@lib/fx/analisys/helpers\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, EScopeType, IExprInstruction, IInitExprInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents:\r\n *   int a[3] = { 1, 2, 3 };\r\n *              -----------\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    type: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\nexport class InitExprInstruction extends ExprInstruction implements IInitExprInstruction {\r\n    private _args: IExprInstruction[];\r\n\r\n    constructor({ type, args = [], ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_InitExpr, type, ...settings });\r\n        this._args = args.map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n\r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this.type.isNotBaseArray();\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = '';\r\n\r\n        if (!isNull(this.type)) {\r\n            code += this.type.toCode();\r\n        }\r\n        code += \"(\";\r\n\r\n        for (let i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        let bConst: boolean;\r\n        let args: IExprInstruction[] = <IExprInstruction[]>this.args;\r\n\r\n        for (let i: number = 0; i < args.length; i++) {\r\n            if (!args[i].isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param type The type of the variable for which the initializer was created.\r\n     */\r\n    // TODO: move it to Analysis.ts\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean {\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        if ((type.isNotBaseArray() && type.scope.type <= EScopeType.k_Global) ||\r\n            (type.isArray() && this.args.length > 1)) {\r\n\r\n            if (type.length === instruction.UNDEFINE_LENGTH ||\r\n                (type.isNotBaseArray() && this.args.length !== type.length) ||\r\n                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {\r\n                return false;\r\n            }\r\n\r\n            let arrayElementType = <IVariableTypeInstruction>type.arrayElementType;\r\n\r\n            for (let i = 0; i < this.args.length; i++) {\r\n                let testedInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (testedInstruction.instructionType === EInstructionTypes.k_InitExpr) {\r\n                    if (!(<IInitExprInstruction>testedInstruction).optimizeForVariableType(arrayElementType)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    // if (SystemScope.isSamplerType(arrayElementType)) {\r\n                    //     if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                    //         return false;\r\n                    //     }\r\n                    // }\r\n                    // else \r\n                    {\r\n                        if (!types.equals(testedInstruction.type, arrayElementType)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n        else {\r\n            let firstInstruction = <IExprInstruction>this.args[0];\r\n\r\n            if (this.args.length === 1 &&\r\n                firstInstruction.instructionType !== EInstructionTypes.k_InitExpr) {\r\n\r\n                // if (SystemScope.isSamplerType(type)) {\r\n                //     if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                //         return true;\r\n                //     }\r\n                //     else {\r\n                //         return false;\r\n                //     }\r\n                // }\r\n\r\n                // TODO: remove this hack!!\r\n                if (types.equals(firstInstruction.type, SystemScope.T_INT) || types.equals(firstInstruction.type, SystemScope.T_UINT)) {\r\n                    if (types.equals(type, SystemScope.T_INT) || types.equals(type, SystemScope.T_UINT)) {\r\n                        return true;\r\n                    }   \r\n                }\r\n\r\n                if (types.equals(firstInstruction.type, type)) {\r\n                    return true;\r\n                }\r\n                \r\n                return false;\r\n            }\r\n            else if (this.args.length === 1) {\r\n                return false;\r\n            }\r\n\r\n            let args = <IInitExprInstruction[]>this.args;\r\n            let fieldNameList = type.fields.map(f => f.name);\r\n\r\n            for (let i = 0; i < args.length; i++) {\r\n                let fieldType = type.getField(fieldNameList[i]).type;\r\n                if (!args[i].optimizeForVariableType(fieldType)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { ECheckStage, EInstructionTypes, IInstruction, IInstructionError, IScope, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport interface IInstructionSettings {\r\n    scope: IScope;\r\n\r\n    sourceNode?: IParseNode;\r\n    visible?: boolean;\r\n\r\n    instrType?: EInstructionTypes;\r\n}\r\n\r\nexport class Instruction implements IInstruction {\r\n    private _sourceNode: IParseNode;\r\n    private _instructionID: number;\r\n    private _instructionType: EInstructionTypes;\r\n    private _scope: IScope;\r\n    private _parent: IInstruction;\r\n    private _lastError: IInstructionError;\r\n\r\n    private static INSTRUCTION_COUNTER: number = 0;\r\n\r\n    constructor({\r\n        scope,\r\n        instrType/* = EInstructionTypes.k_Instruction*/,\r\n        sourceNode = null,\r\n        visible = true\r\n    }: IInstructionSettings) {\r\n\r\n        this._sourceNode = sourceNode;\r\n        this._instructionType = instrType;\r\n        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);\r\n        this._scope = scope;\r\n        this._parent = null;\r\n        this._lastError = null;\r\n    }\r\n\r\n\r\n    get parent(): IInstruction {\r\n        // console.assert(this._parent, \"Parent is not defined!\");\r\n        return this._parent;\r\n    }\r\n\r\n\r\n    get instructionType(): EInstructionTypes {\r\n        console.assert(this._instructionType != EInstructionTypes.k_Instruction, \"Instruction type 'k_Instruction' is forbidden.\");\r\n        return this._instructionType;\r\n    }\r\n\r\n    get instructionName(): string {\r\n        return EInstructionTypes[this.instructionType];\r\n    }\r\n\r\n\r\n    get instructionID(): number {\r\n        return this._instructionID;\r\n    }\r\n\r\n\r\n    get scope(): IScope {\r\n        if (!isNull(this._scope)) {\r\n            return this._scope;\r\n        }\r\n\r\n        if (!isNull(this.parent)) {\r\n            return this.parent.scope;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    get sourceNode(): IParseNode {\r\n        return this._sourceNode;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    $withParent<T extends IInstruction>(parent: IInstruction | null): T {\r\n        console.assert(this._parent == null, \"parent redefenition detected!\");\r\n        if (this.instructionType === EInstructionTypes.k_SystemType && (this as any).name === 'float' && this._parent == null && parent != null) {\r\n            debugger;\r\n        }\r\n        this._parent = parent;\r\n        // todo: remove this hack!\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    // An auxiliary function created to maintain the clarity of the code.\r\n    $withNoParent<T extends IInstruction>(): T {\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    static $withParent<T extends IInstruction>(child: T, parent: IInstruction): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withParent(parent);\r\n    }\r\n\r\n    static $withNoParent<T extends IInstruction>(child: T): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withNoParent();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { EInstructionTypes, IInstruction, IInstructionCollector } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IInstructionCollectorSettings extends IInstructionSettings {\r\n    instructions?: IInstruction[];\r\n}\r\n\r\nexport class InstructionCollector extends Instruction implements IInstructionCollector {\r\n    protected _instructions: IInstruction[];\r\n\r\n    constructor({ instructions = [], ...settings }: IInstructionCollectorSettings) {\r\n        super({ instrType: EInstructionTypes.k_Collector, ...settings });\r\n\r\n        this._instructions = instructions;\r\n    }\r\n\r\n\r\n    get instructions(): IInstruction[] {\r\n        return this._instructions;\r\n    }\r\n\r\n    push(instr: IInstruction): void {\r\n        this._instructions.push(instr);\r\n    }\r\n\r\n    toCode(): string {\r\n        let code = \"\";\r\n        for (const instr of  this.instructions) {\r\n            switch (instr.instructionType) {\r\n                case EInstructionTypes.k_VariableDecl:\r\n                    code += instr.toCode() + ';\\n';\r\n                break;\r\n                default:\r\n                    code += instr.toCode() + '\\n';\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_INT, T_UINT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IIntInstructionSettings extends IInstructionSettings {\r\n    signed: boolean;\r\n    base: number;\r\n    exp: number;\r\n    heximal?: boolean;\r\n}\r\n\r\nexport class IntInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly signed: boolean;\r\n    readonly base: number;\r\n    readonly exp: number;\r\n    readonly heximal: boolean;\r\n\r\n\r\n    constructor({ base, signed, exp, heximal = false, scope, ...settings }: IIntInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IntExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes \r\n            type: VariableTypeInstruction.wrapAsConst(signed ? T_INT : T_UINT, SCOPE), scope, ...settings });\r\n\r\n        this.base = base;\r\n        this.exp = exp;\r\n        this.signed = signed;\r\n        this.heximal = heximal;\r\n\r\n        if (!signed) {\r\n            this.base >>>= 0;\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return (this.base * Math.pow(10, this.exp));\r\n    }\r\n\r\n    toString(): string {\r\n        return `${this.heximal ? '0x' : ''}${this.base.toString(this.heximal ? 16 : 10).toUpperCase()}${this.exp !== 0? `e${this.exp}`: ''}${this.signed? '': 'u'}`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IExprInstruction, ILogicalExprInstruction, ILogicalOperator } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ILogicalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ILogicalOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent boolExpr && || boolExpr\r\n * (&& | ||) Instruction Instruction\r\n */\r\nexport class LogicalExprInstruction extends ExprInstruction implements ILogicalExprInstruction {\r\n    protected _operator: ILogicalOperator;\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n\r\n    constructor({ left, right, operator, ...settings }: ILogicalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_LogicalExpr, type: SystemScope.T_BOOL, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): ILogicalOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this.left.toCode();\r\n        sCode += this.operator;\r\n        sCode += this.right.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { T_NULL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n\r\nexport class NullInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n\r\n    constructor({ scope, ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_NullExpr, type: T_NULL, scope, ...settings });\r\n    }\r\n\r\n    get value(): number {\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return `NULL`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { isNull, isNumber } from \"@lib/common\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, IIdInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPassInstructionSettings extends IDeclInstructionSettings {\r\n    vertexShader?: IFunctionDeclInstruction;\r\n    pixelShader?: IFunctionDeclInstruction;\r\n    renderStates?: IMap<ERenderStateValues>;\r\n    id?: IIdInstruction;\r\n}\r\n\r\n\r\nexport class PassInstruction extends DeclInstruction implements IPassInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _vertexShader: IFunctionDeclInstruction;\r\n    protected _pixelShader: IFunctionDeclInstruction;\r\n    protected _passStateMap: IMap<ERenderStateValues>;\r\n\r\n    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }: IPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PassDecl, ...settings });\r\n\r\n        this._passStateMap = {};\r\n        PassInstruction.clearRenderStateMap(this._passStateMap);\r\n        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);\r\n \r\n        this._vertexShader = Instruction.$withNoParent(vertexShader);\r\n        this._pixelShader = Instruction.$withNoParent(pixelShader);\r\n\r\n        this._id = id;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get vertexShader(): IFunctionDeclInstruction {\r\n        return this._vertexShader;\r\n    }\r\n\r\n    get pixelShader(): IFunctionDeclInstruction {\r\n        return this._pixelShader;\r\n    }\r\n\r\n\r\n    getState(state: ERenderStates): ERenderStateValues {\r\n        return this._passStateMap[state];\r\n    }\r\n\r\n    get renderStates(): IMap<ERenderStateValues> {\r\n        return this._passStateMap;\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static copyRenderStateMap(from: IMap<ERenderStateValues>, to: IMap<ERenderStateValues>): void {\r\n        if (isNull(from)) {\r\n            return;\r\n        }\r\n\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { to[rs] = from[rs] || to[rs] });\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static clearRenderStateMap(map: IMap<ERenderStateValues>): void {\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { map[rs] = ERenderStateValues.UNDEF });\r\n    }\r\n\r\n\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixArithmeticInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type PostfixOperator = \"++\" | \"--\";\r\n\r\nexport interface IPostfixArithmeticInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: PostfixOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr ++\r\n * (-- | ++) Instruction\r\n */\r\nexport class PostfixArithmeticInstruction extends ExprInstruction implements IPostfixArithmeticInstruction {\r\n    protected _operator: PostfixOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    \r\n    constructor({ expr, operator, ...settings }: IPostfixArithmeticInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });\r\n\r\n        this._operator = operator;\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n\r\n        code += this.expr.toCode();\r\n        code += this.operator;\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixIndexInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixIndexInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    index: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent element[index]\r\n * EMPTY_OPERATOR Instruction ExprInstruction\r\n */\r\nexport class PostfixIndexInstruction extends ExprInstruction implements IPostfixIndexInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly index: IExprInstruction;\r\n\r\n    constructor({ element, index, ...settings }: IPostfixIndexInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_PostfixIndexExpr, \r\n            type: (element.type as IVariableTypeInstruction).arrayElementType, ...settings });\r\n            \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.index = Instruction.$withParent(index, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.element.toCode()}[${this.index.toCode()}]`;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.element.isConst() && this.index.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IIdExprInstruction, IPostfixPointInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixPointInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr.id\r\n * EMPTY_OPERATOR Instruction IdInstruction\r\n */\r\nexport class PostfixPointInstruction extends ExprInstruction implements IPostfixPointInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n\r\n\r\n    constructor({ element, postfix, ...settings }: IPostfixPointInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });\r\n        \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.postfix = Instruction.$withParent(postfix, this);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.element.toCode()}.${this.postfix.toCode()}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.element.isConst();\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IIdInstruction, IPresetInstruction, IPresetPropertyInstruction } from \"@lib/idl/IInstruction\";\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPresetInstructionSettings extends IDeclInstructionSettings {\r\n    id?: IIdInstruction;\r\n    props: IPresetPropertyInstruction[];\r\n}\r\n\r\nexport class PresetInstruction extends DeclInstruction implements IPresetInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _props: IPresetPropertyInstruction[];\r\n\r\n    constructor({ props, id = null, ...settings }: IPresetInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PresetDecl, ...settings });\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._props = props.map(prop => Instruction.$withParent(prop, this));\r\n    }\r\n\r\n    \r\n    get id(): IIdInstruction { \r\n        return this._id; \r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get props(): IPresetPropertyInstruction[] {\r\n        return this._props;\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.id} = {\\n${this.props.map(prop => prop.toCode()).join(';\\n')}\\n}`;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IIdInstruction, IPresetPropertyInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPresetInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    args: IExprInstruction[];\r\n}\r\n\r\nexport class PresetProperty extends Instruction implements IPresetPropertyInstruction {\r\n    readonly id: IIdInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    constructor({ id, args, ...settings }: IPresetInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PresetProperty, ...settings });\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.args = args.map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    resolveDeclaration(): IVariableDeclInstruction {\r\n        return this.scope.findVariable(this.id.name);\r\n    }\r\n\r\n    toCode() {\r\n        return `${this.id} = { ${this.args.map(arg => arg.toCode()).join(',')} }`;\r\n    }\r\n}\r\n","import { EInstructionTypes, IProvideInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IProvideInstructionSettings extends IInstructionSettings {\r\n    moduleName: string;\r\n}\r\n\r\nexport class ProvideInstruction extends Instruction implements IProvideInstruction {\r\n    protected _value: string;\r\n\r\n    constructor({ moduleName, ...settings }: IProvideInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Provide, ...settings });\r\n        \r\n        this._value = moduleName;\r\n    }\r\n\r\n    get moduleName(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction, types } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport class ProxyTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _host: ITypeInstruction;\r\n\r\n    constructor(settings: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ProxyType, ...settings });\r\n        this._host = null;\r\n    }\r\n\r\n    get host(): ITypeInstruction {\r\n        return this._host;\r\n    }\r\n    \r\n    get writable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this.isResolved() ? this.host.name : 'auto';\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.isResolved() ? this.host.size : instruction.UNDEFINE_SIZE;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.host;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return this.isResolved() ? this.host.arrayElementType : null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return this.isResolved() ? this.host.length : instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.isResolved() ? this.host.fields : [];\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isResolved(): boolean {\r\n        return !isNull(this.host);\r\n    }\r\n\r\n\r\n    resolve(host: ITypeInstruction) {\r\n        this._host = host;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.isResolved() ? this.host.toString() : this.name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.isResolved() ? this.host.toDeclString() : null;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.isResolved() ? this.host.toCode() : this.name;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this.isResolved() ? this.host.isArray() : false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return this.isResolved() ? this.host.isNotBaseArray() : false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return this.isResolved() ? this.host.isComplex() : false;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getField(fieldName) : null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.isResolved() ? this.host.getMethod(methodName, args) : null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;\r\n    }\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IRelationalExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { assert } from \"console\";\r\n\r\nexport type RelationOperator = \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\";\r\n\r\nexport interface IRelationalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: RelationOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr == != < > <= >= someExpr\r\n * (==|!=|<|>|<=|>=) Instruction Instruction\r\n */\r\nexport class RelationalExprInstruction extends ExprInstruction implements IRelationalExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: RelationOperator;\r\n\r\n\r\n    constructor({ left, right, operator, instrType, ...settings }: IRelationalExprInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_RelationalExpr, \r\n            type: SystemScope[`T_BOOL${left.type.length > 1 ? left.type.length : ''}`], \r\n            ...settings \r\n        });\r\n        this._leftOperand = left;\r\n        this._rightOperand = right;\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    get operator(): RelationOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        code += this.left.toCode();\r\n        code += ` ${this.operator} `;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IReturnOperator, IReturnStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IReturnStmtInstructionSettings extends IInstructionSettings {\r\n    expr?: IExprInstruction;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Represent return expr;\r\n * return ExprInstruction\r\n */\r\nexport class ReturnStmtInstruction extends StmtInstruction implements IReturnStmtInstruction {\r\n    protected _operator: IReturnOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr = null, ...settings }: IReturnStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ReturnStmt, ...settings });\r\n        \r\n        this._operator = \"return\";\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get operator(): IReturnOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        if (this.expr) {\r\n            return \"return \" + this.expr.toCode() + \";\";\r\n        }\r\n        else {\r\n            return \"return;\";\r\n        }\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n/**\r\n * Represent empty statement only semicolon ;\r\n * ;\r\n */\r\nexport class SemicolonStmtInstruction extends StmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SemicolonStmt, ...settings });\r\n    }\r\n\r\n    toCode(): string {\r\n        return \";\";\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IStateBlockInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents this kind of initialization:\r\n *   DepthStencilState depthState { DepthEnable = TRUE; };\r\n *                                ^^^^^^^^^^^^^^^^^^^^^^^\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    props?: Object;\r\n    blocks?: IStateBlockInstruction[];\r\n}\r\n\r\nexport class StateBlockInstruction extends ExprInstruction implements IStateBlockInstruction {\r\n    readonly props: Object;\r\n    readonly blocks: IStateBlockInstruction[];\r\n\r\n    constructor({ type, blocks = null, props = null, ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StateBlockExpr, type, ...settings });\r\n        this.props = props;\r\n        this.blocks = blocks;\r\n    }\r\n\r\n    toCode(): string {\r\n        console.error(`not implemeted`);\r\n        return null;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IStmtBlockInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IStmtBlockInstructionSettings extends IInstructionSettings {\r\n    stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent {stmts}\r\n * EMPTY_OPERATOR StmtInstruction ... StmtInstruction\r\n */\r\nexport class StmtBlockInstruction extends StmtInstruction implements IStmtBlockInstruction {\r\n    protected _stmtList: IStmtInstruction[];\r\n\r\n    \r\n    constructor({ stmtList, ...settings }: IStmtBlockInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StmtBlock, ...settings });\r\n        this._stmtList = stmtList.map(stmt => Instruction.$withParent(stmt, this));\r\n    }\r\n\r\n\r\n    get stmtList(): IStmtInstruction[] {\r\n        return this._stmtList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"{\" + \"\\n\";\r\n\r\n        for (var i: number = 0; i < this.stmtList.length; i++) {\r\n            code += \"\\t\" + this.stmtList[i].toCode() + \"\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represent all kind of statements\r\n */\r\nexport class StmtInstruction extends Instruction implements IStmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Stmt, ...settings });\r\n    }    \r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_STRING } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IStringInstructionSettings extends IInstructionSettings {\r\n    value: string;\r\n}\r\n\r\n\r\nexport class StringInstruction extends ExprInstruction implements ILiteralInstruction<string> {\r\n    protected _value: string;\r\n\r\n\t/**\r\n\t * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n\t */\r\n    constructor({ value, scope, ...settings }: IStringInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StringExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_STRING, SCOPE), scope, ...settings });\r\n        \r\n        this._value = value;\r\n    }\r\n\r\n    \r\n    get value(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { FunctionDeclInstruction, IFunctionDeclInstructionSettings } from \"./FunctionDeclInstruction\";\r\n\r\nexport interface ISystemFunctionInstructionSettings extends IFunctionDeclInstructionSettings {\r\n    vertex?: boolean;\r\n    pixel?: boolean;\r\n}\r\n\r\n\r\nexport class SystemFunctionInstruction extends FunctionDeclInstruction implements IFunctionDeclInstruction {\r\n    protected _bForVertex: boolean;\r\n    protected _bForPixel: boolean;\r\n    // protected _bForCompute;\r\n    // protected _bForGeometry;\r\n    \r\n     constructor({ vertex = true, pixel = true, impl = null, ...settings }: ISystemFunctionInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemFunctionDecl, impl: null, ...settings });\r\n        \r\n        assert(isNull(impl));\r\n\r\n        this._bForVertex = vertex;\r\n        this._bForPixel = pixel;\r\n    }\r\n\r\n\r\n    checkVertexUsage(): boolean {\r\n        return this._bForVertex;\r\n    }\r\n\r\n\r\n    checkPixelUsage(): boolean {\r\n        return this._bForPixel;\r\n    }\r\n\r\n\r\n    $makeVertexCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForVertex = val;\r\n    }\r\n\r\n\r\n    $makePixelCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForPixel = val;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { fn, instruction, types } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISystemTypeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    \r\n    size: number;\r\n    elementType?: ITypeInstruction;\r\n    length?: number;\r\n    \r\n    fields?: IVariableDeclInstruction[];\r\n    methods?: IFunctionDeclInstruction[];\r\n    \r\n    writable?: boolean;\r\n    readable?: boolean;\r\n}\r\n\r\nexport class SystemTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _size: number;\r\n    protected _elementType: ITypeInstruction;\r\n    protected _length: number;\r\n    \r\n    protected _fields: IVariableDeclInstruction[];\r\n    protected _methods: IFunctionDeclInstruction[];\r\n    \r\n    protected _bIsWritable: boolean;\r\n    protected _bIsReadable: boolean;\r\n\r\n    constructor({\r\n        name, \r\n        size = 0,\r\n        elementType = null, \r\n        length = 1, \r\n        fields = [],\r\n        methods = [],\r\n        writable = true, \r\n        readable = true, \r\n        ...settings\r\n    }: ISystemTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemType, ...settings });\r\n\r\n        this._name = name;\r\n        this._size = size;\r\n        this._elementType = Instruction.$withNoParent(elementType);\r\n        this._length = length;\r\n        this._fields = [];\r\n        this._methods = [];\r\n        this._bIsWritable = writable;\r\n        this._bIsReadable = readable;\r\n        fields.forEach(field => this.addField(field));\r\n        methods.forEach(method => this.addMethod(method));\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        return this._bIsWritable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        return this._bIsReadable;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get size(): number {\r\n        if (this.isArray()) {\r\n            if (this.length === instruction.UNDEFINE_LENGTH) {\r\n                return instruction.UNDEFINE_LENGTH;\r\n            }\r\n            return this.arrayElementType.size * this.length;\r\n        }\r\n        return this._size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n\r\n    get arrayElementType(): ITypeInstruction {\r\n        return this._elementType;\r\n    }\r\n\r\n\r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this._fields;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this._methods;\r\n    }\r\n\r\n\r\n    toDeclString(): string {\r\n        console.warn('@pure_virtual');\r\n        return '';\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this.arrayElementType);\r\n    }\r\n\r\n\r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainPointer(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || types.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields.find(field => field.name === fieldName) || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction | undefined | null {\r\n        const list = this._methods.filter(method => method.name === methodName);\r\n        return fn.matchList(list, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        console.error(\"@undefined_behavior\");\r\n        return null;\r\n    }\r\n\r\n\r\n    /** internal api */\r\n    addField(field: IVariableDeclInstruction): void {\r\n        console.assert(this.getField(field.name) === null);\r\n        this._fields.push(Instruction.$withParent(field, this));\r\n    }\r\n\r\n    /** internal api */\r\n    addMethod(method: IFunctionDeclInstruction): void {\r\n        console.assert(isNull(this.getMethod(method.name, method.def.params.map(param => param.type))));\r\n        this._methods.push(Instruction.$withParent(method, this));\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IPass11Instruction, IPresetInstruction, ITechnique11Instruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings extends IDeclInstructionSettings {\r\n    name: string;\r\n    passes: IPass11Instruction[];\r\n    presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport class Technique11Instruction extends DeclInstruction implements ITechnique11Instruction {\r\n    protected _name: string;\r\n\r\n    readonly passes: IPass11Instruction[];\r\n\r\n    constructor({ name, passes, presets, ...settings }: ITechniqueInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Technique11Decl, ...settings });\r\n        \r\n        this._name = name;\r\n        this.passes = passes?.map(pass => Instruction.$withParent(pass, this));\r\n    }\r\n\r\n    get name() {\r\n        return this._name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IPassInstruction, IPresetInstruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings<PassType extends IPassInstruction> extends IDeclInstructionSettings {\r\n    name: string;\r\n    techniqueType: ETechniqueType;\r\n    passes: PassType[];\r\n    presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport class TechniqueInstruction<PassType extends IPassInstruction> extends DeclInstruction implements ITechniqueInstruction {\r\n    readonly type: ETechniqueType;\r\n    readonly passes: PassType[];\r\n\r\n    readonly presets: IPresetInstruction[];\r\n\r\n    protected _name: string;\r\n\r\n    constructor({ name, techniqueType, passes, presets, ...settings }: ITechniqueInstructionSettings<PassType>) {\r\n        super({ instrType: EInstructionTypes.k_TechniqueDecl, ...settings });\r\n        \r\n        this._name = name;\r\n        this.passes = passes?.map(pass => Instruction.$withParent(pass, this));\r\n        this.type = techniqueType;\r\n\r\n        this.presets = presets;\r\n    }\r\n\r\n\r\n    get name() {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    isValid(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isDef, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypeDeclInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypeDeclInstruction extends DeclInstruction implements ITypeDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypeDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypeDecl, ...settings });\r\n        this.type =  Instruction.$withParent(type, this);\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return this.type.toDeclString() + \";\";\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport class TypedInstruction extends Instruction implements ITypedInstruction {\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Typed, ...settings });\r\n        \r\n        this._type = Instruction.$withNoParent(type);\r\n\r\n        // todo: remove this check\r\n        if (isNull(this._type)) {\r\n            console.warn(\"Something goes wrong! Type is not specified!\", this);\r\n        }\r\n    }\r\n\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","import { assert, isDef } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedefInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedefInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n    alias: string;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypedefInstruction extends DeclInstruction implements ITypedefInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly alias: string;\r\n\r\n    constructor({ type, alias, ...settings }: ITypedefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypedefDecl, ...settings });\r\n        this.type =  Instruction.$withNoParent(type);\r\n        this.alias = alias;\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type?.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return `typedef ${this.type.toDeclString()} ${this.alias};`;\r\n    }\r\n}\r\n","import { SCOPE, T_BOOL } from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IUnaryExprInstruction, IUnaryOperator } from '@lib/idl/IInstruction';\r\n\r\nimport { ExprInstruction } from './ExprInstruction';\r\nimport { IInstructionSettings, Instruction } from './Instruction';\r\nimport { VariableTypeInstruction } from './VariableTypeInstruction';\r\n\r\nexport interface IUnaryExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: IUnaryOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent + - ! ++ -- expr\r\n * (+|-|!|++|--|) Instruction\r\n */\r\nexport class UnaryExprInstruction extends ExprInstruction implements IUnaryExprInstruction {\r\n    protected _operator: IUnaryOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, operator, ...settings }: IUnaryExprInstructionSettings) {\r\n        super({\r\n            instrType: EInstructionTypes.k_UnaryExpr,\r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: operator === '!'\r\n                ? VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE)\r\n                : expr.type,\r\n            ...settings\r\n        });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): IUnaryOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = '';\r\n        sCode += this.operator;\r\n        sCode += this.expr.toCode();\r\n\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","import { assert, isNull } from '@lib/common';\r\nimport { EInstructionTypes, IExprInstruction, IIdInstruction, IInitExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from './DeclInstruction';\r\nimport { Instruction } from './Instruction';\r\n\r\n// import * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface IVariableDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: IVariableTypeInstruction;\r\n    init?: IExprInstruction;\r\n\r\n    // EVariableUsageFlags\r\n    usageFlags?: number;\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport enum EVariableUsageFlags {\r\n    k_Local     = 0x01,\r\n    k_Global    = 0x02,\r\n    k_Argument  = 0x04,\r\n    k_Cbuffer   = 0x08\r\n}\r\n\r\n/**\r\n * Represent type var_name [= init_expr]\r\n * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction\r\n */\r\nexport class VariableDeclInstruction extends DeclInstruction implements IVariableDeclInstruction {\r\n\r\n    protected _id: IIdInstruction;\r\n    protected _type: IVariableTypeInstruction;\r\n    protected _initExpr: IExprInstruction;\r\n    protected _usageFlags: number;\r\n\r\n \r\n    constructor({ id, type, init = null, usageFlags = 0, ...settings }: IVariableDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withNoParent(type);\r\n        this._initExpr = Instruction.$withParent(init, this);\r\n        this._usageFlags = usageFlags;\r\n\r\n        assert(!this.isParameter() || (isNull(this.parent) || this.parent.instructionType == EInstructionTypes.k_FunctionDef));\r\n        assert(this.isLocal() || !this.isLocal());\r\n        assert(!this.isParameter() || this.isLocal());\r\n    }\r\n\r\n\r\n    get usageFlags(): number {\r\n        return this._usageFlags;\r\n    }\r\n\r\n\r\n    get initExpr(): IExprInstruction {\r\n        return this._initExpr;\r\n    }\r\n\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>this._type;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    isGlobal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Global);\r\n    }\r\n\r\n\r\n    isLocal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Local);\r\n    }\r\n\r\n\r\n    isParameter(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);\r\n    }\r\n\r\n\r\n    isField(): boolean {\r\n        if (isNull(this.parent)) {\r\n            return false;\r\n        }\r\n\r\n        const parentType = this.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableType ||\r\n            parentType === EInstructionTypes.k_ComplexType ||\r\n            parentType === EInstructionTypes.k_SystemType) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    isConstant(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Cbuffer) || this.type.isUniform();\r\n    }\r\n    \r\n    toCode(): string {\r\n        var code = '';        \r\n        code = this.type.toCode();\r\n        code += ' ' + this.id.toCode();\r\n\r\n        if (this.type.isNotBaseArray()) {\r\n            var iLength: number = this.type.length;\r\n            code += '[' + iLength + ']';\r\n        }\r\n\r\n        if (!isNull(this.initExpr) &&\r\n            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?\r\n            !this.type.isUniform()) {\r\n            code += '=' + this.initExpr.toCode();\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { assert, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { expression, instruction, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, ILiteralInstruction, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IVariableTypeInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n    usages?: IVariableUsage[];\r\n    arrayIndex?: IExprInstruction;\r\n    padding?: number;\r\n\r\n    readable?: boolean;\r\n    writable?: boolean;\r\n}\r\n\r\nexport class VariableTypeInstruction extends Instruction implements IVariableTypeInstruction {\r\n    protected _subType: ITypeInstruction;\r\n    protected _usageList: IVariableUsage[];\r\n\r\n    /** overrites for defautl read/write tests (for internal usage) */\r\n    protected _isWritable: boolean;\r\n    protected _isReadable: boolean;\r\n\r\n    protected _arrayIndexExpr: IExprInstruction;\r\n    protected _arrayElementType: IVariableTypeInstruction;\r\n    protected _padding: number;\r\n    protected _aligment: number;\r\n\r\n    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = instruction.UNDEFINE_PADDING, ...settings }: IVariableTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableType, ...settings });\r\n\r\n        type = Instruction.$withNoParent(type);\r\n        this._usageList = [];\r\n\r\n        let instrType = type.instructionType;\r\n        if (instrType === EInstructionTypes.k_ProxyType ||\r\n            instrType === EInstructionTypes.k_SystemType ||\r\n            instrType === EInstructionTypes.k_ComplexType) {\r\n            this._subType = type;\r\n        }\r\n        else {\r\n            let varType = <IVariableTypeInstruction>type;\r\n            // TODO: review this code\r\n            if (!varType.isNotBaseArray()) {\r\n                this._subType = varType.subType;\r\n                varType.usages.forEach(usage => this.addUsage(usage))\r\n            }\r\n            else {\r\n                this._subType = type;\r\n            }\r\n        }\r\n\r\n        assert(isDefAndNotNull(this._subType));\r\n        assert(isDefAndNotNull(this._usageList));\r\n\r\n        this._isWritable = writable;\r\n        this._isReadable = readable;\r\n\r\n        this._arrayIndexExpr = null;\r\n        this._arrayElementType = null;\r\n        this._padding = padding;\r\n        this._aligment = 1;\r\n\r\n        if (arrayIndex) {\r\n            // todo: add support for v[][10]\r\n            // todo: move elements construction to analyzer, don't make it implicitly\r\n            this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: this.subType, usages: this._usageList }), this);\r\n            this._arrayIndexExpr = Instruction.$withParent(arrayIndex, this);\r\n        } \r\n        // todo: array element type must be constructed with proper usages and read/write flags!\r\n        // else if (this.isArray()) {\r\n        //     this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: type.arrayElementType, usages: this._usageList }), this);\r\n        // }\r\n\r\n        usages.forEach(usage => this.addUsage(usage));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.baseType.name;\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        if (!this._isWritable) {\r\n            return false;\r\n        }\r\n\r\n        if (/*(this.isArray() && !this.isBase()) || */this.isUniform()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        // check for usages.includes('in') ?\r\n\r\n        return this.subType.writable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        if (!this._isReadable) {\r\n            return false;\r\n        }\r\n\r\n        if (this.usages.includes(\"out\")) {\r\n            return false;\r\n        }\r\n\r\n        return this.subType.readable;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this.subType.methods;\r\n    }\r\n\r\n\r\n    get aligment(): number {\r\n        return this._aligment;\r\n    }\r\n\r\n    // TODO: move to helpers\r\n    get size(): number {\r\n        if (!isNull(this._arrayElementType)) {\r\n            const size = types.alignSize(this._arrayElementType.size, this.aligment);\r\n            const length = this.length;\r\n            if (length === instruction.UNDEFINE_LENGTH || size === instruction.UNDEFINE_SIZE) {\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n            return size * length;\r\n        }\r\n        // return type.alignSize(this.subType.size, this.aligment);\r\n        return this.subType.size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.subType.baseType;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        if (!this.isNotBaseArray()) { // not a user defined array like arr[10]\r\n            // for ex. if type is float3x4 then length is 3\r\n            return this.subType.length;\r\n        }\r\n\r\n        // IP: arrays like float[]?\r\n        if (this.isNotBaseArray() && isNull(this._arrayElementType)) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        // arrays like float[10]\r\n        const expr = this._arrayIndexExpr;\r\n        if (instruction.isLiteral(expr)) {\r\n            return Number((<ILiteralInstruction<number>>expr).value);\r\n        }\r\n\r\n        // arrays like float[N];\r\n        const len = expression.evalConst(expr);\r\n        return len < 0 ? instruction.UNDEFINE_LENGTH: len;\r\n    }\r\n\r\n\r\n    get padding(): number {\r\n        return this._padding;\r\n    }\r\n\r\n\r\n    get arrayElementType(): IVariableTypeInstruction {\r\n        if (!this.isArray()) {\r\n            return null;\r\n        }\r\n\r\n        // todo: fix this.subType.arrayElementType!\r\n        return this._arrayElementType || <IVariableTypeInstruction>this.subType.arrayElementType;\r\n    }\r\n\r\n\r\n    get usages(): IVariableUsage[] {\r\n        let usages =  [ ...this._usageList ];\r\n        let subType = this.subType;\r\n        while (subType && subType.instructionType === EInstructionTypes.k_VariableType) {\r\n            const vtype = <IVariableTypeInstruction>subType;\r\n            // todo: remove duplicates\r\n            usages = [ ...usages, ...vtype.usages ];\r\n            subType = vtype.subType;\r\n        }\r\n\r\n        return usages;\r\n    }\r\n\r\n\r\n    get subType(): ITypeInstruction {\r\n        return this._subType;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.subType.fields;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        // TODO: fix this condition\r\n        return this.name || this.subType.toString() || types.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = \"\";\r\n        if (!isNull(this._usageList)) {\r\n            for (let i: number = 0; i < this._usageList.length; i++) {\r\n                code += this._usageList[i] + \" \";\r\n            }\r\n        }\r\n\r\n        code += this.subType.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.subType.toDeclString();\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isArray();\r\n    }\r\n\r\n\r\n    // Returns true if the type is user defined array.\r\n    // like an ordinary array: int a[5]\r\n    // not a base array like: float4/int3 etc.\r\n    isNotBaseArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isNotBaseArray();\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this.subType.isComplex();\r\n    }\r\n\r\n\r\n    isUniform(): boolean {\r\n        return this.usages.includes(\"uniform\");\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.usages.includes(\"const\");\r\n    }\r\n\r\n\r\n    isUnsigned(): boolean {\r\n        return this.usages.includes(\"unsigned\");\r\n    }\r\n\r\n\r\n    isStatic(): boolean {\r\n        return this.usages.includes(\"static\");\r\n    }\r\n\r\n\r\n    $overwritePadding(padding: number, aligment: number) {\r\n        this._padding = padding;\r\n        this._aligment = aligment;\r\n    }\r\n    \r\n\r\n    private addUsage(usage: IVariableUsage): void {\r\n        if (!this.usages.includes(usage)) {\r\n            this._usageList.push(usage);\r\n        }\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.subType.hasFieldWithSematics(semantic);\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.subType.hasAllUniqueSemantics();\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.subType.hasFieldWithoutSemantics();\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages? atleast readable/writable\r\n        return this.subType.getField(fieldName);\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.subType.getMethod(methodName, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    /**\r\n     * Helpers\r\n     */\r\n\r\n    // TODO: move to type.ts\r\n    /** @deprecated */\r\n    static wrap(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope });\r\n    }\r\n\r\n    // TODO: move to type.ts\r\n    /** @deprecated */\r\n    static wrapAsConst(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IStmtInstruction, IWhileStmtInstruction, IDoWhileOperator } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n\r\n\r\nexport interface IWhileStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    body: IStmtInstruction;\r\n    operator: IDoWhileOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent while(expr) stmt\r\n * ( while || do_while) ExprInstruction StmtInstruction\r\n */\r\nexport class WhileStmtInstruction extends StmtInstruction implements IWhileStmtInstruction {\r\n    protected _operator: IDoWhileOperator;\r\n    protected _cond: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    \r\n    constructor({ cond, body, operator, ...settings }: IWhileStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_WhileStmt, ...settings });\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this.cond;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n\r\n    get operator(): IDoWhileOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        if (this.operator === \"while\") {\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \")\";\r\n            code += this.body.toCode();\r\n        }\r\n        else {\r\n            code += \"do\";\r\n            code += this.body.toCode();\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \");\";\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IDrawStmtInstruction, IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface IDrawInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args: IExprInstruction[];\r\n}\r\n\r\n\r\nexport class DrawInstruction extends StmtInstruction implements IDrawStmtInstruction {\r\n    readonly name: string;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    constructor({ name, args, ...settings }: IDrawInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DrawStmt, ...settings });\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `draw ${this.name};`;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IStructDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ICompileExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { T_VOID } from \"@lib/fx/analisys/SystemScope\";\r\n\r\nimport { ITechniqueInstructionSettings, TechniqueInstruction } from \"@lib/fx/analisys/instructions/TechniqueInstruction\";\r\nimport { types } from \"@lib/fx/analisys/helpers\"\r\n\r\n// prohibition of explicitly indicating the type of technique\r\nexport interface IPartFxInstructionSettings extends Omit<ITechniqueInstructionSettings<IPartFxPassInstruction>, \"techniqueType\"> {\r\n    spawnRoutine: ICompileExprInstruction;\r\n    initRoutine: ICompileExprInstruction;\r\n    updateRoutine: ICompileExprInstruction;\r\n    particle: ITypeInstruction;\r\n    capacity?: number;\r\n}\r\n\r\n// var s: IPartFxInstructionSettings;\r\n// s.te\r\n\r\nexport class PartFxInstruction extends TechniqueInstruction<IPartFxPassInstruction> implements IPartFxInstruction {\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }: IPartFxInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxDecl, techniqueType: ETechniqueType.k_PartFx, ...settings });\r\n\r\n        this.spawnRoutine = spawnRoutine;\r\n        this.initRoutine = initRoutine;\r\n        this.updateRoutine = updateRoutine;\r\n        this.particle = particle;\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    isValid() {\r\n        if (!this.spawnRoutine) {\r\n            console.error(`no spawn routine found`);\r\n            return false;\r\n        }\r\n\r\n        if (!types.equals(this.spawnRoutine.function.def.returnType, T_VOID)) {\r\n            if (!this.initRoutine) {\r\n                console.error(`init routine must be defined if regular spawner is used`);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this.updateRoutine) {\r\n            console.error(`no update routine found`);\r\n            return false;\r\n        }\r\n\r\n        const particleCheck = !!this.particle;\r\n        const passCheck = this.passes && this.passes.filter((pass: IPartFxPassInstruction) => pass.isValid()).length > 0;\r\n        return particleCheck && passCheck;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { IPassInstructionSettings, PassInstruction } from \"@lib/fx/analisys/instructions/PassInstruction\";\r\nimport { EInstructionTypes, ICompileExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPassDrawMode, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nexport interface IPartFxPassInstructionSettings extends IPassInstructionSettings {\r\n    sorting?: boolean;\r\n    prerenderRoutine: ICompileExprInstruction;\r\n    geometry: string;\r\n    instanceCount?: number;\r\n    drawMode?: EPassDrawMode;\r\n}\r\n\r\n\r\nexport class PartFxPassInstruction extends PassInstruction implements IPartFxPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly geometry: string;\r\n    readonly instanceCount: number;\r\n    readonly drawMode: EPassDrawMode;\r\n\r\n    constructor({ sorting = false, instanceCount = 1, drawMode = EPassDrawMode.k_Auto, prerenderRoutine, geometry, ...settings }: IPartFxPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxPass, ...settings });\r\n        \r\n        this.sorting = sorting;\r\n        this.prerenderRoutine = prerenderRoutine;\r\n        this.geometry = geometry;\r\n        this.instanceCount = instanceCount;\r\n        this.drawMode = drawMode;\r\n    }\r\n\r\n    get particleInstance(): ITypeInstruction {\r\n        if (isNull(this.prerenderRoutine)) {\r\n            return null;\r\n        }\r\n\r\n        return this.prerenderRoutine.function.def.params[1].type.subType;\r\n    }\r\n\r\n    isValid(): boolean {\r\n        return !!this.particleInstance && !!this.prerenderRoutine;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface ISpawnInstructionSettings extends IInstructionSettings {\r\n    count: IExprInstruction;\r\n    args: IExprInstruction[];\r\n    name: string;\r\n}\r\n\r\n\r\nexport class SpawnInstruction extends StmtInstruction implements ISpawnStmtInstruction {\r\n    readonly count: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n    readonly name: string;\r\n    \r\n    // private _fx: IPartFxInstruction = null;\r\n    // private _init: IFunctionDeclInstruction = null;\r\n\r\n    constructor({ count, name, args, ...settings }: ISpawnInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SpawnStmt, ...settings });\r\n\r\n        this.count = count;\r\n        this.args = args;\r\n        this.name = name;\r\n    }    \r\n\r\n    \r\n    // get fx(): IPartFxInstruction {\r\n    //     return this._fx;\r\n    // }\r\n\r\n\r\n    // get init(): IFunctionDeclInstruction {\r\n    //     return this._init;\r\n    // }\r\n\r\n\r\n    toCode(): string {\r\n        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;\r\n    }\r\n\r\n    // // delayed resolve of the spawn instructions\r\n    // $resolve(fx: IPartFxInstruction, init: IFunctionDeclInstruction): void {\r\n    //     this._fx = fx;\r\n    //     this._init = init;\r\n    // }\r\n}\r\n","import { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\n\r\nclass AppendStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('AppendStructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                const type = new VariableTypeInstruction({ type: args[0], scope });\r\n                const id = new IdInstruction({ scope, name: 'Append' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            const id = new IdInstruction({ scope, name: 'Append' });\r\n            const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            const func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default AppendStructuredBufferTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass BufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('Buffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!isBase(args[0])) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\nexport default BufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!isBase(args[0])) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default RWBufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass RWStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWStructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'IncrementCounter' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'DecrementCounter' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default RWStructuredBufferTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWTexture1DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(RWTexture1DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'RWTexture1D';\r\n}\r\n\r\n\r\nexport default RWTexture1DTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass RWTexture2DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(RWTexture2DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, });\r\n    }\r\n\r\n    static TYPE_NAME = 'RWTexture2D';\r\n}\r\n\r\n\r\nexport default RWTexture2DTemplate;\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass StructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('StructuredBuffer');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\nexport default StructuredBufferTemplate;\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture2DArrayTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture2DArrayTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dx' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dy' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleGrad' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture2DArray';\r\n}\r\n\r\nexport default Texture2DArrayTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture2DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture2DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const rtName = `${type.isArray() ? type.arrayElementType.name : type.name}4`;\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(rtName), scope });\r\n            let id = new IdInstruction({ scope, name: 'Gather' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f1 = scope.findType(\"float\");\r\n                const type = new VariableTypeInstruction({ type: f1, scope });\r\n                const id = new IdInstruction({ scope, name: 'lod' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleLevel' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dx' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f2 = scope.findType(\"float2\");\r\n                const type = new VariableTypeInstruction({ type: f2, scope });\r\n                const id = new IdInstruction({ scope, name: 'dy' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleGrad' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'mipLevel' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'width' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'height' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'GetDimensions' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let int3 = scope.findType(\"int3\");\r\n                const type = new VariableTypeInstruction({ type: int3, scope });\r\n                const id = new IdInstruction({ scope, name: 'location' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: elementType, scope });\r\n            let id = new IdInstruction({ scope, name: 'Load' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture2D';\r\n}\r\n\r\nexport default Texture2DTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass Texture3DTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(Texture3DTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'Texture3D';\r\n}\r\n\r\n\r\nexport default Texture3DTemplate;\r\n\r\n","import { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass TextureCubeArrayTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(TextureCubeArrayTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'TextureCubeArray';\r\n}\r\n\r\n\r\nexport default TextureCubeArrayTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { types, instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\nimport { isBase } from \"./utils\";\r\n\r\nclass TextureCubeTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super(TextureCubeTemplate.TYPE_NAME);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length > 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const type = args.length > 0 ? args[0] : scope.findType('float4');\r\n\r\n        if (!isBase(type)) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = type;\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'Sample' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let samplerState = scope.findType(\"SamplerState\");\r\n                const type = new VariableTypeInstruction({ type: samplerState, scope });\r\n                const id = new IdInstruction({ scope, name: 'samplerState' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float3\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'uv' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let f3 = scope.findType(\"float\");\r\n                const type = new VariableTypeInstruction({ type: f3, scope });\r\n                const id = new IdInstruction({ scope, name: 'lod' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type, scope });\r\n            let id = new IdInstruction({ scope, name: 'SampleLevel' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n\r\n    static TYPE_NAME = 'TextureCube';\r\n}\r\n\r\nexport default TextureCubeTemplate;\r\n\r\n","import { IScope, ITypeInstruction, IVariableDeclInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { parseUintLiteral } from \"@lib/fx/analisys/system/utils\";\r\nimport TypeTemplate from \"./TypeTemplate\";\r\n\r\nclass TriMeshTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('TriMesh');\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1;\r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'vertCount' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'faceCount' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'GetDimensions' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'vert' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: elementType, scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadVertex' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint3\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadFace' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                const { base, signed, heximal, exp } = parseUintLiteral(\"6u\");\r\n                const arrayIndex = new IntInstruction({ scope, base, exp, signed, heximal });\r\n\r\n                const uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'adjacency' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadGSAdjacency' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                let uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope });\r\n                const id = new IdInstruction({ scope, name: 'face' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param1 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param1);\r\n            }\r\n\r\n            {\r\n                const { base, signed, heximal, exp } = parseUintLiteral(\"3u\");\r\n                const arrayIndex = new IntInstruction({ scope, base, exp, signed, heximal });\r\n\r\n                const uint = scope.findType(\"uint\");\r\n                const type = new VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });\r\n                const id = new IdInstruction({ scope, name: 'adjacency' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param2 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param2);\r\n            }\r\n\r\n\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'LoadFaceAdjacency' });\r\n            let def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            let func = new SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    }\r\n}\r\n\r\n\r\nexport default TriMeshTemplate;\r\n\r\n","import { IScope, ITypeInstruction, ITypeTemplate } from \"@lib/idl/IInstruction\";\r\n\r\nclass TypeTemplate implements ITypeTemplate {\r\n    readonly name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    typeName(args?: ITypeInstruction[]): string {\r\n        if (args && args.length > 0) {\r\n            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;\r\n        }\r\n        return this.name;\r\n    }\r\n}\r\n\r\nexport default TypeTemplate;\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { generateSystemFunction, TEMPLATE_TYPE, USAGE_CONTROL_FLOW, USAGE_PS } from \"./utils\";\r\n\r\n\r\n// TODO: rework system function templates for better readability\r\nexport function addSystemFunctions(scope: IScope): void {\r\n    // todo: rework setup of system functions according with microsoft docs.\r\n    generateSystemFunction(scope, \"dot\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul\r\n    // TODO: add support for int|uint|bool based vectors \r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(scope, \"mul\", TEMPLATE_TYPE, [\"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float4\", [\"float4\", TEMPLATE_TYPE], [\"float4x4\", \"float4x3\", \"float4x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float3\", [\"float3\", TEMPLATE_TYPE], [\"float3x4\", \"float3x3\", \"float3x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float2\", [\"float2\", TEMPLATE_TYPE], [\"float2x4\", \"float2x3\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float4\", [TEMPLATE_TYPE, \"float4\"], [\"float4x4\", \"float3x4\", \"float2x4\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float3\", [TEMPLATE_TYPE, \"float3\"], [\"float4x3\", \"float3x3\", \"float2x3\"]);\r\n    generateSystemFunction(scope, \"mul\", \"float2\", [TEMPLATE_TYPE, \"float2\"], [\"float4x2\", \"float3x2\", \"float2x2\"]);\r\n\r\n    /**\r\n     * scalar = int|uint|float\r\n     * vector = vector<int|uint|float, n>, n = 2,3,4\r\n     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4\r\n     * \r\n     * scalar mul(scalar, scalar)\r\n     * vector mul(scalar, vector)\r\n     * vector mul(vector, scalar)\r\n     * vector mul(vector, vector)\r\n     * matrix mul(scalar, matrix)\r\n     * matrix mul(matrix, scalar)\r\n     * vector mul(vector, matrix)\r\n     * vector mul(matrix, vector)\r\n     * matrix mul(matrix, matrix)\r\n     */\r\n\r\n    generateSystemFunction(scope, \"mod\", \"float\", [\"float\", \"float\"], null);\r\n    generateSystemFunction(scope, \"floor\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"round\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"ceil\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"fract\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"normalize\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"length\", \"float\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"cross\", \"float3\", [\"float3\", \"float3\"], null);\r\n    generateSystemFunction(scope, \"reflect\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    \r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    generateSystemFunction(scope, \"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"fmod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"ldexp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"reversebits\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"uint\"]);\r\n    \r\n\r\n    generateSystemFunction(scope, \"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\", \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"pow\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"exp\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"exp2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"log\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"log2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"inversesqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    // generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    /** @deprecated (SM4) */\r\n    generateSystemFunction(scope, \"not\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"distance\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"lessThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"lessThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"lessThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"lessThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"equal\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"equal\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"equal\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(scope, \"equal\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"notEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"notEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"notEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(scope, \"notEqual\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"greaterThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"greaterThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"radians\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"degrees\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"cos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"sincos\", \"void\", [TEMPLATE_TYPE, `out ${TEMPLATE_TYPE}`, `out ${TEMPLATE_TYPE}`], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"tan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"asin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"acos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"atan2\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler\", \"float2\"], null);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler2D\", \"float2\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float4\"], null);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\"], null);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\"], null);\r\n\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2D\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    // generateSystemFunction(scope, \"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, false, true);\r\n\r\n    // generateSystemFunction(scope, \"tex2DLod\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DLod\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"texCUBELod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    // generateSystemFunction(scope, \"texCUBELod\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, true, false);\r\n\r\n    //OES_standard_derivatives\r\n\r\n    generateSystemFunction(scope, \"dFdx\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"dFdy\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"width\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"fwidth\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(scope, \"smoothstep\", \"float3\", [\"float3\", \"float3\", \"float3\"], null);\r\n\r\n    generateSystemFunction(scope, \"smoothstep\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"smoothstep\", TEMPLATE_TYPE, [\"float\", \"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"step\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"clip\", \"void\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"], USAGE_PS);\r\n\r\n    generateSystemFunction(scope, \"frac\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(scope, \"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"saturate\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(scope, \"asfloat\", \"float\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asfloat\", \"float4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asint\", \"int4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"asuint\", \"uint\", [TEMPLATE_TYPE], [\"float\", \"int\", \"bool\", \"uint\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint2\", [TEMPLATE_TYPE], [\"float2\", \"int2\", \"bool2\", \"uint2\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint3\", [TEMPLATE_TYPE], [\"float3\", \"int3\", \"bool3\", \"uint3\"]);\r\n    generateSystemFunction(scope, \"asuint\", \"uint4\", [TEMPLATE_TYPE], [\"float4\", \"int4\", \"bool4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(scope, \"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\"]);\r\n    // generateSystemFunction(scope, \"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\"]);\r\n\r\n    generateSystemFunction(scope, \"f16tof32\", \"float\", [\"uint\"], null);\r\n    generateSystemFunction(scope, \"f32tof16\", \"uint\", [\"float\"], null);\r\n\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int\", \"uint\", \"float\", \"bool\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int2\", \"uint2\", \"float2\", \"bool2\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int3\", \"uint3\", \"float3\", \"bool3\", \"float3x3\"]);\r\n    generateSystemFunction(scope, \"any\", \"bool\", [TEMPLATE_TYPE], [\"int4\", \"uint4\", \"float4\", \"bool4\", \"float4x4\"]);\r\n\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int\", \"uint\", \"float\", \"bool\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int2\", \"uint2\", \"float2\", \"bool2\", \"float2x2\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int3\", \"uint3\", \"float3\", \"bool3\", \"float3x3\"]);\r\n    generateSystemFunction(scope, \"all\", \"bool\", [TEMPLATE_TYPE], [\"int4\", \"uint4\", \"float4\", \"bool4\", \"float4x4\"]);\r\n\r\n    // DX12\r\n\r\n    generateSystemFunction(scope, \"WaveGetLaneIndex\", \"uint\", [], [\"void\"]);\r\n    generateSystemFunction(scope, \"WaveActiveBallot\", \"uint4\", [TEMPLATE_TYPE], [\"bool\"]);\r\n\r\n    // control flow\r\n    generateSystemFunction(scope, \"SetVertexShader\", \"void\", [TEMPLATE_TYPE], [\"VertexShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetPixelShader\", \"void\", [TEMPLATE_TYPE], [\"PixelShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetGeometryShader\", \"void\", [TEMPLATE_TYPE], [\"GeometryShader\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetDepthStencilState\", \"void\", [TEMPLATE_TYPE, \"int\"], [\"DepthStencilState\"], USAGE_CONTROL_FLOW);\r\n    generateSystemFunction(scope, \"SetBlendState\", \"void\", [TEMPLATE_TYPE], [\"BlendState\"], USAGE_CONTROL_FLOW);                        // todo: use correct arguments\r\n    generateSystemFunction(scope, \"SetRasterizerState\", \"void\", [TEMPLATE_TYPE], [\"RasterizerState\"], USAGE_CONTROL_FLOW);              // todo: use correct arguments\r\n}\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport AppendStructuredBufferTemplate from \"./AppendStructuredBufferTemplate\";\r\nimport BufferTemplate from \"./BufferTemplate\";\r\nimport RWBufferTemplate from \"./RWBufferTemplate\";\r\nimport RWStructuredBufferTemplate from \"./RWStructuredBufferTemplate\";\r\nimport RWTexture1DTemplate from \"./RWTexture1DTemplate\";\r\nimport RWTexture2DTemplate from \"./RWTexture2DTemplate\";\r\nimport StructuredBufferTemplate from \"./StructuredBufferTemplate\";\r\nimport Texture2DArrayTemplate from \"./Texture2DArrayTemplate\";\r\nimport Texture2DTemplate from \"./Texture2DTemplate\";\r\nimport Texture3DTemplate from \"./Texture3DTemplate\";\r\nimport TextureCubeArrayTemplate from \"./TextureCubeArrayTemplate\";\r\nimport TextureCubeTemplate from \"./TextureCubeTemplate\";\r\nimport TriMeshTemplate from \"./TriMeshTemplate\";\r\nimport { generateSystemType } from \"./utils\";\r\n\r\n\r\nexport function addSystemTypeBuiltin(scope: IScope) {\r\n    generateSystemType(scope, \"SamplerState\", 4);\r\n    generateSystemType(scope, \"SamplerComparisonState\", 4);\r\n    generateSystemType(scope, \"DepthStencilState\", 4);\r\n    generateSystemType(scope, \"BlendState\", 4);\r\n    generateSystemType(scope, \"RasterizerState\", 4);\r\n\r\n    generateSystemType(scope, \"VertexShader\", 4);\r\n    generateSystemType(scope, \"PixelShader\", 4);\r\n    generateSystemType(scope, \"ComputeShader\", 4);\r\n    generateSystemType(scope, \"GeometryShader\", 4);\r\n    generateSystemType(scope, \"HullShader\", 4);\r\n    generateSystemType(scope, \"DomainShader\", 4);\r\n\r\n    // generateSystemType(scope, \"texture\");\r\n    // generateSystemType(scope, \"sampler\");\r\n    // generateSystemType(scope, \"sampler2D\");\r\n    // generateSystemType(scope, \"samplerCUBE\");\r\n\r\n    scope.addTypeTemplate(new BufferTemplate);\r\n    scope.addTypeTemplate(new RWBufferTemplate);\r\n    scope.addTypeTemplate(new RWStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new AppendStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new StructuredBufferTemplate);\r\n\r\n    scope.addTypeTemplate(new TriMeshTemplate);\r\n\r\n    scope.addTypeTemplate(new RWTexture1DTemplate);\r\n    scope.addTypeTemplate(new RWTexture2DTemplate);\r\n    // TODO: RWTexture3D\r\n\r\n    // TODO: Texture1D\r\n    scope.addTypeTemplate(new Texture2DTemplate);\r\n    scope.addTypeTemplate(new Texture3DTemplate);\r\n    scope.addTypeTemplate(new TextureCubeTemplate);\r\n    // TODO: Texture1DArray\r\n    scope.addTypeTemplate(new Texture2DArrayTemplate);\r\n    // TODO: Texture3DArray\r\n    scope.addTypeTemplate(new TextureCubeArrayTemplate);\r\n\r\n    // produce default Texture2D type\r\n    const templateTexture2D = scope.findTypeTemplate(Texture2DTemplate.TYPE_NAME);\r\n    const typeTexture2D = templateTexture2D.produceType(scope, []);\r\n    scope.addType(typeTexture2D);\r\n\r\n    // produce default TextureCube type\r\n    const templateTextureCube = scope.findTypeTemplate(TextureCubeTemplate.TYPE_NAME);\r\n    const typeTextureCube = templateTextureCube.produceType(scope, []);\r\n    scope.addType(typeTextureCube);\r\n\r\n    // produce default Texture3D type\r\n    const templateTexture3D = scope.findTypeTemplate(Texture3DTemplate.TYPE_NAME);\r\n    const typeTexture3D = templateTexture3D.produceType(scope, []);\r\n    scope.addType(typeTexture3D);\r\n\r\n    // produce default Texture2DArray type\r\n    const templateTexture2DArray = scope.findTypeTemplate(Texture2DArrayTemplate.TYPE_NAME);\r\n    const typeTexture2DArray = templateTexture2DArray.produceType(scope, []);\r\n    scope.addType(typeTexture2DArray);\r\n\r\n    // produce default TextureCubeArray type\r\n    const templateTextureCubeArray = scope.findTypeTemplate(TextureCubeArrayTemplate.TYPE_NAME);\r\n    const typeTextureCubeArray = templateTextureCubeArray.produceType(scope, []);\r\n    scope.addType(typeTextureCubeArray);\r\n\r\n    // produce default RWTexture1D type\r\n    const templateRWTexture1D = scope.findTypeTemplate(RWTexture1DTemplate.TYPE_NAME);\r\n    const typeRWTexture1D = templateRWTexture1D.produceType(scope, []);\r\n    scope.addType(typeRWTexture1D);\r\n\r\n    // produce default RWTexture2D type\r\n    const templateRWTexture2D = scope.findTypeTemplate(RWTexture2DTemplate.TYPE_NAME);\r\n    const typeRWTexture2D = templateRWTexture2D.produceType(scope, []);\r\n    scope.addType(typeRWTexture2D);\r\n}\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { getSystemType, generateSystemType } from \"./utils\";\r\n\r\nexport function addSystemTypeMatrix(scope: IScope): void {\r\n    let float2 = getSystemType(scope, \"float2\");\r\n    let float3 = getSystemType(scope, \"float3\");\r\n    let float4 = getSystemType(scope, \"float4\");\r\n\r\n    let int2 = getSystemType(scope, \"int2\");\r\n    let int3 = getSystemType(scope, \"int3\");\r\n    let int4 = getSystemType(scope, \"int4\");\r\n\r\n    let uint2 = getSystemType(scope, \"uint2\");\r\n    let uint3 = getSystemType(scope, \"uint3\");\r\n    let uint4 = getSystemType(scope, \"uint4\");\r\n\r\n    let bool2 = getSystemType(scope, \"bool2\");\r\n    let bool3 = getSystemType(scope, \"bool3\");\r\n    let bool4 = getSystemType(scope, \"bool4\");\r\n\r\n    generateSystemType(scope, \"float2x2\", -1, float2, 2);\r\n    generateSystemType(scope, \"float2x3\", -1, float3, 2);\r\n    generateSystemType(scope, \"float2x4\", -1, float4, 2);\r\n\r\n    generateSystemType(scope, \"float3x2\", -1, float2, 3);\r\n    generateSystemType(scope, \"float3x3\", -1, float3, 3);\r\n    generateSystemType(scope, \"float3x4\", -1, float4, 3);\r\n\r\n    generateSystemType(scope, \"float4x2\", -1, float2, 4);\r\n    generateSystemType(scope, \"float4x3\", -1, float3, 4);\r\n    generateSystemType(scope, \"float4x4\", -1, float4, 4);\r\n\r\n    generateSystemType(scope, \"int2x2\", -1, int2, 2);\r\n    generateSystemType(scope, \"int2x3\", -1, int3, 2);\r\n    generateSystemType(scope, \"int2x4\", -1, int4, 2);\r\n\r\n    generateSystemType(scope, \"int3x2\", -1, int2, 3);\r\n    generateSystemType(scope, \"int3x3\", -1, int3, 3);\r\n    generateSystemType(scope, \"int3x4\", -1, int4, 3);\r\n\r\n    generateSystemType(scope, \"int4x2\", -1, int2, 4);\r\n    generateSystemType(scope, \"int4x3\", -1, int3, 4);\r\n    generateSystemType(scope, \"int4x4\", -1, int4, 4);\r\n\r\n    generateSystemType(scope, \"bool2x2\", -1, bool2, 2);\r\n    generateSystemType(scope, \"bool2x3\", -1, bool3, 2);\r\n    generateSystemType(scope, \"bool2x4\", -1, bool4, 2);\r\n\r\n    generateSystemType(scope, \"bool3x2\", -1, bool2, 3);\r\n    generateSystemType(scope, \"bool3x3\", -1, bool3, 3);\r\n    generateSystemType(scope, \"bool3x4\", -1, bool4, 3);\r\n\r\n    generateSystemType(scope, \"bool4x2\", -1, bool2, 4);\r\n    generateSystemType(scope, \"bool4x3\", -1, bool3, 4);\r\n    generateSystemType(scope, \"bool4x4\", -1, bool4, 4);\r\n}\r\n\r\n","import { IScope } from \"@lib/idl/IInstruction\";\r\nimport { defineTypeAlias, generateSystemType, USE_STRICT_HALF_TYPE } from \"./utils\";\r\n\r\nexport function addSystemTypeScalar(scope: IScope) {\r\n    generateSystemType(scope, \"void\", 0);\r\n    generateSystemType(scope, \"int\", 4);\r\n    generateSystemType(scope, \"uint\", 4);\r\n    generateSystemType(scope, \"bool\", 4);\r\n    generateSystemType(scope, \"float\", 4);\r\n    generateSystemType(scope, \"string\", 4/* pointer to string */);\r\n    generateSystemType(scope, \"null_t\", 4/* pointer */);\r\n\r\n    // TODO: use dedicated type for half\r\n    defineTypeAlias(scope, \"float\", \"half\");\r\n    console.assert(USE_STRICT_HALF_TYPE === false);\r\n}\r\n\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { types } from '@lib/fx/analisys/helpers';\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { CodeContext, CodeEmitter } from \"@lib/fx/translators/CodeEmitter\";\r\nimport { EAnalyzerErrors } from \"@lib/idl/EAnalyzerErrors\";\r\nimport {\r\n    EInstructionTypes, IAttributeInstruction, ICbufferInstruction, IFunctionDeclInstruction, IFunctionDefInstruction,\r\n    IRegister, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableUsage\r\n} from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { AttributeInstruction } from \"../instructions/AttributeInstruction\";\r\nimport { FunctionDefInstruction } from \"../instructions/FunctionDefInstruction\";\r\nimport { SystemFunctionInstruction } from \"../instructions/SystemFunctionInstruction\";\r\n\r\nexport const USE_STRICT_HALF_TYPE = false;\r\nexport const TEMPLATE_TYPE = \"template\";\r\n\r\nexport function parseUintLiteral(value: string) {\r\n    const match = value.match(/^((0x[a-fA-F0-9]{1,8}?|[0-9]+)(e([+-]?[0-9]+))?)([ulUL]*)$/);\r\n    assert(match, `cannot parse uint literal: ${value}`);\r\n\r\n    const signed = match[5].toLowerCase().indexOf('u') === -1;\r\n    const exp = Number(match[4] || '0');\r\n    const base = Number(match[2]);\r\n    assert(!Number.isNaN(base));\r\n\r\n    const heximal = value[1] === 'x';\r\n\r\n    return { signed, exp, base, heximal };\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nexport function getSystemType(scope: IScope, typeName: string): SystemTypeInstruction {\r\n    //boolean, string, float and others\r\n    let type = <SystemTypeInstruction>scope.findType(typeName);\r\n    assert(!type || (type.instructionType === EInstructionTypes.k_SystemType));\r\n    return type;\r\n}\r\n\r\n\r\nexport function generateSystemType(scope: IScope, name: string, size?: number, elementType?: ITypeInstruction,\r\n    length?: number, fields?: IVariableDeclInstruction[], methods?: IFunctionDeclInstruction[]): SystemTypeInstruction;\r\nexport function generateSystemType(scope: IScope, ...args: any[]): SystemTypeInstruction {\r\n    let name: string;\r\n    let size: number;\r\n    let elementType: ITypeInstruction;\r\n    let length: number;\r\n    let fields: IVariableDeclInstruction[];\r\n    let methods: IFunctionDeclInstruction[];\r\n\r\n    [name, size, elementType, length, fields, methods] = args;\r\n\r\n    if (getSystemType(scope, name)) {\r\n        console.error(`type already exists: ${name}`);\r\n        return null;\r\n    }\r\n\r\n    const type = new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    scope.addType(type);\r\n\r\n    return type;\r\n}\r\n\r\nexport function defineTypeAlias(scope: IScope, typeName: string, aliasName: string) {\r\n    scope.addTypeAlias(typeName, aliasName);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function addFieldsToVectorFromSuffixObject(scope: IScope, fields: IVariableDeclInstruction[], suffixMap: IMap<boolean>, baseType: string) {\r\n    for (let suffix in suffixMap) {\r\n        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : \"\");\r\n        const fieldBaseType = getSystemType(scope, fieldTypeName);\r\n\r\n        assert(fieldBaseType);\r\n\r\n        const fieldId = new IdInstruction({ scope, name: suffix });\r\n        const fieldType = new VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] })\r\n\r\n        fields.push(new VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function generateSuffixLiterals(literals: string, output: IMap<boolean> = {}, depth: number = 0): IMap<boolean> {\r\n    if (depth >= /*literals.length*/4) {\r\n        return output;\r\n    }\r\n\r\n    if (depth === 0) {\r\n        for (let i = 0; i < literals.length; i++) {\r\n            output[literals[i]] = true;\r\n        }\r\n\r\n        depth = 1;\r\n    }\r\n\r\n    const outputKeys = Object.keys(output);\r\n\r\n    for (let i = 0; i < literals.length; i++) {\r\n        for (let j = 0; j < outputKeys.length; j++) {\r\n            if (outputKeys[j].indexOf(literals[i]) !== -1) {\r\n                output[outputKeys[j] + literals[i]] = false;\r\n            }\r\n            else {\r\n                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;\r\n            }\r\n        }\r\n    }\r\n\r\n    depth++;\r\n\r\n    return generateSuffixLiterals(literals, output, depth);\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function isTemplate(typename: string): boolean {\r\n    return typename.split(' ').slice(-1)[0] === TEMPLATE_TYPE;\r\n}\r\n\r\nexport function parseType(scope: IScope, typename: string, typevalue: string = null) {\r\n    assert(typevalue !== TEMPLATE_TYPE);\r\n    const usagesType = (typevalue ? typename.replace(TEMPLATE_TYPE, typevalue) : typename).split(' ');\r\n    const hash = usagesType.slice(-1)[0];\r\n    const type = getSystemType(scope, hash);\r\n    const usages = <IVariableUsage[]>usagesType.slice(0, -1);\r\n\r\n    assert(type !== null);\r\n    usages.forEach(usage => assert(['in', 'out', 'inout'].indexOf(usage) !== -1));\r\n\r\n    return { type, usages, hash };\r\n}\r\n\r\ntype ITypeDesc = ReturnType<typeof parseType>;\r\n\r\n\r\nconst systemFunctionHashMap: IMap<boolean> = {};\r\n\r\nfunction _emitException(message: string) {\r\n    throw new Error(message);\r\n}\r\n\r\n// todo: rewrite it!\r\nfunction _error(code: number, info = {}): void {\r\n    _emitException(EAnalyzerErrors[code]);\r\n}\r\n\r\n\r\nexport const USAGE_VS = 0x01;\r\nexport const USAGE_PS = 0x02;\r\nexport const USAGE_GS = 0x04;\r\nexport const USAGE_CS = 0x08;\r\nexport const USAGE_HS = 0x10;\r\nexport const USAGE_DS = 0x20;\r\nexport const USAGE_CONTROL_FLOW = 0x100;\r\n\r\nfunction generateSystemFunctionInstance(scope: IScope, retType: ITypeDesc, name: string, paramTypes: ITypeDesc[], usage: number) {\r\n    const paramList = paramTypes.map((typeDesc, n) => {\r\n        return new VariableDeclInstruction({\r\n            type: new VariableTypeInstruction({\r\n                type: typeDesc.type,\r\n                usages: typeDesc.usages,\r\n                scope\r\n            }),\r\n            id: new IdInstruction({ name: `p${n}`, scope }),\r\n            scope\r\n        });\r\n    });\r\n\r\n    const returnType = new VariableTypeInstruction({\r\n        type: retType.type,\r\n        usages: retType.usages,\r\n        scope\r\n    });\r\n\r\n    const pixel = !!(usage & USAGE_PS);\r\n    const vertex = !!(usage & USAGE_VS);\r\n    const extern = !!(usage & USAGE_CONTROL_FLOW);\r\n    const attrs: IAttributeInstruction[] = [];\r\n    if (extern) {\r\n        attrs.push(new AttributeInstruction({ scope, name: 'extern' }));\r\n    }\r\n\r\n    const id = new IdInstruction({ scope, name });\r\n    const def = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n    const func = new SystemFunctionInstruction({ scope, def, pixel, vertex, attrs });\r\n\r\n    scope.addFunction(func);\r\n}\r\n\r\n\r\n/**\r\n * Exampler:\r\n *  generateSystemFunction(\"dot\", \"dot($1,$2)\",   \"float\",    [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n *                         name   translationExpr returnType  argsTypes                       templateTypes\r\n */\r\nexport function generateSystemFunction(\r\n    scope: IScope,\r\n    name: string,\r\n    returnTypeName: string,\r\n    paramTypeNames: string[],\r\n    templateTypes: string[], usage: number = USAGE_VS | USAGE_PS): void {\r\n\r\n    if (!isNull(templateTypes)) {\r\n        for (let i = 0; i < templateTypes.length; i++) {\r\n            let funcHash = name + \"(\";\r\n            let returnType = parseType(scope, returnTypeName, templateTypes[i]);\r\n            let paramTypes = <ITypeDesc[]>[];\r\n\r\n            for (let j = 0; j < paramTypeNames.length; j++) {\r\n                const typeDesc = parseType(scope, paramTypeNames[j], templateTypes[i]);\r\n                paramTypes.push(typeDesc);\r\n                funcHash += typeDesc.hash + \",\";\r\n            }\r\n\r\n            funcHash += \")\";\r\n\r\n            if (systemFunctionHashMap[funcHash]) {\r\n                _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n            }\r\n\r\n            generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);\r\n            systemFunctionHashMap[funcHash] = true;\r\n        }\r\n    }\r\n    else {\r\n        if (isTemplate(returnTypeName)) {\r\n            _emitException(\"Bad return type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n        }\r\n\r\n        let funcHash = name + \"(\";\r\n        let returnType = parseType(scope, returnTypeName);\r\n        let paramTypes = <ITypeDesc[]>[];\r\n\r\n        for (let i = 0; i < paramTypeNames.length; i++) {\r\n            if (isTemplate(paramTypeNames[i])) {\r\n                _emitException(\"Bad argument type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n            }\r\n            else {\r\n                const typeDesc = parseType(scope, paramTypeNames[i]);\r\n                paramTypes.push(typeDesc);\r\n                funcHash += typeDesc.hash + \",\";\r\n            }\r\n        }\r\n\r\n        funcHash += \")\";\r\n\r\n        if (systemFunctionHashMap[funcHash]) {\r\n            _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n        }\r\n\r\n        generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);\r\n        systemFunctionHashMap[funcHash] = true;\r\n    }\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport const SCALAR_TYPES = [\r\n    'bool',\r\n    'int',\r\n    'uint',\r\n    'half',\r\n    'float'\r\n];\r\n\r\n\r\nexport const INT_TYPES = [\r\n    'int', 'uint'\r\n];\r\n\r\nexport const FLOAT_TYPES = [\r\n    'float'\r\n];\r\n\r\nexport const INT_BASED_TYPES = [\r\n    'int',\r\n    'int2', 'int3', 'int4',\r\n    'int2x2', 'int2x3', 'int2x4',\r\n    'int3x2', 'int3x3', 'int3x4',\r\n    'int4x2', 'int4x3', 'int4x4',\r\n];\r\n\r\n\r\nexport const UINT_BASED_TYPES = [\r\n    'uint',\r\n    'uint2', 'uint3', 'uint4',\r\n    'uint2x2', 'uint2x3', 'uint2x4',\r\n    'uint3x2', 'uint3x3', 'uint3x4',\r\n    'uint4x2', 'uint4x3', 'uint4x4',\r\n];\r\n\r\n\r\nexport const HALF_BASED_TYPES = [\r\n    'half',\r\n    'half2', 'half3', 'half4',\r\n    'half2x2', 'half2x3', 'half2x4',\r\n    'half3x2', 'half3x3', 'half3x4',\r\n    'half4x2', 'half4x3', 'half4x4',\r\n];\r\n\r\n\r\nexport const FLOAT_BASED_TYPES = [\r\n    'float',\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float2x3', 'float2x4',\r\n    'float3x2', 'float3x3', 'float3x4',\r\n    'float4x2', 'float4x3', 'float4x4',\r\n];\r\n\r\n\r\nexport const BOOL_BASED_TYPES = [\r\n    'bool',\r\n    'bool2', 'bool3', 'bool4',\r\n    'bool2x2', 'bool2x3', 'bool2x4',\r\n    'bool3x2', 'bool3x3', 'bool3x4',\r\n    'bool4x2', 'bool4x3', 'bool4x4',\r\n];\r\n\r\n\r\nexport const VECTOR_TYPES = [\r\n    'bool2', 'bool3', 'bool4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'half2', 'half3', 'half4',\r\n    'float2', 'float3', 'float4'\r\n];\r\n\r\n\r\nexport const MATRIX_TYPES = [\r\n    'bool2x2', 'bool2x3', 'bool2x4', 'bool3x2', 'bool3x3', 'bool3x4', 'bool4x2', 'bool4x3', 'bool4x4',\r\n    'int2x2', 'int2x3', 'int2x4', 'int3x2', 'int3x3', 'int3x4', 'int4x2', 'int4x3', 'int4x4',\r\n    'uint2x2', 'uint2x3', 'uint2x4', 'uint3x2', 'uint3x3', 'uint3x4', 'uint4x2', 'uint4x3', 'uint4x4',\r\n    'half2x2', 'half2x3', 'half2x4', 'half3x2', 'half3x3', 'half3x4', 'half4x2', 'half4x3', 'half4x4',\r\n    'float2x2', 'float2x3', 'float2x4', 'float3x2', 'float3x3', 'float3x4', 'float4x2', 'float4x3', 'float4x4',\r\n];\r\n\r\nexport const BASE_TYPES = [\r\n    ...SCALAR_TYPES, ...VECTOR_TYPES, ...MATRIX_TYPES\r\n]\r\n\r\nexport const UAV_TYPES = [\r\n    'RWTexture1D',\r\n    'RWTexture2D',\r\n    'RWTexture3D',\r\n    'RWBuffer',\r\n    'RWStructuredBuffer',\r\n    'AppendStructuredBuffer'\r\n];\r\n\r\nexport const TEXTURE_TYPES = [\r\n    'Texture1D',\r\n    'Texture2D',\r\n    'Texture3D',\r\n    'TextureCube',\r\n    'Texture2DArray',\r\n    'TextureCubeArray',\r\n    'RWTexture1D',\r\n    'RWTexture2D',\r\n    'RWTexture3D',\r\n];\r\n\r\nexport const BUFFER_TYPES = [\r\n    'Buffer',\r\n    'RWBuffer',\r\n    'RWStructuredBuffer',\r\n    'AppendStructuredBuffer',\r\n    'StructuredBuffer'\r\n];\r\n\r\nexport const SAMPLER_TYPES = [\r\n    'SamplerState',\r\n    'SamplerComparisonState'\r\n];\r\n\r\nexport const BLEND_STATE = 'BlendState';\r\nexport const DEPTH_STENCIL_STATE = 'DepthStencilState';\r\nexport const RASTERIZER_STATE = 'RasterizerState';\r\n\r\nexport const SHADER_TYPES = [\r\n    'VertexShader',\r\n    'PixelShader',\r\n    'GeometryShader',\r\n    'HullShader',\r\n    'DomainShader',\r\n    'ComputeShader'\r\n];\r\n\r\nconst skipTemplate = (name: string) => name.match(/([\\w][\\w\\d]+)(<[\\w][\\w\\d]+>)?/)[1];\r\n// note: arrays like \"Texture2D[5]\" also return true in this checks (!)\r\nexport const isUAV = (type: ITypeInstruction) => UAV_TYPES.includes(skipTemplate(type.name));\r\nexport const isTexture = (type: ITypeInstruction) => TEXTURE_TYPES.includes(skipTemplate(type.name));\r\nexport const isBuffer = (type: ITypeInstruction) => BUFFER_TYPES.includes(skipTemplate(type.name));\r\n\r\n// note: arrays like \"BlendState[5]\" also return true in this checks (!)\r\nexport const isSamplerState = (type: ITypeInstruction) => SAMPLER_TYPES.includes(type.name);\r\nexport const isBlendState = (type: ITypeInstruction) => [BLEND_STATE].includes(type.name);\r\nexport const isDepthStencilState = (type: ITypeInstruction) => [DEPTH_STENCIL_STATE].includes(type.name);\r\nexport const isRasterizerState = (type: ITypeInstruction) => [RASTERIZER_STATE].includes(type.name);\r\n\r\n// note: arrays like \"BlendState[5]\" also return true in this checks (!)\r\nexport const isPipelineState = (type: ITypeInstruction) => [\r\n    BLEND_STATE,\r\n    DEPTH_STENCIL_STATE,\r\n    RASTERIZER_STATE\r\n].includes(type.name);\r\n\r\nexport const isShaderType = (type: ITypeInstruction) => SHADER_TYPES.includes(types.signature(type));\r\n\r\n// note: arrays like \"float4[4]\" return false in this checks (!)\r\nexport const isBase = (type: ITypeInstruction) => BASE_TYPES.includes(types.signature(type));\r\nexport const isVectorType = (type: ITypeInstruction) => VECTOR_TYPES.includes(types.signature(type));\r\nexport const isMatrixType = (type: ITypeInstruction) => MATRIX_TYPES.includes(types.signature(type));\r\nexport const isScalarType = (type: ITypeInstruction) => SCALAR_TYPES.includes(types.signature(type));\r\nexport const isIntegerType = (type: ITypeInstruction) => INT_TYPES.includes(types.signature(type));\r\nexport const isFloatType = (type: ITypeInstruction) => FLOAT_TYPES.includes(types.signature(type));\r\nexport const isIntBasedType = (type: ITypeInstruction) => INT_BASED_TYPES.includes(types.signature(type));\r\nexport const isUintBasedType = (type: ITypeInstruction) => UINT_BASED_TYPES.includes(types.signature(type));\r\nexport const isBoolBasedType = (type: ITypeInstruction) => BOOL_BASED_TYPES.includes(types.signature(type));\r\nexport const isHalfBasedType = (type: ITypeInstruction) => HALF_BASED_TYPES.includes(types.signature(type));\r\nexport const isFloatBasedType = (type: ITypeInstruction) => FLOAT_BASED_TYPES.includes(types.signature(type));\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nexport function resolveRegister(decl: IVariableDeclInstruction | ICbufferInstruction): IRegister {\r\n    let type = null;\r\n    let index = -1;\r\n\r\n    const semantic = decl.semantic;\r\n    if (semantic) {\r\n        const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n        if (match) {\r\n            type = match[1];\r\n            index = Number(match[2]);\r\n        }\r\n    }\r\n\r\n    if (isUAV(decl.type)) {\r\n        assert(type === null || type === 'u');\r\n        type = 'u';\r\n    }\r\n\r\n    if (isTexture(decl.type)) {\r\n        assert(type === null || type === 't');\r\n        type = 't';\r\n    }\r\n\r\n    if (isSamplerState(decl.type)) {\r\n        assert(type === null || type === 's');\r\n        type = 's';\r\n    }\r\n\r\n    if (decl.instructionType === EInstructionTypes.k_CbufferDecl) {\r\n        assert(type === null || type === 'b');\r\n        type = 'b';\r\n    }\r\n\r\n    // TODO: buffers\r\n\r\n    return { type, index };\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////\r\n\r\n\r\nfunction alignL(content: string, len: number) {\r\n    let diff = Math.max(0, len - content.length);\r\n    return `${Array(diff).fill(' ').join('')}${content}`;\r\n}\r\n\r\n\r\nfunction alignR(content: string, len: number) {\r\n    let diff = Math.max(0, len - content.length);\r\n    return `${content}${Array(diff).fill(' ').join('')}`;\r\n}\r\n\r\nclass Emitter<ContextT extends CodeContext> extends CodeEmitter<ContextT> {\r\n    emitFunctionDefinition(ctx: ContextT, def: IFunctionDefInstruction, attrs: IAttributeInstruction[]): void {\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n        // this.emitKeyword(alignL(typeName, 10));\r\n        // this.emitKeyword(alignR(def.name, 16));\r\n        attrs?.forEach(attr => this.emitLine(`[${attr.name}]`));\r\n        this.emitKeyword(typeName);\r\n        this.emitKeyword(def.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitParams(ctx, def.params);\r\n        this.emitChar(')');\r\n    }\r\n}\r\n\r\nexport function debugPrint(scope: IScope) {\r\n\r\n    const ctx = new CodeContext;\r\n    const emitter = new Emitter({ omitEmptyParams: true });\r\n\r\n    const { functions, types, typeTemplates } = scope;\r\n\r\n    emitter.begin();\r\n    for (let name in types) {\r\n        const type = types[name];\r\n        emitter.emitLine(`// ${type.name};`);\r\n    }\r\n    emitter.end();\r\n\r\n    emitter.begin();\r\n    for (let name in typeTemplates) {\r\n        const tpl = typeTemplates[name];\r\n        emitter.emitLine(`// ${tpl.name};`);\r\n    }\r\n    emitter.end();\r\n\r\n    emitter.begin();\r\n    for (let name in functions) {\r\n        const overloads = functions[name];\r\n\r\n        for (const fn of overloads) {\r\n            emitter.emitFunctionDefinition(ctx, fn.def, fn.attrs);\r\n            emitter.emitChar(';');\r\n            emitter.emitNewline();\r\n        }\r\n\r\n        emitter.emitNewline();\r\n    }\r\n    emitter.end();\r\n    return emitter.toString();\r\n}\r\n","import { IScope, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { addFieldsToVectorFromSuffixObject, defineTypeAlias, generateSuffixLiterals, generateSystemType, getSystemType, USE_STRICT_HALF_TYPE } from \"./utils\";\r\n\r\nexport function addSystemTypeVector(scope: IScope): void {\r\n    const XYSuffix = generateSuffixLiterals(\"xy\");\r\n    const XYZSuffix = generateSuffixLiterals(\"xyz\");\r\n    const XYZWSuffix = generateSuffixLiterals(\"xyzw\");\r\n\r\n    const RGSuffix = generateSuffixLiterals(\"rg\");\r\n    const RGBSuffix = generateSuffixLiterals(\"rgb\");\r\n    const RGBASuffix = generateSuffixLiterals(\"rgba\");\r\n\r\n    const STSuffix = generateSuffixLiterals(\"st\");\r\n    const STPSuffix = generateSuffixLiterals(\"stp\");\r\n    const STPQSuffix = generateSuffixLiterals(\"stpq\");\r\n\r\n\r\n    let float = getSystemType(scope, \"float\");\r\n    let half = getSystemType(scope, \"half\");\r\n    let int = getSystemType(scope, \"int\");\r\n    let uint = getSystemType(scope, \"uint\");\r\n    let bool = getSystemType(scope, \"bool\");\r\n\r\n    let float2 = generateSystemType(scope, \"float2\", -1, float, 2);\r\n    let float3 = generateSystemType(scope, \"float3\", -1, float, 3);\r\n    let float4 = generateSystemType(scope, \"float4\", -1, float, 4);\r\n\r\n    if (!USE_STRICT_HALF_TYPE) {\r\n        defineTypeAlias(scope, 'float2', 'half2');\r\n        defineTypeAlias(scope, 'float3', 'half3');\r\n        defineTypeAlias(scope, 'float4', 'half4');\r\n    }\r\n\r\n    let int2 = generateSystemType(scope, \"int2\", -1, int, 2);\r\n    let int3 = generateSystemType(scope, \"int3\", -1, int, 3);\r\n    let int4 = generateSystemType(scope, \"int4\", -1, int, 4);\r\n\r\n    let uint2 = generateSystemType(scope, \"uint2\", -1, uint, 2);\r\n    let uint3 = generateSystemType(scope, \"uint3\", -1, uint, 3);\r\n    let uint4 = generateSystemType(scope, \"uint4\", -1, uint, 4);\r\n\r\n    let bool2 = generateSystemType(scope, \"bool2\", -1, bool, 2);\r\n    let bool3 = generateSystemType(scope, \"bool3\", -1, bool, 3);\r\n    let bool4 = generateSystemType(scope, \"bool4\", -1, bool, 4);\r\n\r\n    {\r\n        let suf2f: IVariableDeclInstruction[] = [];\r\n        // program.push(EScopeType.k_Struct);\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, XYSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, RGSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2f, STSuffix, \"float\");\r\n        // program.pop();\r\n        suf2f.forEach(field => float2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, XYZSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, RGBSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3f, STPSuffix, \"float\");\r\n        suf3f.forEach(field => float3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, XYZWSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, RGBASuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4f, STPQSuffix, \"float\");\r\n        suf4f.forEach(field => float4.addField(field));\r\n    }\r\n\r\n    if (USE_STRICT_HALF_TYPE) {\r\n        let half2 = generateSystemType(scope, \"half2\", -1, half, 2);\r\n        let half3 = generateSystemType(scope, \"half3\", -1, half, 3);\r\n        let half4 = generateSystemType(scope, \"half4\", -1, half, 4);\r\n\r\n        {\r\n            let suf2f: IVariableDeclInstruction[] = [];\r\n            // program.push(EScopeType.k_Struct);\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, XYSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, RGSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf2f, STSuffix, \"half\");\r\n            // program.pop();\r\n            suf2f.forEach(field => half2.addField(field));\r\n        }\r\n\r\n        {\r\n            let suf3f: IVariableDeclInstruction[] = [];\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, XYZSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, RGBSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf3f, STPSuffix, \"half\");\r\n            suf3f.forEach(field => half3.addField(field));\r\n        }\r\n\r\n        {\r\n            let suf4f: IVariableDeclInstruction[] = [];\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, XYZWSuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, RGBASuffix, \"half\");\r\n            addFieldsToVectorFromSuffixObject(scope, suf4f, STPQSuffix, \"half\");\r\n            suf4f.forEach(field => half4.addField(field));\r\n        }\r\n    }\r\n\r\n    {\r\n        let suf2i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, XYSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, RGSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2i, STSuffix, \"int\");\r\n        suf2i.forEach(field => int2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, XYZSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, RGBSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3i, STPSuffix, \"int\");\r\n        suf3i.forEach(field => int3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, XYZWSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, RGBASuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4i, STPQSuffix, \"int\");\r\n        suf4i.forEach(field => int4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, XYSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, RGSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2ui, STSuffix, \"uint\");\r\n        suf2ui.forEach(field => uint2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, XYZSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, RGBSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3ui, STPSuffix, \"uint\");\r\n        suf3ui.forEach(field => uint3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, XYZWSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, RGBASuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4ui, STPQSuffix, \"uint\");\r\n        suf4ui.forEach(field => uint4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, XYSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, RGSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf2b, STSuffix, \"bool\");\r\n        suf2b.forEach(field => bool2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, XYZSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, RGBSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf3b, STPSuffix, \"bool\");\r\n        suf3b.forEach(field => bool3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, XYZWSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, RGBASuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(scope, suf4b, STPQSuffix, \"bool\");\r\n        suf4b.forEach(field => bool4.addField(field));\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { createOutput, IOutput } from \"./Output\";\r\n\r\nexport class BaseEmitter {\r\n    private blocks: IOutput[] = [];\r\n    private stack: IOutput[] = [];\r\n\r\n    private top() { return this.stack[this.depth() - 1]; }\r\n    \r\n    private findOrCreateOutput(name?: string) {\r\n        const i = this.blocks.findIndex(block => name && block.name === name);\r\n        const block = i !== -1\r\n            ? this.blocks.splice(i, 1)[0]\r\n            : createOutput({ name });\r\n        return block;\r\n    }\r\n\r\n    protected depth() { \r\n        return this.stack.length;\r\n    }\r\n\r\n    begin(block?: string) {\r\n        this.stack.push(this.findOrCreateOutput(block));\r\n    }\r\n\r\n    /**\r\n     * @param prologue Move block to the beginning.\r\n     */\r\n    end(prologue = false) {\r\n        const block = this.stack.pop();\r\n        \r\n        if (block.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        if (!prologue) {\r\n            this.blocks.push(block);\r\n        } else {\r\n            this.blocks = [ block, ...this.blocks ];\r\n        }\r\n    }\r\n\r\n    push(pad?) {\r\n        this.top().push(pad);\r\n    }\r\n\r\n    pop() {\r\n        this.top().pop();\r\n    }\r\n\r\n    emitNewline(n = 1) { Array(n).fill(0).forEach(i => this.top()?.newline()); }\r\n    emitKeyword(kw: string) { this.top()?.keyword(kw); }\r\n    emitNoSpace() { this.top()?.ignoreNextSpace(); }\r\n    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }\r\n    emitChar(char: string) { this.top()?.add(char); }\r\n    emitLine(line: string) { \r\n        this.emitChar(line);\r\n        this.emitNewline(); \r\n    }\r\n\r\n    clear(): void {\r\n        assert(this.stack.length == 0);\r\n        this.blocks = [];\r\n    }\r\n\r\n    toString(): string {\r\n        const res = this.blocks\r\n            .map(block => block.toString())\r\n            .filter(code => !!code)\r\n            .join('\\n\\n');\r\n        this.clear();\r\n        return res;\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.toString();\r\n    }\r\n}","import { assert, isBoolean, isDef, isNull } from \"@lib/common\";\r\nimport { instruction, variable, types } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IAnnotationInstruction, IArithmeticExprInstruction, IAssignmentExprInstruction, IAttributeInstruction, IBitwiseExprInstruction, ICastExprInstruction, ICbufferInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, IInstructionCollector, ILiteralInstruction, ILogicalExprInstruction, IPassInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, IStateBlockInstruction, IStmtBlockInstruction, ITypeDeclInstruction, ITypedefInstruction, ITypedInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { fn } from \"@lib/fx/analisys/helpers/fn\";\r\nimport { IntInstruction } from \"@lib/fx/analisys/instructions/IntInstruction\";\r\nimport { EVariableUsageFlags } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { isString } from \"@lib/util/s3d/type\";\r\nimport { BaseEmitter } from \"./BaseEmitter\";\r\nimport { BreakStmtInstruction } from \"../analisys/instructions/BreakStmtInstruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface ITypeInfo {\r\n    typeName: string;\r\n    length: number;\r\n    usage?: string;\r\n}\r\n\r\nexport enum EUsages {\r\n    k_Vertex = 0x01,\r\n    k_Pixel = 0x02,\r\n    k_Compute = 0x04\r\n};\r\n\r\n\r\nexport interface IUavReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"RWBuffer<float4>\", \"AppendBuffer<int>\" etc. \r\n    uavType: string;        // \"RWBuffer\"\r\n    elementType: string;    // \"float4\"\r\n};\r\n\r\n\r\nexport interface IBufferReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"Buffer<float4>\", \"AppendBuffer<int>\" etc. \r\n    bufType: string;        // \"Buffer\"\r\n    elementType: string;    // \"float4\"\r\n}\r\n\r\n\r\nexport interface ITextureReflection {\r\n    register: number;\r\n    name: string;\r\n    /** @deprecated */\r\n    type: string;           // \"Texture2D<float4>\"\r\n    texType: string;        // \"Texture2D\"\r\n    elementType: string;    // \"float4\"\r\n}\r\n\r\n\r\nexport interface ICSShaderReflection {\r\n    name: string;\r\n    numthreads: number[];\r\n    uavs: IUavReflection[];\r\n    buffers: IBufferReflection[];\r\n    textures: ITextureReflection[];\r\n}\r\n\r\n\r\nexport interface IUniformReflection {\r\n    name: string;\r\n    typeName: string;\r\n    semantic?: string;\r\n    length?: number;\r\n}\r\n\r\n\r\nexport interface ICbReflection {\r\n    register: number;\r\n    name: string;\r\n    size: number; // byte length\r\n}\r\n\r\nexport interface ICodeEmitterOptions {\r\n    // do not print 'in' for function parameters even if it is specified\r\n    omitInUsage?: boolean;\r\n    // skip complex type parameters of zero size\r\n    omitEmptyParams?: boolean;\r\n}\r\n\r\n\r\nfunction pushUniq<T>(arr: Array<T>, elem: T) {\r\n    if (arr.indexOf(elem) == -1)\r\n        arr.push(elem);\r\n}\r\n\r\nexport type CodeContextMode = 'vs' | 'ps' | 'cs' | 'gs' | 'hs' | 'ds' | 'raw';\r\n\r\nexport interface ICodeContextOptions {\r\n    mode?: CodeContextMode;\r\n    // rename entry point\r\n    entryName?: string;\r\n\r\n    // temp solution\r\n    /** @deprecated Expected to use dynamic constants in the future. */\r\n    constants?: {\r\n        type: string;\r\n        value: number | boolean;\r\n    }[];\r\n}\r\n\r\n\r\nexport class CodeContext {\r\n    // known globals like: functions, types, uniforms etc.\r\n    private knownSignatures: Set<string> = new Set();\r\n\r\n    readonly uavs: IUavReflection[] = [];\r\n    readonly textures: ITextureReflection[] = [];\r\n    readonly buffers: IBufferReflection[] = [];\r\n    readonly cbuffers: ICbReflection[] = [];\r\n    readonly CSShaders: ICSShaderReflection[] = [];\r\n\r\n    protected CSShader?: ICSShaderReflection;\r\n\r\n    readonly opts: ICodeContextOptions;\r\n\r\n    constructor(opts: ICodeContextOptions = {}) {\r\n        this.opts = opts;\r\n        this.opts.mode ||= 'raw';\r\n        console.assert([ 'vs', 'ps', 'ds', 'hs', 'gs', 'cs', 'raw' ].includes(this.opts.mode));\r\n    }\r\n\r\n    get entryName(): string { return this.opts.entryName; }\r\n    get mode(): CodeContextMode { return this.opts.mode; }\r\n    isPixel() { return this.mode === 'ps'; }\r\n    isVertex() { return this.mode === 'vs'; }\r\n    isRaw() { return this.mode === 'raw'; }\r\n\r\n\r\n    has(signature: string): boolean {\r\n        return this.knownSignatures.has(signature);\r\n    }\r\n\r\n\r\n    add(signature: string): void {\r\n        assert(!this.has(signature));\r\n        this.knownSignatures.add(signature);\r\n    }\r\n\r\n\r\n    // note: cbuffers without predefined register are not supported yet (!)\r\n    addCbuffer(cbuf: ICbufferInstruction): ICbReflection {\r\n        assert(!this.has(cbuf.name));\r\n        this.add(cbuf.name);\r\n\r\n        const { name, type: { size } } = cbuf;\r\n        const register = SystemScope.resolveRegister(cbuf).index;\r\n        const buf = { name, size, register };\r\n        this.cbuffers.push(buf);\r\n\r\n        return buf;\r\n    }\r\n\r\n\r\n    addTexture(type: string, name: string): ITextureReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.buffers.length + this.textures.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp) || [ `${type}<float4>`, `${type}`, `float4` ];\r\n        const texture = <ITextureReflection>{\r\n            name,\r\n            type,\r\n            texType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.textures.push(texture);\r\n        return texture;\r\n    }\r\n\r\n\r\n    addUav(type: string, name: string): IUavReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.uavs.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp);\r\n        assert(match);\r\n        const uav = {\r\n            name,\r\n            type,\r\n            uavType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.uavs.push(uav);\r\n        return uav;\r\n    }\r\n\r\n\r\n\r\n    addBuffer(type: string, name: string): IBufferReflection {\r\n        assert(!this.has(name));\r\n        this.add(name);\r\n\r\n        const register = this.buffers.length + this.textures.length;\r\n        const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n        const match = type.match(regexp);\r\n        assert(match);\r\n\r\n        const buf = {\r\n            name,\r\n            type,\r\n            bufType: match[1],\r\n            elementType: match[2],\r\n            register\r\n        };\r\n\r\n        this.buffers.push(buf);\r\n        return buf;\r\n    }\r\n\r\n\r\n    beginCsShader(name: string, numthreads: number[]) {\r\n        const uavs = [];\r\n        const buffers = [];\r\n        const textures = [];\r\n        this.CSShader = { name, numthreads, uavs, buffers, textures };\r\n    }\r\n\r\n\r\n    endCsShader() {\r\n        const sh = this.CSShader;\r\n        assert(sh);\r\n        assert(!this.has(sh.name));\r\n        this.add(sh.name);\r\n        this.CSShaders.push(sh);\r\n\r\n        this.CSShader = null;\r\n    }\r\n\r\n\r\n    linkBuffer(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.buffers, this.buffers.find(b => b.name == name));\r\n        }\r\n    }\r\n\r\n\r\n    linkCbuffer(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            // pushUniq(sh.cbuffers, this.cbuffers.find(b => b.name == name));\r\n        }\r\n    }\r\n\r\n\r\n    linkUav(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.uavs, this.uavs.find(u => u.name == name));\r\n        }\r\n    }\r\n\r\n    linkTexture(name: string) {\r\n        assert(this.has(name));\r\n        // push if not exists\r\n        let sh = this.CSShader;\r\n        if (sh) {\r\n            pushUniq(sh.textures, this.textures.find(t => t.name == name));\r\n        }\r\n    }\r\n}\r\n\r\nexport class CodeEmitter<ContextT extends CodeContext> extends BaseEmitter {\r\n    constructor(protected options: ICodeEmitterOptions = {}) {\r\n        super();\r\n    }\r\n\r\n\r\n    protected isMain() {\r\n        return this.depth() === 1;\r\n    }\r\n\r\n\r\n    protected resolveTypeName(type: ITypeInstruction): string {\r\n        return type.name;\r\n    }\r\n\r\n\r\n    protected resolveType(ctx: ContextT, type: ITypeInstruction): ITypeInfo {\r\n        if (!type) {\r\n            return null;\r\n        }\r\n\r\n        let complex = type.isComplex();\r\n\r\n        let length: number;\r\n        let typeName: string;\r\n        let usages: string[];\r\n        let usage: string;\r\n\r\n        if (!complex) {\r\n            typeName = this.resolveTypeName(type);\r\n        } else {\r\n            typeName = type.name;\r\n            // find original type instead of VariableType wrapper. \r\n            const originalType = type.scope.findType(type.name);\r\n            this.emit(ctx, originalType);\r\n        }\r\n\r\n        if (type.instructionType === EInstructionTypes.k_VariableType) {\r\n            const vtype = type as IVariableTypeInstruction;\r\n            usages = vtype.usages as string[];\r\n        }\r\n\r\n        if (type.isNotBaseArray()) {\r\n            length = type.length;\r\n        }\r\n\r\n        if (usages && usages.length) {\r\n            usage = usages.filter(u => !this.options.omitInUsage || u != 'in').join(' ');\r\n        }\r\n\r\n        return { typeName, length, usage };\r\n    }\r\n\r\n\r\n    emitBuffer(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const buf = ctx.addBuffer(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(t${buf.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkBuffer(name);\r\n    }\r\n\r\n\r\n    emitUav(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const uav = ctx.addUav(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(u${uav.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkUav(name);\r\n    }\r\n\r\n\r\n\r\n    emitTexture(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const { name, type } = decl;\r\n        this.emitTextureRaw(ctx, type.name, name);\r\n    }\r\n\r\n\r\n\r\n    emitTextureRaw(ctx: ContextT, type: string, name: string, comment?: string): void {\r\n        if (!ctx.has(name)) {\r\n            const tex = ctx.addTexture(type, name);\r\n            this.begin();\r\n            {\r\n                comment && this.emitComment(comment);\r\n                this.emitKeyword(`${type} ${name}: register(t${tex.register});`);\r\n            }\r\n            this.end();\r\n        }\r\n        ctx.linkTexture(name);\r\n    }\r\n\r\n\r\n    emitLine(line: string, comment?: string) {\r\n        this.emitChar(line);\r\n        comment && assert(comment.split('\\n').length === 1);\r\n        comment && (this.emitChar('\\t'), this.emitComment(comment));\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitComment(comment: string) {\r\n        //\r\n        if (comment.indexOf('\\n') === -1) {\r\n            this.emitLine(`// ${comment}`);\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * \r\n         */\r\n        this.emitLine('/**');\r\n        this.push(' * ');\r\n        comment.split('\\n').forEach(line => this.emitLine(line));\r\n        this.pop();\r\n        this.emitLine(' */');\r\n    }\r\n\r\n\r\n    emitComplexType(ctx: ContextT, type: ITypeInstruction) {\r\n        assert(type.isComplex());\r\n        this.emitKeyword('struct');\r\n        this.emitKeyword(type.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n\r\n        type.fields.map(field => (this.emitComplexField(ctx, field), this.emitNewline()));\r\n\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n\r\n    emitComplexTypeDecl(ctx: ContextT, ctype: ITypeInstruction) {\r\n        if (ctx.has(ctype.name)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(ctype.name);\r\n\r\n        this.begin();\r\n        this.emitComplexType(ctx, ctype);\r\n        this.emitChar(';');\r\n        this.end();\r\n    }\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitVariableNoInit(ctx: ContextT, decl: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        const { typeName, length, usage } = this.resolveType(ctx, decl.type);\r\n        const name = rename ? rename(decl) : decl.name;\r\n\r\n        usage && this.emitKeyword(usage);\r\n        this.emitKeyword(typeName);\r\n        this.emitKeyword(name);\r\n        length && this.emitChar(`[${length}]`);\r\n        decl.semantic && this.emitSemantic(ctx, decl.semantic);\r\n        decl.annotation && this.emitAnnotation(ctx, decl.annotation);\r\n    }\r\n\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitVariable(ctx: ContextT, src: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        this.emitVariableNoInit(ctx, src, rename);\r\n        if (src.initExpr) {\r\n            // blocks are valid for blend/raster/depth state initialization.\r\n            const isBlock = src.initExpr.instructionType === EInstructionTypes.k_StateBlockExpr;\r\n            if (!isBlock) {\r\n                this.emitKeyword('=');\r\n                this.emitSpace();\r\n            }\r\n            this.emitExpression(ctx, src.initExpr);\r\n        }\r\n    }\r\n\r\n\r\n    emitIfStmt(ctx: ContextT, stmt: IIfStmtInstruction): void {\r\n        this.emitKeyword('if');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, stmt.cond);\r\n        this.emitChar(')');\r\n        this.emitNewline();\r\n\r\n        if (stmt.conseq) {\r\n            this.emitStmt(ctx, stmt.conseq);\r\n        } else {\r\n            this.emitChar(';');\r\n        }\r\n\r\n        if (stmt.contrary) {\r\n            this.emitNewline();\r\n            this.emitKeyword('else');\r\n            this.emitStmt(ctx, stmt.contrary);\r\n        }\r\n    }\r\n\r\n\r\n    emitSemantic(ctx: ContextT, semantic: string) {\r\n        this.emitChar(':');\r\n        this.emitKeyword(semantic);\r\n    }\r\n\r\n\r\n    emitAnnotation(ctx: ContextT, anno: IAnnotationInstruction) {\r\n        // TODO: add annotation emission.\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    emitCompile(ctx: ContextT, compile: ICompileExprInstruction) {\r\n        this.emitFunction(ctx, compile.function);\r\n\r\n        this.emitKeyword('compile');\r\n        this.emitKeyword(compile.function.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, compile.args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    protected evaluateEntryName(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        const fnName = fn.name;\r\n        const entryName = ctx.entryName;\r\n        if (!isString(entryName)) return fnName;\r\n        if (isDef(fn.scope.functions[entryName]))\r\n            // todo: emit correct error\r\n            console.error('entry point already exists');\r\n        return entryName;\r\n    }\r\n\r\n\r\n    protected emitEntryParams(ctx: ContextT, params: IVariableDeclInstruction[]) {\r\n        // emit constants instead of uniforms arguments if provided\r\n        const constants = ctx.opts.constants;\r\n        if (constants) {\r\n            params.filter(p => p.type.isUniform()).forEach((param, i) => {\r\n                const c = constants[i];\r\n                const name = param.name;\r\n\r\n                if (ctx.has(name)) {\r\n                    // global variable with the same name as argument already exists\r\n                    console.assert(false, '?!');\r\n                    return;\r\n                }\r\n\r\n                ctx.add(name);\r\n                this.begin();\r\n                this.emitLine(`static const ${c.type} ${name} = ${String(c.value)};`);\r\n                this.end();\r\n            })\r\n        }\r\n\r\n        // skip uniform arguments if constant substitution were passed\r\n        params\r\n            .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && (!p.type.isUniform() || !constants))\r\n            .forEach((param, i, list) => {\r\n                this.emitParam(ctx, param);\r\n                (i + 1 != list.length) && this.emitChar(',');\r\n            });\r\n    }\r\n\r\n\r\n    // todo: add compute entry support\r\n    protected emitEntryFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        const { def } = fn;\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n\r\n        this.begin();\r\n        {\r\n            // in case of hlsl materials it's typical to swap arbitrary name for bundle name\r\n            // to simplify further compilation\r\n            let fnName = this.evaluateEntryName(ctx, fn);\r\n            this.emitKeyword(typeName);\r\n            this.emitKeyword(fnName);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitEntryParams(ctx, def.params);\r\n            this.emitChar(')');\r\n\r\n            // todo: validate complex type sematics\r\n            // all the output parameters of entry function must have valid semantics\r\n            if (!def.returnType.isComplex()) {\r\n                if (ctx.isPixel()) {\r\n                    this.emitChar(':');\r\n                    this.emitKeyword(fn.semantic || 'SV_Target0');\r\n                }\r\n            }\r\n            this.emitNewline();\r\n            this.emitBlock(ctx, fn.impl);\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    protected emitAttributes(ctx: ContextT, attrs: IAttributeInstruction[]) {\r\n        attrs?.forEach(attr => {\r\n            this.emitChar(`[`);\r\n            this.emitNoSpace();\r\n            this.emitKeyword(attr.name);\r\n            this.emitNoSpace();\r\n            if (attr.args) {\r\n                this.emitChar('(');\r\n                this.emitNoSpace();\r\n                this.emitExpressionList(ctx, attr.args);\r\n                this.emitChar(')');\r\n                this.emitNoSpace();\r\n            }\r\n            this.emitChar(`]`);\r\n            this.emitNewline();\r\n        });\r\n    }\r\n    \r\n\r\n    protected emitRegularFunction(ctx: ContextT, fn: IFunctionDeclInstruction) {\r\n        if (!fn) {\r\n            return;\r\n        }\r\n\r\n        const { def } = fn;\r\n        const { typeName } = this.resolveType(ctx, def.returnType);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitAttributes(ctx, fn.attrs);\r\n            this.emitKeyword(typeName);\r\n            this.emitKeyword(fn.name);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitParams(ctx, def.params);\r\n            this.emitChar(')');\r\n            this.emitNewline();\r\n            if (fn.impl)\r\n                this.emitBlock(ctx, fn.impl);\r\n            else \r\n                this.emitChar(';');\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitFunction(ctx: ContextT, decl: IFunctionDeclInstruction) {\r\n        if (!decl) {\r\n            return;\r\n        }\r\n\r\n        const sign = fn.signature(decl.def);\r\n        if (ctx.has(sign)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(sign);\r\n\r\n        const isEntry = (this.depth() == 0) && !ctx.isRaw();\r\n        if (isEntry) this.emitEntryFunction(ctx, decl);\r\n        else this.emitRegularFunction(ctx, decl);\r\n    }\r\n\r\n\r\n    emitCollector(ctx: ContextT, collector: IInstructionCollector) {\r\n        this.begin();\r\n        for (let instr of collector.instructions) {\r\n            this.emit(ctx, instr);\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitTypeDecl(ctx: ContextT, decl: ITypeDeclInstruction) {\r\n        this.resolveType(ctx, decl.type);\r\n    }\r\n\r\n\r\n    emitTypedef(ctx: ContextT, def: ITypedefInstruction) {\r\n        // nothing todo because current implementation implies\r\n        // immediate target type substitution \r\n        return;\r\n        /*\r\n            this.emitKeyword('typedef');\r\n            // todo: add support for typedefs like:\r\n            //  typedef const float4 T;\r\n            //          ^^^^^^^^^^^^\r\n            this.emitKeyword(def.type.name);\r\n            this.emitKeyword(def.alias);\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        */\r\n    }\r\n\r\n    emitForInit(ctx: ContextT, init: ITypedInstruction) {\r\n        if (instruction.isExpression(init)) {\r\n            this.emitExpression(ctx, init as IExprInstruction);\r\n        } else {\r\n            this.emitVariable(ctx, init as IVariableDeclInstruction);\r\n        }\r\n    }\r\n\r\n    emitForStmt(ctx: ContextT, stmt: IForStmtInstruction) {\r\n\r\n        //for(int i = 0;i < 4;++ i)\r\n        //{\r\n        //  ...\r\n        //}\r\n\r\n        this.emitKeyword('for');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n\r\n        this.emitForInit(ctx, stmt.init);\r\n        this.emitChar(';');\r\n\r\n        this.emitExpression(ctx, stmt.cond);\r\n        this.emitChar(';');\r\n\r\n        this.emitExpression(ctx, stmt.step);\r\n        this.emitChar(')');\r\n\r\n        if (stmt.body.instructionType === EInstructionTypes.k_StmtBlock)\r\n            this.emitNewline();\r\n        this.emitStmt(ctx, stmt.body);\r\n    }\r\n\r\n\r\n    emitExpression(ctx: ContextT, expr: IExprInstruction) {\r\n        if (!expr) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        | ICastExprInstruction\r\n        | ILogicalExprInstruction\r\n        | IPostfixIndexInstruction\r\n        | ISamplerStateBlockInstruction\r\n        */\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                return this.emitArithmetic(ctx, expr as IArithmeticExprInstruction);\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                return this.emitAssigment(ctx, expr as IAssignmentExprInstruction);\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return this.emitPostfixPoint(ctx, expr as IPostfixPointInstruction);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return this.emitIdentifier(ctx, expr as IIdExprInstruction);\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                return this.emitFCall(ctx, expr as IFunctionCallInstruction);\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                return this.emitCCall(ctx, expr as IConstructorCallInstruction);\r\n            case EInstructionTypes.k_FloatExpr:\r\n                return this.emitFloat(ctx, expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_IntExpr:\r\n                return this.emitInteger(ctx, expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_BoolExpr:\r\n                return this.emitBool(ctx, expr as ILiteralInstruction<boolean>);\r\n            case EInstructionTypes.k_StringExpr:\r\n                return this.emitString(ctx, expr as ILiteralInstruction<string>);\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return this.emitComplexExpr(ctx, expr as IComplexExprInstruction);\r\n            case EInstructionTypes.k_CompileExpr:\r\n                return this.emitCompile(ctx, expr as ICompileExprInstruction);\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n                return this.emitConditionalExpr(ctx, expr as IConditionalExprInstruction);\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                return this.emitRelationalExpr(ctx, expr as IRelationalExprInstruction);\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                return this.emitLogicalExpr(ctx, expr as ILogicalExprInstruction);\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                return this.emitUnaryExpr(ctx, expr as IUnaryExprInstruction);\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                return this.emitPostfixArithmetic(ctx, expr as IPostfixArithmeticInstruction);\r\n            case EInstructionTypes.k_InitExpr:\r\n                return this.emitInitExpr(ctx, expr as IInitExprInstruction);\r\n            case EInstructionTypes.k_CastExpr:\r\n                return this.emitCast(ctx, expr as ICastExprInstruction);\r\n            case EInstructionTypes.k_BitwiseExpr:\r\n                return this.emitBitwise(ctx, expr as IBitwiseExprInstruction);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return this.emitPostfixIndex(ctx, expr as IPostfixIndexInstruction);\r\n            case EInstructionTypes.k_StateBlockExpr:\r\n                return this.emitStateBlockExpr(ctx, expr as IStateBlockInstruction);\r\n            default:\r\n                this.emitLine(`/* ... unsupported expression '${expr.instructionName}' ... */`);\r\n                assert(false, `unsupported instruction found: ${expr.instructionName}`);\r\n        }\r\n    }\r\n\r\n\r\n    emitFloat(ctx: ContextT, lit: ILiteralInstruction<number>) {\r\n        const sval = String(lit.value);\r\n        this.emitKeyword(sval);\r\n        (sval.indexOf('.') === -1) && this.emitChar('.');\r\n        this.emitChar('f');\r\n    }\r\n\r\n\r\n    emitBool(ctx: ContextT, lit: ILiteralInstruction<boolean>) {\r\n        this.emitKeyword(lit.value ? 'true' : 'false');\r\n    }\r\n    \r\n\r\n    emitString(ctx: ContextT, lit: ILiteralInstruction<string>) {\r\n        this.emitKeyword(lit.value);\r\n    }\r\n\r\n\r\n    emitComplexExpr(ctx: ContextT, complex: IComplexExprInstruction) {\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, complex.expr);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitConditionalExpr(ctx: ContextT, cond: IConditionalExprInstruction) {\r\n        this.emitExpression(ctx, cond.condition);\r\n        this.emitKeyword('?');\r\n        this.emitExpression(ctx, cond.left as IExprInstruction);\r\n        this.emitKeyword(':');\r\n        this.emitExpression(ctx, cond.right as IExprInstruction);\r\n    }\r\n\r\n\r\n    emitInteger(ctx: ContextT, lit: ILiteralInstruction<number>) {\r\n        const int = lit as IntInstruction;\r\n        this.emitKeyword(`${int.heximal ? '0x' + int.value.toString(16).toUpperCase() : int.value.toFixed(0)}${!int.signed ? 'u' : ''}`);\r\n    }\r\n\r\n\r\n    emitRelationalExpr(ctx: ContextT, rel: IRelationalExprInstruction) {\r\n        this.emitExpression(ctx, rel.left);\r\n        this.emitKeyword(rel.operator);\r\n        this.emitExpression(ctx, rel.right);\r\n    }\r\n\r\n\r\n    emitLogicalExpr(ctx: ContextT, rel: ILogicalExprInstruction) {\r\n        this.emitExpression(ctx, rel.left);\r\n        this.emitKeyword(rel.operator);\r\n        this.emitExpression(ctx, rel.right);\r\n    }\r\n\r\n\r\n    emitUnaryExpr(ctx: ContextT, unary: IUnaryExprInstruction) {\r\n        this.emitChar(unary.operator);\r\n        this.emitExpression(ctx, unary.expr);\r\n    }\r\n\r\n\r\n    emitPostfixArithmetic(ctx: ContextT, par: IPostfixArithmeticInstruction) {\r\n        this.emitExpression(ctx, par.expr);\r\n        this.emitChar(par.operator);\r\n    }\r\n\r\n\r\n    emitPostfixIndex(ctx: ContextT, pfidx: IPostfixIndexInstruction) {\r\n        this.emitExpression(ctx, pfidx.element);\r\n        this.emitChar('[');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, pfidx.index);\r\n        this.emitChar(']');\r\n    }\r\n\r\n\r\n    emitStateBlockExpr(ctx: ContextT, stblk: IStateBlockInstruction) {\r\n        if (ctx.mode !== 'raw') {\r\n            // no need to emit state blocks in plain hlsl shaders\r\n            return;\r\n        }\r\n\r\n        assert('not implemented');\r\n    }\r\n\r\n\r\n    emitBreakStmt(ctx: ContextT, brk: BreakStmtInstruction) {\r\n        this.emitLine(`${brk.operator};`);\r\n    }\r\n\r\n\r\n    emitExpressionList(ctx: ContextT, list: IExprInstruction[]) {\r\n        list?.forEach((expr, i) => {\r\n            this.emitExpression(ctx, expr);\r\n            (i != list.length - 1) && this.emitChar(',');\r\n        })\r\n    }\r\n\r\n\r\n    emitParam(ctx: ContextT, param: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, param);\r\n    }\r\n\r\n\r\n    emitParams(ctx: ContextT, params: IVariableDeclInstruction[]) {\r\n        params.filter(p => !this.options.omitEmptyParams || p.type.size !== 0).forEach((param, i, list) => {\r\n            this.emitParam(ctx, param);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n    }\r\n\r\n\r\n    emitInitExpr(ctx: ContextT, init: IInitExprInstruction) {\r\n        if (init.args.length > 1) {\r\n            this.emitChar('{');\r\n            this.emitNoSpace();\r\n            this.emitExpressionList(ctx, init.args);\r\n            this.emitChar('}');\r\n            return;\r\n        }\r\n\r\n        this.emitExpression(ctx, init.args[0]);\r\n    }\r\n\r\n\r\n    emitCast(ctx: ContextT, cast: ICastExprInstruction) {\r\n        if (cast.isUseless()) {\r\n            return;\r\n        }\r\n\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n\r\n        const { typeName } = this.resolveType(ctx, cast.type);\r\n        this.emitKeyword(typeName);\r\n\r\n        this.emitChar(')');\r\n        this.emitNoSpace();\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(ctx, cast.expr);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitBitwise(ctx: ContextT, bwise: IBitwiseExprInstruction) {\r\n        this.emitExpression(ctx, bwise.left);\r\n        this.emitKeyword(bwise.operator);\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, bwise.right);\r\n    }\r\n\r\n\r\n    emitArithmetic(ctx: ContextT, arthm: IArithmeticExprInstruction) {\r\n        this.emitExpression(ctx, arthm.left);\r\n        this.emitKeyword(arthm.operator);\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, arthm.right);\r\n    }\r\n\r\n\r\n    emitAssigment(ctx: ContextT, asgm: IAssignmentExprInstruction) {\r\n        this.emitExpression(ctx, asgm.left);\r\n        this.emitKeyword(asgm.operator);\r\n        this.emitSpace();\r\n        assert(instruction.isExpression(asgm.right));\r\n        this.emitExpression(ctx, asgm.right as IExprInstruction);\r\n    }\r\n\r\n\r\n    emitPostfixPoint(ctx: ContextT, pfxp: IPostfixPointInstruction) {\r\n        // todo: skip brackets wherever possible to avoid exprs like (a).x;\r\n        if (pfxp.element.instructionType === EInstructionTypes.k_IdExpr ||\r\n            pfxp.element.instructionType === EInstructionTypes.k_PostfixPointExpr) {\r\n            this.emitExpression(ctx, pfxp.element);\r\n        } else {\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitExpression(ctx, pfxp.element);\r\n            this.emitChar(')');\r\n        }\r\n        this.emitChar('.');\r\n        this.emitChar(pfxp.postfix.name);\r\n    }\r\n\r\n\r\n    emitCbufferField(ctx: ContextT, field: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, field);\r\n        this.emitChar(';');\r\n        this.emitChar('\\t')\r\n        this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);\r\n    }\r\n\r\n\r\n    emitCbuffer(ctx: ContextT, cbuf: ICbufferInstruction) {\r\n        if (!ctx.has(cbuf.name)) {\r\n            ctx.addCbuffer(cbuf);\r\n\r\n            this.begin();\r\n            this.emitComment(`size: ${cbuf.type.size}`);\r\n            this.emitKeyword('cbuffer');\r\n            if (cbuf.id) {\r\n                this.emitKeyword(cbuf.name);\r\n            }\r\n            const reg = SystemScope.resolveRegister(cbuf);\r\n            if (reg.index !== -1) {\r\n                this.emitChar(':');\r\n                this.emitKeyword('register');\r\n                this.emitChar('(');\r\n                this.emitNoSpace();\r\n                this.emitKeyword(`${reg.type}${reg.index}`);\r\n                this.emitNoSpace();\r\n                this.emitChar(')');\r\n            }\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                cbuf.type.fields.forEach(field => {\r\n                    this.emitCbufferField(ctx, field);\r\n                });\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n            this.emitChar(';');\r\n            // emit annotation?\r\n            this.end();\r\n        }\r\n        ctx.linkCbuffer(cbuf.name);\r\n    }\r\n\r\n\r\n    // request global declaration for local identifier\r\n    emitGlobal(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        const { name, type } = decl;\r\n        const isUniformArg = this.isMain() && decl.isParameter() && type.isUniform();\r\n\r\n        if (decl.isGlobal()/* || isUniformArg*/) {\r\n            if (decl.usageFlags & EVariableUsageFlags.k_Cbuffer) {\r\n                const cbufType = decl.parent;\r\n                const cbuf = <ICbufferInstruction>cbufType.parent;\r\n                this.begin();\r\n                this.emitCbuffer(ctx, cbuf);\r\n                this.end();\r\n            } else if (SystemScope.isTexture(type)) {\r\n                this.begin();\r\n                this.emitTexture(ctx, decl);\r\n                this.end();\r\n            } else {\r\n                this.begin();\r\n                this.emitGlobalVariable(ctx, decl);\r\n                this.end();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    emitIdentifier(ctx: ContextT, id: IIdExprInstruction) {\r\n        const { decl, name } = id;\r\n\r\n        this.emitGlobal(ctx, decl);\r\n        this.emitKeyword(name);\r\n    }\r\n\r\n\r\n    emitCCall(ctx: ContextT, call: IConstructorCallInstruction) {\r\n        const args = call.args as IExprInstruction[];\r\n        const { typeName } = this.resolveType(ctx, call.ctor);\r\n\r\n        this.emitKeyword(typeName);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    // todo: remove hack with rename mutator\r\n    emitFCall(ctx: ContextT, call: IFunctionCallInstruction, rename: (decl: IFunctionDeclInstruction) => string = decl => decl.name) {\r\n        const { decl, args, callee } = call;\r\n\r\n        if (decl.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            this.emitFunction(ctx, decl);\r\n        }\r\n\r\n        if (callee) {\r\n            this.emitExpression(ctx, callee);\r\n            this.emitChar('.');\r\n            this.emitNoSpace();\r\n        }\r\n        this.emitKeyword(rename(decl));\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(ctx, args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitReturnStmt(ctx: ContextT, stmt: IReturnStmtInstruction) {\r\n        this.emitKeyword('return');\r\n        this.emitSpace();\r\n        this.emitExpression(ctx, stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitExpressionStmt(ctx: ContextT, stmt: IExprStmtInstruction) {\r\n        this.emitExpression(ctx, stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitLocalVariable(ctx: ContextT, stmt: IVariableDeclInstruction) {\r\n        this.emitVariable(ctx, stmt);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitGlobalVariable(ctx: ContextT, decl: IVariableDeclInstruction) {\r\n        if (ctx.has(decl.name)) {\r\n            return;\r\n        }\r\n\r\n        ctx.add(decl.name);\r\n\r\n        this.begin();\r\n        this.emitVariable(ctx, decl);\r\n        this.emitChar(';');\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitComplexField(ctx: ContextT, instr: IVariableDeclInstruction) {\r\n        console.assert(instr.instructionType === EInstructionTypes.k_VariableDecl);\r\n\r\n        this.emitVariable(ctx, instr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitDeclStmt(ctx: ContextT, stmt: IDeclStmtInstruction) {\r\n        stmt.declList.forEach(decl => {\r\n            console.assert(decl.instructionType === EInstructionTypes.k_VariableDecl);\r\n            this.emitLocalVariable(ctx, decl as IVariableDeclInstruction);\r\n        });\r\n    }\r\n\r\n\r\n    /*\r\n        | IStmtBlockInstruction\r\n        | IWhileStmtInstruction\r\n        | IForStmtInstruction;\r\n    */\r\n    emitStmt(ctx: ContextT, stmt: IInstruction) {\r\n        switch (stmt.instructionType) {\r\n            case EInstructionTypes.k_DeclStmt:\r\n                this.emitDeclStmt(ctx, stmt as IDeclStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ExprStmt:\r\n                this.emitExpressionStmt(ctx, stmt as IExprStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                this.emitReturnStmt(ctx, stmt as IReturnStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                this.emitChar(';');\r\n                break;\r\n            case EInstructionTypes.k_IfStmt:\r\n                this.emitIfStmt(ctx, stmt as IIfStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_StmtBlock:\r\n                this.emitBlock(ctx, stmt as IStmtBlockInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ForStmt:\r\n                this.emitForStmt(ctx, stmt as IForStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_BreakStmt:\r\n                this.emitBreakStmt(ctx, stmt as BreakStmtInstruction);\r\n                break;\r\n            default:\r\n                this.emitLine(`/* ... unsupported stmt '${stmt.instructionName}' .... */`);\r\n                console.warn(`unknown stmt found: '${stmt.instructionName}'`);\r\n        }\r\n    }\r\n\r\n\r\n    emitBlock(ctx: ContextT, blk: IStmtBlockInstruction) {\r\n        // if (!blk.stmtList.length)\r\n        // {\r\n        //     this.emitChar(';');\r\n        //     return;\r\n        // }\r\n\r\n        this.emitChar('{');\r\n        this.push();\r\n        blk.stmtList.forEach(stmt => (this.emitStmt(ctx, stmt), this.emitNewline()));\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n\r\n    emitPass(ctx: ContextT, pass: IPassInstruction) {\r\n        this.emitKeyword('pass');\r\n        pass.name && this.emitKeyword(pass.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        this.emitPassBody(ctx, pass);\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitPassBody(ctx: ContextT, pass: IPassInstruction) {\r\n        // TODO: replace with emitCompile();\r\n        if (pass.vertexShader) {\r\n            this.emitFunction(ctx, pass.vertexShader);\r\n\r\n            this.emitKeyword('VertexShader');\r\n            this.emitKeyword('=');\r\n            this.emitKeyword('compile');\r\n            this.emitKeyword(pass.vertexShader.name);\r\n            this.emitChar('()');\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        }\r\n\r\n        if (pass.pixelShader) {\r\n            this.emitFunction(ctx, pass.pixelShader);\r\n\r\n            this.emitKeyword('PixelShader');\r\n            this.emitKeyword('=');\r\n            this.emitKeyword('compile');\r\n            this.emitKeyword(pass.pixelShader.name);\r\n            this.emitChar('()');\r\n            this.emitChar(';');\r\n            this.emitNewline();\r\n        }\r\n\r\n        if (pass.renderStates) {\r\n            for (let key in pass.renderStates) {\r\n                const state = pass.renderStates[key];\r\n                if (state != ERenderStateValues.UNDEF) {\r\n                    this.emitKeyword(ERenderStates[Number(key)]);\r\n                    this.emitChar('=');\r\n                    this.emitKeyword(ERenderStateValues[state]);\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.emitNewline();\r\n\r\n        // mwalk(pass.renderStates, (val, key) => {\r\n        //     console.log(ERenderStates[key], ERenderStateValues[val]);\r\n        // });\r\n    }\r\n\r\n\r\n    emit(ctx: ContextT, instr: IInstruction): CodeEmitter<ContextT> {\r\n        if (!instr) {\r\n            // TODO: emit error.\r\n            this.emitLine('/* ... empty instruction .... */');\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isExpression(instr)) {\r\n            this.emitExpression(ctx, instr as IExprInstruction);\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isStatement(instr)) {\r\n            this.emitStmt(ctx, instr);\r\n            return this;\r\n        }\r\n\r\n        //\r\n        // Other types\r\n        //\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                this.emitFunction(ctx, instr as IFunctionDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_CbufferDecl:\r\n                this.emitCbuffer(ctx, instr as ICbufferInstruction);\r\n                break;\r\n            case EInstructionTypes.k_VariableDecl:\r\n                this.emitGlobalVariable(ctx, instr as IVariableDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_Collector:\r\n                this.emitCollector(ctx, instr as IInstructionCollector);\r\n                break;\r\n            case EInstructionTypes.k_TypeDecl:\r\n                this.emitTypeDecl(ctx, instr as ITypeDeclInstruction);\r\n                break;\r\n            case EInstructionTypes.k_TypedefDecl:\r\n                this.emitTypedef(ctx, instr as ITypedefInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ComplexType:\r\n            case EInstructionTypes.k_VariableType:\r\n                // todo: addComplexType ?\r\n                this.emitComplexTypeDecl(ctx, instr as ITypeInstruction);\r\n                break;\r\n            default:\r\n                this.emitLine(`/* ... unsupported instruction '${instr.instructionName}' .... */`);\r\n                assert(false, `unsupported instruction found: ${instr.instructionName}`);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    private static cEmitter = new CodeEmitter({ omitEmptyParams: true });\r\n\r\n    static translate(instr: IInstruction, ctx: CodeContext = new CodeContext): string {\r\n        return CodeEmitter.cEmitter.emit(ctx, instr).toString();\r\n    }\r\n\r\n    static translateDocument(document: ISLDocument, ctx: CodeContext = new CodeContext): string {\r\n        if (isNull(document)) {\r\n            return '';\r\n        }\r\n\r\n        if (isNull(document.root)) {\r\n            return '';\r\n        }\r\n\r\n        return CodeEmitter.translate(document.root, ctx);\r\n    }\r\n}\r\n\r\n// export function emit(instr: IInstruction): string {\r\n//     return CodeEmitter.translate(instr);\r\n// }\r\n","export function createOutput({ tab = '\\t', nl = '\\n', name = null } = {}) {\r\n    let data: string[] = [''];\r\n    let nesting = [];\r\n    let count = 0;\r\n    let noNextSpace = false;\r\n\r\n    const push = (pad = tab) => (nesting.push(pad), count && newline());\r\n    const pop = () => (nesting.pop(), count && newline());\r\n    const toString = () => data.join(nl);\r\n    const ignoreNextSpace = () => noNextSpace = true;\r\n\r\n    function add(val: string) {\r\n        if (!count) {\r\n            for (let i = 0; i < nesting.length; ++i) val = nesting[i] + val;\r\n        }\r\n        \r\n        data[data.length - 1] += val;\r\n        count++;\r\n        noNextSpace = false;\r\n    }\r\n\r\n    function keyword(token: string) {\r\n        !noNextSpace && count && add(' ');\r\n        add(token);\r\n    }\r\n\r\n    function newline() {\r\n        data.push('');\r\n        count = 0;\r\n    }\r\n\r\n    function isEmpty() {\r\n        return data.length == 1 && \r\n            data[0].length == 0;\r\n    }\r\n\r\n    return {\r\n        isEmpty,\r\n        keyword,\r\n        ignoreNextSpace,\r\n        push,\r\n        pop,\r\n        newline,\r\n        add,\r\n        toString,\r\n        name\r\n    };\r\n}\r\n\r\n\r\nexport type IOutput = ReturnType<typeof createOutput>;","export enum EAnalyzerErrors {\r\n    SystemTypeRedefinition = 2202,\r\n    TypeRedefinition,\r\n    VariableRedefinition,\r\n    SystemVariableRedefinition,\r\n    FunctionRedifinition,\r\n    CbufferRedefinition,\r\n    SystemFunctionRedefinition,\r\n\r\n    UnsupportedTypeDecl,\r\n    UnsupportedExpr,\r\n    UnknownVarName,\r\n    UnknownInstruction,\r\n    InvalidArithmeticOperation,\r\n    InvalidArithmeticAssigmentOperation,\r\n    InvalidAssigmentOperation,\r\n    InvalidBitwiseOperation,\r\n    InvalidLeftHandSideInAssignment,\r\n    InvalidRelationalOperation,\r\n    InvalidLogicOperation,\r\n    InvalidConditionType ,\r\n    InvalidConditonValueTypes,\r\n    InvalidCastTypeUsage,\r\n    InvalidCastTypeNotBase,\r\n    InvalidCastUnknownType,\r\n    InvalidUnaryOperation,\r\n    InvalidPostfixNotArray,\r\n    InvalidPostfixNotIntIndex,\r\n    InvalidPostfixNotField,\r\n    InvalidPostfixArithmetic,\r\n    InvalidComplexNotFunction,\r\n    InvalidComplexNotType,\r\n    InvalidComplexNotConstructor,\r\n    InvalidCompileNotFunction,\r\n    InvalidCompileFunctionNotValid,\r\n    FunctionRedefinition,\r\n    InvalidWhileCondition,\r\n    InvalidDoWhileCondition,\r\n    InvalidIfCondition,\r\n    InvalidForInitExpr,\r\n    InvalidForInitEmptyIterator,\r\n    InvalidForConditionEmpty,\r\n    InvalidForConditionRelation,\r\n    InvalidForStepEmpty,\r\n    InvalidForStepOperator,\r\n    InvalidForStepExpr,\r\n    InvalidNewFieldForStructName,\r\n    InvalidNewFieldForStructSematic,\r\n    InvalidNewAnnotationVar,\r\n    InvalidFunctionParameterDefenitionDefaultNeeded,\r\n    CannotChooseFunction,\r\n    InvalidFuncDefenitionReturnType,\r\n    InvalidSystemFunctionReturnType,\r\n    InvalidTypeNameNotType,\r\n    InvalidTypeNameTemplateNotFound,\r\n    InvalidTypeScope,\r\n    CannotProduceType,\r\n    InvalidTypeVectorMatrix,\r\n    TechniqueNameRedefinition,\r\n    InvalidFunctionRecursionNotAllowed,\r\n    InvalidFunctionImplementationNotFound,\r\n    // InvalidFunctionUsageVertex,\r\n    // InvalidFunctionUsagePixel,\r\n    FunctionIsNotCompatibleWithVertexShader,\r\n    FunctionIsNotCompatibleWithPixelShader,\r\n    InvalidReturnStmtVoid,\r\n    InvalidReturnStmtEmpty,\r\n    InvalidReturnStmtTypesNotEqual,\r\n    InvalidFunctionReturnType,\r\n    InvalidFunctionParameterUsage,\r\n    InvalidTypeForWriting,\r\n    InvalidTypeForReading,\r\n    InvalidExprIsNotLValue,\r\n    InvalidVariableInitializing,   // TODO: << remove (see desc below)\r\n    InvalidVariableInitializingEx, // TODO: << remove error in favor of custom errors\r\n    UnsupportedStateIndex,\r\n    InvalidSamplerTexture,\r\n    CannotCalcPadding,\r\n    ImportedComponentNotExists,\r\n    InvalidFunctionReturnStmtNotFound,\r\n    UnsupportedProvideAs,\r\n    UnreachableCode,\r\n    OperatorCannotBeUsedWithGivenLValue, // for ex.: cannot perfom (bool4)x*=(int4)y;\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    PartFx_VertexShaderParametersMismatch,\r\n    PartFx_InvalidSpawnStmtInitializerNotFound,\r\n    // PartFx_RenderPassWasNotFound, // << moved to warnings\r\n    PartFx_DrawOpOnlyAllowedWithinUpdateRoutine\r\n};\r\n","export enum EAnalyzerWarnings {\r\n    UnsupportedRenderStateTypeUsed = 3000,\r\n    IncompleteTechnique,\r\n    IncompletePass,\r\n    UselessPassState,\r\n    EmptySemicolon,\r\n    InvalidCbufferRegister,\r\n\r\n    ImplicitTypeConversion,\r\n    ImplicitTypeTruncation,\r\n\r\n    Deprecated,\r\n\r\n    // part fx\r\n    PartFx_SortingCannotBeApplied,\r\n    PartFx_PresetPropertyHasNotBeenFound,\r\n    PartFx_RenderPassWasNotFound,\r\n    PartFx_EmitterPersistentDataMustBeMarkedAsInout,\r\n\r\n    ExternCall\r\n}","/** @deprecated */\r\nexport enum ERenderStateValues {\r\n    UNDEF = 0,\r\n\r\n    TRUE,\r\n    FALSE,\r\n\r\n    ZERO,\r\n    ONE,\r\n    SRCCOLOR,\r\n    INVSRCCOLOR,\r\n    SRCALPHA,\r\n    INVSRCALPHA,\r\n    DESTALPHA,\r\n    INVDESTALPHA,\r\n    DESTCOLOR,\r\n    INVDESTCOLOR,\r\n    SRCALPHASAT,\r\n\r\n    NONE,\r\n    CW,\r\n    CCW,\r\n    FRONT,\r\n    BACK,\r\n    FRONT_AND_BACK,\r\n\r\n    NEVER,\r\n    LESS,\r\n    EQUAL,\r\n    LESSEQUAL,\r\n    GREATER,\r\n    NOTEQUAL,\r\n    GREATEREQUAL,\r\n    ALWAYS,\r\n\r\n    FUNCADD,\r\n    FUNCSUBTRACT,\r\n    FUNCREVERSESUBTRACT,\r\n\r\n    // HACK: temp hack\r\n    LINELIST,\r\n    LINESTRIP,\r\n    TRIANGLELIST,\r\n    TRAINGLESTRIP,\r\n    POINTLIST\r\n}\r\n/*\r\n//\r\n//\r\n//\r\n\r\nexport enum BLEND {\r\n    ZERO = 1,\r\n    ONE = 2,\r\n    SRC_COLOR = 3,\r\n    INV_SRC_COLOR = 4,\r\n    SRC_ALPHA = 5,\r\n    INV_SRC_ALPHA = 6,\r\n    DEST_ALPHA = 7,\r\n    INV_DEST_ALPHA = 8,\r\n    DEST_COLOR = 9,\r\n    INV_DEST_COLOR = 10,\r\n    SRC_ALPHA_SAT = 11,\r\n    BLEND_FACTOR = 14,\r\n    INV_BLEND_FACTOR = 15,\r\n    SRC1_COLOR = 16,\r\n    INV_SRC1_COLOR = 17,\r\n    SRC1_ALPHA = 18,\r\n    INV_SRC1_ALPHA = 19\r\n};\r\n\r\n\r\nexport enum BLEND_OP {\r\n    ADD = 1,\r\n    SUBTRACT = 2,\r\n    REV_SUBTRACT = 3,\r\n    MIN = 4,\r\n    MAX = 5\r\n};\r\n\r\n\r\nexport class RENDER_TARGET_BLEND_DESC {\r\n    BlendEnable: boolean;\r\n    SrcBlend: BLEND;\r\n    DestBlend: BLEND;\r\n    BlendOp: BLEND_OP;\r\n    SrcBlendAlpha: BLEND;\r\n    DestBlendAlpha: BLEND;\r\n    BlendOpAlpha: BLEND_OP;\r\n    RenderTargetWriteMask: number;\r\n};\r\n\r\n\r\n//\r\n//\r\n//\r\n\r\nexport enum DEPTH_WRITE_MASK {\r\n    ZERO = 0,\r\n    ALL = 1\r\n};\r\n\r\n\r\nexport enum COMPARISON_FUNC {\r\n    NEVER = 1,\r\n    LESS = 2,\r\n    EQUAL = 3,\r\n    LESS_EQUAL = 4,\r\n    GREATER = 5,\r\n    NOT_EQUAL = 6,\r\n    GREATER_EQUAL = 7,\r\n    ALWAYS = 8\r\n};\r\n\r\n\r\nexport enum STENCIL_OP {\r\n    KEEP = 1,\r\n    ZERO = 2,\r\n    REPLACE = 3,\r\n    INCR_SAT = 4,\r\n    DECR_SAT = 5,\r\n    INVERT = 6,\r\n    INCR = 7,\r\n    DECR = 8\r\n};\r\n\r\n\r\nexport class DEPTH_STENCILOP_DESC {\r\n    StencilFailOp: STENCIL_OP;\r\n    StencilDepthFailOp: STENCIL_OP;\r\n    StencilPassOp: STENCIL_OP;\r\n    StencilFunc: COMPARISON_FUNC;\r\n};\r\n\r\n//\r\n//\r\n//\r\n\r\nexport enum PRIMITIVE_TOPOLOGY {\r\n    UNDEFINED = 0,\r\n    POINTLIST = 1,\r\n    LINELIST = 2,\r\n    LINESTRIP = 3,\r\n    TRIANGLELIST = 4,\r\n    TRIANGLESTRIP = 5,\r\n    LINELIST_ADJ = 10,\r\n    LINESTRIP_ADJ = 11,\r\n    TRIANGLELIST_ADJ = 12,\r\n    TRIANGLESTRIP_ADJ = 13\r\n};\r\n\r\n//\r\n//\r\n//\r\n\r\nenum CULL_MODE {\r\n    NONE = 1,\r\n    FRONT = 2,\r\n    BACK = 3,\r\n    // ?\r\n    FRONT_AND_BACK = 4\r\n};\r\n\r\n\r\nenum FILL_MODE {\r\n    WIREFRAME = 2,\r\n    SOLID = 3\r\n};\r\n\r\n\r\nclass RASTERIZER_DESC {\r\n    FillMode: FILL_MODE;\r\n    CullMode: CULL_MODE;\r\n    FrontCounterClockwise: boolean;\r\n    DepthBias: number;\r\n    DepthBiasClamp: number;\r\n    SlopeScaledDepthBias: number;\r\n    DepthClipEnable: boolean;\r\n    ScissorEnable: boolean;\r\n    MultisampleEnable: boolean;\r\n    AntialiasedLineEnable: boolean;\r\n}\r\n*/\r\n","\r\n/** @deprecated */\r\nexport enum ERenderStates {\r\n\tBLENDENABLE,\r\n\tCULLFACEENABLE,\r\n\tZENABLE,\r\n\tZWRITEENABLE,\r\n\tDITHERENABLE,\r\n\tSCISSORTESTENABLE,\r\n\tSTENCILTESTENABLE,\r\n\tPOLYGONOFFSETFILLENABLE,\r\n\r\n\tCULLFACE,\r\n\tFRONTFACE,\r\n\r\n\tSRCBLENDCOLOR,\r\n\tDESTBLENDCOLOR,\r\n\r\n\tSRCBLENDALPHA,\r\n\tDESTBLENDALPHA,\r\n\r\n\tBLENDEQUATIONCOLOR,\r\n\tBLENDEQUATIONALPHA,\r\n\r\n\tZFUNC,\r\n\r\n\tALPHABLENDENABLE,\r\n\tALPHATESTENABLE,\r\n\r\n\tSRCBLEND, // Fake, set SRCBLENDCOLOR, SRCBLENDALPHA. Not use in setRenderState\r\n\tDESTBLEND, // Fake, set DESTBLENDCOLOR, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDFUNC, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\tBLENDFUNCSEPARATE, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDEQUATION, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\tBLENDEQUATIONSEPARATE, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\r\n\r\n\t// HACK:\r\n\tPRIMITIVETOPOLOGY,\r\n}\r\n","import { IPosition, IRange } from \"./parser/IParser\";\r\n\r\nexport enum EDiagnosticCategory {\r\n    k_Warning,\r\n    k_Error\r\n}\r\n\r\n\r\nexport interface IDiagnosticEntry<DESC_T> {\r\n    category: EDiagnosticCategory;\r\n    code: number;\r\n    desc: DESC_T;\r\n}\r\n\r\n\r\ntype IDiagnosticDescription = string;\r\n\r\nexport interface IDiagnosticMessage extends IRange {\r\n    code: string;\r\n    category: EDiagnosticCategory;\r\n    start: IPosition;\r\n    end: IPosition;\r\n    /** @deprecated */\r\n    file?: string;\r\n    content: string;\r\n}\r\n\r\nexport interface IDiagnosticReport {\r\n    errors: number;\r\n    warnings: number;\r\n\r\n    messages: IDiagnosticMessage[];\r\n}\r\n\r\n\r\n\r\nexport interface IDiagnostics<DESC_T> {\r\n    reset(): void;\r\n    resolve(): IDiagnosticReport;\r\n    error(code: number, desc: DESC_T);\r\n    warning(code: number, desc: DESC_T);\r\n    critical(code: number, desc: DESC_T);\r\n    prettyPrint(): string;\r\n    hasErrors(): boolean;\r\n    getLastError(): IDiagnosticMessage;\r\n}\r\n","import { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport enum EInstructionTypes {\r\n    k_Instruction = 0,\r\n    \r\n    k_Id,\r\n    k_Provide,\r\n    k_Collector,\r\n    k_Keyword,      // FIXME: useless type\r\n    k_Simple,       // FIXME: useless type\r\n    k_SamplerState,\r\n    k_Attribute,\r\n    k_Annotation,   // FIXME: instruction is not fully implemented\r\n    k_UsageType,    // FIXME: instruction is not implemented\r\n    \r\n    k_Typed,        // NOTE: Abstract type\r\n    k_VariableType,\r\n    k_SystemType,\r\n    k_ComplexType,  // todo: merge with system type\r\n    k_ProxyType,\r\n    \r\n    k_Expr,         // NOTE: Abstract type\r\n    k_IdExpr,\r\n    k_IntExpr,\r\n    k_FloatExpr,\r\n    k_BoolExpr,\r\n    k_StringExpr,\r\n    k_NullExpr,\r\n    k_ArithmeticExpr,\r\n    k_AssignmentExpr,\r\n    k_BitwiseExpr,\r\n    k_RelationalExpr,\r\n    k_LogicalExpr,\r\n    k_ConditionalExpr,\r\n    k_CastExpr,\r\n    k_UnaryExpr,\r\n    k_PostfixIndexExpr,\r\n    k_PostfixPointExpr,\r\n    k_PostfixArithmeticExpr,\r\n    k_ComplexExpr,\r\n    k_FunctionCallExpr,\r\n    k_ConstructorCallExpr,\r\n    /** @deprecated */\r\n    k_CompileExpr,\r\n    k_CompileShader11Expr,\r\n    k_InitExpr,\r\n    k_StateBlockExpr,\r\n    /** @deprecated */\r\n    k_SamplerStateBlockExpr,\r\n\r\n    k_Decl,\r\n    k_TypeDecl,\r\n    k_TypedefDecl,\r\n    k_VariableDecl,\r\n    k_StructDecl,\r\n    k_FunctionDecl,\r\n    k_SystemFunctionDecl,\r\n    k_FunctionDef,\r\n    /** @deprecated */\r\n    k_PassDecl,\r\n    /** @deprecated */\r\n    k_TechniqueDecl,\r\n    k_Technique11Decl,\r\n    k_CbufferDecl,\r\n    \r\n    k_Stmt,\r\n    k_ExprStmt,\r\n    k_BreakStmt,\r\n    k_WhileStmt,\r\n    k_ForStmt,\r\n    k_IfStmt,\r\n    k_DeclStmt,\r\n    k_ReturnStmt,\r\n    k_SemicolonStmt,\r\n    k_StmtBlock,\r\n    \r\n    // part fx\r\n    k_PartFxDecl,\r\n    k_PartFxPass,\r\n    k_SpawnStmt,\r\n    k_DrawStmt,\r\n    k_PresetDecl,\r\n    k_PresetProperty\r\n}\r\n\r\n\r\nexport enum ECheckStage {\r\n    CODE_TARGET_SUPPORT, /* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */\r\n    SELF_CONTAINED /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */\r\n    // VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ \r\n}\r\n\r\nexport enum EVarUsedMode {\r\n    k_Read,\r\n    k_Write,\r\n    k_ReadWrite,\r\n    k_Undefined,\r\n    k_Default = k_ReadWrite\r\n}\r\n\r\n\r\nexport interface IInstructionError {\r\n    code: number;\r\n    info: any;\r\n}\r\n\r\nexport interface ITypeUseInfoContainer {\r\n    type: IVariableTypeInstruction;\r\n    isRead: boolean;\r\n    isWrite: boolean;\r\n    numRead: number;\r\n    numWrite: number;\r\n    numUsed: number;\r\n}\r\n\r\nexport enum EExtractExprType {\r\n    k_Header,\r\n\r\n    k_Float,\r\n    k_Int,\r\n    k_Bool,\r\n\r\n    k_Float2,\r\n    k_Int2,\r\n    k_Bool2,\r\n\r\n    k_Float3,\r\n    k_Int3,\r\n    k_Bool3,\r\n\r\n    k_Float4,\r\n    k_Int4,\r\n    k_Bool4,\r\n\r\n    k_Float4x4\r\n}\r\n\r\n\r\nexport enum EScopeType {\r\n    k_System,\r\n    k_Global,\r\n    k_Default,\r\n    k_Struct,\r\n    k_Cbuffer,\r\n    k_Annotation\r\n}\r\n\r\n\r\nexport interface ITypeTemplate {\r\n    readonly name: string;\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction;\r\n    typeName(args?: ITypeInstruction[]): string;\r\n}\r\n\r\n\r\nexport interface IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly techniques11: IMap<ITechnique11Instruction>;\r\n    readonly cbuffers: IMap<ICbufferInstruction>;\r\n\r\n    /** Recursive check for all parents for strict mode */\r\n    isStrict(): boolean;\r\n\r\n    findVariable(variableName: string): IVariableDeclInstruction;\r\n    findType(typeName: string): ITypeInstruction;\r\n    findTypeTemplate(typeName: string): ITypeTemplate;\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction | null | undefined;\r\n    /** @deprecated */\r\n    findTechnique(techName: string): ITechniqueInstruction | null;\r\n    findTechnique11(techName: string): ITechnique11Instruction | null;\r\n    findCbuffer(cbufName: string): ICbufferInstruction | null;\r\n\r\n    /** @deprecated */\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction;\r\n\r\n    addVariable(variable: IVariableDeclInstruction): boolean;\r\n    addType(type: ITypeInstruction): boolean;\r\n    addTypeAlias(typeName: string, aliasName: string): boolean;\r\n    addTypeAlias(type: ITypeInstruction, aliasName: string): boolean;\r\n    addTypeTemplate(template: ITypeTemplate): boolean;\r\n    addFunction(func: IFunctionDeclInstruction): boolean;\r\n    /** @deprecated */\r\n    addTechnique(technique: ITechniqueInstruction): boolean;\r\n    addTechnique11(technique: ITechnique11Instruction): boolean;\r\n    addCbuffer(cbuf: ICbufferInstruction): boolean;\r\n}\r\n\r\n\r\n/**\r\n * All opertion are represented by: \r\n * operator : arg1 ... argn\r\n * Operator and instructions may be empty.\r\n */\r\nexport interface IInstruction {\r\n    readonly parent: IInstruction;\r\n    readonly scope: IScope;\r\n\r\n    readonly sourceNode: IParseNode | null;\r\n    readonly instructionType: EInstructionTypes;\r\n    readonly instructionID: number;\r\n    readonly instructionName: string;\r\n\r\n    toString(): string;\r\n    toCode(): string;\r\n\r\n    /** Internal API */\r\n    $withParent<T extends IInstruction>(parent: IInstruction): T;\r\n    $withNoParent<T extends IInstruction>(): T;\r\n}\r\n\r\n\r\nexport interface IInstructionCollector extends IInstruction {\r\n    readonly instructions: IInstruction[];\r\n}\r\n\r\n\r\nexport interface ISimpleInstruction extends IInstruction {\r\n    readonly value: string;\r\n}\r\n\r\n\r\nexport interface IProvideInstruction extends IInstruction {\r\n    readonly moduleName: string;\r\n}\r\n\r\n\r\n\r\nexport interface ITypeInstruction extends IInstruction {\r\n    readonly size: number;\r\n    readonly name: string;\r\n    readonly baseType: ITypeInstruction;\r\n    readonly length: number;\r\n    readonly arrayElementType: ITypeInstruction;\r\n\r\n    readonly writable: boolean;\r\n    readonly readable: boolean;\r\n\r\n    readonly fields: IVariableDeclInstruction[];\r\n    readonly methods: IFunctionDeclInstruction[];\r\n\r\n    // Returns true if it's allowed to apply [] operator.\r\n    isArray(): boolean;\r\n    // Returns true is type is user defined array.\r\n    // an user defined array like: float f[4]\r\n    // not: float4 \r\n    isNotBaseArray(): boolean;\r\n    // Returns true if it's user defined structure\r\n    // todo: move to types.isComplex()\r\n    isComplex(): boolean;\r\n\r\n    hasFieldWithSematics(semantic: string);\r\n    hasAllUniqueSemantics(): boolean;\r\n    hasFieldWithoutSemantics(): boolean;\r\n\r\n    /** \r\n     * @deprecated \r\n     * todo: move to types.findFieldByName(type, name)\r\n     */\r\n    getField(fieldName: string): IVariableDeclInstruction;\r\n    /** \r\n     * @deprecated \r\n     * todo: move to types.findFieldBySemantic(type, name)\r\n     */\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction;\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    getMethod(methodName: string, args?: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction;\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string;\r\n}\r\n\r\n\r\nexport type IVariableUsage = 'uniform' | 'const' | 'in' | 'out' | 'inout' | 'unsigned' | 'static' | 'precise';\r\n\r\nexport interface IVariableTypeInstruction extends ITypeInstruction {\r\n    readonly usages: IVariableUsage[];\r\n    readonly subType: ITypeInstruction;\r\n    readonly padding: number;\r\n    readonly aligment: number;\r\n\r\n    isUniform(): boolean;\r\n    isStatic(): boolean;\r\n    isConst(): boolean;\r\n\r\n    // for structures internal usage\r\n    $overwritePadding(padding: number, aligment: number): void;\r\n}\r\n\r\n\r\nexport interface ITypedInstruction extends IInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface IConditionalExprInstruction extends IExprInstruction {\r\n    readonly condition: IExprInstruction;\r\n    readonly left: ITypedInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IDeclInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly semantic: string;\r\n    readonly annotation: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionDefInstruction extends IDeclInstruction {\r\n    readonly returnType: IVariableTypeInstruction;\r\n    readonly name: string;\r\n    readonly params: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface ITypeDeclInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface ITypedefInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly alias: string;\r\n}\r\n\r\n\r\nexport interface IRegister {\r\n    type: 'u' | 'b' | 't' | 's' | null;\r\n    index: number;\r\n    // space ?\r\n};\r\n\r\nexport interface ICbufferInstruction extends IDeclInstruction, ITypedInstruction {\r\n    \r\n}\r\n\r\n\r\nexport interface ISamplerStateInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly value: IInstruction;\r\n}\r\n\r\n\r\nexport interface IVariableDeclInstruction extends IDeclInstruction, ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly initExpr: IExprInstruction;\r\n    readonly usageFlags: number;\r\n\r\n    isParameter(): boolean;\r\n    isLocal(): boolean;\r\n    isGlobal(): boolean;\r\n    isField(): boolean;\r\n    // is part of the constant buffer ?\r\n    isConstant(): boolean;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclInstruction extends IDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStructDeclInstruction extends IInstruction {\r\n\r\n}\r\n\r\n\r\nexport interface IIdInstruction extends IInstruction {\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface IKeywordInstruction extends IInstruction {\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface IExprInstruction extends ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n\r\n    isConst(): boolean;\r\n    isConstExpr(): boolean;\r\n}\r\n\r\nexport type ILogicalOperator = \"&&\" | \"||\";\r\n\r\nexport interface ILogicalExprInstruction extends IExprInstruction {\r\n    operator: ILogicalOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IBitwiseOperator = \">>\" | \"<<\" | \"&\" | \"|\" | \"^\";\r\n\r\nexport interface IBitwiseExprInstruction extends IExprInstruction {\r\n    operator: IBitwiseOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IUnaryOperator = \"+\" | \"-\" | \"!\" | \"++\" | \"--\";\r\n\r\nexport interface IUnaryExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: IUnaryOperator;\r\n}\r\n\r\nexport interface IPostfixPointInstruction extends IExprInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixIndexInstruction extends IExprInstruction {\r\n    readonly index: IExprInstruction;\r\n    readonly element: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IConstructorCallInstruction extends IExprInstruction {\r\n    readonly args: IInstruction[];\r\n    readonly ctor: IVariableTypeInstruction;\r\n}\r\n\r\nexport type IArithmeticOperator = '+' | '-' | '/' | '*' | '%';\r\n\r\n\r\nexport interface IArithmeticExprInstruction extends IExprInstruction {\r\n    readonly right: IExprInstruction;\r\n    readonly left: IExprInstruction;\r\n    readonly operator: IArithmeticOperator;\r\n}\r\n\r\nexport interface ICastExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    /** @deprecated */\r\n    isUseless(): boolean;\r\n}\r\n\r\n\r\nexport interface IComplexExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixArithmeticInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\n/** @deprecated */\r\nexport interface ISamplerStateBlockInstruction extends IExprInstruction {\r\n    readonly texture: IVariableDeclInstruction;\r\n    readonly params: ISamplerStateInstruction[];\r\n    readonly operator: string;\r\n}\r\n\r\n\r\n/** @deprecated */\r\nexport interface ICompileExprInstruction extends IExprInstruction {\r\n    readonly function: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\nexport interface ICompileShader11Instruction extends IExprInstruction {\r\n    readonly ver: string;\r\n    readonly func: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\nexport interface IRelationalExprInstruction extends IExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\nexport interface IAssignmentExprInstruction extends IExprInstruction {\r\n    readonly operator: string;\r\n    readonly left: IExprInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IInitExprInstruction extends IExprInstruction {\r\n    readonly args: IExprInstruction[];\r\n\r\n    // Returns true if it's not a base array initialization, like \"int a[2] = { 1, 1 }\"\r\n    /** @deprecated */\r\n    isArray(): boolean;\r\n\r\n    // todo: refactor this!!\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean;\r\n}\r\n\r\n\r\nexport interface IStateBlockInstruction extends IExprInstruction {\r\n    readonly props: Object; // native json?\r\n    readonly blocks: IStateBlockInstruction[];\r\n}\r\n\r\n\r\nexport interface IIdExprInstruction extends IExprInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    /** @helpers */\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionCallInstruction extends IExprInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // move it to method?\r\n    readonly decl: IFunctionDeclInstruction;   \r\n}\r\n\r\n\r\nexport interface ILiteralInstruction<T = number | boolean | string> extends IExprInstruction {\r\n    readonly value: T;\r\n}\r\n\r\n\r\nexport type IExprDerived =\r\n    | IArithmeticExprInstruction\r\n    | IAssignmentExprInstruction\r\n    | ICastExprInstruction\r\n    | ICompileExprInstruction\r\n    | ICompileShader11Instruction\r\n    | IComplexExprInstruction\r\n    | IConditionalExprInstruction\r\n    | IConstructorCallInstruction\r\n    | IFunctionCallInstruction\r\n    | IIdExprInstruction\r\n    | IInitExprInstruction\r\n    | IStateBlockInstruction\r\n    | ILiteralInstruction<number>\r\n    | ILiteralInstruction<boolean>\r\n    | ILiteralInstruction<string>\r\n    | ILogicalExprInstruction\r\n    | IPostfixArithmeticInstruction\r\n    | IPostfixIndexInstruction\r\n    | IPostfixPointInstruction\r\n    | IRelationalExprInstruction\r\n    | ISamplerStateBlockInstruction\r\n    | IUnaryExprInstruction;\r\n\r\nexport interface IAnnotationInstruction extends IInstruction {\r\n    decls: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtInstruction extends IInstruction {\r\n}\r\n\r\nexport interface IAttributeInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n}\r\n\r\nexport interface IForStmtInstruction extends IStmtInstruction {\r\n    readonly init: ITypedInstruction;\r\n    readonly cond: IExprInstruction;\r\n    readonly step: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n}\r\n\r\nexport type IDoWhileOperator = \"do\" | \"while\";\r\n\r\nexport interface IWhileStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n    readonly operator: IDoWhileOperator;\r\n}\r\n\r\nexport interface IDeclStmtInstruction extends IStmtInstruction {\r\n    readonly declList: IDeclInstruction[];\r\n}\r\n\r\nexport type IReturnOperator = \"return\";\r\n\r\nexport interface IReturnStmtInstruction extends IStmtInstruction {\r\n    readonly operator: IReturnOperator;\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\nexport interface IIfStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attrs: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtBlockInstruction extends IStmtInstruction {\r\n    readonly stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n\r\nexport interface IExprStmtInstruction extends IStmtInstruction {\r\n    expr: IExprInstruction;\r\n}\r\n\r\nexport type IPass11Instruction = IFunctionDeclInstruction;\r\n\r\n/** @deprecated */\r\nexport interface IPassInstruction extends IDeclInstruction {\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly vertexShader: IFunctionDeclInstruction;\r\n    readonly pixelShader: IFunctionDeclInstruction;\r\n\r\n    readonly renderStates: IMap<ERenderStateValues>;\r\n    getState(type: ERenderStates): ERenderStateValues;\r\n\r\n    /** check if the pass is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\n\r\nexport type IStmtDerived =\r\n    | IDeclStmtInstruction\r\n    | IReturnStmtInstruction\r\n    | IIfStmtInstruction\r\n    | IStmtBlockInstruction\r\n    | IExprStmtInstruction\r\n    | IWhileStmtInstruction\r\n    | IForStmtInstruction;\r\n\r\n\r\nexport enum ETechniqueType {\r\n    k_BasicFx,  // << basic Microsoft DirectX like effect\r\n    k_PartFx,\r\n    k_Unknown\r\n}\r\n\r\n//\r\n// Preset extention\r\n//\r\n\r\nexport interface IPresetPropertyInstruction extends IInstruction{ \r\n    id: IIdInstruction;\r\n    args: IExprInstruction[];\r\n \r\n    resolveDeclaration(): IVariableDeclInstruction;\r\n }\r\n \r\n export interface IPresetInstruction extends IDeclInstruction {\r\n    props: IPresetPropertyInstruction[];\r\n }\r\n\r\n//\r\n//\r\n//\r\n\r\nexport interface ITechniqueInstruction extends IDeclInstruction {\r\n    readonly passes: IPassInstruction[];\r\n    readonly type: ETechniqueType;\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n\r\n    // todo: separate from basic dx effect functionality (?)\r\n    // Preset extention (non-standart)\r\n    // note: see PRESETS_EX define in HLSL.gr\r\n    readonly presets: IPresetInstruction[];\r\n}\r\n\r\n\r\nexport interface ITechnique11Instruction extends IDeclInstruction {\r\n    readonly passes: IPass11Instruction[];\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\nexport interface IFunctionDeclListMap {\r\n    [functionName: string]: IFunctionDeclInstruction[];\r\n}\r\n\r\n","import { IDiagnosticReport, IDiagnostics } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { IKnownDefine } from '@lib/parser/Preprocessor';\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport enum ENodeCreateMode {\r\n    k_Default,\r\n    k_Necessary,\r\n    k_Expose,\r\n    k_Skip\r\n}\r\n\r\nexport enum EParserCode {\r\n    // k_Pause,\r\n    k_Ok,\r\n    k_Error\r\n}\r\n\r\nexport enum EParserType {\r\n    k_LR0,\r\n    k_LR1,\r\n    k_LALR\r\n}\r\n\r\nexport enum IASTDocumentFlags {\r\n    k_Optimize = 0x0008,\r\n    k_DeveloperMode = 0x0010\r\n}\r\n\r\n\r\nexport enum EParserFlags {\r\n    k_ForceAppendAll = 0x0001,\r\n    k_AllowExposeMode = 0x0002,\r\n    k_AllowAddMode = 0x0004,\r\n    k_AllowSkipMode = 0x008,\r\n    k_Default = k_AllowAddMode | k_AllowExposeMode | k_AllowSkipMode,\r\n    k_Debug = 0x0010\r\n}\r\n\r\n\r\nexport enum ETokenType {\r\n    k_NumericLiteral = 1,\r\n    k_SinglelineCommentLiteral,\r\n    k_MultilineCommentLiteral,\r\n    k_StringLiteral,\r\n    k_PunctuatorLiteral,\r\n    k_WhitespaceLiteral,\r\n    k_EscapeSequence,\r\n    k_NewlineLiteral,\r\n    k_IdentifierLiteral,\r\n    k_KeywordLiteral,\r\n    K_MacroLiteral,\r\n    k_Unknown,\r\n    k_End\r\n}\r\n\r\n\r\nexport type IFile = StringRef;\r\n\r\nexport interface IPosition {\r\n    file: IFile;\r\n    line: number;\r\n    column: number;\r\n    offset?: number;\r\n}\r\n\r\n// todo: add support for range over multiple files;\r\nexport interface IRange {\r\n    start: IPosition;\r\n    end: IPosition;\r\n\r\n    // see \"Preprocessor.ts\" for more details\r\n    // source?: IRange;\r\n}\r\n\r\nexport interface IToken {\r\n    index: number;\r\n    value: string;\r\n\r\n    name?: string;\r\n    type?: ETokenType;\r\n\r\n    loc?: IRange;\r\n}\r\n\r\n\r\n/**\r\n * Grammar rule corresponding to the entry from grammar file.\r\n */\r\nexport interface IRule {\r\n    left: string;\r\n    right: string[];\r\n\r\n    /**\r\n     * rule index based on parser's '_nRules'; \r\n     */\r\n    index: number;\r\n}\r\n\r\nexport enum EOperationType {\r\n    k_Error = 100,\r\n    k_Shift,\r\n    k_Reduce,\r\n    k_Success,\r\n    k_Ok\r\n}\r\n\r\nexport type IRuleFunction = () => EOperationType;// | Promise<EOperationType>;\r\n\r\nexport interface IParseNode {\r\n    children: IParseNode[];\r\n    parent: IParseNode;\r\n    name: string;\r\n    value: string;\r\n    loc?: IRange;\r\n}\r\n\r\nexport interface IParseTree {\r\n    readonly nodes: IParseNode[];\r\n    readonly lastNode: IParseNode;\r\n    readonly optimized: boolean;\r\n    readonly root: IParseNode;\r\n\r\n    addToken(pToken: IToken): void;\r\n    reduceByRule(pRule: IRule, eCreate: ENodeCreateMode): void;\r\n    finishTree(): void;\r\n\r\n    $pop(loc?: IRange): void;\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree;\r\n    /** @deprecated */\r\n    toString(): string;\r\n    /** @deprecated */\r\n    toHTMLString(node?: IParseNode, padding?: string): string;\r\n}\r\n\r\n\r\nexport interface ILexerEngine {\r\n    readonly keywords: IMap<string>;\r\n    readonly punctuators: IMap<string>;\r\n    readonly punctuatorsFirstSymbols: IMap<boolean>;\r\n\r\n\r\n    addPunctuator(value: string, name?: string): string;\r\n    addKeyword(value: string, name: string): string;\r\n\r\n    getTerminalValueByName(name: string): string;\r\n\r\n    isLineTerminator(symbol: string): boolean;\r\n    isKeyword(value: string): boolean;\r\n    isPunctuator(value: string): boolean;\r\n    isNumberStart(ch: string, ch1: string): boolean;\r\n    isCommentStart(ch: string, ch1: string): boolean;\r\n    isStringStart(ch: string): boolean;\r\n    isPunctuatorStart(ch: string): boolean;\r\n    isWhiteSpaceStart(ch: string): boolean;\r\n    isNewlineStart(ch: string): boolean;\r\n    isIdentifierStart(ch: string): boolean;\r\n    isEscapeSequenceStart(ch: string): boolean;\r\n}\r\n\r\nexport interface ILexerConfig {\r\n    engine?: ILexerEngine;\r\n    knownTypes?: Set<string>;\r\n    skipComments?: boolean;\r\n    allowLineTerminators?: boolean;\r\n}\r\n\r\n\r\nexport interface ILexer {\r\n    readonly document: ITextDocument;\r\n    readonly config: ILexerConfig;\r\n\r\n    setTextDocument(textDocument: ITextDocument): ILexer;\r\n    // FIXME: do not use any?\r\n    getPosition(): any;\r\n    setPosition(pos: any): void;\r\n    getDiagnosticReport(): IDiagnosticReport;\r\n    getNextToken(): IToken;\r\n    getNextLine(): IToken;\r\n}\r\n\r\nexport type IncludeResolver = (filename: string) => Promise<ITextDocument>;\r\n\r\nexport interface IASTConfig {\r\n    parser?: IParser;\r\n    knownTypes?: Set<string>;\r\n    ruleFunctions?: Map<string, IRuleFunction>;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n}\r\n\r\n\r\nexport interface IASTDocument {\r\n    readonly uri: IFile;\r\n    readonly diagnosticReport: IDiagnosticReport;\r\n    readonly root: IParseNode;\r\n}\r\n\r\n\r\n\r\n\r\nexport interface IOperation {\r\n    type: EOperationType;\r\n    rule?: IRule;\r\n    stateIndex?: number;\r\n}\r\n\r\nexport interface IOperationMap {\r\n    [grammarSymbol: string]: IOperation;\r\n    [stateIndex: number]: IOperation;\r\n}\r\n\r\nexport interface ISyntaxTable {\r\n    [stateIndex: number]: {\r\n        [terminal: string]: IOperation;\r\n    }\r\n}\r\n\r\n\r\nexport interface IRuleMap {\r\n    [ruleIndex: number]: IRule;\r\n}\r\n\r\nexport interface IProductions {\r\n    [nonTerminal: string]: IRuleMap;\r\n}\r\n\r\n// TODO: remove type\r\nexport interface IRuleFunctionMap {\r\n    [grammarSymbolOrFuncName: string]: string;\r\n}\r\n\r\nexport interface IRuleFunctionDMap {\r\n    [stateIndex: number]: IRuleFunctionMap;\r\n}\r\n\r\nexport interface IAdditionalFuncInfo {\r\n    name: string;\r\n    position: number;\r\n    rule: IRule;\r\n}\r\n\r\nexport interface IParser {\r\n    readonly lexerEngine: ILexerEngine;\r\n    readonly syntaxTable: ISyntaxTable;\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreateMode;\r\n    getGrammarSymbols(): Map<string, string>;\r\n}\r\n\r\n\r\nexport interface IParserParams {\r\n    grammar: string;\r\n    flags?: number; // EParserFlags\r\n    type?: EParserType;\r\n}\r\n\r\n\r\nexport type ExpectedSymbols = Set<string>;\r\n","import { ICompileExprInstruction, IExprInstruction, IPassInstruction, IStmtInstruction, ITechniqueInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// import { EPartFxInstructionTypes } from \"./IPartFxInstruction\";\r\n\r\nexport enum EPassDrawMode {\r\n   k_Auto,\r\n   k_Manual\r\n};\r\n\r\n\r\nexport interface IPartFxPassInstruction extends IPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly particleInstance: ITypeInstruction;\r\n    readonly geometry: string;\r\n    readonly instanceCount: number;\r\n    readonly drawMode: EPassDrawMode;\r\n}\r\n\r\n\r\n export interface IPartFxInstruction extends ITechniqueInstruction {\r\n\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    readonly passes: IPartFxPassInstruction[];\r\n }\r\n\r\n\r\n export interface ISpawnStmtInstruction extends IStmtInstruction {\r\n    readonly name: string;\r\n    readonly count: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    // resolved properties\r\n   //  readonly fx: IPartFxInstruction;\r\n   //  readonly init: IFunctionDeclInstruction;\r\n }\r\n\r\n export interface IDrawStmtInstruction extends IStmtInstruction {\r\n   readonly name: string;\r\n   readonly args: IExprInstruction[];\r\n}\r\n","import { createFXSLDocument } from '@lib/fx/FXSLDocument';\r\nimport { ILanguageService } from '@lib/idl/ILanguageService';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IASTDocumentFlags, IncludeResolver } from '@lib/idl/parser/IParser';\r\nimport { Color, ColorInformation, ColorPresentation, CompletionItem, CompletionList, FoldingRange, FormattingOptions, Hover, Position, Range, SymbolInformation, TextDocument, TextEdit } from 'vscode-languageserver-types';\r\n\r\nimport { FXCodeLenses } from './services/fx/codeLenses';\r\nimport { SLSignatureHelp } from './services/signatureHelp';\r\nimport { createSLASTDocument } from '@lib/fx/SLASTDocument';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { createTextDocument } from '@lib/fx/TextDocument';\r\nimport { IKnownDefine } from '@lib/parser/Preprocessor';\r\n\r\n// import { SLValidation } from './services/validation';\r\n\r\n// FIXME: use correct type\r\ntype SelectionRange = Range;\r\n\r\n\r\nexport function getLanguageService(opts: { flags: IASTDocumentFlags, includeResolver?: IncludeResolver, defines?: IKnownDefine[] }): ILanguageService {\r\n    const signatureHelp = new SLSignatureHelp();\r\n\r\n    //\r\n    // FX\r\n    //\r\n    \r\n    const fxCodeLenses = new FXCodeLenses();\r\n\r\n    return {\r\n        async $parseSLASTDocument(textDocument: TextDocument): Promise<ISLASTDocument> {\r\n            const uri = textDocument.uri;\r\n            const source = textDocument.getText();\r\n            const slastDocument = await createSLASTDocument(await createTextDocument(uri, source), opts);\r\n            return slastDocument;\r\n        },\r\n\r\n        async $parseSLDocument(slastDocument: ISLASTDocument): Promise<ISLDocument> {\r\n            return await createFXSLDocument(slastDocument);\r\n        },\r\n\r\n\r\n        async parseDocument(textDocument: TextDocument): Promise<ISLDocument> { \r\n            const uri = textDocument.uri;\r\n            const source = textDocument.getText();\r\n            return await createFXSLDocument(await createTextDocument(uri, source), opts);\r\n        },\r\n\r\n        doResolve(item: CompletionItem): Thenable<CompletionItem> { return null; },\r\n        doComplete(textDocument: TextDocument, position: Position, slDocument: ISLDocument): Thenable<CompletionList | null> { return null; },\r\n        findDocumentSymbols(textDocument: TextDocument, slDocument: ISLDocument): SymbolInformation[] { return []; },\r\n        findDocumentColors(textDocument: TextDocument, slDocument: ISLDocument): Thenable<ColorInformation[]> { return null; },\r\n        getColorPresentations(textDocument: TextDocument, slDocument: ISLDocument, color: Color, range: Range): ColorPresentation[] { return []; },\r\n        doHover(textDocument: TextDocument, position: Position, slDocument: ISLDocument): Thenable<Hover | null> { return null; },\r\n        format(textDocument: TextDocument, range: Range, options: FormattingOptions): TextEdit[] { return []; },\r\n        getFoldingRanges(textDocument: TextDocument): FoldingRange[] { return []; },\r\n        getSelectionRanges(textDocument: TextDocument, positions: Position[], slDocument: ISLDocument): SelectionRange[] { return []; },\r\n        \r\n        doSignatureHelp: signatureHelp.doSignatureHelp.bind(signatureHelp),\r\n\r\n        //\r\n        // FX\r\n        //\r\n\r\n        doFxCodeLenses: fxCodeLenses.doProvide.bind(fxCodeLenses)\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { T_VOID } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ETechniqueType } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { IPartFxInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { CodeLens, Command, Position, Range, TextDocument } from \"vscode-languageserver-types\";\r\nimport { types } from \"@lib/fx/analisys/helpers\"\r\n\r\nexport class FXCodeLenses {\r\n    doProvide(textDocument: TextDocument, slDocument: ISLDocument): CodeLens[] {\r\n        if (!slDocument) {\r\n            return [];\r\n        }\r\n\r\n        const lenses: CodeLens[] = [];\r\n        const scope = slDocument.root.scope;\r\n\r\n        /**\r\n         * Just a draft code :)\r\n         */\r\n\r\n        const createCodeLens = (name: string, loc: IRange): CodeLens => {\r\n            const pos = Position.create(loc.start.line, loc.start.column);\r\n            const range = Range.create(pos, pos);\r\n            const lens = CodeLens.create(range);\r\n            lens.command = Command.create(name, null);\r\n            return lens;\r\n        };\r\n\r\n        if (!isNull(scope)) {\r\n            for (const techniqueName in scope.techniques) {\r\n                const technique = scope.techniques[techniqueName];\r\n                if (technique.type === ETechniqueType.k_PartFx) {\r\n                    const partFx = <IPartFxInstruction>technique;\r\n\r\n                    if (partFx.spawnRoutine) {\r\n                        const fn = partFx.spawnRoutine.function.def;\r\n                        const sourceNode = partFx.spawnRoutine.function.def.sourceNode;\r\n                        if (types.equals(fn.returnType, T_VOID)) {\r\n                            if (fn.params.length > 0) {\r\n                                lenses.push(createCodeLens(`[extened spawn]`, sourceNode.loc));\r\n                            } else {\r\n                                lenses.push(createCodeLens(`[generic spawn]`, sourceNode.loc));\r\n                            }\r\n                        } else {\r\n                            lenses.push(createCodeLens(`[regular spawn]`, sourceNode.loc));\r\n                        }\r\n                    }\r\n\r\n                    if (partFx.initRoutine) {\r\n                        const sourceNode = partFx.initRoutine.function.def.sourceNode;\r\n                        lenses.push(createCodeLens(`[init routine]`, sourceNode.loc));\r\n                    }\r\n\r\n                    if (partFx.updateRoutine) {\r\n                        const sourceNode = partFx.updateRoutine.function.def.sourceNode;\r\n                        lenses.push(createCodeLens(`[update routine]`, sourceNode.loc));\r\n                    }\r\n\r\n                    if (partFx.particle &&\r\n                        partFx.particle.instructionType !== EInstructionTypes.k_SystemType) {\r\n                        const sourceNode = partFx.particle.sourceNode;\r\n                        lenses.push(createCodeLens(`[particle]`, sourceNode.loc));\r\n                    }\r\n\r\n                    for (const pass of partFx.passes) {\r\n                        if (pass.prerenderRoutine) {\r\n                            {\r\n                                const sourceNode = pass.prerenderRoutine.function.def.sourceNode;\r\n                                lenses.push(createCodeLens(`[prerender routine]`, sourceNode.loc));\r\n                            }\r\n                            {\r\n                                const sourceNode = pass.particleInstance.sourceNode;\r\n                                if (sourceNode.loc.start.file.toString() === textDocument.uri)\r\n                                    lenses.push(createCodeLens(`[material]`, sourceNode.loc));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lenses;\r\n    }\r\n}\r\n","import { Visitor } from \"@lib/fx/Visitors\";\r\nimport { EInstructionTypes, IFunctionCallInstruction, IFunctionDeclInstruction, IInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { checkRange } from \"@lib/parser/util\";\r\nimport { ParameterInformation, Position, SignatureHelp, SignatureInformation, TextDocument } from \"vscode-languageserver-types\";\r\n\r\nconst asRange = (instr: IInstruction) => instr.sourceNode.loc;\r\n\r\nexport class SLSignatureHelp {\r\n    doSignatureHelp(textDocument: TextDocument, position: Position, slDocument: ISLDocument): SignatureHelp {\r\n        if (!slDocument) {\r\n            return null;\r\n        }\r\n        \r\n        const offset = textDocument.offsetAt(position);\r\n        const decl = slDocument.root.instructions.find(instr => checkRange(asRange(instr), offset));\r\n        \r\n        if (decl) {\r\n            // console.log(decl);\r\n            if (decl.instructionType === EInstructionTypes.k_FunctionDecl) {\r\n\r\n                let fcall: IFunctionCallInstruction = null;\r\n                Visitor.each(decl, instr => {\r\n                    if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n                        if (checkRange(asRange(instr), offset)) {\r\n                            fcall = <IFunctionCallInstruction>instr;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (!fcall) {\r\n                    return null;\r\n                }\r\n\r\n                const fdecl = <IFunctionDeclInstruction>fcall.decl;\r\n                const fnList = fdecl.scope.functions[fdecl.name];\r\n                const signatures = fnList.map(fn =>\r\n                    SignatureInformation.create(\r\n                        fn.def.toCode(),\r\n                        null, // no documentation provided\r\n                        ...fn.def.params.map(param => ParameterInformation.create(param.name))\r\n                    ));\r\n\r\n                let activeSignature = fnList.indexOf(fdecl);\r\n                let activeParameter = 0;\r\n\r\n                if (activeSignature !== -1) {\r\n                    activeParameter = fcall.args.findIndex(arg =>\r\n                        checkRange(asRange(arg), offset));\r\n                } else {\r\n                    activeSignature = 0;\r\n                    console.error(`could not find active signature for: '${fdecl.def.toCode()}'`);\r\n                }\r\n\r\n                return { signatures, activeParameter, activeSignature };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EDiagnosticCategory, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { EOperationType, EParserCode, IASTConfig, IASTDocument, IASTDocumentFlags as EASTParsingFlags, IFile, ILexer, IParseNode, IParser, IParseTree, IPosition, IRange, IRuleFunction, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { ParseTree } from \"@lib/parser/ParseTree\";\r\nimport { END_SYMBOL, ERROR, T_NON_TYPE_ID, UNKNOWN_TOKEN } from \"@lib/parser/symbols\";\r\nimport { extendRange } from \"@lib/parser/util\";\r\nimport { DiagnosticException, Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\n\r\nexport enum EParsingErrors {\r\n    SyntaxUnknownError = 2051,\r\n    SyntaxUnexpectedEOF,\r\n    SyntaxRecoverableStateNotFound,\r\n\r\n    GeneralParsingLimitIsReached,\r\n};\r\n\r\n\r\nexport enum EParsingWarnings {\r\n    MacroUnknownWarning = 3000,\r\n\r\n    ReserveWordUsing,\r\n}\r\n\r\n\r\nexport class ParsingDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Parsing diagnostics\", 'P');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        if (category === EDiagnosticCategory.k_Warning) {\r\n            switch (code) {\r\n                case EParsingWarnings.MacroUnknownWarning:\r\n                    return desc.loc;\r\n            }\r\n        }\r\n\r\n        //\r\n        // errors\r\n        //\r\n        \r\n        switch (code) {\r\n            case EParsingErrors.SyntaxUnknownError:\r\n            case EParsingErrors.SyntaxUnexpectedEOF:\r\n                return desc.token.loc;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n\r\n    //\r\n    // NODE: position is being resolved only in case of failed range resolving\r\n    //\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: IMap<any>): IPosition {\r\n        console.assert(code != EParsingErrors.SyntaxUnknownError);\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParsingErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"{token.loc.start.file}:{token.loc.start.line}:{token.loc.start.column}.\",\r\n            [EParsingErrors.SyntaxUnexpectedEOF]: \"Syntax error. Unexpected EOF.\",\r\n            [EParsingErrors.GeneralParsingLimitIsReached]: \"Parsing limit is reached.\",\r\n            [EParsingErrors.SyntaxRecoverableStateNotFound]: \"Recoverable state not found.\"\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IMap<any>): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EParsingWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EParsingErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\nfunction cloneToken(token: IToken): IToken {\r\n    return {\r\n        ...token,\r\n        loc: {\r\n            start: { ...token.loc.start },\r\n            end: { ...token.loc.end }\r\n        }\r\n    };\r\n}\r\n\r\n\r\n// class Context {\r\n//     allowErrorRecoverty: boolean = true;\r\n//     developerMode: boolean = false;\r\n\r\n//     lexer: Lexer;\r\n//     diagnostics: ParsingDiagnostics;\r\n//     knownTypes: Set<string>;\r\n//     ruleFunctions: Map<string, IRuleFunction>;\r\n    \r\n//     stack: number[] = [0];\r\n\r\n\r\n//     constructor() {\r\n//         this.diagnostics = new ParsingDiagnostics;\r\n//     }\r\n\r\n//     readToken() {\r\n//         return this.lexer.getNextToken();\r\n//     }\r\n\r\n\r\n//     private error(code: number, token: IToken) {\r\n//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n\r\n//     private critical(code: number, token: IToken = null) {\r\n//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n// }\r\n \r\n\r\nexport class ASTDocument implements IASTDocument {\r\n    protected parser: IParser;\r\n    protected knownTypes: Set<string>;\r\n    protected ruleFunctions: Map<string, IRuleFunction>;\r\n\r\n    protected diag: ParsingDiagnostics;\r\n\r\n    protected tree: IParseTree;\r\n    protected stack: number[];\r\n    \r\n    protected lexer: ILexer;\r\n    protected token: IToken;\r\n\r\n    constructor(config: IASTConfig) {\r\n        assert(config.parser, 'parser engine is not defined');\r\n        this.init(config);\r\n    }\r\n\r\n    protected init({ parser, knownTypes = new Set(), ruleFunctions = new Map }: IASTConfig) {\r\n        this.parser = parser;\r\n        this.knownTypes = knownTypes;\r\n        this.ruleFunctions = ruleFunctions;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        // TODO: use uri from original textDocument\r\n        return this.lexer.document.uri;\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let lexerReport = this.lexer.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([lexerReport, parserReport]);\r\n    }\r\n\r\n    get root(): IParseNode {\r\n        return this.tree.root;\r\n    }\r\n\r\n\r\n    async parse(textDocument: ITextDocument, flags: number = EASTParsingFlags.k_Optimize): Promise<EParserCode> {\r\n        const developerMode = bf.testAll(flags, EASTParsingFlags.k_DeveloperMode);\r\n        const allowErrorRecoverty = true;\r\n        const optimizeTree = bf.testAll(flags, EASTParsingFlags.k_Optimize);\r\n\r\n        this.diag = new ParsingDiagnostics;\r\n        this.tree = new ParseTree(optimizeTree);\r\n        this.stack = [0];\r\n        \r\n        this.setTextDocument(textDocument);\r\n        this.token = await this.readToken();\r\n\r\n        if (this.token.name === END_SYMBOL) {\r\n            return EParserCode.k_Ok;\r\n        }\r\n\r\n        await this.run({ developerMode, allowErrorRecoverty });\r\n\r\n        // clear context\r\n\r\n        // this.stack = null;\r\n        // this.lexer = null;\r\n        // this.token = null;\r\n        // diag\r\n        // tree\r\n\r\n        // end of clear\r\n\r\n        if (this.diag.hasErrors()) {\r\n            console.error('parsing was ended with errors.');\r\n            return EParserCode.k_Error;\r\n        }\r\n\r\n        return EParserCode.k_Ok;\r\n    }\r\n\r\n    protected setTextDocument(textDocument: ITextDocument): void {\r\n        this.lexer = new Lexer({\r\n            engine: this.parser.lexerEngine,\r\n            knownTypes: this.knownTypes\r\n        });\r\n        this.lexer.setTextDocument(textDocument);\r\n    }\r\n\r\n\r\n    protected async readToken(): Promise<IToken> {\r\n        return this.lexer.getNextToken();\r\n    }\r\n\r\n    protected emitWarning(code: number, token: IToken) {\r\n        this.diag.warning(code, { token });\r\n    }\r\n    \r\n    protected emitError(code: number, token: IToken) {\r\n        this.diag.error(code, { token });\r\n    }\r\n\r\n    \r\n    protected emitCritical(code: number, token: IToken = null) {\r\n        this.diag.critical(code, { token });\r\n    }\r\n\r\n\r\n    private async restoreState(syntaxTable: ISyntaxTable, parseTree: ParseTree, stack: number[], causingErrorToken: IToken, errorToken: IToken): Promise<number> {\r\n        while (true) {\r\n            let recoverableState = -1;\r\n            for (let i = stack.length - 1; i >= 0; --i) {\r\n                const errorOp = syntaxTable[stack[i]][ERROR];\r\n                const isRecoverableState = (isDef(errorOp) &&\r\n                    errorOp.type === EOperationType.k_Shift &&\r\n                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);\r\n                if (isRecoverableState) {\r\n                    recoverableState = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (recoverableState !== -1) {\r\n                const recoveredStateIndex = stack[recoverableState];\r\n                // current op will be: syntaxTable[recoveredStateIndex][ERROR];\r\n\r\n                let stackDiff = stack.length - 1 - recoverableState;\r\n                while (stackDiff != 0) {\r\n                    // extend error token location with the already processed tokens\r\n                    parseTree.$pop(errorToken.loc);\r\n                    stack.pop();\r\n                    stackDiff--;\r\n                }\r\n\r\n                // recoverable state found so continue normal processing as it would be before the error\r\n                return recoveredStateIndex;\r\n            }\r\n\r\n            // TODO: optimize this call!\r\n            extendRange(errorToken.loc, causingErrorToken.loc);\r\n\r\n            if (causingErrorToken.value === END_SYMBOL) {\r\n                // state cant be recovered\r\n                break;\r\n            }\r\n\r\n            // try to restore from the next token\r\n            // FIXME: \r\n            const nextToken: IToken = await this.readToken();\r\n            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    \r\n    private operationAdditionalAction(stateIndex: number, grammarSymbol: string): EOperationType {\r\n        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);\r\n        if (!isNull(funcName)) {\r\n            assert(!!this.ruleFunctions.has(funcName));\r\n            return this.ruleFunctions.get(funcName)();\r\n        }\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private async run({ developerMode = false, allowErrorRecoverty = true }): Promise<void> {\r\n\r\n        const { syntaxTable } = this.parser;\r\n        const { stack, tree } = this;\r\n\r\n        const undefinedToken: IToken = { index: -1, name: null, value: null };\r\n        let causingErrorToken: IToken = undefinedToken;\r\n\r\n        // debug mode\r\n        const opLimit = 64e5;\r\n        let opCounter = 0;\r\n\r\n        try {\r\n            breakProcessing:\r\n            while (true) {\r\n                // global recursion prevention in debug mode\r\n                if (developerMode) {\r\n                    if (opCounter > opLimit) {\r\n                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);\r\n                    }\r\n                    opCounter++;\r\n                }\r\n\r\n                let currStateIndex = stack[stack.length - 1];\r\n                let op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                if (allowErrorRecoverty) {\r\n                    if (!op) {\r\n                        const ID_REGEXP = /^[_a-zA-Z][_a-zA-Z0-9]{0,30}$/;\r\n                        const isLikeID = this.token.name !== T_NON_TYPE_ID && ID_REGEXP.test(this.token.value);\r\n                        const canContinueAsID = isLikeID && syntaxTable[currStateIndex][T_NON_TYPE_ID];\r\n\r\n                        // recursion prevention\r\n                        if (causingErrorToken.index !== this.token.index) {\r\n                            if (this.token.name === END_SYMBOL) {\r\n                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);\r\n                            } else {\r\n                                // a special case to bypass tokens of the same name with keywords\r\n                                if (canContinueAsID) {\r\n                                    // todo: emit warning(!)\r\n                                    // this.emitWarning(EParsingWarnings.ReserveWordUsing, this.token);\r\n                                } else {\r\n                                    this.emitError(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // one more attempt to recover but from the next token\r\n                            this.token = await this.readToken();\r\n                            if (this.token.index === -1) debugger;\r\n                            // NOTE: in order to prevent recusrion on END_SYMBOL\r\n                            causingErrorToken = undefinedToken;\r\n                            continue;\r\n                        }\r\n\r\n                        causingErrorToken = cloneToken(this.token);\r\n\r\n                        if (canContinueAsID) {\r\n                            this.token = { ...cloneToken(this.token), name: T_NON_TYPE_ID };\r\n                        } else {\r\n                            // token = { ...token, name: ERROR };\r\n                            this.token = { ...cloneToken(this.token), name: ERROR };\r\n                        }\r\n                    }\r\n                    \r\n                    op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                    const errorProcessing = this.token.name === ERROR;\r\n                    const errorReductionEnded = !op || (errorProcessing && (op.type === EOperationType.k_Shift));\r\n\r\n                    // state must be recovered if operation is undefined or error reduction was ended. \r\n                    if (errorReductionEnded) {\r\n                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. \r\n                        let recoveryToken = cloneToken(causingErrorToken);\r\n                        while (recoveryToken.name === UNKNOWN_TOKEN) {\r\n                            recoveryToken = await this.readToken();\r\n                            if (recoveryToken.index === -1) debugger;\r\n                        }\r\n                        currStateIndex = await this.restoreState(syntaxTable, <ParseTree>tree, stack, recoveryToken, this.token /* error token */);\r\n                        if (currStateIndex === -1) {\r\n                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);\r\n                        }\r\n\r\n                        // perform error shift op.\r\n                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'\r\n                        stack.push(op.stateIndex);\r\n                        tree.addToken(this.token/* error token */);\r\n                        this.token = recoveryToken;\r\n\r\n                        // const nextOp = syntaxTable[op.stateIndex][token.name];\r\n                        // if (nextOp.type === EOperationType.k_Reduce) {\r\n                        //     tokenBuffer.push(rec);\r\n                        // }\r\n\r\n                        // return to normal precesing loop\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isDef(op)) {\r\n                    switch (op.type) {\r\n                        case EOperationType.k_Success:\r\n                            break breakProcessing;\r\n\r\n                        case EOperationType.k_Shift:\r\n                            {\r\n                                const stateIndex = op.stateIndex;\r\n                                stack.push(stateIndex);\r\n                                tree.addToken(this.token);\r\n\r\n                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, this.token.name);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                } else if (additionalOperationCode === EOperationType.k_Ok) {\r\n                                    this.token = await this.readToken();\r\n                                    if (this.token.index === -1) debugger;\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case EOperationType.k_Reduce:\r\n                            {\r\n                                const ruleLength = op.rule.right.length;\r\n                                stack.length -= ruleLength;\r\n\r\n                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;\r\n\r\n                                stack.push(stateIndex);\r\n                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));\r\n\r\n                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, op.rule.left);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    assert(!allowErrorRecoverty, `unexpected end, something went wrong :/`);\r\n                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                }\r\n            }\r\n\r\n            tree.finishTree();\r\n        } catch (e) {\r\n            if (!(e instanceof DiagnosticException)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IDMap, IMap } from \"@lib/idl/IMap\";\r\nimport { ENodeCreateMode as ENodeCreationMode, EOperationType, EParserFlags, EParserType, ExpectedSymbols, IAdditionalFuncInfo, IOperation, IOperationMap, IParser, IParserParams, IPosition, IProductions, IRange, IRule, IRuleFunctionDMap, IRuleMap, ISyntaxTable } from \"@lib/idl/parser/IParser\";\r\nimport { Item } from \"@lib/parser/Item\";\r\nimport { LexerEngine } from \"@lib/parser/Lexer\";\r\nimport { State } from \"@lib/parser/State\";\r\nimport { END_POSITION, END_SYMBOL, FLAG_RULE_CREATE_NODE, FLAG_RULE_EXPOSE_NODE, FLAG_RULE_FUNCTION, FLAG_RULE_SKIP_NODE, INLINE_COMMENT_SYMBOL, LEXER_RULES, START_SYMBOL, T_EMPTY, UNUSED_SYMBOL } from \"@lib/parser/symbols\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\n\r\nexport enum EParserErrors {\r\n    GrammarAddOperation = 2001,\r\n    GrammarAddStateLink,\r\n    GrammarUnexpectedSymbol,\r\n    GrammarInvalidAdditionalFuncName,\r\n    GrammarInvalidKeyword\r\n};\r\n\r\n\r\ntype Terminals = Set<string>;\r\n\r\n\r\nexport class GrammarDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Grammar diagnostics\", 'G');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: IMap<any>): IPosition {\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParserErrors.GrammarAddOperation]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old operation: {oldOperation}\\n\" +\r\n                \"New operation: {newOperation}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\" +\r\n                `\\n\\n{stateDesc}`,\r\n            [EParserErrors.GrammarAddStateLink]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old next state: {oldNextStateIndex}\\n\" +\r\n                \"New next state: {newNextStateIndex}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\",\r\n            [EParserErrors.GrammarUnexpectedSymbol]: \"Grammar error. Can`t generate rules from grammar\\n\" +\r\n                \"Unexpected symbol: {unexpectedSymbol}\\n\" +\r\n                \"Expected: {expectedSymbol}\",\r\n            [EParserErrors.GrammarInvalidAdditionalFuncName]: \"Grammar error. Empty additional function name.\",\r\n            [EParserErrors.GrammarInvalidKeyword]: \"Grammar error. Bad keyword: {badKeyword}\\n\" +\r\n                \"All keyword must be define in lexer rule block.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class AbstractParser implements IParser {\r\n    //Process params\r\n\r\n    // TODO: make readonly\r\n    lexerEngine: LexerEngine;\r\n\r\n    //\r\n    // Grammar based Info\r\n    //\r\n\r\n    private _syntaxTable: ISyntaxTable;\r\n\r\n\r\n    /**\r\n     * General structure:\r\n     *  { [symbol name]: { [rule index]: IRule } }\r\n     */\r\n    private _productions: IProductions;\r\n    private _states: State[];\r\n\r\n    /**\r\n * Auxiliary map for all symbols from grammar: symbolName => symbolName.\r\n * For ex.: T_PUNCTUATOR_61 => '='\r\n */\r\n    private _grammarSymbols: Map<string, string>;\r\n\r\n    // functions described in grammar's flags\r\n    private _additionalFuncInfoList: IAdditionalFuncInfo[];\r\n    private _adidtionalFunctByStateDMap: IRuleFunctionDMap;\r\n\r\n    // Additioanal info\r\n\r\n    // flags for rules (extracted from grammar's flags)\r\n    private _ruleCreationModeMap: IMap<number>;\r\n\r\n    // Temp\r\n\r\n    // aux. cache for first terminals\r\n    private _firstTerminalsCache: IMap<Terminals>;\r\n    // private _followTerminalsCache: IDMap<boolean>;\r\n\r\n\r\n    //\r\n    // LALR specific\r\n    //\r\n\r\n    /**\r\n     * Auxiliary map: [item index] => { [item index]: true }\r\n     * Expectation correspondence map.\r\n     */\r\n    // NOTE: default JS object significantly faster than Map<number, Set<number>>\r\n    //       for this case :/\r\n    private _expectedExtensionDMap: IDMap<boolean>;\r\n    private _baseItems: Item[];\r\n    private _closureForItemsCache: IMap<State>;\r\n\r\n    // TODO: use dedicated type for parser engine\r\n    private _diag: GrammarDiagnostics;\r\n\r\n    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR\r\n    constructor({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this._syntaxTable = null;\r\n\r\n        this._productions = null;\r\n        this._baseItems = null;\r\n        this._states = null;\r\n\r\n        this._additionalFuncInfoList = null;\r\n        this._adidtionalFunctByStateDMap = null;\r\n\r\n        this._ruleCreationModeMap = null;\r\n\r\n        this._firstTerminalsCache = null;\r\n        // this._followTerminalsCache = null;\r\n        this._closureForItemsCache = null;\r\n\r\n        this._expectedExtensionDMap = null;\r\n        this._diag = new GrammarDiagnostics;\r\n\r\n        this.init({ grammar, flags, type });\r\n    }\r\n\r\n    get syntaxTable(): ISyntaxTable {\r\n        return this._syntaxTable;\r\n    }\r\n\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string {\r\n        const funcDMap = this._adidtionalFunctByStateDMap;\r\n\r\n        if (!isNull(funcDMap) &&\r\n            isDef(funcDMap[stateIndex]) &&\r\n            isDef(funcDMap[stateIndex][grammarSymbol])) {\r\n            return funcDMap[stateIndex][grammarSymbol];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreationMode {\r\n        return this._ruleCreationModeMap[nonTerminal];\r\n    }\r\n\r\n\r\n    getGrammarSymbols(): Map<string, string> {\r\n        return this._grammarSymbols;\r\n    }\r\n\r\n    protected init({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this.lexerEngine = new LexerEngine();\r\n\r\n        this.generateRules(grammar, flags);\r\n        this.buildSyntaxTable(type);\r\n        this.generateFunctionByStateMap();\r\n\r\n        if (!bf.testAll(flags, EParserFlags.k_Debug)) {\r\n            this.clearMem();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    printStates(isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.warn(\"It`s impossible to print states. You must init parser in debug-mode\");\r\n            return;\r\n        }\r\n        const mesg = \"\\n\" + this.statesToString(isBaseOnly);\r\n        console.log(mesg);\r\n    }\r\n\r\n\r\n    printState(stateIndex: number, isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.log(\"It`s impossible to print states. You must init parser in debug-mode.\");\r\n            return;\r\n        }\r\n\r\n        var state = this._states[stateIndex];\r\n        if (!isDef(state)) {\r\n            console.log(\"Can not print stete with index: \" + stateIndex.toString());\r\n            return;\r\n        }\r\n\r\n        console.log(`\\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);\r\n    }\r\n\r\n\r\n    protected critical(code, desc) {\r\n        this._diag.critical(code, desc);\r\n    }\r\n\r\n    private grammarError(code: number, desc) {\r\n        let file = \"grammar\";\r\n\r\n        switch (code) {\r\n            case EParserErrors.GrammarAddOperation:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;\r\n                    this.critical(code, {\r\n                        file, line: 0, stateIndex, grammarSymbol,\r\n                        oldOperation: AbstractParser.operationToString(oldOperation),\r\n                        newOperation: AbstractParser.operationToString(newOperation),\r\n                        stateDesc: this._states[stateIndex].toString()\r\n                    });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarAddStateLink:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;\r\n                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarUnexpectedSymbol:\r\n                {\r\n                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;\r\n                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidAdditionalFuncName:\r\n                {\r\n                    const { grammarLine } = desc;\r\n                    this.critical(code, { file, line: grammarLine });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidKeyword:\r\n                {\r\n                    const { grammarLine, badKeyword } = desc;\r\n                    this.critical(code, { file, line: grammarLine, badKeyword })\r\n                }\r\n                break;\r\n            default:\r\n                throw \"invalid case!!!!\";\r\n        }\r\n    }\r\n\r\n\r\n    private clearMem(): void {\r\n        delete this._states;\r\n\r\n        delete this._productions;\r\n        delete this._baseItems;\r\n        // delete this._followTerminalsCache;\r\n        delete this._firstTerminalsCache;\r\n        delete this._closureForItemsCache;\r\n        delete this._expectedExtensionDMap;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for the state's dublicate.\r\n     */\r\n    private hasState(state: State, type: EParserType): State {\r\n        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;\r\n    }\r\n\r\n\r\n    private nonTerminals(): string[] {\r\n        return Object.keys(this._productions);\r\n    }\r\n\r\n    private rules(nonTerminal: string): IRule[] {\r\n        const prods = this._productions[nonTerminal];\r\n        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;\r\n    }\r\n\r\n    private ruleCreationMode(symbol: string) {\r\n        return this._ruleCreationModeMap[symbol];\r\n    }\r\n\r\n    /**\r\n     * terminals & non-terminals;\r\n     */\r\n    private symbols(): string[] {\r\n        return [...this._grammarSymbols.keys()];\r\n    }\r\n\r\n    private isTerminal(symbol: string): boolean {\r\n        return !(this._productions[symbol]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'stateList' and set item's index in it.\r\n     */\r\n    private pushState(state: State): void {\r\n        state.index = this._states.length;\r\n        this._states.push(state);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'baseItemList' and set item's index in it.\r\n     */\r\n    private pushBaseItem(item: Item): void {\r\n        item.index = this._baseItems.length;\r\n        this._baseItems.push(item);\r\n    }\r\n\r\n\r\n    private tryAddState(state: State, type: EParserType): State {\r\n        let res = this.hasState(state, type);\r\n\r\n        if (isNull(res)) {\r\n            if (type === EParserType.k_LR0) {\r\n                state.eachItem(item => this.pushBaseItem(item));\r\n            }\r\n\r\n            this.pushState(state);\r\n            this.closure(state, type);\r\n\r\n            return state;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private hasEmptyRule(symbol: string): boolean {\r\n        if (this.isTerminal(symbol)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this.rules(symbol).find(rule => rule.right.length === 0);\r\n    }\r\n\r\n\r\n    private pushInSyntaxTable(syntaxTable: ISyntaxTable, stateIndex: number, symbol: string, operation: IOperation): void {\r\n        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};\r\n\r\n        if (isDef(syntaxTable[stateIndex][symbol])) {\r\n            this.grammarError(EParserErrors.GrammarAddOperation, {\r\n                stateIndex: stateIndex,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol),\r\n                oldOperation: this._syntaxTable[stateIndex][symbol],\r\n                newOperation: operation\r\n            });\r\n        }\r\n\r\n        syntaxTable[stateIndex][symbol] = operation;\r\n    }\r\n\r\n\r\n    private addStateLink(state: State, nextState: State, symbol: string): void {\r\n        let isAddState = state.addNextState(symbol, nextState);\r\n        if (!isAddState) {\r\n            this.grammarError(EParserErrors.GrammarAddStateLink, {\r\n                stateIndex: state.index,\r\n                oldNextStateIndex: state.nextStates[symbol] || null,\r\n                newNextStateIndex: nextState.index,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol)\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    private firstTerminals(symbol: string): Terminals {\r\n        if (this.isTerminal(symbol)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(this._firstTerminalsCache[symbol])) {\r\n            return this._firstTerminalsCache[symbol];\r\n        }\r\n\r\n        const rules = this.rules(symbol);\r\n        const res: Terminals = this._firstTerminalsCache[symbol] = new Set<string>();\r\n\r\n        if (this.hasEmptyRule(symbol)) {\r\n            res.add(T_EMPTY);\r\n        }\r\n\r\n        if (isNull(rules)) {\r\n            return res;\r\n        }\r\n\r\n        for (let i = 0; i < rules.length; ++i) {\r\n            const rule = rules[i];\r\n            const right = rule.right;\r\n\r\n            let isFinish = false;\r\n\r\n            for (let j = 0; j < right.length; j++) {\r\n                if (right[j] === symbol) {\r\n                    if (res.has(T_EMPTY)) {\r\n                        continue;\r\n                    }\r\n\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n\r\n                const terminals = this.firstTerminals(right[j]);\r\n\r\n                if (isNull(terminals)) {\r\n                    res.add(right[j]);\r\n                } else {\r\n                    for (const terminal of terminals) {\r\n                        res.add(terminal);\r\n                    }\r\n                }\r\n\r\n                if (!this.hasEmptyRule(right[j])) {\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!isFinish) {\r\n                res.add(T_EMPTY);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // private followTerminal(symbolVal: string): IMap<boolean> {\r\n    //     if (isDef(this._followTerminalsCache[symbolVal])) {\r\n    //         return this._followTerminalsCache[symbolVal];\r\n    //     }\r\n\r\n    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;\r\n    //     var pRulesDMap: IRuleDMap = this._rulesDMap;\r\n    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];\r\n\r\n    //     var rule: IRule;\r\n    //     var pTempRes: IMap<boolean>;\r\n    //     var pTempKeys: string[];\r\n    //     var res: IMap<boolean>;\r\n\r\n    //     var right: string[];\r\n    //     var isFinish: boolean;\r\n\r\n    //     var sFirstKey: string;\r\n    //     var sSecondKey: string;\r\n\r\n    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};\r\n\r\n    //     if (isNull(pRulesDMap)) {\r\n    //         return res;\r\n    //     }\r\n\r\n    //     rulesDMapKeys = Object.keys(pRulesDMap);\r\n    //     for (i = 0; i < rulesDMapKeys.length; i++) {\r\n    //         sFirstKey = rulesDMapKeys[i];\r\n\r\n    //         if (isNull(pRulesDMap[sFirstKey])) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);\r\n\r\n    //         for (j = 0; j < pRulesMapKeys.length; j++) {\r\n    //             rule = pRulesDMap[sFirstKey][sSecondKey];\r\n    //             right = rule.right;\r\n\r\n    //             for (k = 0; k < right.length; k++) {\r\n    //                 if (right[k] === symbolVal) {\r\n    //                     if (k === right.length - 1) {\r\n    //                         pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                         pTempKeys = Object.keys(pTempRes);\r\n    //                         for (m = 0; m < pTempKeys.length; i++) {\r\n    //                             res[pTempKeys[m]] = true;\r\n    //                         }\r\n    //                     }\r\n    //                     else {\r\n    //                         isFinish = false;\r\n\r\n    //                         for (l = k + 1; l < right.length; l++) {\r\n    //                             pTempRes = this.firstTerminal(right[l]);\r\n\r\n    //                             if (isNull(pTempRes)) {\r\n    //                                 res[right[l]] = true;\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                             else {\r\n    //                                 pTempKeys = Object.keys(pTempRes);\r\n    //                                 for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                     res[pTempKeys[m]] = true;\r\n    //                                 }\r\n    //                             }\r\n\r\n    //                             if (!pTempRes[T_EMPTY]) {\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                         }\r\n\r\n    //                         if (!isFinish) {\r\n    //                             pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                             pTempKeys = Object.keys(pTempRes);\r\n    //                             for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                 res[pTempKeys[m]] = true;\r\n    //                             }\r\n    //                         }\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     return res;\r\n    // }\r\n\r\n    private firstTerminalsForSet(symbolList: string[], expectedSymbols: ExpectedSymbols): Terminals {\r\n        const res = new Set<string>();\r\n\r\n        for (let i = 0; i < symbolList.length; i++) {\r\n            const terminals = this.firstTerminals(symbolList[i]);\r\n\r\n            if (isNull(terminals)) {\r\n                res.add(symbolList[i]);\r\n                return res;\r\n            }\r\n\r\n            let isEmpty = false;\r\n            for (const symbol of terminals) {\r\n                if (symbol === T_EMPTY) {\r\n                    isEmpty = true;\r\n                    continue;\r\n                }\r\n                res.add(symbol);\r\n            }\r\n\r\n            if (!isEmpty) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        if (!isNull(expectedSymbols)) {\r\n            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private generateRules(grammarSource: string, flags: EParserFlags): void {\r\n        let allRuleList: string[] = grammarSource.split(/\\r?\\n/);\r\n        let tempRule: string[];\r\n        let rule: IRule;\r\n        let isLexerBlock = false;\r\n\r\n        this._productions = <IProductions>{};\r\n        this._additionalFuncInfoList = <IAdditionalFuncInfo[]>[];\r\n        this._ruleCreationModeMap = <IMap<number>>{};\r\n        this._grammarSymbols = new Map([['END_SYMBOL', END_SYMBOL]]);\r\n\r\n        let i = 0, j = 0;\r\n\r\n        // append all nodes ignoring any flags\r\n        const forceAppendAllMode = bf.testAll(flags, EParserFlags.k_ForceAppendAll);\r\n        // force unwind node if it is marked as '--expose'\r\n        const allowExposeMode = bf.testAll(flags, EParserFlags.k_AllowExposeMode);\r\n        // force add node if it is marked as '--add'\r\n        const allowAddMode = bf.testAll(flags, EParserFlags.k_AllowAddMode);\r\n        // remove node from parsing tree if it is marked as '--skip'\r\n        const allowSkipMode = bf.testAll(flags, EParserFlags.k_AllowSkipMode);\r\n\r\n        let symbolsWithNodeMap: IMap<number> = this._ruleCreationModeMap;\r\n\r\n        let name: string;\r\n\r\n        let nRules = 0;\r\n\r\n        for (i = 0; i < allRuleList.length; i++) {\r\n            if (allRuleList[i] === \"\" || allRuleList[i] === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // split rule like 'S : Program'\r\n            tempRule = allRuleList[i].trim().split(/\\s* \\s*/);\r\n\r\n            // ignore rules starting with '#'\r\n            if (tempRule[0][0] == INLINE_COMMENT_SYMBOL) {\r\n                continue;\r\n            }\r\n\r\n            if (isLexerBlock) {\r\n                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === \"\")) &&\r\n                    ((tempRule[2][0] === \"\\\"\" || tempRule[2][0] === \"'\") && tempRule[2].length > 3)) {\r\n\r\n                    //TERMINALS\r\n                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],\r\n                            expectedSymbol: tempRule[2][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);\r\n\r\n                    var ch: string = tempRule[2][0];\r\n\r\n\r\n                    if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);\r\n                    }\r\n                    else {\r\n                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);\r\n                    }\r\n\r\n                    this._grammarSymbols.set(name, tempRule[2]);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // looking for '--LEXER--' keyword\r\n            if (tempRule[0] === LEXER_RULES) {\r\n                isLexerBlock = true;\r\n                continue;\r\n            }\r\n\r\n            //NON TERMNINAL RULES\r\n            if (!isDef(this._productions[tempRule[0]])) {\r\n                this._productions[tempRule[0]] = <IRuleMap>{};\r\n            }\r\n\r\n            rule = {\r\n                left: tempRule[0],\r\n                right: <string[]>[],\r\n                index: 0\r\n            };\r\n\r\n            this._grammarSymbols.set(tempRule[0], tempRule[0]);\r\n\r\n            if (forceAppendAllMode) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowExposeMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowAddMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n            } else if (allowSkipMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n            }\r\n\r\n            for (j = 2; j < tempRule.length; j++) {\r\n                if (tempRule[j] === \"\") {\r\n                    continue;\r\n                }\r\n                // handle flag '--add'\r\n                if (tempRule[j] === FLAG_RULE_CREATE_NODE) {\r\n                    if (allowAddMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Necessary;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (tempRule[j] === FLAG_RULE_SKIP_NODE) {\r\n                    if (allowSkipMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n                    }\r\n                    continue;\r\n                }\r\n                // handle flag '--expose'\r\n                if (tempRule[j] === FLAG_RULE_EXPOSE_NODE) {\r\n                    if (allowExposeMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n                    }\r\n                    continue;\r\n                }\r\n                // looking for additional user functions like '--F includeCode'\r\n                if (tempRule[j] === FLAG_RULE_FUNCTION) {\r\n                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });\r\n                    }\r\n\r\n                    const funcInfo = <IAdditionalFuncInfo>{\r\n                        name: tempRule[j + 1],\r\n                        position: rule.right.length,\r\n                        rule: rule\r\n                    };\r\n                    this._additionalFuncInfoList.push(funcInfo);\r\n                    j++;\r\n                    continue;\r\n                }\r\n                // handle string literlas\r\n                if (tempRule[j][0] === \"'\" || tempRule[j][0] === \"\\\"\") {\r\n                    if (tempRule[j].length !== 3) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {\r\n                            badKeyword: tempRule[j],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n                    if (tempRule[j][0] !== tempRule[j][2]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[j][2],\r\n                            expectedSymbol: tempRule[j][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);\r\n                    rule.right.push(name);\r\n                    this._grammarSymbols.set(name, tempRule[j][1]);\r\n                }\r\n                else {\r\n                    rule.right.push(tempRule[j]);\r\n                    this._grammarSymbols.set(tempRule[j], tempRule[j]);\r\n                }\r\n            }\r\n\r\n            rule.index = nRules;\r\n            this._productions[tempRule[0]][rule.index] = rule;\r\n            nRules++;\r\n\r\n            // TODO: emit diagnostics error instead.\r\n            assert(nRules != 1 || isDef(this._productions[START_SYMBOL][0]));\r\n        }\r\n    }\r\n\r\n\r\n    private generateFunctionByStateMap(): void {\r\n        const stateList = this._states;\r\n        const funcInfoList = this._additionalFuncInfoList;\r\n        const funcByStateDMap = this._adidtionalFunctByStateDMap = <IRuleFunctionDMap>{};\r\n\r\n        for (let i = 0; i < funcInfoList.length; i++) {\r\n            const funcInfo = funcInfoList[i];\r\n            const rule = funcInfo.rule;\r\n            const pos = funcInfo.position;\r\n            const grammarSymbol = rule.right[pos - 1];\r\n\r\n            for (let j = 0; j < stateList.length; j++) {\r\n                if (stateList[j].hasRule(rule, pos)) {\r\n                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};\r\n                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateFirstState_LR0(): void {\r\n        const state = new State();\r\n        // START_SYMBOL should be always defined at the beginning of grammar\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n        const item = new Item(firstRule, 0);\r\n\r\n        this.pushBaseItem(item);\r\n        state.push(item);\r\n\r\n        this.closure_LR0(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private generateFirstState_LR(): void {\r\n        const state = new State();\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n\r\n        state.push(new Item(firstRule, 0, [END_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private closure(state: State, type: EParserType) {\r\n        if (type === EParserType.k_LR0) {\r\n            this.closure_LR0(state);\r\n        } else {\r\n            this.closure_LR(state);\r\n        }\r\n    }\r\n\r\n\r\n    private closure_LR0(state: State) {\r\n        // NOTE: loop grows implicitly inside state.tryPush() function.\r\n        //       do not change this loop.\r\n        state.eachItem(item => {\r\n            const symbol = item.symbolName();\r\n            if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private closure_LR(state: State) {\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            state.eachItem(item => {\r\n                const symbol = item.symbolName();\r\n                if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                    const nextSymbols = item.rule.right.slice(item.pos + 1);\r\n                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);\r\n\r\n                    this.rules(symbol).forEach(rule => {\r\n                        expectedTerminals.forEach(expectedTerminal => {\r\n                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private static nextState_LR0(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                nextState.push(new Item(item.rule, item.pos + 1));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private static nextState_LR(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                const expectedSymbols = Array.from(item.expectedSymbols);\r\n                nextState.push(new Item(item.rule, item.pos + 1, expectedSymbols));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private deleteNotBaseItems(): void {\r\n        this._states.forEach(state => state.deleteNotBase());\r\n    }\r\n\r\n\r\n    private closureForItem({ rule, pos }: Item): State {\r\n        const indexVal = rule.index + \"_\" + pos;\r\n\r\n        let state = this._closureForItemsCache[indexVal];\r\n        if (isDef(state)) {\r\n            return state;\r\n        }\r\n\r\n        state = new State();\r\n        state.push(new Item(rule, pos, [UNUSED_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this._closureForItemsCache[indexVal] = state;\r\n\r\n        return state;\r\n    }\r\n\r\n\r\n    private addLinkExpected(item: Item, itemX: Item): void {\r\n        let table = this._expectedExtensionDMap;\r\n        let index = item.index;\r\n\r\n        table[index] = table[index] || {};\r\n        table[index][itemX.index] = true;\r\n    }\r\n\r\n\r\n    private determineExpected(testState: State, symbol: string): void {\r\n        const stateNext = testState.nextStates[symbol] || null;\r\n\r\n        if (isNull(stateNext)) {\r\n            return;\r\n        }\r\n\r\n        // at this moment all items already 'base' because of\r\n        // deleteNotBase() call before.\r\n        testState.eachBaseItem(baseItem => {\r\n            const state = this.closureForItem(baseItem);\r\n            stateNext.eachBaseItem(baseItemNext => {\r\n                const item = state.hasChildItem(baseItemNext);\r\n                if (item) {\r\n                    item.expectedSymbols.forEach(symbol => {\r\n                        if (symbol === UNUSED_SYMBOL) {\r\n                            this.addLinkExpected(baseItem, baseItemNext);\r\n                        } else {\r\n                            baseItemNext.addExpected(symbol);\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    private generateLinksExpected(): void {\r\n        const states = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        states.forEach(state =>\r\n            symbols.forEach(symbol =>\r\n                this.determineExpected(state, symbol)));\r\n    }\r\n\r\n\r\n    private expandExpected(): void {\r\n        const baseItems = this._baseItems;\r\n        const itemExpected = baseItems.map(item => true);\r\n        const table = this._expectedExtensionDMap;\r\n\r\n        baseItems[0].addExpected(END_SYMBOL);\r\n        itemExpected[0] = (true);\r\n\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            baseItems.forEach((baseItem) => {\r\n                if (itemExpected[baseItem.index] && isDefAndNotNull(table[baseItem.index])) {\r\n                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));\r\n\r\n                    baseItem.expectedSymbols.forEach(expectedSymbol => {\r\n                        indexesOfExpectedItems.forEach(expectedIndex => {\r\n                            const baseItemExpected = baseItems[expectedIndex];\r\n                            if (baseItemExpected.addExpected(expectedSymbol)) {\r\n                                itemExpected[expectedIndex] = true;\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                itemExpected[baseItem.index] = false;\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private generateStates(type: EParserType): void {\r\n        if (type === EParserType.k_LR0) {\r\n            this.generateStates_LR0();\r\n        }\r\n        else if (type === EParserType.k_LR1) {\r\n            this.generateStates_LR();\r\n        }\r\n        else if (type === EParserType.k_LALR) {\r\n            this.generateStates_LALR();\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR0(): void {\r\n        this.generateFirstState_LR0();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                const symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR0(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR0);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR(): void {\r\n        this._firstTerminalsCache = {};\r\n        this.generateFirstState_LR();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                let symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR1);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private generateStates_LALR(): void {\r\n        this._baseItems = [];\r\n        this._expectedExtensionDMap = {};\r\n        this._closureForItemsCache = {};\r\n        this._firstTerminalsCache = {};\r\n\r\n        this.generateStates_LR0();\r\n        this.deleteNotBaseItems();\r\n        this.generateLinksExpected();\r\n        this.expandExpected();\r\n\r\n        this._states.forEach(state => this.closure_LR(state));\r\n    }\r\n\r\n\r\n    private addReducing(syntaxTable: ISyntaxTable, state: State, reduceOperationsMap: IOperationMap): void {\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === END_POSITION) {\r\n                if (item.rule.left === START_SYMBOL) {\r\n                    this.pushInSyntaxTable(syntaxTable, state.index, END_SYMBOL, { type: EOperationType.k_Success });\r\n                } else {\r\n                    for (const expectedSymbol of item.expectedSymbols) {\r\n                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private addShift(syntaxTable: ISyntaxTable, state: State, shiftOperationsMap: IOperationMap) {\r\n        const nextStates = state.nextStates;\r\n        const nextSymbols = Object.keys(nextStates);\r\n        for (let i = 0; i < nextSymbols.length; i++) {\r\n            const nextState = nextStates[nextSymbols[i]];\r\n            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);\r\n        }\r\n    }\r\n\r\n    private buildSyntaxTable(type: EParserType): void {\r\n        this._states = [];\r\n        this._syntaxTable = {};\r\n\r\n        const stateList = this._states;\r\n        const syntaxTable = this._syntaxTable;\r\n\r\n        this.generateStates(type);\r\n\r\n        const reduceOperationsMap: IOperationMap = {};\r\n        const shiftOperationsMap: IOperationMap = {};\r\n\r\n        stateList.forEach(state => {\r\n            shiftOperationsMap[state.index] = <IOperation>{\r\n                type: EOperationType.k_Shift,\r\n                stateIndex: state.index\r\n            };\r\n        })\r\n\r\n        const nonTerminals = this.nonTerminals();\r\n        nonTerminals.forEach(nonTerminal => {\r\n            this.rules(nonTerminal).forEach(rule => {\r\n                reduceOperationsMap[rule.index] = {\r\n                    type: EOperationType.k_Reduce,\r\n                    rule: rule\r\n                };\r\n            });\r\n        });\r\n\r\n        //Build syntax table\r\n        stateList.forEach(state => {\r\n            this.addReducing(syntaxTable, state, reduceOperationsMap);\r\n            this.addShift(syntaxTable, state, shiftOperationsMap);\r\n        });\r\n    }\r\n\r\n\r\n    private statesToString(isBaseOnly: boolean = true): string {\r\n        if (!this._states) {\r\n            return \"\";\r\n        }\r\n\r\n        let msg = \"\";\r\n        for (let i = 0; i < this._states.length; i++) {\r\n            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);\r\n            msg += \" \";\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    private static operationToString(operation: IOperation): string {\r\n        let opVal: string = \"\";\r\n\r\n        switch (operation.type) {\r\n            case EOperationType.k_Shift:\r\n                opVal = \"SHIFT to state \" + operation.stateIndex.toString();\r\n                break;\r\n            case EOperationType.k_Reduce:\r\n                opVal = \"REDUCE by rule { \" + AbstractParser.ruleToString(operation.rule) + \" }\";\r\n                break;\r\n            case EOperationType.k_Success:\r\n                opVal = \"SUCCESS\";\r\n                break;\r\n        }\r\n\r\n        return opVal;\r\n    }\r\n\r\n\r\n    private static ruleToString(rule: IRule): string {\r\n        let ruleVal: string;\r\n\r\n        ruleVal = rule.left + \" : \" + rule.right.join(\" \");\r\n\r\n        return ruleVal;\r\n    }\r\n\r\n\r\n    private convertGrammarSymbol(symbol: string): string {\r\n        if (!this.isTerminal(symbol)) {\r\n            return symbol;\r\n        }\r\n        return this.lexerEngine.getTerminalValueByName(symbol);\r\n    }\r\n\r\n\r\n\r\n    private static $parserEngine: IParser = null;\r\n    private static $parserParams: IParserParams = null;\r\n\r\n    // /**\r\n    //  * Create a singleton instance of parser for internal use.\r\n    //  */\r\n    // static init(\r\n    //     parserParams: IParserParams, \r\n    //     ParserEngineConstructor: new (grammar, flags, type) => IParserEngine = null\r\n    //     ): IParserEngine {\r\n    //     const { grammar, flags, type } = parserParams;\r\n\r\n    //     if (!grammar) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (deepEqual(parserParams, ParserEngine.$parserParams)) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (isNull(ParserEngineConstructor)) {\r\n    //         ParserEngineConstructor = ParserEngine;\r\n    //     }\r\n\r\n    //     console.time();\r\n    //     console.log('%c Creating parser engine....', 'background: #222; color: #bada55');\r\n    //     ParserEngine.$parserParams = parserParams;\r\n\r\n    //     try {\r\n    //         ParserEngine.$parserEngine = new ParserEngineConstructor(grammar, flags, type);\r\n    //         console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n    //     } catch (e) {\r\n    //         ParserEngine.$parserEngine = null;\r\n    //         console.error('%c [ FAILED ]', 'background: #ffdcd6; color: #ff0000');\r\n\r\n    //         if (e instanceof DiagnosticException) {\r\n    //             verbose(e.stack);\r\n    //         }\r\n    //         throw e;\r\n    //     }\r\n\r\n    //     console.timeEnd();\r\n\r\n    //     return ParserEngine.$parserEngine;\r\n    // }\r\n\r\n\r\n    // static async parse(source: string, uri = \"stdin\", flags = EParsingFlags.k_Optimize) {\r\n\r\n    //     const engine = ParserEngine.$parserEngine;\r\n\r\n    //     const timeLabel = `parse ${uri}`;\r\n    //     console.time(timeLabel);\r\n    //     // All diagnostic exceptions should be already handled inside parser.\r\n    //     const parser = new ParserEngine.$parserEngine.parse(source, filename, flags)\r\n    //     let result = await ;\r\n    //     console.timeEnd(timeLabel);\r\n\r\n    //     let diag = ParserEngine.$parserEngine.getDiagnostics();\r\n    //     let ast = ParserEngine.$parserEngine.getSyntaxTree();\r\n\r\n    //     return { result, diag, ast };\r\n    // }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { ILexer, ILexerConfig, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { END_SYMBOL } from \"@lib/parser/symbols\";\r\n\r\nexport class CachingLexer implements ILexer {\r\n    private tokens: IToken[];\r\n    private pos: number;\r\n\r\n    constructor(tokens: IToken[]) {\r\n        this.tokens = tokens || [];\r\n        this.pos = 0;\r\n    }\r\n\r\n    /**\r\n     * Dummy api\r\n     */\r\n    get document(): ITextDocument { assert(false); return null; }\r\n    get config(): ILexerConfig { assert(false); return null; }\r\n    \r\n    setTextDocument(textDocument: ITextDocument): ILexer { assert(false); return this; }\r\n    getNextLine(): IToken { assert(false); return null; }\r\n    /** end */\r\n\r\n    getPosition(): number {\r\n        return this.pos;\r\n    }\r\n\r\n    setPosition(pos: number): void {\r\n        this.pos = pos;\r\n    }\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        assert(false);\r\n        return null;\r\n    }\r\n\r\n    getNextToken(): IToken {\r\n        return this.tokens[this.pos++] || CachingLexer.END_TOKEN;\r\n    }\r\n\r\n    private static END_TOKEN = {\r\n        index: -1,\r\n        name: END_SYMBOL,\r\n        value: END_SYMBOL,\r\n        loc: null\r\n    };\r\n}\r\n\r\n","import { EParserType, ExpectedSymbols, IRule } from \"@lib/idl/parser/IParser\";\r\nimport { END_POSITION } from \"@lib/parser/symbols\";\r\n\r\n\r\nexport class Item {\r\n    rule: IRule;\r\n    /**\r\n     * Position in item. \r\n     * left: right0,   right1, ...., rightN;\r\n     *               ^\r\n     *               position\r\n     */\r\n    pos: number;\r\n    /**\r\n     * Index in parser.\r\n     * (Uniq ID)\r\n     */\r\n    index: number;\r\n\r\n    expectedSymbols: ExpectedSymbols;\r\n\r\n    constructor(rule: IRule, pos: number, expectedSymbols?: string[]) {\r\n        this.rule = rule;\r\n        this.pos = pos;\r\n        this.index = 0;\r\n        this.expectedSymbols = new Set<string>();\r\n\r\n        if (expectedSymbols) {\r\n            expectedSymbols.forEach(symbol => this.addExpected(symbol));\r\n        }\r\n    }\r\n\r\n    isEqual(item: Item, type: EParserType = EParserType.k_LR0): boolean {\r\n        if (type === EParserType.k_LR0) {\r\n            return (this.rule === item.rule && this.pos === item.pos);\r\n        } \r\n        \r\n        if (type === EParserType.k_LR1) {\r\n            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {\r\n                return false;\r\n            }\r\n\r\n            for (const symbol of this.expectedSymbols) {\r\n                if (!item.isExpected(symbol)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } \r\n\r\n        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.\r\n        return false;\r\n    }\r\n\r\n    isParentItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos + 1);\r\n    }\r\n\r\n    isChildItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos - 1);\r\n    }\r\n\r\n    symbolName(): string {\r\n        const right = this.rule.right;\r\n        if (this.pos === right.length) {\r\n            return END_POSITION;\r\n        }\r\n        return right[this.pos];\r\n    }\r\n\r\n    // lastSymbolName(): string {\r\n    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;\r\n    // }\r\n\r\n    // // get next symbol name\r\n    // nextSymbolName(): string {\r\n    //     return this.rule.right[this.pos + 1] || END_POSITION;\r\n    // }\r\n\r\n    isExpected(symbol: string): boolean {\r\n        return this.expectedSymbols.has(symbol);\r\n    }\r\n\r\n    addExpected(symbol: string): boolean {\r\n        if (this.isExpected(symbol)) {\r\n            return false;\r\n        }\r\n        this.expectedSymbols.add(symbol);\r\n        return true;\r\n    }\r\n\r\n    toString(grammarSymbols: Map<string, string> = null): string {\r\n        const { left, right } = this.rule;\r\n\r\n        let msg = `${left} -> `;\r\n\r\n        msg += right\r\n            .map(s => Item.decodeSymbol(s, grammarSymbols))\r\n            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))\r\n            .join(' ');\r\n\r\n        if (this.pos === right.length) {\r\n            msg += \" . \";\r\n        }\r\n\r\n        if (this.expectedSymbols) {\r\n            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));\r\n\r\n            if (expectedTokens.length) {\r\n                msg += \", \" + expectedTokens.join(' ');\r\n            }\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    static decodeSymbol(s: string, grammarSymbols: Map<string, string>) {\r\n        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);\r\n    }\r\n}\r\n","import { assert } from '@lib/common';\r\nimport { EDiagnosticCategory, IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { ETokenType, ILexer, ILexerConfig, ILexerEngine, IPosition, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { END_SYMBOL, EOF, T_FLOAT, T_LINE_TERMINATOR, T_MACRO, T_MACRO_CONCAT, T_NON_TYPE_ID, T_STRING, T_TYPE_ID, T_UINT, UNKNOWN_TOKEN } from '@lib/parser/symbols';\r\nimport * as util from '@lib/parser/util';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\n\r\ninterface ILexerDiagDesc {\r\n    file: string;\r\n    token: IToken;\r\n}\r\n\r\n\r\nenum ELexerErrors {\r\n    UnknownToken = 2101,\r\n    InvalidToken = 2102\r\n};\r\n\r\n\r\nclass LexerDiagnostics extends Diagnostics<ILexerDiagDesc> {\r\n    constructor() {\r\n        super(\"Lexer Diagnostics\", 'L');\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: ILexerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: ILexerDiagDesc): IRange {\r\n        return desc.token.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [ELexerErrors.UnknownToken]: \"Unknown token: {token.value}.\",\r\n            [ELexerErrors.InvalidToken]: \"Invalid token: {token.value}.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport class LexerEngine implements ILexerEngine {\r\n    readonly keywords: IMap<string> = {};\r\n    readonly punctuators: IMap<string> = {};\r\n    readonly punctuatorsFirstSymbols: IMap<boolean> = {};\r\n\r\n\r\n    addPunctuator(value: string, name: string = LexerEngine.getPunctuatorName(value)): string {\r\n        this.punctuators[value] = name;\r\n        this.punctuatorsFirstSymbols[value[0]] = true;\r\n        return name;\r\n    }\r\n\r\n\r\n    addKeyword(value: string, name: string): string {\r\n        this.keywords[value] = name;\r\n        return name;\r\n    }\r\n\r\n\r\n    getTerminalValueByName(name: string): string {\r\n        let value = \"\";\r\n\r\n        for (value in this.punctuators) {\r\n            if (this.punctuators[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        for (value in this.keywords) {\r\n            if (this.keywords[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    isLineTerminator(symbol: string): boolean {\r\n        return (symbol === \"\\n\" || symbol === \"\\r\" || symbol === \"\\u2028\" || symbol === \"\\u2029\");\r\n    }\r\n\r\n\r\n    isKeyword(value: string): boolean {\r\n        return !!(this.keywords[value]);\r\n    }\r\n\r\n\r\n    isPunctuator(value: string): boolean {\r\n        return !!(this.punctuators[value]);\r\n    }\r\n\r\n\r\n    isNumberStart(ch: string, ch1: string): boolean {\r\n        if ((ch >= \"0\") && (ch <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        if (ch === \".\" && (ch1 >= \"0\") && (ch1 <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isCommentStart(ch: string, ch1: string): boolean {\r\n        if (ch === \"/\" && (ch1 === \"/\" || ch1 === \"*\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isStringStart(ch: string): boolean {\r\n        if (ch === \"\\\"\" || ch === \"'\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isPunctuatorStart(ch: string): boolean {\r\n        if (this.punctuatorsFirstSymbols[ch]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isWhiteSpaceStart(ch: string): boolean {\r\n        if (ch === \" \" || ch === \"\\t\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isNewlineStart(ch: string): boolean {\r\n        if (ch === \"\\n\" || ch === \"\\r\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isEscapeSequenceStart(ch: string): boolean {\r\n        return ch === '\\\\';\r\n    }\r\n\r\n\r\n    isIdentifierStart(ch: string): boolean {\r\n        if ((ch === \"_\") || (ch === \"$\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    static getPunctuatorName(value: string): string {\r\n        return \"T_PUNCTUATOR_\" + value.charCodeAt(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nexport class Lexer implements ILexer {\r\n    protected index: number;\r\n    protected lineNumber: number;\r\n    protected columnNumber: number;\r\n\r\n    //\r\n    // text document\r\n    //\r\n\r\n    /* readonly */ document: ITextDocument;\r\n\r\n    //\r\n    // Setup\r\n    //\r\n\r\n    readonly engine: LexerEngine;\r\n    readonly diagnostics: LexerDiagnostics;\r\n    readonly knownTypes: Set<string>;\r\n\r\n    //\r\n    // Config\r\n    //\r\n\r\n    readonly config: {\r\n        skipComments: boolean;\r\n        allowLineTerminators: boolean;\r\n    };\r\n\r\n    constructor({ \r\n        engine = new LexerEngine,\r\n        knownTypes = new Set(),\r\n        skipComments = true,\r\n        allowLineTerminators = false,\r\n    }: ILexerConfig = {}) {\r\n        this.diagnostics = new LexerDiagnostics;\r\n        this.knownTypes = knownTypes;\r\n        this.engine = engine;\r\n        this.config = { skipComments, allowLineTerminators };\r\n    }\r\n\r\n\r\n    getPosition(): IPosition {\r\n        return this.pos();\r\n    }\r\n\r\n\r\n    setPosition(pos: IPosition): void {\r\n        assert(this.document.uri === pos.file);\r\n        this.index = pos.offset;\r\n        this.lineNumber = pos.line;\r\n        this.columnNumber = pos.column;\r\n    }\r\n\r\n    \r\n    setTextDocument(textDocument: ITextDocument): ILexer {\r\n        this.columnNumber = 0;\r\n        this.lineNumber = 0;\r\n        this.index = 0;\r\n        this.document = textDocument;\r\n        return this;\r\n    }\r\n\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return this.diagnostics.resolve();\r\n    }\r\n\r\n    \r\n    getNextToken(): IToken {\r\n        const token = this.scanToken();\r\n        util.offset(token.loc, this.document.offset);\r\n        return token;\r\n    }\r\n\r\n\r\n    getNextLine(): IToken {\r\n        const token = this.scanThisLine();\r\n        util.offset(token.loc, this.document.offset);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected scanToken(): IToken {\r\n        const ch = this.currentChar();\r\n        if (!ch) {\r\n            const pos = this.pos();\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: END_SYMBOL,\r\n                value: END_SYMBOL,\r\n                loc: {\r\n                    start: pos,\r\n                    end: { ...pos }\r\n                }\r\n            };\r\n        }\r\n\r\n        switch (this.identityTokenType()) {\r\n            case ETokenType.k_NumericLiteral:\r\n                return this.scanNumber();\r\n            case ETokenType.k_SinglelineCommentLiteral:\r\n            case ETokenType.k_MultilineCommentLiteral:\r\n                if (this.config.skipComments) {\r\n                    this.scanComment();\r\n                    return this.scanToken();\r\n                }\r\n                return this.scanComment();\r\n            case ETokenType.k_StringLiteral:\r\n                return this.scanString();\r\n            case ETokenType.k_PunctuatorLiteral:\r\n                return this.scanPunctuator();\r\n            case ETokenType.k_IdentifierLiteral:\r\n                return this.scanIdentifier();\r\n            case ETokenType.k_EscapeSequence:\r\n                return this.scanEscapeSequence();\r\n            case ETokenType.k_NewlineLiteral:\r\n                if (!this.config.allowLineTerminators) {\r\n                    this.scanLineTerminators();\r\n                    return this.scanToken();\r\n                }\r\n                return this.scanLineTerminators();\r\n            case ETokenType.k_WhitespaceLiteral:\r\n                this.scanWhiteSpace();\r\n                return this.scanToken();\r\n            case ETokenType.K_MacroLiteral:\r\n                return this.scanMacro();\r\n            default:\r\n                return this.scanInvalid();\r\n        }\r\n    }\r\n\r\n\r\n    protected scanThisLine(): IToken {\r\n        let start = this.pos();\r\n        let value = '';\r\n        let ch = this.currentChar();\r\n        while (ch) {\r\n            if (ch === '\\\\') {\r\n                let chNext = this.readNextChar();\r\n                if (chNext === '\\r') {\r\n                    chNext = this.readNextChar();\r\n                }\r\n                switch (chNext) {\r\n                    case '\\n':\r\n                        ch = this.readNextChar();\r\n                        this.lineNumber++;\r\n                        this.columnNumber = 0;\r\n                        value += '\\\\\\n'; \r\n                        continue;\r\n                    case 'n':\r\n                        ch = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        ch = '\\t';\r\n                        break;\r\n                    default:\r\n                        assert(false, 'unsupported character sequence found');\r\n                }\r\n            } else if (ch === '\\n') {\r\n                break;\r\n            }\r\n\r\n            value += ch;\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value,\r\n            loc: { start, end: this.pos() }\r\n        };\r\n    }\r\n\r\n\r\n    protected pos(n: number = 0): IPosition {\r\n        return {\r\n            file: this.document.uri,\r\n            line: this.lineNumber,\r\n            column: this.columnNumber + n,\r\n            offset: this.index + n\r\n        };\r\n    }\r\n\r\n\r\n    protected emitError(code: number, token: IToken): void {\r\n        this.diagnostics.error(code, { file: `${this.document.uri}`, token });\r\n    }\r\n\r\n\r\n    protected identityTokenType(): ETokenType {\r\n        if (this.isIdentifierStart()) {\r\n            return ETokenType.k_IdentifierLiteral;\r\n        }\r\n        if (this.isWhiteSpaceStart()) {\r\n            return ETokenType.k_WhitespaceLiteral;\r\n        }\r\n        if (this.isNewlineStart()) {\r\n            return ETokenType.k_NewlineLiteral;\r\n        }\r\n        if (this.isEscapeSequenceStart()) {\r\n            return ETokenType.k_EscapeSequence;\r\n        }\r\n        if (this.isStringStart()) {\r\n            return ETokenType.k_StringLiteral;\r\n        }\r\n        if (this.isCommentStart()) {\r\n            // TODO: return exact type (separate multiline/singleline comment parsings)\r\n            return ETokenType.k_SinglelineCommentLiteral;\r\n        }\r\n        if (this.isNumberStart()) {\r\n            return ETokenType.k_NumericLiteral;\r\n        }\r\n        if (this.isPunctuatorStart()) {\r\n            return ETokenType.k_PunctuatorLiteral;\r\n        }\r\n        if (this.isMacroStart()) {\r\n            return ETokenType.K_MacroLiteral;\r\n        }\r\n        return ETokenType.k_Unknown;\r\n    }\r\n\r\n\r\n    protected isNumberStart(): boolean {\r\n        return this.engine.isNumberStart(this.currentChar(), this.nextChar());\r\n    }\r\n\r\n\r\n    protected isCommentStart(): boolean {\r\n        return this.engine.isCommentStart(this.currentChar(), this.nextChar())\r\n    }\r\n\r\n\r\n    protected isStringStart(): boolean {\r\n        return this.engine.isStringStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isPunctuatorStart(): boolean {\r\n        return this.engine.isPunctuatorStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isWhiteSpaceStart(): boolean {\r\n        return this.engine.isWhiteSpaceStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isNewlineStart(): boolean {\r\n        return this.engine.isNewlineStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected isEscapeSequenceStart(): boolean {\r\n        return this.engine.isEscapeSequenceStart(this.currentChar());\r\n    }\r\n\r\n    protected isMacroStart(): boolean {\r\n        return this.currentChar() === '#';\r\n    }\r\n\r\n    protected isIdentifierStart(): boolean {\r\n        return this.engine.isIdentifierStart(this.currentChar());\r\n    }\r\n\r\n\r\n    protected nextChar(): string {\r\n        return this.document.source[this.index + 1];\r\n    }\r\n\r\n\r\n    protected currentChar(): string {\r\n        return this.document.source[<number>this.index];\r\n    }\r\n\r\n\r\n    protected readNextChar(): string {\r\n        this.index++;\r\n        this.columnNumber++;\r\n        return this.document.source[<number>this.index];\r\n    }\r\n\r\n\r\n    protected scanEscapeSequence(): IToken {\r\n        let ch = this.readNextChar();\r\n        if (ch === '\\r') {\r\n            ch = this.readNextChar();\r\n        }\r\n        assert(ch === '\\n', 'unsupported escape sequence found');\r\n        this.lineNumber++;\r\n        this.columnNumber = 0;\r\n        this.readNextChar();\r\n        return this.scanToken();\r\n    }\r\n\r\n    protected scanString(): IToken {\r\n        let chFirst = this.currentChar();\r\n        let value = chFirst;\r\n        let ch = \"\";\r\n        let chPrevious = chFirst;\r\n        let isGoodFinish = false;\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            value += ch;\r\n            if (ch === chFirst && chPrevious !== \"\\\\\") {\r\n                isGoodFinish = true;\r\n                this.readNextChar();\r\n                break;\r\n            }\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: T_STRING,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_StringLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanInvalid(): IToken {\r\n        const start = this.pos();\r\n        \r\n        let value = '';\r\n        while (this.identityTokenType() === ETokenType.k_Unknown && this.index < this.document.source.length) {\r\n            value += this.currentChar();\r\n            this.readNextChar();\r\n        }\r\n\r\n        const token = {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value,\r\n            loc: { start, end: this.pos() }\r\n        };\r\n\r\n        this.emitError(ELexerErrors.UnknownToken, token);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected scanPunctuator(): IToken {\r\n        let value = this.currentChar();\r\n        let start = this.pos();\r\n        let ch: string;\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch) {\r\n                value += ch;\r\n                if (!this.engine.isPunctuator(value)) {\r\n                    value = value.slice(0, value.length - 1);\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return <IToken>{\r\n            index: this.index,\r\n            name: this.engine.punctuators[value],\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanNumber(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = \"\";\r\n        let isFloat = false;\r\n        let isHex = false;\r\n        let isL = false;\r\n        let chPrevious = ch;\r\n        let isGoodFinish = false;\r\n        let isE = false; // exponential\r\n        let isU = false; // unsigned\r\n        let start = this.pos();\r\n\r\n        if (ch === \".\") {\r\n            value += 0;\r\n            isFloat = true;\r\n        }\r\n\r\n        value += ch;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch === \".\") {\r\n                if (isFloat || isU || isL || isHex) {\r\n                    break;\r\n                }\r\n                isFloat = true;\r\n            }\r\n            else if (ch === \"e\") {\r\n                if (isE || isU || isL) { // \"0x100e2\" is valid\r\n                    break;\r\n                }\r\n                isE = true;\r\n            }\r\n            else if (ch === \"u\" || ch === \"U\") {\r\n                if (isFloat || isU) { // \"0x02u\" or \"0x100e2u\" are valid\r\n                    break;\r\n                }\r\n                isU = true;\r\n            }\r\n            else if (ch === \"l\" || ch === \"L\") {\r\n                if (isFloat || isL) { \r\n                    break;\r\n                }\r\n                isL = true;\r\n            }\r\n            else if (ch === \"x\") {\r\n                if (isU || isL || isE || isFloat) {\r\n                    break;\r\n                }\r\n                isHex = true;\r\n            }\r\n            else if (((ch === \"+\" || ch === \"-\") && chPrevious === \"e\")) {\r\n                // nothing todo, valid case\r\n            }\r\n            else if (ch === \"f\" && (isFloat || isE)) {\r\n                isFloat = true;\r\n                ch = this.readNextChar();\r\n                // redundant check?\r\n                if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                    break;\r\n                }\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            // break on any unused alphabetic character\r\n            else if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                if (!isHex) {\r\n                    break;\r\n                }\r\n            }\r\n            // Handle the case when a character is read not a number (end of numeric seq.)\r\n            else if (!((ch >= \"0\") && (ch <= \"9\")) || !ch || isU || isL) {\r\n                // check that the exponent completely read\r\n                if ((isE && chPrevious !== \"+\" && chPrevious !== \"-\" && chPrevious !== \"e\") || !isE) {\r\n                    isGoodFinish = true;\r\n                }\r\n                break;\r\n            }\r\n\r\n            value += ch;\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            let name = isFloat ? T_FLOAT : T_UINT;\r\n            return <IToken>{\r\n                index: this.index,\r\n                name,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_NumericLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanMacro(): IToken {\r\n        // TODO: add option config.allowMacro \r\n\r\n        const start = this.pos();\r\n        const chNext = this.nextChar();\r\n\r\n        if ((chNext >= \"a\" && chNext <= \"z\") || (chNext >= \"A\" && chNext <= \"Z\")) {\r\n            this.readNextChar();\r\n            const id = this.scanIdentifier();\r\n            return {\r\n                index: this.index,\r\n                name: T_MACRO,\r\n                value: `#${id.value}`,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        } else if (chNext === '#') {\r\n            this.readNextChar();\r\n            this.readNextChar();\r\n            \r\n            return {\r\n                index: this.index,\r\n                name: T_MACRO_CONCAT,\r\n                value: '##',\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        } \r\n        \r\n        assert(false, `unsupported macro found: ${this.document.source.substr(this.index, 20)}...`);\r\n        this.readNextChar();\r\n        return {\r\n            index: this.index,\r\n            name: UNKNOWN_TOKEN,\r\n            value: '#',\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanIdentifier(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = ch;\r\n        let start = this.pos();\r\n        let isGoodFinish = false;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            if (!((ch === \"_\") || (ch === \"$\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\") || (ch >= \"0\" && ch <= \"9\"))) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            value += ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            if (this.engine.isKeyword(value)) {\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name: this.engine.keywords[value],\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                let name = this.knownTypes.has(value) ? T_TYPE_ID : T_NON_TYPE_ID;\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_IdentifierLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    protected scanLineTerminators(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = '';\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            if (this.engine.isLineTerminator(ch)) {\r\n                value += ch;\r\n                if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                    this.lineNumber--;\r\n                }\r\n                this.lineNumber++;\r\n                ch = this.readNextChar();\r\n                this.columnNumber = 0;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n\r\n        let name = T_LINE_TERMINATOR;\r\n        return <IToken>{\r\n            index: this.index,\r\n            name,\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    protected scanWhiteSpace(): boolean {\r\n        let ch = this.currentChar();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"\\t\") {\r\n                // possible way to convert tab to multiple spaces\r\n                this.columnNumber += 0;\r\n            }\r\n            else if (ch !== \" \") {\r\n                break;\r\n            }\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    protected scanComment(): IToken {\r\n        let value = this.currentChar();\r\n        let ch = this.readNextChar();\r\n        let start = this.pos();\r\n        value += ch;\r\n\r\n        if (ch === \"/\") {\r\n            //Line Comment\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.readNextChar();\r\n                    this.columnNumber = 0;\r\n                    break;\r\n                }\r\n                value += ch;\r\n            }\r\n\r\n            return {\r\n                index: this.index,\r\n                type: ETokenType.k_SinglelineCommentLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            //Multiline Comment\r\n            let chPrevious = ch;\r\n            let isGoodFinish = false;\r\n            let start = this.pos();\r\n\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                value += ch;\r\n                if (ch === \"/\" && chPrevious === \"*\") {\r\n                    isGoodFinish = true;\r\n                    this.readNextChar();\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.columnNumber = -1;\r\n                }\r\n                chPrevious = ch;\r\n            }\r\n\r\n            if (isGoodFinish) {\r\n                return {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                if (!ch) {\r\n                    ch = EOF;\r\n                }\r\n                value += ch;\r\n\r\n                const token = {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n\r\n                this.emitError(ELexerErrors.InvalidToken, token);\r\n                return Lexer.makeUnknownToken(token);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    static makeUnknownToken(token: IToken): IToken {\r\n        return {\r\n            ...token,\r\n            type: undefined,\r\n            name: UNKNOWN_TOKEN,\r\n            loc: {\r\n                start: { ...token.loc.start },\r\n                end: { ...token.loc.end }\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { IMap } from \"@lib/idl/IMap\";\r\nimport { IMacro } from \"@lib/idl/parser/IMacro\";\r\n\r\nexport class Macros {\r\n    stack: { root: IMacro, macros: IMap<IMacro>; }[] = [{ root: null, macros: {} }];\r\n\r\n    get depth() {\r\n        return this.stack.length;\r\n    }\r\n\r\n    get root(): IMacro{\r\n        return this.stack[this.depth - 1].root;\r\n    }\r\n\r\n    push(source: IMacro) {\r\n        this.stack.push({ root: source, macros: {} });\r\n    }\r\n\r\n    pop() {\r\n        this.stack.pop();\r\n    }\r\n\r\n    set(macro: IMacro): void {\r\n        this.stack[this.depth - 1].macros[macro.name] = macro;\r\n    }\r\n\r\n    unset(name: string): void {\r\n        delete this.stack[this.depth - 1].macros[name];\r\n    }\r\n\r\n    get(name: string): IMacro {\r\n        let i = this.depth - 1;\r\n        while (true) {\r\n            const { macros, root } = this.stack[i];\r\n            \r\n            // avoidance of recursive substitution\r\n            if (root?.name === name && !root.bFunction) {\r\n                return null;\r\n            }\r\n\r\n            const macro = macros[name];\r\n            if (macro) {\r\n                return macro;\r\n            }\r\n\r\n            if (i == 0) break;\r\n            i = 0;\r\n        };\r\n        return null;\r\n    }\r\n\r\n    has(name: string): boolean {\r\n        return this.get(name) !== null;\r\n    }\r\n\r\n    forEach(cb: (value: IMacro) => void): void {\r\n        let overrides = new Set;\r\n        for (let i = this.depth - 1; i >= 0; --i) {\r\n            const macros = this.stack[i].macros;\r\n            for (const macro of Object.values(macros)) {\r\n                if (!overrides.has(macro.name)) {\r\n                    overrides.add(macro.name);\r\n                    cb(macro);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    *[Symbol.iterator]() {\r\n        let overrides = new Set;\r\n        for (let i = this.depth - 1; i >= 0; --i) {\r\n            const macros = this.stack[i].macros;\r\n            for (const macro of Object.values(macros)) {\r\n                if (!overrides.has(macro.name)) {\r\n                    overrides.add(macro.name);\r\n                    yield macro;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { ENodeCreateMode, IParseNode, IParseTree, IPosition, IRange, IRule, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { extendRange } from \"./util\";\r\n\r\nexport class ParseTree implements IParseTree {\r\n    root: IParseNode;\r\n    nodes: IParseNode[];\r\n    \r\n    readonly optimized: boolean;\r\n    \r\n    private nodesCountStack: number[];\r\n\r\n\r\n    constructor(optimized: boolean, root: IParseNode = null) {\r\n        this.root = root;\r\n        this.nodes = [];\r\n        this.optimized = optimized;\r\n\r\n        this.nodesCountStack = [];\r\n    }\r\n\r\n\r\n    get lastNode(): IParseNode {\r\n        return this.nodes[this.nodes.length - 1];\r\n    }\r\n\r\n\r\n    finishTree(): void {\r\n        this.root = this.nodes.pop() || null;\r\n    }\r\n\r\n\r\n    addToken({ name, value, loc }: IToken): void {\r\n        const children = null;\r\n        const parent = null;\r\n        this.addNode({ name, value, loc, children, parent });\r\n    }\r\n\r\n    reduceByRule(rule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {\r\n        let iReduceCount = 0;\r\n        let nodesCountStack = this.nodesCountStack;\r\n        let ruleLength = rule.right.length;\r\n        let nodes = this.nodes;\r\n        let optimize = this.optimized ? 1 : 0;\r\n\r\n        while (ruleLength) {\r\n            iReduceCount += nodesCountStack.pop();\r\n            ruleLength--;\r\n        }\r\n\r\n        if ((eCreate === ENodeCreateMode.k_Skip && iReduceCount > optimize) || iReduceCount === 0) {\r\n            nodes.length -= iReduceCount;\r\n            nodesCountStack.push(0);\r\n        }  else if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > optimize) || \r\n            (eCreate === ENodeCreateMode.k_Necessary)) {\r\n\r\n            assert(iReduceCount > 0);\r\n            \r\n            let temp = nodes.pop();\r\n            iReduceCount--;\r\n            \r\n            const name = rule.left;\r\n            // TODO: use correct location in case of include macro. \r\n            const loc = { ...temp.loc };\r\n\r\n            const node: IParseNode = { name, children: null, parent: null, value: '', loc };\r\n\r\n            this.addLink(node, temp);\r\n\r\n            while (iReduceCount) {\r\n                assert(nodes.length > 0);\r\n                this.addLink(node, nodes.pop());\r\n                iReduceCount--;\r\n            }\r\n            \r\n            nodes.push(node);\r\n            nodesCountStack.push(1);      \r\n        }\r\n        else {\r\n            nodesCountStack.push(iReduceCount);\r\n        }\r\n    }\r\n\r\n    private addNode(node: IParseNode): void {\r\n        this.nodes.push(node);\r\n        this.nodesCountStack.push(1);\r\n    }\r\n\r\n    $pop(loc: IRange = null): void {\r\n        let count = this.nodesCountStack.pop();\r\n        while (count) {\r\n            let node = this.nodes.pop();\r\n            if (loc) {\r\n                extendRange(loc, node.loc);\r\n            }\r\n            count--;\r\n        }\r\n    }\r\n \r\n    private addLink(parent: IParseNode, child: IParseNode): void {\r\n        parent.children = parent.children || [];\r\n        \r\n        extendRange(parent.loc, child.loc);\r\n        \r\n        parent.children.push(child);\r\n        child.parent = parent;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree {\r\n        return new ParseTree(this.optimized, this.cloneNode(this.root));\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // FIXME: location should be clonned too\r\n    private cloneNode({ name, value, children }: IParseNode): IParseNode {\r\n        const clone: IParseNode = { name, value, children: null, parent: null };\r\n        if (children) { \r\n            children.forEach(child => this.addLink(clone, this.cloneNode(child)))\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toString(): string {\r\n        if (this.root) {\r\n            return this.toStringNode(this.root);\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    /** @deprecated */\r\n    private toStringNode(node: IParseNode, padding: string = \"\"): string {\r\n        let res: string = padding + \"{\\n\";\r\n        let oldPadding: string = padding;\r\n        let defaultPadding: string = \"  \";\r\n\r\n        padding += defaultPadding;\r\n\r\n        if (node.value) {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"value : \\\"\" + node.value + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"children : [\";\r\n\r\n            let children: IParseNode[] = node.children;\r\n\r\n            if (children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n\r\n                for (let i = children.length - 1; i >= 0; i--) {\r\n                    res += this.toStringNode(children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toHTMLString(node: IParseNode, padding: string = \"\") {\r\n        node = node || this.root;\r\n        let res = padding + \"{\\n\";\r\n        let oldPadding = padding;\r\n        let defaultPadding = \"  \";\r\n        padding += defaultPadding;\r\n        if (node.value) {\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">name</b>: \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">value</b>: \\\"\" + node.value + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            let i;\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">name</i>: \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">children</i>: [\";\r\n            if (node.children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n                for (i = node.children.length - 1; i >= 0; i--) {\r\n                    res += this.toHTMLString(node.children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n}\r\n","import { isDef, isDefAndNotNull } from \"@lib/common\";\r\nimport { assert, isNull, isString } from \"@lib/common\";\r\nimport { defaultSLParser } from \"@lib/fx/SLParser\";\r\nimport { createTextDocument } from \"@lib/fx/TextDocument\";\r\nimport { EDiagnosticCategory, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IMacro } from \"@lib/idl/parser/IMacro\";\r\nimport { ETokenType, IFile, ILexer, ILexerConfig, ILexerEngine, IncludeResolver, IPosition, IRange, IToken } from \"@lib/idl/parser/IParser\";\r\nimport * as util from '@lib/parser/util';\r\nimport * as URI from \"@lib/uri/uri\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { CachingLexer } from \"@lib/parser/CachingLexer\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { Macros } from \"@lib/parser/Macros\";\r\nimport { END_SYMBOL, T_MACRO, T_MACRO_CONCAT, T_NON_TYPE_ID, T_TYPE_ID } from \"@lib/parser/symbols\";\r\n\r\nlet DEBUG_MACRO = false;\r\n\r\nenum EMacroState {\r\n    k_AllowElse,\r\n    k_ForbidElse\r\n};\r\n\r\n\r\ninterface IMacroFunc {\r\n    op: (...args: IToken[]) => IToken;\r\n    length: number;\r\n}\r\n\r\n\r\nexport enum EPreprocessorErrors {\r\n    SyntaxUnknownError = 7051,\r\n    GeneralCouldNotReadFile = 7200,\r\n    MacroUnknownError,\r\n};\r\n\r\n\r\nexport enum EPreprocessorWarnings {\r\n    MacroUnknownWarning = 3000,\r\n}\r\n\r\n\r\nexport class PreprocessorDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Preprocessor diagnostics\", 'M');\r\n    }\r\n\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: IMap<any>): IRange {\r\n        if (category === EDiagnosticCategory.k_Warning) {\r\n            switch (code) {\r\n                case EPreprocessorWarnings.MacroUnknownWarning:\r\n                    return desc.loc;\r\n            }\r\n        }\r\n\r\n        //\r\n        // errors\r\n        //\r\n\r\n        switch (code) {\r\n            case EPreprocessorErrors.SyntaxUnknownError:\r\n                return desc.token.loc;\r\n            case EPreprocessorErrors.GeneralCouldNotReadFile:\r\n                return desc.loc;\r\n            case EPreprocessorErrors.MacroUnknownError:\r\n                return desc.loc;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EPreprocessorErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"Line: {token.loc.start.line}. Column: {token.loc.start.column}.\",\r\n            [EPreprocessorErrors.GeneralCouldNotReadFile]: \"Could not read file '{target}'.\",\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IMap<any>): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EPreprocessorWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EPreprocessorErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\n\r\n// as macro token\r\n/** @deprecated */\r\nfunction createMacroToken(value: string, loc: IRange): IToken {\r\n    assert(isString(value), value);\r\n    return { index: -1, type: ETokenType.k_Unknown, name: T_MACRO, value, loc };\r\n}\r\n\r\n\r\nfunction asMacroFunc(fn: (...args: IToken[]) => number | boolean): IMacroFunc {\r\n    return {\r\n        op: (...args: IToken[]): IToken => {\r\n            const value = String(fn(...args));\r\n            const loc = util.commonRange(...args.map(arg => arg.loc));\r\n            // TODO: use typed token like: T_BOOL, T_UINT etc.\r\n            return createMacroToken(value, loc);\r\n        },\r\n        length: fn.length\r\n    };\r\n}\r\n\r\n\r\n\r\nfunction tokenToNative(token: IToken, fallback: (token: IToken) => number = () => NaN) {\r\n    const value = token.value;\r\n\r\n    if (String(value) === 'true') {\r\n        return 1;\r\n    }\r\n\r\n    if (String(value) === 'false') {\r\n        return 0;\r\n    }\r\n\r\n    // TODO: replace this check\r\n    if (String(Number(value)) === String(value)) {\r\n        return Number(value);\r\n    }\r\n\r\n    return fallback(token)\r\n}\r\n\r\n\r\nclass MacroState {\r\n    states: EMacroState[] = [];\r\n\r\n    is(state: EMacroState): boolean {\r\n        return this.states[this.states.length - 1] === state;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.states.length === 0;\r\n    }\r\n\r\n    push(state: EMacroState): void {\r\n        this.states.push(state);\r\n    }\r\n\r\n    pop(): EMacroState {\r\n        return this.states.pop();\r\n    }\r\n\r\n    replace(state: EMacroState): void {\r\n        this.pop();\r\n        this.push(state);\r\n    }\r\n}\r\n\r\n\r\nenum EPPDocumentFlags {\r\n    k_None = 0x00,\r\n    k_Macro = 0x01,\r\n    k_Include = 0x02\r\n}\r\n\r\nexport interface IKnownDefine {\r\n    name: string;\r\n}\r\n\r\nexport class Preprocessor {\r\n    protected stack: {\r\n        lexer: ILexer;\r\n        tokens: IToken[];\r\n        flags: number;  // EPPDocumentFlags \r\n        loc: IRange;\r\n    }[];\r\n    protected includes: number[];\r\n\r\n    protected diagnostics: PreprocessorDiagnostics;\r\n    protected includeResolver: IncludeResolver;\r\n\r\n    /* protected */ macros: Macros;\r\n    /* protected */ macroState: MacroState;\r\n    /* protected */ unreachableCodeList: IRange[];\r\n    /* protected */ includeMap: Map<string, IRange>;\r\n\r\n    /* protected */ unresolvedMacros: IMacro[];\r\n\r\n    protected knownTypes: Set<string>;\r\n    protected lexerEngine: ILexerEngine;\r\n\r\n    protected lexerReport: IDiagnosticReport;\r\n\r\n    protected lexerOptions: { skipComments: boolean; };\r\n\r\n    document: ITextDocument;\r\n\r\n    constructor(lexerEngine: ILexerEngine, \r\n        { \r\n            knownTypes = new Set<string>(), \r\n            macros = new Macros, \r\n            diag = new PreprocessorDiagnostics, \r\n            skipComments = true,\r\n            includeResolver = null,\r\n            defines = null\r\n        } = {}) {\r\n\r\n        this.macros = macros;\r\n\r\n        if (defines) {\r\n            // set as boolean macro\r\n            (<IKnownDefine[]>defines)\r\n                .forEach(({ name }) => \r\n                    this.macros.set({name, tokens: [], bFunction: false, params: null, bRegionExpr: false}));\r\n        }\r\n\r\n        this.macroState = new MacroState;\r\n        this.includeMap = new Map;\r\n\r\n        this.unreachableCodeList = [];\r\n        this.unresolvedMacros = [];\r\n\r\n        this.knownTypes = knownTypes;\r\n        this.lexerEngine = lexerEngine;\r\n\r\n        this.diagnostics = diag;\r\n        this.includeResolver = includeResolver;\r\n        this.lexerReport = null;\r\n        this.lexerOptions = { skipComments };\r\n        // TODO: add initital document to includeList !!!\r\n\r\n        this.stack = [];\r\n        this.includes = [];\r\n    }\r\n\r\n\r\n    get lexer(): ILexer {\r\n        return this.stack[this.stack.length - 1].lexer;\r\n    }\r\n\r\n\r\n    get tokens(): IToken[] {\r\n        return this.stack[this.stack.length - 1].tokens;\r\n    }\r\n\r\n\r\n    get uri(): IFile {\r\n        return this.document.uri;\r\n    }\r\n\r\n    /** Current location stack (each location contains \".source\" property inside.) */\r\n    // get location(): IRange {\r\n    //     return this.stack[this.stack.length - 1].loc;\r\n    // }\r\n\r\n\r\n    /** Top location of the macro if presented or null otherwise. */\r\n    macroLocation(): IRange {\r\n        // return first macro location in the current document\r\n        const latestInclude = this.includes[this.includes.length - 1];\r\n        if (latestInclude < this.stack.length - 1) {\r\n            return this.stack[latestInclude + 1].loc;\r\n        }\r\n\r\n        // return null (we are alrady in the current document)\r\n        return null;\r\n    }\r\n\r\n    currentMacro(): IMacro {\r\n        return this.macros.root;\r\n    }\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return Diagnostics.mergeReports([this.lexerReport, this.diagnostics.resolve()]);\r\n    }\r\n\r\n\r\n    readLine(): IToken {\r\n        return this.lexer.getNextLine();\r\n    }\r\n\r\n\r\n    setTextDocument(textDocument: ITextDocument): Preprocessor {\r\n        this.document = textDocument;\r\n        this.pushDocument(this.documentToLexer(textDocument), null, EPPDocumentFlags.k_Include);\r\n        return this;\r\n    }\r\n\r\n\r\n    protected pushDocument(lexer: ILexer, loc: IRange, flags: number, macro: IMacro = null): void {\r\n        const tokens = <IToken[]>[];\r\n\r\n        /// link location into chain\r\n        // if (loc) {\r\n        //     loc.source = this.stack[this.stack.length - 1].loc;\r\n        // }\r\n        \r\n        if (flags & EPPDocumentFlags.k_Macro) {\r\n            assert(isDefAndNotNull(macro));\r\n            this.macros.push(macro);\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Include) {\r\n            this.includes.push(this.stack.length);\r\n\r\n            // assert(!this.includeMap.has(`${textDocument.uri}`));\r\n            this.includeMap.set(`${lexer.document.uri}`, loc);\r\n        }\r\n\r\n        this.stack.push({ lexer, tokens, flags, loc });\r\n    }\r\n\r\n\r\n    protected pop(): void {\r\n        const { flags, lexer } = this.stack.pop();\r\n\r\n        // FIXME: do not Lexer type\r\n        const diag = (lexer as Lexer).diagnostics;\r\n        if (diag && !diag.isEmpty()) {\r\n            this.lexerReport = Diagnostics.mergeReports([this.lexerReport, lexer.getDiagnosticReport()]);\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Macro) {\r\n            this.macros.pop();\r\n        }\r\n\r\n        if (flags & EPPDocumentFlags.k_Include) {\r\n            this.includes.pop();\r\n        }\r\n    }\r\n\r\n    protected pushToken(...tokens: IToken[]): void {\r\n        this.tokens.push(...tokens);\r\n    }\r\n\r\n\r\n    protected popToken(): IToken {\r\n        return this.tokens.shift() || null;\r\n    }\r\n\r\n\r\n    async readToken(allowMacro: boolean = true, allowStateChanging = true): Promise<IToken> {\r\n        const token: IToken = this.popToken() || this.lexer.getNextToken();\r\n\r\n        switch (token.name) {\r\n            case T_MACRO:\r\n                if (allowMacro) {\r\n                    return this.readMacro(token);\r\n                }\r\n                break;\r\n            case END_SYMBOL:\r\n                if (allowStateChanging) {\r\n                    if (this.stack.length > 1) {\r\n                        this.pop();\r\n                        return this.readToken(allowMacro);\r\n                    }\r\n\r\n                    if (!this.macroState.isEmpty()) {\r\n                        // TODO: highlight open tag too.\r\n                        this.emitMacroError(`'endif' not found :/`, token.loc);\r\n                    }\r\n                }\r\n                break\r\n            default:\r\n                if (allowMacro) {\r\n                    return this.examMacro(token);\r\n                }\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    protected async readMacro(token: IToken): Promise<IToken> {\r\n        switch (token.value) {\r\n            case '#define': return this.processDefineMacro(token);\r\n            case '#ifdef': return this.processIfdefMacro(token);\r\n            case '#ifndef': return this.processIfndefMacro(token);\r\n            case '#endif': return this.processEndifMacro(token);\r\n            case '#else': return this.processElseMacro(token);\r\n            case '#elif': return this.processElifMacro(token);\r\n            case '#if': return this.processIfMacro(token);\r\n            case '#error': return this.processErrorMacro(token);\r\n            case '#include': return this.processIncludeMacro(token);\r\n            case '#undef': return this.processUndefMacro(token);\r\n            case '#pragma': {\r\n                this.readLine();\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        this.emitMacroWarning(`unsupported macro type found: ${token.value}`, token.loc)\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processUndefMacro(token: IToken): Promise<IToken> {\r\n        const name = await this.readToken(false);\r\n        const text = this.readLine();\r\n\r\n        if (name.name !== T_NON_TYPE_ID) {\r\n            // TODO: emit error\r\n            assert(name.name === T_NON_TYPE_ID);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (!this.macros.has(name.value)) {\r\n            this.emitMacroWarning(`target macro not found: ${name.value}`, name.loc);\r\n        } else {\r\n            this.macros.unset(name.value);\r\n        }\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processDefineMacro(token: IToken): Promise<IToken> {\r\n        const name = await this.readToken(false);\r\n        const text = this.readLine();\r\n\r\n        if (name.name !== T_NON_TYPE_ID) {\r\n            // TODO: emit error\r\n            assert(name.name === T_NON_TYPE_ID);\r\n            return this.readToken();\r\n        }\r\n\r\n\r\n        if (this.macros.has(name.value)) {\r\n            this.emitMacroWarning(`macro redefinition found: ${name.value}`, name.loc);\r\n        }\r\n\r\n        const macro = await this.processMacro(name, text);\r\n        if (macro) {\r\n            const unresolvedMacro = this.unresolvedMacros.find(macro => macro.name === name.value);\r\n            if (unresolvedMacro) {\r\n                macro.bRegionExpr = unresolvedMacro.bRegionExpr;\r\n                // TODO: remove this hack\r\n                this.unresolvedMacros = this.unresolvedMacros.filter(macro => macro.name !== name.value);\r\n            }\r\n\r\n            this.macros.set(macro);\r\n        }\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processMacro(name: IToken, lineToken: IToken): Promise<IMacro> {\r\n        let bFunction = false;\r\n        let bRegionExpr = false;\r\n        let params: string[] = null;\r\n        let tokens = <IToken[]>[];\r\n\r\n        if (!/^\\s*$/.test(lineToken.value)) {\r\n\r\n            //\r\n            // process macro params\r\n            //\r\n\r\n            const lexer = await this.tokenToLexer(lineToken);\r\n\r\n            let token: IToken = lexer.getNextToken();\r\n\r\n            const bOpenBracket = token.value === '(';\r\n            const bSameLine = token.loc.start.line === name.loc.end.line;\r\n            const bNoSpace = token.loc.start.column === name.loc.end.column;\r\n\r\n            // A bit tricky way to separate macro like:\r\n            // >  #define NAME(A, B)\r\n            // from the macro:\r\n            // >  #define NAME (A, B)\r\n            // and macro like:\r\n            // >  #define NAME\\\r\n            // >              (A, B)\r\n\r\n            // note: only macro like 'NAME(a, b)' is a valid function-like macro (no spaces allowed)\r\n\r\n            if (bOpenBracket && bSameLine && bNoSpace) {\r\n                params = [];\r\n                bFunction = true;\r\n                let bExpectComma = false;\r\n                token = lexer.getNextToken();\r\n                while (token.name !== END_SYMBOL && token.value !== ')') {\r\n                    if (bExpectComma) {\r\n                        if (token.value !== ',') {\r\n                            this.emitMacroError(`invalid macro, comma expected`, token.loc);\r\n                            return null;\r\n                        }\r\n                    } else {\r\n                        if (token.name !== T_NON_TYPE_ID) {\r\n                            this.emitMacroError('invalid token found. only identifiers allowed as param names', token.loc);\r\n                            return null;\r\n                        }\r\n                        params.push(token.value);\r\n                    }\r\n\r\n                    bExpectComma = !bExpectComma;\r\n                    token = lexer.getNextToken();\r\n                }\r\n\r\n                if (token.name === END_SYMBOL) {\r\n                    this.emitMacroError(`comma mismatch`, token.loc);\r\n                    return null;\r\n                }\r\n\r\n                token = lexer.getNextToken();\r\n            }\r\n\r\n            while (token.name !== END_SYMBOL) {\r\n                tokens.push(token);\r\n                token = lexer.getNextToken();\r\n            }\r\n        }\r\n        tokens.forEach(t => { (<any>t).synthetic = true; });\r\n        return { name: name.value, tokens, bFunction, params, bRegionExpr };\r\n    }\r\n\r\n\r\n    protected async processIfdefMacro(token: IToken): Promise<IToken> {\r\n        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));\r\n\r\n        if (exprValue) {\r\n            this.macroState.push(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_AllowElse);\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processIfndefMacro(token: IToken): Promise<IToken> {\r\n        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));\r\n\r\n        if (exprValue) {\r\n            this.macroState.push(EMacroState.k_AllowElse);\r\n            return this.skipUnreachableCode(token);\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_ForbidElse);\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async processIfMacro(token: IToken): Promise<IToken> {\r\n        if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {\r\n            this.macroState.push(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.push(EMacroState.k_AllowElse);\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processElifMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (this.macroState.is(EMacroState.k_AllowElse)) {\r\n            if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {\r\n                this.macroState.replace(EMacroState.k_ForbidElse);\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processElseMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        if (this.macroState.is(EMacroState.k_AllowElse)) {\r\n            this.macroState.replace(EMacroState.k_ForbidElse);\r\n            return this.readToken();\r\n        }\r\n\r\n        return this.skipUnreachableCode(token);\r\n    }\r\n\r\n\r\n    protected async processEndifMacro(token: IToken): Promise<IToken> {\r\n        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {\r\n            this.emitMacroError(`inappropriate control instruction found`, token.loc);\r\n            return this.readToken();\r\n        }\r\n\r\n        this.macroState.pop();\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected resolveDefMacro(lexer: ILexer): number {\r\n        const macros = this.macros;\r\n\r\n        const asRaw = (token: IToken): number => tokenToNative(token, ({ value }) => {\r\n            const macro = macros.get(value);\r\n            if (macro) {\r\n                // mark macro as a part of ifdef/else expression\r\n                macro.bRegionExpr = true;\r\n                return 1;\r\n            }\r\n            this.addUnresolvedMacro(value);\r\n            return 0;\r\n        });\r\n        const asFn = asMacroFunc;\r\n        const asValue = asFn(asRaw);\r\n\r\n        const opPriors = {\r\n            '(': 1, ')': 1,\r\n            '&&': 2,\r\n            '||': 3,\r\n            '!': 8\r\n        };\r\n\r\n        const opLogic = {\r\n            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),\r\n            '||': asFn((a, b) => asRaw(a) || asRaw(b)),\r\n            '!': asFn((a) => !asRaw(a)),\r\n            'asValue': asValue\r\n        };\r\n\r\n        const exprValue = this.evaluateMacroExpr(lexer, opPriors, opLogic, {});\r\n        return exprValue;\r\n    }\r\n    \r\n\r\n    protected resolveMacroInner(lexer: ILexer): number {\r\n\r\n        const macros = this.macros;\r\n\r\n        const asRaw = (token: IToken) => this.resolveMacro(token);\r\n        const asFn = asMacroFunc;\r\n        const asValue = asFn(asRaw);\r\n\r\n        const opPriors = {\r\n            '(': 1, ')': 1,\r\n            '||': 2,\r\n            '&&': 3,\r\n            '<': 4, '>': 4, '<=': 4, '>=': 4,\r\n            '==': 5, '!=': 5,\r\n            '+': 6, '-': 6,\r\n            '*': 7, '/': 7,\r\n            '!': 8,\r\n            'defined': 9\r\n        };\r\n\r\n        // TODO: add conditional operator\r\n        // TODO: add unary '+' and unary '-' operators\r\n        const opLogic = {\r\n            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),\r\n            '||': asFn((a, b) => asRaw(a) || asRaw(b)),\r\n            '!': asFn((a) => !asRaw(a)),\r\n            '+': asFn((a, b) => asRaw(a) + asRaw(b)),\r\n            '-': asFn((a, b) => asRaw(a) - asRaw(b)),\r\n            '*': asFn((a, b) => asRaw(a) * asRaw(b)),\r\n            '/': asFn((a, b) => asRaw(a) / asRaw(b)),\r\n            '<': asFn((a, b) => asRaw(a) < asRaw(b)),\r\n            '>': asFn((a, b) => asRaw(a) > asRaw(b)),\r\n            '<=': asFn((a, b) => asRaw(a) <= asRaw(b)),\r\n            '>=': asFn((a, b) => asRaw(a) >= asRaw(b)),\r\n            '==': asFn((a, b) => asRaw(a) === asRaw(b)),\r\n            '!=': asFn((a, b) => asRaw(a) !== asRaw(b)),\r\n            'asValue': asValue\r\n        };\r\n\r\n        //\r\n        // Wrap all macro functions to native \r\n        //\r\n\r\n        const macroFuncs = <IMap<IMacroFunc>>{\r\n            'defined': asFn((a: IToken) => {\r\n                const macro = macros.get(a.value);\r\n                if (macro) {\r\n                    macro.bRegionExpr = true;\r\n                    return 1;\r\n                }\r\n                this.addUnresolvedMacro(a.value);\r\n                return 0;\r\n            }),\r\n        };\r\n\r\n        // TODO: move list construction to preprocess\r\n        macros.forEach((macro: IMacro) => {\r\n            if (macro.bFunction) {\r\n                opPriors[macro.name] = 10;\r\n                macroFuncs[macro.name] = {\r\n                    op: (...args: IToken[]): IToken => {\r\n                        macros.push(macro);\r\n\r\n                        assert(macro.params.length === args.length);\r\n                        const params = macro.params;\r\n\r\n                        for (let i = 0; i < params.length; ++i) {\r\n                            if (DEBUG_MACRO) {\r\n                                console.log(`${macro.name}.${params[i]} => ${args[i].value}`, isString(args[i].value));\r\n                            }\r\n                            macros.set({\r\n                                name: params[i],\r\n                                tokens: [args[i]],\r\n                                bFunction: false,\r\n                                params: null,\r\n                                bRegionExpr: false\r\n                            });\r\n                        }\r\n\r\n                        const value = String(this.resolveMacroInner(this.macroToLexer(macro)));\r\n                        macros.pop();\r\n\r\n                        // TODO: use min/max instead?\r\n                        const loc = util.commonRange(...args.map(arg => arg.loc));\r\n                        return { index: -1, type: ETokenType.k_NumericLiteral, name: 'T_UINT', value, loc };\r\n                    },\r\n\r\n                    length: macro.params.length\r\n                };\r\n            }\r\n        });\r\n\r\n        return this.evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs);\r\n    }\r\n\r\n\r\n    protected resolveMacro(textToken: IToken): number {\r\n        return tokenToNative(textToken, (token) => {\r\n            const macro = this.macros.get(token.value);\r\n            if (!isNull(macro) && !isNull(macro.tokens)) {\r\n                const exprValue = this.resolveMacroInner(this.macroToLexer(macro));\r\n\r\n                if (DEBUG_MACRO) {\r\n                    console.log(`macro '${token.value}:${macro.tokens.map(tk => tk.value).join(' ')}' resolved to '${exprValue}''`);\r\n                }\r\n\r\n                return exprValue;\r\n            }\r\n\r\n            this.emitMacroWarning(`cannot resolve macro '${token.value}'`, textToken.loc);\r\n            this.addUnresolvedMacro(token.value);\r\n\r\n            return NaN;\r\n        });\r\n    }\r\n\r\n\r\n    protected addUnresolvedMacro(name: string): void {\r\n        if (this.unresolvedMacros.find(macro => macro.name === name)) {\r\n            return;\r\n        }\r\n\r\n        this.unresolvedMacros.push({\r\n            bFunction: false,\r\n            name,\r\n            params: null,\r\n            tokens: null,\r\n            bRegionExpr: true\r\n        });\r\n    }\r\n\r\n\r\n    protected evaluateMacroExpr(lexer: ILexer,\r\n        opPriors: IMap<number>,\r\n        opLogic: IMap<IMacroFunc>,\r\n        macroFuncs: IMap<IMacroFunc> = {}): number {\r\n\r\n        const values = <IToken[]>[];\r\n        const opStack = <IToken[]>[];\r\n\r\n        let token: IToken = lexer.getNextToken();\r\n\r\n        //\r\n        // Transform input sequence to reverse Polish notation\r\n        //\r\n\r\n        exit:\r\n        while (true) {\r\n            switch (token.name) {\r\n                case 'T_TYPE_ID':\r\n                case 'T_NON_TYPE_ID':\r\n                    // process functional macros as operators\r\n                    if (macroFuncs[token.value]) {\r\n                        opStack.push(token);\r\n                        break;\r\n                    }\r\n\r\n                    values.push(token);\r\n                    break;\r\n\r\n                case 'T_UINT':\r\n                case 'T_KW_TRUE':\r\n                case 'T_KW_FALSE':\r\n                    values.push(token);\r\n                    break;\r\n                case 'T_PUNCTUATOR_40': // '('\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'T_PUNCTUATOR_41': // ')'\r\n                    {\r\n                        let op = opStack.pop();\r\n                        while (op.value !== '(') {\r\n                            values.push(op);\r\n                            op = opStack.pop();\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'T_PUNCTUATOR_44': // ','\r\n                    // ignoring of all commas\r\n                    break;\r\n                case END_SYMBOL:\r\n                    break exit;\r\n                default:\r\n                    if (opPriors[token.value]) {\r\n                        if (opStack.length) {\r\n                            const thisOp = token.value;\r\n                            const prevOp = opStack[opStack.length - 1].value;\r\n                            assert(opPriors[prevOp] && opPriors[thisOp], prevOp, thisOp);\r\n                            if (opPriors[prevOp] >= opPriors[thisOp]) {\r\n                                values.push(opStack.pop());\r\n                            }\r\n                        }\r\n                        opStack.push(token);\r\n                        break;\r\n                    }\r\n\r\n                    this.emitMacroError(`unsupported macro operator found: '${token.value}'`, token.loc);\r\n                    return NaN;\r\n            }\r\n\r\n            token = lexer.getNextToken();\r\n        }\r\n\r\n        while (opStack.length) {\r\n            values.push(opStack.pop());\r\n        }\r\n\r\n        //\r\n        // Evaluate reverse Polish notation\r\n        //\r\n\r\n        // FIXME: remove debug log\r\n        const $input = `[${values.map(token => token.value).join(', ')}]`;\r\n\r\n        const isOp = (op: IToken): boolean => isDef(opLogic[op.value]);\r\n        const asOp = (op: IToken): IMacroFunc => opLogic[op.value];\r\n        const isFn = (op: IToken): boolean => isDef(macroFuncs[op.value]);\r\n        const asFn = (op: IToken): IMacroFunc => macroFuncs[op.value];\r\n\r\n        const stack: IToken[] = [];\r\n        values.forEach(token => {\r\n            if (isOp(token)) {\r\n                const { op, length } = asOp(token);\r\n                stack.push(op(...stack.splice(-(length))));\r\n                return;\r\n            }\r\n            if (isFn(token)) {\r\n                const { op, length } = asFn(token);\r\n                stack.push(op(...stack.splice(-(length))));\r\n                return;\r\n            }\r\n            stack.push(token);\r\n        });\r\n\r\n        if (values.length === 1) {\r\n            stack[0] = opLogic.asValue.op(stack[0]);\r\n        }\r\n\r\n        if (DEBUG_MACRO) console.log(`${$input} => {${stack[0].value}}`);\r\n        // assert(asMacroNative(stack[0]) !== NaN, stack);\r\n\r\n        return tokenToNative(stack[0]);\r\n    }\r\n\r\n\r\n    protected async processErrorMacro(token: IToken): Promise<IToken> {\r\n        const text = this.readLine();\r\n        const msg = text.value.trim();\r\n        this.emitMacroError(`erroneous macro reached: \"${msg}\"`, util.commonRange(token.loc, text.loc));\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async skipUnreachableCode(startToken: IToken): Promise<IToken> {\r\n        let token: IToken = await this.readToken(false);\r\n        let nesting = 0;\r\n\r\n        while (token.name !== END_SYMBOL) {\r\n            if (token.name === T_MACRO) {\r\n                switch (token.value) {\r\n                    case '#if':\r\n                    case '#ifdef':\r\n                    case '#ifndef':\r\n                        nesting++;\r\n                        this.readLine();\r\n                        break;\r\n                    case '#elif':\r\n                    case '#else':\r\n                        if (nesting !== 0) {\r\n                            this.readLine();\r\n                            break;\r\n                        }\r\n\r\n                    /* fall throught */\r\n                    case '#endif':\r\n                        if (nesting > 0) {\r\n                            nesting--;\r\n                            this.readLine();\r\n                            break;\r\n                        }\r\n\r\n                        this.addUnreachableCode(startToken, token);\r\n                        return this.readMacro(token);\r\n                    case '#error':\r\n                        this.readLine();\r\n                }\r\n            }\r\n\r\n            token = await this.readToken(false);\r\n        }\r\n\r\n        // TODO: highlight open tag\r\n        this.emitMacroError(`'endif' non found :/`, token.loc);\r\n        return token;\r\n    }\r\n\r\n\r\n    protected addUnreachableCode(start: IToken, end: IToken): void {\r\n        const block = { start: { ...start.loc.end, column: 0 }, end: { ...end.loc.end, column: 0 } };\r\n        block.start.line++;\r\n\r\n        if (block.end.line - block.start.line > 0) {\r\n            if (DEBUG_MACRO) {\r\n                console.log(`unreachable code: [${block.start.line}, ${block.end.line})`);\r\n            }\r\n            this.unreachableCodeList.push(block);\r\n        }\r\n    }\r\n\r\n\r\n    protected async processIncludeMacro(token: IToken): Promise<IToken> {\r\n        const file = this.readLine();\r\n        //cuttin qoutes\r\n        const includeURL = file.value.trim().slice(1, -1);\r\n        const resolvedURI = URI.resolve(includeURL, `${token.loc.start.file}`);\r\n        const loc = util.commonRange(token.loc, file.loc);\r\n\r\n        if (this.includeMap.has(resolvedURI)) {\r\n            if (DEBUG_MACRO) {\r\n                const chain = this.includes.map(i => this.stack[i].lexer.document.uri.toString()).map(name => `\\t> ${name}`).join('\\n');\r\n                console.warn(`'${resolvedURI}' file has already been included previously at \"${this.includeMap.get(resolvedURI).start.file}\":\\n${chain}`);\r\n            }\r\n\r\n            // TODO: prevent recursion!\r\n            // // TODO: emit warning\r\n            // return this.readToken();\r\n        }\r\n\r\n        const textDocumentRaw = await this.includeResolver(resolvedURI);\r\n        if (!textDocumentRaw) {\r\n            this.emitFileNotFound(resolvedURI, loc);\r\n            return this.readToken();\r\n        }\r\n        \r\n        // rebuild text document in order to avoid problems if include handler was called through worker\r\n        const { uri, source } = textDocumentRaw;\r\n        const textDocument = await createTextDocument(uri, source);\r\n        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_Include);\r\n\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected emitMacroWarning(msg: string, loc: IRange): void {\r\n        this.diagnostics.warning(EPreprocessorWarnings.MacroUnknownWarning, { ...loc.start/* << FIXME: remove this */, loc, msg });\r\n    }\r\n\r\n\r\n    protected emitMacroError(msg: string, loc: IRange): void {\r\n        this.diagnostics.error(EPreprocessorErrors.MacroUnknownError, { ...loc.start/* << FIXME: remove this */, loc, msg });\r\n    }\r\n\r\n\r\n    protected emitFileNotFound(file: string, loc: IRange) {\r\n        this.diagnostics.error(EPreprocessorErrors.GeneralCouldNotReadFile, { ...loc.start/* << FIXME: remove this */, loc, target: file });\r\n    }\r\n\r\n\r\n    protected async applyMacro(token: IToken): Promise<IMacro> {\r\n        const macros = this.macros;\r\n        const macro = macros.get(token.value);\r\n\r\n        if (!macro) {\r\n            return null;\r\n        }\r\n\r\n        if (macro.bFunction) {\r\n\r\n            const $lexer = this.lexer;\r\n            const pos = this.lexer.getPosition();\r\n\r\n            const nextToken: IToken = await this.readToken();\r\n            if (nextToken.value !== '(') {\r\n                this.emitMacroWarning(`for macro '${macro.name} function call signature is expected'`, token.loc);\r\n\r\n                assert($lexer === this.lexer, 'something went wrong');\r\n                this.lexer.setPosition(pos);\r\n                return null;\r\n            }\r\n\r\n            let readTokens = [nextToken];\r\n            let argRanges = <number[]>[];\r\n\r\n            let argToken: IToken = await this.readToken();\r\n            let bracketDepth = 0;\r\n\r\n            let startPos = 1;\r\n            let endPos = 1;\r\n\r\n            readTokens.push(argToken);\r\n            while (argToken.name !== END_SYMBOL && !(argToken.value === ')' && bracketDepth == 0)) {\r\n                switch (argToken.value) {\r\n                    case '(':\r\n                        bracketDepth++;\r\n                        break;\r\n                    case ')':\r\n                        bracketDepth--;\r\n                        break;\r\n                    case ',':\r\n                        if (bracketDepth === 0) {\r\n                            assert(endPos - startPos > 0);\r\n                            // TODO: emit error\r\n                            if ((endPos - startPos) > 0) {\r\n                                argRanges.push(startPos, endPos);\r\n                            }\r\n                            startPos = endPos + 1;\r\n                        }\r\n                        break;\r\n                }\r\n\r\n                endPos++;\r\n                argToken = await this.readToken();\r\n                readTokens.push(argToken);\r\n            }\r\n\r\n\r\n            if (endPos > startPos) {\r\n                argRanges.push(startPos, endPos);\r\n            }\r\n\r\n            const nArgs = argRanges.length / 2;\r\n\r\n            if (nArgs !== macro.params.length) {\r\n                this.emitMacroError(`macro '${macro.name}' arguments mismatch, expected count is ${macro.params.length} but recived ${nArgs}`, token.loc);\r\n\r\n                assert($lexer === this.lexer, 'something went wrong');\r\n                this.lexer.setPosition(pos);\r\n                return null;\r\n            }\r\n\r\n            {\r\n                const { loc: { start } } = token;\r\n                const { loc: { end } } = argToken;\r\n                this.pushDocument(this.macroToLexer(macro), { start, end }, EPPDocumentFlags.k_Macro, macro);\r\n            }\r\n\r\n            const params = macro.params;\r\n\r\n            for (let i = 0; i < params.length; ++i) {\r\n                const i2 = i * 2;\r\n\r\n                const startPos = argRanges[i2];\r\n                const endPos = argRanges[i2 + 1];\r\n                const start = readTokens[startPos].loc.start;\r\n                const end = readTokens[endPos - 1].loc.end;\r\n                const tokens = readTokens.slice(startPos, endPos);\r\n\r\n                if (DEBUG_MACRO) {\r\n                    console.log(`${macro.name}.${params[i]} => ${tokens.map(tk => tk.value).join(' ')}`);\r\n                }\r\n\r\n                macros.set({\r\n                    name: params[i],\r\n                    tokens,\r\n                    bFunction: false,\r\n                    params: null,\r\n                    bRegionExpr: false\r\n                });\r\n            }\r\n        } else {\r\n            if (DEBUG_MACRO) {\r\n                console.log(`${macro.name} => ${macro.tokens.map(tk => tk.value).join(' ')}`);\r\n            }\r\n            this.pushDocument(this.macroToLexer(macro), token.loc, EPPDocumentFlags.k_Macro, macro);\r\n        }\r\n        return macro;\r\n    }\r\n\r\n    protected async preprocessToString(value: string, includeResolver: IncludeResolver): Promise<string> {\r\n        if (DEBUG_MACRO) {\r\n            console.info('preprocess to string', value);\r\n        }\r\n\r\n        const { knownTypes, macros, diagnostics: diag } = this;\r\n\r\n        const pp = new Preprocessor(this.lexerEngine, { knownTypes, macros, diag, includeResolver });\r\n        pp.setTextDocument(await createTextDocument('://macro', value));\r\n\r\n        let token: IToken = await pp.readToken();\r\n        let raw = null;\r\n        while (token.name !== END_SYMBOL) {\r\n            raw = (raw ? raw + ' ' : '') + token.value;\r\n            token = await pp.readToken();\r\n        }\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`>> \"${raw}\"`);\r\n        }\r\n\r\n        return raw;\r\n    }\r\n\r\n\r\n    // apply \"left'##'right\" operator to value and next token\r\n    protected async applyConcatMacro(left: IToken): Promise<IToken> {\r\n        assert(!this.macros.get(left.value) || !this.macros.get(left.value).bFunction);\r\n\r\n        const right = await this.readToken(false, false);\r\n        assert(right.name !== END_SYMBOL);\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`concat strings: \"${left.value}##${right.value}\"`);\r\n        }\r\n\r\n        const leftRaw = await this.preprocessToString(left.value, this.includeResolver);\r\n        const rightRaw = await this.preprocessToString(right.value, this.includeResolver);\r\n        const raw = `${leftRaw}${rightRaw}`;\r\n\r\n        if (DEBUG_MACRO) {\r\n            console.info(`=> \"${leftRaw}${rightRaw}\"`);\r\n        }\r\n\r\n        const loc = { start: left.loc.start, end: right.loc.end };\r\n\r\n        // multiple concatenation processing: A ## B ## C ##  etc.\r\n        const nextToken: IToken = await this.readToken(false, false);\r\n        if (nextToken.name === T_MACRO_CONCAT) {\r\n            return this.applyConcatMacro(createMacroToken(raw, loc));\r\n        }\r\n\r\n        this.pushToken(nextToken);\r\n\r\n        // we handle it as text document, because all possible macros inside are already resolved\r\n        const pos = left.loc.start;\r\n        const textDocument = await createTextDocument(pos.file, raw, pos);\r\n        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_None);\r\n        return this.readToken();\r\n    }\r\n\r\n\r\n    protected async examMacro(token: IToken): Promise<IToken> {\r\n        const macroProcessing = this.stack[this.stack.length - 1].flags & EPPDocumentFlags.k_Macro;\r\n\r\n        if (macroProcessing) {\r\n            const nextToken: IToken = await this.readToken(false, false);\r\n            if (nextToken.name === T_MACRO_CONCAT) {\r\n                return this.applyConcatMacro(token);\r\n            }\r\n            this.pushToken(nextToken);\r\n        }\r\n\r\n        if (token.name === T_NON_TYPE_ID || token.name === T_TYPE_ID) {\r\n            const macro: IMacro = await this.applyMacro(token);\r\n            if (macro) {\r\n                return this.readToken();\r\n            }\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n\r\n    protected documentToLexer(textDocument: ITextDocument): ILexer {\r\n        const { lexerEngine: engine, knownTypes, lexerOptions: { skipComments } } = this;\r\n        const lexer = new Lexer({ engine, knownTypes, skipComments });\r\n        lexer.setTextDocument(textDocument);\r\n        return lexer;\r\n    }\r\n\r\n\r\n    protected tokensToLexer(tokens: IToken[]): ILexer {\r\n        return new CachingLexer(tokens);\r\n    }\r\n\r\n\r\n    protected macroToLexer(macro: IMacro): ILexer {\r\n        return this.tokensToLexer(macro.tokens);\r\n    }\r\n\r\n\r\n    protected async tokenToLexer(token: IToken): Promise<ILexer> {\r\n        const lexer = new Lexer({ engine: this.lexerEngine, knownTypes: this.knownTypes });\r\n        const uri = token.loc.start.file;\r\n        const source = token.value;\r\n        const offset = token.loc.start;\r\n        lexer.setTextDocument(await createTextDocument(uri, source, offset));\r\n        return lexer;\r\n    }\r\n\r\n\r\n    protected async lineToTokens(lineToken: IToken): Promise<IToken[]> {\r\n        const lexer = await this.tokenToLexer(lineToken);\r\n        let tokens = [];\r\n        let tk = lexer.getNextToken();\r\n        while (tk.name !== END_SYMBOL) {\r\n            tokens.push(tk);\r\n            tk = lexer.getNextToken();\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n\r\n    protected async lineToLexer(lineToken: IToken): Promise<ILexer> {\r\n        return this.tokensToLexer(await this.lineToTokens(lineToken));\r\n    }\r\n\r\n}\r\n\r\nexport interface IPPOptions {\r\n    skipComments?: boolean;\r\n    includeResolver?: IncludeResolver;\r\n    defines?: IKnownDefine[];\r\n}\r\n\r\n// create preprocessed document\r\nexport async function createPPDocument(textDocument: ITextDocument, \r\n        options: IPPOptions = {}): Promise<ITextDocument> {\r\n    // TODO: try to use default lexer: new LexerEngine()\r\n\r\n    const parser = defaultSLParser();\r\n    const { skipComments = true, includeResolver, defines } = options;\r\n    const pp = new Preprocessor(parser.lexerEngine, { skipComments, includeResolver, defines });\r\n    pp.setTextDocument(textDocument);\r\n\r\n    const newline = (from: number, to: number): string => Array(Math.min(to - from, 4)).fill('\\n').join('');\r\n    const padding = (length: number): string => Array(length).fill(' ').join('');\r\n\r\n    let content = '';\r\n    let tokenThis = await pp.readToken();\r\n    while (tokenThis.name !== END_SYMBOL) {\r\n        const doPadding = !content || content.substr(-1) === '\\n';\r\n        const locThis = pp.macroLocation() || tokenThis.loc;\r\n        const macroThis = pp.currentMacro();\r\n\r\n        // padding\r\n        if (doPadding) {\r\n            content += padding(locThis.start.column);// + padding(tokenThis.loc.start.column);\r\n            // note: paddings inside multiline macro are not supported\r\n        }\r\n\r\n        // place content\r\n        content = `${content}${!doPadding ? ' ' : ''}${tokenThis.value}`;\r\n\r\n        const tokenNext = await pp.readToken();\r\n        const locNext = pp.macroLocation() || tokenNext.loc;\r\n\r\n        // newline if new file\r\n        if (locThis.end.file !== locNext.start.file) {\r\n            content += '\\n\\n';\r\n        }\r\n        // newline if new global macro (or just diff lines) on a new line\r\n        else if (locThis.end.line < locNext.start.line) {\r\n            content += newline(locThis.end.line, locNext.start.line);\r\n        }\r\n        // new line if it is a multiline macro\r\n        else if (tokenThis.loc.end.line < tokenNext.loc.start.line && macroThis === pp.currentMacro()) {\r\n            content += newline(tokenThis.loc.end.line, tokenNext.loc.start.line);\r\n        }\r\n\r\n        tokenThis = tokenNext;\r\n    }\r\n\r\n    return createTextDocument(textDocument.uri, content);\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { Item } from \"./Item\";\r\n\r\nexport class State {\r\n    index: number;\r\n    nextStates: IMap<State>;\r\n\r\n    private items: Item[];\r\n    private numBaseItems: number;\r\n    // for debug only\r\n    private numOtherItems: number;\r\n\r\n    constructor() {\r\n        this.nextStates = {};\r\n        this.index = 0;\r\n\r\n        this.items = [];\r\n        this.numBaseItems = 0;\r\n        this.numOtherItems = 0;\r\n    }\r\n\r\n\r\n    eachItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.items.length; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n\r\n    eachBaseItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n    \r\n    isExpected(symbol: string): boolean {\r\n        return !!this.items.find(item => item.isExpected(symbol));\r\n    }\r\n\r\n\r\n    hasItem(value: Item, type: EParserType): Item {\r\n        return this.items.find(item => item.isEqual(value, type)) || null;\r\n    }\r\n\r\n    \r\n    hasParentItem(value: Item): Item {\r\n        return this.items.find(item => item.isParentItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasChildItem(value: Item): Item {\r\n        return this.items.find(item => item.isChildItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasRule(rule: IRule, pos: number): boolean {\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const item = this.items[i];\r\n            if (item.rule === rule && item.pos === pos) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    isEmpty(): boolean {\r\n        return !(this.items.length);\r\n    }\r\n\r\n    \r\n    isEqual(state: State, type: EParserType): boolean {\r\n        if (this.numBaseItems !== state.numBaseItems) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const baseItemA = this.items[i];\r\n\r\n            let isEqual = false;\r\n            for (let i = 0; i < state.numBaseItems; ++i) {\r\n                const baseItemB = state.items[i];\r\n                if (baseItemA.isEqual(baseItemB, type)) {\r\n                    isEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isEqual) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    push(item: Item): void {\r\n        if (this.items.length === 0 || item.pos > 0) {\r\n            assert(this.numOtherItems === 0);\r\n            this.numBaseItems++;\r\n        } else {\r\n            this.numOtherItems++;\r\n        }\r\n        this.items.push(item);\r\n    }\r\n\r\n\r\n    tryPush_LR0(rule: IRule, pos: number): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return false;\r\n        }\r\n\r\n        const item = new Item(rule, pos);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n\r\n    tryPush_LR(rule: IRule, pos: number, expectedSymbol: string): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return sameItem.addExpected(expectedSymbol);\r\n        }\r\n\r\n        const item = new Item(rule, pos, [expectedSymbol]);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n    \r\n    addNextState(symbol: string, state: State): boolean {\r\n        if (this.nextStates[symbol]) {\r\n            return false;\r\n        }\r\n\r\n        this.nextStates[symbol] = state;\r\n        return true;\r\n    }\r\n\r\n    \r\n    deleteNotBase(): void {\r\n        this.items.length = this.numBaseItems;\r\n    }\r\n\r\n    \r\n    toString(isBase: boolean = true, grammarSymbols: Map<string, string> = null): string {\r\n        const items = isBase? this.items.slice(0, this.numBaseItems) : this.items;\r\n        return `State ${this.index}:\\n` +\r\n            items.map(item => `\\t\\t${item.toString(grammarSymbols)}\\n`).join();\r\n    }\r\n}\r\n","export const END_POSITION               = 'END';                 // item, parser\r\nexport const T_EMPTY                    = 'EMPTY';               // item, parser\r\nexport const UNKNOWN_TOKEN              = 'UNKNOWN';             // lexer\r\nexport const START_SYMBOL               = 'S';                   // parser\r\nexport const UNUSED_SYMBOL              = '##';                  // parser\r\nexport const INLINE_COMMENT_SYMBOL      = '#';                   // parser\r\n// TODO: do not use ambigious name 'ERROR'\r\nexport const ERROR                      = 'ERROR';               // parser\r\nexport const END_SYMBOL                 = '$';                   // lexer, parser\r\nexport const LEXER_RULES                = '--LEXER--';           // parser\r\nexport const FLAG_RULE_CREATE_NODE      = '--add';                // parser\r\nexport const FLAG_RULE_SKIP_NODE        = '--skip';              // parser\r\nexport const FLAG_RULE_EXPOSE_NODE      = '--expose';            // parser\r\nexport const FLAG_RULE_FUNCTION         = '--F';                 // parser\r\nexport const EOF                        = 'EOF';                 // lexer\r\nexport const T_STRING                   = 'T_STRING';            // lexer\r\nexport const T_FLOAT                    = 'T_FLOAT';             // lexer\r\nexport const T_UINT                     = 'T_UINT';              // lexer\r\nexport const T_TYPE_ID                  = 'T_TYPE_ID';           // lexer\r\nexport const T_NON_TYPE_ID              = 'T_NON_TYPE_ID';       // lexer\r\nexport const T_LINE_TERMINATOR          = 'T_LINE_TERMINATOR';   // lexer\r\n\r\nexport const T_MACRO                    = 'T_MACRO';             // lexer '#define', '#ifdef' etc.\r\nexport const T_MACRO_CONCAT             = 'T_MACRO_CONCAT';      // lexer '##'\r\n","import { assert } from \"@lib/common\";\r\nimport { IPosition, IRange } from \"@lib/idl/parser/IParser\";\r\n\r\nexport function positionMin(a: IPosition, b: IPosition): IPosition {\r\n    assert(a.file === b.file);\r\n    return {\r\n        offset: Math.min(a.offset, b.offset),\r\n        line: Math.min(a.line, b.line),\r\n        column: Math.min(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\nexport function positionMax(a: IPosition, b: IPosition): IPosition {\r\n    assert(a.file === b.file);\r\n    return {\r\n        offset: Math.max(a.offset, b.offset),\r\n        line: Math.max(a.line, b.line),\r\n        column: Math.max(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\n\r\nexport function cloneRange(range: IRange): IRange {\r\n    return { start: { ...range.start }, end: { ...range.end } };\r\n}\r\n\r\n// export function extendRange(parent: IRange, child: IRange): IRange {\r\n//     if (child.start.file !== parent.start.file) {\r\n//         return parent;\r\n//     }\r\n\r\n//     assert(parent.end.file === child.end.file);\r\n\r\n//     if (child.start.line < parent.start.line) {\r\n        \r\n//         parent.start.column = child.start.column;\r\n//         parent.start.line = child.start.line;\r\n//         parent.start.file = child.start.file;\r\n//         parent.start.offset = child.start.offset;\r\n\r\n//     } else if (child.start.line === parent.start.line) {\r\n//         // parent.start = positionMin(child.start, parent.start);\r\n\r\n//         parent.start.column = Math.min(child.start.column, parent.start.column);\r\n//         parent.start.line = Math.min(child.start.line, parent.start.line);\r\n//         parent.start.offset = Math.min(child.start.offset, parent.start.offset);\r\n//     }\r\n\r\n//     if (child.end.line > parent.end.line) {\r\n\r\n//         parent.end.column = child.end.column;\r\n//         parent.end.line = child.end.line;\r\n//         parent.end.file = child.end.file;\r\n//         parent.end.offset = child.end.offset;\r\n\r\n//     } else if (child.end.line === parent.end.line) {\r\n//         // parent.end = positionMax(child.end, parent.end);\r\n\r\n//         parent.end.column = Math.max(child.end.column, parent.end.column);\r\n//         parent.end.line = Math.max(child.end.line, parent.end.line);\r\n//         parent.end.offset = Math.max(child.end.offset, parent.end.offset);\r\n//     }\r\n\r\n//     return parent;\r\n// }\r\n\r\nexport function extendRange(parent: IRange, child: IRange): IRange {\r\n    if (child.start.file !== parent.start.file) {\r\n        return parent;\r\n    }\r\n\r\n    if (child.start.line < parent.start.line) {\r\n        parent.start = { ...child.start };\r\n    } else if (child.start.line === parent.start.line) {\r\n        parent.start = positionMin(child.start, parent.start);\r\n    }\r\n\r\n    if (child.end.line > parent.end.line) {\r\n        parent.end = { ...child.end };\r\n    } else if (child.end.line === parent.end.line) {\r\n        parent.end = positionMax(child.end, parent.end);\r\n    }\r\n\r\n    return parent;\r\n}\r\n\r\nexport function commonRange(...rangeList: IRange[]): IRange {\r\n    const MAX_I32 = Number.MAX_SAFE_INTEGER;\r\n    const MIN_I32 = Number.MIN_SAFE_INTEGER;\r\n\r\n    const file = rangeList[0].start.file;\r\n\r\n    let start: IPosition = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };\r\n    let end: IPosition = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };\r\n\r\n    rangeList.forEach(range => start = positionMin(start, range.start));\r\n    rangeList.forEach(range => end = positionMax(end, range.end));\r\n\r\n    return { start, end };\r\n}\r\n\r\nexport function offset(source: IRange, offset: IPosition): IRange {\r\n    if (offset) {\r\n        // TODO: check that URIs the same\r\n        const { start, end } = source;\r\n\r\n        if (start.line === 0) {\r\n            start.column += offset.column;\r\n        }\r\n\r\n        if (end.line === 0) {\r\n            end.column += offset.column;\r\n        }\r\n\r\n        start.line += offset.line;\r\n        end.line += offset.line;\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\nexport const checkRange = (range: IRange, offset: number) => range.start.offset <= offset && range.end.offset > offset;\r\n\r\n// export function stringifyRange(range: IRange, depth = 0) {\r\n//     if (!range) {\r\n//         return '';\r\n//     }\r\n\r\n//     const offset = Array(depth).fill('---').join('') + (depth? ' ' : '');\r\n//     const { start, end, source } = range;\r\n//     const filename = String(start.file).split('/').reverse()[0];\r\n//     return `${offset}${filename}:${start.line}:${start.column}-${end.line}:${end.column}\\n${stringifyRange(source, depth + 1)}`;\r\n// } \r\n","import { isString, isDef, isNull } from \"../common\";\r\n\r\nclass Pathinfo {\r\n    private _dirname: string = null;\r\n    private _extension: string = null;\r\n    private _filename: string = null;\r\n\r\n    get path(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    set path(path: string) {\r\n        this.set(path);\r\n    }\r\n\r\n    get dirname(): string {\r\n        return this._dirname;\r\n    }\r\n\r\n    set dirname(dirname: string) {\r\n        this._dirname = dirname;\r\n    }\r\n\r\n    get filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    set filename(filename: string) {\r\n        this._filename = filename;\r\n    }\r\n\r\n    get ext(): string {\r\n        return this._extension;\r\n    }\r\n\r\n    set ext(extension: string) {\r\n        this._extension = extension;\r\n    }\r\n\r\n    get basename(): string {\r\n        return (this._filename ? this._filename + (this._extension ? \".\" + this._extension : \"\") : \"\");\r\n    }\r\n\r\n    set basename(basename: string) {\r\n        var nPos: number = basename.lastIndexOf(\".\");\r\n\r\n        if (nPos < 0) {\r\n            this._filename = basename.substr(0);\r\n            this._extension = null;\r\n        }\r\n        else {\r\n            this._filename = basename.substr(0, nPos);\r\n            this._extension = basename.substr(nPos + 1);\r\n        }\r\n    }\r\n\r\n\r\n    constructor(path: Pathinfo);\r\n    constructor(path: string);\r\n    constructor(path?: any) {\r\n        if (isDef(path)) {\r\n            this.set(<string>path);\r\n        }\r\n    }\r\n\r\n\r\n    set(path: string): void;\r\n    set(path: Pathinfo): void;\r\n    set(path?: any) {\r\n        if (isString(path)) {\r\n            var pParts: string[] = path.replace('\\\\', '/').split('/');\r\n\r\n            this.basename = (pParts.pop());\r\n\r\n            this._dirname = pParts.join('/');\r\n        }\r\n        else if (path instanceof Pathinfo) {\r\n            this._dirname = path.dirname;\r\n            this._filename = path.filename;\r\n            this._extension = path.ext;\r\n        }\r\n        else if (isNull(path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            //critical_error\r\n            throw new Error(`Unexpected data type was used: ${path}`);\r\n        }\r\n    }\r\n\r\n    replaceExt(ext: string): Pathinfo\r\n    {\r\n        this.ext = ext;\r\n        return this;\r\n    }\r\n\r\n    isAbsolute(): boolean { return !!(this._dirname?.[0] === \"/\"); }\r\n\r\n\r\n    toString(): string {\r\n        return (this._dirname ? this._dirname + \"/\" : \"\") + (this.basename);\r\n    }\r\n}\r\n\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n        var last = parts[i];\r\n        if (last === '.') {\r\n            parts.splice(i, 1);\r\n        } else if (last === \"..\") {\r\n            parts.splice(i, 1);\r\n            up++;\r\n        } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n        }\r\n    }\r\n\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n        for (; up--;) {\r\n            parts.unshift(\"..\");\r\n        }\r\n    }\r\n\r\n    return parts;\r\n}\r\n\r\n\r\nexport function normalize(path: string): string {\r\n    var info: Pathinfo = parse(path);\r\n    var isAbsolute: boolean = info.isAbsolute();\r\n    var tail: string = info.dirname;\r\n    var trailingSlash: boolean = /[\\\\\\/]$/.test(tail);\r\n\r\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/).filter(function (p) {\r\n        return !!p;\r\n    }), !isAbsolute).join(\"/\");\r\n\r\n    if (tail && trailingSlash) {\r\n        tail += \"/\";\r\n    }\r\n\r\n    info.dirname = ((isAbsolute ? \"/\" : \"\") + tail);\r\n\r\n    return info.toString();\r\n}\r\n\r\nexport function parse(path: Pathinfo): Pathinfo;\r\nexport function parse(path: string): Pathinfo;\r\nexport function parse(path?): Pathinfo {\r\n    return new Pathinfo(path);\r\n}\r\n\r\nexport function dirname(path: string)\r\n{\r\n    return parse(path).dirname;\r\n}\r\n\r\nexport function ext(path)\r\n{\r\n    return parse(path).ext;\r\n}\r\n","import { isString, isNull, isDef } from \"../common\";\r\nimport * as path from \"../path/path\"\r\nimport { IDataURI } from \"../idl/IDataURI\";\r\n\r\nclass URI {\r\n    private _scheme: string = null;\r\n    private _userinfo: string = null;\r\n    private _host: string = null;\r\n    private _port: number = 0;\r\n    private _path: string = null;\r\n    private _query: string = null;\r\n    private _fragment: string = null;\r\n\r\n    get urn(): string {\r\n        return (this._path ? this._path : \"\") +\r\n            (this._query ? '?' + this._query : \"\") +\r\n            (this._fragment ? '#' + this._fragment : \"\");\r\n    }\r\n\r\n    get url(): string {\r\n        return (this._scheme ? this._scheme + '//' : \"\") + this.authority;\r\n    }\r\n\r\n    get authority(): string {\r\n        return (this._host ? (this._userinfo ? this._userinfo + '@' : \"\") +\r\n            this._host + (this._port ? ':' + this._port : \"\") : \"\");\r\n    }\r\n\r\n    get scheme(): string {\r\n        return this._scheme;\r\n    }\r\n\r\n    get protocol(): string {\r\n        if (!this._scheme) {\r\n            return this._scheme;\r\n        }\r\n\r\n        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));\r\n    }\r\n\r\n    get userInfo(): string {\r\n        return this._userinfo;\r\n    }\r\n\r\n    get host(): string {\r\n        return this._host;\r\n    }\r\n\r\n    set host(sHost: string) {\r\n        //TODO: check host format\r\n        this._host = sHost;\r\n    }\r\n\r\n    get port(): number {\r\n        return this._port;\r\n    }\r\n\r\n    set port(iPort: number) {\r\n        this._port = iPort;\r\n    }\r\n\r\n    get path(): string {\r\n        return this._path;\r\n    }\r\n\r\n    set path(sPath: string) {\r\n        // debug_assert(!isNull(sPath.match(new RegExp(\"^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$\"))), \r\n        //     \"invalid path used: \" + sPath);\r\n        //TODO: check path format\r\n        this._path = sPath;\r\n    }\r\n\r\n    get query(): string {\r\n        //TODO: check query format\r\n        return this._query;\r\n    }\r\n\r\n    set query(sQuery: string) {\r\n        this._query = sQuery;\r\n    }\r\n\r\n    get fragment(): string {\r\n        return this._fragment;\r\n    }\r\n\r\n\r\n    constructor(uri: URI);\r\n    constructor(uri: string);\r\n    constructor(uri?) {\r\n        if (uri) {\r\n            this.set(uri);\r\n        }\r\n    }\r\n\r\n    set(uri: URI);\r\n    set(uri: string);\r\n    set(data?): URI {\r\n        if (isString(data)) {\r\n            var uri: RegExpExecArray = URI.uriExp.exec(<string>data);\r\n\r\n            console.assert(uri !== null, 'Invalid URI format used.\\nused uri: ' + data);\r\n\r\n            if (!uri) {\r\n                return null;\r\n            }\r\n\r\n            this._scheme = uri[1] || null;\r\n            this._userinfo = uri[2] || null;\r\n            this._host = uri[3] || null;\r\n            this._port = parseInt(uri[4]) || null;\r\n            this._path = uri[5] || uri[6] || null;\r\n            this._query = uri[7] || null;\r\n            this._fragment = uri[8] || null;\r\n\r\n            return this;\r\n\r\n        }\r\n        else if (data instanceof URI) {\r\n            return this.set(data.toString());\r\n        }\r\n\r\n        console.error('Unexpected data type was used.');\r\n\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.url + this.urn;\r\n    }\r\n\r\n    //------------------------------------------------------------------//\r\n    //----- Validate a URI -----//\r\n    //------------------------------------------------------------------//\r\n    //- The different parts are kept in their own groups and can be recombined\r\n    //  depending on the scheme:\r\n    //  - http as $1://$3:$4$5?$7#$8\r\n    //  - ftp as $1://$2@$3:$4$5\r\n    //  - mailto as $1:$6?$7\r\n    //- groups are as follows:\r\n    //  1   == scheme\r\n    //  2   == userinfo\r\n    //  3   == host\r\n    //  4   == port\r\n    //  5,6 == path (5 if it has an authority, 6 if it doesn't)\r\n    //  7   == query\r\n    //  8   == fragment\r\n\r\n\r\n    private static uriExp: RegExp = new RegExp(\"^([a-z0-9+.-]+:)?(?:\\\\/\\\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\\\d*))?(\\\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$\", \"i\");\r\n\r\n    /*\r\n     composed as follows:\r\n     ^\r\n     ([a-z0-9+.-]+):                            #scheme\r\n     (?:\r\n     //                            #it has an authority:\r\n     (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?    #userinfo\r\n     ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)        #host\r\n     (?::(\\d*))?                        #port\r\n     (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     |\r\n     #it doesn't have an authority:\r\n     (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     )\r\n     (?:\r\n     \\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #query string\r\n     )?\r\n     (?:\r\n     #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #fragment\r\n     )?\r\n     $\r\n     */\r\n}\r\n\r\n\r\nfunction normalizeURIPath(file: URI): URI {\r\n    if (!isNull(file.path)) {\r\n        if (file.scheme === \"filesystem:\") {\r\n            var uri = parse(file.path);\r\n\r\n            uri.path = path.normalize(uri.path);\r\n            file.path = uri.toString();\r\n        }\r\n        else {\r\n            file.path = path.normalize(file.path);\r\n        }\r\n    }\r\n\r\n    return file;\r\n}\r\n\r\n\r\n\r\nexport function resolve(from: string, to: string = document.location.href): string {\r\n    var currentPath = parse(to);\r\n    var file = parse(from);\r\n    var dirname: string;\r\n\r\n    normalizeURIPath(file);\r\n    normalizeURIPath(currentPath);\r\n\r\n    if (!isNull(file.scheme) || !isNull(file.host) || path.parse(file.path).isAbsolute()) {\r\n        //another server or absolute path\r\n        return from;\r\n    }\r\n\r\n    dirname = path.parse(currentPath.path).dirname;\r\n    currentPath.path = dirname ? (dirname + \"/\" + from) : from;\r\n\r\n    return normalizeURIPath(currentPath).toString();\r\n}\r\n\r\n\r\nexport function parseDataURI(uri: string): IDataURI {\r\n    var re: RegExp = /^data:([\\w\\d\\-\\/]+)?(;charset=[\\w\\d\\-]*)?(;base64)?,(.*)$/;\r\n    var m: string[] = uri.match(re);\r\n\r\n    return {\r\n        //like [text/plain]\r\n        mediatype: m[1] || null,\r\n        //like [;charset=windows-1251]\r\n        charset: isString(m[2]) ? m[2].substr(9) : null,\r\n        //like [;base64]\r\n        base64: isDef(m[3]),\r\n        data: m[4] || null\r\n    };\r\n}\r\n\r\n\r\nexport function parse(uri: string | URI): URI {\r\n    return new URI(String(uri));\r\n}\r\n\r\n\r\nexport function currentScript(): HTMLScriptElement {\r\n    if (isDef(document['currentScript'])) {\r\n        return <HTMLScriptElement>document['currentScript'];\r\n    }\r\n\r\n    var scripts: HTMLCollectionOf<HTMLScriptElement> = document.getElementsByTagName(\"script\");\r\n    return scripts[scripts.length - 1];\r\n}\r\n\r\n\r\nexport function currentPath(): string {\r\n    var uri = parse(currentScript().src);\r\n    let dirname = path.parse(uri.path).dirname;\r\n    return uri.url + dirname + \"/\";\r\n}\r\n\r\n\r\nexport function here(): URI {\r\n    return new URI(document.location.href);\r\n}\r\n\r\n\r\nexport function fromLocalPath(filepath: string | ReturnType<typeof path.parse>) {\r\n    return `file:///${String(filepath).replaceAll('\\\\', '/')}`;\r\n}\r\n\r\nexport function toLocalPath(uri: string | URI): string {\r\n    return parse(uri).path?.substring(1) || '';\r\n}\r\n","import { isString } from \"@lib/common\";\r\nimport { EDiagnosticCategory, IDiagnosticEntry, IDiagnosticMessage, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\n\r\nimport { IMap } from \"../idl/IMap\";\r\nimport { IPosition, IRange } from \"../idl/parser/IParser\";\r\n\r\nfunction locToString(loc: IPosition) {\r\n    return `${loc.line},${loc.column}`;\r\n}\r\n\r\n\r\nfunction rangeToString(range: IRange) {\r\n    return `${locToString(range.start)}:${locToString(range.end)}`;\r\n}\r\n\r\n\r\nfunction readKey(desc: Object, key: string) {\r\n    let keyParts: string[] = key.split('.');\r\n    if (keyParts.length > 1) {\r\n        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));\r\n    }\r\n    return desc[keyParts[0]];\r\n}\r\n\r\n\r\nfunction fillPattern(pattern: string, desc: Object): string {\r\n    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {\r\n        return readKey(desc, key);\r\n    });\r\n}\r\n\r\nexport class DiagnosticException<DESC_T> extends Error {\r\n    host: Diagnostics<DESC_T>;\r\n\r\n    constructor(host: Diagnostics<DESC_T>, mesg: IDiagnosticMessage) {\r\n        super(mesg.content);\r\n        Error.captureStackTrace(this, DiagnosticException);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Diagnostics <DESC_T>{\r\n    protected _name: string;\r\n    protected _codePrefix: string;\r\n    protected _entries: IDiagnosticEntry<DESC_T>[];\r\n\r\n    constructor(name: string, codePrefix: string) {\r\n        this._name = name;\r\n        this._codePrefix = (codePrefix || '').toUpperCase();\r\n        this.reset();\r\n    }\r\n\r\n    protected emitException(): void {\r\n        throw new DiagnosticException<DESC_T>(this, this.getLastError());\r\n    }\r\n\r\n    reset() {\r\n        this._entries = [];\r\n    }\r\n\r\n    resolve(): IDiagnosticReport {\r\n        let report: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        for (let entry of this._entries) {\r\n            let message = this.resolveEntry(entry);\r\n\r\n            switch(message.category) {\r\n                case EDiagnosticCategory.k_Warning:\r\n                    report.warnings ++;\r\n                    break;\r\n                case EDiagnosticCategory.k_Error:\r\n                    report.errors ++;\r\n                    break;\r\n            }\r\n            report.messages.push(message);\r\n        }\r\n\r\n        return report;\r\n    }\r\n\r\n    private resolveEntry(entry: IDiagnosticEntry<DESC_T>): IDiagnosticMessage {\r\n        // let { category, desc } = entry;\r\n\r\n        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();\r\n        let loc: string = null;\r\n        let range: IRange;\r\n        let start: IPosition;\r\n        let end: IPosition;\r\n        let file = this.resolveFilename(entry.category, entry.code, entry.desc);\r\n\r\n        if (range = this.resolveRange(entry.category, entry.code, entry.desc)) {\r\n            ({ start, end } = range);\r\n            loc = rangeToString(range);\r\n        } \r\n        else {\r\n            start = this.resolvePosition(entry.category, entry.code, entry.desc);\r\n            loc = locToString(start);\r\n        }\r\n\r\n        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;\r\n        let code = `${this._codePrefix}${entry.code}`;\r\n        let category = entry.category;\r\n        return { code, category, content, file, start, end };\r\n    }\r\n\r\n    protected resolveFilename(category: EDiagnosticCategory, code: number, desc: DESC_T): string {\r\n        return '[unknown]';\r\n    }\r\n\r\n    protected resolvePosition(category: EDiagnosticCategory, code: number, desc: DESC_T): IPosition {\r\n        return { file: null, line: 0, column: 0 };\r\n    }\r\n\r\n    protected resolveRange(category: EDiagnosticCategory, code: number, desc: DESC_T): IRange {\r\n        return null;\r\n    }\r\n\r\n    protected resolveDescription(code:number, category: EDiagnosticCategory, desc: DESC_T): string {\r\n        let diagMesgs = this.diagnosticMessages();\r\n        if (!diagMesgs) {\r\n            console.error(`Diagnostic messages of '${this._name}' not found.`);\r\n            return '[no description found]';\r\n        }\r\n\r\n        if (!diagMesgs[code]) {\r\n            return `[no description found for code '${code}']`;\r\n        }\r\n\r\n        if (isString(diagMesgs[code])) {\r\n            return fillPattern(<string>diagMesgs[code], desc);\r\n        }\r\n\r\n        return (<((desc: DESC_T) => string)>diagMesgs[code])(desc);\r\n    }\r\n\r\n    protected diagnosticMessages(): IMap<string | ((desc: DESC_T) => string)> {\r\n        return null;\r\n    }\r\n\r\n    error(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Error, code, desc });\r\n    }\r\n\r\n    warning(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Warning, code, desc });\r\n    }\r\n\r\n    // add error and emit an exception in order to interrupt processing\r\n    critical(code: number, desc: DESC_T) {\r\n        this.error(code, desc);\r\n        this.emitException();\r\n    }\r\n\r\n    prettyPrint(): string {\r\n        return null;//JSON.stringify(this._errors, null, '\\t');\r\n    }\r\n\r\n    hasErrors(): boolean {\r\n        return this._entries.filter(entry => entry.category === EDiagnosticCategory.k_Error).length > 0;\r\n    }\r\n\r\n    getLastError(): IDiagnosticMessage {\r\n        for (let i = this._entries.length - 1; i >= 0; --i) {\r\n            if (this._entries[i].category === EDiagnosticCategory.k_Error) {\r\n                return this.resolveEntry(this._entries[i]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this._entries.length === 0;\r\n    }\r\n\r\n    static mergeReports(reportList: IDiagnosticReport[]): IDiagnosticReport {\r\n        let result: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        reportList.forEach((report) => {\r\n            if (!report) return;\r\n            result.errors += report.errors;\r\n            result.warnings += report.warnings;\r\n            result.messages = result.messages.concat(report.messages);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    static stringify(report: IDiagnosticReport): string {\r\n        return report.messages.map(mesg => mesg.content).join('\\n');\r\n    }\r\n\r\n    static asRange(mesg: IDiagnosticMessage): IRange {\r\n        let range: IRange = { start: mesg.start, end: mesg.end };\r\n\r\n        if (!range.end) {\r\n            range.end = { ...range.start };\r\n        }\r\n\r\n        const { start, end } = range;\r\n\r\n        if (end.line == start.line && end.column == start.column) {\r\n            end.column +=1;\r\n        }\r\n\r\n        return range;\r\n    }\r\n}","import { isString } from \"@lib/common\";\r\n\r\n// helper class to always pass strings by pointer and not by value;\r\nexport class StringRef {\r\n    constructor(readonly content: string) {\r\n\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toSource(): string {\r\n        return this.content;\r\n    }\r\n\r\n    static make(val: string | StringRef): StringRef {\r\n        if (!val) {\r\n            return null;\r\n        }\r\n\r\n        if (!isString(val)) {\r\n            if (val instanceof StringRef)\r\n                return <StringRef>val;\r\n            // IP: sometimes it can be useful to restore string ref after worker transfer and so on\r\n            if (isString(val['content']))\r\n                return StringRef.make(val['content']);\r\n        }\r\n\r\n        const sval = val as string;\r\n        \r\n        let ref = StringRef.storage[sval];\r\n        if (ref) {\r\n            return ref;\r\n        }\r\n\r\n        ref = new StringRef(sval);\r\n        StringRef.storage[sval] = ref;\r\n        return ref;\r\n    }\r\n\r\n    static storage: { [val: string]: StringRef; } = {};\r\n}\r\n\r\n","\r\nexport function isNull(x) { return x === null; }\r\nexport function isDef(x) { return x !== undefined; }\r\nexport function isDefAndNotNull(x) { return x != null; }\r\nexport function isString(x) { return typeof x === 'string'; }\r\nexport function isFunction(fn) { return typeof fn === \"function\"; }\r\nexport function isBoolean(x) { return x === !!x; }\r\nexport function isArray(x) { return typeof x === \"object\" && x instanceof Array; }\r\nexport function isObject(x) { return typeof x === \"object\" && x !== null && !isArray(x); }\r\nexport function isNumber(x) { return typeof x === \"number\"; }\r\nexport function isEmpty(x: any) {\r\n    if (x == null) {\r\n        return true;\r\n    }\r\n\r\n    if (typeof x !== \"object\") {\r\n        return false;\r\n    }\r\n\r\n    for (let key in x) {\r\n        if (x.hasOwnProperty(key)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function clone (obj: any): any {\r\n    var copy;\r\n\r\n    // Handle the 3 simple types, and null or undefined\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n\r\n    // Handle Array\r\n    if (obj instanceof Array) {\r\n        copy = [];\r\n        for (var i = 0, len = obj.length; i < len; i++) {\r\n            copy[i] = clone(obj[i]);\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    // Handle Object\r\n    if (obj instanceof Object) {\r\n        copy = {};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    throw new Error(\"Unable to copy obj! Its type isn't supported.\");\r\n}","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: \"RELEASE\" /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: \"GET\" /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: \"SET\" /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: \"ENDPOINT\" /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"APPLY\" /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"CONSTRUCT\" /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { createDefaultSLParser } from '@lib/fx/SLParser';\r\nimport { EDiagnosticCategory, IDiagnosticMessage } from '@lib/idl/IDiagnostics';\r\nimport { ILanguageService } from '@lib/idl/ILanguageService';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IncludeResolver, IParserParams, IRange } from '@lib/idl/parser/IParser';\r\nimport { getLanguageService } from '@lib/language-service/LanguageService';\r\nimport { IKnownDefine } from '@lib/parser/Preprocessor';\r\nimport * as Comlink from 'comlink';\r\nimport { CodeLens, Diagnostic, DiagnosticSeverity, Position, Range, SignatureHelp, TextDocument, TextDocumentIdentifier } from 'vscode-languageserver-types';\r\n\r\n/* tslint:disable:typedef */\r\n/* tslint:disable:no-empty */\r\n/* tslint:disable:forin */\r\n/* tslint:disable:no-for-in */\r\n\r\n// supress all console messages for debugging/development purposes\r\n// import NULL_LOGGER from '@lib/util/NullLogger';\r\n// console = <any>NULL_LOGGER;\r\n\r\n\r\nfunction asTextDocument({ _content, _languageId, _lineOffsets, _uri, _version }): TextDocument {\r\n    return TextDocument.create(_uri, _languageId, _version, _content);\r\n}\r\n\r\n\r\nfunction asDiagnostic(diagEntry: IDiagnosticMessage): Diagnostic {\r\n    const { code, content, start, end, category } = diagEntry;\r\n\r\n    const severities = {\r\n        [EDiagnosticCategory.k_Error]: DiagnosticSeverity.Error,\r\n        [EDiagnosticCategory.k_Warning]: DiagnosticSeverity.Warning\r\n    };\r\n\r\n    return {\r\n        range: Range.create(start.line, start.column, (end || start).line, (end || start).column),\r\n        severity: severities[category],\r\n        code,\r\n        message: content,\r\n        source: `${start.file}`\r\n    };\r\n}\r\n\r\nfunction resolveLocation(src: IRange, slastDocument: ISLASTDocument): IRange {\r\n    if (!slastDocument) {\r\n        return null;\r\n    }\r\n\r\n    const { includes, uri } = slastDocument;\r\n    let dst = src;\r\n    while (dst && String(uri) !== String(dst.start.file)) {\r\n        dst = includes.get(String(dst.start.file));\r\n    }\r\n    return dst;\r\n}\r\n\r\n\r\ninterface IDocumentCacheEntry {\r\n    textDocument: TextDocument;\r\n    slastDocument: ISLASTDocument;\r\n    slDocument: ISLDocument;\r\n}\r\n\r\nclass LanguageServiceProvider {\r\n    private service: ILanguageService;\r\n    private documents: Map<string, IDocumentCacheEntry> = new Map();\r\n\r\n    init(parserParams: IParserParams, parsingFlags: number, includeResolver: IncludeResolver, defines?: IKnownDefine[]) {\r\n        console.log('%c Creating parser for language service provider...', 'background: #222; color: #bada55');\r\n        try {\r\n            createDefaultSLParser(parserParams);\r\n            console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n        } catch (e) {\r\n            console.error('could not initialize parser.');\r\n            return null;\r\n        }\r\n\r\n        this.service = getLanguageService({ flags: parsingFlags, includeResolver, defines });\r\n    }\r\n\r\n    async validate(rawDocument): Promise<Diagnostic[]> {\r\n        const textDocument = asTextDocument(rawDocument);\r\n\r\n        const slastDocument = await this.service.$parseSLASTDocument(textDocument);\r\n        const slDocument = await this.service.$parseSLDocument(slastDocument);\r\n        this.documents.set(textDocument.uri, { textDocument, slastDocument, slDocument });\r\n        \r\n        slDocument.diagnosticReport.messages.forEach(msg => {\r\n            const loc = resolveLocation(msg, slastDocument);\r\n            if (!loc) {\r\n                return;\r\n            }\r\n\r\n            const { start, end } = loc;\r\n            msg.start = start;\r\n            msg.end = end;\r\n        });\r\n\r\n        // IP: skip deprecations\r\n        return slDocument.diagnosticReport.messages.filter(msg => msg.code !== 'A3008').map(asDiagnostic);\r\n    }\r\n\r\n    async provideFxCodeLenses(textDocumentIdentifier: TextDocumentIdentifier): Promise<CodeLens[]> {\r\n        if (!this.service) {\r\n            return [];\r\n        }\r\n\r\n        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);\r\n        return this.service.doFxCodeLenses(textDocument, slDocument);\r\n    }\r\n\r\n    async provideSignatureHelp(textDocumentIdentifier: TextDocumentIdentifier, position: Position): Promise<SignatureHelp> {\r\n        if (!this.service) {\r\n            return null;\r\n        }\r\n\r\n        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);\r\n        return this.service.doSignatureHelp(textDocument, position, slDocument);\r\n    }\r\n\r\n    // async provideUnreachableCodeBlocks(textDocumentIdentifier: TextDocumentIdentifier): Promise<Range[]> {\r\n    //     if (!this.service) {\r\n    //         return null;\r\n    //     }\r\n\r\n    //     const { textDocument, slastDocument } = await this.getDocument(textDocumentIdentifier);\r\n    //     if (!slastDocument) {\r\n    //         return [];\r\n    //     }\r\n\r\n    //     // return slastDocument.unreachableCode.map(range => Range.create(Position.create(), Position.create()));\r\n    //     return [];\r\n    // }\r\n\r\n    private getDocument(textDocumentIdentifier: TextDocumentIdentifier): IDocumentCacheEntry {\r\n        if (!this.documents.has(textDocumentIdentifier.uri)) {\r\n            console.warn('could not find document', textDocumentIdentifier.uri);\r\n            return { textDocument: null, slastDocument: null, slDocument: null };\r\n        }\r\n        return this.documents.get(textDocumentIdentifier.uri);\r\n    }\r\n}\r\n\r\nexport type ILanguageServiceProvider = LanguageServiceProvider;\r\n\r\nComlink.expose(new LanguageServiceProvider());\r\n\r\n"],"names":[],"sourceRoot":""}