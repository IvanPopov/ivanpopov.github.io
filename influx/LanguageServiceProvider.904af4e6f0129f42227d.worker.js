/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "+C5w":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionTriggerKind": () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemLabelDetails": () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "DocumentUri": () => (/* binding */ DocumentUri),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "InlayHint": () => (/* binding */ InlayHint),
/* harmony export */   "InlayHintKind": () => (/* binding */ InlayHintKind),
/* harmony export */   "InlayHintLabelPart": () => (/* binding */ InlayHintLabelPart),
/* harmony export */   "InlineValueContext": () => (/* binding */ InlineValueContext),
/* harmony export */   "InlineValueEvaluatableExpression": () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   "InlineValueText": () => (/* binding */ InlineValueText),
/* harmony export */   "InlineValueVariableLookup": () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "SemanticTokenModifiers": () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   "SemanticTokenTypes": () => (/* binding */ SemanticTokenTypes),
/* harmony export */   "SemanticTokens": () => (/* binding */ SemanticTokens),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceFolder": () => (/* binding */ WorkspaceFolder),
/* harmony export */   "WorkspaceSymbol": () => (/* binding */ WorkspaceSymbol),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name: name, kind: kind, location: { uri: uri, range: range } }
            : { name: name, kind: kind, location: { uri: uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range: range, text: text };
    }
    InlineValueText.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range: range, expression: expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * [InlineValueContext](#InlineValueContext) literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId: frameId, stoppedLocation: stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the [InlineValueContext](#InlineValueContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value: value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        var result = { position: position, label: label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "+s+v":
/*!****************************!*\
  !*** ./src/lib/fx/HLSL.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HLSL": () => (/* reexport default export from named module */ _HLSL_gr__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _HLSL_gr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HLSL.gr */ "Zvko");




/***/ }),

/***/ "/ig4":
/*!**************************!*\
  !*** ./src/lib/bf/bf.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "clearAll": () => (/* binding */ clearAll),
/* harmony export */   "clearBit": () => (/* binding */ clearBit),
/* harmony export */   "clearFlags": () => (/* binding */ clearFlags),
/* harmony export */   "equal": () => (/* binding */ equal),
/* harmony export */   "flag": () => (/* binding */ flag),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "isNotEqaul": () => (/* binding */ isNotEqaul),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "setAll": () => (/* binding */ setAll),
/* harmony export */   "setBit": () => (/* binding */ setBit),
/* harmony export */   "setFlags": () => (/* binding */ setFlags),
/* harmony export */   "testAll": () => (/* binding */ testAll),
/* harmony export */   "testAny": () => (/* binding */ testAny),
/* harmony export */   "testBit": () => (/* binding */ testBit),
/* harmony export */   "totalBits": () => (/* binding */ totalBits),
/* harmony export */   "totalSet": () => (/* binding */ totalSet)
/* harmony export */ });
/**
 *    @a x  .
 */
var flag = (x) => (1 << (x));
/**
 *     @a value    @a bit  .
 */
var testBit = (value, bit) => ((value & flag(bit)) != 0);
/**
 *     @a value    ,
 *     @a set.
 */
var testAll = (value, set) => (((value) & (set)) == (set));
/**
 *     @a value        ,
 *     @a set.
 */
var testAny = (value, set) => (((value) & (set)) != 0);
/**
 *     @a bit   @a value  
 */
var setBit = (value, bit, setting = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
 *
 */
var clearBit = (value, bit) => ((value) &= ~flag((bit)));
/**
 *     @a bit   @a value  
 */
var setAll = (value, set, setting = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));
/**
 *      @a value  ,
 *      @a set
 */
var clearAll = (value, set) => ((value) &= ~(set));
/**
 *      @a value  ,
 *      @a set
 */
var equal = (value, src) => { value = src; };
/**
 *   @a value  @a src
 */
var isEqual = (value, src) => value == src;
/**
 *   @a value   @a src  true
 */
var isNotEqaul = (value, src) => value != src;
/**
 *   @a value  @a src
 */
var set = (value, src) => { value = src; };
/**
 *   @a value
 */
var clear = (value) => { value = 0; };
/**
 *      @a value  ,
 *      @a src
 */
var setFlags = (value, src) => (value |= src);
/**
 *      @a value  ,
 *      @a src
 */
var clearFlags = (value, src) => value &= ~src;
/**
 *     @a value .    true.
 *     false.
 */
var isEmpty = (value) => (value == 0);
/**
 *      @a value.
 *      32.
 */
var totalBits = (value) => 32;
/**
 *       @a value.
 */
var totalSet = (value) => {
    var count = 0;
    var total = totalBits(value);
    for (var i = total; i; --i) {
        count += (value & 1);
        value >>= 1;
    }
    return (count);
};


/***/ }),

/***/ "SSye":
/*!*****************************!*\
  !*** ./src/lib/bf/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bf */ "/ig4");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_bf__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "cOQ3":
/*!***************************!*\
  !*** ./src/lib/common.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "deepEqual": () => (/* binding */ deepEqual),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "isBlob": () => (/* binding */ isBlob),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDef": () => (/* binding */ isDef),
/* harmony export */   "isDefAndNotNull": () => (/* binding */ isDefAndNotNull),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isFloat": () => (/* binding */ isFloat),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isInt": () => (/* binding */ isInt),
/* harmony export */   "isNull": () => (/* binding */ isNull),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isTypedArray": () => (/* binding */ isTypedArray),
/* harmony export */   "isUint": () => (/* binding */ isUint),
/* harmony export */   "mwalk": () => (/* binding */ mwalk),
/* harmony export */   "typeOf": () => (/* binding */ typeOf),
/* harmony export */   "verbose": () => (/* binding */ verbose)
/* harmony export */ });
let typeOf = (x) => {
    const s = typeof x;
    if (s === 'object') {
        if (x) {
            if (x instanceof Array) {
                return 'array';
            }
            else if (x instanceof Object) {
                return s;
            }
            const sClassName = Object.prototype.toString.call(x);
            if (sClassName === '[object Window]') {
                return 'object';
            }
            if ((sClassName === '[object Array]' ||
                (typeof x.length) === 'number' &&
                    (typeof x.splice) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('splice'))) {
                return 'array';
            }
            if ((sClassName === '[object Function]' ||
                (typeof x.call) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                return 'function';
            }
        }
        else {
            return 'null';
        }
    }
    else if (s === 'function' && (typeof x.call) === 'undefined') {
        return 'object';
    }
    return s;
};
let isDef = (x) => x !== undefined;
let isDefAndNotNull = (x) => x != null;
let isEmpty = (x) => x.length === 0;
let isNull = (x) => x === null;
let isBoolean = (x) => typeof x === 'boolean';
let isString = (x) => typeof x === 'string';
let isNumber = (x) => typeof x === 'number';
let isFloat = isNumber;
let isInt = (x) => isNumber(x) && (~~x === x);
let isUint = (x) => isInt(x) && x > 0;
let isFunction = (x) => typeOf(x) === 'function';
let isObject = (x) => {
    const T = typeOf(x);
    return T === 'object' || T === 'array' || T === 'function';
};
let isArrayBuffer = (x) => x instanceof ArrayBuffer;
let isTypedArray = (x) => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';
let isBlob = (x) => x instanceof Blob;
let isArray = (x) => typeOf(x) === 'array';
// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);
let deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
const assert = console.assert.bind(console);
const verbose = console.log.bind(console);
/** 'ForEach' for maps. */
function mwalk(map, cb) {
    let i = 0;
    for (const key in map) {
        if (cb(map[key], key, i++) === false) {
            break;
        }
    }
}


/***/ }),

/***/ "GtHH":
/*!*******************************************!*\
  !*** ./src/lib/fx/AnalyzerDiagnostics.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnalyzerDiagnostics": () => (/* binding */ AnalyzerDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");





class AnalyzerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics {
    constructor() {
        super("Analyzer Diagnostics", 'A');
    }
    resolveFilename(category, code, desc) {
        return desc.file.toString();
    }
    resolveRange(category, code, desc) {
        return desc.loc;
    }
    diagnosticMessages() {
        // TODO: fill all errors.
        // TODO: add support for warnings
        return {
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \'*type*\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \'void\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedefinition]: 'Function redefinition. Function with name \'{info.funcName}\' already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \'{info.funcName}\' but another type already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotFunction]: ({ info }) => `Function definition for "${info.funcName}(${info.args.join(', ')})" has not been found.`
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            return `${_lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors[code]}: ${JSON.stringify(data)}`;
    }
}


/***/ }),

/***/ "sg/z":
/*!************************************!*\
  !*** ./src/lib/fx/FXSLDocument.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFXSLDocument": () => (/* binding */ createFXSLDocument),
/* harmony export */   "extendFXSLDocument": () => (/* binding */ extendFXSLDocument)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analisys/FxAnalyzer */ "rHPT");
/* harmony import */ var _SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SLASTDocument */ "s/Ev");



;
async function createFXSLDocument(document, opts = {}, parent = null) {
    let textDocument;
    let slastDocument;
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(document.source)) {
        textDocument = document;
        slastDocument = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textDocument, opts);
    }
    else {
        slastDocument = document;
    }
    const timeLabel = `createFXSLDocument(${slastDocument.uri})`;
    console.time(timeLabel);
    const analyzer = new _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__.FxAnalyzer;
    const slDocument = await analyzer.parse(slastDocument, parent);
    console.timeEnd(timeLabel);
    return slDocument;
}
async function extendFXSLDocument(textAddition, base, expressions, opts = {}) {
    let addition = null;
    if (textAddition) {
        const knownTypes = Object.keys(base.root.scope.types);
        const { flags, includeResolver } = opts;
        addition = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textAddition, { flags, knownTypes, includeResolver });
    }
    const analyzer = new _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__.FxAnalyzer;
    const slDocument = analyzer.extend(addition, base, expressions);
    return slDocument;
}


/***/ }),

/***/ "s/Ev":
/*!*************************************!*\
  !*** ./src/lib/fx/SLASTDocument.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SLASTDocument": () => (/* binding */ SLASTDocument),
/* harmony export */   "createSLASTDocument": () => (/* binding */ createSLASTDocument)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/ASTDocument */ "7GK7");
/* harmony import */ var _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/Preprocessor */ "nYIV");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _SLParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SLParser */ "/oCY");





// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));
const PREDEFINED_TYPES = [
    'half2', 'half3', 'half4',
    'float2', 'float3', 'float4',
    'float2x2', 'float2x3', 'float2x4',
    'float3x2', 'float3x3', 'float3x4',
    'float4x2', 'float4x3', 'float4x4',
    'int2', 'int3', 'int4',
    'uint2', 'uint3', 'uint4',
    'bool2', 'bool3', 'bool4',
    'auto'
];
class SLASTDocument extends _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__.ASTDocument {
    constructor({ parser = (0,_SLParser__WEBPACK_IMPORTED_MODULE_4__.defaultSLParser)(), knownTypes = new Set(), ...settings } = {}) {
        super({ parser, knownTypes: new Set([...PREDEFINED_TYPES, ...knownTypes]), ...settings });
    }
    get includes() {
        return this.preprocessor.includeMap;
    }
    get unreachableCode() {
        return this.preprocessor.unreachableCodeList;
    }
    get macros() {
        return [...this.preprocessor.macros];
    }
    get unresolvedMacros() {
        return this.preprocessor.unresolvedMacros;
    }
    get uri() {
        return this.preprocessor.uri;
    }
    get diagnosticReport() {
        let preprocessorReport = this.preprocessor.getDiagnosticReport();
        let parserReport = this.diag.resolve();
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__.Diagnostics.mergeReports([preprocessorReport, parserReport]);
    }
    init(config) {
        super.init(config);
        const { knownTypes } = this;
        const { includeResolver, defines } = config;
        this.preprocessor = new _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__.Preprocessor(this.parser.lexerEngine, { knownTypes, includeResolver, defines });
        this.ruleFunctions.set('addType', this._addType.bind(this));
        this.ruleFunctions.set('addTypeDef', this._addTypeDef.bind(this));
        this.ruleFunctions.set('print', this._print.bind(this));
    }
    _addType() {
        const tree = this.tree;
        const node = tree.lastNode;
        const typeId = node.value;
        this.knownTypes.add(typeId);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    _addTypeDef() {
        const tree = this.tree;
        const node = tree.lastNode;
        const typeId = node.children[0].value;
        this.knownTypes.add(typeId);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    _print() {
        const tree = this.tree;
        const node = tree.lastNode;
        console.log(node);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    setTextDocument(textDocument) {
        this.preprocessor.setTextDocument(textDocument);
    }
    async readToken() {
        const token = await this.preprocessor.readToken();
        // replacement of the original token location with the macro location
        const macroLoc = this.preprocessor.macroLocation();
        if (macroLoc) {
            token.loc = macroLoc;
        }
        return token;
    }
}
;
async function createSLASTDocument(textDocument, opts = {}) {
    const { flags, knownTypes, includeResolver, defines } = opts;
    const document = new SLASTDocument({ knownTypes: new Set([...(knownTypes || [])]), includeResolver, defines });
    // const timeLabel = `createSLASTDocument(${textDocument.uri})`;
    // console.time(timeLabel);
    await document.parse(textDocument, flags);
    // console.timeEnd(timeLabel);
    return document;
}


/***/ }),

/***/ "/oCY":
/*!********************************!*\
  !*** ./src/lib/fx/SLParser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SLParser": () => (/* binding */ SLParser),
/* harmony export */   "createDefaultSLParser": () => (/* binding */ createDefaultSLParser),
/* harmony export */   "defaultSLGrammar": () => (/* binding */ defaultSLGrammar),
/* harmony export */   "defaultSLParser": () => (/* binding */ defaultSLParser)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/AbstractParser */ "BF0t");
/* harmony import */ var _HLSL__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HLSL */ "+s+v");



// import slGrammar from 'raw-loader!./HLSL.gr';

class SLParser extends _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__.AbstractParser {
    init({ grammar = _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LALR, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_Default }) {
        super.init({ grammar, type, flags });
    }
}
let paramsDefault = null;
let parserDefault = null;
function defaultSLGrammar() {
    return _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL;
}
function defaultSLParser() {
    if (!parserDefault) {
        createDefaultSLParser();
    }
    return parserDefault;
}
/**
 * Internal debugging functionality, no need to use without necessary.
 */
function createDefaultSLParser(params = { grammar: _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL }) {
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(paramsDefault, params)) {
        return;
    }
    paramsDefault = params;
    parserDefault = new SLParser(params);
}


/***/ }),

/***/ "E5ji":
/*!************************************!*\
  !*** ./src/lib/fx/TextDocument.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTextDocument": () => (/* binding */ createTextDocument)
/* harmony export */ });
/* harmony import */ var _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/util/StringRef */ "Cx6u");

async function createTextDocument(uri, source, offset = null) {
    uri = _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_0__.StringRef.make(uri);
    return { uri, source, offset };
}


/***/ }),

/***/ "q04y":
/*!********************************!*\
  !*** ./src/lib/fx/Visitors.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Visitor": () => (/* binding */ Visitor),
/* harmony export */   "visitor": () => (/* binding */ visitor)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");

// TODO: move it to helpers
function visitor(owner, cb) {
    if (!owner) {
        return;
    }
    const visit = (instr) => {
        if (instr) {
            cb(instr, owner);
            visitor(instr, cb);
        }
    };
    switch (owner.instructionType) {
        //
        // Stmt
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt:
            owner.declList.forEach(decl => visit(decl));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ExprStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IfStmt:
            visit(owner.cond);
            visit(owner.conseq);
            visit(owner.contrary);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock:
            owner.stmtList.forEach(stmt => visit(stmt));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt:
            visit(owner.init);
            visit(owner.cond);
            visit(owner.body);
            visit(owner.step);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt:
            visit(owner.cond);
            visit(owner.body);
            break;
        //
        // Expr
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CastExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as ICompileExprInstruction).function);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileShader11Expr:
            visit(owner.func);
            owner.args.forEach(arg => visit(arg));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr:
            visit(owner.left);
            visit(owner.right);
            visit(owner.condition);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IConstructorCallInstruction).ctor);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IFunctionCallInstruction).decl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr:
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_InitExpr:
            owner.args.forEach(arg => visit(arg));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StateBlockExpr:
            console.assert(false, 'not implemented');
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StringExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_NullExpr:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_LogicalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr:
            visit(owner.element);
            visit(owner.index);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr:
            visit(owner.element);
            visit(owner.postfix);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_RelationalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SamplerStateBlockExpr:
            owner.params.forEach(param => visit(param));
            visit(owner.texture);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_UnaryExpr:
            visit(owner.expr);
            break;
        //
        // Others
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexType:
            owner.fields.forEach(field => visit(field));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDef:
            visit(owner.returnType);
            visit(owner.id);
            owner.params.forEach(param => visit(param));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDecl:
            visit(owner.def);
            visit(owner.impl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableDecl:
            visit(owner.type);
            visit(owner.initExpr);
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableType:
            visit(owner.subType);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Id:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SystemFunctionDecl:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SystemType:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt:
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SpawnStmt:
            // nothing todo?
            break;
        default:
            console.error('unsupported instruction type found');
    }
}
const Visitor = {
    each: visitor
};


/***/ }),

/***/ "R35j":
/*!*****************************************!*\
  !*** ./src/lib/fx/analisys/Analyzer.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Analyzer": () => (/* binding */ Analyzer),
/* harmony export */   "Context": () => (/* binding */ Context)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _lib_fx_AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/AnalyzerDiagnostics */ "GtHH");
/* harmony import */ var _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/fx/Visitors */ "q04y");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./helpers */ "pEQR");
/* harmony import */ var _instructions_AnnotationInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instructions/AnnotationInstruction */ "0qyf");
/* harmony import */ var _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./instructions/ArithmeticExprInstruction */ "+tx1");
/* harmony import */ var _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./instructions/AssignmentExprInstruction */ "eck/");
/* harmony import */ var _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./instructions/AttributeInstruction */ "rs/O");
/* harmony import */ var _instructions_BitwiseExprInstruction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./instructions/BitwiseExprInstruction */ "l236");
/* harmony import */ var _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./instructions/BoolInstruction */ "d+t4");
/* harmony import */ var _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./instructions/BreakStmtInstruction */ "t33R");
/* harmony import */ var _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./instructions/CastExprInstruction */ "KHnE");
/* harmony import */ var _instructions_CbufferInstruction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./instructions/CbufferInstruction */ "r+W1");
/* harmony import */ var _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./instructions/CompileExprInstruction */ "MV/g");
/* harmony import */ var _instructions_CompileShader11Instruction__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./instructions/CompileShader11Instruction */ "Ugh4");
/* harmony import */ var _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./instructions/ComplexExprInstruction */ "RRea");
/* harmony import */ var _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./instructions/ComplexTypeInstruction */ "G0Ba");
/* harmony import */ var _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./instructions/ConditionalExprInstruction */ "IsZF");
/* harmony import */ var _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./instructions/ConstructorCallInstruction */ "RIdR");
/* harmony import */ var _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./instructions/DeclStmtInstruction */ "YZc1");
/* harmony import */ var _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./instructions/ExprStmtInstruction */ "ubxH");
/* harmony import */ var _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./instructions/FloatInstruction */ "OsKO");
/* harmony import */ var _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./instructions/ForStmtInstruction */ "r82U");
/* harmony import */ var _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./instructions/FunctionCallInstruction */ "y57x");
/* harmony import */ var _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./instructions/FunctionDeclInstruction */ "BLpd");
/* harmony import */ var _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./instructions/IdInstruction */ "Muaz");
/* harmony import */ var _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./instructions/IfStmtInstruction */ "AAir");
/* harmony import */ var _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./instructions/InitExprInstruction */ "lavR");
/* harmony import */ var _instructions_Instruction__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./instructions/Instruction */ "hbjL");
/* harmony import */ var _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./instructions/IntInstruction */ "s0og");
/* harmony import */ var _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./instructions/LogicalExprInstruction */ "Oxvu");
/* harmony import */ var _instructions_NullInstruction__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./instructions/NullInstruction */ "a5rM");
/* harmony import */ var _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./instructions/PassInstruction */ "Z/0D");
/* harmony import */ var _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./instructions/PostfixArithmeticInstruction */ "fxHi");
/* harmony import */ var _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./instructions/PostfixIndexInstruction */ "yhcv");
/* harmony import */ var _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _instructions_Preset__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./instructions/Preset */ "6z3E");
/* harmony import */ var _instructions_PresetProperty__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./instructions/PresetProperty */ "vF1C");
/* harmony import */ var _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./instructions/ProvideInstruction */ "Tk3Z");
/* harmony import */ var _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./instructions/ProxyTypeInstruction */ "ijf+");
/* harmony import */ var _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./instructions/RelationalExprInstruction */ "2i/b");
/* harmony import */ var _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./instructions/ReturnStmtInstruction */ "UL2e");
/* harmony import */ var _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./instructions/SemicolonStmtInstruction */ "Po1l");
/* harmony import */ var _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./instructions/StateBlockInstruction */ "z98Y");
/* harmony import */ var _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./instructions/StmtBlockInstruction */ "fc3/");
/* harmony import */ var _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./instructions/StringInstruction */ "mlvU");
/* harmony import */ var _instructions_Technique11Instruction__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./instructions/Technique11Instruction */ "QdWn");
/* harmony import */ var _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./instructions/TechniqueInstruction */ "dmHP");
/* harmony import */ var _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./instructions/TypeDeclInstruction */ "Jg/d");
/* harmony import */ var _instructions_TypedefInstruction__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./instructions/TypedefInstruction */ "bYYM");
/* harmony import */ var _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./instructions/UnaryExprInstruction */ "Dbly");
/* harmony import */ var _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./instructions/WhileStmtInstruction */ "eHl7");
/* harmony import */ var _ProgramScope__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./ProgramScope */ "zHDc");
/* harmony import */ var _system_utils__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./system/utils */ "BeyE");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./SystemScope */ "c0pO");
/* module decorator */ module = __webpack_require__.hmd(module);




































































// TODO: refactor it
function findConstructor(type, args) {
    return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ type, scope: null });
}
const asType = (instr) => instr ? instr.type : null;
// FIXME: refuse from the regular expressions in favor of a full typecasting graph
// relax only uint => int
const asRelaxedType = (instr) => {
    if (!instr) {
        return null;
    }
    const type = (instr.getField) ? instr : instr.type;
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^
    //          hacky way to check if "type" instruction (not "typed")
    // hack to NULL expression to any type
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(type, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_NULL)) {
        return /^.*$/;
    }
    // allow "int" => "float" substitution
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(type) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(type) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(type)) {
        // temp workaround in order to match int to uint and etc. 
        const n = `${type.length > 1 ? type.length : ''}`;
        return new RegExp(`^int${n}$|^uint${n}$|^bool${n}$|^float${n}$`, "g");
    }
    return type;
};
// TODO: rework 'auto' api
function tryResolveProxyType(type, host) {
    if (type.subType && type.subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_ProxyType) {
        const proxy = type.subType;
        if (!proxy.isResolved()) {
            proxy.resolve(host);
        }
    }
}
/** @deprecated */
function getRenderStateValue(state, value) {
    let eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF;
    switch (state) {
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ALPHABLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ALPHATESTENABLE:
            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');
            return _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.CULLFACEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZWRITEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DITHERENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SCISSORTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.STENCILTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.POLYGONOFFSETFILLENABLE:
            switch (value) {
                case 'TRUE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.TRUE;
                    break;
                case 'FALSE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FALSE;
                    break;
                default:
                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '
                        + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.CULLFACE:
            switch (value) {
                case 'FRONT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FRONT;
                    break;
                case 'BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.BACK;
                    break;
                case 'FRONT_AND_BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FRONT_AND_BACK;
                    break;
                default:
                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.FRONTFACE:
            switch (value) {
                case 'CW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.CW;
                    break;
                case 'CCW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.CCW;
                    break;
                default:
                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNC:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNCSEPARATE:
            switch (value) {
                case 'ZERO':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ZERO;
                    break;
                case 'ONE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ONE;
                    break;
                case 'SRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCCOLOR;
                    break;
                case 'INVSRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVSRCCOLOR;
                    break;
                case 'SRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCALPHA;
                    break;
                case 'INVSRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVSRCALPHA;
                    break;
                case 'DESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.DESTALPHA;
                    break;
                case 'INVDESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVDESTALPHA;
                    break;
                case 'DESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.DESTCOLOR;
                    break;
                case 'INVDESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVDESTCOLOR;
                    break;
                case 'SRCALPHASAT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCALPHASAT;
                    break;
                default:
                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATION:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONSEPARATE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA:
            switch (value) {
                case 'FUNCADD':
                case 'ADD':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCADD;
                    break;
                case 'FUNCSUBTRACT':
                case 'SUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCSUBTRACT;
                    break;
                case 'FUNCREVERSESUBTRACT':
                case 'REVERSESUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCREVERSESUBTRACT;
                    break;
                default:
                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZFUNC:
            switch (value) {
                case 'NEVER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.NEVER;
                    break;
                case 'LESS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LESS;
                    break;
                case 'EQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.EQUAL;
                    break;
                case 'LESSEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LESSEQUAL;
                    break;
                case 'GREATER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.GREATER;
                    break;
                case 'NOTEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.NOTEQUAL;
                    break;
                case 'GREATEREQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.GREATEREQUAL;
                    break;
                case 'ALWAYS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ALWAYS;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.PRIMITIVETOPOLOGY:
            switch (value) {
                case 'TRIANGLELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.TRIANGLELIST;
                    break;
                case 'LINELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LINELIST;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
    }
    return eValue;
}
function addTypeDecl(context, scope, typeDecl) {
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(typeDecl.name)) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemTypeRedefinition, { typeName: typeDecl.name });
    }
    let isAdded = scope.addType(typeDecl.type);
    if (!isAdded) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: typeDecl.name });
    }
}
// TODO: rework to support complex typ defenitions like 
//  typedef const float4 TYPE_T;
//          ^^^^^^
// IP: at the moment type defenitions are not supported
function addTypeAlias(context, scope, typedef) {
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(typedef.alias)) {
        context.error(typedef.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemTypeRedefinition, { typeName: typedef.name });
    }
    let isAdded = scope.addTypeAlias(typedef.type, typedef.alias);
    if (!isAdded) {
        context.error(typedef.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: typedef.alias });
    }
}
function checkFunctionForRecursion(context, func, stack) {
    if (stack.indexOf(func.instructionID) !== -1) {
        context.error(func.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionRecursionNotAllowed, { funcName: func.name });
        return false;
    }
    let recursionFound = false;
    stack = [...stack, func.instructionID];
    const recursionChecker = (instr) => {
        if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FunctionCallExpr) {
            let fcall = instr;
            let fdecl = fcall.decl;
            if (fdecl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemFunctionDecl) {
                return;
            }
            // NOTE: it is possible that the declaration was not complete 
            //       at the time of the call, so you need to look for a 
            //       version with implementation
            fdecl = fdecl.scope.findFunctionInScope(fdecl);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(fdecl.impl)) {
                if (fdecl.attrs.find(attr => attr.name === 'extern')) {
                    // todo: use context info
                    context.warn(instr.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ExternCall);
                }
                else {
                    context.error(instr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionImplementationNotFound, { funcName: fdecl.name });
                }
                return;
            }
            // visitor(fdecl.impl, recursionChecker);
            recursionFound = recursionFound ||
                checkFunctionForRecursion(context, fdecl, stack);
        }
    };
    (0,_lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_9__.visitor)(func.impl, recursionChecker);
    return !recursionFound;
}
function checkFunctionsForRecursion(context, program) {
    const gs = program.globalScope;
    let recusrionFound = false;
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.mwalk)(gs.functions, funcOverloads => {
        funcOverloads.forEach(func => {
            recusrionFound = recusrionFound ||
                !checkFunctionForRecursion(context, func, []);
        });
    });
    return !recusrionFound;
}
function checkForVertexUsage(funcDef) {
    if (!checkReturnTypeForVertexUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForVertexUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkForPixelUsage(funcDef) {
    if (!checkReturnTypeForPixelUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForPixelUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkReturnTypeForVertexUsage(funcDef) {
    const returnType = funcDef.returnType;
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID)) {
        return true;
    }
    if (returnType.isComplex()) {
        if (returnType.hasFieldWithoutSemantics()) {
            // todo: emit warning
            // return false;
        }
        if (!returnType.hasAllUniqueSemantics()) {
            return false;
        }
        // Forbid fileds with user-defined types
        // or any other complex types?
        // if (returnType.isContainComplexType()) 
        {
            //return false;
        }
    }
    else {
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4)) {
            return false;
        }
        if (funcDef.semantic !== "POSITION") {
            return false;
        }
    }
    return true;
}
// todo: add support for dual source blending
// todo: add support for MRT
function checkReturnTypeForPixelUsage(funcDef) {
    let returnType = funcDef.returnType;
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID)) {
        return true;
    }
    // TODO: add MRT support
    if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(returnType)) {
        return false;
    }
    if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4)) {
        return false;
    }
    if (funcDef.semantic !== "COLOR") {
        // todo: emit warning
        // return false;
    }
    return true;
}
function checkArgumentsForVertexUsage(funcDef) {
    let params = funcDef.params;
    let isAttributeByStruct = false;
    let isAttributeByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(param.type) ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics()) {
                    return false;
                }
                isAttributeByStruct = true;
            }
            else if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isAttributeByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isAttributeByStruct) {
            return false;
        }
        else if (isAttributeByParams) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                return false;
            }
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
function checkArgumentsForPixelUsage(funcDef) {
    let params = funcDef.params;
    let isVaryingsByStruct = false;
    let isVaryingsByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if (param.semantic === "") {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(param.type) ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics()) {
                    // todo: check that there are no samplers in properties
                    return false;
                }
                isVaryingsByStruct = true;
            }
            else if (param.semantic !== "") {
                // todo: check that there are no samplers in properties
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isVaryingsByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isVaryingsByStruct) {
            return false;
        }
        else if (isVaryingsByParams) {
            if (param.semantic === "") {
                // todo: emit warning
                // return false;
            }
            // todo: check that there are no samplers in properties
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
class Context {
    constructor(uri, expressions) {
        this.diagnostics = new _lib_fx_AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_8__.AnalyzerDiagnostics;
        this.uri = uri;
        this.moduleName = null;
        this.haveCurrentFunctionReturnOccur = false;
        this.expressions = expressions || {};
    }
    beginCbuffer() { this.cbuffer = true; }
    endCbuffer() { this.cbuffer = false; }
    beginFunc() {
        this.func = true;
        this.haveCurrentFunctionReturnOccur = false;
        this.funcDef = null; // << will be set inside analyzeFunctionDecl();
    }
    endFunc() {
        this.func = false;
    }
    beginPass() {
        this.renderStates = null;
    }
    endPass() {
        this.renderStates = null;
    }
    error(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.error(code, { file, loc, info });
    }
    critical(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.critical(code, { file, loc, info });
    }
    warn(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.warning(code, { file, loc, info });
    }
    resolveNodeSourceLocation(sourceNode) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(sourceNode)) {
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(sourceNode.loc)) {
            return sourceNode.loc;
        }
        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);
    }
}
class Analyzer {
    analyzeUseDecl(context, program, sourceNode) {
        program.currentScope.strictMode = true;
    }
    analyzeComplexName(sourceNode) {
        const children = sourceNode.children;
        let name = '';
        for (let i = children.length - 1; i >= 0; i--) {
            name += children[i].value;
        }
        return name;
    }
    /**
     * AST example:
     *    ProvideDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_PROVIDE = 'provide'
     */
    analyzeProvideDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (children.length === 3) {
            let moduleName = this.analyzeComplexName(children[1]);
            ;
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(context.moduleName)) {
                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);
            }
            context.moduleName = moduleName;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(children[2].name === 'T_KW_PROVIDE');
            return new _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_48__.ProvideInstruction({ sourceNode, moduleName, scope });
        }
        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedProvideAs);
        return null;
    }
    /**
     * AST example:
     *    InitExpr
     *         T_UINT = '0'
     *    InitExpr
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeInitExprChildren(context, program, sourceNode, children, expectedType, exprSourceNode = null) {
        const scope = program.currentScope;
        // raw value like "int a = 1"
        if (children.length === 1) {
            const initExpr = this.analyzeExpr(context, program, children[0]);
            if (!initExpr) {
                return null;
            }
            // NOTE: exprSourceNode => source node of the whole expression like "const float name = value" for better error highlighting.
            //                                                                               ^^^^^^^^^^^^
            //       sourceNode => source node of the init expr: const float3 name = { 1, 2, 3 };
            //                                                                    ^^^^^^^^^^^^^
            //       sourceNode => source node of the init expr: const float3[1] name = { { 1, 2, 3 } };
            //                                                                            ^^^^^^^^^^^
            const resType = Analyzer.checkTwoOperandExprTypes(context, '=', expectedType, initExpr.type, sourceNode /* Use correct source node! */, initExpr.sourceNode, exprSourceNode || sourceNode, { isInitializing: true });
            if (!resType) {
                // omit error, all errors must be already fired above (inside checkTwoOperandExprTypes)
                return null;
            }
            ////////////////////////////////////////////////
            // IP: quick hack to avoid future conversions
            ////////////////////////////////////////////////
            // cast uint <=> int constant if possible
            // if (initExpr.instructionType === EInstructionTypes.k_IntExpr && !types.equals(initExpr.type, expectedType)) {
            //     let { scope, sourceNode, base, exp, signed, heximal } = <IntInstruction>initExpr;
            //     signed = expectedType.name === 'int';
            //     return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
            // }
            // if (!types.equals(initExpr.type, expectedType)) {
            //     return new CastExprInstruction({scope, sourceNode, sourceExpr: initExpr, type: expectedType});
            // }
            ////////////////////////////////////////////////
            ////////////////////////////////////////////////
            return initExpr;
        }
        // It's a global user defined array or just not unit array;
        // Trying to exclude types like float1.
        else if ((expectedType.isNotBaseArray() && expectedType.scope.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global) ||
            expectedType.isArray()) {
            const args = [];
            const numArgs = (children.length - 1) / 2;
            if (expectedType.length === _helpers__WEBPACK_IMPORTED_MODULE_10__.instruction.UNDEFINE_LENGTH ||
                (expectedType.isNotBaseArray() && numArgs !== expectedType.length) ||
                (!expectedType.isNotBaseArray() && numArgs !== expectedType.baseType.length)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializingEx, {
                    tooltip: `attemp to init an array with invalid number of arguments. expected: ${expectedType.length}, given: ${numArgs}`
                });
                return null;
            }
            const arrayElementType = expectedType.arrayElementType;
            /**
             * AST example:
             *    InitExpr
             *         T_PUNCTUATOR_125 = '}'
             *       + InitExpr
             *         T_PUNCTUATOR_44 = ','
             *       + InitExpr
             *         T_PUNCTUATOR_123 = '{'
             */
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].name === 'InitExpr') {
                    const initExpr = this.analyzeInitExpr(context, program, children[i], arrayElementType);
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(initExpr)) {
                        // omit error because it was already produced by the call above
                        return null;
                    }
                    args.push(initExpr);
                }
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(expectedType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableType);
            return new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__.InitExprInstruction({ scope, sourceNode, args, type: expectedType });
        }
        else if (expectedType.isComplex()) {
            const numArgs = (children.length - 1) / 2;
            const fieldNameList = expectedType.fields.map(f => f.name);
            const args = [];
            if (numArgs !== fieldNameList.length) {
                // TODO: emit error (invalid number of arguments)
                return null;
            }
            /**
             * AST example:
             *    InitExpr
             *         T_PUNCTUATOR_125 = '}'
             *       + InitExpr
             *         T_PUNCTUATOR_44 = ','
             *       + InitExpr
             *         T_PUNCTUATOR_123 = '{'
             */
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].name === 'InitExpr') {
                    const fieldType = expectedType.getField(fieldNameList[i]).type;
                    const initExpr = this.analyzeInitExpr(context, program, children[i], fieldType);
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(initExpr)) {
                        // omit error because it was already produced by the call above
                        return null;
                    }
                    args.push(initExpr);
                }
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(expectedType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableType);
            return new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__.InitExprInstruction({ scope, sourceNode, args, type: expectedType });
        }
        else {
            const numArgs = (children.length - 1) / 2;
            // handle cases like: int a = { 1 };
            if (numArgs !== 1) {
                // TODO: emit error (invalid number of arguments)
                return null;
            }
            const exprNode = children[children.length - 2];
            let initExpr = null;
            if (exprNode.name === 'InitExpr')
                initExpr = this.analyzeInitExpr(context, program, exprNode, expectedType);
            else
                initExpr = this.analyzeExpr(context, program, children[children.length - 2]);
            // TODO: use checkTwoOperandTypes() function instead
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expectedType, initExpr.type)) {
                // TODO: emit error
                return null;
            }
            return initExpr;
        }
        return null;
    }
    /**
     * AST example:
     *    InitExpr
     *         T_UINT = '0'
     *    InitExpr
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeInitExpr(context, program, sourceNode, expectedType) {
        return this.analyzeInitExprChildren(context, program, sourceNode, sourceNode.children, expectedType);
    }
    /**
     * AST example:
     *    SamplerStateDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + StateBlock
     *         T_NON_TYPE_ID = 'MeshTextureSampler'
     *         T_KW_SAMPLER_STATE = 'SamplerState'
     */
    /** @deprecated */
    analyzeSamplerStateDecl(context, program, sourceNode) {
        return null;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeVariableDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);
        const vars = [];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(generalType)) {
            return null;
        }
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars.push(this.analyzeVariable(context, program, children[i], generalType));
            }
        }
        return vars;
    }
    /**
     * AST example:
     *    UsageType
     *       + Type
     *       + Usage
     */
    analyzeUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        let usagesRaw = [];
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                // basically, just get type from scope
                type = this.analyzeType(context, program, children[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'Usage') {
                usagesRaw.push(this.analyzeUsage(children[i]));
            }
        }
        const usageIn = usagesRaw.includes('in');
        const usageOut = usagesRaw.includes('out');
        const usageInout = usagesRaw.includes('inout');
        const usageConst = usagesRaw.includes('const');
        const usageUniform = usagesRaw.includes('uniform');
        const usageUnsigned = usagesRaw.includes('unsigned');
        const usageStatic = usagesRaw.includes('static');
        // TODO: emit errors in case of inconsistent usages
        // TODO: remplace with bitflags
        let usages = [];
        if (usageInout) {
            usages.push('inout');
            // emit error in case of uniform
            // emit error in case of const
        }
        else {
            if (usageIn && usageOut) {
                usages.push('inout');
                // emit error in case of uniform
                // emit error in case of const
            }
            else {
                if (usageIn) {
                    usages.push('in');
                }
                if (usageOut) {
                    usages.push('out');
                    // emit error in case of const
                    // emit error in case of uniform
                }
                else {
                    if (usageConst)
                        usages.push('const');
                    if (usageUniform)
                        usages.push('uniform');
                }
            }
        }
        if (usageStatic) {
            usages.push('static');
        }
        if (usageUnsigned && !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(type)) {
            console.error('invalid unsigned usage');
        }
        // wrap type with usages
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, type, usages });
    }
    /**
     * AST example:
     *    Type
     *         T_TYPE_ID = 'float3'
     */
    analyzeType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        switch (sourceNode.name) {
            case 'T_TYPE_ID':
                if (sourceNode.value === 'auto') {
                    type = new _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_49__.ProxyTypeInstruction({ scope });
                    break;
                }
                type = scope.findType(sourceNode.value);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });
                }
                break;
            case 'Struct':
                type = this.analyzeStruct(context, program, sourceNode);
                break;
            case 'T_KW_VOID':
                type = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID;
                break;
            case 'ScalarType':
            case 'ObjectType':
                {
                    let typeName = children[children.length - 1].value;
                    if (children.length !== 1) {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(children[children.length - 2].value === '<' && children[0].value === '>');
                        const tplName = typeName;
                        const args = children
                            .slice(1, -2)
                            .reverse()
                            .filter((v, i) => i % 2 == 0)
                            .map(sourceNode => this.analyzeType(context, program, sourceNode));
                        const template = scope.findTypeTemplate(typeName);
                        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(template)) {
                            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameTemplateNotFound, { tplName, args: args.map(arg => arg.toCode()) });
                            return null;
                        }
                        // TODO: validate register
                        // TODO: use ESystemTypes enumeration
                        const SYSTEM_TYPES = [
                            'Buffer',
                            'RWBuffer',
                            'RWStructuredBuffer',
                            'AppendStructuredBuffer',
                            'RWTexture1D',
                            'RWTexture2D',
                            'RWTexture3D',
                            'Texture1D',
                            'Texture2D',
                            'Texture3D',
                            'Texture2DArray',
                            'TextureCubeArray',
                        ];
                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {
                            if (scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeScope, { typeName: template.name, tooltip: 'only global scope allowed' });
                                return null;
                            }
                        }
                        typeName = template.typeName(args);
                        type = scope.findType(typeName);
                        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                            type = template.produceType(scope, args);
                            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotProduceType, { typeName });
                                return null;
                            }
                            scope.addType(type);
                        }
                    }
                    else {
                        type = scope.findType(typeName);
                    }
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameNotType, { typeName });
                        return null;
                    }
                }
                break;
            case 'VectorType':
            case 'MatrixType':
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeVectorMatrix);
                break;
            case 'BaseType':
            case 'Type':
                return this.analyzeType(context, program, children[0]);
        }
        return type;
    }
    analyzeUsage(sourceNode) {
        sourceNode = sourceNode.children[0];
        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout', 'static', 'unsigned', 'precise', 'inline'];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(supportedUsages.indexOf(sourceNode.value) !== -1, sourceNode.value);
        return sourceNode.value;
    }
    /**
     * AST example:
     *    CbufferDecl
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_125 = '}'
     *       + VarStructDecl
     *         T_PUNCTUATOR_123 = '{'
     *       + Annotation
     *       + Semantic
     *         T_NON_TYPE_ID = 'NAME'
     *         T_KW_CBUFFER = 'cbuffer'
     *
     * AST example:
     *    CbufferDecl
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_125 = '}'
     *       + VarStructDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_KW_CBUFFER = 'cbuffer'
     */
    analyzeCbufferDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = '';
        let id = null;
        context.beginCbuffer();
        let ic = children.length - 2;
        if (children[ic].name === 'T_NON_TYPE_ID') {
            id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode: children[ic], name: children[ic].value });
            ic--;
        }
        if (children[ic].name === 'Semantic') {
            semantic = this.analyzeSemantic(children[ic]);
            const match = semantic.match(/^register\(([utbs]{1})([\d]+)\)$/);
            if (match) {
                const rtype = match[1];
                if (rtype !== 'b') {
                    context.warn(children[ic], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.InvalidCbufferRegister);
                }
            }
            ic--;
        }
        if (children[ic].name === 'Annotation') {
            annotation = this.analyzeAnnotation(context, program, children[ic]);
            ic--;
        }
        ic--;
        // program.push(EScopeType.k_Cbuffer);
        let fields = [];
        for (let i = ic; i >= 2; i--) {
            switch (children[i].name) {
                case 'VariableDecl':
                    fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
                    break;
                case 'VarStructDecl':
                    fields = fields.concat(this.analyzeVarStructDecl(context, program, children[i]));
                    break;
                default:
                    context.error(children[i], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, {});
            }
        }
        // program.pop();
        context.endCbuffer();
        const aligment = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4.size; // float4 aligment!
        const name = id.name;
        const type = new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, name, fields, aligment });
        {
            let isAdded = scope.addType(type);
            if (!isAdded) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: name });
            }
        }
        const cbuf = new _instructions_CbufferInstruction__WEBPACK_IMPORTED_MODULE_19__.CbufferInstruction({ id, type, sourceNode, semantic, annotation, scope });
        {
            let isAdded = scope.addCbuffer(cbuf);
            if (!isAdded) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CbufferRedefinition, { typeName: name });
            }
        }
        return cbuf;
    }
    /**
     * AST example:
     *    Variable
     *       + Initializer
     *       + Semantic
     *       + VariableDim
     *              T_PUNCTUATOR_93 = ']'
     *              T_NON_TYPE_ID = 'N'
     *              T_PUNCTUATOR_91 = '['
     *            + VariableDim
     *                   T_NON_TYPE_ID = 'x'
     *                   ^^^^^^^^^^^^^^^^^^
     */
    analyzeVariable(context, program, sourceNode, generalType) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let annotation = null;
        let init = null;
        let semantic = '';
        let usageFlags = 0;
        if (!context.func) {
            if (scope.type !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Global;
            }
            if (context.cbuffer) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Cbuffer;
            }
        }
        else {
            // All variables found inside function definition are arguments.
            if (!context.funcDef) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Argument;
            }
            usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Local;
        }
        let id = null;
        let arrayIndex = null;
        let type = null;
        let vdimNode = children[children.length - 1];
        do {
            let vdimChildren = vdimNode.children;
            if (vdimChildren.length === 1) {
                const name = vdimChildren[0].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
                break;
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(vdimChildren.length == 4);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(arrayIndex)) {
                // usage of generalType.source node instead of sourceNode was done for more clear debugging
                generalType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
            }
            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);
            vdimNode = vdimChildren[vdimChildren.length - 1];
        } while (true);
        // using generalType.source node instead of sourceNode was done for more clear debugging
        type = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
        /**
         * (state block initializer)
         * AST example:
         *    Initializer
         *       + StateBlock
         */
        /**
         * (list initializer)
         * AST example:
         *    Initializer
         *         T_UINT = '1'
         *         T_PUNCTUATOR_61 = '='
         */
        const doInitUsingList = (sourceNode) => sourceNode.children[sourceNode.children.length - 1]?.value == '=';
        for (let i = children.length - 2; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else if (children[i].name === 'Initializer') {
                if (doInitUsingList(children[i])) {
                    init = this.analyzeInitializer(context, program, children[i], type, sourceNode);
                }
                else {
                    init = this.analyzeStateBlock(context, program, children[i].children[0], type);
                }
                switch (type.name) {
                    case 'BlendState':
                    case 'SamplerState':
                    case 'SamplerComparisonState':
                    case 'DepthStencilState':
                    case 'RasterizerState':
                        // todo: validate properties
                        console.assert(!doInitUsingList(children[i]));
                        console.assert(!type.isNotBaseArray() || type.length == init.blocks.length);
                        break;
                    default:
                        console.assert(doInitUsingList(children[i]));
                }
                if (!init) {
                    // TODO: make it warning
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializing, { varName: id.name });
                }
            }
        }
        const varDecl = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_System);
        if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.hasVariable(varDecl.name)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemVariableRedefinition, { varName: varDecl.name });
        }
        const isAdded = scope.addVariable(varDecl);
        if (!isAdded) {
            switch (scope.type) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global:
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.VariableRedefinition, { varName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Annotation:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidNewAnnotationVar, { varName: varDecl.name });
                    break;
            }
        }
        return varDecl;
    }
    /**
     * AST example:
     *    AnnotationDecls
     *       + AnnotationDecls
     *       + VariableDecl
     */
    analyzeAnnotationDecls(context, program, sourceNode) {
        const children = sourceNode.children;
        let decls = [];
        for (let i = children.length - 1; i >= 0; i--) {
            switch (children[i].name) {
                case 'AnnotationDecls':
                    decls.push(...this.analyzeAnnotationDecls(context, program, children[i]));
                    break;
                case 'VariableDecl':
                    decls.push(...this.analyzeVariableDecl(context, program, children[i]));
                    break;
            }
        }
        return decls;
    }
    /**
     * AST example:
     *    Annotation
     *         T_PUNCTUATOR_62 = '>'
     *         T_PUNCTUATOR_60 = '<'
     */
    analyzeAnnotation(context, $program, sourceNode) {
        // IP: hucky way to not add annotation variables to real scope
        const program = new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScope(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        const scope = program.currentScope;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Annotation);
        const decls = [
            ...sourceNode.children.filter(node => node.name == 'AnnotationDecls').map(node => this.analyzeAnnotationDecls(context, program, node)).flat(),
            ...sourceNode.children.filter(node => node.name == 'VariableDecl').map(node => this.analyzeVariableDecl(context, program, node)).flat()
        ];
        program.pop();
        if (!decls || !decls.length)
            return null;
        return new _instructions_AnnotationInstruction__WEBPACK_IMPORTED_MODULE_11__.AnnotationInstruction({ scope, sourceNode, decls });
    }
    /**
     * AST example:
     *    Semantic
     *         T_NON_TYPE_ID = 'SEMANTIC'
     *         T_PUNCTUATOR_58 = ':'
     */
    /**
     * AST example:
     *    Semantic
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'u2'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_REGISTER = 'register'
     *         T_PUNCTUATOR_58 = ':'
     */
    analyzeSemantic(sourceNode) {
        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');
    }
    /**
     * AST example:
     *    Initializer
     *         T_UINT = '10'
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *       + CastExpr
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_44 = ','
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     *         T_PUNCTUATOR_61 = '='
     */
    analyzeInitializer(context, program, sourceNode, expectedType, exprSourceNode = null) {
        const children = sourceNode.children;
        // IP: hacky varification to be sure that it's not a 
        if (children[children.length - 1]?.value == '=') {
            console.assert(children[children.length - 1].name === 'T_PUNCTUATOR_61');
            return this.analyzeInitExprChildren(context, program, sourceNode, children.slice(0, -1), expectedType, exprSourceNode);
        }
        console.assert(false, 'not valid branch');
        return null;
    }
    analyzeExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        switch (name) {
            case 'ObjectExpr':
                return this.analyzeObjectExpr(context, program, sourceNode);
            case 'ComplexExpr':
                return this.analyzeComplexExpr(context, program, sourceNode);
            case 'PostfixExpr':
                return this.analyzePostfixExpr(context, program, sourceNode);
            case 'UnaryExpr':
                return this.analyzeUnaryExpr(context, program, sourceNode);
            case 'CastExpr':
                return this.analyzeCastExpr(context, program, sourceNode);
            case 'ConditionalExpr':
                return this.analyzeConditionalExpr(context, program, sourceNode);
            case 'MulExpr':
            case 'AddExpr':
                return this.analyzeArithmeticExpr(context, program, sourceNode);
            case 'RelationalExpr':
            case 'EqualityExpr':
                return this.analyzeRelationExpr(context, program, sourceNode);
            case 'LogicalAndExpr':
            case 'LogicalOrExpr':
                return this.analyzeLogicalExpr(context, program, sourceNode);
            case 'AssignmentExpr':
                return this.analyzeAssignmentExpr(context, program, sourceNode);
            case 'AndExpr':
            case 'ShiftExpr':
            case 'InclusiveOrExpr':
            case 'ExclusiveOrExpr':
                return this.analyzeBitwiseExpr(context, program, sourceNode);
            case 'T_NON_TYPE_ID':
                return this.analyzeIdExpr(context, program, sourceNode);
            case 'T_STRING':
            case 'T_UINT':
            case 'T_FLOAT':
            case 'T_KW_TRUE':
            case 'T_KW_FALSE':
                return this.analyzeSimpleExpr(context, program, sourceNode);
            default:
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedExpr, { exprName: name });
                break;
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *       + StateBlock
     *         T_KW_SAMPLER_STATE = 'sampler_state'
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'fs_skybox'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeObjectExpr(context, program, sourceNode) {
        let name = sourceNode.children[sourceNode.children.length - 1].name;
        switch (name) {
            /** @deprecated */
            case 'T_KW_COMPILE':
                return this.analyzeCompileExpr(context, program, sourceNode);
            case 'T_KW_COMPILE_SHADER':
                return this.analyzeCompileShader11(context, program, sourceNode);
                return null;
            default:
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *       + ComplexExpr
     *         T_PUNCTUATOR_44 = ','
     *         T_NON_TYPE_ID = 'vs_4_0_level_9_1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_COMPILE_SHADER = 'CompileShader'
     */
    analyzeCompileShader11(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        // CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )
        const shaderNode = children[1]; // RenderSceneVS( 1, true, true )
        const versionNode = children[3]; // vs_4_0_level_9_1
        const ver = versionNode.value;
        const entryNode = shaderNode.children[shaderNode.children.length - 1]; // RenderSceneVS
        const funcName = entryNode.value;
        const args = [];
        for (let i = shaderNode.children.length - 3; i > 0; i--) {
            if (shaderNode.children[i].value !== ',') {
                args.push(this.analyzeExpr(context, program, shaderNode.children[i]));
            }
        }
        //findFunction(funcName, args);
        const func = program.globalScope.functions[funcName][0]; // todo: get suitable?
        const shaderType = ver.substring(0, 2);
        const sh = {
            'vs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VERTEX_SHADER,
            'ps': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_PIXEL_SHADER,
            'gs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_GEOMETRY_SHADER,
            'cs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_COMPUTE_SHADER
        };
        const type = sh[shaderType];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(type), `unknown shader type '${shaderType} (${ver})' has been used`);
        return new _instructions_CompileShader11Instruction__WEBPACK_IMPORTED_MODULE_21__.CompileShader11Instruction({ scope, sourceNode, ver, args, func, type });
    }
    /**
     * AST example:
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'main'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeCompileExpr(context, program, sourceNode, validators) {
        const children = sourceNode.children;
        const shaderFuncName = children[children.length - 2].value;
        const scope = program.currentScope;
        let compileArgs = null;
        let retType = null;
        let args = null;
        if (children.length > 4) {
            compileArgs = [];
            for (let i = children.length - 4; i > 0; i--) {
                if (children[i].value !== ',') {
                    compileArgs.push(this.analyzeExpr(context, program, children[i]));
                }
            }
        }
        args = compileArgs ? compileArgs.map(asType) : null;
        let func = null;
        if (validators) {
            for (let validator of validators) {
                args = compileArgs ? compileArgs.map(asType) : null;
                retType = null;
                args = validator.args || args;
                retType = validator.ret || retType;
                func = program.globalScope.findFunction(shaderFuncName, args);
                if (func) {
                    // skip function if validator is not suitable
                    if (validator.ret && !_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(validator.ret, func.def.returnType)) {
                        // skip this function
                        continue;
                    }
                    break;
                }
            }
        }
        else {
            func = program.globalScope.findFunction(shaderFuncName, args);
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });
            return null;
        }
        if (retType) {
            // show error if we found some variant of function but return type mismath
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(func.def.returnType, retType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCompileFunctionNotValid, {
                    funcName: shaderFuncName,
                    funcType: retType.toCode(),
                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `
                });
                return null;
            }
        }
        let type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(func.def.returnType, scope);
        return new _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_20__.CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });
    }
    // /**
    //  * AST example:
    //  *    ObjectExpr
    //  *       + StateBlock 
    //  *         T_KW_SAMPLER_STATE = 'sampler_state'
    //  */
    // protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {
    //     sourceNode = sourceNode.children[0];
    //     let scope = program.currentScope;
    //     let children = sourceNode.children;
    //     let operator: SamplerOperator = "sampler_state";
    //     let texture = null;
    //     let params = <ISamplerStateInstruction[]>[];
    //     for (let i = children.length - 2; i >= 1; i--) {
    //         let param = this.analyzeSamplerState(context, program, children[i]);
    //         if (!isNull(param)) {
    //             params.push(param);
    //         }
    //     }
    //     return new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });
    // }
    // /**
    //  * AST example:
    //  *    State
    //  *         T_PUNCTUATOR_59 = ';'
    //  *         StateExpr
    //  *              T_PUNCTUATOR_62 = '>'
    //  *              T_NON_TYPE_ID = 'tex0'
    //  *              T_PUNCTUATOR_60 = '<'
    //  *         T_PUNCTUATOR_61 = '='
    //  *         T_NON_TYPE_ID = 'Texture'
    //  */
    // protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {
    //     const children = sourceNode.children;
    //     const scope = program.currentScope;
    //     if (children[children.length - 2].name === 'StateIndex') {
    //         context.error(sourceNode, EErrors.UnsupportedStateIndex);
    //         return null;
    //     }
    //     let stateExprNode = children[children.length - 3];
    //     let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];
    //     let stateType = children[children.length - 1].value.toUpperCase();
    //     let stateValue = '';
    //     if (isNull(subStateExprNode.value)) {
    //         context.error(subStateExprNode, EErrors.InvalidSamplerTexture);
    //         return null;
    //     }
    //     switch (stateType) {
    //         case 'TEXTURE':
    //             if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {
    //                 context.error(subStateExprNode, EErrors.InvalidSamplerTexture);
    //                 return null;
    //             }
    //             let texNameNode = stateExprNode.children[1];
    //             let texName = texNameNode.value;
    //             if (isNull(texName) || !scope.findVariable(texName)) {
    //                 context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);
    //                 return null;
    //             }
    //             let texDecl = scope.findVariable(texName);
    //             let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });
    //             let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });
    //             return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });
    //         case 'ADDRESSU': /* WRAP_S */
    //         case 'ADDRESSV': /* WRAP_T */
    //             stateValue = subStateExprNode.value.toUpperCase();
    //             switch (stateValue) {
    //                 case 'WRAP':
    //                 case 'CLAMP':
    //                 case 'MIRROR':
    //                     break;
    //                 default:
    //                     // TODO: move to errors
    //                     // console.warn('Webgl don`t support this wrapmode: ' + stateValue);
    //                     return null;
    //             }
    //             break;
    //         case 'MAGFILTER':
    //         case 'MINFILTER':
    //             stateValue = subStateExprNode.value.toUpperCase();
    //             switch (stateValue) {
    //                 case 'POINT':
    //                     stateValue = 'NEAREST';
    //                     break;
    //                 case 'POINT_MIPMAP_POINT':
    //                     stateValue = 'NEAREST_MIPMAP_NEAREST';
    //                     break;
    //                 case 'LINEAR_MIPMAP_POINT':
    //                     stateValue = 'LINEAR_MIPMAP_NEAREST';
    //                     break;
    //                 case 'POINT_MIPMAP_LINEAR':
    //                     stateValue = 'NEAREST_MIPMAP_LINEAR';
    //                     break;
    //                 case 'NEAREST':
    //                 case 'LINEAR':
    //                 case 'NEAREST_MIPMAP_NEAREST':
    //                 case 'LINEAR_MIPMAP_NEAREST':
    //                 case 'NEAREST_MIPMAP_LINEAR':
    //                 case 'LINEAR_MIPMAP_LINEAR':
    //                     break;
    //                 default:
    //                     // TODO: move to erros api
    //                     // console.warn('Webgl don`t support this texture filter: ' + stateValue);
    //                     return null;
    //             }
    //             break;
    //         default:
    //             // TODO: move to erros api
    //             console.warn('Don`t support this texture param: ' + stateType);
    //             return null;
    //     }
    //     return new SamplerStateInstruction({
    //         sourceNode,
    //         scope,
    //         name: stateType,
    //         value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })
    //     });
    // }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_FLOAT = '2.'
     *         T_PUNCTUATOR_44 = ','
     *         T_FLOAT = '1.'
     *         T_PUNCTUATOR_40 = '('
     *         T_TYPE_ID = 'float4'
     */
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *       + PostfixPointExpr
     */
    analyzeComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'PostfixPointExpr':
            case 'T_NON_TYPE_ID':
                return this.analyzeFunctionCallExpr(context, program, sourceNode);
            case 'BaseType':
            case 'T_TYPE_ID':
                return this.analyzeConstructorCallExpr(context, program, sourceNode);
            default:
                return this.analyzeSimpleComplexExpr(context, program, sourceNode);
        }
    }
    analyzeCallee(context, program, sourceNode) {
        const children = sourceNode.children;
        return this.analyzeExpr(context, program, children[children.length - 1]);
    }
    createTracePseudoDeclaration(context, program, args) {
        const scope = program.globalScope; // global scope (!)
        const attrs = [new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__.AttributeInstruction({ scope, name: "extern", args: null })];
        const impl = null;
        const returnType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID, scope);
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: "trace" });
        const paramList = args.map((arg, i) => {
            // todo: fully deduce base type 
            const type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrapAsConst(arg.type.baseType, scope);
            const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: `p${i}` });
            const usageFlags = _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Argument | _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Local;
            return new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({ scope, type, id, usageFlags });
        });
        const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, returnType, id, paramList });
        const traceFunc = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ scope, def, impl, attrs });
        scope.addFunction(traceFunc);
        return traceFunc;
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_44 = ','
     *         T_NON_TYPE_ID = 'a'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'foo'
     */
    /**
     * AST example:
     *    PostfixPointExpr
     *         T_NON_TYPE_ID = 'IncrementCounter'
     *         T_PUNCTUATOR_46 = '.'
     *       + PostfixExpr
     */
    analyzeFunctionCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const firstNodeName = children[children.length - 1].name;
        let funcName = null;
        let func = null;
        let callee = null;
        let args = [];
        switch (firstNodeName) {
            // call as function
            case 'T_NON_TYPE_ID':
                {
                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address
                    funcName = children[children.length - 1].value;
                    if (children.length > 3) {
                        for (let i = children.length - 3; i > 0; i--) {
                            if (children[i].value !== ',') {
                                const arg = this.analyzeExpr(context, program, children[i]);
                                args.push(arg);
                            }
                        }
                    }
                    const noStrictTypeWereProvided = args.every(arg => arg?.type != asRelaxedType(arg));
                    // don't relax all types because it's useless
                    // like: (0, 0, 0) => (float|int, float|int)
                    // relax only uint => int if not strict types were provided 
                    func = globalScope.findFunction(funcName, args.map(arg => arg?.type || null));
                    // still not found?
                    if (!func) {
                        // last resort for cases like: "sqrt(2)"
                        func = globalScope.findFunction(funcName, args.map(asRelaxedType));
                    }
                    // special case for debug "void trace(...)" function
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func) && funcName === 'trace') {
                        func = this.createTracePseudoDeclaration(context, program, args);
                    }
                }
                break;
            // call as method
            case 'PostfixPointExpr':
                {
                    callee = this.analyzeCallee(context, program, children[children.length - 1]);
                    funcName = children[children.length - 1].children[0].value; // method name
                    if (children.length > 3) {
                        for (let i = children.length - 3; i > 0; i--) {
                            if (children[i].value !== ',') {
                                const arg = this.analyzeExpr(context, program, children[i]);
                                args.push(arg);
                            }
                        }
                    }
                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));
                }
                break;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotFunction, { funcName, args: args.map(arg => _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(arg?.type)) });
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotChooseFunction, { funcName });
            return null;
        }
        if (args.includes(null)) {
            return null;
        }
        if (func.def.params.filter(p => !p.initExpr).length > args.length) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedExpr, { funcName });
            return null;
        }
        args.forEach((x, i) => {
            const param = func.def.params[i];
            const arg = args[i];
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(param.type, arg.type)) {
                context.warn(arg.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { info: `${arg.type.toCode()} => ${param.type.toCode()}` });
            }
        });
        if (func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FunctionDecl &&
            func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemFunctionDecl) {
            console.error("@undefined_behavior");
            return null;
        }
        const params = func.def.params;
        for (let i = 0; i < args.length; i++) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(args[i])) {
                continue;
            }
            if (params[i].type.usages.includes('out')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(args[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidExprIsNotLValue);
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
                }
            }
            else if (params[i].type.usages.includes('inout')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(args[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidExprIsNotLValue);
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
                }
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
            else {
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
        }
        {
            const type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?
            return new _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_30__.FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });
        }
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *       + BaseType
     */
    analyzeConstructorCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const ctorType = this.analyzeType(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(ctorType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotType);
            return null;
        }
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 3; i > 0; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeExpr(context, program, children[i]);
                    args.push(argumentExpr);
                }
            }
        }
        // TODO: add correct implementation! 
        const exprType = findConstructor(ctorType, args);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(args)) {
            for (let i = 0; i < args.length; i++) {
                if (!args[i] || !args[i].type.readable) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
        }
        return new _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_25__.ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });
    }
    // TODO: add comment!
    analyzeSimpleComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
            return null;
        }
        return new _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_22__.ComplexExprInstruction({ scope, sourceNode, expr });
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const symbol = children[children.length - 2].value;
        switch (symbol) {
            case '[':
                return this.analyzePostfixIndex(context, program, sourceNode);
            case '.':
                return this.analyzePostfixPoint(context, program, sourceNode);
            case '++':
            case '--':
                return this.analyzePostfixArithmetic(context, program, sourceNode);
        }
        return null;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixIndex(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(postfixExpr)) {
            // TODO: emit error?
            return null;
        }
        const postfixExprType = postfixExpr.type;
        if (!postfixExprType.isArray()) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });
            return null;
        }
        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const indexExprType = indexExpr.type;
        if (!(_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(indexExprType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT) || _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(indexExprType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_UINT))) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });
            return null;
        }
        return new _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_44__.PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     * @param fieldName
     */
    static createFieldDecl(elementType, fieldName) {
        if (!elementType.getField(fieldName)) {
            return null;
        }
        const decl = 
        // FIXME: remove 'logical OR' operation, always use subType
        (elementType.subType || elementType).getField(fieldName); // arrayIndex
        const { type } = decl;
        // in case of typical postfix exp. like "element.postfix":
        //      elementType => type derived from the parameter or variable declaration or derived from another expr
        //      elementType.subType => original complex (structure) type
        // in case of something else, like ccall with postfix "float2(1.0, 2.0).yx":
        //      elementType => original system type
        const fieldType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({
            scope: type.scope,
            sourceNode: type.sourceNode,
            type,
            readable: elementType.readable,
            writable: elementType.writable,
            /*aligment,*/
            padding: type.padding
        });
        const fieldId = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope: decl.scope, name: decl.id.name, sourceNode: decl.id.sourceNode });
        const field = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({
            semantic: decl.semantic,
            scope: decl.scope,
            type: fieldType,
            sourceNode: decl.sourceNode,
            id: fieldId,
            usageFlags: decl.usageFlags
        });
        return _instructions_Instruction__WEBPACK_IMPORTED_MODULE_37__.Instruction.$withParent(field, elementType);
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     */
    analyzePostfixPointField(context, program, sourceNode, elementType) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(elementType)) {
            return null;
        }
        const scope = program.currentScope;
        const name = sourceNode.value; // fiedl name
        const decl = Analyzer.createFieldDecl(elementType, name); // field decl
        // const decl = elementType.getField(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
        return new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__.IdExprInstruction({ scope, sourceNode, id, decl });
        ;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     */
    /**
     * Expressions like:
     *      **(element.postfix)**
     */
    analyzePostfixPoint(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const element = this.analyzeExpr(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(element)) {
            // TODO: emit error?
            return null;
        }
        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(postfix)) {
            const fieldName = children[children.length - 3].value;
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });
            return null;
        }
        return new _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_45__.PostfixPointInstruction({ sourceNode, scope, element, postfix });
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'b'
     */
    analyzePostfixArithmetic(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[0].value;
        const postfixExpr = this.analyzeExpr(context, program, children[1]);
        const postfixExprType = postfixExpr.type;
        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixArithmetic, {
                operator: operator,
                typeName: String(postfixExprType)
            });
            return null;
        }
        return new _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_43__.PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });
    }
    /**
     * AST example:
     *    UnaryExpr
     *         T_NON_TYPE_ID = 'x'
     *         T_PUNCTUATOR_33 = '!'
     */
    analyzeUnaryExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const operator = children[1].value;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[0]);
        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidUnaryOperation, {
                operator: operator,
                tyename: String(expr.type)
            });
            return null;
        }
        let unaryExpr = null;
        // shortcut for replacment of unary expressions with literals
        if (operator === '-' || operator === '+') {
            if (_helpers__WEBPACK_IMPORTED_MODULE_10__.instruction.isLiteral(expr)) {
                switch (expr.instructionType) {
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_IntExpr:
                        {
                            let lit = expr;
                            let { base, signed, heximal, exp } = lit;
                            signed = operator === '-' || lit.signed;
                            // TODO: emit warning in case of '-100u' expr.
                            base = operator === '-' ? -base : base;
                            unaryExpr = new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
                        }
                        break;
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FloatExpr:
                        unaryExpr = new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__.FloatInstruction({ scope, sourceNode, value: Number(`${operator}${expr.value}`) });
                }
            }
        }
        if (!unaryExpr) {
            unaryExpr = new _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_60__.UnaryExprInstruction({ scope, sourceNode, expr, operator });
        }
        return unaryExpr;
    }
    /**
     * AST example:
     *    CastExpr
     *         T_NON_TYPE_ID = 'y'
     *         T_PUNCTUATOR_41 = ')'
     *       + ConstType
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeCastExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const type = this.analyzeConstTypeDim(context, program, children[2]);
        if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastTypeNotBase, { typeName: String(type) });
        }
        const sourceExpr = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(sourceExpr)) {
            return null;
        }
        if (!sourceExpr.type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        return new _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_18__.CastExprInstruction({ scope, sourceNode, sourceExpr, type });
    }
    /**
     * AST example:
     *    ConditionalExpr
     *         T_KW_FALSE = 'false'
     *         T_PUNCTUATOR_58 = ':'
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_63 = '?'
     *         T_NON_TYPE_ID = 'isOk'
     */
    analyzeConditionalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const rightExpr = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(conditionExpr)) {
            context.error(children[children.length - 1], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(leftExpr)) {
            context.error(children[children.length - 3], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(rightExpr)) {
            context.error(children[0], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        const conditionType = conditionExpr.type;
        const leftExprType = leftExpr.type;
        const rightExprType = rightExpr.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
            context.error(conditionExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: String(conditionType) });
            return null;
        }
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftExprType, rightExprType)) {
            context.error(leftExprType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditonValueTypes, {
                leftTypeName: String(leftExprType),
                rightTypeName: String(rightExprType)
            });
            return null;
        }
        if (!conditionType.readable) {
            context.error(conditionExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${conditionExpr.toCode()}` });
        }
        if (!leftExprType.readable) {
            context.error(leftExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${leftExpr.toCode()}` });
        }
        if (!rightExprType.readable) {
            context.error(rightExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${rightExpr.toCode()}` });
        }
        return new _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_24__.ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });
    }
    /**
     * AST example:
     *    AddExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_43 = '+'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeArithmeticExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        if (!left || !right) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: '[unknown]',
                rightTypeName: '[unknown]'
            });
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: String(leftType),
                rightTypeName: String(rightType)
            });
            return null;
        }
        return new _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_12__.ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });
    }
    /**
     * AST example:
     *    RelationalExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_60 = '<'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeRelationExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left && left.type;
        const rightType = right && right.type;
        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left && left.sourceNode, right && right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidRelationalOperation, {
                operator: operator,
                leftTypeName: leftType ? _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType) : '[unknown]',
                rightTypeName: rightType ? _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType) : '[unknown]'
            });
            return null;
        }
        if (!left || !right) {
            return null;
        }
        return new _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_50__.RelationalExprInstruction({ sourceNode, scope, left, right, operator });
    }
    /**
     * AST example:
     *    LogicalOrExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_OP_OR = '||'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeLogicalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left.type;
        const rightType = right.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, boolType)) {
            context.error(leftType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLogicOperation, {
                operator: operator,
                typeName: String(leftType)
            });
            return null;
        }
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(rightType, boolType)) {
            context.error(rightType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLogicOperation, {
                operator: operator,
                typeName: String(rightType)
            });
            return null;
        }
        if (!leftType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        if (!rightType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        return new _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_40__.LogicalExprInstruction({ scope, sourceNode, left, right, operator });
    }
    /**
     * AST example:
     *    InclusiveOrExpr
     *       + ComplexExpr
     *         T_PUNCTUATOR_124 = '|'
     *       + ComplexExpr
     */
    analyzeBitwiseExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        if (!left || !right) {
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidBitwiseOperation, {
                operator: operator,
                leftTypeName: String(leftType),
                rightTypeName: String(rightType)
            });
            return null;
        }
        return new _instructions_BitwiseExprInstruction__WEBPACK_IMPORTED_MODULE_15__.BitwiseExprInstruction({ scope, sourceNode, left, right, type, operator });
    }
    /**
     * AST example:
     *    AssignmentExpr
     *         T_UINT = '10'
     *         T_OP_AE = '+='
     *         T_NON_TYPE_ID = 'x'
     */
    analyzeAssignmentExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(left)) {
            // Invalid left-hand side in assignment
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLeftHandSideInAssignment, {
                operator: operator
            });
        }
        const right = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(left) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(right)) {
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        let exprType = null;
        if (operator !== '=') {
            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticAssigmentOperation, {
                    operator: operator,
                    leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType),
                    rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType)
                });
            }
        }
        else {
            exprType = rightType;
        }
        // FIXME: show corrent source nodes for left and right expression.
        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType, left.sourceNode, null, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidAssigmentOperation, {
                leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType),
                rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType)
            });
        }
        return new _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_13__.AssignmentExprInstruction({ scope, sourceNode, left, right, operator });
    }
    /**
     * AST example:
     *    T_NON_TYPE_ID = 'name'
     */
    analyzeIdExpr(context, program, sourceNode) {
        const scope = program.currentScope;
        const name = sourceNode.value;
        // beginning-of-hack
        // hack to support pseudo-dynamic expression
        //
        const exprSubst = context.expressions[name];
        if (exprSubst) {
            return exprSubst(context, program, sourceNode);
        }
        // end-of-hack
        // explicit support of built in HLSL 'NULL' define
        if (name === 'NULL') {
            // const { base, signed, heximal, exp } = parseUintLiteral('0');
            // return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal }); 
            return new _instructions_NullInstruction__WEBPACK_IMPORTED_MODULE_41__.NullInstruction({ scope, sourceNode });
        }
        const decl = scope.findVariable(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownVarName, { varName: name });
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
        return new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__.IdExprInstruction({ scope, sourceNode, id, decl });
    }
    analyzeSimpleExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        const value = sourceNode.value;
        const scope = program.currentScope;
        switch (name) {
            case 'T_UINT':
                {
                    const { base, signed, heximal, exp } = (0,_system_utils__WEBPACK_IMPORTED_MODULE_65__.parseUintLiteral)(value);
                    return new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
                }
            case 'T_FLOAT':
                return new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__.FloatInstruction({ scope, sourceNode, value: Number(value) });
            case 'T_STRING':
                return new _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_55__.StringInstruction({ scope, sourceNode, value });
            case 'T_KW_TRUE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__.BoolInstruction({ scope, sourceNode, value: true });
            case 'T_KW_FALSE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__.BoolInstruction({ scope, sourceNode, value: false });
        }
        return null;
    }
    /**
     * AST example:
     *    ConstType
     *       + Type
     */
    analyzeConstTypeDim(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length > 1) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastTypeUsage);
            return null;
        }
        const type = (this.analyzeType(context, program, children[0]));
        return type;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *       + UsageType
     */
    analyzeVarStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);
        let vars = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));
            }
        }
        return vars;
    }
    analyzeUsageStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'StructDecl') {
                type = this.analyzeStructDecl(context, program, children[i]);
                const typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__.TypeDeclInstruction({ scope, sourceNode: children[i], type });
                addTypeDecl(context, scope, typeDecl);
            }
            else if (children[i].name === 'Usage') {
                const usage = this.analyzeUsage(children[i]);
                usages.push(usage);
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type));
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, usages, type });
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *       + VariableDecl
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     *    Struct
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStruct(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let name = null;
        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {
            name = children[children.length - 2].value;
        }
        let fields = [];
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct);
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        let aligment = 1;
        if (context.cbuffer) {
            aligment = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4.size;
        }
        return new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, fields, name, aligment });
    }
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + Annotation
     *       + FunctionDef
     */
    analyzeFunctionDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const lastNodeValue = children[0].value;
        let annotation = null;
        let impl = null;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default);
        const attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        const def = this.analyzeFunctionDef(context, program, children[children.length - 1 - attrs.length]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(def)) {
            // TODO: emit proper error
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, {});
            program.pop();
            return null;
        }
        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)
        let func = globalScope.findFunction(def.name, def.params.map(asType));
        // undedined means that there are more than one instance 
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotChooseFunction, { funcName: def.name });
            program.pop();
            return null;
        }
        // todo: handle the case when definition without implementation is occured later than the found function with implementation
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func) && func.impl) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedefinition, { funcName: def.name });
            program.pop();
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(func.def.returnType, def.returnType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFuncDefenitionReturnType, { funcName: def.name });
                program.pop();
                return null;
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(context.funcDef === null);
        // TODO: rewrite context ?
        context.funcDef = def;
        if (children.length === 3) {
            annotation = this.analyzeAnnotation(context, program, children[1]);
        }
        if (lastNodeValue !== ';') {
            // TODO: do to increase scope depth inside stmt block!!
            impl = this.analyzeStmtBlock(context, program, children[0]);
        }
        program.pop();
        let hasVoidType = _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(def.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID);
        // validate unreachable code.
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl)) {
            let stmtList = impl.stmtList;
            // stmtList = stmtList.slice().reverse();
            for (let i = stmtList.length - 1; i >= 0; --i) {
                if (stmtList[i].instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_ReturnStmt) {
                    if (i != stmtList.length - 1) {
                        context.error(stmtList[i + 1].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnreachableCode);
                    }
                    break;
                }
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(scope == globalScope);
        func = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ sourceNode, scope, def, impl, annotation, attrs: attrs });
        // NOTE: possible implicit replacement of function 
        //       without implementaion inside addFunction() call.
        if (!globalScope.addFunction(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedifinition, { funcName: def.name });
        }
        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnStmtNotFound, { funcName: def.name });
        }
        return func;
    }
    /**
     * AST example:
     *    FunctionDef
     *       + ParamList
     *         T_NON_TYPE_ID = 'bar'
     *       + UsageType
     */
    analyzeFunctionDef(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nameNode = children[children.length - 2];
        const name = nameNode.value;
        const retTypeNode = children[children.length - 1];
        let returnType = this.analyzeUsageType(context, program, retTypeNode);
        // TODO: is it really needed?
        if (!returnType) {
            context.error(retTypeNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnType, { funcName: name });
            return null;
        }
        let id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name, sourceNode: nameNode });
        let semantic = null;
        if (children.length === 4) {
            semantic = this.analyzeSemantic(children[0]);
        }
        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);
        return new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic });
    }
    /**
     * AST example:
     *    ParamList
     *         T_PUNCTUATOR_41 = ')'
     *       + ParameterDecl
     *         T_PUNCTUATOR_44 = ','
     *       + ParameterDecl
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeParamList(context, program, sourceNode) {
        const children = sourceNode.children;
        let paramList = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'ParameterDecl') {
                let param = this.analyzeParameterDecl(context, program, children[i]);
                paramList.push(param);
            }
        }
        return paramList;
    }
    /**
     * AST example:
     *    ParameterDecl
     *       + Variable
     *       + ParamUsageType
     */
    analyzeParameterDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const type = this.analyzeParamUsageType(context, program, children[1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            return null;
        }
        const param = this.analyzeVariable(context, program, children[0], type);
        return param;
    }
    /**
     * AST example:
     *    ParamUsageType
     *       + Type
     *       + ParamUsage
     */
    analyzeParamUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                type = this.analyzeType(context, program, children[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'ParamUsage') {
                usages.push(this.analyzeUsage(children[i]));
            }
        }
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, type, usages });
    }
    /**
     * AST example:
     *    StmtBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + Stmt
     *       + Stmt
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeStmtBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (!children) {
            return null;
        }
        let stmtList = [];
        for (let i = children.length - 2; i > 0; i--) {
            let stmt = this.analyzeStmt(context, program, children[i]);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(stmt)) {
                stmtList.push(stmt);
            }
        }
        return new _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_54__.StmtBlockInstruction({ sourceNode, scope, stmtList });
    }
    analyzeStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        let nonAttrNode = children.length;
        let nonAttrNodeName;
        do {
            nonAttrNodeName = children[--nonAttrNode].name;
        } while (nonAttrNodeName === 'Attribute');
        switch (nonAttrNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'UseDecl':
                this.analyzeUseDecl(context, program, children[0]);
                return null;
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
            case 'T_KW_IF':
                return this.analyzeIfStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_RETURN':
                return this.analyzeReturnStmt(context, program, sourceNode);
            case 'T_KW_DO':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'StmtBlock':
                {
                    program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default);
                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);
                    program.pop();
                    return stmtBlock;
                }
            case 'T_KW_DISCARD':
            case 'T_KW_BREAK':
            case 'T_KW_CONTINUE':
                return this.analyzeBreakStmt(context, program, sourceNode);
            case 'TypeDecl':
            case 'VariableDecl':
            case 'VarStructDecl':
                return this.analyzeDeclStmt(context, program, children[0]);
            default:
                if (children.length === 2) {
                    return this.analyzeExprStmt(context, program, sourceNode);
                }
                return new _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_52__.SemicolonStmtInstruction({ sourceNode, scope });
        }
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_NON_TYPE_ID = 'y'
     *         T_KW_RETURN = 'return'
     */
    analyzeReturnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(context.func);
        const funcReturnType = context.funcDef.returnType;
        context.haveCurrentFunctionReturnOccur = true;
        if (children.length === 2) {
            tryResolveProxyType(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID);
        }
        if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID) && children.length === 3) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtVoid);
            return null;
        }
        else if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID) && children.length === 2) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtEmpty);
            return null;
        }
        let expr = null;
        if (children.length === 3) {
            expr = this.analyzeExpr(context, program, children[1]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtTypesNotEqual);
                return null;
            }
            tryResolveProxyType(funcReturnType, expr.type); // auto foo() { return typedExpr; }
            tryResolveProxyType(expr.type, funcReturnType); // typedFunc foo() { return auto; }
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expr.type, funcReturnType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtTypesNotEqual);
                return null;
            }
        }
        return new _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_51__.ReturnStmtInstruction({ sourceNode, scope, expr });
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_KW_BREAK = 'break'
     */
    analyzeBreakStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        if (operator === 'discard' && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(context.funcDef)) {
            // context.currentFunction.vertex = (false);
        }
        return new _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_17__.BreakStmtInstruction({ sourceNode, scope, operator });
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeDeclStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nodeName = sourceNode.name;
        let declList = [];
        switch (nodeName) {
            case 'TypeDecl':
                declList.push(this.analyzeTypeDecl(context, program, sourceNode));
                break;
            case 'VariableDecl':
                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));
                break;
            case 'VarStructDecl':
                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));
                break;
        }
        return new _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_26__.DeclStmtInstruction({ sourceNode, scope, declList });
    }
    analyzeExprStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const expr = this.analyzeExpr(context, program, children[1]);
        return new _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_27__.ExprStmtInstruction({ sourceNode, scope, expr });
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *       + Stmt
     *         T_KW_DO = 'do'
     */
    analyzeWhileStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isDoWhile = (children[children.length - 1].value === 'do');
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        let cond = null;
        let conditionType = null;
        let body = null;
        let operator = "do";
        if (isDoWhile) {
            operator = "do";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            body = this.analyzeStmt(context, program, children[0]);
        }
        else {
            operator = "while";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            if (isNonIfStmt) {
                body = this.analyzeNonIfStmt(context, program, children[0]);
            }
            else {
                body = this.analyzeStmt(context, program, children[0]);
            }
        }
        return new _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_63__.WhileStmtInstruction({ sourceNode, scope, cond, body, operator });
    }
    /**
     * AST example:
     *    Attribute
     *         T_PUNCTUATOR_93 = ']'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '3'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '2'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'loop'
     *         T_PUNCTUATOR_91 = '['
     */
    analyzeAttribute(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const name = children[children.length - 2].value;
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 4; i > 1; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeSimpleExpr(context, program, children[i]);
                    // TODO: emit diagnostics error
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_BoolExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FloatExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_IntExpr);
                    args.push(argumentExpr);
                }
            }
        }
        return new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__.AttributeInstruction({ scope, sourceNode, name, args });
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_KW_ELSE = 'else'
     *       + NonIfStmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_IF = 'if'
     *       + Attribute
     *       + Attribute
     */
    analyzeIfStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        let attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        const isIfElse = (children.length - attrs.length === 7);
        const condNode = children[children.length - 3 - attrs.length];
        const cond = this.analyzeExpr(context, program, condNode);
        if (!cond || !_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(asRelaxedType(cond.type), _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL)) {
            context.error(condNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });
        }
        else if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(cond.type, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL)) {
            context.warn(condNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${cond.type.name} => bool` });
        }
        let conseq = null;
        let contrary = null;
        if (isIfElse) {
            conseq = this.analyzeNonIfStmt(context, program, children[2]);
            contrary = this.analyzeStmt(context, program, children[0]);
        }
        else {
            conseq = this.analyzeNonIfStmt(context, program, children[0]);
        }
        if (!cond) {
            return null;
        }
        return new _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_35__.IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attrs: attrs });
    }
    /**
     * AST example:
     *    NonIfStmt
     *       + SimpleStmt
     */
    analyzeNonIfStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeForStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');
        let body = null;
        let init = null;
        let cond = null;
        let step = null;
        let attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        if (children[1].name === 'ERROR') {
            return null;
        }
        program.push();
        const initSourceNode = children[children.length - 3 - attrs.length];
        const condSourceNode = children[children.length - 4 - attrs.length];
        init = this.analyzeForInit(context, program, initSourceNode);
        cond = this.analyzeForCond(context, program, condSourceNode);
        step = null;
        const isEmptyInit = initSourceNode.children[0].name == 'T_PUNCTUATOR_59';
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(init) && !isEmptyInit) {
            context.error(initSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForInitEmptyIterator);
        }
        else if (init.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableDecl) {
            // EAnalyzerErrors.InvalidForInitExpr
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(cond)) {
            context.error(condSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForConditionEmpty);
        }
        else if (cond.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_RelationalExpr) {
            // EAnalyzerErrors.InvalidForConditionRelation
        }
        if (children.length === 7 + attrs.length) {
            step = this.analyzeForStep(context, program, children[2]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(step)) {
                context.error(children[2], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForStepEmpty);
            }
        }
        if (isNonIfStmt) {
            body = this.analyzeNonIfStmt(context, program, children[0]);
        }
        else {
            body = this.analyzeStmt(context, program, children[0]);
        }
        //     if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||
        //         this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||
        //         this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {
        //         // todo: rewrite this check!!
        //         // var sOperator: string = this._step.operator;
        //         // if (sOperator !== "++" && sOperator !== "--" &&
        //         //     sOperator !== "+=" && sOperator !== "-=") {
        //         //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });
        //         //     return false;
        //         // }
        //     }
        //     else {
        //         this._setError(EAnalyzerErrors.InvalidForStepExpr);
        //         return false;
        //     }
        program.pop();
        return new _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_29__.ForStmtInstruction({ sourceNode, scope, init, cond, step, body });
    }
    /**
     * AST example:
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + AssignmentExpr
     *    ForInit
     *       + VariableDecl
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + Expr
     */
    analyzeForInit(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'VariableDecl':
                // TODO: fixme!! 
                // add support for expressions like "a = 1, b = 2, c = 3"
                return this.analyzeVariableDecl(context, program, children[0])[0] || null;
            case 'Expr':
            case 'AssignmentExpr':
                return this.analyzeExpr(context, program, children[1]);
        }
        // ForInit : ';'
        return null;
    }
    /**
     * AST example:
     *    ForCond
     *         T_PUNCTUATOR_59 = ';'
     *       + RelationalExpr
     */
    analyzeForCond(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length === 1) {
            return null;
        }
        return this.analyzeExpr(context, program, children[1]);
    }
    /**
     * AST example:
     *    ForStep
     *       + UnaryExpr
     */
    analyzeForStep(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length == 0) {
            return null;
        }
        const step = this.analyzeExpr(context, program, children[0]);
        return step;
    }
    analyzePresetProperty(context, program, sourceNode) {
        const children = sourceNode.children;
        const nameNode = children[children.length - 1];
        const propName = nameNode.value;
        const propExprNode = children[children.length - 3];
        const exprNode = propExprNode.children[propExprNode.children.length - 1];
        const scope = program.currentScope;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(propName)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            return null;
        }
        const decl = scope.findVariable(propName);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.PartFx_PresetPropertyHasNotBeenFound);
            return null;
        }
        const type = decl.type;
        /**
         * AST example:
         *    PassStateExpr
         *         T_PUNCTUATOR_125 = '}'
         *         T_UINT = '1'
         *         T_PUNCTUATOR_44 = ','
         *         T_KW_TRUE = 'true'
         *         T_PUNCTUATOR_123 = '{'
         */
        const args = [];
        if (exprNode.value === '{' && propExprNode.children.length > 3) {
            for (let i = propExprNode.children.length - 2; i >= 1; i -= 2) {
                const expr = this.analyzeExpr(context, program, propExprNode.children[i]);
                // todo: use more strict check same as for InitExpr analyze
                if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expr.type, type.arrayElementType)) {
                    context.warn(propExprNode.children[i], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${expr.type.name} => ${type.arrayElementType.name}` });
                }
                args.push(expr);
            }
        }
        else {
            if (exprNode.value === '{') {
                args.push(this.analyzeExpr(context, program, propExprNode.children[1]));
            }
            else {
                args.push(this.analyzeExpr(context, program, exprNode));
            }
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ name: propName, scope, sourceNode: nameNode });
        return new _instructions_PresetProperty__WEBPACK_IMPORTED_MODULE_47__.PresetProperty({ scope, sourceNode, id, args });
    }
    analyzePresetStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let props = [];
        for (let i = children.length - 2; i >= 1; i--) {
            props.push(this.analyzePresetProperty(context, program, children[i]));
        }
        return props;
    }
    /**
     * AST example:
     *    PresetDecl
     *       + PassStateBlock
     *         T_NON_TYPE_ID = 'X'
     *         T_KW_PRESET = 'preset'
     */
    analyzePresetDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ sourceNode: children[i], scope, name });
            }
        }
        const props = this.analyzePresetStateBlock(context, program, children[0]);
        const preset = new _instructions_Preset__WEBPACK_IMPORTED_MODULE_46__.PresetInstruction({
            scope,
            sourceNode,
            id,
            props
        });
        return preset;
    }
    analyzeTechnique11Decl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let passes = null;
        let presets = null;
        for (let i = children.length - 3; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else {
                [passes] = this.analyzeTechnique11(context, program, children[i]);
            }
        }
        const technique = new _instructions_Technique11Instruction__WEBPACK_IMPORTED_MODULE_56__.Technique11Instruction({ sourceNode, name, semantic, annotation, passes, scope, presets });
        Analyzer.addTechnique11(context, program, technique);
        return technique;
    }
    /** @deprecated */
    analyzeTechniqueDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.Deprecated);
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let passes = null;
        let presets = null;
        let techniqueType = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.ETechniqueType.k_BasicFx;
        for (let i = children.length - 3; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else {
                [passes, presets] = this.analyzeTechnique(context, program, children[i]);
            }
        }
        const technique = new _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_57__.TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passes, scope, presets });
        Analyzer.addTechnique(context, program, technique);
        return technique;
    }
    /**
     * AST example:
     *    TechniqueBody
     *         T_PUNCTUATOR_125 = '}'
     *       + PassDecl
     *       + PassDecl
     *         T_PUNCTUATOR_123 = '{'
     */
    /** @deprecated */
    analyzeTechnique(context, program, sourceNode) {
        const children = sourceNode.children;
        let passes = [];
        let presets = [];
        for (let i = children.length - 2; i >= 1; i--) {
            // IP: hack to support preset extension
            if (children[i].children[0].name === 'PresetDecl') {
                let preset = this.analyzePresetDecl(context, program, children[i].children[0]);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(preset));
                presets.push(preset);
                continue;
            }
            let pass = this.analyzePassDecl(context, program, children[i]);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
            passes.push(pass);
        }
        return [passes, presets];
    }
    /**
     * AST example:
     *    Technique11Body
     *         T_PUNCTUATOR_125 = '}'
     *       + Pass11Decl
     *         T_PUNCTUATOR_123 = '{'
     */
    // todo: add preset support (!)
    // see analyzeTechnique() for example.
    analyzeTechnique11(context, program, sourceNode) {
        const children = sourceNode.children;
        let passes = [];
        let iPass = 0;
        for (let i = children.length - 2; i >= 1; i--) {
            let pass = this.analyzePass11Decl(context, program, children[i], iPass);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
            passes.push(pass);
        }
        return [passes];
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *       + Annotation
     *         T_NON_TYPE_ID = 'name'
     *         T_KW_PASS = 'pass'
     */
    /** @deprecated */
    analyzePassDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name });
            }
        }
        const pass = new _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_42__.PassInstruction({
            scope,
            sourceNode,
            renderStates,
            id,
            pixelShader: entry.pixel,
            vertexShader: entry.vertex
        });
        //TODO: add annotation and id
        return pass;
    }
    /**
     * AST example:
     *    Pass11Decl
     *       + StmtBlock
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_PASS = 'pass'
     */
    analyzePass11Decl(context, program, sourceNode, iPass = 0) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name, sourceNode: children[i] });
            }
        }
        if (!id) {
            // create fake pass name for better readability
            id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: `auto_pass_${iPass}` });
        }
        const impl = this.analyzeStmtBlock(context, program, children[0]);
        const returnType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID, scope);
        const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, id, returnType });
        const pass11 = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ scope, sourceNode, impl, def });
        //TODO: add annotation and id
        return pass11;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'VertexShader'
     */
    /** @deprecated */
    analyzePassStateBlockForShaders(context, program, sourceNode) {
        const children = sourceNode.children;
        let pixel = null;
        let vertex = null;
        const supportedTypeNames = ['vertexshader', 'pixelshader'];
        for (let i = children.length - 2; i >= 1; i--) {
            let func = null;
            const childrenIth = children[i].children;
            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();
            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {
                continue;
            }
            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
                switch (shaderTypeName) {
                    case 'vertexshader':
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(vertex == null);
                        vertex = func;
                        break;
                    case 'pixelshader':
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(pixel == null);
                        pixel = func;
                        break;
                    default:
                        // TODO: make error!
                        console.error('function is not suitable as shader entry point');
                }
            }
        }
        return { vertex, pixel };
    }
    analyzePassStateForShader(context, program, sourceNode, shaderType) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(shaderType === 'vertexshader' || shaderType === 'pixelshader');
        const children = sourceNode.children;
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        const compileExpr = this.analyzeExpr(context, program, exprNode);
        if (!compileExpr) {
            return null;
        }
        const shaderFunc = compileExpr.function;
        if (shaderType === 'vertexshader') {
            if (!checkForVertexUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });
            }
        }
        else {
            if (!checkForPixelUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });
            }
        }
        return shaderFunc;
    }
    /**
     * AST example:
     *    StateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + State
     *       + State
     *       + State
     *         T_PUNCTUATOR_123 = '{'
     */
    /**
     * AST example:
     *    StateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + StateBlock
     *         T_PUNCTUATOR_44 = ','
     *       + StateBlock
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeStateBlock(context, program, sourceNode, type) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (!type.isNotBaseArray()) {
            let props = {};
            for (let i = children.length - 2; i >= 1; i--) {
                props = { ...props, ...this.analyzeState(context, program, children[i]) };
            }
            return new _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__.StateBlockInstruction({ scope, sourceNode, type, props });
        }
        else {
            let blocks = [];
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].value === ',')
                    continue;
                blocks = [...blocks, this.analyzeStateBlock(context, program, children[i], type.subType)];
            }
            return new _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__.StateBlockInstruction({ scope, sourceNode, type, blocks });
        }
    }
    /**
     * AST example:
     *    State
     *         T_PUNCTUATOR_59 = ';'
     *       + StateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'ZWRITE'
     */
    analyzeState(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateName = children[children.length - 1].value;
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value)) {
            console.warn('state is incorrect.'); // TODO: move to warnings
            return {};
        }
        let states = {};
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                values[j] = stateExprNode.children[i].value;
            }
            // todo: convert values to native types
            states[stateName] = values;
        }
        else {
            let value = '';
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value;
            }
            else {
                value = exprNode.value;
            }
            // todo: convert value to native type
            states[stateName] = value;
        }
        return states;
    }
    /**
     * AST example:
     *    PassStateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + PassState
     *       + PassState
     *       + PassState
     *         T_PUNCTUATOR_123 = '{'
     */
    /** @deprecated */
    analyzePassStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePassState(context, program, children[i]) };
        }
        return states;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'ZWRITE'
     */
    analyzePassState(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateType = children[children.length - 1].value.toUpperCase();
        const stateName = _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates[stateType];
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__.isNumber)(stateName)) {
            return {};
        }
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            return {};
        }
        let renderStates = {};
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());
            }
            switch (stateName) {
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNC:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = values[1];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNCSEPARATE:
                    if (values.length !== 4) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = values[2];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = values[3];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONSEPARATE:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA] = values[1];
                    break;
                default:
                    console.warn('Pass state is incorrect.');
                    return {};
            }
        }
        else {
            let value = '';
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            const stateValue = getRenderStateValue(stateName, value);
            if (stateValue !== _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF) {
                switch (stateName) {
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATION:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA] = stateValue;
                        break;
                    default:
                        renderStates[stateName] = stateValue;
                        break;
                }
            }
        }
        return renderStates;
    }
    /**
     * AST example:
     *    ImportDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_IMPORT = 'import'
     */
    // TODO: restore functionality! 
    analyzeImportDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const componentName = this.analyzeComplexName(children[children.length - 2]);
        // if (!isNull(technique)) {
        //     //We can import techniques from the same file, but on this stage they don`t have component yet.
        //     //So we need special mehanism to add them on more belated stage
        //     // let sShortedComponentName: string = componentName;
        //     if (!isNull(context.moduleName)) {
        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + ".", "");
        //     }
        //     throw null;
        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];
        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {
        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);
        //     //     return;
        //     // }
        // }
        const sourceTechnique = null; //fx.techniques[componentName];
        if (!sourceTechnique) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.ImportedComponentNotExists, { componentName: componentName });
            return null;
        }
        return null;
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children[children.length - 2].value;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct);
        let fields = [];
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        return new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, name, fields });
    }
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + VariableDim
     *       + ConstType
     *         T_KW_TYPEDEF = 'typedef'
     */
    analyzeTypedefDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        // TODO: rework to support complex typ defenitions like 
        //  typedef const float4 TYPE_T;
        //          ^^^^^^
        // IP: at the moment type defenitions are not supported
        const vdimNode = children[1];
        const alias = vdimNode.children[0].value;
        const type = this.analyzeConstTypeDim(context, program, children[2]);
        // this.analyzeConstTypeDim() <= doesn't support 'const float' like expressions with modifiers
        // const type = new TypeAlias()
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // add support for typealiases
        const typedef = new _instructions_TypedefInstruction__WEBPACK_IMPORTED_MODULE_59__.TypedefInstruction({ scope, sourceNode, type, alias });
        addTypeAlias(context, scope, typedef);
        return typedef;
    }
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + StructDecl
     */
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + VariableDim
     *       + ConstType
     *         T_KW_TYPEDEF = 'typedef'
     */
    analyzeTypeDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        if (children.length === 2) {
            type = this.analyzeStructDecl(context, program, children[1]);
        }
        else if (children.length === 4) {
            return this.analyzeTypedefDecl(context, program, sourceNode);
        }
        else {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedTypeDecl);
        }
        const typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__.TypeDeclInstruction({ scope, sourceNode, type });
        addTypeDecl(context, scope, typeDecl);
        return typeDecl;
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'TechniqueDecl':
                return [this.analyzeTechniqueDecl(context, program, sourceNode)];
            case 'Technique11Decl':
                return [this.analyzeTechnique11Decl(context, program, sourceNode)];
            case 'UseDecl':
                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!
                return null;
            case 'ImportDecl':
                return [this.analyzeImportDecl(context, program, sourceNode)];
            case 'ProvideDecl':
                return [this.analyzeProvideDecl(context, program, sourceNode)];
            case 'TypeDecl':
                return [this.analyzeTypeDecl(context, program, sourceNode)];
            case 'VariableDecl':
                return this.analyzeVariableDecl(context, program, sourceNode);
            case 'VarStructDecl':
                return this.analyzeVarStructDecl(context, program, sourceNode);
            case 'FunctionDecl':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(program.currentScope == program.globalScope);
                let fdecl = null;
                context.beginFunc();
                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);
                context.endFunc();
                return [fdecl];
            case 'CbufferDecl':
                return [this.analyzeCbufferDecl(context, program, sourceNode)];
            case 'SamplerStateDecl':
                return [this.analyzeSamplerStateDecl(context, program, sourceNode)];
            case 'T_PUNCTUATOR_59':
                context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.EmptySemicolon);
                return null;
            default:
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, { name });
        }
        return null;
    }
    analyzeGlobals(context, program, slastDocument) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(slastDocument) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(slastDocument.root)) {
            return null;
        }
        const children = slastDocument.root.children;
        let globals = [];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(children)) {
            return [];
        }
        for (let i = children.length - 1; i >= 0; i--) {
            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));
        }
        return globals.filter(decl => !!decl);
    }
    createContext(uri, expressions) {
        return new Context(uri, expressions);
    }
    // create new scope
    createProgram(document = null) {
        let parent = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            parent = document.root.scope;
        }
        return new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScope(parent);
    }
    // extends existing scoope
    createProgramEx(document = null) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return this.createProgram();
        }
        return new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScopeEx(document.root.scope);
    }
    /**
     * Post-analysis validation.
     */
    validate(context, program, root) {
        checkFunctionsForRecursion(context, program);
        program.validate();
    }
    /**
     * Create a new standalone document.
     * @param slastDocument
     * @param document Context source. The scope of the parent document will be used when creating a new one.
     * @returns
     */
    parse(slastDocument, document) {
        const uri = slastDocument.uri;
        const program = this.createProgram(document);
        const context = this.createContext(uri);
        let instructions = null;
        try {
            instructions = this.analyzeGlobals(context, program, slastDocument);
        }
        catch (e) {
            // critical errors were occured
            // throw e;
            console.error(e);
        }
        const root = new _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__.InstructionCollector({ scope: program.globalScope, instructions });
        this.validate(context, program, root);
        const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__.Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);
        return { root, diagnosticReport, uri };
    }
    /**
     * Extend existing document. (Base document stay unchanged (!))
     * @param slastAddition Extension. (Can be null if just copy of base document is needed.)
     * @param slBase Original document to be extneded.
     * @param options
     * @returns
     *
     * The idea is to create new documents which references to existings scope and extends
     * existings instruction list, but leave parent document unchanged.
     */
    extend(slastAddition, slBase, expressions) {
        let uri = slBase.uri;
        // new program (scope chain) holds links to known variales, types etc of parent document
        let program = this.createProgramEx(slBase);
        // context is absolutely new (!)
        let context = this.createContext(uri, expressions);
        let instructions = slBase.root.instructions;
        let diagnosticReport = slBase.diagnosticReport;
        if (slastAddition) {
            uri = slastAddition.uri;
            try {
                // new list holds links to existings instructions (!)
                instructions = instructions.concat(this.analyzeGlobals(context, program, slastAddition));
            }
            catch (e) {
                // critical errors were occured
                // throw e;
                console.error(e);
            }
            diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__.Diagnostics.mergeReports([diagnosticReport, slastAddition.diagnosticReport, context.diagnostics.resolve()]);
        }
        const root = new _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__.InstructionCollector({ scope: program.globalScope, instructions });
        this.validate(context, program, root);
        return { root, diagnosticReport, uri };
    }
    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {
    //     if (isSystemFunction(func)) {
    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });
    //     }
    //     let isFunctionAdded: boolean = program.addFunction(func);
    //     if (!isFunctionAdded) {
    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });
    //     }
    // }
    static addTechnique11(context, program, technique) {
        let name = technique.name;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(program.globalScope.findTechnique11(name))) {
            context.error(technique.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TechniqueNameRedefinition, { techName: name });
            return;
        }
        program.globalScope.addTechnique11(technique);
    }
    /** @deprecated */
    static addTechnique(context, program, technique) {
        let name = technique.name;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(program.globalScope.findTechnique(name))) {
            context.error(technique.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TechniqueNameRedefinition, { techName: name });
            return;
        }
        program.globalScope.addTechnique(technique);
    }
    /**
    * Check the possibility of using the operator between the two types.
    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.
     *
     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =
     * @leftType {ITypeInstruction} Type of the left side of the expression.
     * @rightType {ITypeInstruction} Type of the right side of the expression.
     */
    static checkTwoOperandExprTypes(context, operator, leftType, rightType, leftSourceNode = null, rightSourceNode = null, exprSourceNode = null, { isInitializing = false } = {}) {
        if (!leftType || !rightType) {
            return null;
        }
        leftSourceNode = leftSourceNode || leftType.sourceNode;
        rightSourceNode = rightSourceNode || rightType.sourceNode;
        const isComplex = leftType.isComplex() || rightType.isComplex();
        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();
        // const isSampler = isSamplerType(leftType) || isSamplerType(rightType);
        const constBoolType = (len) => {
            if (len >= 1 && len <= 4) {
                let ba = [_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL2, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL3, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL4];
                return _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrapAsConst(ba[len - 1], _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            console.error('unsupported code branch');
            return null;
        };
        if (isArray /* || isSampler*/) {
            // TODO: allow expressions like: arr1 = arr2; ??
            return null;
        }
        if (Analyzer.isAssignmentOperator(operator)) {
            if (!leftType.writable && !isInitializing) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
            if (operator !== '=' && !leftType.readable) {
                // temp solution for cases like:
                // void f(out int x) 
                // {
                //      x = 10;
                //      x |= 1; // << allow to write here
                // }
                context.error(exprSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `lvalue is not readable` });
            }
        }
        else {
            if (!leftType.readable) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
        }
        if (isComplex) {
            if (operator === '=' && _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, rightType)) {
                return leftType;
            }
            // samplers and arrays can't be compared directly
            else if (Analyzer.isEqualityOperator(operator) && !leftType.isComplex()) {
                return constBoolType(1);
            }
            // TODO: emit error (unsupported operation on complex values)
            return null;
        }
        // FIXME: use operands' scope instead of system scope?
        let leftBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(leftType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        let rightBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(rightType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        if (Analyzer.isBitwiseOperator(operator)) {
            if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(leftType) &&
                !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(leftType)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(leftType)) {
                    // todo: use correct error
                    context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastUnknownType, { tooltip: `${leftType.name} => int` });
                }
                else {
                    context.warn(leftSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });
                }
                leftBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(rightType) &&
                !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(rightType)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(rightType)) {
                    // todo: use correct error
                    context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastUnknownType, { tooltip: `${rightType.name} => int` });
                }
                else {
                    context.warn(rightSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });
                }
                rightBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            switch (operator) {
                case '&':
                case '|':
                case '^':
                    if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftBaseType, rightType)) {
                        // TODO: emit warning (bitwise between int and uint)
                    }
            }
            return leftBaseType;
        }
        // hack to allow int/uint comparisson
        if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, asRelaxedType(rightType))) {
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, rightType)) {
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${leftType.name} [${operator}] ${rightType.name}` });
            }
            if (Analyzer.isArithmeticalOperator(operator)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {
                    return leftBaseType;
                }
                // TODO: emit error (cannot perfome devision with matrices)
                return null;
            }
            else if (Analyzer.isRelationalOperator(operator)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(leftType) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(leftType)) {
                    return constBoolType(leftType.length);
                }
                // TODO: allow vectors? for ex: vec3 < vec3 => bool3
                // TODO: emit error (cannot perfome comparison with non-scalar)
                return null;
            }
            else if (Analyzer.isEqualityOperator(operator)) {
                return constBoolType(leftType.length);
            }
            else if (operator === '=') {
                return leftBaseType;
            }
            // TODO: emit error (unknonw operation)
            return null;
        }
        // op: "+", "-", "*", "/"
        //     "+=", "-=", "*=", "/=", "%="
        if (Analyzer.isArithmeticalOperator(operator)) {
            // op: "+", "-", "*", "/", "%"
            const length = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(leftType)
                ? rightType.length
                : _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(rightType)
                    ? leftType.length
                    : Math.min(leftType.length, rightType.length);
            const baseType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determMostPreciseBaseType(leftType, rightType);
            const resultType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(`${baseType.name}${length === 1 ? '' : length}`);
            if (!resultType) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `cannot determ result type for "${leftType.toCode()} ${operator} ${rightType.toCode()}"`);
                return null;
            }
            // op: "+=", "-=", "*=", "/=", "%="
            if (Analyzer.isAssignmentOperator(operator)) {
                if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, resultType)) {
                    // TODO: add support for imlicit conversions
                    // TODO: emit error (operator cannot be used with a given lvalue)
                    context.error(exprSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.OperatorCannotBeUsedWithGivenLValue, {});
                    return null;
                }
            }
            if (resultType.length < leftType.length || resultType.length < rightType.length) {
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeTruncation, {
                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`
                });
            }
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.determBaseType(leftType), _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determBaseType(rightType))) {
                // do not emit errors for expr like: float2 * float, int2 + int etc..
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`
                });
            }
            /**
             * Special case for matrices
             */
            if (operator === '*' || operator === '*=') {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(leftType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(rightType)) {
                    if (leftType.length === rightType.length) {
                        return rightBaseType;
                    }
                    return null;
                }
                else if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(rightType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(leftType)) {
                    if (leftType.length === rightType.length) {
                        return leftBaseType;
                    }
                    return null;
                }
            }
            return resultType;
        }
        if (operator === '=') {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(rightType)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.determTypePrecision(leftType) > _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determTypePrecision(rightType)) {
                    context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`
                    });
                    return leftType;
                }
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntegerType(leftType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntegerType(rightType)) {
                    context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`
                    });
                    return leftType;
                }
            }
        }
        return null;
    }
    /**
     * Check the ability to use the operator to the data type.
     * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.
     *
     * @operator {string} One of the operators: + - ! ++ --
     * @leftType {IVariableTypeInstruction} Operand type
     */
    static checkOneOperandExprType(context, sourceNode, operator, type) {
        const isComplex = type.isComplex();
        const isArray = type.isNotBaseArray();
        // const isSampler = isSamplerType(type);
        if (isComplex || isArray /* || isSampler*/) {
            return null;
        }
        if (!type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        if (operator === '++' || operator === '--') {
            if (!type.writable) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
            }
            return type;
        }
        if (operator === '!') {
            const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
            // validate(boolType, EInstructionTypes.k_VariableDecl);
            if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(type, boolType)) {
                return boolType;
            }
            else {
                return null;
            }
        }
        else {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(type)) {
                return null;
            }
            else {
                return type.baseType; // << TODO: fixme!!!! remove "any"!
            }
        }
        return null;
    }
    static isAssignmentOperator(operator) {
        return operator === '+=' || operator === '-=' ||
            operator === '*=' || operator === '/=' ||
            operator === '%=' || operator === '=' ||
            operator === '|=' || operator === '&=' ||
            operator === '>>=' || operator === '<<=' || operator === '^=';
    }
    static isBitwiseOperator(operator) {
        return operator === '>>' || operator === '<<' ||
            operator === '|' || operator === '&' || operator === '^' ||
            operator === '|=' || operator === '&=' ||
            operator === '>>=' || operator === '<<=' || operator === '^=';
    }
    static isArithmeticalOperator(operator) {
        return operator === '+' || operator === '+=' ||
            operator === '-' || operator === '-=' ||
            operator === '*' || operator === '*=' ||
            operator === '/' || operator === '/=' ||
            operator === '%' || operator === '%=';
    }
    static isRelationalOperator(operator) {
        return operator === '>' || operator === '>=' ||
            operator === '<' || operator === '<=';
    }
    static isEqualityOperator(operator) {
        return operator === '==' || operator === '!=';
    }
}


/***/ }),

/***/ "rHPT":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/FxAnalyzer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FxAnalyzer": () => (/* binding */ FxAnalyzer),
/* harmony export */   "FxContext": () => (/* binding */ FxContext)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");
/* harmony import */ var _Analyzer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Analyzer */ "R35j");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instructions/IdInstruction */ "Muaz");
/* harmony import */ var _instructions_part_DrawInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./instructions/part/DrawInstruction */ "9jn4");
/* harmony import */ var _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instructions/part/PartFxInstruction */ "0Qwk");
/* harmony import */ var _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./instructions/part/PartFxPassInstruction */ "pCHB");
/* harmony import */ var _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instructions/part/SpawnInstruction */ "sg/T");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SystemScope */ "c0pO");














const asType = (instr) => instr ? instr.type : null;
class FxContext extends _Analyzer__WEBPACK_IMPORTED_MODULE_6__.Context {
    constructor() {
        super(...arguments);
        this.spawnStmts = [];
        this.drawStmts = [];
    }
    // beginFunc(): void {
    //     super.beginFunc();
    // }
    // endFunc(): void {
    //     super.endFunc();
    // }
    beginPartFxPass() {
        this.beginPass();
        this.particleInstance = null;
    }
    endPartFxPass() {
        this.particleInstance = null;
        this.endPass();
    }
    beginPartFx() {
        this.particleCore = null;
    }
    endPartFx() {
        this.particleCore = null;
    }
}
function sliceNode(source, from, to) {
    const { children, parent, name, value, loc } = source;
    return {
        children: children.slice(from, to),
        parent,
        name,
        value,
        loc
    };
}
class FxAnalyzer extends _Analyzer__WEBPACK_IMPORTED_MODULE_6__.Analyzer {
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'Init'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '10'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_SPAWN = 'spawn'
     */
    analyzeSpawnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children.slice(-5, -4)[0].value;
        const args = [];
        for (let i = children.length - 7; i >= 2; i--) {
            if (children[i].value !== ',') {
                const arg = this.analyzeExpr(context, program, children[i]);
                args.push(arg);
            }
        }
        // const { base, signed, heximal, exp } = parseUintLiteral(children.slice(-3, -2)[0].value);
        // const count = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
        const count = this.analyzeExpr(context, program, children.slice(-3, -2)[0]);
        // find function name(args)
        const spawnStmt = new _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_11__.SpawnInstruction({ sourceNode, scope, name, args, count });
        context.spawnStmts.push(spawnStmt);
        return spawnStmt;
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'part'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_DRAW = 'draw'
     */
    analyzeDrawStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children[children.length - 2].value;
        const args = [];
        for (let i = children.length - 4; i >= 2; i--) {
            if (children[i].value !== ',') {
                const arg = this.analyzeExpr(context, program, children[i]);
                args.push(arg);
            }
        }
        const instr = new _instructions_part_DrawInstruction__WEBPACK_IMPORTED_MODULE_8__.DrawInstruction({ sourceNode, scope, name, args });
        const ctx = context.funcDef;
        context.drawStmts.push({ instr, ctx });
        return instr;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_SPAWN':
                return this.analyzeSpawnStmt(context, program, sourceNode);
            case 'T_KW_DRAW':
                return this.analyzeDrawStmt(context, program, sourceNode);
            default:
                return super.analyzeSimpleStmt(context, program, sourceNode);
        }
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_PASS = 'pass'
     */
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *         T_KW_PASS = 'pass'
     */
    analyzePartFXPassDecl(context, program, sourceNode) {
        context.beginPartFxPass();
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        // temp solution in order to not highlight useless pass states in the next analysis call.
        context.renderStates = renderStates;
        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);
        let sorting = (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(fxStates.sorting) ? fxStates.sorting : false;
        const prerenderRoutine = fxStates.prerenderRoutine || null;
        const geometry = fxStates.geometry || null;
        const instanceCount = fxStates.instanceCount || 1;
        if (sorting && prerenderRoutine && _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(prerenderRoutine.function.def.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID)) {
            context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_SortingCannotBeApplied);
            context.warn(prerenderRoutine.function.def.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_SortingCannotBeApplied);
        }
        //
        // Validation of the shader input
        //
        let pixelShader = entry.pixel;
        /**
         * Vertex shader validation pattern:
         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);
         */
        let vertexShader = entry.vertex;
        if (vertexShader) {
            const requiredSemantics = ['POSITION', 'POSITION0'];
            let hasInstance = false;
            let hasRequiredSemantics = false;
            for (const param of vertexShader.def.params) {
                hasInstance = hasInstance ||
                    param.type.subType === context.particleInstance;
                hasRequiredSemantics = hasRequiredSemantics ||
                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));
            }
            if (!hasInstance) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_VertexShaderParametersMismatch, { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });
                vertexShader = pixelShader = null;
            }
            // if (!hasRequiredSemantics) {
            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,
            //         { tooltip: 'doesn\'t have requiredsemantics.' });
            //     vertexShader = pixelShader = null;
            // }
        }
        //
        // Rest
        //
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_7__.IdInstruction({ sourceNode: children[i], scope, name });
            }
        }
        let drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__.EPassDrawMode.k_Auto;
        if (id) {
            if (context.drawStmts.find(x => x.instr.name == id.name)) {
                drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__.EPassDrawMode.k_Manual;
            }
        }
        const pass = new _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_10__.PartFxPassInstruction({
            scope,
            sourceNode,
            id,
            sorting,
            geometry,
            instanceCount,
            prerenderRoutine,
            drawMode,
            renderStates,
            pixelShader,
            vertexShader
        });
        //TODO: add annotation and id
        context.endPartFxPass();
        return pass;
    }
    // TODO: use explicit return type
    analyzePartFxStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };
        }
        return states;
    }
    /**
    * AST example:
    *    PassState
    *         T_PUNCTUATOR_59 = ';'
    *       + PassStateExpr
    *         T_PUNCTUATOR_61 = '='
    *         T_NON_TYPE_ID = 'STATE_ONE'
    */
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'STATE_TWO'
     */
    /**
     * AST example:
     *    PassStateExpr
     *         T_PUNCTUATOR_125 = '}'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_44 = ','
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_123 = '{'
     */
    // TODO: add explicit type for fx statess
    analyzePartFXPassProperies(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateName = children[children.length - 1].value.toUpperCase();
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        let fxStates = {};
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(stateName)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            // TODO: return correct state list
            return fxStates;
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_PUNCTUATOR_125 = '}'
         *         T_UINT = '1'
         *         T_PUNCTUATOR_44 = ','
         *         T_KW_TRUE = 'true'
         *         T_PUNCTUATOR_123 = '{'
         */
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                // TODO: validate values with names
                values[j] = stateExprNode.children[i].value.toUpperCase();
            }
            switch (stateName) {
                // case ERenderStates.BLENDFUNC:
                //     if (values.length !== 2) {
                //         console.warn('Pass state are incorrect.');
                //         return {};
                //     }
                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];
                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];
                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];
                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];
                //     break;
                default:
                    console.warn('Pass fx state is incorrect.');
                    return fxStates;
            }
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_NON_TYPE_ID = 'FALSE'
         */
        else {
            let value = null;
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            switch (stateName) {
                case ('InstanceCount'.toUpperCase()):
                    fxStates.instanceCount = Number(value) || 1;
                    break;
                case ('Geometry'.toUpperCase()):
                    // Geometry = "sfx_leaves";
                    if (exprNode.name == "T_STRING") {
                        value = value.replace(/^"(.+)"$/, '$1');
                    }
                    // Geometry = Sphere;
                    else {
                        console.assert(exprNode.name === 'T_NON_TYPE_ID');
                    }
                    fxStates.geometry = value.toLowerCase();
                    break;
                case ('Sorting'.toUpperCase()):
                    // TODO: use correct validation with diag error output
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(value == 'TRUE' || value == 'FALSE');
                    fxStates.sorting = (value === 'TRUE');
                    break;
                case ('PrerenderRoutine'.toUpperCase()):
                    {
                        /**
                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.
                        */
                        let validators = [
                            /* void prerender(in Part part, inout PartInstance instance) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [context.particleCore, null] },
                            /* void prerender(in Part part, inout PartInstance instance, int instanceId) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [context.particleCore, null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                            /* int prerender(in Part part, inout PartInstance instance) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [context.particleCore, null] },
                            /* int prerender(in Part part, inout PartInstance instance, int instanceId) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [context.particleCore, null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                        ];
                        //
                        // TODO: add string-based validators like this:
                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);
                        //
                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);
                        if (!prerenderRoutine) {
                            break;
                        }
                        //
                        // check arguments
                        //
                        let fn = prerenderRoutine.function;
                        /** first argument's type */
                        let argv = fn.def.params.map(param => param.type);
                        if (argv.length < 2) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });
                            prerenderRoutine = null;
                        }
                        if (!argv[0].readable || argv[0].subType !== context.particleCore ||
                            argv[0].isNotBaseArray() ||
                            !(argv[1].usages.includes('out') || argv[1].usages.includes('inout')) || !argv[1].writable || argv[1].isNotBaseArray()) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });
                            prerenderRoutine = null;
                        }
                        //         argv[1]: "out PartInstance"
                        // argv[1].subType: "PartInstance"
                        context.particleInstance = argv[1].subType;
                        fxStates.prerenderRoutine = prerenderRoutine;
                    }
                    break;
                default:
            }
        }
        return fxStates;
    }
    analyzePartFXBody(context, program, sourceNode) {
        let passes = [];
        let spawnRoutine = null;
        let initRoutine = null;
        let updateRoutine = null;
        let particle = null;
        let capacity = null;
        const children = sourceNode.children;
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassState':
                    {
                        let sourceNode = children[i];
                        let stateName = sourceNode.children[3].value; // "T_NON_TYPE_ID"
                        switch (stateName.toUpperCase()) {
                            case ('Capacity'.toUpperCase()):
                                {
                                    // TODO: make correct validation of the capacity value and emit errors
                                    //       through diagnostics system. 
                                    const snum = sourceNode.children[1].children[0].value;
                                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(Number(snum)));
                                    capacity = Number(snum) || -1;
                                    // capacity must be multiple of 64 because of group size is 64
                                    // and we run thread for every alive particle
                                    // todo: fix it usind condition in the beginning of the shader
                                    capacity = Math.floor((capacity + 63) / 64) * 64;
                                    break;
                                }
                            case ('SpawnRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Spawn routine expected as 'int spawn(void)'.
                                     */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [/.*/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [] }, // void f(void)
                                    ];
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    const params = spawnRoutine.function.def.params;
                                    if (params.length > 0) {
                                        if (!params[0].type.usages.includes('inout')) {
                                            context.warn(params[0].type.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_EmitterPersistentDataMustBeMarkedAsInout);
                                        }
                                    }
                                }
                                break;
                            case ('InitRoutine'.toUpperCase()):
                                {
                                    /** Init routine expected as 'void init(in Part part)'. */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null, /u?int/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null, /u?int/, /u?int/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null] }, /* init(PART part) */
                                    ];
                                    // TODO: show error in case of both functions are found
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!initRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    let fn = initRoutine.function;
                                    /** first argument's type */
                                    let type = fn.def.params[0].type;
                                    if ((!type.usages.includes('out') && !type.usages.includes('inout')) || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        initRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                            case ('UpdateRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Update routine expected as 'void update(inout Part part)'.
                                     */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL, args: [null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL, args: [null] }, /* update(PART part) */
                                    ];
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    const fn = updateRoutine.function;
                                    const fdef = fn.def;
                                    const paramList = fdef.params;
                                    if (paramList.length < 1 || paramList.length > 2) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    /** first argument's type */
                                    let type = paramList[0].type;
                                    if (!type.usages.includes('out') && !type.usages.includes('inout') || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    //
                                    // Check return type
                                    //
                                    if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(fdef.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL)) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });
                                        updateRoutine = null;
                                    }
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                        }
                    }
                    break;
            }
        }
        // Note: all fx properties should be parsed prior to pass declaraion analysis
        // because some of them are critical for pass validation
        context.particleCore = particle;
        const presets = [];
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassDecl':
                    {
                        // hack to support presets extension
                        if (children[i].children[0].name === 'PresetDecl') {
                            presets.push(this.analyzePresetDecl(context, program, children[i].children[0]));
                            break;
                        }
                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);
                        if (!pass.isValid()) {
                            context.warn((pass.id && pass.id.sourceNode) || children[i], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.IncompletePass, {
                                techniqueName: pass.name,
                                tooltip: `The pass is not completed. Not all required parameters are specified.`
                            });
                        }
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
                        passes.push(pass);
                    }
                    break;
            }
        }
        return { passes, spawnRoutine, initRoutine, updateRoutine, particle, capacity, presets };
    }
    /**
     * AST example:
     *    PartFxDecl
     *       + PartFxBody
     *       + Annotation
     *       + Semantic
     *       + ComplexNameOpt
     *         T_KW_FXPART = 'partFx'
     */
    analyzePartFXDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let props = null;
        context.beginPartFx();
        for (let i = children.length - 3; i >= 0; i--) {
            switch (children[i].name) {
                case 'Annotation':
                    annotation = this.analyzeAnnotation(context, program, children[i]);
                    break;
                case 'Semantic':
                    semantic = this.analyzeSemantic(children[i]);
                    break;
                case 'PartFxBody':
                    props = this.analyzePartFXBody(context, program, children[i]);
                    break;
            }
        }
        //
        // draw operator finalization
        //
        for (const stmt of context.drawStmts) {
            const { instr, ctx } = stmt;
            const pass = props.passes.find(pass => pass.id.name == instr.name);
            if (!pass) {
                // emit warning not an error
                // because in some cases it may be useful to have several effects with
                // common update routine but different pass set
                context.warn(instr.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_RenderPassWasNotFound, {
                    techniqueName: name,
                    tooltip: `The technique doesn't have pass with name <${instr.name}>`
                });
            }
            const p0Type = ctx.params[0].type;
            if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(p0Type, context.particleCore) || !p0Type.readable) {
                context.error(instr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_DrawOpOnlyAllowedWithinUpdateRoutine, { tooltip: 'Draw operator only allowed within update routine' });
            }
        }
        context.endPartFx();
        const partFx = new _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_9__.PartFxInstruction({
            sourceNode, name, semantic, annotation, scope, ...props
        });
        if (!partFx.isValid()) {
            // highlight name only
            context.warn(children[children.length - 2], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.IncompleteTechnique, {
                techniqueName: partFx.name,
                tooltip: `The technique is not completed. Not all required parameters are specified.`
            });
        }
        FxAnalyzer.addTechnique(context, program, partFx);
        return partFx;
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'PartFxDecl':
                return [this.analyzePartFXDecl(context, program, sourceNode)];
            default:
                return super.analyzeUnknDecl(context, program, sourceNode);
        }
    }
    createContext(uri) {
        return new FxContext(uri);
    }
    validate(context, program, root) {
        super.validate(context, program, root);
        const scope = program.globalScope;
        if (!root.instructions) {
            return;
        }
        // NOTE: all effects are assumed to be valid
        const fxList = root.instructions.filter(instr => instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_PartFxDecl);
        //
        // spawn operator validation
        //
        for (const spawnStmt of context.spawnStmts) {
            const bImportedEffect = false;
            //parse as the spawn from the same effect
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!bImportedEffect, 'unsupported');
            if (!bImportedEffect) {
                let initializer = null;
                for (const fx of fxList) {
                    // looking for:
                    // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)
                    // Init(out Part part, int partId: PART_ID, ...parameters)
                    // Init(out Part part, ...parameters)
                    let argsList = [[/u?int/, /u?int/], [/u?int/], []]
                        .map(v => [fx.particle, ...v, ...spawnStmt.args.map(asType)]);
                    for (const args of argsList) {
                        initializer = scope.findFunction(spawnStmt.name, args);
                        if (initializer) {
                            break;
                        }
                    }
                    if (initializer) {
                        // spawnStmt.$resolve(fx, initializer);
                        break;
                    }
                }
                if (!initializer) {
                    context.error(spawnStmt.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_InvalidSpawnStmtInitializerNotFound, { tooltip: 'Invalid spawn statement. Effect initializer not found.' });
                }
            }
        }
    }
}


/***/ }),

/***/ "zHDc":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/ProgramScope.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProgramScope": () => (/* binding */ ProgramScope),
/* harmony export */   "ProgramScopeEx": () => (/* binding */ ProgramScopeEx),
/* harmony export */   "Scope": () => (/* binding */ Scope)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ "pEQR");




class Scope {
    constructor(params) {
        let type;
        let strictMode;
        let parent;
        if (params instanceof Scope) {
            let scope = params;
            ({ type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default, parent = null, strictMode = false } = scope);
            this.variables = { ...(scope.variables) };
            this.types = { ...scope.types };
            this.functions = { ...scope.functions };
            this.techniques = { ...scope.techniques };
            this.techniques11 = { ...scope.techniques11 };
            this.typeTemplates = { ...scope.typeTemplates };
            this.cbuffers = { ...scope.cbuffers };
        }
        else {
            let settings = params;
            ({ type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default, parent = null, strictMode = false } = settings);
            this.variables = {};
            this.types = {};
            this.functions = {};
            this.techniques = {};
            this.techniques11 = {};
            this.typeTemplates = {};
            this.cbuffers = {};
        }
        this.type = type;
        this.parent = parent;
        this.strictMode = strictMode;
    }
    isStrict() {
        return this.filter(scope => scope.strictMode);
    }
    findVariable(varName) {
        return this.filter(scope => scope.variables[varName] || null);
    }
    findTypeTemplate(typeName) {
        return this.filter(scope => scope.typeTemplates[typeName] || null);
    }
    findType(typeName) {
        return this.filter(scope => scope.types[typeName] || null);
    }
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    findFunction(funcName, args = null) {
        return this.filter(scope => _helpers__WEBPACK_IMPORTED_MODULE_3__.fn.matchList(scope.functions[funcName], args));
    }
    findTechnique(techName) {
        return this.filter(scope => scope.techniques[techName] || null);
    }
    findTechnique11(techName) {
        return this.filter(scope => scope.techniques11[techName] || null);
    }
    findCbuffer(cbufName) {
        return this.filter(scope => scope.cbuffers[cbufName] || null);
    }
    findFunctionInScope(func) {
        let res = _helpers__WEBPACK_IMPORTED_MODULE_3__.fn.matchList(this.functions[func.name], func.def.params.map(param => param ? param.type : null));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(res !== undefined);
        return res;
    }
    addVariable(variable) {
        let variableMap = this.variables;
        let varName = variable.name;
        if (!this.variables[varName]) {
            variableMap[varName] = variable;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(variable.scope === this);
        }
        else {
            // console.error(`letiable '${varName}' already exists in scope:`, this);
            return false;
        }
        return true;
    }
    addTypeTemplate(template) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this.typeTemplates[template.name])) {
            return false;
        }
        this.typeTemplates[template.name] = template;
        return true;
    }
    // todo: remove scopeId from argumts, use type.scope instead.
    addType(type) {
        if (this.types[type.name]) {
            return false;
        }
        this.types[type.name] = type;
        console.assert(type.scope === this);
        return true;
    }
    addTypeAlias(t, aliasName) {
        let typeName = null;
        let type = null;
        if ((0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__.isString)(t)) {
            typeName = t;
            type = this.findType(typeName);
        }
        else {
            type = t;
            typeName = type.name;
        }
        const alias = this.findType(aliasName);
        if (alias) {
            return false;
        }
        if (!type) {
            return false;
        }
        // original type must be part of this scope?
        if (!this.findType(typeName)) {
            return false;
        }
        this.types[aliasName] = type;
        return true;
    }
    addFunction(func) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(func.scope === this);
        let funcMap = this.functions;
        let funcName = func.name;
        funcMap[funcName] = funcMap[funcName] || [];
        const funcOverloads = funcMap[funcName];
        let targetFunc = this.findFunctionInScope(func);
        if (!targetFunc) {
            funcOverloads.push(func);
        }
        else {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func.impl));
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(targetFunc.impl));
            let i = funcOverloads.indexOf(targetFunc);
            funcOverloads[i] = func;
        }
        return true;
    }
    addTechnique(technique) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.techniques[technique.name]) {
            return false;
        }
        this.techniques[technique.name] = technique;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(technique.scope === this);
        return true;
    }
    addTechnique11(technique11) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.techniques11[technique11.name]) {
            return false;
        }
        this.techniques11[technique11.name] = technique11;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(technique11.scope === this);
        return true;
    }
    addCbuffer(cbuf) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.cbuffers[cbuf.name]) {
            return false;
        }
        this.cbuffers[cbuf.name] = cbuf;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(cbuf.scope === this);
        return true;
    }
    filter(cb) {
        let scope = this;
        while (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope)) {
            let res = cb(scope);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(res)) {
                return res;
            }
            scope = scope.parent;
        }
        return null;
    }
}
class ProgramScope {
    constructor(parent) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(parent)) {
            let type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global;
            this.globalScope = new Scope({ parent, type });
            this.currentScope = this.globalScope;
        }
    }
    validate() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope === this.globalScope);
    }
    push(type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type >= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default);
        let parent = this.currentScope;
        let scope = new Scope({ parent, type });
        this.currentScope = scope;
    }
    pop() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
        this.currentScope = this.currentScope.parent;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
    }
}
class ProgramScopeEx extends ProgramScope {
    constructor(parent) {
        super(null);
        this.globalScope = new Scope(parent); // clone scope
        this.currentScope = this.globalScope;
    }
}


/***/ }),

/***/ "c0pO":
/*!********************************************!*\
  !*** ./src/lib/fx/analisys/SystemScope.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SCOPE": () => (/* binding */ SCOPE),
/* harmony export */   "T_BLEND_STATE": () => (/* binding */ T_BLEND_STATE),
/* harmony export */   "T_BOOL": () => (/* binding */ T_BOOL),
/* harmony export */   "T_BOOL2": () => (/* binding */ T_BOOL2),
/* harmony export */   "T_BOOL2X2": () => (/* binding */ T_BOOL2X2),
/* harmony export */   "T_BOOL3": () => (/* binding */ T_BOOL3),
/* harmony export */   "T_BOOL3X3": () => (/* binding */ T_BOOL3X3),
/* harmony export */   "T_BOOL4": () => (/* binding */ T_BOOL4),
/* harmony export */   "T_BOOL4X4": () => (/* binding */ T_BOOL4X4),
/* harmony export */   "T_COMPUTE_SHADER": () => (/* binding */ T_COMPUTE_SHADER),
/* harmony export */   "T_DEPTH_STENCIL_STATE": () => (/* binding */ T_DEPTH_STENCIL_STATE),
/* harmony export */   "T_FLOAT": () => (/* binding */ T_FLOAT),
/* harmony export */   "T_FLOAT2": () => (/* binding */ T_FLOAT2),
/* harmony export */   "T_FLOAT2X2": () => (/* binding */ T_FLOAT2X2),
/* harmony export */   "T_FLOAT2X3": () => (/* binding */ T_FLOAT2X3),
/* harmony export */   "T_FLOAT2X4": () => (/* binding */ T_FLOAT2X4),
/* harmony export */   "T_FLOAT3": () => (/* binding */ T_FLOAT3),
/* harmony export */   "T_FLOAT3X2": () => (/* binding */ T_FLOAT3X2),
/* harmony export */   "T_FLOAT3X3": () => (/* binding */ T_FLOAT3X3),
/* harmony export */   "T_FLOAT3X4": () => (/* binding */ T_FLOAT3X4),
/* harmony export */   "T_FLOAT4": () => (/* binding */ T_FLOAT4),
/* harmony export */   "T_FLOAT4X2": () => (/* binding */ T_FLOAT4X2),
/* harmony export */   "T_FLOAT4X3": () => (/* binding */ T_FLOAT4X3),
/* harmony export */   "T_FLOAT4X4": () => (/* binding */ T_FLOAT4X4),
/* harmony export */   "T_GEOMETRY_SHADER": () => (/* binding */ T_GEOMETRY_SHADER),
/* harmony export */   "T_HALF": () => (/* binding */ T_HALF),
/* harmony export */   "T_HALF2": () => (/* binding */ T_HALF2),
/* harmony export */   "T_HALF3": () => (/* binding */ T_HALF3),
/* harmony export */   "T_HALF4": () => (/* binding */ T_HALF4),
/* harmony export */   "T_INT": () => (/* binding */ T_INT),
/* harmony export */   "T_INT2": () => (/* binding */ T_INT2),
/* harmony export */   "T_INT2X2": () => (/* binding */ T_INT2X2),
/* harmony export */   "T_INT3": () => (/* binding */ T_INT3),
/* harmony export */   "T_INT3X3": () => (/* binding */ T_INT3X3),
/* harmony export */   "T_INT4": () => (/* binding */ T_INT4),
/* harmony export */   "T_INT4X4": () => (/* binding */ T_INT4X4),
/* harmony export */   "T_NULL": () => (/* binding */ T_NULL),
/* harmony export */   "T_PIXEL_SHADER": () => (/* binding */ T_PIXEL_SHADER),
/* harmony export */   "T_SAMPLER_STATE": () => (/* binding */ T_SAMPLER_STATE),
/* harmony export */   "T_STRING": () => (/* binding */ T_STRING),
/* harmony export */   "T_UINT": () => (/* binding */ T_UINT),
/* harmony export */   "T_UINT2": () => (/* binding */ T_UINT2),
/* harmony export */   "T_UINT3": () => (/* binding */ T_UINT3),
/* harmony export */   "T_UINT4": () => (/* binding */ T_UINT4),
/* harmony export */   "T_VERTEX_SHADER": () => (/* binding */ T_VERTEX_SHADER),
/* harmony export */   "T_VOID": () => (/* binding */ T_VOID),
/* harmony export */   "determBaseType": () => (/* binding */ determBaseType),
/* harmony export */   "determMostPreciseBaseType": () => (/* binding */ determMostPreciseBaseType),
/* harmony export */   "determTypePrecision": () => (/* binding */ determTypePrecision),
/* harmony export */   "findFunction": () => (/* binding */ findFunction),
/* harmony export */   "findTechnique": () => (/* binding */ findTechnique),
/* harmony export */   "findType": () => (/* binding */ findType),
/* harmony export */   "findVariable": () => (/* binding */ findVariable),
/* harmony export */   "hasTechnique": () => (/* binding */ hasTechnique),
/* harmony export */   "hasType": () => (/* binding */ hasType),
/* harmony export */   "hasVariable": () => (/* binding */ hasVariable),
/* harmony export */   "isBase": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBase),
/* harmony export */   "isBlendState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBlendState),
/* harmony export */   "isBoolBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType),
/* harmony export */   "isBuffer": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBuffer),
/* harmony export */   "isDepthStencilState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isDepthStencilState),
/* harmony export */   "isFloatBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType),
/* harmony export */   "isFloatType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatType),
/* harmony export */   "isHalfBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType),
/* harmony export */   "isIntBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType),
/* harmony export */   "isIntegerType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntegerType),
/* harmony export */   "isMatrixType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isMatrixType),
/* harmony export */   "isPipelineState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isPipelineState),
/* harmony export */   "isRasterizerState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isRasterizerState),
/* harmony export */   "isSamplerState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isSamplerState),
/* harmony export */   "isScalarType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType),
/* harmony export */   "isTexture": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isTexture),
/* harmony export */   "isUAV": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isUAV),
/* harmony export */   "isUintBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType),
/* harmony export */   "isVectorType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType),
/* harmony export */   "resolveRegister": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.resolveRegister),
/* harmony export */   "typePrecisionAsType": () => (/* binding */ typePrecisionAsType)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _system_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system/api */ "9ebs");
/* harmony import */ var _system_builtin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./system/builtin */ "OC3L");
/* harmony import */ var _system_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./system/matrix */ "L0DD");
/* harmony import */ var _system_scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./system/scalar */ "gzl7");
/* harmony import */ var _system_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./system/utils */ "BeyE");
/* harmony import */ var _system_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./system/vector */ "9oB0");










const scope = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.Scope({ type: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EScopeType.k_System });
(0,_system_scalar__WEBPACK_IMPORTED_MODULE_6__.addSystemTypeScalar)(scope);
(0,_system_vector__WEBPACK_IMPORTED_MODULE_8__.addSystemTypeVector)(scope);
(0,_system_matrix__WEBPACK_IMPORTED_MODULE_5__.addSystemTypeMatrix)(scope);
(0,_system_builtin__WEBPACK_IMPORTED_MODULE_4__.addSystemTypeBuiltin)(scope);
(0,_system_api__WEBPACK_IMPORTED_MODULE_3__.addSystemFunctions)(scope);
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
const findType = (typeName) => scope.findType(typeName);
const findVariable = (varName) => scope.findVariable(varName);
const findTechnique = (techName) => scope.findTechnique(techName);
const findFunction = (funcName, args) => scope.findFunction(funcName, args);
const hasType = (typeName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findType(typeName));
const hasVariable = (varName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findVariable(varName));
const hasTechnique = (techName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findTechnique(techName));
const SCOPE = scope;
const T_VOID = scope.findType("void");
const T_STRING = scope.findType("string");
const T_NULL = scope.findType("null_t");
const T_SAMPLER_STATE = scope.findType("SamplerState");
const T_BLEND_STATE = scope.findType("BlendState");
const T_DEPTH_STENCIL_STATE = scope.findType("DepthStencilState");
const T_FLOAT = scope.findType("float");
const T_FLOAT2 = scope.findType("float2");
const T_FLOAT3 = scope.findType("float3");
const T_FLOAT4 = scope.findType("float4");
const T_HALF = scope.findType("half");
const T_HALF2 = scope.findType("half2");
const T_HALF3 = scope.findType("half3");
const T_HALF4 = scope.findType("half4");
const T_FLOAT2X2 = scope.findType("float2x2");
const T_FLOAT2X3 = scope.findType("float2x3");
const T_FLOAT2X4 = scope.findType("float2x4");
const T_FLOAT3X2 = scope.findType("float3x2");
const T_FLOAT3X3 = scope.findType("float3x3");
const T_FLOAT3X4 = scope.findType("float3x4");
const T_FLOAT4X2 = scope.findType("float4x2");
const T_FLOAT4X3 = scope.findType("float4x3");
const T_FLOAT4X4 = scope.findType("float4x4");
const T_BOOL = scope.findType("bool");
const T_BOOL2 = scope.findType("bool2");
const T_BOOL3 = scope.findType("bool3");
const T_BOOL4 = scope.findType("bool4");
const T_BOOL2X2 = scope.findType("bool2x2");
const T_BOOL3X3 = scope.findType("bool3x3");
const T_BOOL4X4 = scope.findType("bool4x4");
const T_INT = scope.findType("int");
const T_INT2 = scope.findType("int2");
const T_INT3 = scope.findType("int3");
const T_INT4 = scope.findType("int4");
const T_UINT = scope.findType("uint");
const T_UINT2 = scope.findType("uint2");
const T_UINT3 = scope.findType("uint3");
const T_UINT4 = scope.findType("uint4");
const T_INT2X2 = scope.findType("int2x2");
const T_INT3X3 = scope.findType("int3x3");
const T_INT4X4 = scope.findType("int4x4");
// export const T_SAMPLER = scope.findType("sampler");
// export const T_SAMPLER_2D = scope.findType("sampler2D");
// export const T_SAMPLER_CUBE = scope.findType("samplerCUBE");
const T_VERTEX_SHADER = scope.findType("VertexShader");
const T_PIXEL_SHADER = scope.findType("PixelShader");
const T_COMPUTE_SHADER = scope.findType("ComputeShader");
const T_GEOMETRY_SHADER = scope.findType("GeometryShader");
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function determBaseType(type) {
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(type)) {
        return type;
    }
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(type) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isMatrixType)(type)) {
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType)(type)) {
            return T_FLOAT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType)(type)) {
            return T_INT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType)(type)) {
            return T_UINT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType)(type)) {
            return T_HALF;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType)(type)) {
            return T_BOOL;
        }
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `cannot determ base type of ${type.name}`);
    return null;
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
var ETypePrecision;
(function (ETypePrecision) {
    ETypePrecision[ETypePrecision["k_Bool"] = 0] = "k_Bool";
    ETypePrecision[ETypePrecision["k_Uint"] = 1] = "k_Uint";
    ETypePrecision[ETypePrecision["k_Int"] = 2] = "k_Int";
    ETypePrecision[ETypePrecision["k_Half"] = 3] = "k_Half";
    ETypePrecision[ETypePrecision["k_Float"] = 4] = "k_Float";
    ETypePrecision[ETypePrecision["k_Unknown"] = NaN] = "k_Unknown";
})(ETypePrecision || (ETypePrecision = {}));
;
function determTypePrecision(type) {
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType)(type))
        return ETypePrecision.k_Float;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType)(type))
        return ETypePrecision.k_Half;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType)(type))
        return ETypePrecision.k_Int;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType)(type))
        return ETypePrecision.k_Uint;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType)(type))
        return ETypePrecision.k_Bool;
    return ETypePrecision.k_Unknown;
}
function typePrecisionAsType(precision) {
    switch (precision) {
        case ETypePrecision.k_Float: return T_FLOAT;
        case ETypePrecision.k_Half: return T_HALF;
        case ETypePrecision.k_Int: return T_INT;
        case ETypePrecision.k_Uint: return T_UINT;
        case ETypePrecision.k_Bool: return T_BOOL;
    }
    return null;
}
/**
 * Determining the most precise type of two types.
 * Type hierarchy:
 *  float => half => int => uint => bool
 */
function determMostPreciseBaseType(left, right) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(left) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(left));
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(right) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(right));
    const type = typePrecisionAsType(Math.max(determTypePrecision(left), determTypePrecision(right)));
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type !== null, 'cannot determ base type');
    return type;
}


/***/ }),

/***/ "jbLw":
/*!***************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/expression.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expression": () => (/* binding */ expression)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "IP3g");



var expression;
(function (expression) {
    /**
     * unwind operation returns declaration in case of correct l-value expression;
     */
    function unwind(expr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
            return null;
        }
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PostfixPointExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PostfixIndexExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IdExpr:
                return expr.decl;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_BitwiseExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ArithmeticExpr:
                // arithmetic expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_InitExpr:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'init expression doesn\'t support unwind operation');
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_AssignmentExpr:
                // todo: reseach how it work in HLSL
                //// assigment expression returns right-hand value;
                return unwind(expr.left);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr:
                // cast expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_UnaryExpr:
                // unary expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_RelationalExpr:
                // relation expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ConstructorCallExpr:
                // ctor call expression is not allowed as l-value;
                // todo: allow it?
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexExpr:
                return unwind(expr.expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_StringExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_BoolExpr:
                // literal cannot be a left-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionCallExpr:
                // function call expression returns right-hand value;
                return null;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, "unsupported expr found");
                return null;
        }
    }
    expression.unwind = unwind;
    function evalVal(val) {
        if (!val) {
            return 0;
        }
        if (_instruction__WEBPACK_IMPORTED_MODULE_2__.instruction.isLiteral(val)) {
            return val.value;
        }
        if (val.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr) {
            return evalConst(val.expr);
        }
        if (val.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IdExpr) {
            const idExpr = val;
            if (idExpr.decl.isGlobal()) { // and is constant?
                console.assert(idExpr.decl.initExpr.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_InitExpr);
                return evalConst(idExpr.decl.initExpr);
            }
        }
        return -1;
    }
    // simples possible evalator for minimal compartibility
    function evalConst(expr) {
        const val = evalVal(expr);
        if (val >= 0) {
            return val;
        }
        if (expr.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ArithmeticExpr) {
            console.error(`expr "${expr.toCode()}" could not be evaluated`);
            return -1;
        }
        const { left, right, operator } = expr;
        const lval = evalConst(left);
        const rval = evalConst(right);
        if (lval >= 0 && rval >= 0) {
            switch (operator) {
                // todo: use round ? check if integers only
                case '*': return rval * lval;
                case '/': return rval / lval;
                case '+': return rval + lval;
                case '-': return rval - lval;
                default:
                    console.error('unsupported operator');
            }
        }
        console.error(`expr "${expr.toCode()}" could not be evaluated`);
        return -1;
    }
    expression.evalConst = evalConst;
})(expression || (expression = {}));


/***/ }),

/***/ "zoki":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/helpers/fn.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fn": () => (/* binding */ fn)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");


var fn;
(function (fn) {
    function signatureParam(param, strong) {
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;
    }
    function signature(def, strong = false) {
        const { name, params } = def;
        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signature = signature;
    function signatureEx(def, strong = false) {
        const { name, returnType, params } = def;
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signatureEx = signatureEx;
    function numArgsRequired(def) {
        return def.params.filter((param) => !param || !param.initExpr).length;
    }
    fn.numArgsRequired = numArgsRequired;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function match(def, args, strong = false) {
        if (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(args)) {
            return true;
        }
        if (args.length > def.params.length || numArgsRequired(def) > args.length) {
            return false;
        }
        return args.every((arg, i) => (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(arg)) ||
            (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(def.params[i].type)) ||
            _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.equals(arg, def.params[i].type, strong));
    }
    fn.match = match;
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function matchList(funcList, args, strong = false) {
        if (!funcList) {
            return null;
        }
        const res = funcList.filter(func => fn.match(func.def, args, strong));
        if (res.length > 1) {
            return undefined;
        }
        if (res.length === 1) {
            return res[0];
        }
        return null;
    }
    fn.matchList = matchList;
})(fn || (fn = {}));


/***/ }),

/***/ "pEQR":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expression": () => (/* reexport safe */ _expression__WEBPACK_IMPORTED_MODULE_0__.expression),
/* harmony export */   "fn": () => (/* reexport safe */ _fn__WEBPACK_IMPORTED_MODULE_1__.fn),
/* harmony export */   "instruction": () => (/* reexport safe */ _instruction__WEBPACK_IMPORTED_MODULE_2__.instruction),
/* harmony export */   "types": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.types),
/* harmony export */   "variable": () => (/* reexport safe */ _variable__WEBPACK_IMPORTED_MODULE_4__.variable)
/* harmony export */ });
/* harmony import */ var _expression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression */ "jbLw");
/* harmony import */ var _fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fn */ "zoki");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "IP3g");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "7MAr");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variable */ "9MfH");







/***/ }),

/***/ "IP3g":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/instruction.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "instruction": () => (/* binding */ instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");

var instruction;
(function (instruction) {
    instruction.UNDEFINE_LENGTH = 0xffffff;
    instruction.UNDEFINE_SIZE = 0xffffff;
    instruction.UNDEFINE_PADDING = 0xffffff;
    instruction.UNDEFINE_NAME = "undef";
    function isExpression(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_InitExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CastExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_UnaryExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_RelationalExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_LogicalExpr:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isExpression = isExpression;
    function isStatement(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Stmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IfStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ExprStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SemicolonStmt:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isStatement = isStatement;
    function isLiteral(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StringExpr:
                return true;
        }
        return false;
    }
    instruction.isLiteral = isLiteral;
})(instruction || (instruction = {}));


/***/ }),

/***/ "7MAr":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/types.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "types": () => (/* binding */ types)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instruction */ "IP3g");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variable */ "9MfH");





var types;
(function (types) {
    // todo: rename it
    /** @deprecated */
    function isInheritedFromVariableDecl(type) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type.parent)) {
            return false;
        }
        const parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            return true;
        }
        else if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType) {
            return isInheritedFromVariableDecl(type.parent);
        }
        return false;
    }
    types.isInheritedFromVariableDecl = isInheritedFromVariableDecl;
    /** @deprecated */
    function isTypeOfField(type) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type.parent)) {
            return false;
        }
        if (type.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            let pParentDecl = type.parent;
            return pParentDecl.isField();
        }
        return false;
    }
    types.isTypeOfField = isTypeOfField;
    /** @deprecated */
    function findParentContainer(type) {
        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {
            return null;
        }
        let containerType = findParentVariableDecl(type).parent;
        if (!isInheritedFromVariableDecl(containerType)) {
            return null;
        }
        return findParentVariableDecl(containerType);
    }
    types.findParentContainer = findParentContainer;
    /** @deprecated */
    function findParentVariableDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            return type.parent;
        }
        return findParentVariableDecl(type.parent);
    }
    types.findParentVariableDecl = findParentVariableDecl;
    /** @deprecated */
    function findParentVariableDeclName(type) {
        let varDecl = findParentVariableDecl(type);
        return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(varDecl) ? null : varDecl.name;
    }
    types.findParentVariableDeclName = findParentVariableDeclName;
    /** @deprecated */
    function finParentTypeDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypeDecl) {
            return type.parent;
        }
        return finParentTypeDecl(type.parent);
    }
    types.finParentTypeDecl = finParentTypeDecl;
    /** @deprecated */
    function finParentTypeDeclName(type) {
        let typeDecl = finParentTypeDecl(type);
        return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(typeDecl) ? null : typeDecl.name;
    }
    types.finParentTypeDeclName = finParentTypeDeclName;
    /** @deprecated */
    function resolveVariableDeclFullName(type) {
        if (!isInheritedFromVariableDecl(type)) {
            console.error("Not from variable decl");
            return null;
        }
        return _variable__WEBPACK_IMPORTED_MODULE_4__.variable.fullName(findParentVariableDecl(type));
    }
    types.resolveVariableDeclFullName = resolveVariableDeclFullName;
    // todo: add comment
    // todo: review this code
    /** @deprecated */
    function findMainVariable(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        if (isTypeOfField(type)) {
            return findMainVariable(type.parent.parent);
        }
        return findParentVariableDecl(type);
    }
    types.findMainVariable = findMainVariable;
    //
    // Signatures
    //
    function signatureVType(vtype, strong) {
        let prefix = '';
        if (strong) {
            if (vtype.usages.length > 0) {
                prefix = `${vtype.usages.join('_')}_`;
            }
        }
        let postfix = '';
        if (vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        // skip all variable type wrappers
        // is it safe?
        let subType = vtype.subType;
        while (subType.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType)
            subType = subType.subType;
        return `${prefix}${signature(subType)}${postfix}`;
    }
    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)
    function signature(type, strong = false) {
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__.isDefAndNotNull)(type)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!strong);
            return '*';
        }
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType:
                return signatureVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType:
                return `${type.name}${type.instructionID}`;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType:
                return type.baseType ? signature(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType:
                return type.name;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported type');
                return null;
        }
    }
    types.signature = signature;
    // export function relaxType(type: ITypeInstruction): ITypeInstruction | RegExp {
    //     if (!type) {
    //         return null;
    //     }
    //     if (types.equals(type, T_INT) || types.equals(type, T_UINT)) {
    //         // temp workaround in order to match int to uint and etc. 
    //         return /^int$|^uint$/g;
    //     }
    //     return type;
    // }
    // // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    // export function asRelaxedType(instr: ITypedInstruction): ITypeInstruction | RegExp {
    //     if (!instr) {
    //         return null;
    //     }
    //     return relaxType(instr.type);
    // };
    //
    // hash
    //
    function hashVType(vtype, strong) {
        let postfix = '';
        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        return `${hash(vtype.subType)}${postfix}`;
    }
    function hashComplex(ctype, strong) {
        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;
    }
    function hash(type, strong = false) {
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType:
                return hashVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType:
                return hashComplex(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType:
                return type.baseType ? hash(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType:
                return type.name;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported type');
                return null;
        }
    }
    types.hash = hash;
    function compareRelaxed(a, b, strong = false) {
        return hash(a, strong) === hash(b, strong);
    }
    types.compareRelaxed = compareRelaxed;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function compare(a, b, strong = false) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(a) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(b)) {
            return false;
        }
        if (a instanceof RegExp && b instanceof RegExp) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
            return false;
        }
        if (a instanceof RegExp) {
            let ra = a;
            let sb = signature(b, strong);
            return !!sb.match(ra);
        }
        if (b instanceof RegExp) {
            let sa = signature(a, strong);
            let rb = b;
            return !!sa.match(rb);
        }
        let ta = a;
        let tb = b;
        if (ta.isArray() && tb.isArray()) {
            if (ta.length === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH ||
                tb.length === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                // wnen both types are undefined is valid 
                if (ta.length !== tb.length) {
                    return false;
                }
            }
        }
        return signature(ta, strong) === signature(tb, strong);
    }
    types.compare = compare;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function equals(a, b, strong = false) {
        return compare(a, b, strong);
    }
    types.equals = equals;
    //
    // utils
    //
    function alignSize(size, aligment) {
        if (size === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_SIZE) {
            return size;
        }
        const unaligned = size % aligment;
        return unaligned !== 0 ? size + aligment - unaligned : size;
    }
    types.alignSize = alignSize;
})(types || (types = {}));


/***/ }),

/***/ "9MfH":
/*!*************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/variable.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "variable": () => (/* binding */ variable)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "7MAr");



var variable;
(function (variable) {
    /**
     * @param decl Variable declaraion (decl.isParameter() must be true).
     * @returns Serial number of the declaration among the function parameters or -1 otherwise.
     */
    function parameterIndex(decl) {
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return -1;
        }
        // all parameters must be a children on function definition!
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(decl.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionDef);
        return decl.parent.params.indexOf(decl);
    }
    variable.parameterIndex = parameterIndex;
    /**
     * @returns Offset in bytes from the beginning of the parameters' list.
     */
    function parameterOffset(decl) {
        // todo: add support for 'inout', 'out' usages 
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return 0;
        }
        let idx = parameterIndex(decl);
        let offset = 0;
        for (let i = 0; i < idx; ++i) {
            offset += decl.parent.params[i].type.size;
        }
        return offset;
    }
    variable.parameterOffset = parameterOffset;
    /**
     * Helper:
     *  Returns 'structName.fieldName' for structs;
     *  Returns 'varName' for variables;
     */
    function fullName(decl) {
        if (decl.isField() &&
            _types__WEBPACK_IMPORTED_MODULE_2__.types.findParentVariableDecl(decl.parent)) {
            let name = '';
            let parentType = decl.parent.instructionType;
            if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType) {
                name = _types__WEBPACK_IMPORTED_MODULE_2__.types.resolveVariableDeclFullName(decl.parent);
            }
            name += '.' + decl.name;
            return name;
        }
        return decl.name;
    }
    variable.fullName = fullName;
})(variable || (variable = {}));


/***/ }),

/***/ "0qyf":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AnnotationInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationInstruction": () => (/* binding */ AnnotationInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class AnnotationInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ decls, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Annotation, ...settings });
        this.decls = decls;
    }
}


/***/ }),

/***/ "+tx1":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArithmeticExprInstruction": () => (/* binding */ ArithmeticExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr + / - * % someExpr
 * (+|-|*|/|%) Instruction Instruction
 */
class ArithmeticExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr, ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var sCode = "";
        sCode += this._leftOperand.toCode();
        sCode += ` ${this.operator} `;
        sCode += this._rightOperand.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() && this.right.isConst();
    }
}


/***/ }),

/***/ "eck/":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssignmentExprInstruction": () => (/* binding */ AssignmentExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr = += -= /= *= %= someExpr
 * (=|+=|-=|*=|/=|%=) Instruction Instruction
 */
class AssignmentExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = "";
        code += this.left.toCode();
        code += this.operator;
        code += this.right.toCode();
        return code;
    }
}


/***/ }),

/***/ "rs/O":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AttributeInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeInstruction": () => (/* binding */ AttributeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


/**
 * Represent attributes:
 *  [numthreads(1, 2, 3)]
 *  [loop]
 *  [branch]
 */
class AttributeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ name, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Attribute, ...settings });
        this.name = name;
        this.args = args;
    }
    toCode() {
        return `[${this.name}${this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})` : ``}]`;
    }
}


/***/ }),

/***/ "l236":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BitwiseExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitwiseExprInstruction": () => (/* binding */ BitwiseExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr >> << | & ^ someExpr
 * (>>,<<,|,&,^) Instruction Instruction
 */
class BitwiseExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr, ...settings });
        this.left = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this.right = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this.operator = operator;
    }
    toCode() {
        return `${this.left.toCode()} ${this.operator} ${this.right.toCode()}`;
    }
    // FIXME: use isConstExpr instead!
    isConst() {
        return this.left.isConst() && this.right.isConst();
    }
}


/***/ }),

/***/ "d+t4":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BoolInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoolInstruction": () => (/* binding */ BoolInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class BoolInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_BoolExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_BOOL, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return this.value ? "true" : "false";
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "t33R":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BreakStmtInstruction": () => (/* binding */ BreakStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "pGoc");


/**
 * Reprsernt continue; break; discard;
 * (continue || break || discard)
 */
class BreakStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ operator = "break", ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt, ...settings });
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    // todo: validate operator's name
    toCode() {
        console.assert(this.operator == "break");
        return this.operator + ";";
    }
}


/***/ }),

/***/ "KHnE":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CastExprInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CastExprInstruction": () => (/* binding */ CastExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represent (type) expr
 * EMPTY_OPERATOR VariableTypeInstruction Instruction
 */
class CastExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ sourceExpr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr, ...settings });
        this.expr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(sourceExpr, this);
    }
    toCode() {
        return `(${this.type.toCode()})(${this.expr.toCode()})`;
    }
    /** @deprecated */
    isUseless() {
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.equals(this.type, this.expr.type);
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "r+W1":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CbufferInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CbufferInstruction": () => (/* binding */ CbufferInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class CbufferInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ id, type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CbufferDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(id, this);
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(type, this);
    }
    get id() {
        return this._id;
    }
    get name() {
        return this.id.name;
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "MV/g":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CompileExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileExprInstruction": () => (/* binding */ CompileExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");


/**
 * Represents compile vs_func(...args)
 * compile IdExprInstruction ExprInstruction ... ExprInstruction
 */
/** @deprecated */
class CompileExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ operand, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileExpr, ...settings });
        this._operand = operand; //Instruction.$withParent(operand, this);
        this._args = args; //(args || []).map(arg => Instruction.$withParent(arg, this));
    }
    get function() {
        return this._operand;
    }
    get args() {
        return this._args;
    }
}


/***/ }),

/***/ "Ugh4":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CompileShader11Instruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileShader11Instruction": () => (/* binding */ CompileShader11Instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represents CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )
 */
class CompileShader11Instruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ ver, func, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileShader11Expr, ...settings });
        this.func = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withNoParent(func);
        this.ver = ver;
        this.args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
    }
}


/***/ }),

/***/ "RRea":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComplexExprInstruction": () => (/* binding */ ComplexExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent (expr)
 * EMPTY_OPERATOR ExprInstruction
 */
class ComplexExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return "(" + this.expr.toCode() + ")";
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "G0Ba":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComplexTypeInstruction": () => (/* binding */ ComplexTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "pEQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// todo: merge with system tpye ?
class ComplexTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ name = null, fields, aligment = 1 /* byte */, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType, ...settings });
        this._name = name;
        this._fields = {};
        this._aligment = aligment;
        this.addFields(fields.filter(field => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(field)).map(field => _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(field, this)));
    }
    get writable() {
        return true;
    }
    get readable() {
        return true;
    }
    get name() {
        return this._name;
    }
    get size() {
        return this.calculatePaddings(false);
    }
    get aligment() {
        return this._aligment;
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return 0;
    }
    get fields() {
        return Object.values(this._fields);
    }
    get methods() {
        return [];
    }
    toString() {
        return this.name || _helpers__WEBPACK_IMPORTED_MODULE_2__.types.hash(this);
    }
    /** @deprecated */
    toDeclString() {
        var code = "struct " + this._name + "{";
        for (var i = 0; i < this.fields.length; i++) {
            code += "\t" + this.fields[i].toCode() + ";\n";
        }
        code += "}";
        return code;
    }
    toCode() {
        return this._name;
    }
    isArray() {
        return false;
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return true;
    }
    addField(variable) {
        this._fields[variable.name] = variable;
    }
    addFields(fields) {
        for (var i = 0; i < fields.length; i++) {
            this.addField(fields[i]);
        }
        this.calculatePaddings();
    }
    hasFieldWithSematics(semantic) {
        return !!this.getFieldBySemantics(semantic);
    }
    getField(fieldName) {
        return this._fields[fieldName] || null;
    }
    getMethod(methodName, args) {
        return null;
    }
    getFieldBySemantics(semantic) {
        for (let i in this._fields) {
            let field = this._fields[i];
            if (semantic == field.semantic) {
                return field;
            }
        }
        return null;
    }
    hasFieldWithoutSemantics() {
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if (semantic == null || semantic == '') {
                return true;
            }
            if (field.type.hasFieldWithoutSemantics()) {
                return true;
            }
        }
        return false;
    }
    hasAllUniqueSemantics() {
        let fieldBySemantics = {};
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(fieldBySemantics[semantic])) {
                return false;
            }
            fieldBySemantics[semantic] = field;
            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {
                return false;
            }
        }
        return true;
    }
    calculatePaddings(override = true) {
        const aligment = this._aligment;
        let padding = 0;
        let aligned = (offset, align) => (offset + (align - 1)) & ~(align - 1);
        for (let i = 0; i < this.fields.length; i++) {
            const varType = this.fields[i].type;
            const varSize = varType.size;
            if (varSize === _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'cannot calc padding');
                return _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE;
            }
            let a = aligned(padding, aligment);
            let b = aligned(padding + varSize, aligment);
            if (b > a) {
                padding = a;
            }
            if (override)
                varType.$overwritePadding(padding, aligment);
            padding += varSize;
        }
        return aligned(padding, aligment);
    }
}


/***/ }),

/***/ "IsZF":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConditionalExprInstruction": () => (/* binding */ ConditionalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represen boolExpr ? someExpr : someExpr
 * EMPTY_OPERATOR Instruction Instruction Instruction
 */
class ConditionalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ cond, left, right, ...settings }) {
        // todo: do not use {left.type} here
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings });
        console.assert(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, right.type));
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(cond, this);
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(right, this);
    }
    get condition() {
        return this._cond;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    toCode() {
        var code = '(';
        code += this.condition.toCode();
        code += '?';
        code += this.left.toCode();
        code += ':';
        code += this.right.toCode();
        code += ')';
        return code;
    }
    isConst() {
        return this.condition.isConst() &&
            this.left.isConst();
    }
}


/***/ }),

/***/ "RIdR":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructorCallInstruction": () => (/* binding */ ConstructorCallInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Resresnt ctor(arg1,..., argn)
 * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
 */
class ConstructorCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ ctor, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });
        this._args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
        this._ctor = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(ctor, this);
    }
    get args() {
        return this._args;
    }
    get ctor() {
        return this._ctor;
    }
    toCode() {
        var code = "";
        code += this.ctor.toCode();
        code += "(";
        for (var i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        for (var i = 0; i < this.args.length; i++) {
            if (!this.args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
}


/***/ }),

/***/ "0xZW":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeclInstruction": () => (/* binding */ DeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class DeclInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ semantic = null, annotation = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Decl, ...settings });
        this._semantic = semantic;
        this._annotation = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(annotation, this);
    }
    get semantic() {
        return this._semantic;
    }
    get annotation() {
        return this._annotation;
    }
    get name() {
        return null;
    }
    get id() {
        return null;
    }
}


/***/ }),

/***/ "YZc1":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeclStmtInstruction": () => (/* binding */ DeclStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent TypeDecl or VariableDecl or VarStructDecl
 * EMPTY DeclInstruction
 */
class DeclStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ declList = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt, ...settings });
        this._declList = (declList || []).map(decl => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(decl, this));
    }
    get declList() {
        return this._declList;
    }
    toCode() {
        var code = '';
        var declList = this.declList;
        for (var i = 0; i < this.declList.length; i++) {
            code += declList[i].toCode() + ";\n";
        }
        return code;
    }
}


/***/ }),

/***/ "nqRf":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExprInstruction": () => (/* binding */ ExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/TypedInstruction */ "jSFO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");


class ExprInstruction extends _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__.TypedInstruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Expr, ...settings });
        this._evalResult = null;
    }
    get type() {
        return super.type;
    }
    isConst() {
        // console.error("@pure_virtual");
        return false;
    }
    isConstExpr() {
        // todo: implement it properly
        return true;
    }
}


/***/ }),

/***/ "ubxH":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExprStmtInstruction": () => (/* binding */ ExprStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "pGoc");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent expr;
 * EMPTY_OPERTOR ExprInstruction
 */
class ExprStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ExprStmt, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return (this._expr ? this._expr.toCode() : '') + ';';
    }
}


/***/ }),

/***/ "OsKO":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FloatInstruction.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatInstruction": () => (/* binding */ FloatInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class FloatInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_FloatExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return `${this.value}${this.value % 1 === 0 ? '.' : ''}`;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "r82U":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ForStmtInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ForStmtInstruction": () => (/* binding */ ForStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent for(forInit forCond ForStep) stmt
 * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
 */
class ForStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ init = null, cond = null, step = null, body = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt, ...settings });
        this._init = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(init, this);
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(cond, this);
        this._step = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(step, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(body, this);
    }
    get init() {
        return this._init;
    }
    get cond() {
        return this._cond;
    }
    get step() {
        return this._step;
    }
    get body() {
        return this._body;
    }
    toCode() {
        var code = "for(";
        code += this._init.toCode() + ";";
        code += this._cond.toCode() + ";";
        code += this._step.toCode() + ")";
        code += this._body.toCode();
        return code;
    }
}


/***/ }),

/***/ "y57x":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionCallInstruction": () => (/* binding */ FunctionCallInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Respresnt func(arg1,..., argn)
 * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
 */
class FunctionCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ decl, args, callee, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr, ...settings });
        this.callee = callee;
        this.args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
        this.decl = decl;
    }
    toCode() {
        const { callee, decl: { def }, args } = this;
        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;
    }
}


/***/ }),

/***/ "BLpd":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionDeclInstruction": () => (/* binding */ FunctionDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
 * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
 */
class FunctionDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ def, impl = null, attrs = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDecl, ...settings });
        this.def = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(def, this);
        this.impl = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(impl, this);
        this.attrs = (attrs || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(attr, this));
    }
    get name() {
        return this.def.name;
    }
    get id() {
        return this.def.id;
    }
    get semantic() {
        return this.def.semantic;
    }
    toCode() {
        let code = '';
        code += this.def.toCode();
        if (this.impl) {
            code += this.impl.toCode();
        }
        else {
            code += ';';
        }
        return code;
    }
}


/***/ }),

/***/ "O1LO":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionDefInstruction": () => (/* binding */ FunctionDefInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/DeclInstruction */ "0xZW");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");




/**
 * Represent type func(...args)[:Semantic]
 * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
 */
class FunctionDefInstruction extends _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__.DeclInstruction {
    constructor({ returnType, id, paramList = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionDef, ...settings });
        this.params = paramList.map(param => _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(param, this));
        this.returnType = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(returnType, this);
        this._id = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(id, this);
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._id.name;
    }
    toString() {
        let def = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.signature(this.returnType) + " " + this.name + "(";
        for (let i = 0; i < this.params.length; i++) {
            def += _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.signature(this.params[i].type) + ",";
        }
        def += ")";
        // TODO: add semantic
        return def;
    }
    toCode() {
        const { _id: id, returnType, params } = this;
        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;
    }
}


/***/ }),

/***/ "kBTl":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdExprInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IdExprInstruction": () => (/* binding */ IdExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class IdExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ id, decl, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr, type: decl.type, ...settings });
        this.id = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(id, this);
        this.decl = decl;
    }
    get name() {
        return this.id.name;
    }
    isConst() {
        return this.type.isConst();
    }
    toCode() {
        return this.decl.id.toCode();
    }
}


/***/ }),

/***/ "Muaz":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdInstruction.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IdInstruction": () => (/* binding */ IdInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class IdInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ name, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Id, ...settings });
        this.name = name;
    }
    toString() {
        return this.name;
    }
    toCode() {
        return this.name;
    }
}


/***/ }),

/***/ "AAir":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IfStmtInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IfStmtInstruction": () => (/* binding */ IfStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");




/**
 * Represent if(expr) stmt or if(expr) stmt else stmt
 * ( if || if_else ) Expr Stmt [Stmt]
 */
class IfStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__.StmtInstruction {
    constructor({ cond, conseq, attrs = null, contrary = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IfStmt, ...settings });
        this.cond = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(cond, this);
        this.conseq = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(conseq, this);
        this.contrary = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(contrary, this);
        this.attrs = (attrs || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(attr, this));
    }
    toCode() {
        var code = "";
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.contrary)) {
            code += "if(";
            code += this.cond.toCode() + ")";
            code += this.conseq.toCode();
        }
        else {
            code += "if(";
            code += this.cond.toCode() + ") ";
            code += this.conseq.toCode();
            code += "else ";
            code += this.contrary.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ "lavR":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InitExprInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InitExprInstruction": () => (/* binding */ InitExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "hbjL");






class InitExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__.ExprInstruction {
    constructor({ type, args = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr, type, ...settings });
        this._args = args.map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withParent(arg, this));
    }
    get args() {
        return this._args;
    }
    isArray() {
        return this.type.isNotBaseArray();
    }
    toCode() {
        let code = '';
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.type)) {
            code += this.type.toCode();
        }
        code += "(";
        for (let i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        let bConst;
        let args = this.args;
        for (let i = 0; i < args.length; i++) {
            if (!args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
    /**
     *
     * @param type The type of the variable for which the initializer was created.
     */
    // TODO: move it to Analysis.ts
    optimizeForVariableType(type) {
        // It's a global user defined array or just not unit array;
        // Trying to exclude types like float1.
        if ((type.isNotBaseArray() && type.scope.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EScopeType.k_Global) ||
            (type.isArray() && this.args.length > 1)) {
            if (type.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH ||
                (type.isNotBaseArray() && this.args.length !== type.length) ||
                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {
                return false;
            }
            let arrayElementType = type.arrayElementType;
            for (let i = 0; i < this.args.length; i++) {
                let testedInstruction = this.args[i];
                if (testedInstruction.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr) {
                    if (!testedInstruction.optimizeForVariableType(arrayElementType)) {
                        return false;
                    }
                }
                else {
                    // if (SystemScope.isSamplerType(arrayElementType)) {
                    //     if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {
                    //         return false;
                    //     }
                    // }
                    // else 
                    {
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(testedInstruction.type, arrayElementType)) {
                            return false;
                        }
                    }
                }
            }
            this._type = type.baseType;
            return true;
        }
        else {
            let firstInstruction = this.args[0];
            if (this.args.length === 1 &&
                firstInstruction.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr) {
                // if (SystemScope.isSamplerType(type)) {
                //     if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {
                //         return true;
                //     }
                //     else {
                //         return false;
                //     }
                // }
                // TODO: remove this hack!!
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT)) {
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT)) {
                        return true;
                    }
                }
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, type)) {
                    return true;
                }
                return false;
            }
            else if (this.args.length === 1) {
                return false;
            }
            let args = this.args;
            let fieldNameList = type.fields.map(f => f.name);
            for (let i = 0; i < args.length; i++) {
                let fieldType = type.getField(fieldNameList[i]).type;
                if (!args[i].optimizeForVariableType(fieldType)) {
                    return false;
                }
            }
            this._type = type.baseType;
            return true;
        }
    }
}


/***/ }),

/***/ "hbjL":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Instruction.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Instruction": () => (/* binding */ Instruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");


class Instruction {
    constructor({ scope, instrType /* = EInstructionTypes.k_Instruction*/, sourceNode = null, visible = true }) {
        this._sourceNode = sourceNode;
        this._instructionType = instrType;
        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);
        this._scope = scope;
        this._parent = null;
        this._lastError = null;
    }
    get parent() {
        // console.assert(this._parent, "Parent is not defined!");
        return this._parent;
    }
    get instructionType() {
        console.assert(this._instructionType != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Instruction, "Instruction type 'k_Instruction' is forbidden.");
        return this._instructionType;
    }
    get instructionName() {
        return _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes[this.instructionType];
    }
    get instructionID() {
        return this._instructionID;
    }
    get scope() {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._scope)) {
            return this._scope;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent)) {
            return this.parent.scope;
        }
        return null;
    }
    get sourceNode() {
        return this._sourceNode;
    }
    toString() {
        console.error("@pure_virtual");
        return null;
    }
    toCode() {
        console.error("@pure_virtual");
        return null;
    }
    $withParent(parent) {
        console.assert(this._parent == null, "parent redefenition detected!");
        if (this.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType && this.name === 'float' && this._parent == null && parent != null) {
            debugger;
        }
        this._parent = parent;
        // todo: remove this hack!
        return this;
    }
    // An auxiliary function created to maintain the clarity of the code.
    $withNoParent() {
        return this;
    }
    static $withParent(child, parent) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(child)) {
            return null;
        }
        return child.$withParent(parent);
    }
    static $withNoParent(child) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(child)) {
            return null;
        }
        return child.$withNoParent();
    }
}
Instruction.INSTRUCTION_COUNTER = 0;


/***/ }),

/***/ "pjXG":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InstructionCollector.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionCollector": () => (/* binding */ InstructionCollector)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class InstructionCollector extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ instructions = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Collector, ...settings });
        this._instructions = instructions;
    }
    get instructions() {
        return this._instructions;
    }
    push(instr) {
        this._instructions.push(instr);
    }
    toCode() {
        let code = "";
        for (const instr of this.instructions) {
            switch (instr.instructionType) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableDecl:
                    code += instr.toCode() + ';\n';
                    break;
                default:
                    code += instr.toCode() + '\n';
            }
        }
        return code;
    }
}


/***/ }),

/***/ "s0og":
/*!************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IntInstruction.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntInstruction": () => (/* binding */ IntInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class IntInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ base, signed, exp, heximal = false, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_IntExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes 
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(signed ? _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT : _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.base = base;
        this.exp = exp;
        this.signed = signed;
        this.heximal = heximal;
        if (!signed) {
            this.base >>>= 0;
        }
    }
    get value() {
        return (this.base * Math.pow(10, this.exp));
    }
    toString() {
        return `${this.heximal ? '0x' : ''}${this.base.toString(this.heximal ? 16 : 10).toUpperCase()}${this.exp !== 0 ? `e${this.exp}` : ''}${this.signed ? '' : 'u'}`;
    }
    toCode() {
        return this.toString();
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "Oxvu":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogicalExprInstruction": () => (/* binding */ LogicalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represent boolExpr && || boolExpr
 * (&& | ||) Instruction Instruction
 */
class LogicalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_LogicalExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.T_BOOL, ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    toCode() {
        var sCode = "";
        sCode += this.left.toCode();
        sCode += this.operator;
        sCode += this.right.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "a5rM":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/NullInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullInstruction": () => (/* binding */ NullInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



class NullInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_NullExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_NULL, scope, ...settings });
    }
    get value() {
        return null;
    }
    toString() {
        return `NULL`;
    }
    toCode() {
        return this.toString();
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "Z/0D":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PassInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PassInstruction": () => (/* binding */ PassInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "hbjL");






class PassInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_4__.DeclInstruction {
    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_PassDecl, ...settings });
        this._passStateMap = {};
        PassInstruction.clearRenderStateMap(this._passStateMap);
        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);
        this._vertexShader = _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withNoParent(vertexShader);
        this._pixelShader = _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withNoParent(pixelShader);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get name() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._id)) {
            return null;
        }
        return this._id.name;
    }
    get vertexShader() {
        return this._vertexShader;
    }
    get pixelShader() {
        return this._pixelShader;
    }
    getState(state) {
        return this._passStateMap[state];
    }
    get renderStates() {
        return this._passStateMap;
    }
    // TODO: move it to helpers
    static copyRenderStateMap(from, to) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(from)) {
            return;
        }
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates)
            .filter(k => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k])
            .forEach(rs => { to[rs] = from[rs] || to[rs]; });
    }
    // TODO: move it to helpers
    static clearRenderStateMap(map) {
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates)
            .filter(k => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k])
            .forEach(rs => { map[rs] = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__.ERenderStateValues.UNDEF; });
    }
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "fxHi":
/*!**************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixArithmeticInstruction": () => (/* binding */ PostfixArithmeticInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr ++
 * (-- | ++) Instruction
 */
class PostfixArithmeticInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ expr, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });
        this._operator = operator;
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.expr.toCode();
        code += this.operator;
        return code;
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "yhcv":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixIndexInstruction": () => (/* binding */ PostfixIndexInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent element[index]
 * EMPTY_OPERATOR Instruction ExprInstruction
 */
class PostfixIndexInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ element, index, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr,
            type: element.type.arrayElementType, ...settings
        });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(element, this);
        this.index = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(index, this);
    }
    toCode() {
        return `${this.element.toCode()}[${this.index.toCode()}]`;
    }
    isConst() {
        return this.element.isConst() && this.index.isConst();
    }
}


/***/ }),

/***/ "++2t":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixPointInstruction": () => (/* binding */ PostfixPointInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr.id
 * EMPTY_OPERATOR Instruction IdInstruction
 */
class PostfixPointInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ element, postfix, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(element, this);
        this.postfix = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(postfix, this);
    }
    toCode() {
        return `${this.element.toCode()}.${this.postfix.toCode()}`;
    }
    isConst() {
        return this.element.isConst();
    }
}


/***/ }),

/***/ "6z3E":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Preset.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PresetInstruction": () => (/* binding */ PresetInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class PresetInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ props, id = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PresetDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(id, this);
        this._props = props.map(prop => _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(prop, this));
    }
    get id() {
        return this._id;
    }
    get name() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._id)) {
            return null;
        }
        return this._id.name;
    }
    get props() {
        return this._props;
    }
    toCode() {
        return `${this.id} = {\n${this.props.map(prop => prop.toCode()).join(';\n')}\n}`;
    }
}


/***/ }),

/***/ "vF1C":
/*!************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PresetProperty.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PresetProperty": () => (/* binding */ PresetProperty)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class PresetProperty extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ id, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PresetProperty, ...settings });
        this.id = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(id, this);
        this.args = args.map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(arg, this));
    }
    resolveDeclaration() {
        return this.scope.findVariable(this.id.name);
    }
    toCode() {
        return `${this.id} = { ${this.args.map(arg => arg.toCode()).join(',')} }`;
    }
}


/***/ }),

/***/ "Tk3Z":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProvideInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProvideInstruction": () => (/* binding */ ProvideInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class ProvideInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ moduleName, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Provide, ...settings });
        this._value = moduleName;
    }
    get moduleName() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
}


/***/ }),

/***/ "ijf+":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProxyTypeInstruction": () => (/* binding */ ProxyTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "pEQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class ProxyTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor(settings) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType, ...settings });
        this._host = null;
    }
    get host() {
        return this._host;
    }
    get writable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get readable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get name() {
        return this.isResolved() ? this.host.name : 'auto';
    }
    get size() {
        return this.isResolved() ? this.host.size : _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE;
    }
    get baseType() {
        return this.host;
    }
    get arrayElementType() {
        return this.isResolved() ? this.host.arrayElementType : null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this.isResolved() ? this.host.length : _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_LENGTH;
    }
    get fields() {
        return this.isResolved() ? this.host.fields : [];
    }
    get methods() {
        return [];
    }
    isResolved() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.host);
    }
    resolve(host) {
        this._host = host;
    }
    toString() {
        return this.isResolved() ? this.host.toString() : this.name;
    }
    /** @deprecated */
    toDeclString() {
        return this.isResolved() ? this.host.toDeclString() : null;
    }
    toCode() {
        return this.isResolved() ? this.host.toCode() : this.name;
    }
    isArray() {
        return this.isResolved() ? this.host.isArray() : false;
    }
    isNotBaseArray() {
        return this.isResolved() ? this.host.isNotBaseArray() : false;
    }
    isComplex() {
        return this.isResolved() ? this.host.isComplex() : false;
    }
    hasFieldWithSematics(semantic) {
        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;
    }
    getField(fieldName) {
        return this.isResolved() ? this.host.getField(fieldName) : null;
    }
    getMethod(methodName, args) {
        return this.isResolved() ? this.host.getMethod(methodName, args) : null;
    }
    getFieldBySemantics(semantic) {
        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;
    }
    hasFieldWithoutSemantics() {
        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;
    }
    hasAllUniqueSemantics() {
        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;
    }
}


/***/ }),

/***/ "2i/b":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RelationalExprInstruction": () => (/* binding */ RelationalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent someExpr == != < > <= >= someExpr
 * (==|!=|<|>|<=|>=) Instruction Instruction
 */
class RelationalExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ left, right, operator, instrType, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_RelationalExpr,
            type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__[`T_BOOL${left.type.length > 1 ? left.type.length : ''}`],
            ...settings
        });
        this._leftOperand = left;
        this._rightOperand = right;
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.left.toCode();
        code += ` ${this.operator} `;
        code += this.right.toCode();
        return code;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "UL2e":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReturnStmtInstruction": () => (/* binding */ ReturnStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent return expr;
 * return ExprInstruction
 */
class ReturnStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ expr = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt, ...settings });
        this._operator = "return";
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(expr, this);
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        if (this.expr) {
            return "return " + this.expr.toCode() + ";";
        }
        else {
            return "return;";
        }
    }
}


/***/ }),

/***/ "Po1l":
/*!**********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SemicolonStmtInstruction": () => (/* binding */ SemicolonStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");


/**
 * Represent empty statement only semicolon ;
 * ;
 */
class SemicolonStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SemicolonStmt, ...settings });
    }
    toCode() {
        return ";";
    }
}


/***/ }),

/***/ "z98Y":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StateBlockInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateBlockInstruction": () => (/* binding */ StateBlockInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");


class StateBlockInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ type, blocks = null, props = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StateBlockExpr, type, ...settings });
        this.props = props;
        this.blocks = blocks;
    }
    toCode() {
        console.error(`not implemeted`);
        return null;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "fc3/":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StmtBlockInstruction": () => (/* binding */ StmtBlockInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent {stmts}
 * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
 */
class StmtBlockInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ stmtList, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock, ...settings });
        this._stmtList = stmtList.map(stmt => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(stmt, this));
    }
    get stmtList() {
        return this._stmtList;
    }
    toCode() {
        var code = "{" + "\n";
        for (var i = 0; i < this.stmtList.length; i++) {
            code += "\t" + this.stmtList[i].toCode() + "\n";
        }
        code += "}";
        return code;
    }
}


/***/ }),

/***/ "pGoc":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StmtInstruction": () => (/* binding */ StmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


/**
 * Represent all kind of statements
 */
class StmtInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Stmt, ...settings });
    }
}


/***/ }),

/***/ "mlvU":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StringInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringInstruction": () => (/* binding */ StringInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class StringInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_StringExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_STRING, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this._value = value;
    }
    get value() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "F8nM":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemFunctionInstruction": () => (/* binding */ SystemFunctionInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FunctionDeclInstruction */ "BLpd");



class SystemFunctionInstruction extends _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__.FunctionDeclInstruction {
    // protected _bForCompute;
    // protected _bForGeometry;
    constructor({ vertex = true, pixel = true, impl = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemFunctionDecl, impl: null, ...settings });
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl));
        this._bForVertex = vertex;
        this._bForPixel = pixel;
    }
    checkVertexUsage() {
        return this._bForVertex;
    }
    checkPixelUsage() {
        return this._bForPixel;
    }
    $makeVertexCompatible(val) {
        console.warn("@deprecated");
        this._bForVertex = val;
    }
    $makePixelCompatible(val) {
        console.warn("@deprecated");
        this._bForPixel = val;
    }
}


/***/ }),

/***/ "/VpG":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemTypeInstruction": () => (/* binding */ SystemTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class SystemTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ name, size = 0, elementType = null, length = 1, fields = [], methods = [], writable = true, readable = true, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemType, ...settings });
        this._name = name;
        this._size = size;
        this._elementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(elementType);
        this._length = length;
        this._fields = [];
        this._methods = [];
        this._bIsWritable = writable;
        this._bIsReadable = readable;
        fields.forEach(field => this.addField(field));
        methods.forEach(method => this.addMethod(method));
    }
    get writable() {
        return this._bIsWritable;
    }
    get readable() {
        return this._bIsReadable;
    }
    get name() {
        return this._name;
    }
    get size() {
        if (this.isArray()) {
            if (this.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH;
            }
            return this.arrayElementType.size * this.length;
        }
        return this._size;
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return this._elementType;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this._length;
    }
    get fields() {
        return this._fields;
    }
    get methods() {
        return this._methods;
    }
    toDeclString() {
        console.warn('@pure_virtual');
        return '';
    }
    isArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.arrayElementType);
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return false;
    }
    isContainPointer() {
        return false;
    }
    toString() {
        return this.name || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.hash(this);
    }
    toCode() {
        return this._name;
    }
    hasFieldWithSematics(semantic) {
        return false;
    }
    hasAllUniqueSemantics() {
        return false;
    }
    hasFieldWithoutSemantics() {
        return false;
    }
    getField(fieldName) {
        return this._fields.find(field => field.name === fieldName) || null;
    }
    getMethod(methodName, args) {
        const list = this._methods.filter(method => method.name === methodName);
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.fn.matchList(list, args);
    }
    getFieldBySemantics(semantic) {
        console.error("@undefined_behavior");
        return null;
    }
    /** internal api */
    addField(field) {
        console.assert(this.getField(field.name) === null);
        this._fields.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(field, this));
    }
    /** internal api */
    addMethod(method) {
        console.assert((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.getMethod(method.name, method.def.params.map(param => param.type))));
        this._methods.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(method, this));
    }
}


/***/ }),

/***/ "QdWn":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Technique11Instruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Technique11Instruction": () => (/* binding */ Technique11Instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class Technique11Instruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ name, passes, presets, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Technique11Decl, ...settings });
        this._name = name;
        this.passes = passes?.map(pass => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(pass, this));
    }
    get name() {
        return this._name;
    }
    /** @deprecated */
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "dmHP":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TechniqueInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TechniqueInstruction": () => (/* binding */ TechniqueInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class TechniqueInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ name, techniqueType, passes, presets, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_TechniqueDecl, ...settings });
        this._name = name;
        this.passes = passes?.map(pass => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(pass, this));
        this.type = techniqueType;
        this.presets = presets;
    }
    get name() {
        return this._name;
    }
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "Jg/d":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeDeclInstruction": () => (/* binding */ TypeDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// TODO: add description comment.
class TypeDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypeDecl, ...settings });
        this.type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(type, this);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.type));
    }
    get name() {
        return this.type.name;
    }
    toCode() {
        return this.type.toDeclString() + ";";
    }
}


/***/ }),

/***/ "jSFO":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypedInstruction.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedInstruction": () => (/* binding */ TypedInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class TypedInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Typed, ...settings });
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withNoParent(type);
        // todo: remove this check
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._type)) {
            console.warn("Something goes wrong! Type is not specified!", this);
        }
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "bYYM":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypedefInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedefInstruction": () => (/* binding */ TypedefInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// TODO: add description comment.
class TypedefInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ type, alias, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypedefDecl, ...settings });
        this.type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this.alias = alias;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.type));
    }
    get name() {
        return this.type?.name;
    }
    toCode() {
        return `typedef ${this.type.toDeclString()} ${this.alias};`;
    }
}


/***/ }),

/***/ "Dbly":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnaryExprInstruction": () => (/* binding */ UnaryExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VariableTypeInstruction */ "6EL/");





/**
 * Represent + - ! ++ -- expr
 * (+|-|!|++|--|) Instruction
 */
class UnaryExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ expr, operator, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_UnaryExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: operator === '!'
                ? _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.T_BOOL, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.SCOPE)
                : expr.type,
            ...settings
        });
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(expr, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        var sCode = '';
        sCode += this.operator;
        sCode += this.expr.toCode();
        return sCode;
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "k9uP":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVariableUsageFlags": () => (/* binding */ EVariableUsageFlags),
/* harmony export */   "VariableDeclInstruction": () => (/* binding */ VariableDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * @deprecated
 */
var EVariableUsageFlags;
(function (EVariableUsageFlags) {
    EVariableUsageFlags[EVariableUsageFlags["k_Local"] = 1] = "k_Local";
    EVariableUsageFlags[EVariableUsageFlags["k_Global"] = 2] = "k_Global";
    EVariableUsageFlags[EVariableUsageFlags["k_Argument"] = 4] = "k_Argument";
    EVariableUsageFlags[EVariableUsageFlags["k_Cbuffer"] = 8] = "k_Cbuffer";
})(EVariableUsageFlags || (EVariableUsageFlags = {}));
/**
 * Represent type var_name [= init_expr]
 * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
 */
class VariableDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ id, type, init = null, usageFlags = 0, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(id, this);
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this._initExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(init, this);
        this._usageFlags = usageFlags;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isParameter() || ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent) || this.parent.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionDef));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLocal() || !this.isLocal());
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isParameter() || this.isLocal());
    }
    get usageFlags() {
        return this._usageFlags;
    }
    get initExpr() {
        return this._initExpr;
    }
    get type() {
        return this._type;
    }
    get name() {
        return this._id.name;
    }
    get id() {
        return this._id;
    }
    isGlobal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Global);
    }
    isLocal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Local);
    }
    isParameter() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);
    }
    isField() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent)) {
            return false;
        }
        const parentType = this.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType ||
            parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType ||
            parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType) {
            return true;
        }
        return false;
    }
    isConstant() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Cbuffer) || this.type.isUniform();
    }
    toCode() {
        var code = '';
        code = this.type.toCode();
        code += ' ' + this.id.toCode();
        if (this.type.isNotBaseArray()) {
            var iLength = this.type.length;
            code += '[' + iLength + ']';
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.initExpr) &&
            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?
            !this.type.isUniform()) {
            code += '=' + this.initExpr.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ "6EL/":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariableTypeInstruction": () => (/* binding */ VariableTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class VariableTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_PADDING, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType, ...settings });
        type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this._usageList = [];
        let instrType = type.instructionType;
        if (instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ProxyType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexType) {
            this._subType = type;
        }
        else {
            let varType = type;
            // TODO: review this code
            if (!varType.isNotBaseArray()) {
                this._subType = varType.subType;
                varType.usages.forEach(usage => this.addUsage(usage));
            }
            else {
                this._subType = type;
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this._subType));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this._usageList));
        this._isWritable = writable;
        this._isReadable = readable;
        this._arrayIndexExpr = null;
        this._arrayElementType = null;
        this._padding = padding;
        this._aligment = 1;
        if (arrayIndex) {
            // todo: add support for v[][10]
            // todo: move elements construction to analyzer, don't make it implicitly
            this._arrayElementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: this.subType, usages: this._usageList }), this);
            this._arrayIndexExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(arrayIndex, this);
        }
        // todo: array element type must be constructed with proper usages and read/write flags!
        // else if (this.isArray()) {
        //     this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: type.arrayElementType, usages: this._usageList }), this);
        // }
        usages.forEach(usage => this.addUsage(usage));
    }
    get name() {
        return this.baseType.name;
    }
    get writable() {
        if (!this._isWritable) {
            return false;
        }
        if ( /*(this.isArray() && !this.isBase()) || */this.isUniform()) {
            return false;
        }
        if (this.isConst()) {
            return false;
        }
        // check for usages.includes('in') ?
        return this.subType.writable;
    }
    get readable() {
        if (!this._isReadable) {
            return false;
        }
        if (this.usages.includes("out")) {
            return false;
        }
        return this.subType.readable;
    }
    get methods() {
        return this.subType.methods;
    }
    get aligment() {
        return this._aligment;
    }
    // TODO: move to helpers
    get size() {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType)) {
            const size = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.alignSize(this._arrayElementType.size, this.aligment);
            const length = this.length;
            if (length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH || size === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_SIZE) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_SIZE;
            }
            return size * length;
        }
        // return type.alignSize(this.subType.size, this.aligment);
        return this.subType.size;
    }
    get baseType() {
        return this.subType.baseType;
    }
    get length() {
        if (!this.isNotBaseArray()) { // not a user defined array like arr[10]
            // for ex. if type is float3x4 then length is 3
            return this.subType.length;
        }
        // IP: arrays like float[]?
        if (this.isNotBaseArray() && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType)) {
            return this.subType.length;
        }
        // arrays like float[10]
        const expr = this._arrayIndexExpr;
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isLiteral(expr)) {
            return Number(expr.value);
        }
        // arrays like float[N];
        const len = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.evalConst(expr);
        return len < 0 ? _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH : len;
    }
    get padding() {
        return this._padding;
    }
    get arrayElementType() {
        if (!this.isArray()) {
            return null;
        }
        // todo: fix this.subType.arrayElementType!
        return this._arrayElementType || this.subType.arrayElementType;
    }
    get usages() {
        let usages = [...this._usageList];
        let subType = this.subType;
        while (subType && subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType) {
            const vtype = subType;
            // todo: remove duplicates
            usages = [...usages, ...vtype.usages];
            subType = vtype.subType;
        }
        return usages;
    }
    get subType() {
        return this._subType;
    }
    get fields() {
        return this.subType.fields;
    }
    toString() {
        // TODO: fix this condition
        return this.name || this.subType.toString() || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.hash(this);
    }
    toCode() {
        let code = "";
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._usageList)) {
            for (let i = 0; i < this._usageList.length; i++) {
                code += this._usageList[i] + " ";
            }
        }
        code += this.subType.toCode();
        return code;
    }
    /** @deprecated */
    toDeclString() {
        return this.subType.toDeclString();
    }
    isArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType) || this.subType.isArray();
    }
    // Returns true if the type is user defined array.
    // like an ordinary array: int a[5]
    // not a base array like: float4/int3 etc.
    isNotBaseArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType) || this.subType.isNotBaseArray();
    }
    isComplex() {
        return this.subType.isComplex();
    }
    isUniform() {
        return this.usages.includes("uniform");
    }
    isConst() {
        return this.usages.includes("const");
    }
    isUnsigned() {
        return this.usages.includes("unsigned");
    }
    isStatic() {
        return this.usages.includes("static");
    }
    $overwritePadding(padding, aligment) {
        this._padding = padding;
        this._aligment = aligment;
    }
    addUsage(usage) {
        if (!this.usages.includes(usage)) {
            this._usageList.push(usage);
        }
    }
    hasFieldWithSematics(semantic) {
        return this.subType.hasFieldWithSematics(semantic);
    }
    hasAllUniqueSemantics() {
        return this.subType.hasAllUniqueSemantics();
    }
    hasFieldWithoutSemantics() {
        return this.subType.hasFieldWithoutSemantics();
    }
    getField(fieldName) {
        // TODO: propogate usages? atleast readable/writable
        return this.subType.getField(fieldName);
    }
    getMethod(methodName, args) {
        return this.subType.getMethod(methodName, args);
    }
    getFieldBySemantics(semantic) {
        // TODO: propogate usages?
        return this.subType.getFieldBySemantics(semantic);
    }
    /**
     * Helpers
     */
    // TODO: move to type.ts
    /** @deprecated */
    static wrap(type, scope) {
        return new VariableTypeInstruction({ type, scope });
    }
    // TODO: move to type.ts
    /** @deprecated */
    static wrapAsConst(type, scope) {
        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });
    }
}


/***/ }),

/***/ "eHl7":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WhileStmtInstruction": () => (/* binding */ WhileStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent while(expr) stmt
 * ( while || do_while) ExprInstruction StmtInstruction
 */
class WhileStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ cond, body, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt, ...settings });
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(cond, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(body, this);
        this._operator = operator;
    }
    get cond() {
        return this.cond;
    }
    get body() {
        return this._body;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        if (this.operator === "while") {
            code += "while(";
            code += this.cond.toCode();
            code += ")";
            code += this.body.toCode();
        }
        else {
            code += "do";
            code += this.body.toCode();
            code += "while(";
            code += this.cond.toCode();
            code += ");";
        }
        return code;
    }
}


/***/ }),

/***/ "9jn4":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/DrawInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawInstruction": () => (/* binding */ DrawInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StmtInstruction */ "pGoc");


class DrawInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DrawStmt, ...settings });
        this.name = name;
        this.args = args;
    }
    toCode() {
        return `draw ${this.name};`;
    }
}


/***/ }),

/***/ "0Qwk":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartFxInstruction": () => (/* binding */ PartFxInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_fx_analisys_instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/TechniqueInstruction */ "dmHP");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");




// var s: IPartFxInstructionSettings;
// s.te
class PartFxInstruction extends _lib_fx_analisys_instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_2__.TechniqueInstruction {
    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PartFxDecl, techniqueType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.ETechniqueType.k_PartFx, ...settings });
        this.spawnRoutine = spawnRoutine;
        this.initRoutine = initRoutine;
        this.updateRoutine = updateRoutine;
        this.particle = particle;
        this.capacity = capacity;
    }
    isValid() {
        if (!this.spawnRoutine) {
            console.error(`no spawn routine found`);
            return false;
        }
        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.equals(this.spawnRoutine.function.def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_VOID)) {
            if (!this.initRoutine) {
                console.error(`init routine must be defined if regular spawner is used`);
                return false;
            }
        }
        if (!this.updateRoutine) {
            console.error(`no update routine found`);
            return false;
        }
        const particleCheck = !!this.particle;
        const passCheck = this.passes && this.passes.filter((pass) => pass.isValid()).length > 0;
        return particleCheck && passCheck;
    }
}


/***/ }),

/***/ "pCHB":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartFxPassInstruction": () => (/* binding */ PartFxPassInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PassInstruction */ "Z/0D");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");




class PartFxPassInstruction extends _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__.PassInstruction {
    constructor({ sorting = false, instanceCount = 1, drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_3__.EPassDrawMode.k_Auto, prerenderRoutine, geometry, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PartFxPass, ...settings });
        this.sorting = sorting;
        this.prerenderRoutine = prerenderRoutine;
        this.geometry = geometry;
        this.instanceCount = instanceCount;
        this.drawMode = drawMode;
    }
    get particleInstance() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.prerenderRoutine)) {
            return null;
        }
        return this.prerenderRoutine.function.def.params[1].type.subType;
    }
    isValid() {
        return !!this.particleInstance && !!this.prerenderRoutine;
    }
}


/***/ }),

/***/ "sg/T":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpawnInstruction": () => (/* binding */ SpawnInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StmtInstruction */ "pGoc");


class SpawnInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    // private _fx: IPartFxInstruction = null;
    // private _init: IFunctionDeclInstruction = null;
    constructor({ count, name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SpawnStmt, ...settings });
        this.count = count;
        this.args = args;
        this.name = name;
    }
    // get fx(): IPartFxInstruction {
    //     return this._fx;
    // }
    // get init(): IFunctionDeclInstruction {
    //     return this._init;
    // }
    toCode() {
        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;
    }
}


/***/ }),

/***/ "Xi4d":
/*!**********************************************************************!*\
  !*** ./src/lib/fx/analisys/system/AppendStructuredBufferTemplate.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");








class AppendStructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('AppendStructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__.VariableTypeInstruction({ type: args[0], scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, name: 'Append' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            const returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, name: 'Append' });
            const def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_6__.FunctionDefInstruction({ scope, returnType, id, paramList });
            const func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_5__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppendStructuredBufferTemplate);


/***/ }),

/***/ "6tHU":
/*!******************************************************!*\
  !*** ./src/lib/fx/analisys/system/BufferTemplate.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class BufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('Buffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(args[0])) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BufferTemplate);


/***/ }),

/***/ "Zvql":
/*!********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWBufferTemplate.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('RWBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(args[0])) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWBufferTemplate);


/***/ }),

/***/ "o6IR":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWStructuredBufferTemplate.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");







class RWStructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor() {
        super('RWStructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'IncrementCounter' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'DecrementCounter' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWStructuredBufferTemplate);


/***/ }),

/***/ "vqrB":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWTexture1DTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWTexture1DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(RWTexture1DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
RWTexture1DTemplate.TYPE_NAME = 'RWTexture1D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWTexture1DTemplate);


/***/ }),

/***/ "cO3W":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWTexture2DTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWTexture2DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(RWTexture2DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, });
    }
}
RWTexture2DTemplate.TYPE_NAME = 'RWTexture2D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWTexture2DTemplate);


/***/ }),

/***/ "b3Cg":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/system/StructuredBufferTemplate.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");



class StructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('StructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StructuredBufferTemplate);


/***/ }),

/***/ "/tL8":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture2DArrayTemplate.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture2DArrayTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture2DArrayTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dx' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dy' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleGrad' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture2DArrayTemplate.TYPE_NAME = 'Texture2DArray';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture2DArrayTemplate);


/***/ }),

/***/ "czsy":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture2DTemplate.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture2DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture2DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            const rtName = `${type.isArray() ? type.arrayElementType.name : type.name}4`;
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: scope.findType(rtName), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Gather' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f1 = scope.findType("float");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f1, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'lod' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleLevel' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dx' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dy' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleGrad' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'mipLevel' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'width' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'height' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'GetDimensions' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let int3 = scope.findType("int3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: int3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'location' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: elementType, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Load' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture2DTemplate.TYPE_NAME = 'Texture2D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture2DTemplate);


/***/ }),

/***/ "3stO":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture3DTemplate.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture3DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture3DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture3DTemplate.TYPE_NAME = 'Texture3D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture3DTemplate);


/***/ }),

/***/ "rn9U":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/system/TextureCubeArrayTemplate.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class TextureCubeArrayTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(TextureCubeArrayTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
TextureCubeArrayTemplate.TYPE_NAME = 'TextureCubeArray';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextureCubeArrayTemplate);


/***/ }),

/***/ "vjwK":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/TextureCubeTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class TextureCubeTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(TextureCubeTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'lod' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleLevel' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
TextureCubeTemplate.TYPE_NAME = 'TextureCube';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextureCubeTemplate);


/***/ }),

/***/ "LRe5":
/*!*******************************************************!*\
  !*** ./src/lib/fx/analisys/system/TriMeshTemplate.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IntInstruction */ "s0og");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");










class TriMeshTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_9__["default"] {
    constructor() {
        super('TriMesh');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'vertCount' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'faceCount' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'GetDimensions' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'vert' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: elementType, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadVertex' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("uint3"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadFace' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__.parseUintLiteral)("6u");
                const arrayIndex = new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__.IntInstruction({ scope, base, exp, signed, heximal });
                const uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'adjacency' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadGSAdjacency' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__.parseUintLiteral)("3u");
                const arrayIndex = new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__.IntInstruction({ scope, base, exp, signed, heximal });
                const uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'adjacency' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadFaceAdjacency' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriMeshTemplate);


/***/ }),

/***/ "+jyi":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/system/TypeTemplate.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class TypeTemplate {
    constructor(name) {
        this.name = name;
    }
    produceType(scope, args) {
        return null;
    }
    typeName(args) {
        if (args && args.length > 0) {
            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;
        }
        return this.name;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TypeTemplate);


/***/ }),

/***/ "9ebs":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/system/api.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemFunctions": () => (/* binding */ addSystemFunctions)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

// TODO: rework system function templates for better readability
function addSystemFunctions(scope) {
    // todo: rework setup of system functions according with microsoft docs.
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dot", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul
    // TODO: add support for int|uint|bool based vectors 
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, ["float", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float4", ["float4", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4x4", "float4x3", "float4x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float3", ["float3", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3x4", "float3x3", "float3x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float2", ["float2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2x4", "float2x3", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float4"], ["float4x4", "float3x4", "float2x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float3"], ["float4x3", "float3x3", "float2x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float2"], ["float4x2", "float3x2", "float2x2"]);
    /**
     * scalar = int|uint|float
     * vector = vector<int|uint|float, n>, n = 2,3,4
     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4
     *
     * scalar mul(scalar, scalar)
     * vector mul(scalar, vector)
     * vector mul(vector, scalar)
     * vector mul(vector, vector)
     * matrix mul(scalar, matrix)
     * matrix mul(matrix, scalar)
     * vector mul(vector, matrix)
     * vector mul(matrix, vector)
     * matrix mul(matrix, matrix)
     */
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", "float", ["float", "float"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "floor", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "round", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "ceil", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "fract", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "abs", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "abs", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sign", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sign", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "normalize", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "length", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "cross", "float3", ["float3", "float3"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "reflect", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "fmod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "ldexp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "reversebits", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clamp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clamp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float", "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "pow", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "exp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "exp2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "log", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "log2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "inversesqrt", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sqrt", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "all", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    // generateSystemFunction(scope, "any", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    /** @deprecated (SM4) */
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "not", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "distance", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "radians", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "degrees", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sin", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "cos", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sincos", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, `out ${_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE}`, `out ${_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE}`], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "tan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asin", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "acos", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler", "float2"], null);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler2D", "float2"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float3"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float3"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float4"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float4"], null);
    // generateSystemFunction(scope, "texCUBE", "float4", ["sampler", "float3"], null);
    // generateSystemFunction(scope, "texCUBE", "float4", ["samplerCUBE", "float3"], null);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler", "float2", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler2D", "float2", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float4", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float4", "float"], null, false, true);
    // generateSystemFunction(scope, "texCUBE", "float4", ["sampler", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "texCUBE", "float4", ["samplerCUBE", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DLod", "float4", ["sampler", "float2", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DLod", "float4", ["sampler2D", "float2", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler2D", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler", "float4", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler2D", "float4", "float"], null, true, false);
    // generateSystemFunction(scope, "texCUBELod", "float4", ["sampler", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "texCUBELod", "float4", ["samplerCUBE", "float3", "float"], null, true, false);
    //OES_standard_derivatives
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dFdx", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dFdy", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "width", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "fwidth", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "smoothstep", "float3", ["float3", "float3", "float3"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "smoothstep", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "smoothstep", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, ["float", "float", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "step", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clip", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_PS);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "frac", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lerp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lerp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "saturate", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "InterlockedAdd", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int"]);
    // generateSystemFunction(scope, "InterlockedAdd", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "f16tof32", "float", ["uint"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "f32tof16", "uint", ["float"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "uint", "float", "bool"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int2", "uint2", "float2", "bool2", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int3", "uint3", "float3", "bool3", "float3x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int4", "uint4", "float4", "bool4", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "uint", "float", "bool"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int2", "uint2", "float2", "bool2", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int3", "uint3", "float3", "bool3", "float3x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int4", "uint4", "float4", "bool4", "float4x4"]);
    // DX12
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "WaveGetLaneIndex", "uint", [], ["void"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "WaveActiveBallot", "uint4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool"]);
    // control flow
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetVertexShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["VertexShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetPixelShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["PixelShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetGeometryShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["GeometryShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetDepthStencilState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "int"], ["DepthStencilState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetBlendState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["BlendState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW); // todo: use correct arguments
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetRasterizerState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["RasterizerState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW); // todo: use correct arguments
}


/***/ }),

/***/ "OC3L":
/*!***********************************************!*\
  !*** ./src/lib/fx/analisys/system/builtin.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeBuiltin": () => (/* binding */ addSystemTypeBuiltin)
/* harmony export */ });
/* harmony import */ var _AppendStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AppendStructuredBufferTemplate */ "Xi4d");
/* harmony import */ var _BufferTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferTemplate */ "6tHU");
/* harmony import */ var _RWBufferTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RWBufferTemplate */ "Zvql");
/* harmony import */ var _RWStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RWStructuredBufferTemplate */ "o6IR");
/* harmony import */ var _RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RWTexture1DTemplate */ "vqrB");
/* harmony import */ var _RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RWTexture2DTemplate */ "cO3W");
/* harmony import */ var _StructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StructuredBufferTemplate */ "b3Cg");
/* harmony import */ var _Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Texture2DArrayTemplate */ "/tL8");
/* harmony import */ var _Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Texture2DTemplate */ "czsy");
/* harmony import */ var _Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Texture3DTemplate */ "3stO");
/* harmony import */ var _TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureCubeArrayTemplate */ "rn9U");
/* harmony import */ var _TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextureCubeTemplate */ "vjwK");
/* harmony import */ var _TriMeshTemplate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TriMeshTemplate */ "LRe5");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils */ "BeyE");














function addSystemTypeBuiltin(scope) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "SamplerState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "SamplerComparisonState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "DepthStencilState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "BlendState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "RasterizerState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "VertexShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "PixelShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "ComputeShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "GeometryShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "HullShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "DomainShader", 4);
    // generateSystemType(scope, "texture");
    // generateSystemType(scope, "sampler");
    // generateSystemType(scope, "sampler2D");
    // generateSystemType(scope, "samplerCUBE");
    scope.addTypeTemplate(new _BufferTemplate__WEBPACK_IMPORTED_MODULE_1__["default"]);
    scope.addTypeTemplate(new _RWBufferTemplate__WEBPACK_IMPORTED_MODULE_2__["default"]);
    scope.addTypeTemplate(new _RWStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_3__["default"]);
    scope.addTypeTemplate(new _AppendStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_0__["default"]);
    scope.addTypeTemplate(new _StructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_6__["default"]);
    scope.addTypeTemplate(new _TriMeshTemplate__WEBPACK_IMPORTED_MODULE_12__["default"]);
    scope.addTypeTemplate(new _RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__["default"]);
    scope.addTypeTemplate(new _RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__["default"]);
    // TODO: RWTexture3D
    // TODO: Texture1D
    scope.addTypeTemplate(new _Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__["default"]);
    scope.addTypeTemplate(new _Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__["default"]);
    scope.addTypeTemplate(new _TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__["default"]);
    // TODO: Texture1DArray
    scope.addTypeTemplate(new _Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__["default"]);
    // TODO: Texture3DArray
    scope.addTypeTemplate(new _TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__["default"]);
    // produce default Texture2D type
    const templateTexture2D = scope.findTypeTemplate(_Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__["default"].TYPE_NAME);
    const typeTexture2D = templateTexture2D.produceType(scope, []);
    scope.addType(typeTexture2D);
    // produce default TextureCube type
    const templateTextureCube = scope.findTypeTemplate(_TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__["default"].TYPE_NAME);
    const typeTextureCube = templateTextureCube.produceType(scope, []);
    scope.addType(typeTextureCube);
    // produce default Texture3D type
    const templateTexture3D = scope.findTypeTemplate(_Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__["default"].TYPE_NAME);
    const typeTexture3D = templateTexture3D.produceType(scope, []);
    scope.addType(typeTexture3D);
    // produce default Texture2DArray type
    const templateTexture2DArray = scope.findTypeTemplate(_Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__["default"].TYPE_NAME);
    const typeTexture2DArray = templateTexture2DArray.produceType(scope, []);
    scope.addType(typeTexture2DArray);
    // produce default TextureCubeArray type
    const templateTextureCubeArray = scope.findTypeTemplate(_TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__["default"].TYPE_NAME);
    const typeTextureCubeArray = templateTextureCubeArray.produceType(scope, []);
    scope.addType(typeTextureCubeArray);
    // produce default RWTexture1D type
    const templateRWTexture1D = scope.findTypeTemplate(_RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_NAME);
    const typeRWTexture1D = templateRWTexture1D.produceType(scope, []);
    scope.addType(typeRWTexture1D);
    // produce default RWTexture2D type
    const templateRWTexture2D = scope.findTypeTemplate(_RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__["default"].TYPE_NAME);
    const typeRWTexture2D = templateRWTexture2D.produceType(scope, []);
    scope.addType(typeRWTexture2D);
}


/***/ }),

/***/ "L0DD":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/matrix.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeMatrix": () => (/* binding */ addSystemTypeMatrix)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeMatrix(scope) {
    let float2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float2");
    let float3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float3");
    let float4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float4");
    let int2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int2");
    let int3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int3");
    let int4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int4");
    let uint2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint2");
    let uint3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint3");
    let uint4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint4");
    let bool2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool2");
    let bool3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool3");
    let bool4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool4");
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x2", -1, float2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x3", -1, float3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x4", -1, float4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x2", -1, float2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x3", -1, float3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x4", -1, float4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x2", -1, float2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x3", -1, float3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x4", -1, float4, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x2", -1, int2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x3", -1, int3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x4", -1, int4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x2", -1, int2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x3", -1, int3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x4", -1, int4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x2", -1, int2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x3", -1, int3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x4", -1, int4, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x2", -1, bool2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x3", -1, bool3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x4", -1, bool4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x2", -1, bool2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x3", -1, bool3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x4", -1, bool4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x2", -1, bool2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x3", -1, bool3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x4", -1, bool4, 4);
}


/***/ }),

/***/ "gzl7":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/scalar.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeScalar": () => (/* binding */ addSystemTypeScalar)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeScalar(scope) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "void", 0);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "string", 4 /* pointer to string */);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "null_t", 4 /* pointer */);
    // TODO: use dedicated type for half
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, "float", "half");
    console.assert(_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE === false);
}


/***/ }),

/***/ "BeyE":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/system/utils.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TYPES": () => (/* binding */ BASE_TYPES),
/* harmony export */   "BLEND_STATE": () => (/* binding */ BLEND_STATE),
/* harmony export */   "BOOL_BASED_TYPES": () => (/* binding */ BOOL_BASED_TYPES),
/* harmony export */   "BUFFER_TYPES": () => (/* binding */ BUFFER_TYPES),
/* harmony export */   "DEPTH_STENCIL_STATE": () => (/* binding */ DEPTH_STENCIL_STATE),
/* harmony export */   "FLOAT_BASED_TYPES": () => (/* binding */ FLOAT_BASED_TYPES),
/* harmony export */   "FLOAT_TYPES": () => (/* binding */ FLOAT_TYPES),
/* harmony export */   "HALF_BASED_TYPES": () => (/* binding */ HALF_BASED_TYPES),
/* harmony export */   "INT_BASED_TYPES": () => (/* binding */ INT_BASED_TYPES),
/* harmony export */   "INT_TYPES": () => (/* binding */ INT_TYPES),
/* harmony export */   "MATRIX_TYPES": () => (/* binding */ MATRIX_TYPES),
/* harmony export */   "RASTERIZER_STATE": () => (/* binding */ RASTERIZER_STATE),
/* harmony export */   "SAMPLER_TYPES": () => (/* binding */ SAMPLER_TYPES),
/* harmony export */   "SCALAR_TYPES": () => (/* binding */ SCALAR_TYPES),
/* harmony export */   "SHADER_TYPES": () => (/* binding */ SHADER_TYPES),
/* harmony export */   "TEMPLATE_TYPE": () => (/* binding */ TEMPLATE_TYPE),
/* harmony export */   "TEXTURE_TYPES": () => (/* binding */ TEXTURE_TYPES),
/* harmony export */   "UAV_TYPES": () => (/* binding */ UAV_TYPES),
/* harmony export */   "UINT_BASED_TYPES": () => (/* binding */ UINT_BASED_TYPES),
/* harmony export */   "USAGE_CONTROL_FLOW": () => (/* binding */ USAGE_CONTROL_FLOW),
/* harmony export */   "USAGE_CS": () => (/* binding */ USAGE_CS),
/* harmony export */   "USAGE_DS": () => (/* binding */ USAGE_DS),
/* harmony export */   "USAGE_GS": () => (/* binding */ USAGE_GS),
/* harmony export */   "USAGE_HS": () => (/* binding */ USAGE_HS),
/* harmony export */   "USAGE_PS": () => (/* binding */ USAGE_PS),
/* harmony export */   "USAGE_VS": () => (/* binding */ USAGE_VS),
/* harmony export */   "USE_STRICT_HALF_TYPE": () => (/* binding */ USE_STRICT_HALF_TYPE),
/* harmony export */   "VECTOR_TYPES": () => (/* binding */ VECTOR_TYPES),
/* harmony export */   "addFieldsToVectorFromSuffixObject": () => (/* binding */ addFieldsToVectorFromSuffixObject),
/* harmony export */   "debugPrint": () => (/* binding */ debugPrint),
/* harmony export */   "defineTypeAlias": () => (/* binding */ defineTypeAlias),
/* harmony export */   "generateSuffixLiterals": () => (/* binding */ generateSuffixLiterals),
/* harmony export */   "generateSystemFunction": () => (/* binding */ generateSystemFunction),
/* harmony export */   "generateSystemType": () => (/* binding */ generateSystemType),
/* harmony export */   "getSystemType": () => (/* binding */ getSystemType),
/* harmony export */   "isBase": () => (/* binding */ isBase),
/* harmony export */   "isBlendState": () => (/* binding */ isBlendState),
/* harmony export */   "isBoolBasedType": () => (/* binding */ isBoolBasedType),
/* harmony export */   "isBuffer": () => (/* binding */ isBuffer),
/* harmony export */   "isDepthStencilState": () => (/* binding */ isDepthStencilState),
/* harmony export */   "isFloatBasedType": () => (/* binding */ isFloatBasedType),
/* harmony export */   "isFloatType": () => (/* binding */ isFloatType),
/* harmony export */   "isHalfBasedType": () => (/* binding */ isHalfBasedType),
/* harmony export */   "isIntBasedType": () => (/* binding */ isIntBasedType),
/* harmony export */   "isIntegerType": () => (/* binding */ isIntegerType),
/* harmony export */   "isMatrixType": () => (/* binding */ isMatrixType),
/* harmony export */   "isPipelineState": () => (/* binding */ isPipelineState),
/* harmony export */   "isRasterizerState": () => (/* binding */ isRasterizerState),
/* harmony export */   "isSamplerState": () => (/* binding */ isSamplerState),
/* harmony export */   "isScalarType": () => (/* binding */ isScalarType),
/* harmony export */   "isShaderType": () => (/* binding */ isShaderType),
/* harmony export */   "isTemplate": () => (/* binding */ isTemplate),
/* harmony export */   "isTexture": () => (/* binding */ isTexture),
/* harmony export */   "isUAV": () => (/* binding */ isUAV),
/* harmony export */   "isUintBasedType": () => (/* binding */ isUintBasedType),
/* harmony export */   "isVectorType": () => (/* binding */ isVectorType),
/* harmony export */   "parseType": () => (/* binding */ parseType),
/* harmony export */   "parseUintLiteral": () => (/* binding */ parseUintLiteral),
/* harmony export */   "resolveRegister": () => (/* binding */ resolveRegister)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "GU3W");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../instructions/AttributeInstruction */ "rs/O");
/* harmony import */ var _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../instructions/SystemFunctionInstruction */ "F8nM");












const USE_STRICT_HALF_TYPE = false;
const TEMPLATE_TYPE = "template";
function parseUintLiteral(value) {
    const match = value.match(/^((0x[a-fA-F0-9]{1,8}?|[0-9]+)(e([+-]?[0-9]+))?)([ulUL]*)$/);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match, `cannot parse uint literal: ${value}`);
    const signed = match[5].toLowerCase().indexOf('u') === -1;
    const exp = Number(match[4] || '0');
    const base = Number(match[2]);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!Number.isNaN(base));
    const heximal = value[1] === 'x';
    return { signed, exp, base, heximal };
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function getSystemType(scope, typeName) {
    //boolean, string, float and others
    let type = scope.findType(typeName);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!type || (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_SystemType));
    return type;
}
function generateSystemType(scope, ...args) {
    let name;
    let size;
    let elementType;
    let length;
    let fields;
    let methods;
    [name, size, elementType, length, fields, methods] = args;
    if (getSystemType(scope, name)) {
        console.error(`type already exists: ${name}`);
        return null;
    }
    const type = new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    scope.addType(type);
    return type;
}
function defineTypeAlias(scope, typeName, aliasName) {
    scope.addTypeAlias(typeName, aliasName);
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function addFieldsToVectorFromSuffixObject(scope, fields, suffixMap, baseType) {
    for (let suffix in suffixMap) {
        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : "");
        const fieldBaseType = getSystemType(scope, fieldTypeName);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(fieldBaseType);
        const fieldId = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: suffix });
        const fieldType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] });
        fields.push(new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));
    }
}
function generateSuffixLiterals(literals, output = {}, depth = 0) {
    if (depth >= /*literals.length*/ 4) {
        return output;
    }
    if (depth === 0) {
        for (let i = 0; i < literals.length; i++) {
            output[literals[i]] = true;
        }
        depth = 1;
    }
    const outputKeys = Object.keys(output);
    for (let i = 0; i < literals.length; i++) {
        for (let j = 0; j < outputKeys.length; j++) {
            if (outputKeys[j].indexOf(literals[i]) !== -1) {
                output[outputKeys[j] + literals[i]] = false;
            }
            else {
                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;
            }
        }
    }
    depth++;
    return generateSuffixLiterals(literals, output, depth);
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function isTemplate(typename) {
    return typename.split(' ').slice(-1)[0] === TEMPLATE_TYPE;
}
function parseType(scope, typename, typevalue = null) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(typevalue !== TEMPLATE_TYPE);
    const usagesType = (typevalue ? typename.replace(TEMPLATE_TYPE, typevalue) : typename).split(' ');
    const hash = usagesType.slice(-1)[0];
    const type = getSystemType(scope, hash);
    const usages = usagesType.slice(0, -1);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type !== null);
    usages.forEach(usage => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(['in', 'out', 'inout'].indexOf(usage) !== -1));
    return { type, usages, hash };
}
const systemFunctionHashMap = {};
function _emitException(message) {
    throw new Error(message);
}
// todo: rewrite it!
function _error(code, info = {}) {
    _emitException(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors[code]);
}
const USAGE_VS = 0x01;
const USAGE_PS = 0x02;
const USAGE_GS = 0x04;
const USAGE_CS = 0x08;
const USAGE_HS = 0x10;
const USAGE_DS = 0x20;
const USAGE_CONTROL_FLOW = 0x100;
function generateSystemFunctionInstance(scope, retType, name, paramTypes, usage) {
    const paramList = paramTypes.map((typeDesc, n) => {
        return new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({
            type: new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({
                type: typeDesc.type,
                usages: typeDesc.usages,
                scope
            }),
            id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ name: `p${n}`, scope }),
            scope
        });
    });
    const returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({
        type: retType.type,
        usages: retType.usages,
        scope
    });
    const pixel = !!(usage & USAGE_PS);
    const vertex = !!(usage & USAGE_VS);
    const extern = !!(usage & USAGE_CONTROL_FLOW);
    const attrs = [];
    if (extern) {
        attrs.push(new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_9__.AttributeInstruction({ scope, name: 'extern' }));
    }
    const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name });
    const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_10__.FunctionDefInstruction({ scope, returnType, id, paramList });
    const func = new _instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_11__.SystemFunctionInstruction({ scope, def, pixel, vertex, attrs });
    scope.addFunction(func);
}
/**
 * Exampler:
 *  generateSystemFunction("dot", "dot($1,$2)",   "float",    [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
 *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                         name   translationExpr returnType  argsTypes                       templateTypes
 */
function generateSystemFunction(scope, name, returnTypeName, paramTypeNames, templateTypes, usage = USAGE_VS | USAGE_PS) {
    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(templateTypes)) {
        for (let i = 0; i < templateTypes.length; i++) {
            let funcHash = name + "(";
            let returnType = parseType(scope, returnTypeName, templateTypes[i]);
            let paramTypes = [];
            for (let j = 0; j < paramTypeNames.length; j++) {
                const typeDesc = parseType(scope, paramTypeNames[j], templateTypes[i]);
                paramTypes.push(typeDesc);
                funcHash += typeDesc.hash + ",";
            }
            funcHash += ")";
            if (systemFunctionHashMap[funcHash]) {
                _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });
            }
            generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);
            systemFunctionHashMap[funcHash] = true;
        }
    }
    else {
        if (isTemplate(returnTypeName)) {
            _emitException("Bad return type(TEMPLATE_TYPE) for system function '" + name + "'.");
        }
        let funcHash = name + "(";
        let returnType = parseType(scope, returnTypeName);
        let paramTypes = [];
        for (let i = 0; i < paramTypeNames.length; i++) {
            if (isTemplate(paramTypeNames[i])) {
                _emitException("Bad argument type(TEMPLATE_TYPE) for system function '" + name + "'.");
            }
            else {
                const typeDesc = parseType(scope, paramTypeNames[i]);
                paramTypes.push(typeDesc);
                funcHash += typeDesc.hash + ",";
            }
        }
        funcHash += ")";
        if (systemFunctionHashMap[funcHash]) {
            _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });
        }
        generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);
        systemFunctionHashMap[funcHash] = true;
    }
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
const SCALAR_TYPES = [
    'bool',
    'int',
    'uint',
    'half',
    'float'
];
const INT_TYPES = [
    'int', 'uint'
];
const FLOAT_TYPES = [
    'float'
];
const INT_BASED_TYPES = [
    'int',
    'int2', 'int3', 'int4',
    'int2x2', 'int2x3', 'int2x4',
    'int3x2', 'int3x3', 'int3x4',
    'int4x2', 'int4x3', 'int4x4',
];
const UINT_BASED_TYPES = [
    'uint',
    'uint2', 'uint3', 'uint4',
    'uint2x2', 'uint2x3', 'uint2x4',
    'uint3x2', 'uint3x3', 'uint3x4',
    'uint4x2', 'uint4x3', 'uint4x4',
];
const HALF_BASED_TYPES = [
    'half',
    'half2', 'half3', 'half4',
    'half2x2', 'half2x3', 'half2x4',
    'half3x2', 'half3x3', 'half3x4',
    'half4x2', 'half4x3', 'half4x4',
];
const FLOAT_BASED_TYPES = [
    'float',
    'float2', 'float3', 'float4',
    'float2x2', 'float2x3', 'float2x4',
    'float3x2', 'float3x3', 'float3x4',
    'float4x2', 'float4x3', 'float4x4',
];
const BOOL_BASED_TYPES = [
    'bool',
    'bool2', 'bool3', 'bool4',
    'bool2x2', 'bool2x3', 'bool2x4',
    'bool3x2', 'bool3x3', 'bool3x4',
    'bool4x2', 'bool4x3', 'bool4x4',
];
const VECTOR_TYPES = [
    'bool2', 'bool3', 'bool4',
    'int2', 'int3', 'int4',
    'uint2', 'uint3', 'uint4',
    'half2', 'half3', 'half4',
    'float2', 'float3', 'float4'
];
const MATRIX_TYPES = [
    'bool2x2', 'bool2x3', 'bool2x4', 'bool3x2', 'bool3x3', 'bool3x4', 'bool4x2', 'bool4x3', 'bool4x4',
    'int2x2', 'int2x3', 'int2x4', 'int3x2', 'int3x3', 'int3x4', 'int4x2', 'int4x3', 'int4x4',
    'uint2x2', 'uint2x3', 'uint2x4', 'uint3x2', 'uint3x3', 'uint3x4', 'uint4x2', 'uint4x3', 'uint4x4',
    'half2x2', 'half2x3', 'half2x4', 'half3x2', 'half3x3', 'half3x4', 'half4x2', 'half4x3', 'half4x4',
    'float2x2', 'float2x3', 'float2x4', 'float3x2', 'float3x3', 'float3x4', 'float4x2', 'float4x3', 'float4x4',
];
const BASE_TYPES = [
    ...SCALAR_TYPES, ...VECTOR_TYPES, ...MATRIX_TYPES
];
const UAV_TYPES = [
    'RWTexture1D',
    'RWTexture2D',
    'RWTexture3D',
    'RWBuffer',
    'RWStructuredBuffer',
    'AppendStructuredBuffer'
];
const TEXTURE_TYPES = [
    'Texture1D',
    'Texture2D',
    'Texture3D',
    'TextureCube',
    'Texture2DArray',
    'TextureCubeArray',
    'RWTexture1D',
    'RWTexture2D',
    'RWTexture3D',
];
const BUFFER_TYPES = [
    'Buffer',
    'RWBuffer',
    'RWStructuredBuffer',
    'AppendStructuredBuffer',
    'StructuredBuffer'
];
const SAMPLER_TYPES = [
    'SamplerState',
    'SamplerComparisonState'
];
const BLEND_STATE = 'BlendState';
const DEPTH_STENCIL_STATE = 'DepthStencilState';
const RASTERIZER_STATE = 'RasterizerState';
const SHADER_TYPES = [
    'VertexShader',
    'PixelShader',
    'GeometryShader',
    'HullShader',
    'DomainShader',
    'ComputeShader'
];
const skipTemplate = (name) => name.match(/([\w][\w\d]+)(<[\w][\w\d]+>)?/)[1];
// note: arrays like "Texture2D[5]" also return true in this checks (!)
const isUAV = (type) => UAV_TYPES.includes(skipTemplate(type.name));
const isTexture = (type) => TEXTURE_TYPES.includes(skipTemplate(type.name));
const isBuffer = (type) => BUFFER_TYPES.includes(skipTemplate(type.name));
// note: arrays like "BlendState[5]" also return true in this checks (!)
const isSamplerState = (type) => SAMPLER_TYPES.includes(type.name);
const isBlendState = (type) => [BLEND_STATE].includes(type.name);
const isDepthStencilState = (type) => [DEPTH_STENCIL_STATE].includes(type.name);
const isRasterizerState = (type) => [RASTERIZER_STATE].includes(type.name);
// note: arrays like "BlendState[5]" also return true in this checks (!)
const isPipelineState = (type) => [
    BLEND_STATE,
    DEPTH_STENCIL_STATE,
    RASTERIZER_STATE
].includes(type.name);
const isShaderType = (type) => SHADER_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
// note: arrays like "float4[4]" return false in this checks (!)
const isBase = (type) => BASE_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isVectorType = (type) => VECTOR_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isMatrixType = (type) => MATRIX_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isScalarType = (type) => SCALAR_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isIntegerType = (type) => INT_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isFloatType = (type) => FLOAT_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isIntBasedType = (type) => INT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isUintBasedType = (type) => UINT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isBoolBasedType = (type) => BOOL_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isHalfBasedType = (type) => HALF_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isFloatBasedType = (type) => FLOAT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function resolveRegister(decl) {
    let type = null;
    let index = -1;
    const semantic = decl.semantic;
    if (semantic) {
        const match = semantic.match(/^register\(([utbs]{1})([\d]+)\)$/);
        if (match) {
            type = match[1];
            index = Number(match[2]);
        }
    }
    if (isUAV(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 'u');
        type = 'u';
    }
    if (isTexture(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 't');
        type = 't';
    }
    if (isSamplerState(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 's');
        type = 's';
    }
    if (decl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_CbufferDecl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 'b');
        type = 'b';
    }
    // TODO: buffers
    return { type, index };
}
///////////////////////////////////////////////////////
function alignL(content, len) {
    let diff = Math.max(0, len - content.length);
    return `${Array(diff).fill(' ').join('')}${content}`;
}
function alignR(content, len) {
    let diff = Math.max(0, len - content.length);
    return `${content}${Array(diff).fill(' ').join('')}`;
}
class Emitter extends _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__.CodeEmitter {
    emitFunctionDefinition(ctx, def, attrs) {
        const { typeName } = this.resolveType(ctx, def.returnType);
        // this.emitKeyword(alignL(typeName, 10));
        // this.emitKeyword(alignR(def.name, 16));
        attrs?.forEach(attr => this.emitLine(`[${attr.name}]`));
        this.emitKeyword(typeName);
        this.emitKeyword(def.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitParams(ctx, def.params);
        this.emitChar(')');
    }
}
function debugPrint(scope) {
    const ctx = new _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__.CodeContext;
    const emitter = new Emitter({ omitEmptyParams: true });
    const { functions, types, typeTemplates } = scope;
    emitter.begin();
    for (let name in types) {
        const type = types[name];
        emitter.emitLine(`// ${type.name};`);
    }
    emitter.end();
    emitter.begin();
    for (let name in typeTemplates) {
        const tpl = typeTemplates[name];
        emitter.emitLine(`// ${tpl.name};`);
    }
    emitter.end();
    emitter.begin();
    for (let name in functions) {
        const overloads = functions[name];
        for (const fn of overloads) {
            emitter.emitFunctionDefinition(ctx, fn.def, fn.attrs);
            emitter.emitChar(';');
            emitter.emitNewline();
        }
        emitter.emitNewline();
    }
    emitter.end();
    return emitter.toString();
}


/***/ }),

/***/ "9oB0":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/vector.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeVector": () => (/* binding */ addSystemTypeVector)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeVector(scope) {
    const XYSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xy");
    const XYZSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xyz");
    const XYZWSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xyzw");
    const RGSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rg");
    const RGBSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rgb");
    const RGBASuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rgba");
    const STSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("st");
    const STPSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("stp");
    const STPQSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("stpq");
    let float = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float");
    let half = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "half");
    let int = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int");
    let uint = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint");
    let bool = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool");
    let float2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2", -1, float, 2);
    let float3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3", -1, float, 3);
    let float4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4", -1, float, 4);
    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE) {
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float2', 'half2');
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float3', 'half3');
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float4', 'half4');
    }
    let int2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2", -1, int, 2);
    let int3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3", -1, int, 3);
    let int4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4", -1, int, 4);
    let uint2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint2", -1, uint, 2);
    let uint3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint3", -1, uint, 3);
    let uint4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint4", -1, uint, 4);
    let bool2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2", -1, bool, 2);
    let bool3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3", -1, bool, 3);
    let bool4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4", -1, bool, 4);
    {
        let suf2f = [];
        // program.push(EScopeType.k_Struct);
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, XYSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, RGSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, STSuffix, "float");
        // program.pop();
        suf2f.forEach(field => float2.addField(field));
    }
    {
        let suf3f = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, XYZSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, RGBSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, STPSuffix, "float");
        suf3f.forEach(field => float3.addField(field));
    }
    {
        let suf4f = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, XYZWSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, RGBASuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, STPQSuffix, "float");
        suf4f.forEach(field => float4.addField(field));
    }
    if (_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE) {
        let half2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half2", -1, half, 2);
        let half3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half3", -1, half, 3);
        let half4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half4", -1, half, 4);
        {
            let suf2f = [];
            // program.push(EScopeType.k_Struct);
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, XYSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, RGSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, STSuffix, "half");
            // program.pop();
            suf2f.forEach(field => half2.addField(field));
        }
        {
            let suf3f = [];
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, XYZSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, RGBSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, STPSuffix, "half");
            suf3f.forEach(field => half3.addField(field));
        }
        {
            let suf4f = [];
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, XYZWSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, RGBASuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, STPQSuffix, "half");
            suf4f.forEach(field => half4.addField(field));
        }
    }
    {
        let suf2i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, XYSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, RGSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, STSuffix, "int");
        suf2i.forEach(field => int2.addField(field));
    }
    {
        let suf3i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, XYZSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, RGBSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, STPSuffix, "int");
        suf3i.forEach(field => int3.addField(field));
    }
    {
        let suf4i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, XYZWSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, RGBASuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, STPQSuffix, "int");
        suf4i.forEach(field => int4.addField(field));
    }
    {
        let suf2ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, XYSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, RGSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, STSuffix, "uint");
        suf2ui.forEach(field => uint2.addField(field));
    }
    {
        let suf3ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, XYZSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, RGBSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, STPSuffix, "uint");
        suf3ui.forEach(field => uint3.addField(field));
    }
    {
        let suf4ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, XYZWSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, RGBASuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, STPQSuffix, "uint");
        suf4ui.forEach(field => uint4.addField(field));
    }
    {
        let suf2b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, XYSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, RGSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, STSuffix, "bool");
        suf2b.forEach(field => bool2.addField(field));
    }
    {
        let suf3b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, XYZSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, RGBSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, STPSuffix, "bool");
        suf3b.forEach(field => bool3.addField(field));
    }
    {
        let suf4b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, XYZWSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, RGBASuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, STPQSuffix, "bool");
        suf4b.forEach(field => bool4.addField(field));
    }
}


/***/ }),

/***/ "EekG":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/BaseEmitter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseEmitter": () => (/* binding */ BaseEmitter)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _Output__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Output */ "/pDr");


class BaseEmitter {
    constructor() {
        this.blocks = [];
        this.stack = [];
    }
    top() { return this.stack[this.depth() - 1]; }
    findOrCreateOutput(name) {
        const i = this.blocks.findIndex(block => name && block.name === name);
        const block = i !== -1
            ? this.blocks.splice(i, 1)[0]
            : (0,_Output__WEBPACK_IMPORTED_MODULE_1__.createOutput)({ name });
        return block;
    }
    depth() {
        return this.stack.length;
    }
    begin(block) {
        this.stack.push(this.findOrCreateOutput(block));
    }
    /**
     * @param prologue Move block to the beginning.
     */
    end(prologue = false) {
        const block = this.stack.pop();
        if (block.isEmpty()) {
            return;
        }
        if (!prologue) {
            this.blocks.push(block);
        }
        else {
            this.blocks = [block, ...this.blocks];
        }
    }
    push(pad) {
        this.top().push(pad);
    }
    pop() {
        this.top().pop();
    }
    emitNewline(n = 1) { Array(n).fill(0).forEach(i => this.top()?.newline()); }
    emitKeyword(kw) { this.top()?.keyword(kw); }
    emitNoSpace() { this.top()?.ignoreNextSpace(); }
    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }
    emitChar(char) { this.top()?.add(char); }
    emitLine(line) {
        this.emitChar(line);
        this.emitNewline();
    }
    clear() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.stack.length == 0);
        this.blocks = [];
    }
    toString() {
        const res = this.blocks
            .map(block => block.toString())
            .filter(code => !!code)
            .join('\n\n');
        this.clear();
        return res;
    }
    valueOf() {
        return this.toString();
    }
}


/***/ }),

/***/ "GU3W":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/CodeEmitter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CodeContext": () => (/* binding */ CodeContext),
/* harmony export */   "CodeEmitter": () => (/* binding */ CodeEmitter),
/* harmony export */   "EUsages": () => (/* binding */ EUsages)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers_fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers/fn */ "zoki");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _BaseEmitter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseEmitter */ "EekG");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");










var EUsages;
(function (EUsages) {
    EUsages[EUsages["k_Vertex"] = 1] = "k_Vertex";
    EUsages[EUsages["k_Pixel"] = 2] = "k_Pixel";
    EUsages[EUsages["k_Compute"] = 4] = "k_Compute";
})(EUsages || (EUsages = {}));
;
;
function pushUniq(arr, elem) {
    if (arr.indexOf(elem) == -1)
        arr.push(elem);
}
class CodeContext {
    constructor(opts = {}) {
        // known globals like: functions, types, uniforms etc.
        this.knownSignatures = new Set();
        this.uavs = [];
        this.textures = [];
        this.buffers = [];
        this.cbuffers = [];
        this.CSShaders = [];
        this.opts = opts;
        this.opts.mode ||= 'raw';
        console.assert(['vs', 'ps', 'ds', 'hs', 'gs', 'cs', 'raw'].includes(this.opts.mode));
    }
    get entryName() { return this.opts.entryName; }
    get mode() { return this.opts.mode; }
    isPixel() { return this.mode === 'ps'; }
    isVertex() { return this.mode === 'vs'; }
    isRaw() { return this.mode === 'raw'; }
    has(signature) {
        return this.knownSignatures.has(signature);
    }
    add(signature) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(signature));
        this.knownSignatures.add(signature);
    }
    // note: cbuffers without predefined register are not supported yet (!)
    addCbuffer(cbuf) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(cbuf.name));
        this.add(cbuf.name);
        const { name, type: { size } } = cbuf;
        const register = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.resolveRegister(cbuf).index;
        const buf = { name, size, register };
        this.cbuffers.push(buf);
        return buf;
    }
    addTexture(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.buffers.length + this.textures.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp) || [`${type}<float4>`, `${type}`, `float4`];
        const texture = {
            name,
            type,
            texType: match[1],
            elementType: match[2],
            register
        };
        this.textures.push(texture);
        return texture;
    }
    addUav(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.uavs.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match);
        const uav = {
            name,
            type,
            uavType: match[1],
            elementType: match[2],
            register
        };
        this.uavs.push(uav);
        return uav;
    }
    addBuffer(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.buffers.length + this.textures.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match);
        const buf = {
            name,
            type,
            bufType: match[1],
            elementType: match[2],
            register
        };
        this.buffers.push(buf);
        return buf;
    }
    beginCsShader(name, numthreads) {
        const uavs = [];
        const buffers = [];
        const textures = [];
        this.CSShader = { name, numthreads, uavs, buffers, textures };
    }
    endCsShader() {
        const sh = this.CSShader;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(sh);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(sh.name));
        this.add(sh.name);
        this.CSShaders.push(sh);
        this.CSShader = null;
    }
    linkBuffer(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.buffers, this.buffers.find(b => b.name == name));
        }
    }
    linkCbuffer(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            // pushUniq(sh.cbuffers, this.cbuffers.find(b => b.name == name));
        }
    }
    linkUav(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.uavs, this.uavs.find(u => u.name == name));
        }
    }
    linkTexture(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.textures, this.textures.find(t => t.name == name));
        }
    }
}
class CodeEmitter extends _BaseEmitter__WEBPACK_IMPORTED_MODULE_8__.BaseEmitter {
    constructor(options = {}) {
        super();
        this.options = options;
    }
    isMain() {
        return this.depth() === 1;
    }
    resolveTypeName(type) {
        return type.name;
    }
    resolveType(ctx, type) {
        if (!type) {
            return null;
        }
        let complex = type.isComplex();
        let length;
        let typeName;
        let usages;
        let usage;
        if (!complex) {
            typeName = this.resolveTypeName(type);
        }
        else {
            typeName = type.name;
            // find original type instead of VariableType wrapper. 
            const originalType = type.scope.findType(type.name);
            this.emit(ctx, originalType);
        }
        if (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType) {
            const vtype = type;
            usages = vtype.usages;
        }
        if (type.isNotBaseArray()) {
            length = type.length;
        }
        if (usages && usages.length) {
            usage = usages.filter(u => !this.options.omitInUsage || u != 'in').join(' ');
        }
        return { typeName, length, usage };
    }
    emitBuffer(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const buf = ctx.addBuffer(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(t${buf.register});`);
            }
            this.end();
        }
        ctx.linkBuffer(name);
    }
    emitUav(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const uav = ctx.addUav(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(u${uav.register});`);
            }
            this.end();
        }
        ctx.linkUav(name);
    }
    emitTexture(ctx, decl) {
        const { name, type } = decl;
        this.emitTextureRaw(ctx, type.name, name);
    }
    emitTextureRaw(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const tex = ctx.addTexture(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(t${tex.register});`);
            }
            this.end();
        }
        ctx.linkTexture(name);
    }
    emitLine(line, comment) {
        this.emitChar(line);
        comment && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(comment.split('\n').length === 1);
        comment && (this.emitChar('\t'), this.emitComment(comment));
        this.emitNewline();
    }
    emitComment(comment) {
        //
        if (comment.indexOf('\n') === -1) {
            this.emitLine(`// ${comment}`);
            return;
        }
        /**
         *
         */
        this.emitLine('/**');
        this.push(' * ');
        comment.split('\n').forEach(line => this.emitLine(line));
        this.pop();
        this.emitLine(' */');
    }
    emitComplexType(ctx, type) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type.isComplex());
        this.emitKeyword('struct');
        this.emitKeyword(type.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        type.fields.map(field => (this.emitComplexField(ctx, field), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitComplexTypeDecl(ctx, ctype) {
        if (ctx.has(ctype.name)) {
            return;
        }
        ctx.add(ctype.name);
        this.begin();
        this.emitComplexType(ctx, ctype);
        this.emitChar(';');
        this.end();
    }
    // todo: remove hack with rename mutator
    emitVariableNoInit(ctx, decl, rename) {
        const { typeName, length, usage } = this.resolveType(ctx, decl.type);
        const name = rename ? rename(decl) : decl.name;
        usage && this.emitKeyword(usage);
        this.emitKeyword(typeName);
        this.emitKeyword(name);
        length && this.emitChar(`[${length}]`);
        decl.semantic && this.emitSemantic(ctx, decl.semantic);
        decl.annotation && this.emitAnnotation(ctx, decl.annotation);
    }
    // todo: remove hack with rename mutator
    emitVariable(ctx, src, rename) {
        this.emitVariableNoInit(ctx, src, rename);
        if (src.initExpr) {
            // blocks are valid for blend/raster/depth state initialization.
            const isBlock = src.initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StateBlockExpr;
            if (!isBlock) {
                this.emitKeyword('=');
                this.emitSpace();
            }
            this.emitExpression(ctx, src.initExpr);
        }
    }
    emitIfStmt(ctx, stmt) {
        this.emitKeyword('if');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, stmt.cond);
        this.emitChar(')');
        this.emitNewline();
        if (stmt.conseq) {
            this.emitStmt(ctx, stmt.conseq);
        }
        else {
            this.emitChar(';');
        }
        if (stmt.contrary) {
            this.emitNewline();
            this.emitKeyword('else');
            this.emitStmt(ctx, stmt.contrary);
        }
    }
    emitSemantic(ctx, semantic) {
        this.emitChar(':');
        this.emitKeyword(semantic);
    }
    emitAnnotation(ctx, anno) {
        // TODO: add annotation emission.
    }
    /** @deprecated */
    emitCompile(ctx, compile) {
        this.emitFunction(ctx, compile.function);
        this.emitKeyword('compile');
        this.emitKeyword(compile.function.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, compile.args);
        this.emitChar(')');
    }
    evaluateEntryName(ctx, fn) {
        const fnName = fn.name;
        const entryName = ctx.entryName;
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__.isString)(entryName))
            return fnName;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(fn.scope.functions[entryName]))
            // todo: emit correct error
            console.error('entry point already exists');
        return entryName;
    }
    emitEntryParams(ctx, params) {
        // emit constants instead of uniforms arguments if provided
        const constants = ctx.opts.constants;
        if (constants) {
            params.filter(p => p.type.isUniform()).forEach((param, i) => {
                const c = constants[i];
                const name = param.name;
                if (ctx.has(name)) {
                    // global variable with the same name as argument already exists
                    console.assert(false, '?!');
                    return;
                }
                ctx.add(name);
                this.begin();
                this.emitLine(`static const ${c.type} ${name} = ${String(c.value)};`);
                this.end();
            });
        }
        // skip uniform arguments if constant substitution were passed
        params
            .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && (!p.type.isUniform() || !constants))
            .forEach((param, i, list) => {
            this.emitParam(ctx, param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    // todo: add compute entry support
    emitEntryFunction(ctx, fn) {
        const { def } = fn;
        const { typeName } = this.resolveType(ctx, def.returnType);
        this.begin();
        {
            // in case of hlsl materials it's typical to swap arbitrary name for bundle name
            // to simplify further compilation
            let fnName = this.evaluateEntryName(ctx, fn);
            this.emitKeyword(typeName);
            this.emitKeyword(fnName);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitEntryParams(ctx, def.params);
            this.emitChar(')');
            // todo: validate complex type sematics
            // all the output parameters of entry function must have valid semantics
            if (!def.returnType.isComplex()) {
                if (ctx.isPixel()) {
                    this.emitChar(':');
                    this.emitKeyword(fn.semantic || 'SV_Target0');
                }
            }
            this.emitNewline();
            this.emitBlock(ctx, fn.impl);
        }
        this.end();
    }
    emitAttributes(ctx, attrs) {
        attrs?.forEach(attr => {
            this.emitChar(`[`);
            this.emitNoSpace();
            this.emitKeyword(attr.name);
            this.emitNoSpace();
            if (attr.args) {
                this.emitChar('(');
                this.emitNoSpace();
                this.emitExpressionList(ctx, attr.args);
                this.emitChar(')');
                this.emitNoSpace();
            }
            this.emitChar(`]`);
            this.emitNewline();
        });
    }
    emitRegularFunction(ctx, fn) {
        if (!fn) {
            return;
        }
        const { def } = fn;
        const { typeName } = this.resolveType(ctx, def.returnType);
        this.begin();
        {
            this.emitAttributes(ctx, fn.attrs);
            this.emitKeyword(typeName);
            this.emitKeyword(fn.name);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitParams(ctx, def.params);
            this.emitChar(')');
            this.emitNewline();
            if (fn.impl)
                this.emitBlock(ctx, fn.impl);
            else
                this.emitChar(';');
        }
        this.end();
    }
    emitFunction(ctx, decl) {
        if (!decl) {
            return;
        }
        const sign = _lib_fx_analisys_helpers_fn__WEBPACK_IMPORTED_MODULE_3__.fn.signature(decl.def);
        if (ctx.has(sign)) {
            return;
        }
        ctx.add(sign);
        const isEntry = (this.depth() == 0) && !ctx.isRaw();
        if (isEntry)
            this.emitEntryFunction(ctx, decl);
        else
            this.emitRegularFunction(ctx, decl);
    }
    emitCollector(ctx, collector) {
        this.begin();
        for (let instr of collector.instructions) {
            this.emit(ctx, instr);
        }
        this.end();
    }
    emitTypeDecl(ctx, decl) {
        this.resolveType(ctx, decl.type);
    }
    emitTypedef(ctx, def) {
        // nothing todo because current implementation implies
        // immediate target type substitution 
        return;
        /*
            this.emitKeyword('typedef');
            // todo: add support for typedefs like:
            //  typedef const float4 T;
            //          ^^^^^^^^^^^^
            this.emitKeyword(def.type.name);
            this.emitKeyword(def.alias);
            this.emitChar(';');
            this.emitNewline();
        */
    }
    emitForInit(ctx, init) {
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(init)) {
            this.emitExpression(ctx, init);
        }
        else {
            this.emitVariable(ctx, init);
        }
    }
    emitForStmt(ctx, stmt) {
        //for(int i = 0;i < 4;++ i)
        //{
        //  ...
        //}
        this.emitKeyword('for');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitForInit(ctx, stmt.init);
        this.emitChar(';');
        this.emitExpression(ctx, stmt.cond);
        this.emitChar(';');
        this.emitExpression(ctx, stmt.step);
        this.emitChar(')');
        if (stmt.body.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StmtBlock)
            this.emitNewline();
        this.emitStmt(ctx, stmt.body);
    }
    emitExpression(ctx, expr) {
        if (!expr) {
            return;
        }
        /*
        | ICastExprInstruction
        | ILogicalExprInstruction
        | IPostfixIndexInstruction
        | ISamplerStateBlockInstruction
        */
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ArithmeticExpr:
                return this.emitArithmetic(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_AssignmentExpr:
                return this.emitAssigment(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixPointExpr:
                return this.emitPostfixPoint(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IdExpr:
                return this.emitIdentifier(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionCallExpr:
                return this.emitFCall(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ConstructorCallExpr:
                return this.emitCCall(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FloatExpr:
                return this.emitFloat(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IntExpr:
                return this.emitInteger(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BoolExpr:
                return this.emitBool(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StringExpr:
                return this.emitString(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexExpr:
                return this.emitComplexExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CompileExpr:
                return this.emitCompile(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ConditionalExpr:
                return this.emitConditionalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_RelationalExpr:
                return this.emitRelationalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_LogicalExpr:
                return this.emitLogicalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_UnaryExpr:
                return this.emitUnaryExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixArithmeticExpr:
                return this.emitPostfixArithmetic(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_InitExpr:
                return this.emitInitExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CastExpr:
                return this.emitCast(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BitwiseExpr:
                return this.emitBitwise(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixIndexExpr:
                return this.emitPostfixIndex(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StateBlockExpr:
                return this.emitStateBlockExpr(ctx, expr);
            default:
                this.emitLine(`/* ... unsupported expression '${expr.instructionName}' ... */`);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported instruction found: ${expr.instructionName}`);
        }
    }
    emitFloat(ctx, lit) {
        const sval = String(lit.value);
        this.emitKeyword(sval);
        (sval.indexOf('.') === -1) && this.emitChar('.');
        this.emitChar('f');
    }
    emitBool(ctx, lit) {
        this.emitKeyword(lit.value ? 'true' : 'false');
    }
    emitString(ctx, lit) {
        this.emitKeyword(lit.value);
    }
    emitComplexExpr(ctx, complex) {
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, complex.expr);
        this.emitChar(')');
    }
    emitConditionalExpr(ctx, cond) {
        this.emitExpression(ctx, cond.condition);
        this.emitKeyword('?');
        this.emitExpression(ctx, cond.left);
        this.emitKeyword(':');
        this.emitExpression(ctx, cond.right);
    }
    emitInteger(ctx, lit) {
        const int = lit;
        this.emitKeyword(`${int.heximal ? '0x' + int.value.toString(16).toUpperCase() : int.value.toFixed(0)}${!int.signed ? 'u' : ''}`);
    }
    emitRelationalExpr(ctx, rel) {
        this.emitExpression(ctx, rel.left);
        this.emitKeyword(rel.operator);
        this.emitExpression(ctx, rel.right);
    }
    emitLogicalExpr(ctx, rel) {
        this.emitExpression(ctx, rel.left);
        this.emitKeyword(rel.operator);
        this.emitExpression(ctx, rel.right);
    }
    emitUnaryExpr(ctx, unary) {
        this.emitChar(unary.operator);
        this.emitExpression(ctx, unary.expr);
    }
    emitPostfixArithmetic(ctx, par) {
        this.emitExpression(ctx, par.expr);
        this.emitChar(par.operator);
    }
    emitPostfixIndex(ctx, pfidx) {
        this.emitExpression(ctx, pfidx.element);
        this.emitChar('[');
        this.emitNoSpace();
        this.emitExpression(ctx, pfidx.index);
        this.emitChar(']');
    }
    emitStateBlockExpr(ctx, stblk) {
        if (ctx.mode !== 'raw') {
            // no need to emit state blocks in plain hlsl shaders
            return;
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)('not implemented');
    }
    emitBreakStmt(ctx, brk) {
        this.emitLine(`${brk.operator};`);
    }
    emitExpressionList(ctx, list) {
        list?.forEach((expr, i) => {
            this.emitExpression(ctx, expr);
            (i != list.length - 1) && this.emitChar(',');
        });
    }
    emitParam(ctx, param) {
        this.emitVariable(ctx, param);
    }
    emitParams(ctx, params) {
        params.filter(p => !this.options.omitEmptyParams || p.type.size !== 0).forEach((param, i, list) => {
            this.emitParam(ctx, param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    emitInitExpr(ctx, init) {
        if (init.args.length > 1) {
            this.emitChar('{');
            this.emitNoSpace();
            this.emitExpressionList(ctx, init.args);
            this.emitChar('}');
            return;
        }
        this.emitExpression(ctx, init.args[0]);
    }
    emitCast(ctx, cast) {
        if (cast.isUseless()) {
            return;
        }
        this.emitChar('(');
        this.emitNoSpace();
        const { typeName } = this.resolveType(ctx, cast.type);
        this.emitKeyword(typeName);
        this.emitChar(')');
        this.emitNoSpace();
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, cast.expr);
        this.emitChar(')');
    }
    emitBitwise(ctx, bwise) {
        this.emitExpression(ctx, bwise.left);
        this.emitKeyword(bwise.operator);
        this.emitSpace();
        this.emitExpression(ctx, bwise.right);
    }
    emitArithmetic(ctx, arthm) {
        this.emitExpression(ctx, arthm.left);
        this.emitKeyword(arthm.operator);
        this.emitSpace();
        this.emitExpression(ctx, arthm.right);
    }
    emitAssigment(ctx, asgm) {
        this.emitExpression(ctx, asgm.left);
        this.emitKeyword(asgm.operator);
        this.emitSpace();
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(asgm.right));
        this.emitExpression(ctx, asgm.right);
    }
    emitPostfixPoint(ctx, pfxp) {
        // todo: skip brackets wherever possible to avoid exprs like (a).x;
        if (pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IdExpr ||
            pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixPointExpr) {
            this.emitExpression(ctx, pfxp.element);
        }
        else {
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, pfxp.element);
            this.emitChar(')');
        }
        this.emitChar('.');
        this.emitChar(pfxp.postfix.name);
    }
    emitCbufferField(ctx, field) {
        this.emitVariable(ctx, field);
        this.emitChar(';');
        this.emitChar('\t');
        this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);
    }
    emitCbuffer(ctx, cbuf) {
        if (!ctx.has(cbuf.name)) {
            ctx.addCbuffer(cbuf);
            this.begin();
            this.emitComment(`size: ${cbuf.type.size}`);
            this.emitKeyword('cbuffer');
            if (cbuf.id) {
                this.emitKeyword(cbuf.name);
            }
            const reg = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.resolveRegister(cbuf);
            if (reg.index !== -1) {
                this.emitChar(':');
                this.emitKeyword('register');
                this.emitChar('(');
                this.emitNoSpace();
                this.emitKeyword(`${reg.type}${reg.index}`);
                this.emitNoSpace();
                this.emitChar(')');
            }
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                cbuf.type.fields.forEach(field => {
                    this.emitCbufferField(ctx, field);
                });
            }
            this.pop();
            this.emitChar('}');
            this.emitChar(';');
            // emit annotation?
            this.end();
        }
        ctx.linkCbuffer(cbuf.name);
    }
    // request global declaration for local identifier
    emitGlobal(ctx, decl) {
        const { name, type } = decl;
        const isUniformArg = this.isMain() && decl.isParameter() && type.isUniform();
        if (decl.isGlobal() /* || isUniformArg*/) {
            if (decl.usageFlags & _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Cbuffer) {
                const cbufType = decl.parent;
                const cbuf = cbufType.parent;
                this.begin();
                this.emitCbuffer(ctx, cbuf);
                this.end();
            }
            else if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.isTexture(type)) {
                this.begin();
                this.emitTexture(ctx, decl);
                this.end();
            }
            else {
                this.begin();
                this.emitGlobalVariable(ctx, decl);
                this.end();
            }
        }
    }
    emitIdentifier(ctx, id) {
        const { decl, name } = id;
        this.emitGlobal(ctx, decl);
        this.emitKeyword(name);
    }
    emitCCall(ctx, call) {
        const args = call.args;
        const { typeName } = this.resolveType(ctx, call.ctor);
        this.emitKeyword(typeName);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, args);
        this.emitChar(')');
    }
    // todo: remove hack with rename mutator
    emitFCall(ctx, call, rename = decl => decl.name) {
        const { decl, args, callee } = call;
        if (decl.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemFunctionDecl) {
            this.emitFunction(ctx, decl);
        }
        if (callee) {
            this.emitExpression(ctx, callee);
            this.emitChar('.');
            this.emitNoSpace();
        }
        this.emitKeyword(rename(decl));
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, args);
        this.emitChar(')');
    }
    emitReturnStmt(ctx, stmt) {
        this.emitKeyword('return');
        this.emitSpace();
        this.emitExpression(ctx, stmt.expr);
        this.emitChar(';');
    }
    emitExpressionStmt(ctx, stmt) {
        this.emitExpression(ctx, stmt.expr);
        this.emitChar(';');
    }
    emitLocalVariable(ctx, stmt) {
        this.emitVariable(ctx, stmt);
        this.emitChar(';');
    }
    emitGlobalVariable(ctx, decl) {
        if (ctx.has(decl.name)) {
            return;
        }
        ctx.add(decl.name);
        this.begin();
        this.emitVariable(ctx, decl);
        this.emitChar(';');
        this.end();
    }
    emitComplexField(ctx, instr) {
        console.assert(instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl);
        this.emitVariable(ctx, instr);
        this.emitChar(';');
    }
    emitDeclStmt(ctx, stmt) {
        stmt.declList.forEach(decl => {
            console.assert(decl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl);
            this.emitLocalVariable(ctx, decl);
        });
    }
    /*
        | IStmtBlockInstruction
        | IWhileStmtInstruction
        | IForStmtInstruction;
    */
    emitStmt(ctx, stmt) {
        switch (stmt.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_DeclStmt:
                this.emitDeclStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ExprStmt:
                this.emitExpressionStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ReturnStmt:
                this.emitReturnStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SemicolonStmt:
                this.emitChar(';');
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IfStmt:
                this.emitIfStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StmtBlock:
                this.emitBlock(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ForStmt:
                this.emitForStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BreakStmt:
                this.emitBreakStmt(ctx, stmt);
                break;
            default:
                this.emitLine(`/* ... unsupported stmt '${stmt.instructionName}' .... */`);
                console.warn(`unknown stmt found: '${stmt.instructionName}'`);
        }
    }
    emitBlock(ctx, blk) {
        // if (!blk.stmtList.length)
        // {
        //     this.emitChar(';');
        //     return;
        // }
        this.emitChar('{');
        this.push();
        blk.stmtList.forEach(stmt => (this.emitStmt(ctx, stmt), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitPass(ctx, pass) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        this.emitPassBody(ctx, pass);
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitPassBody(ctx, pass) {
        // TODO: replace with emitCompile();
        if (pass.vertexShader) {
            this.emitFunction(ctx, pass.vertexShader);
            this.emitKeyword('VertexShader');
            this.emitKeyword('=');
            this.emitKeyword('compile');
            this.emitKeyword(pass.vertexShader.name);
            this.emitChar('()');
            this.emitChar(';');
            this.emitNewline();
        }
        if (pass.pixelShader) {
            this.emitFunction(ctx, pass.pixelShader);
            this.emitKeyword('PixelShader');
            this.emitKeyword('=');
            this.emitKeyword('compile');
            this.emitKeyword(pass.pixelShader.name);
            this.emitChar('()');
            this.emitChar(';');
            this.emitNewline();
        }
        if (pass.renderStates) {
            for (let key in pass.renderStates) {
                const state = pass.renderStates[key];
                if (state != _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__.ERenderStateValues.UNDEF) {
                    this.emitKeyword(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_5__.ERenderStates[Number(key)]);
                    this.emitChar('=');
                    this.emitKeyword(_lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__.ERenderStateValues[state]);
                    this.emitChar(';');
                    this.emitNewline();
                }
            }
        }
        this.emitNewline();
        // mwalk(pass.renderStates, (val, key) => {
        //     console.log(ERenderStates[key], ERenderStateValues[val]);
        // });
    }
    emit(ctx, instr) {
        if (!instr) {
            // TODO: emit error.
            this.emitLine('/* ... empty instruction .... */');
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(instr)) {
            this.emitExpression(ctx, instr);
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isStatement(instr)) {
            this.emitStmt(ctx, instr);
            return this;
        }
        //
        // Other types
        //
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionDecl:
                this.emitFunction(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CbufferDecl:
                this.emitCbuffer(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl:
                this.emitGlobalVariable(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_Collector:
                this.emitCollector(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_TypeDecl:
                this.emitTypeDecl(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_TypedefDecl:
                this.emitTypedef(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexType:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType:
                // todo: addComplexType ?
                this.emitComplexTypeDecl(ctx, instr);
                break;
            default:
                this.emitLine(`/* ... unsupported instruction '${instr.instructionName}' .... */`);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported instruction found: ${instr.instructionName}`);
        }
        return this;
    }
    static translate(instr, ctx = new CodeContext) {
        return CodeEmitter.cEmitter.emit(ctx, instr).toString();
    }
    static translateDocument(document, ctx = new CodeContext) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return '';
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document.root)) {
            return '';
        }
        return CodeEmitter.translate(document.root, ctx);
    }
}
CodeEmitter.cEmitter = new CodeEmitter({ omitEmptyParams: true });
// export function emit(instr: IInstruction): string {
//     return CodeEmitter.translate(instr);
// }


/***/ }),

/***/ "/pDr":
/*!******************************************!*\
  !*** ./src/lib/fx/translators/Output.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createOutput": () => (/* binding */ createOutput)
/* harmony export */ });
function createOutput({ tab = '\t', nl = '\n', name = null } = {}) {
    let data = [''];
    let nesting = [];
    let count = 0;
    let noNextSpace = false;
    const push = (pad = tab) => (nesting.push(pad), count && newline());
    const pop = () => (nesting.pop(), count && newline());
    const toString = () => data.join(nl);
    const ignoreNextSpace = () => noNextSpace = true;
    function add(val) {
        if (!count) {
            for (let i = 0; i < nesting.length; ++i)
                val = nesting[i] + val;
        }
        data[data.length - 1] += val;
        count++;
        noNextSpace = false;
    }
    function keyword(token) {
        !noNextSpace && count && add(' ');
        add(token);
    }
    function newline() {
        data.push('');
        count = 0;
    }
    function isEmpty() {
        return data.length == 1 &&
            data[0].length == 0;
    }
    return {
        isEmpty,
        keyword,
        ignoreNextSpace,
        push,
        pop,
        newline,
        add,
        toString,
        name
    };
}


/***/ }),

/***/ "jeW/":
/*!****************************************!*\
  !*** ./src/lib/idl/EAnalyzerErrors.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EAnalyzerErrors": () => (/* binding */ EAnalyzerErrors)
/* harmony export */ });
var EAnalyzerErrors;
(function (EAnalyzerErrors) {
    EAnalyzerErrors[EAnalyzerErrors["SystemTypeRedefinition"] = 2202] = "SystemTypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["TypeRedefinition"] = 2203] = "TypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["VariableRedefinition"] = 2204] = "VariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemVariableRedefinition"] = 2205] = "SystemVariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedifinition"] = 2206] = "FunctionRedifinition";
    EAnalyzerErrors[EAnalyzerErrors["CbufferRedefinition"] = 2207] = "CbufferRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemFunctionRedefinition"] = 2208] = "SystemFunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedTypeDecl"] = 2209] = "UnsupportedTypeDecl";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedExpr"] = 2210] = "UnsupportedExpr";
    EAnalyzerErrors[EAnalyzerErrors["UnknownVarName"] = 2211] = "UnknownVarName";
    EAnalyzerErrors[EAnalyzerErrors["UnknownInstruction"] = 2212] = "UnknownInstruction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticOperation"] = 2213] = "InvalidArithmeticOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticAssigmentOperation"] = 2214] = "InvalidArithmeticAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidAssigmentOperation"] = 2215] = "InvalidAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidBitwiseOperation"] = 2216] = "InvalidBitwiseOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLeftHandSideInAssignment"] = 2217] = "InvalidLeftHandSideInAssignment";
    EAnalyzerErrors[EAnalyzerErrors["InvalidRelationalOperation"] = 2218] = "InvalidRelationalOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLogicOperation"] = 2219] = "InvalidLogicOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditionType"] = 2220] = "InvalidConditionType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditonValueTypes"] = 2221] = "InvalidConditonValueTypes";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeUsage"] = 2222] = "InvalidCastTypeUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeNotBase"] = 2223] = "InvalidCastTypeNotBase";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastUnknownType"] = 2224] = "InvalidCastUnknownType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidUnaryOperation"] = 2225] = "InvalidUnaryOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotArray"] = 2226] = "InvalidPostfixNotArray";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotIntIndex"] = 2227] = "InvalidPostfixNotIntIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotField"] = 2228] = "InvalidPostfixNotField";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixArithmetic"] = 2229] = "InvalidPostfixArithmetic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotFunction"] = 2230] = "InvalidComplexNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotType"] = 2231] = "InvalidComplexNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotConstructor"] = 2232] = "InvalidComplexNotConstructor";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileNotFunction"] = 2233] = "InvalidCompileNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileFunctionNotValid"] = 2234] = "InvalidCompileFunctionNotValid";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedefinition"] = 2235] = "FunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidWhileCondition"] = 2236] = "InvalidWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidDoWhileCondition"] = 2237] = "InvalidDoWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidIfCondition"] = 2238] = "InvalidIfCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitExpr"] = 2239] = "InvalidForInitExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitEmptyIterator"] = 2240] = "InvalidForInitEmptyIterator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionEmpty"] = 2241] = "InvalidForConditionEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionRelation"] = 2242] = "InvalidForConditionRelation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepEmpty"] = 2243] = "InvalidForStepEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepOperator"] = 2244] = "InvalidForStepOperator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepExpr"] = 2245] = "InvalidForStepExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructName"] = 2246] = "InvalidNewFieldForStructName";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructSematic"] = 2247] = "InvalidNewFieldForStructSematic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewAnnotationVar"] = 2248] = "InvalidNewAnnotationVar";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterDefenitionDefaultNeeded"] = 2249] = "InvalidFunctionParameterDefenitionDefaultNeeded";
    EAnalyzerErrors[EAnalyzerErrors["CannotChooseFunction"] = 2250] = "CannotChooseFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFuncDefenitionReturnType"] = 2251] = "InvalidFuncDefenitionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSystemFunctionReturnType"] = 2252] = "InvalidSystemFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameNotType"] = 2253] = "InvalidTypeNameNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameTemplateNotFound"] = 2254] = "InvalidTypeNameTemplateNotFound";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeScope"] = 2255] = "InvalidTypeScope";
    EAnalyzerErrors[EAnalyzerErrors["CannotProduceType"] = 2256] = "CannotProduceType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeVectorMatrix"] = 2257] = "InvalidTypeVectorMatrix";
    EAnalyzerErrors[EAnalyzerErrors["TechniqueNameRedefinition"] = 2258] = "TechniqueNameRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionRecursionNotAllowed"] = 2259] = "InvalidFunctionRecursionNotAllowed";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionImplementationNotFound"] = 2260] = "InvalidFunctionImplementationNotFound";
    // InvalidFunctionUsageVertex,
    // InvalidFunctionUsagePixel,
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithVertexShader"] = 2261] = "FunctionIsNotCompatibleWithVertexShader";
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithPixelShader"] = 2262] = "FunctionIsNotCompatibleWithPixelShader";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtVoid"] = 2263] = "InvalidReturnStmtVoid";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtEmpty"] = 2264] = "InvalidReturnStmtEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtTypesNotEqual"] = 2265] = "InvalidReturnStmtTypesNotEqual";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnType"] = 2266] = "InvalidFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterUsage"] = 2267] = "InvalidFunctionParameterUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForWriting"] = 2268] = "InvalidTypeForWriting";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForReading"] = 2269] = "InvalidTypeForReading";
    EAnalyzerErrors[EAnalyzerErrors["InvalidExprIsNotLValue"] = 2270] = "InvalidExprIsNotLValue";
    EAnalyzerErrors[EAnalyzerErrors["InvalidVariableInitializing"] = 2271] = "InvalidVariableInitializing";
    EAnalyzerErrors[EAnalyzerErrors["InvalidVariableInitializingEx"] = 2272] = "InvalidVariableInitializingEx";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedStateIndex"] = 2273] = "UnsupportedStateIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSamplerTexture"] = 2274] = "InvalidSamplerTexture";
    EAnalyzerErrors[EAnalyzerErrors["CannotCalcPadding"] = 2275] = "CannotCalcPadding";
    EAnalyzerErrors[EAnalyzerErrors["ImportedComponentNotExists"] = 2276] = "ImportedComponentNotExists";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnStmtNotFound"] = 2277] = "InvalidFunctionReturnStmtNotFound";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedProvideAs"] = 2278] = "UnsupportedProvideAs";
    EAnalyzerErrors[EAnalyzerErrors["UnreachableCode"] = 2279] = "UnreachableCode";
    EAnalyzerErrors[EAnalyzerErrors["OperatorCannotBeUsedWithGivenLValue"] = 2280] = "OperatorCannotBeUsedWithGivenLValue";
    //
    //
    //
    EAnalyzerErrors[EAnalyzerErrors["PartFx_VertexShaderParametersMismatch"] = 2281] = "PartFx_VertexShaderParametersMismatch";
    EAnalyzerErrors[EAnalyzerErrors["PartFx_InvalidSpawnStmtInitializerNotFound"] = 2282] = "PartFx_InvalidSpawnStmtInitializerNotFound";
    // PartFx_RenderPassWasNotFound, // << moved to warnings
    EAnalyzerErrors[EAnalyzerErrors["PartFx_DrawOpOnlyAllowedWithinUpdateRoutine"] = 2283] = "PartFx_DrawOpOnlyAllowedWithinUpdateRoutine";
})(EAnalyzerErrors || (EAnalyzerErrors = {}));
;


/***/ }),

/***/ "AW2x":
/*!******************************************!*\
  !*** ./src/lib/idl/EAnalyzerWarnings.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EAnalyzerWarnings": () => (/* binding */ EAnalyzerWarnings)
/* harmony export */ });
var EAnalyzerWarnings;
(function (EAnalyzerWarnings) {
    EAnalyzerWarnings[EAnalyzerWarnings["UnsupportedRenderStateTypeUsed"] = 3000] = "UnsupportedRenderStateTypeUsed";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompleteTechnique"] = 3001] = "IncompleteTechnique";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompletePass"] = 3002] = "IncompletePass";
    EAnalyzerWarnings[EAnalyzerWarnings["UselessPassState"] = 3003] = "UselessPassState";
    EAnalyzerWarnings[EAnalyzerWarnings["EmptySemicolon"] = 3004] = "EmptySemicolon";
    EAnalyzerWarnings[EAnalyzerWarnings["InvalidCbufferRegister"] = 3005] = "InvalidCbufferRegister";
    EAnalyzerWarnings[EAnalyzerWarnings["ImplicitTypeConversion"] = 3006] = "ImplicitTypeConversion";
    EAnalyzerWarnings[EAnalyzerWarnings["ImplicitTypeTruncation"] = 3007] = "ImplicitTypeTruncation";
    EAnalyzerWarnings[EAnalyzerWarnings["Deprecated"] = 3008] = "Deprecated";
    // part fx
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_SortingCannotBeApplied"] = 3009] = "PartFx_SortingCannotBeApplied";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_PresetPropertyHasNotBeenFound"] = 3010] = "PartFx_PresetPropertyHasNotBeenFound";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_RenderPassWasNotFound"] = 3011] = "PartFx_RenderPassWasNotFound";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_EmitterPersistentDataMustBeMarkedAsInout"] = 3012] = "PartFx_EmitterPersistentDataMustBeMarkedAsInout";
    EAnalyzerWarnings[EAnalyzerWarnings["ExternCall"] = 3013] = "ExternCall";
})(EAnalyzerWarnings || (EAnalyzerWarnings = {}));


/***/ }),

/***/ "HS1/":
/*!*******************************************!*\
  !*** ./src/lib/idl/ERenderStateValues.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERenderStateValues": () => (/* binding */ ERenderStateValues)
/* harmony export */ });
/** @deprecated */
var ERenderStateValues;
(function (ERenderStateValues) {
    ERenderStateValues[ERenderStateValues["UNDEF"] = 0] = "UNDEF";
    ERenderStateValues[ERenderStateValues["TRUE"] = 1] = "TRUE";
    ERenderStateValues[ERenderStateValues["FALSE"] = 2] = "FALSE";
    ERenderStateValues[ERenderStateValues["ZERO"] = 3] = "ZERO";
    ERenderStateValues[ERenderStateValues["ONE"] = 4] = "ONE";
    ERenderStateValues[ERenderStateValues["SRCCOLOR"] = 5] = "SRCCOLOR";
    ERenderStateValues[ERenderStateValues["INVSRCCOLOR"] = 6] = "INVSRCCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHA"] = 7] = "SRCALPHA";
    ERenderStateValues[ERenderStateValues["INVSRCALPHA"] = 8] = "INVSRCALPHA";
    ERenderStateValues[ERenderStateValues["DESTALPHA"] = 9] = "DESTALPHA";
    ERenderStateValues[ERenderStateValues["INVDESTALPHA"] = 10] = "INVDESTALPHA";
    ERenderStateValues[ERenderStateValues["DESTCOLOR"] = 11] = "DESTCOLOR";
    ERenderStateValues[ERenderStateValues["INVDESTCOLOR"] = 12] = "INVDESTCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHASAT"] = 13] = "SRCALPHASAT";
    ERenderStateValues[ERenderStateValues["NONE"] = 14] = "NONE";
    ERenderStateValues[ERenderStateValues["CW"] = 15] = "CW";
    ERenderStateValues[ERenderStateValues["CCW"] = 16] = "CCW";
    ERenderStateValues[ERenderStateValues["FRONT"] = 17] = "FRONT";
    ERenderStateValues[ERenderStateValues["BACK"] = 18] = "BACK";
    ERenderStateValues[ERenderStateValues["FRONT_AND_BACK"] = 19] = "FRONT_AND_BACK";
    ERenderStateValues[ERenderStateValues["NEVER"] = 20] = "NEVER";
    ERenderStateValues[ERenderStateValues["LESS"] = 21] = "LESS";
    ERenderStateValues[ERenderStateValues["EQUAL"] = 22] = "EQUAL";
    ERenderStateValues[ERenderStateValues["LESSEQUAL"] = 23] = "LESSEQUAL";
    ERenderStateValues[ERenderStateValues["GREATER"] = 24] = "GREATER";
    ERenderStateValues[ERenderStateValues["NOTEQUAL"] = 25] = "NOTEQUAL";
    ERenderStateValues[ERenderStateValues["GREATEREQUAL"] = 26] = "GREATEREQUAL";
    ERenderStateValues[ERenderStateValues["ALWAYS"] = 27] = "ALWAYS";
    ERenderStateValues[ERenderStateValues["FUNCADD"] = 28] = "FUNCADD";
    ERenderStateValues[ERenderStateValues["FUNCSUBTRACT"] = 29] = "FUNCSUBTRACT";
    ERenderStateValues[ERenderStateValues["FUNCREVERSESUBTRACT"] = 30] = "FUNCREVERSESUBTRACT";
    // HACK: temp hack
    ERenderStateValues[ERenderStateValues["LINELIST"] = 31] = "LINELIST";
    ERenderStateValues[ERenderStateValues["LINESTRIP"] = 32] = "LINESTRIP";
    ERenderStateValues[ERenderStateValues["TRIANGLELIST"] = 33] = "TRIANGLELIST";
    ERenderStateValues[ERenderStateValues["TRAINGLESTRIP"] = 34] = "TRAINGLESTRIP";
    ERenderStateValues[ERenderStateValues["POINTLIST"] = 35] = "POINTLIST";
})(ERenderStateValues || (ERenderStateValues = {}));
/*
//
//
//

export enum BLEND {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    INV_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    INV_SRC_ALPHA = 6,
    DEST_ALPHA = 7,
    INV_DEST_ALPHA = 8,
    DEST_COLOR = 9,
    INV_DEST_COLOR = 10,
    SRC_ALPHA_SAT = 11,
    BLEND_FACTOR = 14,
    INV_BLEND_FACTOR = 15,
    SRC1_COLOR = 16,
    INV_SRC1_COLOR = 17,
    SRC1_ALPHA = 18,
    INV_SRC1_ALPHA = 19
};


export enum BLEND_OP {
    ADD = 1,
    SUBTRACT = 2,
    REV_SUBTRACT = 3,
    MIN = 4,
    MAX = 5
};


export class RENDER_TARGET_BLEND_DESC {
    BlendEnable: boolean;
    SrcBlend: BLEND;
    DestBlend: BLEND;
    BlendOp: BLEND_OP;
    SrcBlendAlpha: BLEND;
    DestBlendAlpha: BLEND;
    BlendOpAlpha: BLEND_OP;
    RenderTargetWriteMask: number;
};


//
//
//

export enum DEPTH_WRITE_MASK {
    ZERO = 0,
    ALL = 1
};


export enum COMPARISON_FUNC {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8
};


export enum STENCIL_OP {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_SAT = 4,
    DECR_SAT = 5,
    INVERT = 6,
    INCR = 7,
    DECR = 8
};


export class DEPTH_STENCILOP_DESC {
    StencilFailOp: STENCIL_OP;
    StencilDepthFailOp: STENCIL_OP;
    StencilPassOp: STENCIL_OP;
    StencilFunc: COMPARISON_FUNC;
};

//
//
//

export enum PRIMITIVE_TOPOLOGY {
    UNDEFINED = 0,
    POINTLIST = 1,
    LINELIST = 2,
    LINESTRIP = 3,
    TRIANGLELIST = 4,
    TRIANGLESTRIP = 5,
    LINELIST_ADJ = 10,
    LINESTRIP_ADJ = 11,
    TRIANGLELIST_ADJ = 12,
    TRIANGLESTRIP_ADJ = 13
};

//
//
//

enum CULL_MODE {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
    // ?
    FRONT_AND_BACK = 4
};


enum FILL_MODE {
    WIREFRAME = 2,
    SOLID = 3
};


class RASTERIZER_DESC {
    FillMode: FILL_MODE;
    CullMode: CULL_MODE;
    FrontCounterClockwise: boolean;
    DepthBias: number;
    DepthBiasClamp: number;
    SlopeScaledDepthBias: number;
    DepthClipEnable: boolean;
    ScissorEnable: boolean;
    MultisampleEnable: boolean;
    AntialiasedLineEnable: boolean;
}
*/


/***/ }),

/***/ "Y4FD":
/*!**************************************!*\
  !*** ./src/lib/idl/ERenderStates.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERenderStates": () => (/* binding */ ERenderStates)
/* harmony export */ });
/** @deprecated */
var ERenderStates;
(function (ERenderStates) {
    ERenderStates[ERenderStates["BLENDENABLE"] = 0] = "BLENDENABLE";
    ERenderStates[ERenderStates["CULLFACEENABLE"] = 1] = "CULLFACEENABLE";
    ERenderStates[ERenderStates["ZENABLE"] = 2] = "ZENABLE";
    ERenderStates[ERenderStates["ZWRITEENABLE"] = 3] = "ZWRITEENABLE";
    ERenderStates[ERenderStates["DITHERENABLE"] = 4] = "DITHERENABLE";
    ERenderStates[ERenderStates["SCISSORTESTENABLE"] = 5] = "SCISSORTESTENABLE";
    ERenderStates[ERenderStates["STENCILTESTENABLE"] = 6] = "STENCILTESTENABLE";
    ERenderStates[ERenderStates["POLYGONOFFSETFILLENABLE"] = 7] = "POLYGONOFFSETFILLENABLE";
    ERenderStates[ERenderStates["CULLFACE"] = 8] = "CULLFACE";
    ERenderStates[ERenderStates["FRONTFACE"] = 9] = "FRONTFACE";
    ERenderStates[ERenderStates["SRCBLENDCOLOR"] = 10] = "SRCBLENDCOLOR";
    ERenderStates[ERenderStates["DESTBLENDCOLOR"] = 11] = "DESTBLENDCOLOR";
    ERenderStates[ERenderStates["SRCBLENDALPHA"] = 12] = "SRCBLENDALPHA";
    ERenderStates[ERenderStates["DESTBLENDALPHA"] = 13] = "DESTBLENDALPHA";
    ERenderStates[ERenderStates["BLENDEQUATIONCOLOR"] = 14] = "BLENDEQUATIONCOLOR";
    ERenderStates[ERenderStates["BLENDEQUATIONALPHA"] = 15] = "BLENDEQUATIONALPHA";
    ERenderStates[ERenderStates["ZFUNC"] = 16] = "ZFUNC";
    ERenderStates[ERenderStates["ALPHABLENDENABLE"] = 17] = "ALPHABLENDENABLE";
    ERenderStates[ERenderStates["ALPHATESTENABLE"] = 18] = "ALPHATESTENABLE";
    ERenderStates[ERenderStates["SRCBLEND"] = 19] = "SRCBLEND";
    ERenderStates[ERenderStates["DESTBLEND"] = 20] = "DESTBLEND";
    ERenderStates[ERenderStates["BLENDFUNC"] = 21] = "BLENDFUNC";
    ERenderStates[ERenderStates["BLENDFUNCSEPARATE"] = 22] = "BLENDFUNCSEPARATE";
    ERenderStates[ERenderStates["BLENDEQUATION"] = 23] = "BLENDEQUATION";
    ERenderStates[ERenderStates["BLENDEQUATIONSEPARATE"] = 24] = "BLENDEQUATIONSEPARATE";
    // HACK:
    ERenderStates[ERenderStates["PRIMITIVETOPOLOGY"] = 25] = "PRIMITIVETOPOLOGY";
})(ERenderStates || (ERenderStates = {}));


/***/ }),

/***/ "DIkA":
/*!*************************************!*\
  !*** ./src/lib/idl/IDiagnostics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EDiagnosticCategory": () => (/* binding */ EDiagnosticCategory)
/* harmony export */ });
var EDiagnosticCategory;
(function (EDiagnosticCategory) {
    EDiagnosticCategory[EDiagnosticCategory["k_Warning"] = 0] = "k_Warning";
    EDiagnosticCategory[EDiagnosticCategory["k_Error"] = 1] = "k_Error";
})(EDiagnosticCategory || (EDiagnosticCategory = {}));


/***/ }),

/***/ "vIQR":
/*!*************************************!*\
  !*** ./src/lib/idl/IInstruction.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ECheckStage": () => (/* binding */ ECheckStage),
/* harmony export */   "EExtractExprType": () => (/* binding */ EExtractExprType),
/* harmony export */   "EInstructionTypes": () => (/* binding */ EInstructionTypes),
/* harmony export */   "EScopeType": () => (/* binding */ EScopeType),
/* harmony export */   "ETechniqueType": () => (/* binding */ ETechniqueType),
/* harmony export */   "EVarUsedMode": () => (/* binding */ EVarUsedMode)
/* harmony export */ });
var EInstructionTypes;
(function (EInstructionTypes) {
    EInstructionTypes[EInstructionTypes["k_Instruction"] = 0] = "k_Instruction";
    EInstructionTypes[EInstructionTypes["k_Id"] = 1] = "k_Id";
    EInstructionTypes[EInstructionTypes["k_Provide"] = 2] = "k_Provide";
    EInstructionTypes[EInstructionTypes["k_Collector"] = 3] = "k_Collector";
    EInstructionTypes[EInstructionTypes["k_Keyword"] = 4] = "k_Keyword";
    EInstructionTypes[EInstructionTypes["k_Simple"] = 5] = "k_Simple";
    EInstructionTypes[EInstructionTypes["k_SamplerState"] = 6] = "k_SamplerState";
    EInstructionTypes[EInstructionTypes["k_Attribute"] = 7] = "k_Attribute";
    EInstructionTypes[EInstructionTypes["k_Annotation"] = 8] = "k_Annotation";
    EInstructionTypes[EInstructionTypes["k_UsageType"] = 9] = "k_UsageType";
    EInstructionTypes[EInstructionTypes["k_Typed"] = 10] = "k_Typed";
    EInstructionTypes[EInstructionTypes["k_VariableType"] = 11] = "k_VariableType";
    EInstructionTypes[EInstructionTypes["k_SystemType"] = 12] = "k_SystemType";
    EInstructionTypes[EInstructionTypes["k_ComplexType"] = 13] = "k_ComplexType";
    EInstructionTypes[EInstructionTypes["k_ProxyType"] = 14] = "k_ProxyType";
    EInstructionTypes[EInstructionTypes["k_Expr"] = 15] = "k_Expr";
    EInstructionTypes[EInstructionTypes["k_IdExpr"] = 16] = "k_IdExpr";
    EInstructionTypes[EInstructionTypes["k_IntExpr"] = 17] = "k_IntExpr";
    EInstructionTypes[EInstructionTypes["k_FloatExpr"] = 18] = "k_FloatExpr";
    EInstructionTypes[EInstructionTypes["k_BoolExpr"] = 19] = "k_BoolExpr";
    EInstructionTypes[EInstructionTypes["k_StringExpr"] = 20] = "k_StringExpr";
    EInstructionTypes[EInstructionTypes["k_NullExpr"] = 21] = "k_NullExpr";
    EInstructionTypes[EInstructionTypes["k_ArithmeticExpr"] = 22] = "k_ArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_AssignmentExpr"] = 23] = "k_AssignmentExpr";
    EInstructionTypes[EInstructionTypes["k_BitwiseExpr"] = 24] = "k_BitwiseExpr";
    EInstructionTypes[EInstructionTypes["k_RelationalExpr"] = 25] = "k_RelationalExpr";
    EInstructionTypes[EInstructionTypes["k_LogicalExpr"] = 26] = "k_LogicalExpr";
    EInstructionTypes[EInstructionTypes["k_ConditionalExpr"] = 27] = "k_ConditionalExpr";
    EInstructionTypes[EInstructionTypes["k_CastExpr"] = 28] = "k_CastExpr";
    EInstructionTypes[EInstructionTypes["k_UnaryExpr"] = 29] = "k_UnaryExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixIndexExpr"] = 30] = "k_PostfixIndexExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixPointExpr"] = 31] = "k_PostfixPointExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixArithmeticExpr"] = 32] = "k_PostfixArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_ComplexExpr"] = 33] = "k_ComplexExpr";
    EInstructionTypes[EInstructionTypes["k_FunctionCallExpr"] = 34] = "k_FunctionCallExpr";
    EInstructionTypes[EInstructionTypes["k_ConstructorCallExpr"] = 35] = "k_ConstructorCallExpr";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_CompileExpr"] = 36] = "k_CompileExpr";
    EInstructionTypes[EInstructionTypes["k_CompileShader11Expr"] = 37] = "k_CompileShader11Expr";
    EInstructionTypes[EInstructionTypes["k_InitExpr"] = 38] = "k_InitExpr";
    EInstructionTypes[EInstructionTypes["k_StateBlockExpr"] = 39] = "k_StateBlockExpr";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_SamplerStateBlockExpr"] = 40] = "k_SamplerStateBlockExpr";
    EInstructionTypes[EInstructionTypes["k_Decl"] = 41] = "k_Decl";
    EInstructionTypes[EInstructionTypes["k_TypeDecl"] = 42] = "k_TypeDecl";
    EInstructionTypes[EInstructionTypes["k_TypedefDecl"] = 43] = "k_TypedefDecl";
    EInstructionTypes[EInstructionTypes["k_VariableDecl"] = 44] = "k_VariableDecl";
    EInstructionTypes[EInstructionTypes["k_StructDecl"] = 45] = "k_StructDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDecl"] = 46] = "k_FunctionDecl";
    EInstructionTypes[EInstructionTypes["k_SystemFunctionDecl"] = 47] = "k_SystemFunctionDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDef"] = 48] = "k_FunctionDef";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_PassDecl"] = 49] = "k_PassDecl";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_TechniqueDecl"] = 50] = "k_TechniqueDecl";
    EInstructionTypes[EInstructionTypes["k_Technique11Decl"] = 51] = "k_Technique11Decl";
    EInstructionTypes[EInstructionTypes["k_CbufferDecl"] = 52] = "k_CbufferDecl";
    EInstructionTypes[EInstructionTypes["k_Stmt"] = 53] = "k_Stmt";
    EInstructionTypes[EInstructionTypes["k_ExprStmt"] = 54] = "k_ExprStmt";
    EInstructionTypes[EInstructionTypes["k_BreakStmt"] = 55] = "k_BreakStmt";
    EInstructionTypes[EInstructionTypes["k_WhileStmt"] = 56] = "k_WhileStmt";
    EInstructionTypes[EInstructionTypes["k_ForStmt"] = 57] = "k_ForStmt";
    EInstructionTypes[EInstructionTypes["k_IfStmt"] = 58] = "k_IfStmt";
    EInstructionTypes[EInstructionTypes["k_DeclStmt"] = 59] = "k_DeclStmt";
    EInstructionTypes[EInstructionTypes["k_ReturnStmt"] = 60] = "k_ReturnStmt";
    EInstructionTypes[EInstructionTypes["k_SemicolonStmt"] = 61] = "k_SemicolonStmt";
    EInstructionTypes[EInstructionTypes["k_StmtBlock"] = 62] = "k_StmtBlock";
    // part fx
    EInstructionTypes[EInstructionTypes["k_PartFxDecl"] = 63] = "k_PartFxDecl";
    EInstructionTypes[EInstructionTypes["k_PartFxPass"] = 64] = "k_PartFxPass";
    EInstructionTypes[EInstructionTypes["k_SpawnStmt"] = 65] = "k_SpawnStmt";
    EInstructionTypes[EInstructionTypes["k_DrawStmt"] = 66] = "k_DrawStmt";
    EInstructionTypes[EInstructionTypes["k_PresetDecl"] = 67] = "k_PresetDecl";
    EInstructionTypes[EInstructionTypes["k_PresetProperty"] = 68] = "k_PresetProperty";
})(EInstructionTypes || (EInstructionTypes = {}));
var ECheckStage;
(function (ECheckStage) {
    ECheckStage[ECheckStage["CODE_TARGET_SUPPORT"] = 0] = "CODE_TARGET_SUPPORT";
    ECheckStage[ECheckStage["SELF_CONTAINED"] = 1] = "SELF_CONTAINED"; /*  ,    , , .   . */
    // VALIDATION  /*      ,     */ 
})(ECheckStage || (ECheckStage = {}));
var EVarUsedMode;
(function (EVarUsedMode) {
    EVarUsedMode[EVarUsedMode["k_Read"] = 0] = "k_Read";
    EVarUsedMode[EVarUsedMode["k_Write"] = 1] = "k_Write";
    EVarUsedMode[EVarUsedMode["k_ReadWrite"] = 2] = "k_ReadWrite";
    EVarUsedMode[EVarUsedMode["k_Undefined"] = 3] = "k_Undefined";
    EVarUsedMode[EVarUsedMode["k_Default"] = 2] = "k_Default";
})(EVarUsedMode || (EVarUsedMode = {}));
var EExtractExprType;
(function (EExtractExprType) {
    EExtractExprType[EExtractExprType["k_Header"] = 0] = "k_Header";
    EExtractExprType[EExtractExprType["k_Float"] = 1] = "k_Float";
    EExtractExprType[EExtractExprType["k_Int"] = 2] = "k_Int";
    EExtractExprType[EExtractExprType["k_Bool"] = 3] = "k_Bool";
    EExtractExprType[EExtractExprType["k_Float2"] = 4] = "k_Float2";
    EExtractExprType[EExtractExprType["k_Int2"] = 5] = "k_Int2";
    EExtractExprType[EExtractExprType["k_Bool2"] = 6] = "k_Bool2";
    EExtractExprType[EExtractExprType["k_Float3"] = 7] = "k_Float3";
    EExtractExprType[EExtractExprType["k_Int3"] = 8] = "k_Int3";
    EExtractExprType[EExtractExprType["k_Bool3"] = 9] = "k_Bool3";
    EExtractExprType[EExtractExprType["k_Float4"] = 10] = "k_Float4";
    EExtractExprType[EExtractExprType["k_Int4"] = 11] = "k_Int4";
    EExtractExprType[EExtractExprType["k_Bool4"] = 12] = "k_Bool4";
    EExtractExprType[EExtractExprType["k_Float4x4"] = 13] = "k_Float4x4";
})(EExtractExprType || (EExtractExprType = {}));
var EScopeType;
(function (EScopeType) {
    EScopeType[EScopeType["k_System"] = 0] = "k_System";
    EScopeType[EScopeType["k_Global"] = 1] = "k_Global";
    EScopeType[EScopeType["k_Default"] = 2] = "k_Default";
    EScopeType[EScopeType["k_Struct"] = 3] = "k_Struct";
    EScopeType[EScopeType["k_Cbuffer"] = 4] = "k_Cbuffer";
    EScopeType[EScopeType["k_Annotation"] = 5] = "k_Annotation";
})(EScopeType || (EScopeType = {}));
;
var ETechniqueType;
(function (ETechniqueType) {
    ETechniqueType[ETechniqueType["k_BasicFx"] = 0] = "k_BasicFx";
    ETechniqueType[ETechniqueType["k_PartFx"] = 1] = "k_PartFx";
    ETechniqueType[ETechniqueType["k_Unknown"] = 2] = "k_Unknown";
})(ETechniqueType || (ETechniqueType = {}));


/***/ }),

/***/ "Y0AG":
/*!***************************************!*\
  !*** ./src/lib/idl/parser/IParser.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ENodeCreateMode": () => (/* binding */ ENodeCreateMode),
/* harmony export */   "EOperationType": () => (/* binding */ EOperationType),
/* harmony export */   "EParserCode": () => (/* binding */ EParserCode),
/* harmony export */   "EParserFlags": () => (/* binding */ EParserFlags),
/* harmony export */   "EParserType": () => (/* binding */ EParserType),
/* harmony export */   "ETokenType": () => (/* binding */ ETokenType),
/* harmony export */   "IASTDocumentFlags": () => (/* binding */ IASTDocumentFlags)
/* harmony export */ });
var ENodeCreateMode;
(function (ENodeCreateMode) {
    ENodeCreateMode[ENodeCreateMode["k_Default"] = 0] = "k_Default";
    ENodeCreateMode[ENodeCreateMode["k_Necessary"] = 1] = "k_Necessary";
    ENodeCreateMode[ENodeCreateMode["k_Expose"] = 2] = "k_Expose";
    ENodeCreateMode[ENodeCreateMode["k_Skip"] = 3] = "k_Skip";
})(ENodeCreateMode || (ENodeCreateMode = {}));
var EParserCode;
(function (EParserCode) {
    // k_Pause,
    EParserCode[EParserCode["k_Ok"] = 0] = "k_Ok";
    EParserCode[EParserCode["k_Error"] = 1] = "k_Error";
})(EParserCode || (EParserCode = {}));
var EParserType;
(function (EParserType) {
    EParserType[EParserType["k_LR0"] = 0] = "k_LR0";
    EParserType[EParserType["k_LR1"] = 1] = "k_LR1";
    EParserType[EParserType["k_LALR"] = 2] = "k_LALR";
})(EParserType || (EParserType = {}));
var IASTDocumentFlags;
(function (IASTDocumentFlags) {
    IASTDocumentFlags[IASTDocumentFlags["k_Optimize"] = 8] = "k_Optimize";
    IASTDocumentFlags[IASTDocumentFlags["k_DeveloperMode"] = 16] = "k_DeveloperMode";
})(IASTDocumentFlags || (IASTDocumentFlags = {}));
var EParserFlags;
(function (EParserFlags) {
    EParserFlags[EParserFlags["k_ForceAppendAll"] = 1] = "k_ForceAppendAll";
    EParserFlags[EParserFlags["k_AllowExposeMode"] = 2] = "k_AllowExposeMode";
    EParserFlags[EParserFlags["k_AllowAddMode"] = 4] = "k_AllowAddMode";
    EParserFlags[EParserFlags["k_AllowSkipMode"] = 8] = "k_AllowSkipMode";
    EParserFlags[EParserFlags["k_Default"] = 14] = "k_Default";
    EParserFlags[EParserFlags["k_Debug"] = 16] = "k_Debug";
})(EParserFlags || (EParserFlags = {}));
var ETokenType;
(function (ETokenType) {
    ETokenType[ETokenType["k_NumericLiteral"] = 1] = "k_NumericLiteral";
    ETokenType[ETokenType["k_SinglelineCommentLiteral"] = 2] = "k_SinglelineCommentLiteral";
    ETokenType[ETokenType["k_MultilineCommentLiteral"] = 3] = "k_MultilineCommentLiteral";
    ETokenType[ETokenType["k_StringLiteral"] = 4] = "k_StringLiteral";
    ETokenType[ETokenType["k_PunctuatorLiteral"] = 5] = "k_PunctuatorLiteral";
    ETokenType[ETokenType["k_WhitespaceLiteral"] = 6] = "k_WhitespaceLiteral";
    ETokenType[ETokenType["k_EscapeSequence"] = 7] = "k_EscapeSequence";
    ETokenType[ETokenType["k_NewlineLiteral"] = 8] = "k_NewlineLiteral";
    ETokenType[ETokenType["k_IdentifierLiteral"] = 9] = "k_IdentifierLiteral";
    ETokenType[ETokenType["k_KeywordLiteral"] = 10] = "k_KeywordLiteral";
    ETokenType[ETokenType["K_MacroLiteral"] = 11] = "K_MacroLiteral";
    ETokenType[ETokenType["k_Unknown"] = 12] = "k_Unknown";
    ETokenType[ETokenType["k_End"] = 13] = "k_End";
})(ETokenType || (ETokenType = {}));
var EOperationType;
(function (EOperationType) {
    EOperationType[EOperationType["k_Error"] = 100] = "k_Error";
    EOperationType[EOperationType["k_Shift"] = 101] = "k_Shift";
    EOperationType[EOperationType["k_Reduce"] = 102] = "k_Reduce";
    EOperationType[EOperationType["k_Success"] = 103] = "k_Success";
    EOperationType[EOperationType["k_Ok"] = 104] = "k_Ok";
})(EOperationType || (EOperationType = {}));


/***/ }),

/***/ "j3Uf":
/*!*************************************!*\
  !*** ./src/lib/idl/part/IPartFx.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPassDrawMode": () => (/* binding */ EPassDrawMode)
/* harmony export */ });
// import { EPartFxInstructionTypes } from "./IPartFxInstruction";
var EPassDrawMode;
(function (EPassDrawMode) {
    EPassDrawMode[EPassDrawMode["k_Auto"] = 0] = "k_Auto";
    EPassDrawMode[EPassDrawMode["k_Manual"] = 1] = "k_Manual";
})(EPassDrawMode || (EPassDrawMode = {}));
;


/***/ }),

/***/ "w9mJ":
/*!*****************************************************!*\
  !*** ./src/lib/language-service/LanguageService.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLanguageService": () => (/* binding */ getLanguageService)
/* harmony export */ });
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "sg/z");
/* harmony import */ var _services_fx_codeLenses__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./services/fx/codeLenses */ "KMpe");
/* harmony import */ var _services_signatureHelp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./services/signatureHelp */ "m2xT");
/* harmony import */ var _lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/SLASTDocument */ "s/Ev");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");





function getLanguageService(opts) {
    const signatureHelp = new _services_signatureHelp__WEBPACK_IMPORTED_MODULE_2__.SLSignatureHelp();
    //
    // FX
    //
    const fxCodeLenses = new _services_fx_codeLenses__WEBPACK_IMPORTED_MODULE_1__.FXCodeLenses();
    return {
        async $parseSLASTDocument(textDocument) {
            const uri = textDocument.uri;
            const source = textDocument.getText();
            const slastDocument = await (0,_lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_3__.createSLASTDocument)(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__.createTextDocument)(uri, source), opts);
            return slastDocument;
        },
        async $parseSLDocument(slastDocument) {
            return await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_0__.createFXSLDocument)(slastDocument);
        },
        async parseDocument(textDocument) {
            const uri = textDocument.uri;
            const source = textDocument.getText();
            return await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_0__.createFXSLDocument)(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__.createTextDocument)(uri, source), opts);
        },
        doResolve(item) { return null; },
        doComplete(textDocument, position, slDocument) { return null; },
        findDocumentSymbols(textDocument, slDocument) { return []; },
        findDocumentColors(textDocument, slDocument) { return null; },
        getColorPresentations(textDocument, slDocument, color, range) { return []; },
        doHover(textDocument, position, slDocument) { return null; },
        format(textDocument, range, options) { return []; },
        getFoldingRanges(textDocument) { return []; },
        getSelectionRanges(textDocument, positions, slDocument) { return []; },
        doSignatureHelp: signatureHelp.doSignatureHelp.bind(signatureHelp),
        //
        // FX
        //
        doFxCodeLenses: fxCodeLenses.doProvide.bind(fxCodeLenses)
    };
}


/***/ }),

/***/ "KMpe":
/*!************************************************************!*\
  !*** ./src/lib/language-service/services/fx/codeLenses.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FXCodeLenses": () => (/* binding */ FXCodeLenses)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode-languageserver-types */ "+C5w");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");





class FXCodeLenses {
    doProvide(textDocument, slDocument) {
        if (!slDocument) {
            return [];
        }
        const lenses = [];
        const scope = slDocument.root.scope;
        /**
         * Just a draft code :)
         */
        const createCodeLens = (name, loc) => {
            const pos = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.Position.create(loc.start.line, loc.start.column);
            const range = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.Range.create(pos, pos);
            const lens = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.CodeLens.create(range);
            lens.command = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.Command.create(name, null);
            return lens;
        };
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope)) {
            for (const techniqueName in scope.techniques) {
                const technique = scope.techniques[techniqueName];
                if (technique.type === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.ETechniqueType.k_PartFx) {
                    const partFx = technique;
                    if (partFx.spawnRoutine) {
                        const fn = partFx.spawnRoutine.function.def;
                        const sourceNode = partFx.spawnRoutine.function.def.sourceNode;
                        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_4__.types.equals(fn.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_VOID)) {
                            if (fn.params.length > 0) {
                                lenses.push(createCodeLens(`[extened spawn]`, sourceNode.loc));
                            }
                            else {
                                lenses.push(createCodeLens(`[generic spawn]`, sourceNode.loc));
                            }
                        }
                        else {
                            lenses.push(createCodeLens(`[regular spawn]`, sourceNode.loc));
                        }
                    }
                    if (partFx.initRoutine) {
                        const sourceNode = partFx.initRoutine.function.def.sourceNode;
                        lenses.push(createCodeLens(`[init routine]`, sourceNode.loc));
                    }
                    if (partFx.updateRoutine) {
                        const sourceNode = partFx.updateRoutine.function.def.sourceNode;
                        lenses.push(createCodeLens(`[update routine]`, sourceNode.loc));
                    }
                    if (partFx.particle &&
                        partFx.particle.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemType) {
                        const sourceNode = partFx.particle.sourceNode;
                        lenses.push(createCodeLens(`[particle]`, sourceNode.loc));
                    }
                    for (const pass of partFx.passes) {
                        if (pass.prerenderRoutine) {
                            {
                                const sourceNode = pass.prerenderRoutine.function.def.sourceNode;
                                lenses.push(createCodeLens(`[prerender routine]`, sourceNode.loc));
                            }
                            {
                                const sourceNode = pass.particleInstance.sourceNode;
                                if (sourceNode.loc.start.file.toString() === textDocument.uri)
                                    lenses.push(createCodeLens(`[material]`, sourceNode.loc));
                            }
                        }
                    }
                }
            }
        }
        return lenses;
    }
}


/***/ }),

/***/ "m2xT":
/*!************************************************************!*\
  !*** ./src/lib/language-service/services/signatureHelp.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SLSignatureHelp": () => (/* binding */ SLSignatureHelp)
/* harmony export */ });
/* harmony import */ var _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/Visitors */ "q04y");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode-languageserver-types */ "+C5w");




const asRange = (instr) => instr.sourceNode.loc;
class SLSignatureHelp {
    doSignatureHelp(textDocument, position, slDocument) {
        if (!slDocument) {
            return null;
        }
        const offset = textDocument.offsetAt(position);
        const decl = slDocument.root.instructions.find(instr => (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_2__.checkRange)(asRange(instr), offset));
        if (decl) {
            // console.log(decl);
            if (decl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionDecl) {
                let fcall = null;
                _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_0__.Visitor.each(decl, instr => {
                    if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionCallExpr) {
                        if ((0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_2__.checkRange)(asRange(instr), offset)) {
                            fcall = instr;
                        }
                    }
                });
                if (!fcall) {
                    return null;
                }
                const fdecl = fcall.decl;
                const fnList = fdecl.scope.functions[fdecl.name];
                const signatures = fnList.map(fn => vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.SignatureInformation.create(fn.def.toCode(), null, // no documentation provided
                ...fn.def.params.map(param => vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.ParameterInformation.create(param.name))));
                let activeSignature = fnList.indexOf(fdecl);
                let activeParameter = 0;
                if (activeSignature !== -1) {
                    activeParameter = fcall.args.findIndex(arg => (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_2__.checkRange)(asRange(arg), offset));
                }
                else {
                    activeSignature = 0;
                    console.error(`could not find active signature for: '${fdecl.def.toCode()}'`);
                }
                return { signatures, activeParameter, activeSignature };
            }
        }
        return null;
    }
}


/***/ }),

/***/ "7GK7":
/*!***************************************!*\
  !*** ./src/lib/parser/ASTDocument.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTDocument": () => (/* binding */ ASTDocument),
/* harmony export */   "EParsingErrors": () => (/* binding */ EParsingErrors),
/* harmony export */   "EParsingWarnings": () => (/* binding */ EParsingWarnings),
/* harmony export */   "ParsingDiagnostics": () => (/* binding */ ParsingDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "SSye");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_ParseTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/ParseTree */ "Eumm");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");









var EParsingErrors;
(function (EParsingErrors) {
    EParsingErrors[EParsingErrors["SyntaxUnknownError"] = 2051] = "SyntaxUnknownError";
    EParsingErrors[EParsingErrors["SyntaxUnexpectedEOF"] = 2052] = "SyntaxUnexpectedEOF";
    EParsingErrors[EParsingErrors["SyntaxRecoverableStateNotFound"] = 2053] = "SyntaxRecoverableStateNotFound";
    EParsingErrors[EParsingErrors["GeneralParsingLimitIsReached"] = 2054] = "GeneralParsingLimitIsReached";
})(EParsingErrors || (EParsingErrors = {}));
;
var EParsingWarnings;
(function (EParsingWarnings) {
    EParsingWarnings[EParsingWarnings["MacroUnknownWarning"] = 3000] = "MacroUnknownWarning";
    EParsingWarnings[EParsingWarnings["ReserveWordUsing"] = 3001] = "ReserveWordUsing";
})(EParsingWarnings || (EParsingWarnings = {}));
class ParsingDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.Diagnostics {
    constructor() {
        super("Parsing diagnostics", 'P');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        if (category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__.EDiagnosticCategory.k_Warning) {
            switch (code) {
                case EParsingWarnings.MacroUnknownWarning:
                    return desc.loc;
            }
        }
        //
        // errors
        //
        switch (code) {
            case EParsingErrors.SyntaxUnknownError:
            case EParsingErrors.SyntaxUnexpectedEOF:
                return desc.token.loc;
        }
        return null;
    }
    //
    // NODE: position is being resolved only in case of failed range resolving
    //
    resolvePosition(category, code, desc) {
        console.assert(code != EParsingErrors.SyntaxUnknownError);
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParsingErrors.SyntaxUnknownError]: "Syntax error during parsing. Token: '{token.value}'\n" +
                "{token.loc.start.file}:{token.loc.start.line}:{token.loc.start.column}.",
            [EParsingErrors.SyntaxUnexpectedEOF]: "Syntax error. Unexpected EOF.",
            [EParsingErrors.GeneralParsingLimitIsReached]: "Parsing limit is reached.",
            [EParsingErrors.SyntaxRecoverableStateNotFound]: "Recoverable state not found."
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__.EDiagnosticCategory.k_Warning) {
            return `${EParsingWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${EParsingErrors[code]}: ${JSON.stringify(data)}`;
    }
}
function cloneToken(token) {
    return {
        ...token,
        loc: {
            start: { ...token.loc.start },
            end: { ...token.loc.end }
        }
    };
}
// class Context {
//     allowErrorRecoverty: boolean = true;
//     developerMode: boolean = false;
//     lexer: Lexer;
//     diagnostics: ParsingDiagnostics;
//     knownTypes: Set<string>;
//     ruleFunctions: Map<string, IRuleFunction>;
//     stack: number[] = [0];
//     constructor() {
//         this.diagnostics = new ParsingDiagnostics;
//     }
//     readToken() {
//         return this.lexer.getNextToken();
//     }
//     private error(code: number, token: IToken) {
//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });
//     }
//     private critical(code: number, token: IToken = null) {
//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });
//     }
// }
class ASTDocument {
    constructor(config) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(config.parser, 'parser engine is not defined');
        this.init(config);
    }
    init({ parser, knownTypes = new Set(), ruleFunctions = new Map }) {
        this.parser = parser;
        this.knownTypes = knownTypes;
        this.ruleFunctions = ruleFunctions;
    }
    get uri() {
        // TODO: use uri from original textDocument
        return this.lexer.document.uri;
    }
    get diagnosticReport() {
        let lexerReport = this.lexer.getDiagnosticReport();
        let parserReport = this.diag.resolve();
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.Diagnostics.mergeReports([lexerReport, parserReport]);
    }
    get root() {
        return this.tree.root;
    }
    async parse(textDocument, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_Optimize) {
        const developerMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_DeveloperMode);
        const allowErrorRecoverty = true;
        const optimizeTree = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_Optimize);
        this.diag = new ParsingDiagnostics;
        this.tree = new _lib_parser_ParseTree__WEBPACK_IMPORTED_MODULE_5__.ParseTree(optimizeTree);
        this.stack = [0];
        this.setTextDocument(textDocument);
        this.token = await this.readToken();
        if (this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Ok;
        }
        await this.run({ developerMode, allowErrorRecoverty });
        // clear context
        // this.stack = null;
        // this.lexer = null;
        // this.token = null;
        // diag
        // tree
        // end of clear
        if (this.diag.hasErrors()) {
            console.error('parsing was ended with errors.');
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Error;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Ok;
    }
    setTextDocument(textDocument) {
        this.lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__.Lexer({
            engine: this.parser.lexerEngine,
            knownTypes: this.knownTypes
        });
        this.lexer.setTextDocument(textDocument);
    }
    async readToken() {
        return this.lexer.getNextToken();
    }
    emitWarning(code, token) {
        this.diag.warning(code, { token });
    }
    emitError(code, token) {
        this.diag.error(code, { token });
    }
    emitCritical(code, token = null) {
        this.diag.critical(code, { token });
    }
    async restoreState(syntaxTable, parseTree, stack, causingErrorToken, errorToken) {
        while (true) {
            let recoverableState = -1;
            for (let i = stack.length - 1; i >= 0; --i) {
                const errorOp = syntaxTable[stack[i]][_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR];
                const isRecoverableState = ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(errorOp) &&
                    errorOp.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift &&
                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);
                if (isRecoverableState) {
                    recoverableState = i;
                    break;
                }
            }
            if (recoverableState !== -1) {
                const recoveredStateIndex = stack[recoverableState];
                // current op will be: syntaxTable[recoveredStateIndex][ERROR];
                let stackDiff = stack.length - 1 - recoverableState;
                while (stackDiff != 0) {
                    // extend error token location with the already processed tokens
                    parseTree.$pop(errorToken.loc);
                    stack.pop();
                    stackDiff--;
                }
                // recoverable state found so continue normal processing as it would be before the error
                return recoveredStateIndex;
            }
            // TODO: optimize this call!
            (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_7__.extendRange)(errorToken.loc, causingErrorToken.loc);
            if (causingErrorToken.value === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
                // state cant be recovered
                break;
            }
            // try to restore from the next token
            // FIXME: 
            const nextToken = await this.readToken();
            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);
        }
        return -1;
    }
    operationAdditionalAction(stateIndex, grammarSymbol) {
        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(funcName)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(!!this.ruleFunctions.has(funcName));
            return this.ruleFunctions.get(funcName)();
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Ok;
    }
    async run({ developerMode = false, allowErrorRecoverty = true }) {
        const { syntaxTable } = this.parser;
        const { stack, tree } = this;
        const undefinedToken = { index: -1, name: null, value: null };
        let causingErrorToken = undefinedToken;
        // debug mode
        const opLimit = 64e5;
        let opCounter = 0;
        try {
            breakProcessing: while (true) {
                // global recursion prevention in debug mode
                if (developerMode) {
                    if (opCounter > opLimit) {
                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);
                    }
                    opCounter++;
                }
                let currStateIndex = stack[stack.length - 1];
                let op = syntaxTable[currStateIndex][this.token.name];
                if (allowErrorRecoverty) {
                    if (!op) {
                        const ID_REGEXP = /^[_a-zA-Z][_a-zA-Z0-9]{0,30}$/;
                        const isLikeID = this.token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID && ID_REGEXP.test(this.token.value);
                        const canContinueAsID = isLikeID && syntaxTable[currStateIndex][_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID];
                        // recursion prevention
                        if (causingErrorToken.index !== this.token.index) {
                            if (this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);
                            }
                            else {
                                // a special case to bypass tokens of the same name with keywords
                                if (canContinueAsID) {
                                    // todo: emit warning(!)
                                    // this.emitWarning(EParsingWarnings.ReserveWordUsing, this.token);
                                }
                                else {
                                    this.emitError(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                            }
                        }
                        else {
                            // one more attempt to recover but from the next token
                            this.token = await this.readToken();
                            if (this.token.index === -1)
                                debugger;
                            // NOTE: in order to prevent recusrion on END_SYMBOL
                            causingErrorToken = undefinedToken;
                            continue;
                        }
                        causingErrorToken = cloneToken(this.token);
                        if (canContinueAsID) {
                            this.token = { ...cloneToken(this.token), name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID };
                        }
                        else {
                            // token = { ...token, name: ERROR };
                            this.token = { ...cloneToken(this.token), name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR };
                        }
                    }
                    op = syntaxTable[currStateIndex][this.token.name];
                    const errorProcessing = this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR;
                    const errorReductionEnded = !op || (errorProcessing && (op.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift));
                    // state must be recovered if operation is undefined or error reduction was ended. 
                    if (errorReductionEnded) {
                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. 
                        let recoveryToken = cloneToken(causingErrorToken);
                        while (recoveryToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNKNOWN_TOKEN) {
                            recoveryToken = await this.readToken();
                            if (recoveryToken.index === -1)
                                debugger;
                        }
                        currStateIndex = await this.restoreState(syntaxTable, tree, stack, recoveryToken, this.token /* error token */);
                        if (currStateIndex === -1) {
                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);
                        }
                        // perform error shift op.
                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'
                        stack.push(op.stateIndex);
                        tree.addToken(this.token /* error token */);
                        this.token = recoveryToken;
                        // const nextOp = syntaxTable[op.stateIndex][token.name];
                        // if (nextOp.type === EOperationType.k_Reduce) {
                        //     tokenBuffer.push(rec);
                        // }
                        // return to normal precesing loop
                        continue;
                    }
                }
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(op)) {
                    switch (op.type) {
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Success:
                            break breakProcessing;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift:
                            {
                                const stateIndex = op.stateIndex;
                                stack.push(stateIndex);
                                tree.addToken(this.token);
                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, this.token.name);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                                else if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Ok) {
                                    this.token = await this.readToken();
                                    if (this.token.index === -1)
                                        debugger;
                                }
                            }
                            break;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Reduce:
                            {
                                const ruleLength = op.rule.right.length;
                                stack.length -= ruleLength;
                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;
                                stack.push(stateIndex);
                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));
                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, op.rule.left);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                            }
                            break;
                    }
                }
                else {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(!allowErrorRecoverty, `unexpected end, something went wrong :/`);
                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                }
            }
            tree.finishTree();
        }
        catch (e) {
            if (!(e instanceof _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.DiagnosticException)) {
                throw e;
            }
        }
    }
}


/***/ }),

/***/ "BF0t":
/*!******************************************!*\
  !*** ./src/lib/parser/AbstractParser.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractParser": () => (/* binding */ AbstractParser),
/* harmony export */   "EParserErrors": () => (/* binding */ EParserErrors),
/* harmony export */   "GrammarDiagnostics": () => (/* binding */ GrammarDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "SSye");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/Item */ "gO55");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/State */ "Xd2f");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");








var EParserErrors;
(function (EParserErrors) {
    EParserErrors[EParserErrors["GrammarAddOperation"] = 2001] = "GrammarAddOperation";
    EParserErrors[EParserErrors["GrammarAddStateLink"] = 2002] = "GrammarAddStateLink";
    EParserErrors[EParserErrors["GrammarUnexpectedSymbol"] = 2003] = "GrammarUnexpectedSymbol";
    EParserErrors[EParserErrors["GrammarInvalidAdditionalFuncName"] = 2004] = "GrammarInvalidAdditionalFuncName";
    EParserErrors[EParserErrors["GrammarInvalidKeyword"] = 2005] = "GrammarInvalidKeyword";
})(EParserErrors || (EParserErrors = {}));
;
class GrammarDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics {
    constructor() {
        super("Grammar diagnostics", 'G');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        return null;
    }
    resolvePosition(category, code, desc) {
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParserErrors.GrammarAddOperation]: "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old operation: {oldOperation}\n" +
                "New operation: {newOperation}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states." +
                `\n\n{stateDesc}`,
            [EParserErrors.GrammarAddStateLink]: "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old next state: {oldNextStateIndex}\n" +
                "New next state: {newNextStateIndex}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states.",
            [EParserErrors.GrammarUnexpectedSymbol]: "Grammar error. Can`t generate rules from grammar\n" +
                "Unexpected symbol: {unexpectedSymbol}\n" +
                "Expected: {expectedSymbol}",
            [EParserErrors.GrammarInvalidAdditionalFuncName]: "Grammar error. Empty additional function name.",
            [EParserErrors.GrammarInvalidKeyword]: "Grammar error. Bad keyword: {badKeyword}\n" +
                "All keyword must be define in lexer rule block."
        };
    }
}
class AbstractParser {
    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR
    constructor({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR }) {
        this._syntaxTable = null;
        this._productions = null;
        this._baseItems = null;
        this._states = null;
        this._additionalFuncInfoList = null;
        this._adidtionalFunctByStateDMap = null;
        this._ruleCreationModeMap = null;
        this._firstTerminalsCache = null;
        // this._followTerminalsCache = null;
        this._closureForItemsCache = null;
        this._expectedExtensionDMap = null;
        this._diag = new GrammarDiagnostics;
        this.init({ grammar, flags, type });
    }
    get syntaxTable() {
        return this._syntaxTable;
    }
    findFunctionByState(stateIndex, grammarSymbol) {
        const funcDMap = this._adidtionalFunctByStateDMap;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(funcDMap) &&
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(funcDMap[stateIndex]) &&
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(funcDMap[stateIndex][grammarSymbol])) {
            return funcDMap[stateIndex][grammarSymbol];
        }
        return null;
    }
    getRuleCreationMode(nonTerminal) {
        return this._ruleCreationModeMap[nonTerminal];
    }
    getGrammarSymbols() {
        return this._grammarSymbols;
    }
    init({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR }) {
        this.lexerEngine = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__.LexerEngine();
        this.generateRules(grammar, flags);
        this.buildSyntaxTable(type);
        this.generateFunctionByStateMap();
        if (!_lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Debug)) {
            this.clearMem();
        }
    }
    printStates(isBaseOnly = true) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._states)) {
            console.warn("It`s impossible to print states. You must init parser in debug-mode");
            return;
        }
        const mesg = "\n" + this.statesToString(isBaseOnly);
        console.log(mesg);
    }
    printState(stateIndex, isBaseOnly = true) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._states)) {
            console.log("It`s impossible to print states. You must init parser in debug-mode.");
            return;
        }
        var state = this._states[stateIndex];
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(state)) {
            console.log("Can not print stete with index: " + stateIndex.toString());
            return;
        }
        console.log(`\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);
    }
    critical(code, desc) {
        this._diag.critical(code, desc);
    }
    grammarError(code, desc) {
        let file = "grammar";
        switch (code) {
            case EParserErrors.GrammarAddOperation:
                {
                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;
                    this.critical(code, {
                        file, line: 0, stateIndex, grammarSymbol,
                        oldOperation: AbstractParser.operationToString(oldOperation),
                        newOperation: AbstractParser.operationToString(newOperation),
                        stateDesc: this._states[stateIndex].toString()
                    });
                }
                break;
            case EParserErrors.GrammarAddStateLink:
                {
                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;
                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });
                }
                break;
            case EParserErrors.GrammarUnexpectedSymbol:
                {
                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;
                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });
                }
                break;
            case EParserErrors.GrammarInvalidAdditionalFuncName:
                {
                    const { grammarLine } = desc;
                    this.critical(code, { file, line: grammarLine });
                }
                break;
            case EParserErrors.GrammarInvalidKeyword:
                {
                    const { grammarLine, badKeyword } = desc;
                    this.critical(code, { file, line: grammarLine, badKeyword });
                }
                break;
            default:
                throw "invalid case!!!!";
        }
    }
    clearMem() {
        delete this._states;
        delete this._productions;
        delete this._baseItems;
        // delete this._followTerminalsCache;
        delete this._firstTerminalsCache;
        delete this._closureForItemsCache;
        delete this._expectedExtensionDMap;
    }
    /**
     * Check for the state's dublicate.
     */
    hasState(state, type) {
        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;
    }
    nonTerminals() {
        return Object.keys(this._productions);
    }
    rules(nonTerminal) {
        const prods = this._productions[nonTerminal];
        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;
    }
    ruleCreationMode(symbol) {
        return this._ruleCreationModeMap[symbol];
    }
    /**
     * terminals & non-terminals;
     */
    symbols() {
        return [...this._grammarSymbols.keys()];
    }
    isTerminal(symbol) {
        return !(this._productions[symbol]);
    }
    /**
     * Add item to 'stateList' and set item's index in it.
     */
    pushState(state) {
        state.index = this._states.length;
        this._states.push(state);
    }
    /**
     * Add item to 'baseItemList' and set item's index in it.
     */
    pushBaseItem(item) {
        item.index = this._baseItems.length;
        this._baseItems.push(item);
    }
    tryAddState(state, type) {
        let res = this.hasState(state, type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(res)) {
            if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
                state.eachItem(item => this.pushBaseItem(item));
            }
            this.pushState(state);
            this.closure(state, type);
            return state;
        }
        return res;
    }
    hasEmptyRule(symbol) {
        if (this.isTerminal(symbol)) {
            return false;
        }
        return !!this.rules(symbol).find(rule => rule.right.length === 0);
    }
    pushInSyntaxTable(syntaxTable, stateIndex, symbol, operation) {
        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(syntaxTable[stateIndex][symbol])) {
            this.grammarError(EParserErrors.GrammarAddOperation, {
                stateIndex: stateIndex,
                grammarSymbol: this.convertGrammarSymbol(symbol),
                oldOperation: this._syntaxTable[stateIndex][symbol],
                newOperation: operation
            });
        }
        syntaxTable[stateIndex][symbol] = operation;
    }
    addStateLink(state, nextState, symbol) {
        let isAddState = state.addNextState(symbol, nextState);
        if (!isAddState) {
            this.grammarError(EParserErrors.GrammarAddStateLink, {
                stateIndex: state.index,
                oldNextStateIndex: state.nextStates[symbol] || null,
                newNextStateIndex: nextState.index,
                grammarSymbol: this.convertGrammarSymbol(symbol)
            });
        }
    }
    firstTerminals(symbol) {
        if (this.isTerminal(symbol)) {
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._firstTerminalsCache[symbol])) {
            return this._firstTerminalsCache[symbol];
        }
        const rules = this.rules(symbol);
        const res = this._firstTerminalsCache[symbol] = new Set();
        if (this.hasEmptyRule(symbol)) {
            res.add(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY);
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(rules)) {
            return res;
        }
        for (let i = 0; i < rules.length; ++i) {
            const rule = rules[i];
            const right = rule.right;
            let isFinish = false;
            for (let j = 0; j < right.length; j++) {
                if (right[j] === symbol) {
                    if (res.has(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY)) {
                        continue;
                    }
                    isFinish = true;
                    break;
                }
                const terminals = this.firstTerminals(right[j]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(terminals)) {
                    res.add(right[j]);
                }
                else {
                    for (const terminal of terminals) {
                        res.add(terminal);
                    }
                }
                if (!this.hasEmptyRule(right[j])) {
                    isFinish = true;
                    break;
                }
            }
            if (!isFinish) {
                res.add(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY);
            }
        }
        return res;
    }
    // private followTerminal(symbolVal: string): IMap<boolean> {
    //     if (isDef(this._followTerminalsCache[symbolVal])) {
    //         return this._followTerminalsCache[symbolVal];
    //     }
    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;
    //     var pRulesDMap: IRuleDMap = this._rulesDMap;
    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];
    //     var rule: IRule;
    //     var pTempRes: IMap<boolean>;
    //     var pTempKeys: string[];
    //     var res: IMap<boolean>;
    //     var right: string[];
    //     var isFinish: boolean;
    //     var sFirstKey: string;
    //     var sSecondKey: string;
    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};
    //     if (isNull(pRulesDMap)) {
    //         return res;
    //     }
    //     rulesDMapKeys = Object.keys(pRulesDMap);
    //     for (i = 0; i < rulesDMapKeys.length; i++) {
    //         sFirstKey = rulesDMapKeys[i];
    //         if (isNull(pRulesDMap[sFirstKey])) {
    //             continue;
    //         }
    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);
    //         for (j = 0; j < pRulesMapKeys.length; j++) {
    //             rule = pRulesDMap[sFirstKey][sSecondKey];
    //             right = rule.right;
    //             for (k = 0; k < right.length; k++) {
    //                 if (right[k] === symbolVal) {
    //                     if (k === right.length - 1) {
    //                         pTempRes = this.followTerminal(rule.left);
    //                         pTempKeys = Object.keys(pTempRes);
    //                         for (m = 0; m < pTempKeys.length; i++) {
    //                             res[pTempKeys[m]] = true;
    //                         }
    //                     }
    //                     else {
    //                         isFinish = false;
    //                         for (l = k + 1; l < right.length; l++) {
    //                             pTempRes = this.firstTerminal(right[l]);
    //                             if (isNull(pTempRes)) {
    //                                 res[right[l]] = true;
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                             else {
    //                                 pTempKeys = Object.keys(pTempRes);
    //                                 for (m = 0; m < pTempKeys.length; i++) {
    //                                     res[pTempKeys[m]] = true;
    //                                 }
    //                             }
    //                             if (!pTempRes[T_EMPTY]) {
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                         }
    //                         if (!isFinish) {
    //                             pTempRes = this.followTerminal(rule.left);
    //                             pTempKeys = Object.keys(pTempRes);
    //                             for (m = 0; m < pTempKeys.length; i++) {
    //                                 res[pTempKeys[m]] = true;
    //                             }
    //                         }
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return res;
    // }
    firstTerminalsForSet(symbolList, expectedSymbols) {
        const res = new Set();
        for (let i = 0; i < symbolList.length; i++) {
            const terminals = this.firstTerminals(symbolList[i]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(terminals)) {
                res.add(symbolList[i]);
                return res;
            }
            let isEmpty = false;
            for (const symbol of terminals) {
                if (symbol === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY) {
                    isEmpty = true;
                    continue;
                }
                res.add(symbol);
            }
            if (!isEmpty) {
                return res;
            }
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(expectedSymbols)) {
            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));
        }
        return res;
    }
    generateRules(grammarSource, flags) {
        let allRuleList = grammarSource.split(/\r?\n/);
        let tempRule;
        let rule;
        let isLexerBlock = false;
        this._productions = {};
        this._additionalFuncInfoList = [];
        this._ruleCreationModeMap = {};
        this._grammarSymbols = new Map([['END_SYMBOL', _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL]]);
        let i = 0, j = 0;
        // append all nodes ignoring any flags
        const forceAppendAllMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_ForceAppendAll);
        // force unwind node if it is marked as '--expose'
        const allowExposeMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowExposeMode);
        // force add node if it is marked as '--add'
        const allowAddMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowAddMode);
        // remove node from parsing tree if it is marked as '--skip'
        const allowSkipMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowSkipMode);
        let symbolsWithNodeMap = this._ruleCreationModeMap;
        let name;
        let nRules = 0;
        for (i = 0; i < allRuleList.length; i++) {
            if (allRuleList[i] === "" || allRuleList[i] === "\r") {
                continue;
            }
            // split rule like 'S : Program'
            tempRule = allRuleList[i].trim().split(/\s* \s*/);
            // ignore rules starting with '#'
            if (tempRule[0][0] == _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.INLINE_COMMENT_SYMBOL) {
                continue;
            }
            if (isLexerBlock) {
                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === "")) &&
                    ((tempRule[2][0] === "\"" || tempRule[2][0] === "'") && tempRule[2].length > 3)) {
                    //TERMINALS
                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],
                            expectedSymbol: tempRule[2][0],
                            grammarLine: i
                        });
                    }
                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);
                    var ch = tempRule[2][0];
                    if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);
                    }
                    else {
                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);
                    }
                    this._grammarSymbols.set(name, tempRule[2]);
                }
                continue;
            }
            // looking for '--LEXER--' keyword
            if (tempRule[0] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.LEXER_RULES) {
                isLexerBlock = true;
                continue;
            }
            //NON TERMNINAL RULES
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._productions[tempRule[0]])) {
                this._productions[tempRule[0]] = {};
            }
            rule = {
                left: tempRule[0],
                right: [],
                index: 0
            };
            this._grammarSymbols.set(tempRule[0], tempRule[0]);
            if (forceAppendAllMode) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Default;
            }
            else if (allowExposeMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Default;
            }
            else if (allowAddMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Expose;
            }
            else if (allowSkipMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Skip;
            }
            for (j = 2; j < tempRule.length; j++) {
                if (tempRule[j] === "") {
                    continue;
                }
                // handle flag '--add'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_CREATE_NODE) {
                    if (allowAddMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Necessary;
                    }
                    continue;
                }
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_SKIP_NODE) {
                    if (allowSkipMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Skip;
                    }
                    continue;
                }
                // handle flag '--expose'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_EXPOSE_NODE) {
                    if (allowExposeMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Expose;
                    }
                    continue;
                }
                // looking for additional user functions like '--F includeCode'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_FUNCTION) {
                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {
                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });
                    }
                    const funcInfo = {
                        name: tempRule[j + 1],
                        position: rule.right.length,
                        rule: rule
                    };
                    this._additionalFuncInfoList.push(funcInfo);
                    j++;
                    continue;
                }
                // handle string literlas
                if (tempRule[j][0] === "'" || tempRule[j][0] === "\"") {
                    if (tempRule[j].length !== 3) {
                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {
                            badKeyword: tempRule[j],
                            grammarLine: i
                        });
                    }
                    if (tempRule[j][0] !== tempRule[j][2]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[j][2],
                            expectedSymbol: tempRule[j][0],
                            grammarLine: i
                        });
                    }
                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);
                    rule.right.push(name);
                    this._grammarSymbols.set(name, tempRule[j][1]);
                }
                else {
                    rule.right.push(tempRule[j]);
                    this._grammarSymbols.set(tempRule[j], tempRule[j]);
                }
            }
            rule.index = nRules;
            this._productions[tempRule[0]][rule.index] = rule;
            nRules++;
            // TODO: emit diagnostics error instead.
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(nRules != 1 || (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0]));
        }
    }
    generateFunctionByStateMap() {
        const stateList = this._states;
        const funcInfoList = this._additionalFuncInfoList;
        const funcByStateDMap = this._adidtionalFunctByStateDMap = {};
        for (let i = 0; i < funcInfoList.length; i++) {
            const funcInfo = funcInfoList[i];
            const rule = funcInfo.rule;
            const pos = funcInfo.position;
            const grammarSymbol = rule.right[pos - 1];
            for (let j = 0; j < stateList.length; j++) {
                if (stateList[j].hasRule(rule, pos)) {
                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};
                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;
                }
            }
        }
    }
    generateFirstState_LR0() {
        const state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        // START_SYMBOL should be always defined at the beginning of grammar
        const firstRule = this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0];
        const item = new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(firstRule, 0);
        this.pushBaseItem(item);
        state.push(item);
        this.closure_LR0(state);
        this.pushState(state);
    }
    generateFirstState_LR() {
        const state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        const firstRule = this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0];
        state.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(firstRule, 0, [_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL]));
        this.closure_LR(state);
        this.pushState(state);
    }
    closure(state, type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
            this.closure_LR0(state);
        }
        else {
            this.closure_LR(state);
        }
    }
    closure_LR0(state) {
        // NOTE: loop grows implicitly inside state.tryPush() function.
        //       do not change this loop.
        state.eachItem(item => {
            const symbol = item.symbolName();
            if (symbol !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION && !this.isTerminal(symbol)) {
                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));
            }
        });
    }
    closure_LR(state) {
        let isNewExpected;
        do {
            isNewExpected = false;
            state.eachItem(item => {
                const symbol = item.symbolName();
                if (symbol !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION && !this.isTerminal(symbol)) {
                    const nextSymbols = item.rule.right.slice(item.pos + 1);
                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);
                    this.rules(symbol).forEach(rule => {
                        expectedTerminals.forEach(expectedTerminal => {
                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {
                                isNewExpected = true;
                            }
                        });
                    });
                }
            });
        } while (isNewExpected);
    }
    static nextState_LR0(state, symbol) {
        const nextState = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                nextState.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(item.rule, item.pos + 1));
            }
        });
        return nextState;
    }
    static nextState_LR(state, symbol) {
        const nextState = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                const expectedSymbols = Array.from(item.expectedSymbols);
                nextState.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(item.rule, item.pos + 1, expectedSymbols));
            }
        });
        return nextState;
    }
    deleteNotBaseItems() {
        this._states.forEach(state => state.deleteNotBase());
    }
    closureForItem({ rule, pos }) {
        const indexVal = rule.index + "_" + pos;
        let state = this._closureForItemsCache[indexVal];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(state)) {
            return state;
        }
        state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(rule, pos, [_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNUSED_SYMBOL]));
        this.closure_LR(state);
        this._closureForItemsCache[indexVal] = state;
        return state;
    }
    addLinkExpected(item, itemX) {
        let table = this._expectedExtensionDMap;
        let index = item.index;
        table[index] = table[index] || {};
        table[index][itemX.index] = true;
    }
    determineExpected(testState, symbol) {
        const stateNext = testState.nextStates[symbol] || null;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(stateNext)) {
            return;
        }
        // at this moment all items already 'base' because of
        // deleteNotBase() call before.
        testState.eachBaseItem(baseItem => {
            const state = this.closureForItem(baseItem);
            stateNext.eachBaseItem(baseItemNext => {
                const item = state.hasChildItem(baseItemNext);
                if (item) {
                    item.expectedSymbols.forEach(symbol => {
                        if (symbol === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNUSED_SYMBOL) {
                            this.addLinkExpected(baseItem, baseItemNext);
                        }
                        else {
                            baseItemNext.addExpected(symbol);
                        }
                    });
                }
            });
        });
    }
    generateLinksExpected() {
        const states = this._states;
        const symbols = this.symbols();
        states.forEach(state => symbols.forEach(symbol => this.determineExpected(state, symbol)));
    }
    expandExpected() {
        const baseItems = this._baseItems;
        const itemExpected = baseItems.map(item => true);
        const table = this._expectedExtensionDMap;
        baseItems[0].addExpected(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL);
        itemExpected[0] = (true);
        let isNewExpected;
        do {
            isNewExpected = false;
            baseItems.forEach((baseItem) => {
                if (itemExpected[baseItem.index] && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDefAndNotNull)(table[baseItem.index])) {
                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));
                    baseItem.expectedSymbols.forEach(expectedSymbol => {
                        indexesOfExpectedItems.forEach(expectedIndex => {
                            const baseItemExpected = baseItems[expectedIndex];
                            if (baseItemExpected.addExpected(expectedSymbol)) {
                                itemExpected[expectedIndex] = true;
                                isNewExpected = true;
                            }
                        });
                    });
                }
                itemExpected[baseItem.index] = false;
            });
        } while (isNewExpected);
    }
    generateStates(type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
            this.generateStates_LR0();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR1) {
            this.generateStates_LR();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR) {
            this.generateStates_LALR();
        }
    }
    generateStates_LR0() {
        this.generateFirstState_LR0();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                const symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR0(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LR() {
        this._firstTerminalsCache = {};
        this.generateFirstState_LR();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                let symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR1);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LALR() {
        this._baseItems = [];
        this._expectedExtensionDMap = {};
        this._closureForItemsCache = {};
        this._firstTerminalsCache = {};
        this.generateStates_LR0();
        this.deleteNotBaseItems();
        this.generateLinksExpected();
        this.expandExpected();
        this._states.forEach(state => this.closure_LR(state));
    }
    addReducing(syntaxTable, state, reduceOperationsMap) {
        state.eachItem(item => {
            if (item.symbolName() === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION) {
                if (item.rule.left === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL) {
                    this.pushInSyntaxTable(syntaxTable, state.index, _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL, { type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Success });
                }
                else {
                    for (const expectedSymbol of item.expectedSymbols) {
                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);
                    }
                }
            }
        });
    }
    addShift(syntaxTable, state, shiftOperationsMap) {
        const nextStates = state.nextStates;
        const nextSymbols = Object.keys(nextStates);
        for (let i = 0; i < nextSymbols.length; i++) {
            const nextState = nextStates[nextSymbols[i]];
            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);
        }
    }
    buildSyntaxTable(type) {
        this._states = [];
        this._syntaxTable = {};
        const stateList = this._states;
        const syntaxTable = this._syntaxTable;
        this.generateStates(type);
        const reduceOperationsMap = {};
        const shiftOperationsMap = {};
        stateList.forEach(state => {
            shiftOperationsMap[state.index] = {
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Shift,
                stateIndex: state.index
            };
        });
        const nonTerminals = this.nonTerminals();
        nonTerminals.forEach(nonTerminal => {
            this.rules(nonTerminal).forEach(rule => {
                reduceOperationsMap[rule.index] = {
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Reduce,
                    rule: rule
                };
            });
        });
        //Build syntax table
        stateList.forEach(state => {
            this.addReducing(syntaxTable, state, reduceOperationsMap);
            this.addShift(syntaxTable, state, shiftOperationsMap);
        });
    }
    statesToString(isBaseOnly = true) {
        if (!this._states) {
            return "";
        }
        let msg = "";
        for (let i = 0; i < this._states.length; i++) {
            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);
            msg += " ";
        }
        return msg;
    }
    static operationToString(operation) {
        let opVal = "";
        switch (operation.type) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Shift:
                opVal = "SHIFT to state " + operation.stateIndex.toString();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Reduce:
                opVal = "REDUCE by rule { " + AbstractParser.ruleToString(operation.rule) + " }";
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Success:
                opVal = "SUCCESS";
                break;
        }
        return opVal;
    }
    static ruleToString(rule) {
        let ruleVal;
        ruleVal = rule.left + " : " + rule.right.join(" ");
        return ruleVal;
    }
    convertGrammarSymbol(symbol) {
        if (!this.isTerminal(symbol)) {
            return symbol;
        }
        return this.lexerEngine.getTerminalValueByName(symbol);
    }
}
AbstractParser.$parserEngine = null;
AbstractParser.$parserParams = null;


/***/ }),

/***/ "tr/y":
/*!****************************************!*\
  !*** ./src/lib/parser/CachingLexer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CachingLexer": () => (/* binding */ CachingLexer)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");


class CachingLexer {
    constructor(tokens) {
        this.tokens = tokens || [];
        this.pos = 0;
    }
    /**
     * Dummy api
     */
    get document() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    get config() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    setTextDocument(textDocument) { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return this; }
    getNextLine() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    /** end */
    getPosition() {
        return this.pos;
    }
    setPosition(pos) {
        this.pos = pos;
    }
    getDiagnosticReport() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
        return null;
    }
    getNextToken() {
        return this.tokens[this.pos++] || CachingLexer.END_TOKEN;
    }
}
CachingLexer.END_TOKEN = {
    index: -1,
    name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_SYMBOL,
    value: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_SYMBOL,
    loc: null
};


/***/ }),

/***/ "gO55":
/*!********************************!*\
  !*** ./src/lib/parser/Item.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Item": () => (/* binding */ Item)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");


class Item {
    constructor(rule, pos, expectedSymbols) {
        this.rule = rule;
        this.pos = pos;
        this.index = 0;
        this.expectedSymbols = new Set();
        if (expectedSymbols) {
            expectedSymbols.forEach(symbol => this.addExpected(symbol));
        }
    }
    isEqual(item, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR0) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR0) {
            return (this.rule === item.rule && this.pos === item.pos);
        }
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR1) {
            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {
                return false;
            }
            for (const symbol of this.expectedSymbols) {
                if (!item.isExpected(symbol)) {
                    return false;
                }
            }
            return true;
        }
        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.
        return false;
    }
    isParentItem(item) {
        return (this.rule === item.rule && this.pos === item.pos + 1);
    }
    isChildItem(item) {
        return (this.rule === item.rule && this.pos === item.pos - 1);
    }
    symbolName() {
        const right = this.rule.right;
        if (this.pos === right.length) {
            return _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_POSITION;
        }
        return right[this.pos];
    }
    // lastSymbolName(): string {
    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;
    // }
    // // get next symbol name
    // nextSymbolName(): string {
    //     return this.rule.right[this.pos + 1] || END_POSITION;
    // }
    isExpected(symbol) {
        return this.expectedSymbols.has(symbol);
    }
    addExpected(symbol) {
        if (this.isExpected(symbol)) {
            return false;
        }
        this.expectedSymbols.add(symbol);
        return true;
    }
    toString(grammarSymbols = null) {
        const { left, right } = this.rule;
        let msg = `${left} -> `;
        msg += right
            .map(s => Item.decodeSymbol(s, grammarSymbols))
            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))
            .join(' ');
        if (this.pos === right.length) {
            msg += " . ";
        }
        if (this.expectedSymbols) {
            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));
            if (expectedTokens.length) {
                msg += ", " + expectedTokens.join(' ');
            }
        }
        return msg;
    }
    static decodeSymbol(s, grammarSymbols) {
        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);
    }
}


/***/ }),

/***/ "sesj":
/*!*********************************!*\
  !*** ./src/lib/parser/Lexer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lexer": () => (/* binding */ Lexer),
/* harmony export */   "LexerEngine": () => (/* binding */ LexerEngine)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");





var ELexerErrors;
(function (ELexerErrors) {
    ELexerErrors[ELexerErrors["UnknownToken"] = 2101] = "UnknownToken";
    ELexerErrors[ELexerErrors["InvalidToken"] = 2102] = "InvalidToken";
})(ELexerErrors || (ELexerErrors = {}));
;
class LexerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics {
    constructor() {
        super("Lexer Diagnostics", 'L');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        return desc.token.loc;
    }
    diagnosticMessages() {
        return {
            [ELexerErrors.UnknownToken]: "Unknown token: {token.value}.",
            [ELexerErrors.InvalidToken]: "Invalid token: {token.value}."
        };
    }
}
class LexerEngine {
    constructor() {
        this.keywords = {};
        this.punctuators = {};
        this.punctuatorsFirstSymbols = {};
    }
    addPunctuator(value, name = LexerEngine.getPunctuatorName(value)) {
        this.punctuators[value] = name;
        this.punctuatorsFirstSymbols[value[0]] = true;
        return name;
    }
    addKeyword(value, name) {
        this.keywords[value] = name;
        return name;
    }
    getTerminalValueByName(name) {
        let value = "";
        for (value in this.punctuators) {
            if (this.punctuators[value] === name) {
                return value;
            }
        }
        for (value in this.keywords) {
            if (this.keywords[value] === name) {
                return value;
            }
        }
        return name;
    }
    isLineTerminator(symbol) {
        return (symbol === "\n" || symbol === "\r" || symbol === "\u2028" || symbol === "\u2029");
    }
    isKeyword(value) {
        return !!(this.keywords[value]);
    }
    isPunctuator(value) {
        return !!(this.punctuators[value]);
    }
    isNumberStart(ch, ch1) {
        if ((ch >= "0") && (ch <= "9")) {
            return true;
        }
        if (ch === "." && (ch1 >= "0") && (ch1 <= "9")) {
            return true;
        }
        return false;
    }
    isCommentStart(ch, ch1) {
        if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
            return true;
        }
        return false;
    }
    isStringStart(ch) {
        if (ch === "\"" || ch === "'") {
            return true;
        }
        return false;
    }
    isPunctuatorStart(ch) {
        if (this.punctuatorsFirstSymbols[ch]) {
            return true;
        }
        return false;
    }
    isWhiteSpaceStart(ch) {
        if (ch === " " || ch === "\t") {
            return true;
        }
        return false;
    }
    isNewlineStart(ch) {
        if (ch === "\n" || ch === "\r") {
            return true;
        }
        return false;
    }
    isEscapeSequenceStart(ch) {
        return ch === '\\';
    }
    isIdentifierStart(ch) {
        if ((ch === "_") || (ch === "$") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
            return true;
        }
        return false;
    }
    static getPunctuatorName(value) {
        return "T_PUNCTUATOR_" + value.charCodeAt(0);
    }
}
class Lexer {
    constructor({ engine = new LexerEngine, knownTypes = new Set(), skipComments = true, allowLineTerminators = false, } = {}) {
        this.diagnostics = new LexerDiagnostics;
        this.knownTypes = knownTypes;
        this.engine = engine;
        this.config = { skipComments, allowLineTerminators };
    }
    getPosition() {
        return this.pos();
    }
    setPosition(pos) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.document.uri === pos.file);
        this.index = pos.offset;
        this.lineNumber = pos.line;
        this.columnNumber = pos.column;
    }
    setTextDocument(textDocument) {
        this.columnNumber = 0;
        this.lineNumber = 0;
        this.index = 0;
        this.document = textDocument;
        return this;
    }
    getDiagnosticReport() {
        return this.diagnostics.resolve();
    }
    getNextToken() {
        const token = this.scanToken();
        _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__.offset(token.loc, this.document.offset);
        return token;
    }
    getNextLine() {
        const token = this.scanThisLine();
        _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__.offset(token.loc, this.document.offset);
        return token;
    }
    scanToken() {
        const ch = this.currentChar();
        if (!ch) {
            const pos = this.pos();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.END_SYMBOL,
                value: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.END_SYMBOL,
                loc: {
                    start: pos,
                    end: { ...pos }
                }
            };
        }
        switch (this.identityTokenType()) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral:
                return this.scanNumber();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral:
                if (this.config.skipComments) {
                    this.scanComment();
                    return this.scanToken();
                }
                return this.scanComment();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral:
                return this.scanString();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_PunctuatorLiteral:
                return this.scanPunctuator();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral:
                return this.scanIdentifier();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_EscapeSequence:
                return this.scanEscapeSequence();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NewlineLiteral:
                if (!this.config.allowLineTerminators) {
                    this.scanLineTerminators();
                    return this.scanToken();
                }
                return this.scanLineTerminators();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_WhitespaceLiteral:
                this.scanWhiteSpace();
                return this.scanToken();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.K_MacroLiteral:
                return this.scanMacro();
            default:
                return this.scanInvalid();
        }
    }
    scanThisLine() {
        let start = this.pos();
        let value = '';
        let ch = this.currentChar();
        while (ch) {
            if (ch === '\\') {
                let chNext = this.readNextChar();
                if (chNext === '\r') {
                    chNext = this.readNextChar();
                }
                switch (chNext) {
                    case '\n':
                        ch = this.readNextChar();
                        this.lineNumber++;
                        this.columnNumber = 0;
                        value += '\\\n';
                        continue;
                    case 'n':
                        ch = '\n';
                        break;
                    case 't':
                        ch = '\t';
                        break;
                    default:
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported character sequence found');
                }
            }
            else if (ch === '\n') {
                break;
            }
            value += ch;
            ch = this.readNextChar();
        }
        return {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value,
            loc: { start, end: this.pos() }
        };
    }
    pos(n = 0) {
        return {
            file: this.document.uri,
            line: this.lineNumber,
            column: this.columnNumber + n,
            offset: this.index + n
        };
    }
    emitError(code, token) {
        this.diagnostics.error(code, { file: `${this.document.uri}`, token });
    }
    identityTokenType() {
        if (this.isIdentifierStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral;
        }
        if (this.isWhiteSpaceStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_WhitespaceLiteral;
        }
        if (this.isNewlineStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NewlineLiteral;
        }
        if (this.isEscapeSequenceStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_EscapeSequence;
        }
        if (this.isStringStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral;
        }
        if (this.isCommentStart()) {
            // TODO: return exact type (separate multiline/singleline comment parsings)
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral;
        }
        if (this.isNumberStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral;
        }
        if (this.isPunctuatorStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_PunctuatorLiteral;
        }
        if (this.isMacroStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.K_MacroLiteral;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_Unknown;
    }
    isNumberStart() {
        return this.engine.isNumberStart(this.currentChar(), this.nextChar());
    }
    isCommentStart() {
        return this.engine.isCommentStart(this.currentChar(), this.nextChar());
    }
    isStringStart() {
        return this.engine.isStringStart(this.currentChar());
    }
    isPunctuatorStart() {
        return this.engine.isPunctuatorStart(this.currentChar());
    }
    isWhiteSpaceStart() {
        return this.engine.isWhiteSpaceStart(this.currentChar());
    }
    isNewlineStart() {
        return this.engine.isNewlineStart(this.currentChar());
    }
    isEscapeSequenceStart() {
        return this.engine.isEscapeSequenceStart(this.currentChar());
    }
    isMacroStart() {
        return this.currentChar() === '#';
    }
    isIdentifierStart() {
        return this.engine.isIdentifierStart(this.currentChar());
    }
    nextChar() {
        return this.document.source[this.index + 1];
    }
    currentChar() {
        return this.document.source[this.index];
    }
    readNextChar() {
        this.index++;
        this.columnNumber++;
        return this.document.source[this.index];
    }
    scanEscapeSequence() {
        let ch = this.readNextChar();
        if (ch === '\r') {
            ch = this.readNextChar();
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(ch === '\n', 'unsupported escape sequence found');
        this.lineNumber++;
        this.columnNumber = 0;
        this.readNextChar();
        return this.scanToken();
    }
    scanString() {
        let chFirst = this.currentChar();
        let value = chFirst;
        let ch = "";
        let chPrevious = chFirst;
        let isGoodFinish = false;
        let start = this.pos();
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                break;
            }
            value += ch;
            if (ch === chFirst && chPrevious !== "\\") {
                isGoodFinish = true;
                this.readNextChar();
                break;
            }
            chPrevious = ch;
        }
        if (isGoodFinish) {
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_STRING,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanInvalid() {
        const start = this.pos();
        let value = '';
        while (this.identityTokenType() === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_Unknown && this.index < this.document.source.length) {
            value += this.currentChar();
            this.readNextChar();
        }
        const token = {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value,
            loc: { start, end: this.pos() }
        };
        this.emitError(ELexerErrors.UnknownToken, token);
        return token;
    }
    scanPunctuator() {
        let value = this.currentChar();
        let start = this.pos();
        let ch;
        while (true) {
            ch = this.readNextChar();
            if (ch) {
                value += ch;
                if (!this.engine.isPunctuator(value)) {
                    value = value.slice(0, value.length - 1);
                    break;
                }
            }
            else {
                break;
            }
        }
        return {
            index: this.index,
            name: this.engine.punctuators[value],
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanNumber() {
        let ch = this.currentChar();
        let value = "";
        let isFloat = false;
        let isHex = false;
        let isL = false;
        let chPrevious = ch;
        let isGoodFinish = false;
        let isE = false; // exponential
        let isU = false; // unsigned
        let start = this.pos();
        if (ch === ".") {
            value += 0;
            isFloat = true;
        }
        value += ch;
        while (true) {
            ch = this.readNextChar();
            if (ch === ".") {
                if (isFloat || isU || isL || isHex) {
                    break;
                }
                isFloat = true;
            }
            else if (ch === "e") {
                if (isE || isU || isL) { // "0x100e2" is valid
                    break;
                }
                isE = true;
            }
            else if (ch === "u" || ch === "U") {
                if (isFloat || isU) { // "0x02u" or "0x100e2u" are valid
                    break;
                }
                isU = true;
            }
            else if (ch === "l" || ch === "L") {
                if (isFloat || isL) {
                    break;
                }
                isL = true;
            }
            else if (ch === "x") {
                if (isU || isL || isE || isFloat) {
                    break;
                }
                isHex = true;
            }
            else if (((ch === "+" || ch === "-") && chPrevious === "e")) {
                // nothing todo, valid case
            }
            else if (ch === "f" && (isFloat || isE)) {
                isFloat = true;
                ch = this.readNextChar();
                // redundant check?
                if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                    break;
                }
                isGoodFinish = true;
                break;
            }
            // break on any unused alphabetic character
            else if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                if (!isHex) {
                    break;
                }
            }
            // Handle the case when a character is read not a number (end of numeric seq.)
            else if (!((ch >= "0") && (ch <= "9")) || !ch || isU || isL) {
                // check that the exponent completely read
                if ((isE && chPrevious !== "+" && chPrevious !== "-" && chPrevious !== "e") || !isE) {
                    isGoodFinish = true;
                }
                break;
            }
            value += ch;
            chPrevious = ch;
        }
        if (isGoodFinish) {
            let name = isFloat ? _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT : _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_UINT;
            return {
                index: this.index,
                name,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanMacro() {
        // TODO: add option config.allowMacro 
        const start = this.pos();
        const chNext = this.nextChar();
        if ((chNext >= "a" && chNext <= "z") || (chNext >= "A" && chNext <= "Z")) {
            this.readNextChar();
            const id = this.scanIdentifier();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_MACRO,
                value: `#${id.value}`,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else if (chNext === '#') {
            this.readNextChar();
            this.readNextChar();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_MACRO_CONCAT,
                value: '##',
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported macro found: ${this.document.source.substr(this.index, 20)}...`);
        this.readNextChar();
        return {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value: '#',
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanIdentifier() {
        let ch = this.currentChar();
        let value = ch;
        let start = this.pos();
        let isGoodFinish = false;
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                isGoodFinish = true;
                break;
            }
            if (!((ch === "_") || (ch === "$") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || (ch >= "0" && ch <= "9"))) {
                isGoodFinish = true;
                break;
            }
            value += ch;
        }
        if (isGoodFinish) {
            if (this.engine.isKeyword(value)) {
                return {
                    index: this.index,
                    name: this.engine.keywords[value],
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                let name = this.knownTypes.has(value) ? _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_TYPE_ID : _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_NON_TYPE_ID;
                return {
                    index: this.index,
                    name,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanLineTerminators() {
        let ch = this.currentChar();
        let value = '';
        let start = this.pos();
        while (true) {
            if (!ch) {
                break;
            }
            if (this.engine.isLineTerminator(ch)) {
                value += ch;
                if (ch === "\r" && this.nextChar() === "\n") {
                    this.lineNumber--;
                }
                this.lineNumber++;
                ch = this.readNextChar();
                this.columnNumber = 0;
                continue;
            }
            break;
        }
        let name = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_LINE_TERMINATOR;
        return {
            index: this.index,
            name,
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanWhiteSpace() {
        let ch = this.currentChar();
        while (true) {
            if (!ch) {
                break;
            }
            else if (ch === "\t") {
                // possible way to convert tab to multiple spaces
                this.columnNumber += 0;
            }
            else if (ch !== " ") {
                break;
            }
            ch = this.readNextChar();
        }
        return true;
    }
    scanComment() {
        let value = this.currentChar();
        let ch = this.readNextChar();
        let start = this.pos();
        value += ch;
        if (ch === "/") {
            //Line Comment
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.readNextChar();
                    this.columnNumber = 0;
                    break;
                }
                value += ch;
            }
            return {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            //Multiline Comment
            let chPrevious = ch;
            let isGoodFinish = false;
            let start = this.pos();
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                value += ch;
                if (ch === "/" && chPrevious === "*") {
                    isGoodFinish = true;
                    this.readNextChar();
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.columnNumber = -1;
                }
                chPrevious = ch;
            }
            if (isGoodFinish) {
                return {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                if (!ch) {
                    ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
                }
                value += ch;
                const token = {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
                this.emitError(ELexerErrors.InvalidToken, token);
                return Lexer.makeUnknownToken(token);
            }
        }
    }
    /** @deprecated */
    static makeUnknownToken(token) {
        return {
            ...token,
            type: undefined,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            loc: {
                start: { ...token.loc.start },
                end: { ...token.loc.end }
            }
        };
    }
}


/***/ }),

/***/ "wlKN":
/*!**********************************!*\
  !*** ./src/lib/parser/Macros.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Macros": () => (/* binding */ Macros)
/* harmony export */ });
class Macros {
    constructor() {
        this.stack = [{ root: null, macros: {} }];
    }
    get depth() {
        return this.stack.length;
    }
    get root() {
        return this.stack[this.depth - 1].root;
    }
    push(source) {
        this.stack.push({ root: source, macros: {} });
    }
    pop() {
        this.stack.pop();
    }
    set(macro) {
        this.stack[this.depth - 1].macros[macro.name] = macro;
    }
    unset(name) {
        delete this.stack[this.depth - 1].macros[name];
    }
    get(name) {
        let i = this.depth - 1;
        while (true) {
            const { macros, root } = this.stack[i];
            // avoidance of recursive substitution
            if (root?.name === name && !root.bFunction) {
                return null;
            }
            const macro = macros[name];
            if (macro) {
                return macro;
            }
            if (i == 0)
                break;
            i = 0;
        }
        ;
        return null;
    }
    has(name) {
        return this.get(name) !== null;
    }
    forEach(cb) {
        let overrides = new Set;
        for (let i = this.depth - 1; i >= 0; --i) {
            const macros = this.stack[i].macros;
            for (const macro of Object.values(macros)) {
                if (!overrides.has(macro.name)) {
                    overrides.add(macro.name);
                    cb(macro);
                }
            }
        }
    }
    *[Symbol.iterator]() {
        let overrides = new Set;
        for (let i = this.depth - 1; i >= 0; --i) {
            const macros = this.stack[i].macros;
            for (const macro of Object.values(macros)) {
                if (!overrides.has(macro.name)) {
                    overrides.add(macro.name);
                    yield macro;
                }
            }
        }
    }
}


/***/ }),

/***/ "Eumm":
/*!*************************************!*\
  !*** ./src/lib/parser/ParseTree.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParseTree": () => (/* binding */ ParseTree)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "5ZRz");



class ParseTree {
    constructor(optimized, root = null) {
        this.root = root;
        this.nodes = [];
        this.optimized = optimized;
        this.nodesCountStack = [];
    }
    get lastNode() {
        return this.nodes[this.nodes.length - 1];
    }
    finishTree() {
        this.root = this.nodes.pop() || null;
    }
    addToken({ name, value, loc }) {
        const children = null;
        const parent = null;
        this.addNode({ name, value, loc, children, parent });
    }
    reduceByRule(rule, eCreate = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Default) {
        let iReduceCount = 0;
        let nodesCountStack = this.nodesCountStack;
        let ruleLength = rule.right.length;
        let nodes = this.nodes;
        let optimize = this.optimized ? 1 : 0;
        while (ruleLength) {
            iReduceCount += nodesCountStack.pop();
            ruleLength--;
        }
        if ((eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Skip && iReduceCount > optimize) || iReduceCount === 0) {
            nodes.length -= iReduceCount;
            nodesCountStack.push(0);
        }
        else if ((eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Default && iReduceCount > optimize) ||
            (eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Necessary)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(iReduceCount > 0);
            let temp = nodes.pop();
            iReduceCount--;
            const name = rule.left;
            // TODO: use correct location in case of include macro. 
            const loc = { ...temp.loc };
            const node = { name, children: null, parent: null, value: '', loc };
            this.addLink(node, temp);
            while (iReduceCount) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(nodes.length > 0);
                this.addLink(node, nodes.pop());
                iReduceCount--;
            }
            nodes.push(node);
            nodesCountStack.push(1);
        }
        else {
            nodesCountStack.push(iReduceCount);
        }
    }
    addNode(node) {
        this.nodes.push(node);
        this.nodesCountStack.push(1);
    }
    $pop(loc = null) {
        let count = this.nodesCountStack.pop();
        while (count) {
            let node = this.nodes.pop();
            if (loc) {
                (0,_util__WEBPACK_IMPORTED_MODULE_2__.extendRange)(loc, node.loc);
            }
            count--;
        }
    }
    addLink(parent, child) {
        parent.children = parent.children || [];
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.extendRange)(parent.loc, child.loc);
        parent.children.push(child);
        child.parent = parent;
    }
    /** @deprecated */
    clone() {
        return new ParseTree(this.optimized, this.cloneNode(this.root));
    }
    /** @deprecated */
    // FIXME: location should be clonned too
    cloneNode({ name, value, children }) {
        const clone = { name, value, children: null, parent: null };
        if (children) {
            children.forEach(child => this.addLink(clone, this.cloneNode(child)));
        }
        return clone;
    }
    /** @deprecated */
    toString() {
        if (this.root) {
            return this.toStringNode(this.root);
        }
        return '';
    }
    /** @deprecated */
    toStringNode(node, padding = "") {
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "name : \"" + node.name + "\"" + ",\n";
            res += padding + "value : \"" + node.value + "\"" + "\n";
        }
        else {
            res += padding + "name : \"" + node.name + "\"" + "\n";
            res += padding + "children : [";
            let children = node.children;
            if (children) {
                res += "\n";
                padding += defaultPadding;
                for (let i = children.length - 1; i >= 0; i--) {
                    res += this.toStringNode(children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
    /** @deprecated */
    toHTMLString(node, padding = "") {
        node = node || this.root;
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "<b style=\"color: #458383;\">name</b>: \"" + node.name + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">value</b>: \"" + node.value + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
        }
        else {
            let i;
            res += padding + "<i style=\"color: #8A2BE2;\">name</i>: \"" + node.name + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
            res += padding + "<i style=\"color: #8A2BE2;\">children</i>: [";
            if (node.children) {
                res += "\n";
                padding += defaultPadding;
                for (i = node.children.length - 1; i >= 0; i--) {
                    res += this.toHTMLString(node.children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
}


/***/ }),

/***/ "nYIV":
/*!****************************************!*\
  !*** ./src/lib/parser/Preprocessor.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPreprocessorErrors": () => (/* binding */ EPreprocessorErrors),
/* harmony export */   "EPreprocessorWarnings": () => (/* binding */ EPreprocessorWarnings),
/* harmony export */   "Preprocessor": () => (/* binding */ Preprocessor),
/* harmony export */   "PreprocessorDiagnostics": () => (/* binding */ PreprocessorDiagnostics),
/* harmony export */   "createPPDocument": () => (/* binding */ createPPDocument)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/SLParser */ "/oCY");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_parser_CachingLexer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/parser/CachingLexer */ "tr/y");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_Macros__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/parser/Macros */ "wlKN");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");













let DEBUG_MACRO = false;
var EMacroState;
(function (EMacroState) {
    EMacroState[EMacroState["k_AllowElse"] = 0] = "k_AllowElse";
    EMacroState[EMacroState["k_ForbidElse"] = 1] = "k_ForbidElse";
})(EMacroState || (EMacroState = {}));
;
var EPreprocessorErrors;
(function (EPreprocessorErrors) {
    EPreprocessorErrors[EPreprocessorErrors["SyntaxUnknownError"] = 7051] = "SyntaxUnknownError";
    EPreprocessorErrors[EPreprocessorErrors["GeneralCouldNotReadFile"] = 7200] = "GeneralCouldNotReadFile";
    EPreprocessorErrors[EPreprocessorErrors["MacroUnknownError"] = 7201] = "MacroUnknownError";
})(EPreprocessorErrors || (EPreprocessorErrors = {}));
;
var EPreprocessorWarnings;
(function (EPreprocessorWarnings) {
    EPreprocessorWarnings[EPreprocessorWarnings["MacroUnknownWarning"] = 3000] = "MacroUnknownWarning";
})(EPreprocessorWarnings || (EPreprocessorWarnings = {}));
class PreprocessorDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics {
    constructor() {
        super("Preprocessor diagnostics", 'M');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        if (category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            switch (code) {
                case EPreprocessorWarnings.MacroUnknownWarning:
                    return desc.loc;
            }
        }
        //
        // errors
        //
        switch (code) {
            case EPreprocessorErrors.SyntaxUnknownError:
                return desc.token.loc;
            case EPreprocessorErrors.GeneralCouldNotReadFile:
                return desc.loc;
            case EPreprocessorErrors.MacroUnknownError:
                return desc.loc;
        }
        return null;
    }
    diagnosticMessages() {
        return {
            [EPreprocessorErrors.SyntaxUnknownError]: "Syntax error during parsing. Token: '{token.value}'\n" +
                "Line: {token.loc.start.line}. Column: {token.loc.start.column}.",
            [EPreprocessorErrors.GeneralCouldNotReadFile]: "Could not read file '{target}'.",
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            return `${EPreprocessorWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${EPreprocessorErrors[code]}: ${JSON.stringify(data)}`;
    }
}
// as macro token
/** @deprecated */
function createMacroToken(value, loc) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(value), value);
    return { index: -1, type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__.ETokenType.k_Unknown, name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO, value, loc };
}
function asMacroFunc(fn) {
    return {
        op: (...args) => {
            const value = String(fn(...args));
            const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(...args.map(arg => arg.loc));
            // TODO: use typed token like: T_BOOL, T_UINT etc.
            return createMacroToken(value, loc);
        },
        length: fn.length
    };
}
function tokenToNative(token, fallback = () => NaN) {
    const value = token.value;
    if (String(value) === 'true') {
        return 1;
    }
    if (String(value) === 'false') {
        return 0;
    }
    // TODO: replace this check
    if (String(Number(value)) === String(value)) {
        return Number(value);
    }
    return fallback(token);
}
class MacroState {
    constructor() {
        this.states = [];
    }
    is(state) {
        return this.states[this.states.length - 1] === state;
    }
    isEmpty() {
        return this.states.length === 0;
    }
    push(state) {
        this.states.push(state);
    }
    pop() {
        return this.states.pop();
    }
    replace(state) {
        this.pop();
        this.push(state);
    }
}
var EPPDocumentFlags;
(function (EPPDocumentFlags) {
    EPPDocumentFlags[EPPDocumentFlags["k_None"] = 0] = "k_None";
    EPPDocumentFlags[EPPDocumentFlags["k_Macro"] = 1] = "k_Macro";
    EPPDocumentFlags[EPPDocumentFlags["k_Include"] = 2] = "k_Include";
})(EPPDocumentFlags || (EPPDocumentFlags = {}));
class Preprocessor {
    constructor(lexerEngine, { knownTypes = new Set(), macros = new _lib_parser_Macros__WEBPACK_IMPORTED_MODULE_10__.Macros, diag = new PreprocessorDiagnostics, skipComments = true, includeResolver = null, defines = null } = {}) {
        this.macros = macros;
        if (defines) {
            // set as boolean macro
            defines
                .forEach(({ name }) => this.macros.set({ name, tokens: [], bFunction: false, params: null, bRegionExpr: false }));
        }
        this.macroState = new MacroState;
        this.includeMap = new Map;
        this.unreachableCodeList = [];
        this.unresolvedMacros = [];
        this.knownTypes = knownTypes;
        this.lexerEngine = lexerEngine;
        this.diagnostics = diag;
        this.includeResolver = includeResolver;
        this.lexerReport = null;
        this.lexerOptions = { skipComments };
        // TODO: add initital document to includeList !!!
        this.stack = [];
        this.includes = [];
    }
    get lexer() {
        return this.stack[this.stack.length - 1].lexer;
    }
    get tokens() {
        return this.stack[this.stack.length - 1].tokens;
    }
    get uri() {
        return this.document.uri;
    }
    /** Current location stack (each location contains ".source" property inside.) */
    // get location(): IRange {
    //     return this.stack[this.stack.length - 1].loc;
    // }
    /** Top location of the macro if presented or null otherwise. */
    macroLocation() {
        // return first macro location in the current document
        const latestInclude = this.includes[this.includes.length - 1];
        if (latestInclude < this.stack.length - 1) {
            return this.stack[latestInclude + 1].loc;
        }
        // return null (we are alrady in the current document)
        return null;
    }
    currentMacro() {
        return this.macros.root;
    }
    getDiagnosticReport() {
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics.mergeReports([this.lexerReport, this.diagnostics.resolve()]);
    }
    readLine() {
        return this.lexer.getNextLine();
    }
    setTextDocument(textDocument) {
        this.document = textDocument;
        this.pushDocument(this.documentToLexer(textDocument), null, EPPDocumentFlags.k_Include);
        return this;
    }
    pushDocument(lexer, loc, flags, macro = null) {
        const tokens = [];
        /// link location into chain
        // if (loc) {
        //     loc.source = this.stack[this.stack.length - 1].loc;
        // }
        if (flags & EPPDocumentFlags.k_Macro) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(macro));
            this.macros.push(macro);
        }
        if (flags & EPPDocumentFlags.k_Include) {
            this.includes.push(this.stack.length);
            // assert(!this.includeMap.has(`${textDocument.uri}`));
            this.includeMap.set(`${lexer.document.uri}`, loc);
        }
        this.stack.push({ lexer, tokens, flags, loc });
    }
    pop() {
        const { flags, lexer } = this.stack.pop();
        // FIXME: do not Lexer type
        const diag = lexer.diagnostics;
        if (diag && !diag.isEmpty()) {
            this.lexerReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics.mergeReports([this.lexerReport, lexer.getDiagnosticReport()]);
        }
        if (flags & EPPDocumentFlags.k_Macro) {
            this.macros.pop();
        }
        if (flags & EPPDocumentFlags.k_Include) {
            this.includes.pop();
        }
    }
    pushToken(...tokens) {
        this.tokens.push(...tokens);
    }
    popToken() {
        return this.tokens.shift() || null;
    }
    async readToken(allowMacro = true, allowStateChanging = true) {
        const token = this.popToken() || this.lexer.getNextToken();
        switch (token.name) {
            case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO:
                if (allowMacro) {
                    return this.readMacro(token);
                }
                break;
            case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL:
                if (allowStateChanging) {
                    if (this.stack.length > 1) {
                        this.pop();
                        return this.readToken(allowMacro);
                    }
                    if (!this.macroState.isEmpty()) {
                        // TODO: highlight open tag too.
                        this.emitMacroError(`'endif' not found :/`, token.loc);
                    }
                }
                break;
            default:
                if (allowMacro) {
                    return this.examMacro(token);
                }
        }
        return token;
    }
    async readMacro(token) {
        switch (token.value) {
            case '#define': return this.processDefineMacro(token);
            case '#ifdef': return this.processIfdefMacro(token);
            case '#ifndef': return this.processIfndefMacro(token);
            case '#endif': return this.processEndifMacro(token);
            case '#else': return this.processElseMacro(token);
            case '#elif': return this.processElifMacro(token);
            case '#if': return this.processIfMacro(token);
            case '#error': return this.processErrorMacro(token);
            case '#include': return this.processIncludeMacro(token);
            case '#undef': return this.processUndefMacro(token);
            case '#pragma': {
                this.readLine();
                return this.readToken();
            }
        }
        this.emitMacroWarning(`unsupported macro type found: ${token.value}`, token.loc);
        return this.readToken();
    }
    async processUndefMacro(token) {
        const name = await this.readToken(false);
        const text = this.readLine();
        if (name.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
            // TODO: emit error
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(name.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID);
            return this.readToken();
        }
        if (!this.macros.has(name.value)) {
            this.emitMacroWarning(`target macro not found: ${name.value}`, name.loc);
        }
        else {
            this.macros.unset(name.value);
        }
        return this.readToken();
    }
    async processDefineMacro(token) {
        const name = await this.readToken(false);
        const text = this.readLine();
        if (name.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
            // TODO: emit error
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(name.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID);
            return this.readToken();
        }
        if (this.macros.has(name.value)) {
            this.emitMacroWarning(`macro redefinition found: ${name.value}`, name.loc);
        }
        const macro = await this.processMacro(name, text);
        if (macro) {
            const unresolvedMacro = this.unresolvedMacros.find(macro => macro.name === name.value);
            if (unresolvedMacro) {
                macro.bRegionExpr = unresolvedMacro.bRegionExpr;
                // TODO: remove this hack
                this.unresolvedMacros = this.unresolvedMacros.filter(macro => macro.name !== name.value);
            }
            this.macros.set(macro);
        }
        return this.readToken();
    }
    async processMacro(name, lineToken) {
        let bFunction = false;
        let bRegionExpr = false;
        let params = null;
        let tokens = [];
        if (!/^\s*$/.test(lineToken.value)) {
            //
            // process macro params
            //
            const lexer = await this.tokenToLexer(lineToken);
            let token = lexer.getNextToken();
            const bOpenBracket = token.value === '(';
            const bSameLine = token.loc.start.line === name.loc.end.line;
            const bNoSpace = token.loc.start.column === name.loc.end.column;
            // A bit tricky way to separate macro like:
            // >  #define NAME(A, B)
            // from the macro:
            // >  #define NAME (A, B)
            // and macro like:
            // >  #define NAME\
            // >              (A, B)
            // note: only macro like 'NAME(a, b)' is a valid function-like macro (no spaces allowed)
            if (bOpenBracket && bSameLine && bNoSpace) {
                params = [];
                bFunction = true;
                let bExpectComma = false;
                token = lexer.getNextToken();
                while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL && token.value !== ')') {
                    if (bExpectComma) {
                        if (token.value !== ',') {
                            this.emitMacroError(`invalid macro, comma expected`, token.loc);
                            return null;
                        }
                    }
                    else {
                        if (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
                            this.emitMacroError('invalid token found. only identifiers allowed as param names', token.loc);
                            return null;
                        }
                        params.push(token.value);
                    }
                    bExpectComma = !bExpectComma;
                    token = lexer.getNextToken();
                }
                if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
                    this.emitMacroError(`comma mismatch`, token.loc);
                    return null;
                }
                token = lexer.getNextToken();
            }
            while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
                tokens.push(token);
                token = lexer.getNextToken();
            }
        }
        tokens.forEach(t => { t.synthetic = true; });
        return { name: name.value, tokens, bFunction, params, bRegionExpr };
    }
    async processIfdefMacro(token) {
        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));
        if (exprValue) {
            this.macroState.push(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        this.macroState.push(EMacroState.k_AllowElse);
        return this.skipUnreachableCode(token);
    }
    async processIfndefMacro(token) {
        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));
        if (exprValue) {
            this.macroState.push(EMacroState.k_AllowElse);
            return this.skipUnreachableCode(token);
        }
        this.macroState.push(EMacroState.k_ForbidElse);
        return this.readToken();
    }
    async processIfMacro(token) {
        if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {
            this.macroState.push(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        this.macroState.push(EMacroState.k_AllowElse);
        return this.skipUnreachableCode(token);
    }
    async processElifMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        if (this.macroState.is(EMacroState.k_AllowElse)) {
            if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {
                this.macroState.replace(EMacroState.k_ForbidElse);
                return this.readToken();
            }
        }
        return this.skipUnreachableCode(token);
    }
    async processElseMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        if (this.macroState.is(EMacroState.k_AllowElse)) {
            this.macroState.replace(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        return this.skipUnreachableCode(token);
    }
    async processEndifMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        this.macroState.pop();
        return this.readToken();
    }
    resolveDefMacro(lexer) {
        const macros = this.macros;
        const asRaw = (token) => tokenToNative(token, ({ value }) => {
            const macro = macros.get(value);
            if (macro) {
                // mark macro as a part of ifdef/else expression
                macro.bRegionExpr = true;
                return 1;
            }
            this.addUnresolvedMacro(value);
            return 0;
        });
        const asFn = asMacroFunc;
        const asValue = asFn(asRaw);
        const opPriors = {
            '(': 1, ')': 1,
            '&&': 2,
            '||': 3,
            '!': 8
        };
        const opLogic = {
            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),
            '||': asFn((a, b) => asRaw(a) || asRaw(b)),
            '!': asFn((a) => !asRaw(a)),
            'asValue': asValue
        };
        const exprValue = this.evaluateMacroExpr(lexer, opPriors, opLogic, {});
        return exprValue;
    }
    resolveMacroInner(lexer) {
        const macros = this.macros;
        const asRaw = (token) => this.resolveMacro(token);
        const asFn = asMacroFunc;
        const asValue = asFn(asRaw);
        const opPriors = {
            '(': 1, ')': 1,
            '||': 2,
            '&&': 3,
            '<': 4, '>': 4, '<=': 4, '>=': 4,
            '==': 5, '!=': 5,
            '+': 6, '-': 6,
            '*': 7, '/': 7,
            '!': 8,
            'defined': 9
        };
        // TODO: add conditional operator
        // TODO: add unary '+' and unary '-' operators
        const opLogic = {
            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),
            '||': asFn((a, b) => asRaw(a) || asRaw(b)),
            '!': asFn((a) => !asRaw(a)),
            '+': asFn((a, b) => asRaw(a) + asRaw(b)),
            '-': asFn((a, b) => asRaw(a) - asRaw(b)),
            '*': asFn((a, b) => asRaw(a) * asRaw(b)),
            '/': asFn((a, b) => asRaw(a) / asRaw(b)),
            '<': asFn((a, b) => asRaw(a) < asRaw(b)),
            '>': asFn((a, b) => asRaw(a) > asRaw(b)),
            '<=': asFn((a, b) => asRaw(a) <= asRaw(b)),
            '>=': asFn((a, b) => asRaw(a) >= asRaw(b)),
            '==': asFn((a, b) => asRaw(a) === asRaw(b)),
            '!=': asFn((a, b) => asRaw(a) !== asRaw(b)),
            'asValue': asValue
        };
        //
        // Wrap all macro functions to native 
        //
        const macroFuncs = {
            'defined': asFn((a) => {
                const macro = macros.get(a.value);
                if (macro) {
                    macro.bRegionExpr = true;
                    return 1;
                }
                this.addUnresolvedMacro(a.value);
                return 0;
            }),
        };
        // TODO: move list construction to preprocess
        macros.forEach((macro) => {
            if (macro.bFunction) {
                opPriors[macro.name] = 10;
                macroFuncs[macro.name] = {
                    op: (...args) => {
                        macros.push(macro);
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(macro.params.length === args.length);
                        const params = macro.params;
                        for (let i = 0; i < params.length; ++i) {
                            if (DEBUG_MACRO) {
                                console.log(`${macro.name}.${params[i]} => ${args[i].value}`, (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(args[i].value));
                            }
                            macros.set({
                                name: params[i],
                                tokens: [args[i]],
                                bFunction: false,
                                params: null,
                                bRegionExpr: false
                            });
                        }
                        const value = String(this.resolveMacroInner(this.macroToLexer(macro)));
                        macros.pop();
                        // TODO: use min/max instead?
                        const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(...args.map(arg => arg.loc));
                        return { index: -1, type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__.ETokenType.k_NumericLiteral, name: 'T_UINT', value, loc };
                    },
                    length: macro.params.length
                };
            }
        });
        return this.evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs);
    }
    resolveMacro(textToken) {
        return tokenToNative(textToken, (token) => {
            const macro = this.macros.get(token.value);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(macro) && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(macro.tokens)) {
                const exprValue = this.resolveMacroInner(this.macroToLexer(macro));
                if (DEBUG_MACRO) {
                    console.log(`macro '${token.value}:${macro.tokens.map(tk => tk.value).join(' ')}' resolved to '${exprValue}''`);
                }
                return exprValue;
            }
            this.emitMacroWarning(`cannot resolve macro '${token.value}'`, textToken.loc);
            this.addUnresolvedMacro(token.value);
            return NaN;
        });
    }
    addUnresolvedMacro(name) {
        if (this.unresolvedMacros.find(macro => macro.name === name)) {
            return;
        }
        this.unresolvedMacros.push({
            bFunction: false,
            name,
            params: null,
            tokens: null,
            bRegionExpr: true
        });
    }
    evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs = {}) {
        const values = [];
        const opStack = [];
        let token = lexer.getNextToken();
        //
        // Transform input sequence to reverse Polish notation
        //
        exit: while (true) {
            switch (token.name) {
                case 'T_TYPE_ID':
                case 'T_NON_TYPE_ID':
                    // process functional macros as operators
                    if (macroFuncs[token.value]) {
                        opStack.push(token);
                        break;
                    }
                    values.push(token);
                    break;
                case 'T_UINT':
                case 'T_KW_TRUE':
                case 'T_KW_FALSE':
                    values.push(token);
                    break;
                case 'T_PUNCTUATOR_40': // '('
                    opStack.push(token);
                    break;
                case 'T_PUNCTUATOR_41': // ')'
                    {
                        let op = opStack.pop();
                        while (op.value !== '(') {
                            values.push(op);
                            op = opStack.pop();
                        }
                    }
                    break;
                case 'T_PUNCTUATOR_44': // ','
                    // ignoring of all commas
                    break;
                case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL:
                    break exit;
                default:
                    if (opPriors[token.value]) {
                        if (opStack.length) {
                            const thisOp = token.value;
                            const prevOp = opStack[opStack.length - 1].value;
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(opPriors[prevOp] && opPriors[thisOp], prevOp, thisOp);
                            if (opPriors[prevOp] >= opPriors[thisOp]) {
                                values.push(opStack.pop());
                            }
                        }
                        opStack.push(token);
                        break;
                    }
                    this.emitMacroError(`unsupported macro operator found: '${token.value}'`, token.loc);
                    return NaN;
            }
            token = lexer.getNextToken();
        }
        while (opStack.length) {
            values.push(opStack.pop());
        }
        //
        // Evaluate reverse Polish notation
        //
        // FIXME: remove debug log
        const $input = `[${values.map(token => token.value).join(', ')}]`;
        const isOp = (op) => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(opLogic[op.value]);
        const asOp = (op) => opLogic[op.value];
        const isFn = (op) => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(macroFuncs[op.value]);
        const asFn = (op) => macroFuncs[op.value];
        const stack = [];
        values.forEach(token => {
            if (isOp(token)) {
                const { op, length } = asOp(token);
                stack.push(op(...stack.splice(-(length))));
                return;
            }
            if (isFn(token)) {
                const { op, length } = asFn(token);
                stack.push(op(...stack.splice(-(length))));
                return;
            }
            stack.push(token);
        });
        if (values.length === 1) {
            stack[0] = opLogic.asValue.op(stack[0]);
        }
        if (DEBUG_MACRO)
            console.log(`${$input} => {${stack[0].value}}`);
        // assert(asMacroNative(stack[0]) !== NaN, stack);
        return tokenToNative(stack[0]);
    }
    async processErrorMacro(token) {
        const text = this.readLine();
        const msg = text.value.trim();
        this.emitMacroError(`erroneous macro reached: "${msg}"`, _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(token.loc, text.loc));
        return this.readToken();
    }
    async skipUnreachableCode(startToken) {
        let token = await this.readToken(false);
        let nesting = 0;
        while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO) {
                switch (token.value) {
                    case '#if':
                    case '#ifdef':
                    case '#ifndef':
                        nesting++;
                        this.readLine();
                        break;
                    case '#elif':
                    case '#else':
                        if (nesting !== 0) {
                            this.readLine();
                            break;
                        }
                    /* fall throught */
                    case '#endif':
                        if (nesting > 0) {
                            nesting--;
                            this.readLine();
                            break;
                        }
                        this.addUnreachableCode(startToken, token);
                        return this.readMacro(token);
                    case '#error':
                        this.readLine();
                }
            }
            token = await this.readToken(false);
        }
        // TODO: highlight open tag
        this.emitMacroError(`'endif' non found :/`, token.loc);
        return token;
    }
    addUnreachableCode(start, end) {
        const block = { start: { ...start.loc.end, column: 0 }, end: { ...end.loc.end, column: 0 } };
        block.start.line++;
        if (block.end.line - block.start.line > 0) {
            if (DEBUG_MACRO) {
                console.log(`unreachable code: [${block.start.line}, ${block.end.line})`);
            }
            this.unreachableCodeList.push(block);
        }
    }
    async processIncludeMacro(token) {
        const file = this.readLine();
        //cuttin qoutes
        const includeURL = file.value.trim().slice(1, -1);
        const resolvedURI = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.resolve(includeURL, `${token.loc.start.file}`);
        const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(token.loc, file.loc);
        if (this.includeMap.has(resolvedURI)) {
            if (DEBUG_MACRO) {
                const chain = this.includes.map(i => this.stack[i].lexer.document.uri.toString()).map(name => `\t> ${name}`).join('\n');
                console.warn(`'${resolvedURI}' file has already been included previously at "${this.includeMap.get(resolvedURI).start.file}":\n${chain}`);
            }
            // TODO: prevent recursion!
            // // TODO: emit warning
            // return this.readToken();
        }
        const textDocumentRaw = await this.includeResolver(resolvedURI);
        if (!textDocumentRaw) {
            this.emitFileNotFound(resolvedURI, loc);
            return this.readToken();
        }
        // rebuild text document in order to avoid problems if include handler was called through worker
        const { uri, source } = textDocumentRaw;
        const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(uri, source);
        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_Include);
        return this.readToken();
    }
    emitMacroWarning(msg, loc) {
        this.diagnostics.warning(EPreprocessorWarnings.MacroUnknownWarning, { ...loc.start /* << FIXME: remove this */, loc, msg });
    }
    emitMacroError(msg, loc) {
        this.diagnostics.error(EPreprocessorErrors.MacroUnknownError, { ...loc.start /* << FIXME: remove this */, loc, msg });
    }
    emitFileNotFound(file, loc) {
        this.diagnostics.error(EPreprocessorErrors.GeneralCouldNotReadFile, { ...loc.start /* << FIXME: remove this */, loc, target: file });
    }
    async applyMacro(token) {
        const macros = this.macros;
        const macro = macros.get(token.value);
        if (!macro) {
            return null;
        }
        if (macro.bFunction) {
            const $lexer = this.lexer;
            const pos = this.lexer.getPosition();
            const nextToken = await this.readToken();
            if (nextToken.value !== '(') {
                this.emitMacroWarning(`for macro '${macro.name} function call signature is expected'`, token.loc);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)($lexer === this.lexer, 'something went wrong');
                this.lexer.setPosition(pos);
                return null;
            }
            let readTokens = [nextToken];
            let argRanges = [];
            let argToken = await this.readToken();
            let bracketDepth = 0;
            let startPos = 1;
            let endPos = 1;
            readTokens.push(argToken);
            while (argToken.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL && !(argToken.value === ')' && bracketDepth == 0)) {
                switch (argToken.value) {
                    case '(':
                        bracketDepth++;
                        break;
                    case ')':
                        bracketDepth--;
                        break;
                    case ',':
                        if (bracketDepth === 0) {
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(endPos - startPos > 0);
                            // TODO: emit error
                            if ((endPos - startPos) > 0) {
                                argRanges.push(startPos, endPos);
                            }
                            startPos = endPos + 1;
                        }
                        break;
                }
                endPos++;
                argToken = await this.readToken();
                readTokens.push(argToken);
            }
            if (endPos > startPos) {
                argRanges.push(startPos, endPos);
            }
            const nArgs = argRanges.length / 2;
            if (nArgs !== macro.params.length) {
                this.emitMacroError(`macro '${macro.name}' arguments mismatch, expected count is ${macro.params.length} but recived ${nArgs}`, token.loc);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)($lexer === this.lexer, 'something went wrong');
                this.lexer.setPosition(pos);
                return null;
            }
            {
                const { loc: { start } } = token;
                const { loc: { end } } = argToken;
                this.pushDocument(this.macroToLexer(macro), { start, end }, EPPDocumentFlags.k_Macro, macro);
            }
            const params = macro.params;
            for (let i = 0; i < params.length; ++i) {
                const i2 = i * 2;
                const startPos = argRanges[i2];
                const endPos = argRanges[i2 + 1];
                const start = readTokens[startPos].loc.start;
                const end = readTokens[endPos - 1].loc.end;
                const tokens = readTokens.slice(startPos, endPos);
                if (DEBUG_MACRO) {
                    console.log(`${macro.name}.${params[i]} => ${tokens.map(tk => tk.value).join(' ')}`);
                }
                macros.set({
                    name: params[i],
                    tokens,
                    bFunction: false,
                    params: null,
                    bRegionExpr: false
                });
            }
        }
        else {
            if (DEBUG_MACRO) {
                console.log(`${macro.name} => ${macro.tokens.map(tk => tk.value).join(' ')}`);
            }
            this.pushDocument(this.macroToLexer(macro), token.loc, EPPDocumentFlags.k_Macro, macro);
        }
        return macro;
    }
    async preprocessToString(value, includeResolver) {
        if (DEBUG_MACRO) {
            console.info('preprocess to string', value);
        }
        const { knownTypes, macros, diagnostics: diag } = this;
        const pp = new Preprocessor(this.lexerEngine, { knownTypes, macros, diag, includeResolver });
        pp.setTextDocument(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)('://macro', value));
        let token = await pp.readToken();
        let raw = null;
        while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            raw = (raw ? raw + ' ' : '') + token.value;
            token = await pp.readToken();
        }
        if (DEBUG_MACRO) {
            console.info(`>> "${raw}"`);
        }
        return raw;
    }
    // apply "left'##'right" operator to value and next token
    async applyConcatMacro(left) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.macros.get(left.value) || !this.macros.get(left.value).bFunction);
        const right = await this.readToken(false, false);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(right.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL);
        if (DEBUG_MACRO) {
            console.info(`concat strings: "${left.value}##${right.value}"`);
        }
        const leftRaw = await this.preprocessToString(left.value, this.includeResolver);
        const rightRaw = await this.preprocessToString(right.value, this.includeResolver);
        const raw = `${leftRaw}${rightRaw}`;
        if (DEBUG_MACRO) {
            console.info(`=> "${leftRaw}${rightRaw}"`);
        }
        const loc = { start: left.loc.start, end: right.loc.end };
        // multiple concatenation processing: A ## B ## C ##  etc.
        const nextToken = await this.readToken(false, false);
        if (nextToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO_CONCAT) {
            return this.applyConcatMacro(createMacroToken(raw, loc));
        }
        this.pushToken(nextToken);
        // we handle it as text document, because all possible macros inside are already resolved
        const pos = left.loc.start;
        const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(pos.file, raw, pos);
        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_None);
        return this.readToken();
    }
    async examMacro(token) {
        const macroProcessing = this.stack[this.stack.length - 1].flags & EPPDocumentFlags.k_Macro;
        if (macroProcessing) {
            const nextToken = await this.readToken(false, false);
            if (nextToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO_CONCAT) {
                return this.applyConcatMacro(token);
            }
            this.pushToken(nextToken);
        }
        if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID || token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_TYPE_ID) {
            const macro = await this.applyMacro(token);
            if (macro) {
                return this.readToken();
            }
        }
        return token;
    }
    //
    //
    //
    documentToLexer(textDocument) {
        const { lexerEngine: engine, knownTypes, lexerOptions: { skipComments } } = this;
        const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__.Lexer({ engine, knownTypes, skipComments });
        lexer.setTextDocument(textDocument);
        return lexer;
    }
    tokensToLexer(tokens) {
        return new _lib_parser_CachingLexer__WEBPACK_IMPORTED_MODULE_8__.CachingLexer(tokens);
    }
    macroToLexer(macro) {
        return this.tokensToLexer(macro.tokens);
    }
    async tokenToLexer(token) {
        const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__.Lexer({ engine: this.lexerEngine, knownTypes: this.knownTypes });
        const uri = token.loc.start.file;
        const source = token.value;
        const offset = token.loc.start;
        lexer.setTextDocument(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(uri, source, offset));
        return lexer;
    }
    async lineToTokens(lineToken) {
        const lexer = await this.tokenToLexer(lineToken);
        let tokens = [];
        let tk = lexer.getNextToken();
        while (tk.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            tokens.push(tk);
            tk = lexer.getNextToken();
        }
        return tokens;
    }
    async lineToLexer(lineToken) {
        return this.tokensToLexer(await this.lineToTokens(lineToken));
    }
}
// create preprocessed document
async function createPPDocument(textDocument, options = {}) {
    // TODO: try to use default lexer: new LexerEngine()
    const parser = (0,_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__.defaultSLParser)();
    const { skipComments = true, includeResolver, defines } = options;
    const pp = new Preprocessor(parser.lexerEngine, { skipComments, includeResolver, defines });
    pp.setTextDocument(textDocument);
    const newline = (from, to) => Array(Math.min(to - from, 4)).fill('\n').join('');
    const padding = (length) => Array(length).fill(' ').join('');
    let content = '';
    let tokenThis = await pp.readToken();
    while (tokenThis.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
        const doPadding = !content || content.substr(-1) === '\n';
        const locThis = pp.macroLocation() || tokenThis.loc;
        const macroThis = pp.currentMacro();
        // padding
        if (doPadding) {
            content += padding(locThis.start.column); // + padding(tokenThis.loc.start.column);
            // note: paddings inside multiline macro are not supported
        }
        // place content
        content = `${content}${!doPadding ? ' ' : ''}${tokenThis.value}`;
        const tokenNext = await pp.readToken();
        const locNext = pp.macroLocation() || tokenNext.loc;
        // newline if new file
        if (locThis.end.file !== locNext.start.file) {
            content += '\n\n';
        }
        // newline if new global macro (or just diff lines) on a new line
        else if (locThis.end.line < locNext.start.line) {
            content += newline(locThis.end.line, locNext.start.line);
        }
        // new line if it is a multiline macro
        else if (tokenThis.loc.end.line < tokenNext.loc.start.line && macroThis === pp.currentMacro()) {
            content += newline(tokenThis.loc.end.line, tokenNext.loc.start.line);
        }
        tokenThis = tokenNext;
    }
    return (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(textDocument.uri, content);
}


/***/ }),

/***/ "Xd2f":
/*!*********************************!*\
  !*** ./src/lib/parser/State.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "State": () => (/* binding */ State)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _Item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Item */ "gO55");


class State {
    constructor() {
        this.nextStates = {};
        this.index = 0;
        this.items = [];
        this.numBaseItems = 0;
        this.numOtherItems = 0;
    }
    eachItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.items.length; ++i) {
            cb(this.items[i], i);
        }
    }
    eachBaseItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.numBaseItems; ++i) {
            cb(this.items[i], i);
        }
    }
    isExpected(symbol) {
        return !!this.items.find(item => item.isExpected(symbol));
    }
    hasItem(value, type) {
        return this.items.find(item => item.isEqual(value, type)) || null;
    }
    hasParentItem(value) {
        return this.items.find(item => item.isParentItem(value)) || null;
    }
    hasChildItem(value) {
        return this.items.find(item => item.isChildItem(value)) || null;
    }
    hasRule(rule, pos) {
        for (let i = 0; i < this.numBaseItems; ++i) {
            const item = this.items[i];
            if (item.rule === rule && item.pos === pos) {
                return true;
            }
        }
        return false;
    }
    isEmpty() {
        return !(this.items.length);
    }
    isEqual(state, type) {
        if (this.numBaseItems !== state.numBaseItems) {
            return false;
        }
        for (let i = 0; i < this.numBaseItems; ++i) {
            const baseItemA = this.items[i];
            let isEqual = false;
            for (let i = 0; i < state.numBaseItems; ++i) {
                const baseItemB = state.items[i];
                if (baseItemA.isEqual(baseItemB, type)) {
                    isEqual = true;
                    break;
                }
            }
            if (!isEqual) {
                return false;
            }
        }
        return true;
    }
    push(item) {
        if (this.items.length === 0 || item.pos > 0) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.numOtherItems === 0);
            this.numBaseItems++;
        }
        else {
            this.numOtherItems++;
        }
        this.items.push(item);
    }
    tryPush_LR0(rule, pos) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return false;
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__.Item(rule, pos);
        this.push(item);
        return true;
    }
    tryPush_LR(rule, pos, expectedSymbol) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return sameItem.addExpected(expectedSymbol);
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__.Item(rule, pos, [expectedSymbol]);
        this.push(item);
        return true;
    }
    addNextState(symbol, state) {
        if (this.nextStates[symbol]) {
            return false;
        }
        this.nextStates[symbol] = state;
        return true;
    }
    deleteNotBase() {
        this.items.length = this.numBaseItems;
    }
    toString(isBase = true, grammarSymbols = null) {
        const items = isBase ? this.items.slice(0, this.numBaseItems) : this.items;
        return `State ${this.index}:\n` +
            items.map(item => `\t\t${item.toString(grammarSymbols)}\n`).join();
    }
}


/***/ }),

/***/ "yMDx":
/*!***********************************!*\
  !*** ./src/lib/parser/symbols.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "END_POSITION": () => (/* binding */ END_POSITION),
/* harmony export */   "END_SYMBOL": () => (/* binding */ END_SYMBOL),
/* harmony export */   "EOF": () => (/* binding */ EOF),
/* harmony export */   "ERROR": () => (/* binding */ ERROR),
/* harmony export */   "FLAG_RULE_CREATE_NODE": () => (/* binding */ FLAG_RULE_CREATE_NODE),
/* harmony export */   "FLAG_RULE_EXPOSE_NODE": () => (/* binding */ FLAG_RULE_EXPOSE_NODE),
/* harmony export */   "FLAG_RULE_FUNCTION": () => (/* binding */ FLAG_RULE_FUNCTION),
/* harmony export */   "FLAG_RULE_SKIP_NODE": () => (/* binding */ FLAG_RULE_SKIP_NODE),
/* harmony export */   "INLINE_COMMENT_SYMBOL": () => (/* binding */ INLINE_COMMENT_SYMBOL),
/* harmony export */   "LEXER_RULES": () => (/* binding */ LEXER_RULES),
/* harmony export */   "START_SYMBOL": () => (/* binding */ START_SYMBOL),
/* harmony export */   "T_EMPTY": () => (/* binding */ T_EMPTY),
/* harmony export */   "T_FLOAT": () => (/* binding */ T_FLOAT),
/* harmony export */   "T_LINE_TERMINATOR": () => (/* binding */ T_LINE_TERMINATOR),
/* harmony export */   "T_MACRO": () => (/* binding */ T_MACRO),
/* harmony export */   "T_MACRO_CONCAT": () => (/* binding */ T_MACRO_CONCAT),
/* harmony export */   "T_NON_TYPE_ID": () => (/* binding */ T_NON_TYPE_ID),
/* harmony export */   "T_STRING": () => (/* binding */ T_STRING),
/* harmony export */   "T_TYPE_ID": () => (/* binding */ T_TYPE_ID),
/* harmony export */   "T_UINT": () => (/* binding */ T_UINT),
/* harmony export */   "UNKNOWN_TOKEN": () => (/* binding */ UNKNOWN_TOKEN),
/* harmony export */   "UNUSED_SYMBOL": () => (/* binding */ UNUSED_SYMBOL)
/* harmony export */ });
const END_POSITION = 'END'; // item, parser
const T_EMPTY = 'EMPTY'; // item, parser
const UNKNOWN_TOKEN = 'UNKNOWN'; // lexer
const START_SYMBOL = 'S'; // parser
const UNUSED_SYMBOL = '##'; // parser
const INLINE_COMMENT_SYMBOL = '#'; // parser
// TODO: do not use ambigious name 'ERROR'
const ERROR = 'ERROR'; // parser
const END_SYMBOL = '$'; // lexer, parser
const LEXER_RULES = '--LEXER--'; // parser
const FLAG_RULE_CREATE_NODE = '--add'; // parser
const FLAG_RULE_SKIP_NODE = '--skip'; // parser
const FLAG_RULE_EXPOSE_NODE = '--expose'; // parser
const FLAG_RULE_FUNCTION = '--F'; // parser
const EOF = 'EOF'; // lexer
const T_STRING = 'T_STRING'; // lexer
const T_FLOAT = 'T_FLOAT'; // lexer
const T_UINT = 'T_UINT'; // lexer
const T_TYPE_ID = 'T_TYPE_ID'; // lexer
const T_NON_TYPE_ID = 'T_NON_TYPE_ID'; // lexer
const T_LINE_TERMINATOR = 'T_LINE_TERMINATOR'; // lexer
const T_MACRO = 'T_MACRO'; // lexer '#define', '#ifdef' etc.
const T_MACRO_CONCAT = 'T_MACRO_CONCAT'; // lexer '##'


/***/ }),

/***/ "5ZRz":
/*!********************************!*\
  !*** ./src/lib/parser/util.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkRange": () => (/* binding */ checkRange),
/* harmony export */   "cloneRange": () => (/* binding */ cloneRange),
/* harmony export */   "commonRange": () => (/* binding */ commonRange),
/* harmony export */   "extendRange": () => (/* binding */ extendRange),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "positionMax": () => (/* binding */ positionMax),
/* harmony export */   "positionMin": () => (/* binding */ positionMin)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");

function positionMin(a, b) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.file === b.file);
    return {
        offset: Math.min(a.offset, b.offset),
        line: Math.min(a.line, b.line),
        column: Math.min(a.column, b.column),
        file: a.file
    };
}
function positionMax(a, b) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.file === b.file);
    return {
        offset: Math.max(a.offset, b.offset),
        line: Math.max(a.line, b.line),
        column: Math.max(a.column, b.column),
        file: a.file
    };
}
function cloneRange(range) {
    return { start: { ...range.start }, end: { ...range.end } };
}
// export function extendRange(parent: IRange, child: IRange): IRange {
//     if (child.start.file !== parent.start.file) {
//         return parent;
//     }
//     assert(parent.end.file === child.end.file);
//     if (child.start.line < parent.start.line) {
//         parent.start.column = child.start.column;
//         parent.start.line = child.start.line;
//         parent.start.file = child.start.file;
//         parent.start.offset = child.start.offset;
//     } else if (child.start.line === parent.start.line) {
//         // parent.start = positionMin(child.start, parent.start);
//         parent.start.column = Math.min(child.start.column, parent.start.column);
//         parent.start.line = Math.min(child.start.line, parent.start.line);
//         parent.start.offset = Math.min(child.start.offset, parent.start.offset);
//     }
//     if (child.end.line > parent.end.line) {
//         parent.end.column = child.end.column;
//         parent.end.line = child.end.line;
//         parent.end.file = child.end.file;
//         parent.end.offset = child.end.offset;
//     } else if (child.end.line === parent.end.line) {
//         // parent.end = positionMax(child.end, parent.end);
//         parent.end.column = Math.max(child.end.column, parent.end.column);
//         parent.end.line = Math.max(child.end.line, parent.end.line);
//         parent.end.offset = Math.max(child.end.offset, parent.end.offset);
//     }
//     return parent;
// }
function extendRange(parent, child) {
    if (child.start.file !== parent.start.file) {
        return parent;
    }
    if (child.start.line < parent.start.line) {
        parent.start = { ...child.start };
    }
    else if (child.start.line === parent.start.line) {
        parent.start = positionMin(child.start, parent.start);
    }
    if (child.end.line > parent.end.line) {
        parent.end = { ...child.end };
    }
    else if (child.end.line === parent.end.line) {
        parent.end = positionMax(child.end, parent.end);
    }
    return parent;
}
function commonRange(...rangeList) {
    const MAX_I32 = Number.MAX_SAFE_INTEGER;
    const MIN_I32 = Number.MIN_SAFE_INTEGER;
    const file = rangeList[0].start.file;
    let start = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };
    let end = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };
    rangeList.forEach(range => start = positionMin(start, range.start));
    rangeList.forEach(range => end = positionMax(end, range.end));
    return { start, end };
}
function offset(source, offset) {
    if (offset) {
        // TODO: check that URIs the same
        const { start, end } = source;
        if (start.line === 0) {
            start.column += offset.column;
        }
        if (end.line === 0) {
            end.column += offset.column;
        }
        start.line += offset.line;
        end.line += offset.line;
    }
    return source;
}
const checkRange = (range, offset) => range.start.offset <= offset && range.end.offset > offset;
// export function stringifyRange(range: IRange, depth = 0) {
//     if (!range) {
//         return '';
//     }
//     const offset = Array(depth).fill('---').join('') + (depth? ' ' : '');
//     const { start, end, source } = range;
//     const filename = String(start.file).split('/').reverse()[0];
//     return `${offset}${filename}:${start.line}:${start.column}-${end.line}:${end.column}\n${stringifyRange(source, depth + 1)}`;
// } 


/***/ }),

/***/ "U50j":
/*!******************************!*\
  !*** ./src/lib/path/path.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "ext": () => (/* binding */ ext),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "parse": () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "cOQ3");

class Pathinfo {
    constructor(path) {
        this._dirname = null;
        this._extension = null;
        this._filename = null;
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(path)) {
            this.set(path);
        }
    }
    get path() {
        return this.toString();
    }
    set path(path) {
        this.set(path);
    }
    get dirname() {
        return this._dirname;
    }
    set dirname(dirname) {
        this._dirname = dirname;
    }
    get filename() {
        return this._filename;
    }
    set filename(filename) {
        this._filename = filename;
    }
    get ext() {
        return this._extension;
    }
    set ext(extension) {
        this._extension = extension;
    }
    get basename() {
        return (this._filename ? this._filename + (this._extension ? "." + this._extension : "") : "");
    }
    set basename(basename) {
        var nPos = basename.lastIndexOf(".");
        if (nPos < 0) {
            this._filename = basename.substr(0);
            this._extension = null;
        }
        else {
            this._filename = basename.substr(0, nPos);
            this._extension = basename.substr(nPos + 1);
        }
    }
    set(path) {
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(path)) {
            var pParts = path.replace('\\', '/').split('/');
            this.basename = (pParts.pop());
            this._dirname = pParts.join('/');
        }
        else if (path instanceof Pathinfo) {
            this._dirname = path.dirname;
            this._filename = path.filename;
            this._extension = path.ext;
        }
        else if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(path)) {
            return null;
        }
        else {
            //critical_error
            throw new Error(`Unexpected data type was used: ${path}`);
        }
    }
    replaceExt(ext) {
        this.ext = ext;
        return this;
    }
    isAbsolute() { return !!(this._dirname?.[0] === "/"); }
    toString() {
        return (this._dirname ? this._dirname + "/" : "") + (this.basename);
    }
}
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === "..") {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        for (; up--;) {
            parts.unshift("..");
        }
    }
    return parts;
}
function normalize(path) {
    var info = parse(path);
    var isAbsolute = info.isAbsolute();
    var tail = info.dirname;
    var trailingSlash = /[\\\/]$/.test(tail);
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
        return !!p;
    }), !isAbsolute).join("/");
    if (tail && trailingSlash) {
        tail += "/";
    }
    info.dirname = ((isAbsolute ? "/" : "") + tail);
    return info.toString();
}
function parse(path) {
    return new Pathinfo(path);
}
function dirname(path) {
    return parse(path).dirname;
}
function ext(path) {
    return parse(path).ext;
}


/***/ }),

/***/ "CWQE":
/*!****************************!*\
  !*** ./src/lib/uri/uri.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "currentPath": () => (/* binding */ currentPath),
/* harmony export */   "currentScript": () => (/* binding */ currentScript),
/* harmony export */   "fromLocalPath": () => (/* binding */ fromLocalPath),
/* harmony export */   "here": () => (/* binding */ here),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseDataURI": () => (/* binding */ parseDataURI),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "toLocalPath": () => (/* binding */ toLocalPath)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "cOQ3");
/* harmony import */ var _path_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/path */ "U50j");


class URI {
    constructor(uri) {
        this._scheme = null;
        this._userinfo = null;
        this._host = null;
        this._port = 0;
        this._path = null;
        this._query = null;
        this._fragment = null;
        if (uri) {
            this.set(uri);
        }
    }
    get urn() {
        return (this._path ? this._path : "") +
            (this._query ? '?' + this._query : "") +
            (this._fragment ? '#' + this._fragment : "");
    }
    get url() {
        return (this._scheme ? this._scheme + '//' : "") + this.authority;
    }
    get authority() {
        return (this._host ? (this._userinfo ? this._userinfo + '@' : "") +
            this._host + (this._port ? ':' + this._port : "") : "");
    }
    get scheme() {
        return this._scheme;
    }
    get protocol() {
        if (!this._scheme) {
            return this._scheme;
        }
        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));
    }
    get userInfo() {
        return this._userinfo;
    }
    get host() {
        return this._host;
    }
    set host(sHost) {
        //TODO: check host format
        this._host = sHost;
    }
    get port() {
        return this._port;
    }
    set port(iPort) {
        this._port = iPort;
    }
    get path() {
        return this._path;
    }
    set path(sPath) {
        // debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))), 
        //     "invalid path used: " + sPath);
        //TODO: check path format
        this._path = sPath;
    }
    get query() {
        //TODO: check query format
        return this._query;
    }
    set query(sQuery) {
        this._query = sQuery;
    }
    get fragment() {
        return this._fragment;
    }
    set(data) {
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(data)) {
            var uri = URI.uriExp.exec(data);
            console.assert(uri !== null, 'Invalid URI format used.\nused uri: ' + data);
            if (!uri) {
                return null;
            }
            this._scheme = uri[1] || null;
            this._userinfo = uri[2] || null;
            this._host = uri[3] || null;
            this._port = parseInt(uri[4]) || null;
            this._path = uri[5] || uri[6] || null;
            this._query = uri[7] || null;
            this._fragment = uri[8] || null;
            return this;
        }
        else if (data instanceof URI) {
            return this.set(data.toString());
        }
        console.error('Unexpected data type was used.');
        return null;
    }
    toString() {
        return this.url + this.urn;
    }
}
//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment
URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
function normalizeURIPath(file) {
    if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.path)) {
        if (file.scheme === "filesystem:") {
            var uri = parse(file.path);
            uri.path = _path_path__WEBPACK_IMPORTED_MODULE_1__.normalize(uri.path);
            file.path = uri.toString();
        }
        else {
            file.path = _path_path__WEBPACK_IMPORTED_MODULE_1__.normalize(file.path);
        }
    }
    return file;
}
function resolve(from, to = document.location.href) {
    var currentPath = parse(to);
    var file = parse(from);
    var dirname;
    normalizeURIPath(file);
    normalizeURIPath(currentPath);
    if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.scheme) || !(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.host) || _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(file.path).isAbsolute()) {
        //another server or absolute path
        return from;
    }
    dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(currentPath.path).dirname;
    currentPath.path = dirname ? (dirname + "/" + from) : from;
    return normalizeURIPath(currentPath).toString();
}
function parseDataURI(uri) {
    var re = /^data:([\w\d\-\/]+)?(;charset=[\w\d\-]*)?(;base64)?,(.*)$/;
    var m = uri.match(re);
    return {
        //like [text/plain]
        mediatype: m[1] || null,
        //like [;charset=windows-1251]
        charset: (0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(m[2]) ? m[2].substr(9) : null,
        //like [;base64]
        base64: (0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(m[3]),
        data: m[4] || null
    };
}
function parse(uri) {
    return new URI(String(uri));
}
function currentScript() {
    if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(document['currentScript'])) {
        return document['currentScript'];
    }
    var scripts = document.getElementsByTagName("script");
    return scripts[scripts.length - 1];
}
function currentPath() {
    var uri = parse(currentScript().src);
    let dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(uri.path).dirname;
    return uri.url + dirname + "/";
}
function here() {
    return new URI(document.location.href);
}
function fromLocalPath(filepath) {
    return `file:///${String(filepath).replaceAll('\\', '/')}`;
}
function toLocalPath(uri) {
    return parse(uri).path?.substring(1) || '';
}


/***/ }),

/***/ "0mZ+":
/*!*************************************!*\
  !*** ./src/lib/util/Diagnostics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiagnosticException": () => (/* binding */ DiagnosticException),
/* harmony export */   "Diagnostics": () => (/* binding */ Diagnostics)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");


function locToString(loc) {
    return `${loc.line},${loc.column}`;
}
function rangeToString(range) {
    return `${locToString(range.start)}:${locToString(range.end)}`;
}
function readKey(desc, key) {
    let keyParts = key.split('.');
    if (keyParts.length > 1) {
        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));
    }
    return desc[keyParts[0]];
}
function fillPattern(pattern, desc) {
    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {
        return readKey(desc, key);
    });
}
class DiagnosticException extends Error {
    constructor(host, mesg) {
        super(mesg.content);
        Error.captureStackTrace(this, DiagnosticException);
    }
}
class Diagnostics {
    constructor(name, codePrefix) {
        this._name = name;
        this._codePrefix = (codePrefix || '').toUpperCase();
        this.reset();
    }
    emitException() {
        throw new DiagnosticException(this, this.getLastError());
    }
    reset() {
        this._entries = [];
    }
    resolve() {
        let report = { errors: 0, warnings: 0, messages: [] };
        for (let entry of this._entries) {
            let message = this.resolveEntry(entry);
            switch (message.category) {
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Warning:
                    report.warnings++;
                    break;
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error:
                    report.errors++;
                    break;
            }
            report.messages.push(message);
        }
        return report;
    }
    resolveEntry(entry) {
        // let { category, desc } = entry;
        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();
        let loc = null;
        let range;
        let start;
        let end;
        let file = this.resolveFilename(entry.category, entry.code, entry.desc);
        if (range = this.resolveRange(entry.category, entry.code, entry.desc)) {
            ({ start, end } = range);
            loc = rangeToString(range);
        }
        else {
            start = this.resolvePosition(entry.category, entry.code, entry.desc);
            loc = locToString(start);
        }
        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;
        let code = `${this._codePrefix}${entry.code}`;
        let category = entry.category;
        return { code, category, content, file, start, end };
    }
    resolveFilename(category, code, desc) {
        return '[unknown]';
    }
    resolvePosition(category, code, desc) {
        return { file: null, line: 0, column: 0 };
    }
    resolveRange(category, code, desc) {
        return null;
    }
    resolveDescription(code, category, desc) {
        let diagMesgs = this.diagnosticMessages();
        if (!diagMesgs) {
            console.error(`Diagnostic messages of '${this._name}' not found.`);
            return '[no description found]';
        }
        if (!diagMesgs[code]) {
            return `[no description found for code '${code}']`;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(diagMesgs[code])) {
            return fillPattern(diagMesgs[code], desc);
        }
        return diagMesgs[code](desc);
    }
    diagnosticMessages() {
        return null;
    }
    error(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error, code, desc });
    }
    warning(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Warning, code, desc });
    }
    // add error and emit an exception in order to interrupt processing
    critical(code, desc) {
        this.error(code, desc);
        this.emitException();
    }
    prettyPrint() {
        return null; //JSON.stringify(this._errors, null, '\t');
    }
    hasErrors() {
        return this._entries.filter(entry => entry.category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error).length > 0;
    }
    getLastError() {
        for (let i = this._entries.length - 1; i >= 0; --i) {
            if (this._entries[i].category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error) {
                return this.resolveEntry(this._entries[i]);
            }
        }
        return null;
    }
    isEmpty() {
        return this._entries.length === 0;
    }
    static mergeReports(reportList) {
        let result = { errors: 0, warnings: 0, messages: [] };
        reportList.forEach((report) => {
            if (!report)
                return;
            result.errors += report.errors;
            result.warnings += report.warnings;
            result.messages = result.messages.concat(report.messages);
        });
        return result;
    }
    static stringify(report) {
        return report.messages.map(mesg => mesg.content).join('\n');
    }
    static asRange(mesg) {
        let range = { start: mesg.start, end: mesg.end };
        if (!range.end) {
            range.end = { ...range.start };
        }
        const { start, end } = range;
        if (end.line == start.line && end.column == start.column) {
            end.column += 1;
        }
        return range;
    }
}


/***/ }),

/***/ "Cx6u":
/*!***********************************!*\
  !*** ./src/lib/util/StringRef.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringRef": () => (/* binding */ StringRef)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");

// helper class to always pass strings by pointer and not by value;
class StringRef {
    constructor(content) {
        this.content = content;
    }
    valueOf() {
        return this.content;
    }
    toString() {
        return this.content;
    }
    toSource() {
        return this.content;
    }
    static make(val) {
        if (!val) {
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(val)) {
            if (val instanceof StringRef)
                return val;
            // IP: sometimes it can be useful to restore string ref after worker transfer and so on
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(val['content']))
                return StringRef.make(val['content']);
        }
        const sval = val;
        let ref = StringRef.storage[sval];
        if (ref) {
            return ref;
        }
        ref = new StringRef(sval);
        StringRef.storage[sval] = ref;
        return ref;
    }
}
StringRef.storage = {};


/***/ }),

/***/ "z3nI":
/*!**********************************!*\
  !*** ./src/lib/util/s3d/type.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDef": () => (/* binding */ isDef),
/* harmony export */   "isDefAndNotNull": () => (/* binding */ isDefAndNotNull),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNull": () => (/* binding */ isNull),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString)
/* harmony export */ });
function isNull(x) { return x === null; }
function isDef(x) { return x !== undefined; }
function isDefAndNotNull(x) { return x != null; }
function isString(x) { return typeof x === 'string'; }
function isFunction(fn) { return typeof fn === "function"; }
function isBoolean(x) { return x === !!x; }
function isArray(x) { return typeof x === "object" && x instanceof Array; }
function isObject(x) { return typeof x === "object" && x !== null && !isArray(x); }
function isNumber(x) { return typeof x === "number"; }
function isEmpty(x) {
    if (x == null) {
        return true;
    }
    if (typeof x !== "object") {
        return false;
    }
    for (let key in x) {
        if (x.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
function clone(obj) {
    var copy;
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj)
        return obj;
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr))
                copy[attr] = clone(obj[attr]);
        }
        return copy;
    }
    throw new Error("Unable to copy obj! Its type isn't supported.");
}


/***/ }),

/***/ "Zvko":
/*!****************************!*\
  !*** ./src/lib/fx/HLSL.gr ***!
  \****************************/
/***/ ((module) => {

module.exports = "S : Program\r\nProgram : --add\r\nProgram : Decls\r\n\r\nDecls : Decl --expose\r\nDecls : Decls Decl\r\n\r\nDecl : ';'\r\nDecl : TypeDecl\r\nDecl : VariableDecl\r\nDecl : VarStructDecl\r\nDecl : FunctionDecl\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    Decl : TechniqueDecl\r\n#endif\r\nDecl : Technique11Decl\r\nDecl : UseDecl\r\n#if FX_PART\r\n    Decl : ImportDecl\r\n    Decl : ProvideDecl\r\n#endif\r\nDecl : CbufferDecl\r\nDecl : TbufferDecl\r\nDecl : ERROR\r\n\r\n#if FX_PART\r\n    Decl : PartFxDecl\r\n    ImportDecl : T_KW_IMPORT String ';'\r\n    ProvideDecl : T_KW_PROVIDE ComplexNameOpt ';'\r\n# ProvideDecl : T_KW_PROVIDE ComplexNameOpt T_KW_AS ComplexNameOpt ';'\r\n#endif \r\n\r\nUseDecl : T_KW_USE Mode\r\nMode : T_KW_STRICT\r\n\r\nUsages : Usage --expose\r\nUsages : Usages Usage\r\nUsage : T_KW_STATIC --add\r\nUsage : T_KW_NOINTERPOLATION\r\nUsage : T_KW_CENTROID\r\nUsage : T_KW_NOPERSPECTIVE\r\nUsage : T_KW_UNIFORM\r\nUsage : T_KW_EXTERN\r\nUsage : T_KW_VOLATILE\r\nUsage : T_KW_INLINE\r\nUsage : T_KW_UNSIGNED\r\nUsage : T_KW_PRECISE\r\nUsage : ConstUsage\r\n\r\nConstUsages : ConstUsage --expose\r\nConstUsages : ConstUsages ConstUsage\r\nConstUsage : T_KW_CONST\r\nConstUsage : T_KW_ROW_MAJOR\r\nConstUsage : T_KW_COLUMN_MAJOR\r\n\r\nUsageType : Type --add\r\nUsageType : Usages Type\r\n\r\nUsageStructDecl : StructDecl --add\r\nUsageStructDecl : Usages StructDecl\r\n\r\nTypeDecl : T_KW_TYPEDEF ConstType TypeDefs --F addTypeDef ';' --add\r\nTypeDecl : T_KW_TYPEDEF ConstStructDecl TypeDefs --F addTypeDef ';'\r\nTypeDecl : StructDecl ';'\r\nTypeDefs : VariableDim\r\nTypeDefs : VariableDim ',' TypeDefs\r\n\r\nType : BaseType --add\r\nType : Struct\r\nType : TypeId\r\nType : T_KW_STRUCT TypeId\r\n\r\nConstType : Type --add\r\nConstType : ConstUsages Type\r\nConstTypeDim : ConstType --expose\r\nConstTypeDim : ConstTypeDim '[' ConstantExpr ']'\r\n\r\nBaseType : T_KW_VOID --add\r\nBaseType : ScalarType\r\nBaseType : VectorType\r\nBaseType : MatrixType\r\nBaseType : ObjectType\r\n\r\nScalarType : T_KW_BOOL --add\r\nScalarType : T_KW_INT\r\n# ScalarType : T_KW_UNSIGNED T_KW_INT\r\nScalarType : T_KW_UINT\r\nScalarType : T_KW_HALF\r\nScalarType : T_KW_FLOAT\r\nScalarType : T_KW_DOUBLE\r\n\r\nVectorType : T_KW_VECTOR --add\r\nVectorType : T_KW_VECTOR '<' ScalarType ',' AddExpr '>'\r\n\r\nMatrixType : T_KW_MATRIX --add\r\nMatrixType : T_KW_MATRIX '<' ScalarType ',' ConstantExpr ',' AddExpr '>'\r\n\r\nObjectType : T_KW_STRING --add\r\nObjectType : T_KW_TEXTURE\r\nObjectType : T_KW_TEXTURE1D\r\nObjectType : T_KW_TEXTURE2D\r\nObjectType : T_KW_TEXTURE2D '<' Type '>'\r\n#if FX_PART\r\n    ObjectType : T_KW_TRIMESH '<' Type '>'\r\n#endif\r\nObjectType : T_KW_TEXTURE2DARRAY\r\nObjectType : T_KW_TEXTURE3D\r\nObjectType : T_KW_TEXTURE3D '<' Type '>'\r\nObjectType : T_KW_TEXTURECUBE\r\nObjectType : T_KW_TEXTURECUBEARRAY\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectType : T_KW_SAMPLER\r\n    # ObjectType : T_KW_SAMPLER1D\r\n    # ObjectType : T_KW_SAMPLER2D\r\n    # ObjectType : T_KW_SAMPLER3D\r\n    # ObjectType : T_KW_SAMPLERCUBE\r\n    # ObjectType : T_KW_STATEBLOCK\r\n#endif\r\nObjectType : T_KW_SAMPLER_STATE\r\nObjectType : T_KW_SAMPLER_COMPARISON_STATE\r\nObjectType : T_KW_DEPTH_STENCIL_STATE\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectType : T_KW_PIXELSHADER\r\n    # ObjectType : T_KW_VERTEXSHADER\r\n    # ObjectType : T_KW_PIXELFRAGMENT\r\n    # ObjectType : T_KW_VERTEXFRAGMENT\r\n#endif\r\nObjectType : T_KW_RWTEXTURE1D '<' Type '>'\r\nObjectType : T_KW_RWTEXTURE2D '<' Type '>'\r\nObjectType : T_KW_RWTEXTURE3D '<' Type '>'\r\nObjectType : T_KW_BUFFER '<' Type '>'\r\nObjectType : T_KW_RWBUFFER '<' Type '>'\r\nObjectType : T_KW_RWSTRUCTUREDBUFFER '<' Type '>'\r\nObjectType : T_KW_STRUCTUREDBUFFER '<' Type '>'\r\nObjectType : T_KW_APPENDSTRUCTUREDBUFFER '<' Type '>'\r\n\r\nStruct : T_KW_STRUCT '{' '}' --add\r\nStruct : T_KW_STRUCT '{' StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id --F addType '{' '}' --add\r\nStructDecl : T_KW_STRUCT Id --F addType '{' UseDecl StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id --F addType '{' StructDecls '}'\r\n\r\nConstStructDecl : StructDecl\r\nConstStructDecl : ConstUsages StructDecl\r\n\r\nStructDecls : VariableDecl --expose \r\nStructDecls : VarStructDecl --expose \r\nStructDecls : VariableDecl StructDecls\r\nStructDecls : VarStructDecl StructDecls\r\n\r\nSemantic : ':' Id --add\r\nSemantic : ':' T_KW_REGISTER '(' Register ')'\r\nSemantics : Semantic\r\nSemantics : Semantics Semantic\r\nSemanticsOpt :\r\nSemanticsOpt : Semantics\r\n\r\nRegister : Id\r\nRegister : Target ',' Id\r\n\r\nAnnotation : AnnotationBegin AnnotationEnd  --add\r\nAnnotation : AnnotationBegin AnnotationDecls AnnotationEnd\r\nAnnotationOpt :\r\nAnnotationOpt : Annotation\r\nAnnotationBegin : '<'\r\nAnnotationDecls : VariableDecl\r\nAnnotationDecls : VariableDecl AnnotationDecls\r\nAnnotationEnd : '>'\r\n\r\nInitializer : '=' AssignmentExpr --add\r\nInitializer : '=' ERROR --add\r\nInitializer : '=' '{' InitExprs '}'\r\nInitializer : '=' '{' InitExprs ',' '}'\r\nInitializer : StateBlock\r\n\r\nVariableDecl : UsageType Variables ';' --add\r\nVariableDecl : UsageType Variables ERROR --add\r\nVarStructDecl : UsageStructDecl Variables ';' --add\r\n\r\nVariables : Variable --expose\r\nVariables : Variables ',' Variable\r\n# Variables : Variables ERROR Variable\r\nVariables : Variables ',' ERROR\r\nVariable : VariableDim SemanticsOpt AnnotationOpt Initializer --add\r\nVariable : VariableDim SemanticsOpt AnnotationOpt --add\r\nVariableDim : NonTypeId --add\r\nVariableDim : VariableDim '[' ConstantExpr ']'\r\n\r\n\r\nFunctionDecl : Attributes FunctionDef ';' --add\r\nFunctionDecl : FunctionDef ';' --add\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt StmtBlock\r\nFunctionDecl : FunctionDef AnnotationOpt StmtBlock\r\n\r\n# TODO: remove it;\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt ERROR\r\nFunctionDecl : FunctionDef AnnotationOpt ERROR\r\n\r\nFunctionDef : UsageType NonTypeId ParamList SemanticsOpt\r\n\r\nAttribute : '[' Id '(' ArgumentsOpt ')' ']'\r\nAttribute : '[' Id ']'\r\nAttributes : Attribute --expose\r\nAttributes : Attributes Attribute\r\nAttributesOpt : --expose\r\nAttributesOpt : Attributes\r\n\r\nParamList : '(' ')'\r\nParamList : '(' T_KW_VOID ')'\r\nParamList : '(' ParameterDecls ')'\r\n\r\nParameterDecls : ParameterDecl --expose\r\nParameterDecls : ParameterDecls ',' ParameterDecl\r\nParameterDecls : ParameterDecls ERROR ParameterDecl\r\nParameterDecls : ParameterDecls ',' ERROR\r\nParameterDecls : ERROR\r\nParameterDecl : ParamUsageType Variable\r\n\r\nParamUsageType : Type --add\r\nParamUsageType : ParamUsages Type\r\n\r\nParamUsages : ParamUsage --expose\r\nParamUsages : ParamUsages ParamUsage\r\nParamUsage : T_KW_IN --add\r\nParamUsage : T_KW_OUT\r\nParamUsage : T_KW_INOUT\r\nParamUsage : T_KW_UNIFORM\r\nParamUsage : ConstUsage\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    TechniqueDecl : T_KW_TECHNIQUE ComplexNameOpt SemanticsOpt AnnotationOpt TechniqueBody --add\r\n    TechniqueBody : '{' '}'  --add\r\n    TechniqueBody : '{' PassDecls '}'\r\n#endif \r\n\r\nTechnique11Decl : T_KW_TECHNIQUE11 ComplexNameOpt SemanticsOpt AnnotationOpt Technique11Body --add\r\nTechnique11Body : '{' '}'  --add\r\nTechnique11Body : '{' Pass11Decls '}'\r\n\r\nCbufferDecl : T_KW_CBUFFER IdOpt SemanticsOpt AnnotationOpt '{' StructDecls '}' ';' --add\r\nCbufferDecl : T_KW_CBUFFER IdOpt SemanticsOpt AnnotationOpt '{' '}' ';' --add\r\nTbufferDecl : T_KW_TBUFFER IdOpt SemanticsOpt AnnotationOpt '{' StructDecls '}' ';' --add\r\nTbufferDecl : T_KW_TBUFFER IdOpt SemanticsOpt AnnotationOpt '{' '}' ';' --add\r\n\r\nComplexNameOpt : ComplexName --add\r\nComplexName : Id --expose\r\nComplexName : ComplexName '.' Id\r\n\r\n#if PRESETS_EX\r\n    PresetDecl : T_KW_PRESET Id AnnotationOpt PassStateBlock --add\r\n#endif\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassDecls : PassDecl --expose\r\n    PassDecls : PassDecls PassDecl\r\n    PassDecl : T_KW_PASS IdOpt AnnotationOpt PassStateBlock --add\r\n    #if PRESETS_EX\r\n    PassDecl : PresetDecl\r\n    #endif\r\n    PassDecl : ';'\r\n#endif\r\n\r\nPass11Decls : Pass11Decl --expose\r\nPass11Decls : Pass11Decls Pass11Decl\r\nPass11Decl : T_KW_PASS IdOpt AnnotationOpt StmtBlock --add\r\nPass11Decl : ';'\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassStateBlock : '{' '}' --add\r\n    PassStateBlock : '{' PassStates '}'\r\n    PassStates : PassState --expose\r\n    PassStates : PassStates PassState\r\n\r\n    PassState : Id StateIndex '=' PassStateExpr ';' --add\r\n#endif\r\n\r\n# todo: move all particles declarations to separate grammar!\r\n#if FX_PART\r\n    PartFxDecl : T_KW_FXPART ComplexNameOpt SemanticsOpt AnnotationOpt PartFxBody --add\r\n\r\n    PartFxBody : '{' '}' \r\n    PartFxBody : '{' PartFxProperties '}'\r\n\r\n    PartFxProperties : PartFxProperty --expose\r\n    PartFxProperties : PartFxProperties PartFxProperty\r\n    PartFxProperty : PassState\r\n    PartFxProperty : PassDecl\r\n#endif // FX_PART\r\n\r\nStateBlock : '{' '}' --add\r\nStateBlock : '{' States '}'\r\nStateBlock : '{' StateBlockItems '}'\r\nStateBlockItems : StateBlock  --expose\r\nStateBlockItems : StateBlock ',' StateBlockItems\r\nState : Id StateIndex '=' StateExpr ';' --add\r\nStates : State --expose\r\nStates : States State\r\n\r\nStateIndex :\r\nStateIndex : '[' Uint ']'\r\n\r\nStmtBlock : '{' '}' --add\r\nStmtBlock : '{' Stmts '}'  \r\n\r\nStmts : Stmt --expose\r\nStmts : Stmts Stmt\r\n\r\n# SimpleStmt : ERROR ';' \r\n# SimpleStmt : ';' --add\r\n\r\nSimpleStmt : Expr ';'\r\nSimpleStmt : Expr ERROR\r\nSimpleStmt : T_KW_RETURN ';'\r\nSimpleStmt : T_KW_RETURN Expr ';'\r\nSimpleStmt : T_KW_RETURN ERROR ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' Expr ')' ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' ERROR ')' ';'\r\nSimpleStmt : StmtBlock\r\nSimpleStmt : T_KW_DISCARD ';'\r\nSimpleStmt : TypeDecl\r\nSimpleStmt : VariableDecl --add\r\nSimpleStmt : VarStructDecl\r\nSimpleStmt : T_KW_BREAK ';'\r\nSimpleStmt : T_KW_BREAK ERROR\r\nSimpleStmt : T_KW_CONTINUE ';'\r\nSimpleStmt : T_KW_CONTINUE ERROR\r\n\r\n#if FX_PART\r\n    SimpleStmt : T_KW_SPAWN '(' Expr ')' NonTypeId '(' ArgumentsOpt ')' ';'\r\n    SimpleStmt : T_KW_DRAW NonTypeId '(' ArgumentsOpt ')' ';'\r\n#endif\r\n\r\n\r\nNonIfStmt : SimpleStmt --add\r\nNonIfStmt : ';'\r\nNonIfStmt : WhileStmt NonIfStmt\r\nNonIfStmt : ForStmt NonIfStmt\r\n\r\nStmt : SimpleStmt --add\r\nStmt : UseDecl\r\nStmt : WhileStmt Stmt\r\nStmt : ForStmt Stmt\r\nStmt : IfStmt Stmt\r\nStmt : IfStmt NonIfStmt T_KW_ELSE Stmt\r\nStmt : ERROR\r\nStmt : ';'\r\n\r\nIfStmt : AttributesOpt T_KW_IF '(' Expr ')' --expose\r\nIfStmt : AttributesOpt T_KW_IF '(' ERROR ')' --expose\r\n\r\nWhileStmt : T_KW_WHILE '(' Expr ')' --expose\r\nWhileStmt : T_KW_WHILE '(' ERROR ')' --expose\r\n\r\nForStmt : AttributesOpt For '(' ForInit ForCond ForStep ')' --expose\r\nForStmt : AttributesOpt For ERROR --expose\r\n\r\nFor : T_KW_FOR\r\n\r\nForInit : ';' --add\r\nForInit : Expr ';'\r\nForInit : VariableDecl\r\nForInit : ERROR ';'\r\n\r\nForCond : ';' --add\r\nForCond : Expr ';'\r\nForCond : ERROR ';'\r\n\r\nForStep : --add\r\nForStep : Expr\r\nForStep : ERROR\r\n\r\nDwordExpr : Dword\r\nDwordExpr : Dword '|' DwordExpr\r\n\r\nDwordExprSeq : DwordExpr --expose\r\nDwordExprSeq : DwordExpr ',' DwordExprSeq\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassStateExpr : DwordExpr --add\r\n    PassStateExpr : ComplexExpr\r\n    PassStateExpr : String\r\n    PassStateExpr : '{' DwordExprSeq '}'\r\n#endif\r\n\r\nStateExpr : DwordExpr --add\r\nStateExpr : ComplexExpr\r\nStateExpr : '{' InitExprs '}'\r\nStateExpr : '{' InitExprs ',' '}'\r\nStateExpr : '<' RelationalExpr '>'\r\n\r\nSimpleExpr : T_KW_TRUE\r\nSimpleExpr : T_KW_FALSE\r\nSimpleExpr : Uint\r\nSimpleExpr : Float\r\nSimpleExpr : String\r\nSimpleExpr : NonTypeId\r\n\r\nComplexExpr : '(' Expr ')'\r\nComplexExpr : TypeId '(' ArgumentsOpt ')'\r\nComplexExpr : BaseType '(' ArgumentsOpt ')' \r\nComplexExpr : NonTypeId '(' ArgumentsOpt ')'\r\nComplexExpr : PostfixPointExpr '(' ArgumentsOpt ')'\r\nComplexExpr : ObjectExpr\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    ObjectExpr : T_KW_COMPILE NonTypeId '(' ArgumentsOpt ')'\r\n    ObjectExpr : T_KW_COMPILE_FRAGMENT Target NonTypeId '(' ArgumentsOpt ')'\r\n#endif\r\n\r\nObjectExpr : T_KW_COMPILE_SHADER '(' ArgumentsOpt ')'\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectExpr : T_KW_SAMPLER_STATE StateBlock\r\n    # ObjectExpr : T_KW_STATEBLOCK_STATE StateBlocStateBlockk\r\n#endif\r\n\r\nPrimaryExpr : ComplexExpr\r\nPrimaryExpr : SimpleExpr\r\nPostfixExpr : PrimaryExpr\r\nPostfixExpr : PostfixExpr '[' Expr ']'\r\nPostfixExpr : PostfixExpr '[' ERROR ']'\r\nPostfixExpr : PostfixExpr '.' Id\r\nPostfixExpr : PostfixExpr T_OP_INC\r\nPostfixExpr : PostfixExpr T_OP_DEC\r\n\r\nPostfixPointExpr : PostfixExpr '.' Id\r\n\r\nUnaryExpr : PostfixExpr\r\nUnaryExpr : T_OP_INC UnaryExpr\r\nUnaryExpr : T_OP_DEC UnaryExpr\r\n# UnaryExpr : T_OP_INC ERROR\r\n# UnaryExpr : T_OP_DEC ERROR\r\nUnaryExpr : '!' CastExpr\r\nUnaryExpr : '~' CastExpr\r\n# UnaryExpr : '!' ERROR\r\nUnaryExpr : '-' CastExpr\r\nUnaryExpr : '+' CastExpr\r\n\r\nCastExpr : UnaryExpr\r\nCastExpr : '(' ConstTypeDim ')' CastExpr\r\nCastExpr : '(' ERROR ')' CastExpr\r\n\r\nMulExpr : CastExpr\r\nMulExpr : MulExpr '*' CastExpr\r\nMulExpr : MulExpr '/' CastExpr\r\nMulExpr : MulExpr '%' CastExpr\r\n\r\nMulExpr : ERROR '*' CastExpr\r\nMulExpr : ERROR '/' CastExpr\r\nMulExpr : ERROR '%' CastExpr\r\nMulExpr : MulExpr '*' ERROR\r\nMulExpr : MulExpr '/' ERROR\r\nMulExpr : MulExpr '%' ERROR\r\n# MulExpr : ERROR '*' ERROR\r\n# MulExpr : ERROR '/' ERROR\r\n# MulExpr : ERROR '%' ERROR\r\n\r\nAddExpr : MulExpr\r\nAddExpr : AddExpr '+' MulExpr\r\nAddExpr : AddExpr '-' MulExpr\r\n\r\nAddExpr : AddExpr '+' ERROR\r\nAddExpr : AddExpr '-' ERROR\r\n\r\nShiftExpr : AddExpr\r\nShiftExpr : ShiftExpr T_OP_SL AddExpr\r\nShiftExpr : ShiftExpr T_OP_SR AddExpr\r\n\r\nShiftExpr : ShiftExpr T_OP_SR ERROR\r\nShiftExpr : ShiftExpr T_OP_SL ERROR\r\n\r\nRelationalExpr : ShiftExpr\r\nRelationalExpr : RelationalExpr '<' ShiftExpr\r\nRelationalExpr : RelationalExpr '>' ShiftExpr\r\nRelationalExpr : RelationalExpr T_OP_LE ShiftExpr\r\nRelationalExpr : RelationalExpr T_OP_GE ShiftExpr\r\n\r\nRelationalExpr : ERROR '<' ShiftExpr\r\nRelationalExpr : RelationalExpr '<' ERROR\r\nRelationalExpr : ERROR '<' ERROR\r\n\r\nRelationalExpr : RelationalExpr '>' ERROR\r\nRelationalExpr : ERROR '>' ShiftExpr\r\nRelationalExpr : ERROR '>' ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_LE ERROR\r\nRelationalExpr : ERROR T_OP_LE ShiftExpr\r\nRelationalExpr : ERROR T_OP_LE ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_GE ERROR\r\nRelationalExpr : ERROR T_OP_GE ShiftExpr\r\nRelationalExpr : ERROR T_OP_GE ERROR\r\n\r\nEqualityExpr : RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE RelationalExpr\r\nEqualityExpr : ERROR T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE ERROR\r\nEqualityExpr : ERROR T_OP_NE ERROR\r\n\r\nAndExpr : EqualityExpr\r\nAndExpr : AndExpr '&' EqualityExpr\r\nAndExpr : ERROR '&' EqualityExpr\r\nAndExpr : AndExpr '&' ERROR\r\n\r\nExclusiveOrExpr : AndExpr\r\nExclusiveOrExpr : ExclusiveOrExpr '^' AndExpr\r\nExclusiveOrExpr : ERROR '^' AndExpr\r\nExclusiveOrExpr : ExclusiveOrExpr '^' ERROR\r\n\r\nInclusiveOrExpr : ExclusiveOrExpr\r\nInclusiveOrExpr : InclusiveOrExpr '|' ExclusiveOrExpr\r\nInclusiveOrExpr : ERROR '|' ExclusiveOrExpr\r\nInclusiveOrExpr : InclusiveOrExpr '|' ERROR\r\n\r\nLogicalAndExpr : InclusiveOrExpr\r\nLogicalAndExpr : LogicalAndExpr T_OP_AND InclusiveOrExpr\r\nLogicalAndExpr : ERROR T_OP_AND InclusiveOrExpr\r\nLogicalAndExpr : LogicalAndExpr T_OP_AND ERROR\r\n\r\nLogicalOrExpr : LogicalAndExpr\r\nLogicalOrExpr : LogicalOrExpr T_OP_OR LogicalAndExpr\r\nLogicalOrExpr : ERROR T_OP_OR LogicalAndExpr\r\nLogicalOrExpr : LogicalOrExpr T_OP_OR ERROR\r\n\r\nConditionalExpr : LogicalOrExpr\r\nConditionalExpr : LogicalOrExpr '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : ERROR '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : LogicalOrExpr '?' ERROR ':' ConditionalExpr\r\nConditionalExpr : LogicalOrExpr '?' AssignmentExpr ':' ERROR\r\nConditionalExpr : LogicalOrExpr '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ConditionalExpr\r\n\r\nAssignmentExpr : ConditionalExpr\r\nAssignmentExpr : CastExpr '=' AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_ME AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_DE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_RE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_AE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_BORE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_BANDE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_XORE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SRE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SLE AssignmentExpr\r\n\r\nArguments : AssignmentExpr --expose\r\nArguments : Arguments ',' AssignmentExpr\r\nArguments : Arguments ERROR AssignmentExpr\r\nArguments : Arguments ',' ERROR\r\nArgumentsOpt : --expose\r\nArgumentsOpt : Arguments\r\n\r\nInitExpr : AssignmentExpr --add\r\nInitExpr : '{' InitExprs '}'\r\nInitExpr : '{' InitExprs ',' '}'\r\nInitExprs : InitExpr --expose\r\nInitExprs : InitExprs ',' InitExpr\r\n\r\nConstantExpr : AssignmentExpr\r\nExpr : AssignmentExpr\r\nExpr : Expr ',' AssignmentExpr\r\nExpr : Expr ',' ERROR\r\nExpr : ERROR ',' ERROR\r\nExpr : ERROR ',' AssignmentExpr\r\n\r\nDword : Uint\r\nDword : '-' Uint\r\nDword : Float\r\nDword : '-' Float\r\nDword : DwordId\r\nDword : Uint DwordId\r\nDwordId : Id\r\nDwordId : T_KW_TRUE\r\nDwordId : T_KW_FALSE\r\nDwordId : T_KW_TEXTURE\r\n\r\nId : TypeId\r\nId : NonTypeId\r\nIdOpt :\r\nIdOpt : Id\r\n\r\nTarget : NonTypeId\r\n\r\nUint : T_UINT\r\nFloat : T_FLOAT\r\n\r\nStrings : String\r\nStrings : Strings String\r\nString : T_STRING\r\n\r\nTypeId : T_TYPE_ID\r\nNonTypeId : T_NON_TYPE_ID\r\n\r\nLineTerminator : T_LINE_TERMINATOR\r\n\r\nAsmDecl : T_KW_DECL '{'\r\nAsm : T_KW_ASM '{'\r\nAsmFragment : T_KW_ASM_FRAGMENT '{'\r\n\r\n--LEXER--\r\n\r\nT_KW_UNSIGNED : \"unsigned\"\r\nT_KW_PRECISE : \"precise\"\r\nT_KW_STATIC : \"static\"\r\nT_KW_NOINTERPOLATION : \"nointerpolation\"\r\nT_KW_CENTROID : \"centroid\"\r\nT_KW_NOPERSPECTIVE : \"noperspective\"\r\nT_KW_UNIFORM : \"uniform\"\r\nT_KW_EXTERN : \"extern\"\r\nT_KW_VOLATILE : \"volatile\"\r\nT_KW_INLINE : \"inline\"\r\nT_KW_CONST : \"const\"\r\nT_KW_ROW_MAJOR : \"row_major\"\r\nT_KW_COLUMN_MAJOR : \"column_major\"\r\nT_KW_TYPEDEF : \"typedef\"\r\nT_KW_STRUCT : \"struct\"\r\nT_KW_VOID : \"void\"\r\nT_KW_BOOL : \"bool\"\r\nT_KW_INT : \"int\"\r\nT_KW_UINT : \"uint\"\r\nT_KW_HALF : \"half\"\r\nT_KW_FLOAT : \"float\"\r\nT_KW_DOUBLE : \"double\"\r\nT_KW_VECTOR : \"vector\"\r\nT_KW_MATRIX : \"matrix\"\r\nT_KW_STRING : \"string\"\r\nT_KW_TEXTURE : \"Texture\"\r\nT_KW_TEXTURE1D : \"Texture1D\"\r\nT_KW_TEXTURE2D : \"Texture2D\"\r\nT_KW_TEXTURE2DARRAY : \"Texture2DArray\"\r\nT_KW_TEXTURE3D : \"Texture3D\"\r\nT_KW_TEXTURECUBE : \"TextureCube\"\r\nT_KW_TEXTURECUBEARRAY : \"TextureCubeArray\"\r\nT_KW_CBUFFER : \"cbuffer\"\r\nT_KW_TBUFFER : \"tbuffer\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # T_KW_SAMPLER : \"sampler\"\r\n    # T_KW_SAMPLER1D : \"sampler1D\"\r\n    # T_KW_SAMPLER2D : \"sampler2D\"\r\n    # T_KW_SAMPLER3D : \"sampler3D\"\r\n    # T_KW_SAMPLERCUBE : \"samplerCUBE\"\r\n    # T_KW_STATEBLOCK : \"stateblock\"\r\n    # T_KW_STATEBLOCK_STATE : \"stateblock_state\"\r\n#endif\r\nT_KW_SAMPLER_STATE : \"SamplerState\"\r\nT_KW_SAMPLER_COMPARISON_STATE : \"SamplerComparisonState\"\r\nT_KW_DEPTH_STENCIL_STATE : \"DepthStencilState\"\r\nT_KW_BLEND_STATE : \"BlendState\"\r\nT_KW_RASTERIZER_STATE : \"RasterizerState\"\r\nT_KW_BUFFER : \"Buffer\"\r\nT_KW_RWTEXTURE1D : \"RWTexture1D\"\r\nT_KW_RWTEXTURE2D : \"RWTexture2D\"\r\nT_KW_RWTEXTURE3D : \"RWTexture3D\"\r\nT_KW_RWBUFFER : \"RWBuffer\"\r\nT_KW_STRUCTUREDBUFFER : \"StructuredBuffer\"\r\nT_KW_RWSTRUCTUREDBUFFER : \"RWStructuredBuffer\"\r\nT_KW_APPENDSTRUCTUREDBUFFER : \"AppendStructuredBuffer\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # T_KW_PIXELSHADER : \"pixelshader\"\r\n    # T_KW_VERTEXSHADER : \"vertexshader\"\r\n    # T_KW_PIXELFRAGMENT : \"pixelfragment\"\r\n    # T_KW_VERTEXFRAGMENT : \"vertexfragment\"\r\n#endif\r\nT_KW_REGISTER : \"register\"\r\nT_KW_IN : \"in\"\r\nT_KW_OUT : \"out\"\r\nT_KW_INOUT : \"inout\"\r\nT_KW_TECHNIQUE : \"technique\"\r\nT_KW_TECHNIQUE11 : \"technique11\"\r\n#if PRESETS_EX\r\n    T_KW_PRESET : \"preset\"\r\n#endif\r\n#if FX_PART\r\n    T_KW_FXPART : \"partFx\"\r\n    T_KW_TRIMESH : \"TriMesh\"\r\n#endif\r\nT_KW_PASS : \"pass\"\r\nT_KW_RETURN : \"return\"\r\nT_KW_DO : \"do\"\r\nT_KW_DISCARD : \"discard\"\r\nT_KW_WHILE : \"while\"\r\nT_KW_IF : \"if\"\r\nT_KW_ELSE : \"else\"\r\nT_KW_FOR : \"for\"\r\nT_KW_TRUE : \"true\"\r\nT_KW_FALSE : \"false\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    T_KW_COMPILE : \"compile\"\r\n    T_KW_COMPILE_SHADER : \"CompileShader\"\r\n#endif\r\nT_KW_COMPILE_FRAGMENT : \"compile_fragment\"\r\nT_KW_DECL : \"decl\"\r\nT_KW_ASM : \"asm\"\r\nT_KW_ASM_FRAGMENT : \"asm_fragment\"\r\nT_KW_USE : \"use\"\r\nT_KW_STRICT : \"strict\"\r\n#id FX_PART\r\n    T_KW_IMPORT : \"import\"\r\n    T_KW_PROVIDE : \"provide\"\r\n#endif\r\nT_KW_SWITCH : \"switch\"\r\nT_KW_CASE : \"case\"\r\nT_KW_DEFAULT : \"default\"\r\nT_KW_BREAK : \"break\"\r\n#if FX_PART\r\n    T_KW_SPAWN : \"spawn\"\r\n    T_KW_DRAW : \"draw\"\r\n#endif\r\nT_KW_CONTINUE : \"continue\"\r\n# T_KW_AS : \"as\"\r\nT_OP_INC : \"++\"\r\nT_OP_DEC : \"--\"\r\nT_OP_LE : \">=\"\r\nT_OP_GE : \"<=\"\r\nT_OP_EQ : \"==\"\r\nT_OP_NE : \"!=\"\r\nT_OP_AND : \"&&\"\r\nT_OP_OR : \"||\"\r\nT_OP_ME : \"*=\"\r\nT_OP_DE : \"/=\"\r\nT_OP_RE : \"%=\"\r\nT_OP_AE : \"+=\"\r\nT_OP_SE : \"-=\"\r\nT_OP_SR : \">>\"\r\nT_OP_SL : \"<<\"\r\nT_OP_BORE : \"|=\"\r\nT_OP_BANDE : \"&=\"\r\nT_OP_XORE : \"^=\"\r\nT_OP_SRE : \">>=\"\r\nT_OP_SLE : \"<<=\"\r\n";

/***/ }),

/***/ "ZIrC":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEndpoint": () => (/* binding */ createEndpoint),
/* harmony export */   "expose": () => (/* binding */ expose),
/* harmony export */   "proxy": () => (/* binding */ proxy),
/* harmony export */   "proxyMarker": () => (/* binding */ proxyMarker),
/* harmony export */   "releaseProxy": () => (/* binding */ releaseProxy),
/* harmony export */   "transfer": () => (/* binding */ transfer),
/* harmony export */   "transferHandlers": () => (/* binding */ transferHandlers),
/* harmony export */   "windowEndpoint": () => (/* binding */ windowEndpoint),
/* harmony export */   "wrap": () => (/* binding */ wrap)
/* harmony export */ });
/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function expose(obj, ep = self) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case "GET" /* GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case "SET" /* SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case "APPLY" /* APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case "CONSTRUCT" /* CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case "ENDPOINT" /* ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case "RELEASE" /* RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
                default:
                    return;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE" /* RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
            }
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function createProxy(ep, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    return requestResponseMessage(ep, {
                        type: "RELEASE" /* RELEASE */,
                        path: path.map((p) => p.toString()),
                    }).then(() => {
                        closeEndPoint(ep);
                        isProxyReleased = true;
                    });
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, {
                    type: "GET" /* GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously \_()_/
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
                type: "SET" /* SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, {
                    type: "ENDPOINT" /* ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didnt happen.
            if (last === "bind") {
                return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "APPLY" /* APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "CONSTRUCT" /* CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = self, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: "HANDLER" /* HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: "RAW" /* RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case "HANDLER" /* HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case "RAW" /* RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
        });
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader/index.js??ruleSet[1].rules[1]!./src/sandbox/containers/editor/LanguageServiceProvider.ts ***!
  \*************************************************************************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/SLParser */ "/oCY");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_language_service_LanguageService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/language-service/LanguageService */ "w9mJ");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! comlink */ "ZIrC");
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode-languageserver-types */ "+C5w");





/* tslint:disable:typedef */
/* tslint:disable:no-empty */
/* tslint:disable:forin */
/* tslint:disable:no-for-in */
// supress all console messages for debugging/development purposes
// import NULL_LOGGER from '@lib/util/NullLogger';
// console = <any>NULL_LOGGER;
function asTextDocument({ _content, _languageId, _lineOffsets, _uri, _version }) {
    return vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.TextDocument.create(_uri, _languageId, _version, _content);
}
function asDiagnostic(diagEntry) {
    const { code, content, start, end, category } = diagEntry;
    const severities = {
        [_lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error]: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.DiagnosticSeverity.Error,
        [_lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Warning]: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.DiagnosticSeverity.Warning
    };
    return {
        range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_3__.Range.create(start.line, start.column, (end || start).line, (end || start).column),
        severity: severities[category],
        code,
        message: content,
        source: `${start.file}`
    };
}
function resolveLocation(src, slastDocument) {
    if (!slastDocument) {
        return null;
    }
    const { includes, uri } = slastDocument;
    let dst = src;
    while (dst && String(uri) !== String(dst.start.file)) {
        dst = includes.get(String(dst.start.file));
    }
    return dst;
}
class LanguageServiceProvider {
    constructor() {
        this.documents = new Map();
    }
    init(parserParams, parsingFlags, includeResolver, defines) {
        console.log('%c Creating parser for language service provider...', 'background: #222; color: #bada55');
        try {
            (0,_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_0__.createDefaultSLParser)(parserParams);
            console.log('%c [ DONE ]', 'background: #222; color: #bada55');
        }
        catch (e) {
            console.error('could not initialize parser.');
            return null;
        }
        this.service = (0,_lib_language_service_LanguageService__WEBPACK_IMPORTED_MODULE_2__.getLanguageService)({ flags: parsingFlags, includeResolver, defines });
    }
    async validate(rawDocument) {
        const textDocument = asTextDocument(rawDocument);
        const slastDocument = await this.service.$parseSLASTDocument(textDocument);
        const slDocument = await this.service.$parseSLDocument(slastDocument);
        this.documents.set(textDocument.uri, { textDocument, slastDocument, slDocument });
        slDocument.diagnosticReport.messages.forEach(msg => {
            const loc = resolveLocation(msg, slastDocument);
            if (!loc) {
                return;
            }
            const { start, end } = loc;
            msg.start = start;
            msg.end = end;
        });
        // IP: skip deprecations
        return slDocument.diagnosticReport.messages.filter(msg => msg.code !== 'A3008').map(asDiagnostic);
    }
    async provideFxCodeLenses(textDocumentIdentifier) {
        if (!this.service) {
            return [];
        }
        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);
        return this.service.doFxCodeLenses(textDocument, slDocument);
    }
    async provideSignatureHelp(textDocumentIdentifier, position) {
        if (!this.service) {
            return null;
        }
        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);
        return this.service.doSignatureHelp(textDocument, position, slDocument);
    }
    // async provideUnreachableCodeBlocks(textDocumentIdentifier: TextDocumentIdentifier): Promise<Range[]> {
    //     if (!this.service) {
    //         return null;
    //     }
    //     const { textDocument, slastDocument } = await this.getDocument(textDocumentIdentifier);
    //     if (!slastDocument) {
    //         return [];
    //     }
    //     // return slastDocument.unreachableCode.map(range => Range.create(Position.create(), Position.create()));
    //     return [];
    // }
    getDocument(textDocumentIdentifier) {
        if (!this.documents.has(textDocumentIdentifier.uri)) {
            console.warn('could not find document', textDocumentIdentifier.uri);
            return { textDocument: null, slastDocument: null, slDocument: null };
        }
        return this.documents.get(textDocumentIdentifier.uri);
    }
}
comlink__WEBPACK_IMPORTED_MODULE_4__.expose(new LanguageServiceProvider());

})();

/******/ })()
;
//# sourceMappingURL=LanguageServiceProvider.904af4e6f0129f42227d.worker.js.map