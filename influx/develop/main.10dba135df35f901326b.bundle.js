(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "+Z36":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TechniqueInstruction.ts ***!
  \******************************************************************/
/*! exports provided: TechniqueInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TechniqueInstruction", function() { return TechniqueInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "mXWi");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



class TechniqueInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__["DeclInstruction"] {
    constructor({ name, techniqueType, passList, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_TechniqueDecl, ...settings });
        this._name = name;
        this._passList = passList.map(pass => _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(pass, this));
        this._techniqueType = techniqueType;
    }
    // todo: add id support?
    // get id();
    get name() {
        return this._name;
    }
    get passList() {
        return this._passList;
    }
    get type() {
        return this._techniqueType;
    }
}


/***/ }),

/***/ "/Wjm":
/*!**************************!*\
  !*** ./src/lib/bf/bf.ts ***!
  \**************************/
/*! exports provided: flag, testBit, testAll, testAny, setBit, clearBit, setAll, clearAll, equal, isEqual, isNotEqaul, set, clear, setFlags, clearFlags, isEmpty, totalBits, totalSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flag", function() { return flag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testBit", function() { return testBit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testAll", function() { return testAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testAny", function() { return testAny; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBit", function() { return setBit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearBit", function() { return clearBit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAll", function() { return setAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAll", function() { return clearAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return equal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNotEqaul", function() { return isNotEqaul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFlags", function() { return setFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearFlags", function() { return clearFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "totalBits", function() { return totalBits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "totalSet", function() { return totalSet; });
/**
 * Сдвиг единицы на @a x позиций влево.
 */
var flag = (x) => (1 << (x));
/**
 * Проверка того что у @a value бит под номером @a bit равен единице.
 */
var testBit = (value, bit) => ((value & flag(bit)) != 0);
/**
 * Проверка того что у @a value равны единице все биты,
 * которые равны единице у @a set.
 */
var testAll = (value, set) => (((value) & (set)) == (set));
/**
 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 * которые равны единице у @a set.
 */
var testAny = (value, set) => (((value) & (set)) != 0);
/**
 * Выставляет бит под номером @a bit у числа @a value равным единице
 */
var setBit = (value, bit, setting = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
 *
 */
var clearBit = (value, bit) => ((value) &= ~flag((bit)));
/**
 * Выставляет бит под номером @a bit у числа @a value равным нулю
 */
var setAll = (value, set, setting = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));
/**
 * Выставляет все биты у числа @a value равными единице,
 * которые равны единице у числа @a set
 */
var clearAll = (value, set) => ((value) &= ~(set));
/**
 * Выставляет все биты у числа @a value равными нулю,
 * которые равны единице у числа @a set
 */
var equal = (value, src) => { value = src; };
/**
 * Прирасваивает числу @a value число @a src
 */
var isEqual = (value, src) => value == src;
/**
 * Если число @a value равно числу @a src возвращается true
 */
var isNotEqaul = (value, src) => value != src;
/**
 * Прирасваивает числу @a value число @a src
 */
var set = (value, src) => { value = src; };
/**
 * Обнуляет число @a value
 */
var clear = (value) => { value = 0; };
/**
 * Выставляет все биты у числа @a value равными единице,
 * которые равны единице у числа @a src
 */
var setFlags = (value, src) => (value |= src);
/**
 * Выставляет все биты у числа @a value равными нулю,
 * которые равны единице у числа @a src
 */
var clearFlags = (value, src) => value &= ~src;
/**
 * Проверяет равно ли число @a value нулю. Если равно возвращает true.
 * Если не равно возвращает false.
 */
var isEmpty = (value) => (value == 0);
/**
 * Возвращает общее количество бит числа @a value.
 * На самом деле возвращает всегда 32.
 */
var totalBits = (value) => 32;
/**
 * Возвращает общее количество ненулевых бит числа @a value.
 */
var totalSet = (value) => {
    var count = 0;
    var total = totalBits(value);
    for (var i = total; i; --i) {
        count += (value & 1);
        value >>= 1;
    }
    return (count);
};


/***/ }),

/***/ "/oOw":
/*!***************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/expression.ts ***!
  \***************************************************/
/*! exports provided: expression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expression", function() { return expression; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");


var expression;
(function (expression) {
    /**
     * unwind operation returns declaration in case of correct l-value expression;
     */
    function unwind(expr) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(expr)) {
            return null;
        }
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_PostfixPointExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_PostfixIndexExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_IdExpr:
                return expr.decl;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ArithmeticExpr:
                // arithmetic expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_InitExpr:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'init expression doesn\'t support unwind operation');
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_AssignmentExpr:
                // todo: reseach how it work in HLSL
                //// assigment expression returns right-hand value;
                return unwind(expr.left);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_CastExpr:
                // cast expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_UnaryExpr:
                // unary expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_RelationalExpr:
                // relation expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ConstructorCallExpr:
                // ctor call expression is not allowed as l-value;
                // todo: allow it?
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ComplexExpr:
                return unwind(expr.expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_StringExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_BoolExpr:
                // literal cannot be a left-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_FunctionCallExpr:
                // function call expression returns right-hand value;
                return null;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, "unsupported expr found");
                return null;
        }
    }
    expression.unwind = unwind;
})(expression || (expression = {}));


/***/ }),

/***/ "/zHR":
/*!*************************************!*\
  !*** ./src/lib/util/Diagnostics.ts ***!
  \*************************************/
/*! exports provided: DiagnosticException, Diagnostics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticException", function() { return DiagnosticException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Diagnostics", function() { return Diagnostics; });
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "zX2+");

function locToString(loc) {
    return `${loc.line},${loc.column}`;
}
function rangeToString(range) {
    return `${locToString(range.start)}:${locToString(range.end)}`;
}
function readKey(desc, key) {
    let keyParts = key.split('.');
    if (keyParts.length > 1) {
        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));
    }
    return desc[keyParts[0]];
}
function fillPattern(pattern, desc) {
    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {
        return readKey(desc, key);
    });
}
class DiagnosticException extends Error {
    constructor(host, mesg) {
        super(mesg.content);
        Error.captureStackTrace(this, DiagnosticException);
    }
}
class Diagnostics {
    constructor(name, codePrefix) {
        this._name = name;
        this._codePrefix = (codePrefix || '').toUpperCase();
        this.reset();
    }
    emitException() {
        throw new DiagnosticException(this, this.getLastError());
    }
    reset() {
        this._entries = [];
    }
    resolve() {
        let report = { errors: 0, warnings: 0, messages: [] };
        for (let entry of this._entries) {
            let message = this.resolveEntry(entry);
            switch (message.category) {
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Warning:
                    report.warnings++;
                    break;
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Error:
                    report.errors++;
                    break;
            }
            report.messages.push(message);
        }
        return report;
    }
    resolveEntry(entry) {
        // let { category, desc } = entry;
        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();
        let loc = null;
        let range;
        let start;
        let end;
        let file = this.resolveFilename(entry.code, entry.desc);
        if (range = this.resolveRange(entry.code, entry.desc)) {
            ({ start, end } = range);
            loc = rangeToString(range);
        }
        else {
            start = this.resolvePosition(entry.code, entry.desc);
            loc = locToString(start);
        }
        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;
        let code = `${this._codePrefix}${entry.code}`;
        let category = entry.category;
        return { code, category, content, file, start, end };
    }
    resolveFilename(code, desc) {
        return '[unknown]';
    }
    resolvePosition(code, desc) {
        return { file: null, line: 0, column: 0 };
    }
    resolveRange(code, desc) {
        return null;
    }
    resolveDescription(code, category, desc) {
        let diagMesgs = this.diagnosticMessages();
        if (!diagMesgs) {
            console.error(`Diagnostic messages of '${this._name}' not found.`);
            return '[no description found]';
        }
        if (!diagMesgs[code]) {
            return `[no description found for code '${code}']`;
        }
        return fillPattern(diagMesgs[code], desc);
    }
    diagnosticMessages() {
        return null;
    }
    error(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Error, code, desc });
    }
    warning(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Warning, code, desc });
    }
    // add error and emit an exception in order to interrupt processing
    critical(code, desc) {
        this.error(code, desc);
        this.emitException();
    }
    prettyPrint() {
        return null; //JSON.stringify(this._errors, null, '\t');
    }
    hasErrors() {
        return this._entries.filter(entry => entry.category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Error).length > 0;
    }
    getLastError() {
        for (let i = this._entries.length - 1; i >= 0; --i) {
            if (this._entries[i].category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_0__["EDiagnosticCategory"].k_Error) {
                return this.resolveEntry(this._entries[i]);
            }
        }
        return null;
    }
    static mergeReports(reportList) {
        let result = { errors: 0, warnings: 0, messages: [] };
        reportList.forEach((report) => {
            result.errors += report.errors;
            result.warnings += report.warnings;
            result.messages = result.messages.concat(report.messages);
        });
        return result;
    }
    static stringify(report) {
        return report.messages.map(mesg => mesg.content).join('\n');
    }
    static asRange(mesg) {
        let range = { start: mesg.start, end: mesg.end };
        if (!range.end) {
            range.end = { ...range.start };
        }
        const { start, end } = range;
        if (end.line == start.line && end.column == start.column) {
            end.column += 1;
        }
        return range;
    }
}


/***/ }),

/***/ 0:
/*!*********************************************************************!*\
  !*** multi ./src/sandbox/index.tsx ./src/sandbox/index-webpack.pug ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! d:\WEB\GitHub\akra-legacy/src/sandbox/index.tsx */"qUwp");
module.exports = __webpack_require__(/*! d:\WEB\GitHub\akra-legacy/src/sandbox/index-webpack.pug */"WZwn");


/***/ }),

/***/ "0DIJ":
/*!************************************!*\
  !*** ./src/lib/fx/FXSLDocument.ts ***!
  \************************************/
/*! exports provided: createFXSLDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFXSLDocument", function() { return createFXSLDocument; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analisys/FxAnalyzer */ "KjJp");
/* harmony import */ var _SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SLASTDocument */ "ahmV");



async function createFXSLDocument(param1, param2, param3) {
    let textDocument;
    let slastDocument;
    let slDocument;
    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(arguments[0].source)) {
        const flags = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(arguments[1]) ? arguments[1] : undefined;
        textDocument = arguments[0];
        slastDocument = await Object(_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__["createSLASTDocument"])(textDocument, flags);
        slDocument = arguments[2];
    }
    else {
        slastDocument = arguments[0];
        slDocument = arguments[1];
    }
    const analyzer = new _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__["FxAnalyzer"];
    return await analyzer.parse(slastDocument, slDocument);
}


/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "1O8D":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IfStmtInstruction.ts ***!
  \***************************************************************/
/*! exports provided: IfStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IfStmtInstruction", function() { return IfStmtInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");




/**
 * Represent if(expr) stmt or if(expr) stmt else stmt
 * ( if || if_else ) Expr Stmt [Stmt]
 */
class IfStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__["StmtInstruction"] {
    constructor({ cond, conseq, attributes = null, contrary = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_IfStmt, ...settings });
        this.cond = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(cond, this);
        this.conseq = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(conseq, this);
        this.contrary = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(contrary, this);
        this.attributes = (attributes || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(attr, this));
    }
    toCode() {
        var code = "";
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.contrary)) {
            code += "if(";
            code += this.cond.toCode() + ")";
            code += this.conseq.toCode();
        }
        else {
            code += "if(";
            code += this.cond.toCode() + ") ";
            code += this.conseq.toCode();
            code += "else ";
            code += this.contrary.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "2D+5":
/*!*************************************!*\
  !*** ./src/lib/parser/ParseTree.ts ***!
  \*************************************/
/*! exports provided: ParseTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParseTree", function() { return ParseTree; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "wYUO");



class ParseTree {
    constructor(optimized, root = null) {
        this.root = root;
        this.nodes = [];
        this.optimized = optimized;
        this.nodesCountStack = [];
    }
    get lastNode() {
        return this.nodes[this.nodes.length - 1];
    }
    finishTree() {
        this.root = this.nodes.pop();
    }
    addToken({ name, value, loc }) {
        const children = null;
        const parent = null;
        this.addNode({ name, value, loc, children, parent });
    }
    reduceByRule(rule, eCreate = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["ENodeCreateMode"].k_Default) {
        let iReduceCount = 0;
        let nodesCountStack = this.nodesCountStack;
        let ruleLength = rule.right.length;
        let nodes = this.nodes;
        let optimize = this.optimized ? 1 : 0;
        while (ruleLength) {
            iReduceCount += nodesCountStack.pop();
            ruleLength--;
        }
        if (eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["ENodeCreateMode"].k_Skip && iReduceCount > optimize) {
            nodes.length -= iReduceCount;
            nodesCountStack.push(0);
        }
        else if ((eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["ENodeCreateMode"].k_Default && iReduceCount > optimize) ||
            (eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["ENodeCreateMode"].k_Necessary)) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(iReduceCount > 0);
            let temp = nodes.pop();
            iReduceCount--;
            const name = rule.left;
            // TODO: use correct location in case of include macro. 
            const loc = { ...temp.loc };
            const node = { name, children: null, parent: null, value: '', loc };
            this.addLink(node, temp);
            while (iReduceCount) {
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(nodes.length > 0);
                this.addLink(node, nodes.pop());
                iReduceCount--;
            }
            nodes.push(node);
            nodesCountStack.push(1);
        }
        else {
            nodesCountStack.push(iReduceCount);
        }
    }
    addNode(node) {
        this.nodes.push(node);
        this.nodesCountStack.push(1);
    }
    $pop(loc = null) {
        let count = this.nodesCountStack.pop();
        while (count) {
            let node = this.nodes.pop();
            if (loc) {
                Object(_util__WEBPACK_IMPORTED_MODULE_2__["extendRange"])(loc, node.loc);
            }
            count--;
        }
    }
    addLink(parent, child) {
        parent.children = parent.children || [];
        Object(_util__WEBPACK_IMPORTED_MODULE_2__["extendRange"])(parent.loc, child.loc);
        parent.children.push(child);
        child.parent = parent;
    }
    /** @deprecated */
    clone() {
        return new ParseTree(this.optimized, this.cloneNode(this.root));
    }
    /** @deprecated */
    // FIXME: location should be clonned too
    cloneNode({ name, value, children }) {
        const clone = { name, value, children: null, parent: null };
        if (children) {
            children.forEach(child => this.addLink(clone, this.cloneNode(child)));
        }
        return clone;
    }
    /** @deprecated */
    toString() {
        if (this.root) {
            return this.toStringNode(this.root);
        }
        return '';
    }
    /** @deprecated */
    toStringNode(node, padding = "") {
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "name : \"" + node.name + "\"" + ",\n";
            res += padding + "value : \"" + node.value + "\"" + "\n";
        }
        else {
            res += padding + "name : \"" + node.name + "\"" + "\n";
            res += padding + "children : [";
            let children = node.children;
            if (children) {
                res += "\n";
                padding += defaultPadding;
                for (let i = children.length - 1; i >= 0; i--) {
                    res += this.toStringNode(children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
    /** @deprecated */
    toHTMLString(node, padding = "") {
        node = node || this.root;
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "<b style=\"color: #458383;\">name</b>: \"" + node.name + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">value</b>: \"" + node.value + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
        }
        else {
            let i;
            res += padding + "<i style=\"color: #8A2BE2;\">name</i>: \"" + node.name + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
            res += padding + "<i style=\"color: #8A2BE2;\">children</i>: [";
            if (node.children) {
                res += "\n";
                padding += defaultPadding;
                for (i = node.children.length - 1; i >= 0; i--) {
                    res += this.toHTMLString(node.children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
}


/***/ }),

/***/ "2b0+":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Instruction.ts ***!
  \*********************************************************/
/*! exports provided: Instruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Instruction", function() { return Instruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");


class Instruction {
    constructor({ scope, instrType /* = EInstructionTypes.k_Instruction*/, sourceNode = null, visible = true }) {
        this._sourceNode = sourceNode;
        this._instructionType = instrType;
        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);
        this._scope = scope;
        this._parent = null;
        this._lastError = null;
    }
    get parent() {
        // console.assert(this._parent, "Parent is not defined!");
        return this._parent;
    }
    get instructionType() {
        console.assert(this._instructionType != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_Instruction, "Instruction type 'k_Instruction' is forbidden.");
        return this._instructionType;
    }
    get instructionName() {
        return _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"][this.instructionType];
    }
    get instructionID() {
        return this._instructionID;
    }
    get scope() {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._scope)) {
            return this._scope;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.parent)) {
            return this.parent.scope;
        }
        return null;
    }
    get sourceNode() {
        return this._sourceNode;
    }
    _getLastError() {
        return this._lastError;
    }
    _setError(eCode, pInfo = null) {
        this._lastError = { code: eCode, info: pInfo };
    }
    _clearError() {
        this._lastError = null;
    }
    _isErrorOccured() {
        return !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._lastError);
    }
    /**
     * Check that instuction is valid.
     */
    _check(eStage, pInfo = null) {
        if (this._isErrorOccured()) {
            return false;
        }
        else {
            return true;
        }
    }
    toString() {
        console.error("@pure_virtual");
        return null;
    }
    toCode() {
        console.error("@pure_virtual");
        return null;
    }
    $withParent(parent) {
        console.assert(this._parent == null, "parent redefenition detected!");
        if (this.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_SystemType && this.name === 'float' && this._parent == null && parent != null) {
            debugger;
        }
        this._parent = parent;
        // todo: remove this hack!
        return this;
    }
    // An auxiliary function created to maintain the clarity of the code.
    $withNoParent() {
        return this;
    }
    static $withParent(child, parent) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(child)) {
            return null;
        }
        return child.$withParent(parent);
    }
    static $withNoParent(child) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(child)) {
            return null;
        }
        return child.$withNoParent();
    }
}
Instruction.INSTRUCTION_COUNTER = 0;


/***/ }),

/***/ "2blz":
/*!*******************************************!*\
  !*** ./src/lib/idl/ERenderStateValues.ts ***!
  \*******************************************/
/*! exports provided: ERenderStateValues */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERenderStateValues", function() { return ERenderStateValues; });
var ERenderStateValues;
(function (ERenderStateValues) {
    ERenderStateValues[ERenderStateValues["UNDEF"] = 0] = "UNDEF";
    ERenderStateValues[ERenderStateValues["TRUE"] = 1] = "TRUE";
    ERenderStateValues[ERenderStateValues["FALSE"] = 2] = "FALSE";
    ERenderStateValues[ERenderStateValues["ZERO"] = 3] = "ZERO";
    ERenderStateValues[ERenderStateValues["ONE"] = 4] = "ONE";
    ERenderStateValues[ERenderStateValues["SRCCOLOR"] = 5] = "SRCCOLOR";
    ERenderStateValues[ERenderStateValues["INVSRCCOLOR"] = 6] = "INVSRCCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHA"] = 7] = "SRCALPHA";
    ERenderStateValues[ERenderStateValues["INVSRCALPHA"] = 8] = "INVSRCALPHA";
    ERenderStateValues[ERenderStateValues["DESTALPHA"] = 9] = "DESTALPHA";
    ERenderStateValues[ERenderStateValues["INVDESTALPHA"] = 10] = "INVDESTALPHA";
    ERenderStateValues[ERenderStateValues["DESTCOLOR"] = 11] = "DESTCOLOR";
    ERenderStateValues[ERenderStateValues["INVDESTCOLOR"] = 12] = "INVDESTCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHASAT"] = 13] = "SRCALPHASAT";
    ERenderStateValues[ERenderStateValues["NONE"] = 14] = "NONE";
    ERenderStateValues[ERenderStateValues["CW"] = 15] = "CW";
    ERenderStateValues[ERenderStateValues["CCW"] = 16] = "CCW";
    ERenderStateValues[ERenderStateValues["FRONT"] = 17] = "FRONT";
    ERenderStateValues[ERenderStateValues["BACK"] = 18] = "BACK";
    ERenderStateValues[ERenderStateValues["FRONT_AND_BACK"] = 19] = "FRONT_AND_BACK";
    ERenderStateValues[ERenderStateValues["NEVER"] = 20] = "NEVER";
    ERenderStateValues[ERenderStateValues["LESS"] = 21] = "LESS";
    ERenderStateValues[ERenderStateValues["EQUAL"] = 22] = "EQUAL";
    ERenderStateValues[ERenderStateValues["LESSEQUAL"] = 23] = "LESSEQUAL";
    ERenderStateValues[ERenderStateValues["GREATER"] = 24] = "GREATER";
    ERenderStateValues[ERenderStateValues["NOTEQUAL"] = 25] = "NOTEQUAL";
    ERenderStateValues[ERenderStateValues["GREATEREQUAL"] = 26] = "GREATEREQUAL";
    ERenderStateValues[ERenderStateValues["ALWAYS"] = 27] = "ALWAYS";
    ERenderStateValues[ERenderStateValues["FUNCADD"] = 28] = "FUNCADD";
    ERenderStateValues[ERenderStateValues["FUNCSUBTRACT"] = 29] = "FUNCSUBTRACT";
    ERenderStateValues[ERenderStateValues["FUNCREVERSESUBTRACT"] = 30] = "FUNCREVERSESUBTRACT";
    // HACK: temp hack
    ERenderStateValues[ERenderStateValues["LINELIST"] = 31] = "LINELIST";
    ERenderStateValues[ERenderStateValues["LINESTRIP"] = 32] = "LINESTRIP";
    ERenderStateValues[ERenderStateValues["TRIANGLELIST"] = 33] = "TRIANGLELIST";
    ERenderStateValues[ERenderStateValues["TRAINGLESTRIP"] = 34] = "TRAINGLESTRIP";
    ERenderStateValues[ERenderStateValues["POINTLIST"] = 35] = "POINTLIST";
})(ERenderStateValues || (ERenderStateValues = {}));


/***/ }),

/***/ "2oKZ":
/*!*****************************************!*\
  !*** ./src/lib/fx/bytecode/VM/index.ts ***!
  \*****************************************/
/*! exports provided: dispatch, asNative, asNativeInner, createUAV, decodeChunks, decodeCodeChunk, decodeConstChunk, decodeLayoutChunk, load, play, resetRegisters, asNativeFunction, evaluate, setConstant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeChunks", function() { return decodeChunks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeCodeChunk", function() { return decodeCodeChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeConstChunk", function() { return decodeConstChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeLayoutChunk", function() { return decodeLayoutChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "play", function() { return play; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetRegisters", function() { return resetRegisters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asNativeFunction", function() { return asNativeFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evaluate", function() { return evaluate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConstant", function() { return setConstant; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "bTLv");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "oof7");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "p34+");
/* harmony import */ var _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/bytecode/InstructionList */ "RvT5");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _native__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./native */ "dNjM");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dispatch */ "wzb3");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asNative", function() { return _native__WEBPACK_IMPORTED_MODULE_6__["asNative"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asNativeInner", function() { return _native__WEBPACK_IMPORTED_MODULE_6__["asNativeInner"]; });

/* harmony import */ var _uav__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./uav */ "IwZZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createUAV", function() { return _uav__WEBPACK_IMPORTED_MODULE_8__["createUAV"]; });











function decodeChunks(code, chunks) {
    if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(chunks)) {
        chunks = {};
    }
    const view = new DataView(code.buffer, code.byteOffset, code.byteLength);
    const type = view.getUint32(0, true);
    const byteLength = view.getUint32(4, true) << 2;
    const content = new Uint8Array(code.buffer, code.byteOffset + 8, byteLength);
    chunks[type] = content;
    const nextChunkOffset = content.byteOffset + content.byteLength;
    if (nextChunkOffset < code.buffer.byteLength) {
        decodeChunks(new Uint8Array(content.buffer, nextChunkOffset), chunks);
    }
    return chunks;
}
function decodeCodeChunk(codeChunk) {
    return new Uint32Array(codeChunk.buffer, codeChunk.byteOffset, codeChunk.byteLength >> 2);
}
function decodeConstChunk(constChunk) {
    return constChunk;
}
// TODO: rewrite with cleaner code
function decodeLayoutChunk(layoutChunk) {
    let readed = 0;
    let count = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
    readed += 4;
    let layout = [];
    for (let i = 0; i < count; ++i) {
        const nameLength = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const name = String.fromCharCode(...layoutChunk.subarray(readed, readed + nameLength));
        readed += nameLength;
        const typeLength = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const type = String.fromCharCode(...layoutChunk.subarray(readed, readed + typeLength));
        readed += typeLength;
        const semanticLength = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const semantic = String.fromCharCode(...layoutChunk.subarray(readed, readed + semanticLength));
        readed += semanticLength;
        const offset = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const size = Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_3__["u8ArrayToI32"])(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        layout.push({ name, type, offset, size, semantic });
    }
    return layout;
}
class VM {
    static play(data) {
        const ilist = data.instructions;
        const iregs = VM.iregs;
        const fregs = VM.fregs;
        const iinput = data.input;
        let i5 = 0; // current instruction;
        end: while (i5 < ilist.length) {
            let op = ilist[i5];
            let a = ilist[i5 + 1];
            let b = ilist[i5 + 2];
            let c = ilist[i5 + 3];
            let d = ilist[i5 + 4];
            switch (op) {
                // registers
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32SetConst:
                    iregs[a] = b;
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LoadRegister:
                    iregs[a] = iregs[b];
                    break;
                // inputs
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LoadInput:
                    iregs[b] = iinput[a][c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32StoreInput:
                    iinput[a][b] = iregs[c];
                    break;
                // registers pointers    
                // a => dest
                // b => source pointer
                // c => offset
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LoadRegistersPointer:
                    iregs[a] = iregs[iregs[b] + c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32StoreRegisterPointer:
                    iregs[iregs[a] + c] = iregs[b];
                    break;
                // input pointers
                // a => input index
                // b => dest
                // c => source pointer
                // d => offset
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LoadInputPointer:
                    iregs[b] = iinput[a][iregs[c] + d];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32StoreInputPointer:
                    iinput[a][iregs[b] + d] = iregs[c];
                    break;
                //
                // Arithmetic operations
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Add:
                    iregs[a] = iregs[b] + iregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Sub:
                    iregs[a] = iregs[b] - iregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Mul:
                    iregs[a] = iregs[b] * iregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Div:
                    iregs[a] = iregs[b] / iregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Mad:
                    iregs[a] = iregs[b] + iregs[c] * iregs[d];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Min:
                    iregs[a] = Math.min(iregs[b], iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Max:
                    iregs[a] = Math.max(iregs[b], iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Add:
                    fregs[a] = fregs[b] + fregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sub:
                    fregs[a] = fregs[b] - fregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Mul:
                    fregs[a] = fregs[b] * fregs[c];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Div:
                    fregs[a] = fregs[b] / fregs[c];
                    break;
                //
                // Relational operations
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32LessThan:
                    iregs[a] = +((iregs[b] >>> 0) < (iregs[c] >>> 0));
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32GreaterThanEqual:
                    iregs[a] = +((iregs[b] >>> 0) >= (iregs[c] >>> 0));
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LessThan:
                    iregs[a] = +(iregs[b] < iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32GreaterThanEqual:
                    iregs[a] = +(iregs[b] >= iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Equal:
                    iregs[a] = +(iregs[b] === iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32NotEqual:
                    iregs[a] = +(iregs[b] !== iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Not:
                    iregs[a] = +(!iregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32LessThan:
                    fregs[a] = +(fregs[b] < fregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32GreaterThanEqual:
                    fregs[a] = +(fregs[b] >= fregs[c]);
                    break;
                //
                // Logical operations
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LogicalOr:
                    iregs[a] = +(iregs[b] || iregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LogicalAnd:
                    iregs[a] = +(iregs[b] && iregs[c]);
                    break;
                //
                // intrinsics
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Frac:
                    // same as frac() in HLSL
                    fregs[a] = fregs[b] - Math.floor(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Floor:
                    fregs[a] = Math.floor(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Ceil:
                    fregs[a] = Math.ceil(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sin:
                    fregs[a] = Math.sin(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Cos:
                    fregs[a] = Math.cos(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Abs:
                    fregs[a] = Math.abs(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sqrt:
                    fregs[a] = Math.sqrt(fregs[b]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Min:
                    fregs[a] = Math.min(fregs[b], fregs[c]);
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Max:
                    fregs[a] = Math.max(fregs[b], fregs[c]);
                    break;
                //
                // Cast
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32ToF32:
                    fregs[a] = iregs[b] >>> 0;
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32ToF32:
                    fregs[a] = iregs[b];
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32ToU32: // TODO: remove it?
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32ToI32:
                    iregs[a] = Math.trunc(fregs[b]);
                    break;
                //
                // Flow controls
                //
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump:
                    // TODO: don't use multiplication here
                    i5 = a;
                    continue;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_JumpIf:
                    i5 = iregs[a] !== 0
                        ? i5 + _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_4__["default"].STRIDE /* skip one instruction */
                        : i5; /* do nothing (cause next instruction must always be Jump) */
                    break;
                case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Ret:
                    {
                        break end;
                    }
                    break;
                default:
                    console.error(`unknown operation found: ${op}`);
            }
            i5 += _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_4__["default"].STRIDE;
        }
        return VM.regs;
    }
}
VM.$regs = new ArrayBuffer(512 * 4);
VM.iregs = new Int32Array(VM.$regs);
VM.fregs = new Float32Array(VM.$regs);
VM.regs = new Uint8Array(VM.$regs);
function load(code) {
    const chunks = decodeChunks(code);
    const codeChunk = chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EChunkType"].k_Code];
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(codeChunk) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EChunkType"].k_Constants]));
    const constChunk = chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EChunkType"].k_Constants];
    const layoutChunk = chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EChunkType"].k_Layout];
    const instructions = decodeCodeChunk(codeChunk);
    const constants = decodeConstChunk(constChunk);
    const layout = decodeLayoutChunk(layoutChunk);
    const input = Array(64).fill(null);
    input[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__["CBUFFER0_REGISTER"]] = new Int32Array(constants.buffer, constants.byteOffset, constants.length >> 2);
    return { instructions, input, layout };
}
function play(bundle, inputs = null) {
    if (inputs) {
        for (let i = 0; i < inputs.length; ++i) {
            bundle.input[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__["INPUT0_REGISTER"] + i] = inputs[i];
        }
    }
    return VM.play(bundle);
}
function resetRegisters() {
    VM.regs.fill(0);
}
function asNativeFunction(fn) {
    const { code, cdl } = _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["translate"](fn);
    const bundle = load(code);
    return (...args) => {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!args || args.length === 0, 'arguments not supported');
        return Object(_native__WEBPACK_IMPORTED_MODULE_6__["asNative"])(VM.play(bundle), cdl);
    };
}
async function evaluate(param, param2) {
    if (true) {
        resetRegisters();
    }
    let code;
    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(arguments[0])) {
        const expr = arguments[0];
        const slDocument = arguments[1];
        const program = await _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["translateExpression"](expr, slDocument);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(program)) {
            return null;
        }
        const { code, cdl } = program;
        return Object(_native__WEBPACK_IMPORTED_MODULE_6__["asNative"])(VM.play(load(code)), cdl);
    }
    else {
        code = arguments[0];
    }
    return VM.play(load(code));
}
function setConstant(bundle, name, value) {
    const layout = bundle.layout;
    const reflection = layout.find(entry => entry.name === name);
    const constants = bundle.input[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__["CBUFFER0_REGISTER"]];
    if (!reflection) {
        return false;
    }
    const view = new DataView(constants.buffer, constants.byteOffset + reflection.offset);
    // TODO: validate layout / constant type in memory / size
    switch (reflection.type) {
        case 'float':
            view.setFloat32(0, value, true);
            break;
        case 'int':
            view.setInt32(0, value, true);
            break;
        case 'uint':
            view.setUint32(0, value, true);
            break;
        default:
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported');
    }
    return true;
}


/***/ }),

/***/ "2xh7":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CastExprInstruction.ts ***!
  \*****************************************************************/
/*! exports provided: CastExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CastExprInstruction", function() { return CastExprInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent (type) expr
 * EMPTY_OPERATOR VariableTypeInstruction Instruction
 */
class CastExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ sourceExpr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_CastExpr, ...settings });
        this.expr = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(sourceExpr, this);
    }
    toCode() {
        return `(${this.type.toCode()})${this.expr.toCode()}`;
    }
    isUseless() {
        return this.type.isEqual(this.expr.type);
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "34N8":
/*!******************************************!*\
  !*** ./src/lib/fx/translators/Output.ts ***!
  \******************************************/
/*! exports provided: createOutput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOutput", function() { return createOutput; });
function createOutput({ tab = '\t', nl = '\n' } = {}) {
    let data = [''];
    let nesting = [];
    let count = 0;
    let noNextSpace = false;
    const push = (pad = tab) => (nesting.push(pad), count && newline());
    const pop = () => (nesting.pop(), count && newline());
    const toString = () => data.join(nl);
    const ignoreNextSpace = () => noNextSpace = true;
    function add(val) {
        if (!count) {
            for (let i = 0; i < nesting.length; ++i)
                val = nesting[i] + val;
        }
        data[data.length - 1] += val;
        count++;
        noNextSpace = false;
    }
    function keyword(token) {
        !noNextSpace && count && add(' ');
        add(token);
    }
    function newline() {
        data.push('');
        count = 0;
    }
    return {
        keyword,
        ignoreNextSpace,
        push,
        pop,
        newline,
        add,
        toString
    };
}


/***/ }),

/***/ "3ks+":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/UAVPool.ts ***!
  \****************************************/
/*! exports provided: UAVPool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UAVPool", function() { return UAVPool; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytecode */ "oof7");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PromisedAddress */ "m5Cl");





class UAVPool {
    constructor() {
        this._knownUAVs = Array(_Bytecode__WEBPACK_IMPORTED_MODULE_3__["UAV_TOTAL"]).fill(null);
    }
    deref(decl) {
        const knownUAVs = this._knownUAVs;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(decl.type.isUAV());
        let { index, type } = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["variable"].resolveRegister(decl);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type === 'u');
        const knownIndex = knownUAVs.indexOf(decl);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(knownIndex === -1 || knownIndex === index);
        if (index === -1) {
            index = knownUAVs.findIndex(decl => Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl));
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(index !== -1, `uav limit is reached (uav total: ${_Bytecode__WEBPACK_IMPORTED_MODULE_3__["UAV_TOTAL"]})`);
            knownUAVs[index] = decl;
        }
        knownUAVs[index] = decl;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(index !== -1);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(index < _Bytecode__WEBPACK_IMPORTED_MODULE_3__["UAV_TOTAL"]);
        const inputIndex = _Bytecode__WEBPACK_IMPORTED_MODULE_3__["UAV0_REGISTER"] + index;
        const addr = 0;
        // NOTE: UAV's size is unknown in advance
        // so we use maximum aligned int as possible
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__["default"]({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__["EAddrType"].k_Input, addr, size: 1 << 30, inputIndex });
    }
}


/***/ }),

/***/ "3uV/":
/*!************************************!*\
  !*** ./src/sandbox/logic/index.ts ***!
  \************************************/
/*! exports provided: LOCATION_NOT_FOUND, LOCATION_PATTERN, DEFAULT_FILENAME, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOCATION_NOT_FOUND", function() { return LOCATION_NOT_FOUND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOCATION_PATTERN", function() { return LOCATION_PATTERN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_FILENAME", function() { return DEFAULT_FILENAME; });
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "pvc7");
/* harmony import */ var _sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/logic/fxRuntime */ "9w3R");
/* harmony import */ var _sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/logic/parsing */ "x/eC");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers/router */ "SMK2");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! connected-react-router */ "u4tm");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-router */ "Ty5D");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! redux-logic */ "Mn3S");









const readFile = fname => fetch(fname).then(resp => resp.text());
const fetchSourceFileLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_REQUEST"],
    latest: true,
    async process({ getState, action }, dispatch, done) {
        try {
            const content = await readFile(action.payload.filename);
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_DROP_STATE"] });
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_LOADED"], payload: { content } });
        }
        catch (error) {
            console.warn(`Could not find file ${action.payload.filename}.`);
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_DROP_STATE"] });
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_LOADING_FAILED"], payload: { error } });
            // dispatch({ type: evt.SOURCE_FILE_LOADING_FAILED, payload: { error } });
        }
        finally {
            done();
        }
    }
});
const LOCATION_NOT_FOUND = '/NotFound';
const LOCATION_PATTERN = '/:view/:fx?/:name?/:pass?/:property?';
const DEFAULT_FILENAME = '@new';
const navigationLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: connected_react_router__WEBPACK_IMPORTED_MODULE_6__["LOCATION_CHANGE"],
    latest: true,
    debounce: 10,
    async process({ getState, action }, dispatch, done) {
        const location = action.payload.location.pathname;
        const sourceFile = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_5__["getFileState"])(getState());
        if (location === '/') {
            // dispatch(push(`/playground/${DEFAULT_FILENAME}/`));
            _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_4__["history"].push(`/playground/${DEFAULT_FILENAME}/`);
            return done();
        }
        const match = Object(react_router__WEBPACK_IMPORTED_MODULE_7__["matchPath"])(location, {
            path: LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx, name } = match.params;
            const supportedViews = ['playground', 'bytecode', 'program', 'ast'];
            if (supportedViews.indexOf(view) !== -1) {
                if (!fx) {
                    // dispatch(push(`/${view}/${DEFAULT_FILENAME}/`));
                    _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_4__["history"].push(`/${view}/${DEFAULT_FILENAME}`);
                    return done();
                }
                const fxRequest = `./assets/fx/tests/${fx}`;
                if (sourceFile.uri !== fxRequest) {
                    dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_0__["sourceCode"].openFile(fxRequest));
                }
            }
            return done();
        }
        if (location !== LOCATION_NOT_FOUND) {
            _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_4__["history"].push(LOCATION_NOT_FOUND);
        }
        done();
    }
});
/**
 * Redirect to default source (@new) if requested file was not found.
 */
const sourceFileNotFoundLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_LOADING_FAILED"],
    async process({ getState }, dispatch, done) {
        const location = getState().router.location.pathname;
        const match = Object(react_router__WEBPACK_IMPORTED_MODULE_7__["matchPath"])(location, {
            path: LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx } = match.params;
            if (fx !== DEFAULT_FILENAME) {
                _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_4__["history"].push(`/${view}/${DEFAULT_FILENAME}`);
            }
        }
        return done();
    }
});
/* harmony default export */ __webpack_exports__["default"] = (Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogicMiddleware"])([
    fetchSourceFileLogic,
    navigationLogic,
    sourceFileNotFoundLogic,
    ..._sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_3__["default"],
    ..._sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__["default"]
]));


/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "49qt":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FloatInstruction.ts ***!
  \**************************************************************/
/*! exports provided: FloatInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatInstruction", function() { return FloatInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "hljw");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");




class FloatInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_FloatExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__["VariableTypeInstruction"].wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"], _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["SCOPE"]), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return `${this.value}${this.value % 1 === 0 ? '.' : ''}`;
    }
    evaluate() {
        this._evalResult = this.value;
        return true;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "4AA8":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprInstruction.ts ***!
  \*************************************************************/
/*! exports provided: ExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExprInstruction", function() { return ExprInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/TypedInstruction */ "Y1wX");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");


class ExprInstruction extends _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__["TypedInstruction"] {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_Expr, ...settings });
        this._evalResult = null;
    }
    get type() {
        return super.type;
    }
    evaluate() {
        console.error("@pure_virtual");
        return false;
    }
    getEvalValue() {
        return this._evalResult;
    }
    isConst() {
        // console.error("@pure_virtual");
        return false;
    }
    isConstExpr() {
        // todo: implement it properly
        return true;
    }
}


/***/ }),

/***/ "4PT3":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts ***!
  \********************************************************************/
/*! exports provided: PartFxInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartFxInstruction", function() { return PartFxInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _TechniqueInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TechniqueInstruction */ "+Z36");


// var s: IPartFxInstructionSettings;
// s.te
class PartFxInstruction extends _TechniqueInstruction__WEBPACK_IMPORTED_MODULE_1__["TechniqueInstruction"] {
    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PartFxDecl, techniqueType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["ETechniqueType"].k_PartFx, ...settings });
        this._spawnRoutine = spawnRoutine;
        this._initRoutine = initRoutine;
        this._updateRoutine = updateRoutine;
        this._particle = particle;
        this._capacity = capacity;
    }
    get spawnRoutine() {
        return this._spawnRoutine;
    }
    get initRoutine() {
        return this._initRoutine;
    }
    get updateRoutine() {
        return this._updateRoutine;
    }
    get particle() {
        return this._particle;
    }
    get capacity() {
        return this._capacity;
    }
    isValid() {
        const routineCheck = !!this.spawnRoutine && !!this.initRoutine && !!this.updateRoutine;
        const particleCheck = !!this.particle;
        const passCheck = this.passList && this.passList.filter((pass) => pass.isValid()).length > 0;
        return routineCheck && particleCheck && passCheck;
    }
}


/***/ }),

/***/ "4cxW":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: FunctionCallInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionCallInstruction", function() { return FunctionCallInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Respresnt func(arg1,..., argn)
 * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
 */
class FunctionCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ decl, args, callee, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionCallExpr, ...settings });
        this.callee = callee;
        this.args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(arg, this));
        this.decl = decl;
    }
    toCode() {
        const { callee, decl: { def }, args } = this;
        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;
    }
}


/***/ }),

/***/ 5:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "5D93":
/*!******************************!*\
  !*** ./src/lib/path/path.ts ***!
  \******************************/
/*! exports provided: normalize, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "fb8x");

class Pathinfo {
    constructor(path) {
        this._dirname = null;
        this._extension = null;
        this._filename = null;
        if (Object(_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(path)) {
            this.set(path);
        }
    }
    get path() {
        return this.toString();
    }
    set path(path) {
        this.set(path);
    }
    get dirname() {
        return this._dirname;
    }
    set dirname(dirname) {
        this._dirname = dirname;
    }
    get filename() {
        return this._filename;
    }
    set filename(filename) {
        this._filename = filename;
    }
    get ext() {
        return this._extension;
    }
    set ext(extension) {
        this._extension = extension;
    }
    get basename() {
        return (this._filename ? this._filename + (this._extension ? "." + this._extension : "") : "");
    }
    set basename(basename) {
        var nPos = basename.lastIndexOf(".");
        if (nPos < 0) {
            this._filename = basename.substr(0);
            this._extension = null;
        }
        else {
            this._filename = basename.substr(0, nPos);
            this._extension = basename.substr(nPos + 1);
        }
    }
    set(path) {
        if (Object(_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(path)) {
            var pParts = path.replace('\\', '/').split('/');
            this.basename = (pParts.pop());
            this._dirname = pParts.join('/');
        }
        else if (path instanceof Pathinfo) {
            this._dirname = path.dirname;
            this._filename = path.filename;
            this._extension = path.ext;
        }
        else if (Object(_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(path)) {
            return null;
        }
        else {
            //critical_error
            throw new Error(`Unexpected data type was used: ${path}`);
        }
    }
    isAbsolute() { return this._dirname[0] === "/"; }
    toString() {
        return (this._dirname ? this._dirname + "/" : "") + (this.basename);
    }
}
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === "..") {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        for (; up--;) {
            parts.unshift("..");
        }
    }
    return parts;
}
function normalize(path) {
    var info = parse(path);
    var isAbsolute = info.isAbsolute();
    var tail = info.dirname;
    var trailingSlash = /[\\\/]$/.test(tail);
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
        return !!p;
    }), !isAbsolute).join("/");
    if (tail && trailingSlash) {
        tail += "/";
    }
    info.dirname = ((isAbsolute ? "/" : "") + tail);
    return info.toString();
}
function parse(path) {
    return new Pathinfo(path);
}


/***/ }),

/***/ "5EX4":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BoolInstruction.ts ***!
  \*************************************************************/
/*! exports provided: BoolInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoolInstruction", function() { return BoolInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "hljw");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");




class BoolInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_BoolExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__["VariableTypeInstruction"].wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_BOOL"], _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["SCOPE"]), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return this.value ? "true" : "false";
    }
    evaluate() {
        this._evalResult = this.value;
        return true;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "5fm/":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdExprInstruction.ts ***!
  \***************************************************************/
/*! exports provided: IdExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdExprInstruction", function() { return IdExprInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



class IdExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ id, decl, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IdExpr, type: decl.type, ...settings });
        this.id = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(id, this);
        this.decl = decl;
    }
    get name() {
        return this.id.name;
    }
    isConst() {
        return this.type.isConst();
    }
    /** @deprecated */
    evaluate() {
        return false;
    }
    toCode() {
        return this.decl.id.toCode();
    }
}


/***/ }),

/***/ "66j4":
/*!**********************************************************!*\
  !*** ./src/sandbox/containers/playground/Playground.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
/* harmony import */ var _ThreeScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ThreeScene */ "ikYS");
/* tslint:disable:typedef */
/* tslint:disable:forin */
/* tslint:disable:no-for-in */
/* tslint:disable:newline-per-chained-call */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








// TODO: remove it
const threeStylesHotfix = {
    height: 'calc(100vh - 275px - 1em)',
    position: 'relative',
    left: '0',
    right: '0',
    margin: '1em -20px -20px -20px'
};
class Playground extends react__WEBPACK_IMPORTED_MODULE_4__["Component"] {
    constructor(props) {
        super(props);
        this.$emitterName = null;
    }
    // static getDerivedStateFromProps(props: IPlaygroundProps, state: IPlaygroundState) {
    //     return null;
    // }
    handlePlayClick() {
        const props = this.props;
        if (props.emitter) {
            if (props.emitter.isStopped()) {
                props.emitter.start();
                this.forceUpdate();
            }
        }
    }
    handlePauseClick() {
        const props = this.props;
        if (props.emitter) {
            if (!props.emitter.isStopped()) {
                props.emitter.stop();
                this.forceUpdate();
            }
        }
    }
    handleResetClick() {
        const props = this.props;
        if (props.emitter) {
            props.emitter.reset();
        }
    }
    pickEffect(active) {
        this.props.actions.selectEffect(active);
    }
    shouldComponentUpdate(nextProps) {
        return nextProps.emitter !== this.props.emitter ||
            (this.props.emitter && this.$emitterName !== this.props.emitter.name);
    }
    componentDidUpdate() {
        if (this.props.emitter) {
            this.$emitterName = this.props.emitter.name;
        }
        else {
            this.$emitterName = null;
        }
    }
    render() {
        // console.log('Playground:render()');
        const props = this.props;
        const emitter = props.emitter;
        const scope = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_2__["getScope"])(props);
        const list = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_2__["filterPartFx"])(scope);
        const active = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_2__["getEmitterName"])(props);
        return (react__WEBPACK_IMPORTED_MODULE_4__["createElement"]("div", null,
            !list.length &&
                react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Message"], { info: true, textAlign: 'center' },
                    react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Message"].Content, null, "No effects found :/")),
            emitter &&
                react__WEBPACK_IMPORTED_MODULE_4__["createElement"]("div", null,
                    react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["List"], { bulleted: true, horizontal: true }, list.map(fx => (react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["List"].Item, { disabled: !fx.isValid(), as: (fx.name === active ? 'b' : 'a'), onClick: () => this.pickEffect(fx.name) }, fx.name)))),
                    react__WEBPACK_IMPORTED_MODULE_4__["createElement"]("div", null,
                        react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Button"].Group, { compact: true },
                            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Button"], { icon: 'playback pause', color: (emitter.isStopped() ? 'black' : null), disabled: emitter.isStopped(), onClick: this.handlePauseClick }),
                            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Button"], { icon: 'sync', onClick: this.handleResetClick }),
                            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["Button"], { icon: 'playback play', color: (!emitter.isStopped() ? 'black' : null), disabled: !emitter.isStopped(), onClick: this.handlePlayClick })),
                        react__WEBPACK_IMPORTED_MODULE_4__["createElement"](_ThreeScene__WEBPACK_IMPORTED_MODULE_7__["default"], { style: threeStylesHotfix, emitter: emitter })))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], Playground.prototype, "handlePlayClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], Playground.prototype, "handlePauseClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], Playground.prototype, "handleResetClick", null);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_5__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__["mapProps"])(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_2__["getFileState"]), Object(_sandbox_actions__WEBPACK_IMPORTED_MODULE_0__["mapActions"])(_sandbox_actions__WEBPACK_IMPORTED_MODULE_0__["sourceCode"]))(Playground));


/***/ }),

/***/ "6dfp":
/*!**************************************!*\
  !*** ./src/lib/idl/ERenderStates.ts ***!
  \**************************************/
/*! exports provided: ERenderStates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERenderStates", function() { return ERenderStates; });
var ERenderStates;
(function (ERenderStates) {
    ERenderStates[ERenderStates["BLENDENABLE"] = 0] = "BLENDENABLE";
    ERenderStates[ERenderStates["CULLFACEENABLE"] = 1] = "CULLFACEENABLE";
    ERenderStates[ERenderStates["ZENABLE"] = 2] = "ZENABLE";
    ERenderStates[ERenderStates["ZWRITEENABLE"] = 3] = "ZWRITEENABLE";
    ERenderStates[ERenderStates["DITHERENABLE"] = 4] = "DITHERENABLE";
    ERenderStates[ERenderStates["SCISSORTESTENABLE"] = 5] = "SCISSORTESTENABLE";
    ERenderStates[ERenderStates["STENCILTESTENABLE"] = 6] = "STENCILTESTENABLE";
    ERenderStates[ERenderStates["POLYGONOFFSETFILLENABLE"] = 7] = "POLYGONOFFSETFILLENABLE";
    ERenderStates[ERenderStates["CULLFACE"] = 8] = "CULLFACE";
    ERenderStates[ERenderStates["FRONTFACE"] = 9] = "FRONTFACE";
    ERenderStates[ERenderStates["SRCBLENDCOLOR"] = 10] = "SRCBLENDCOLOR";
    ERenderStates[ERenderStates["DESTBLENDCOLOR"] = 11] = "DESTBLENDCOLOR";
    ERenderStates[ERenderStates["SRCBLENDALPHA"] = 12] = "SRCBLENDALPHA";
    ERenderStates[ERenderStates["DESTBLENDALPHA"] = 13] = "DESTBLENDALPHA";
    ERenderStates[ERenderStates["BLENDEQUATIONCOLOR"] = 14] = "BLENDEQUATIONCOLOR";
    ERenderStates[ERenderStates["BLENDEQUATIONALPHA"] = 15] = "BLENDEQUATIONALPHA";
    ERenderStates[ERenderStates["ZFUNC"] = 16] = "ZFUNC";
    ERenderStates[ERenderStates["ALPHABLENDENABLE"] = 17] = "ALPHABLENDENABLE";
    ERenderStates[ERenderStates["ALPHATESTENABLE"] = 18] = "ALPHATESTENABLE";
    ERenderStates[ERenderStates["SRCBLEND"] = 19] = "SRCBLEND";
    ERenderStates[ERenderStates["DESTBLEND"] = 20] = "DESTBLEND";
    ERenderStates[ERenderStates["BLENDFUNC"] = 21] = "BLENDFUNC";
    ERenderStates[ERenderStates["BLENDFUNCSEPARATE"] = 22] = "BLENDFUNCSEPARATE";
    ERenderStates[ERenderStates["BLENDEQUATION"] = 23] = "BLENDEQUATION";
    ERenderStates[ERenderStates["BLENDEQUATIONSEPARATE"] = 24] = "BLENDEQUATIONSEPARATE";
    // HACK:
    ERenderStates[ERenderStates["PRIMITIVETOPOLOGY"] = 25] = "PRIMITIVETOPOLOGY";
})(ERenderStates || (ERenderStates = {}));


/***/ }),

/***/ "79MH":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/type.ts ***!
  \*********************************************/
/*! exports provided: type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "type", function() { return type; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "PKWX");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./variable */ "UsCK");




var type;
(function (type_1) {
    // todo: rename it
    /** @deprecated */
    function isInheritedFromVariableDecl(type) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type.parent)) {
            return false;
        }
        const parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableDecl) {
            return true;
        }
        else if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableType) {
            return isInheritedFromVariableDecl(type.parent);
        }
        return false;
    }
    type_1.isInheritedFromVariableDecl = isInheritedFromVariableDecl;
    /** @deprecated */
    function isTypeOfField(type) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type.parent)) {
            return false;
        }
        if (type.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableDecl) {
            let pParentDecl = type.parent;
            return pParentDecl.isField();
        }
        return false;
    }
    type_1.isTypeOfField = isTypeOfField;
    /** @deprecated */
    function findParentContainer(type) {
        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {
            return null;
        }
        let containerType = findParentVariableDecl(type).parent;
        if (!isInheritedFromVariableDecl(containerType)) {
            return null;
        }
        return findParentVariableDecl(containerType);
    }
    type_1.findParentContainer = findParentContainer;
    /** @deprecated */
    function findParentVariableDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableDecl) {
            return type.parent;
        }
        return findParentVariableDecl(type.parent);
    }
    type_1.findParentVariableDecl = findParentVariableDecl;
    /** @deprecated */
    function findParentVariableDeclName(type) {
        let varDecl = findParentVariableDecl(type);
        return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(varDecl) ? null : varDecl.name;
    }
    type_1.findParentVariableDeclName = findParentVariableDeclName;
    /** @deprecated */
    function finParentTypeDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_TypeDecl) {
            return type.parent;
        }
        return finParentTypeDecl(type.parent);
    }
    type_1.finParentTypeDecl = finParentTypeDecl;
    /** @deprecated */
    function finParentTypeDeclName(type) {
        let typeDecl = finParentTypeDecl(type);
        return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(typeDecl) ? null : typeDecl.name;
    }
    type_1.finParentTypeDeclName = finParentTypeDeclName;
    /** @deprecated */
    function resolveVariableDeclFullName(type) {
        if (!isInheritedFromVariableDecl(type)) {
            console.error("Not from variable decl");
            return null;
        }
        return _variable__WEBPACK_IMPORTED_MODULE_3__["variable"].fullName(findParentVariableDecl(type));
    }
    type_1.resolveVariableDeclFullName = resolveVariableDeclFullName;
    // todo: add comment
    // todo: review this code
    /** @deprecated */
    function findMainVariable(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        if (isTypeOfField(type)) {
            return findMainVariable(type.parent.parent);
        }
        return findParentVariableDecl(type);
    }
    type_1.findMainVariable = findMainVariable;
    //
    // Signatures
    //
    function signatureVType(vtype, strong) {
        let prefix = '';
        if (strong) {
            if (vtype.usages.length > 0) {
                prefix = `${vtype.usages.join('_')}_`;
            }
        }
        let postfix = '';
        if (vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        return `${prefix}${signature(vtype.subType)}${postfix}`;
    }
    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)
    function signature(type, strong = false) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!strong);
            return '*';
        }
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableType:
                return signatureVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ComplexType:
                return `${type.name}${type.instructionID}`;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ProxyType:
                return type.baseType ? signature(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_SystemType:
                return type.name;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported type');
                return null;
        }
    }
    type_1.signature = signature;
    //
    // hash
    //
    function hashVType(vtype, strong) {
        let postfix = '';
        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        return `${hash(vtype.subType)}${postfix}`;
    }
    function hashComplex(ctype, strong) {
        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;
    }
    function hash(type, strong = false) {
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableType:
                return hashVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ComplexType:
                return hashComplex(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ProxyType:
                return type.baseType ? hash(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_SystemType:
                return type.name;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported type');
                return null;
        }
    }
    type_1.hash = hash;
    function compareRelaxed(a, b, strong = false) {
        return hash(a, strong) === hash(b, strong);
    }
    type_1.compareRelaxed = compareRelaxed;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function compare(a, b, strong = false) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(a) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(b)) {
            return false;
        }
        if (a instanceof RegExp && b instanceof RegExp) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
            return false;
        }
        if (a instanceof RegExp) {
            let ra = a;
            let sb = signature(b, strong);
            return !!sb.match(ra);
        }
        if (b instanceof RegExp) {
            let sa = signature(a, strong);
            let rb = b;
            return !!sa.match(rb);
        }
        let ta = a;
        let tb = b;
        if (ta.isArray() && tb.isArray()) {
            if (ta.length === _instruction__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_LENGTH ||
                tb.length === _instruction__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_LENGTH) {
                return false;
            }
        }
        return signature(ta, strong) === signature(tb, strong);
    }
    type_1.compare = compare;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function equals(a, b, strong = false) {
        return compare(a, b, strong);
    }
    type_1.equals = equals;
})(type || (type = {}));


/***/ }),

/***/ "7VRG":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts ***!
  \******************************************************************/
/*! exports provided: BreakStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BreakStmtInstruction", function() { return BreakStmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "oseZ");


/**
 * Reprsernt continue; break; discard;
 * (continue || break || discard)
 */
class BreakStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__["StmtInstruction"] {
    constructor({ operator = "break", ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BreakStmt, ...settings });
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    // todo: validate operator's name
    toCode() {
        console.assert(this.operator == "break");
        return this.operator + ";";
    }
}


/***/ }),

/***/ "7vWe":
/*!******************************************!*\
  !*** ./src/lib/parser/AbstractParser.ts ***!
  \******************************************/
/*! exports provided: EParserErrors, GrammarDiagnostics, AbstractParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EParserErrors", function() { return EParserErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GrammarDiagnostics", function() { return GrammarDiagnostics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractParser", function() { return AbstractParser; });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "U+xq");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _Item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Item */ "GIxw");
/* harmony import */ var _Lexer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Lexer */ "TYG3");
/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./State */ "uXIj");
/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbols */ "YPfw");








var EParserErrors;
(function (EParserErrors) {
    EParserErrors[EParserErrors["GrammarAddOperation"] = 2001] = "GrammarAddOperation";
    EParserErrors[EParserErrors["GrammarAddStateLink"] = 2002] = "GrammarAddStateLink";
    EParserErrors[EParserErrors["GrammarUnexpectedSymbol"] = 2003] = "GrammarUnexpectedSymbol";
    EParserErrors[EParserErrors["GrammarInvalidAdditionalFuncName"] = 2004] = "GrammarInvalidAdditionalFuncName";
    EParserErrors[EParserErrors["GrammarInvalidKeyword"] = 2005] = "GrammarInvalidKeyword";
})(EParserErrors || (EParserErrors = {}));
;
class GrammarDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__["Diagnostics"] {
    constructor() {
        super("Grammar diagnostics", 'G');
    }
    resolveFilename(code, desc) {
        return desc.file;
    }
    resolveRange(code, desc) {
        return null;
    }
    resolvePosition(code, desc) {
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParserErrors.GrammarAddOperation]: "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old operation: {oldOperation}\n" +
                "New operation: {newOperation}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states." +
                `\n\n{stateDesc}`,
            [EParserErrors.GrammarAddStateLink]: "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old next state: {oldNextStateIndex}\n" +
                "New next state: {newNextStateIndex}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states.",
            [EParserErrors.GrammarUnexpectedSymbol]: "Grammar error. Can`t generate rules from grammar\n" +
                "Unexpected symbol: {unexpectedSymbol}\n" +
                "Expected: {expectedSymbol}",
            [EParserErrors.GrammarInvalidAdditionalFuncName]: "Grammar error. Empty additional function name.",
            [EParserErrors.GrammarInvalidKeyword]: "Grammar error. Bad keyword: {badKeyword}\n" +
                "All keyword must be define in lexer rule block."
        };
    }
}
class AbstractParser {
    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR
    constructor({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LALR }) {
        this._syntaxTable = null;
        this._productions = null;
        this._baseItems = null;
        this._states = null;
        this._additionalFuncInfoList = null;
        this._adidtionalFunctByStateDMap = null;
        this._ruleCreationModeMap = null;
        this._firstTerminalsCache = null;
        // this._followTerminalsCache = null;
        this._closureForItemsCache = null;
        this._expectedExtensionDMap = null;
        this._diag = new GrammarDiagnostics;
        this.init({ grammar, flags, type });
    }
    get syntaxTable() {
        return this._syntaxTable;
    }
    findFunctionByState(stateIndex, grammarSymbol) {
        const funcDMap = this._adidtionalFunctByStateDMap;
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(funcDMap) &&
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(funcDMap[stateIndex]) &&
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(funcDMap[stateIndex][grammarSymbol])) {
            return funcDMap[stateIndex][grammarSymbol];
        }
        return null;
    }
    getRuleCreationMode(nonTerminal) {
        return this._ruleCreationModeMap[nonTerminal];
    }
    getGrammarSymbols() {
        return this._grammarSymbols;
    }
    init({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LALR }) {
        this.lexerEngine = new _Lexer__WEBPACK_IMPORTED_MODULE_5__["LexerEngine"]();
        this.generateRules(grammar, flags);
        this.buildSyntaxTable(type);
        this.generateFunctionByStateMap();
        if (!_lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_Debug)) {
            this.clearMem();
        }
    }
    printStates(isBaseOnly = true) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(this._states)) {
            console.warn("It`s impossible to print states. You must init parser in debug-mode");
            return;
        }
        const mesg = "\n" + this.statesToString(isBaseOnly);
        console.log(mesg);
    }
    printState(stateIndex, isBaseOnly = true) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(this._states)) {
            console.log("It`s impossible to print states. You must init parser in debug-mode.");
            return;
        }
        var state = this._states[stateIndex];
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(state)) {
            console.log("Can not print stete with index: " + stateIndex.toString());
            return;
        }
        console.log(`\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);
    }
    critical(code, desc) {
        this._diag.critical(code, desc);
    }
    grammarError(code, desc) {
        let file = "grammar";
        switch (code) {
            case EParserErrors.GrammarAddOperation:
                {
                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;
                    this.critical(code, {
                        file, line: 0, stateIndex, grammarSymbol,
                        oldOperation: AbstractParser.operationToString(oldOperation),
                        newOperation: AbstractParser.operationToString(newOperation),
                        stateDesc: this._states[stateIndex].toString()
                    });
                }
                break;
            case EParserErrors.GrammarAddStateLink:
                {
                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;
                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });
                }
                break;
            case EParserErrors.GrammarUnexpectedSymbol:
                {
                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;
                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });
                }
                break;
            case EParserErrors.GrammarInvalidAdditionalFuncName:
                {
                    const { grammarLine } = desc;
                    this.critical(code, { file, line: grammarLine });
                }
                break;
            case EParserErrors.GrammarInvalidKeyword:
                {
                    const { grammarLine, badKeyword } = desc;
                    this.critical(code, { file, line: grammarLine, badKeyword });
                }
                break;
            default:
                throw "invalid case!!!!";
        }
    }
    clearMem() {
        delete this._states;
        delete this._productions;
        delete this._baseItems;
        // delete this._followTerminalsCache;
        delete this._firstTerminalsCache;
        delete this._closureForItemsCache;
        delete this._expectedExtensionDMap;
    }
    /**
     * Check for the state's dublicate.
     */
    hasState(state, type) {
        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;
    }
    nonTerminals() {
        return Object.keys(this._productions);
    }
    rules(nonTerminal) {
        const prods = this._productions[nonTerminal];
        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;
    }
    ruleCreationMode(symbol) {
        return this._ruleCreationModeMap[symbol];
    }
    /**
     * terminals & non-terminals;
     */
    symbols() {
        return [...this._grammarSymbols.keys()];
    }
    isTerminal(symbol) {
        return !(this._productions[symbol]);
    }
    /**
     * Add item to 'stateList' and set item's index in it.
     */
    pushState(state) {
        state.index = this._states.length;
        this._states.push(state);
    }
    /**
     * Add item to 'baseItemList' and set item's index in it.
     */
    pushBaseItem(item) {
        item.index = this._baseItems.length;
        this._baseItems.push(item);
    }
    tryAddState(state, type) {
        let res = this.hasState(state, type);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(res)) {
            if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR0) {
                state.eachItem(item => this.pushBaseItem(item));
            }
            this.pushState(state);
            this.closure(state, type);
            return state;
        }
        return res;
    }
    hasEmptyRule(symbol) {
        if (this.isTerminal(symbol)) {
            return false;
        }
        return !!this.rules(symbol).find(rule => rule.right.length === 0);
    }
    pushInSyntaxTable(syntaxTable, stateIndex, symbol, operation) {
        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(syntaxTable[stateIndex][symbol])) {
            this.grammarError(EParserErrors.GrammarAddOperation, {
                stateIndex: stateIndex,
                grammarSymbol: this.convertGrammarSymbol(symbol),
                oldOperation: this._syntaxTable[stateIndex][symbol],
                newOperation: operation
            });
        }
        syntaxTable[stateIndex][symbol] = operation;
    }
    addStateLink(state, nextState, symbol) {
        let isAddState = state.addNextState(symbol, nextState);
        if (!isAddState) {
            this.grammarError(EParserErrors.GrammarAddStateLink, {
                stateIndex: state.index,
                oldNextStateIndex: state.nextStates[symbol] || null,
                newNextStateIndex: nextState.index,
                grammarSymbol: this.convertGrammarSymbol(symbol)
            });
        }
    }
    firstTerminals(symbol) {
        if (this.isTerminal(symbol)) {
            return null;
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(this._firstTerminalsCache[symbol])) {
            return this._firstTerminalsCache[symbol];
        }
        const rules = this.rules(symbol);
        const res = this._firstTerminalsCache[symbol] = new Set();
        if (this.hasEmptyRule(symbol)) {
            res.add(_symbols__WEBPACK_IMPORTED_MODULE_7__["T_EMPTY"]);
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(rules)) {
            return res;
        }
        for (let i = 0; i < rules.length; ++i) {
            const rule = rules[i];
            const right = rule.right;
            let isFinish = false;
            for (let j = 0; j < right.length; j++) {
                if (right[j] === symbol) {
                    if (res.has(_symbols__WEBPACK_IMPORTED_MODULE_7__["T_EMPTY"])) {
                        continue;
                    }
                    isFinish = true;
                    break;
                }
                const terminals = this.firstTerminals(right[j]);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(terminals)) {
                    res.add(right[j]);
                }
                else {
                    for (const terminal of terminals) {
                        res.add(terminal);
                    }
                }
                if (!this.hasEmptyRule(right[j])) {
                    isFinish = true;
                    break;
                }
            }
            if (!isFinish) {
                res.add(_symbols__WEBPACK_IMPORTED_MODULE_7__["T_EMPTY"]);
            }
        }
        return res;
    }
    // private followTerminal(symbolVal: string): IMap<boolean> {
    //     if (isDef(this._followTerminalsCache[symbolVal])) {
    //         return this._followTerminalsCache[symbolVal];
    //     }
    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;
    //     var pRulesDMap: IRuleDMap = this._rulesDMap;
    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];
    //     var rule: IRule;
    //     var pTempRes: IMap<boolean>;
    //     var pTempKeys: string[];
    //     var res: IMap<boolean>;
    //     var right: string[];
    //     var isFinish: boolean;
    //     var sFirstKey: string;
    //     var sSecondKey: string;
    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};
    //     if (isNull(pRulesDMap)) {
    //         return res;
    //     }
    //     rulesDMapKeys = Object.keys(pRulesDMap);
    //     for (i = 0; i < rulesDMapKeys.length; i++) {
    //         sFirstKey = rulesDMapKeys[i];
    //         if (isNull(pRulesDMap[sFirstKey])) {
    //             continue;
    //         }
    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);
    //         for (j = 0; j < pRulesMapKeys.length; j++) {
    //             rule = pRulesDMap[sFirstKey][sSecondKey];
    //             right = rule.right;
    //             for (k = 0; k < right.length; k++) {
    //                 if (right[k] === symbolVal) {
    //                     if (k === right.length - 1) {
    //                         pTempRes = this.followTerminal(rule.left);
    //                         pTempKeys = Object.keys(pTempRes);
    //                         for (m = 0; m < pTempKeys.length; i++) {
    //                             res[pTempKeys[m]] = true;
    //                         }
    //                     }
    //                     else {
    //                         isFinish = false;
    //                         for (l = k + 1; l < right.length; l++) {
    //                             pTempRes = this.firstTerminal(right[l]);
    //                             if (isNull(pTempRes)) {
    //                                 res[right[l]] = true;
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                             else {
    //                                 pTempKeys = Object.keys(pTempRes);
    //                                 for (m = 0; m < pTempKeys.length; i++) {
    //                                     res[pTempKeys[m]] = true;
    //                                 }
    //                             }
    //                             if (!pTempRes[T_EMPTY]) {
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                         }
    //                         if (!isFinish) {
    //                             pTempRes = this.followTerminal(rule.left);
    //                             pTempKeys = Object.keys(pTempRes);
    //                             for (m = 0; m < pTempKeys.length; i++) {
    //                                 res[pTempKeys[m]] = true;
    //                             }
    //                         }
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return res;
    // }
    firstTerminalsForSet(symbolList, expectedSymbols) {
        const res = new Set();
        for (let i = 0; i < symbolList.length; i++) {
            const terminals = this.firstTerminals(symbolList[i]);
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(terminals)) {
                res.add(symbolList[i]);
                return res;
            }
            let isEmpty = false;
            for (const symbol of terminals) {
                if (symbol === _symbols__WEBPACK_IMPORTED_MODULE_7__["T_EMPTY"]) {
                    isEmpty = true;
                    continue;
                }
                res.add(symbol);
            }
            if (!isEmpty) {
                return res;
            }
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(expectedSymbols)) {
            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));
        }
        return res;
    }
    generateRules(grammarSource, flags) {
        let allRuleList = grammarSource.split(/\r?\n/);
        let tempRule;
        let rule;
        let isLexerBlock = false;
        this._productions = {};
        this._additionalFuncInfoList = [];
        this._ruleCreationModeMap = {};
        this._grammarSymbols = new Map([['END_SYMBOL', _symbols__WEBPACK_IMPORTED_MODULE_7__["END_SYMBOL"]]]);
        let i = 0, j = 0;
        // append all nodes ignoring any flags
        const forceAppendAllMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_ForceAppendAll);
        // force unwind node if it is marked as '--expose'
        const allowExposeMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_AllowExposeMode);
        // force add node if it is marked as '--add'
        const allowAddMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_AllowAddMode);
        // remove node from parsing tree if it is marked as '--skip'
        const allowSkipMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserFlags"].k_AllowSkipMode);
        let symbolsWithNodeMap = this._ruleCreationModeMap;
        let name;
        let nRules = 0;
        for (i = 0; i < allRuleList.length; i++) {
            if (allRuleList[i] === "" || allRuleList[i] === "\r") {
                continue;
            }
            // split rule like 'S : Program'
            tempRule = allRuleList[i].trim().split(/\s* \s*/);
            // ignore rules starting with '#'
            if (tempRule[0][0] == _symbols__WEBPACK_IMPORTED_MODULE_7__["INLINE_COMMENT_SYMBOL"]) {
                continue;
            }
            if (isLexerBlock) {
                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === "")) &&
                    ((tempRule[2][0] === "\"" || tempRule[2][0] === "'") && tempRule[2].length > 3)) {
                    //TERMINALS
                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],
                            expectedSymbol: tempRule[2][0],
                            grammarLine: i
                        });
                    }
                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);
                    var ch = tempRule[2][0];
                    if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);
                    }
                    else {
                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);
                    }
                    this._grammarSymbols.set(name, tempRule[2]);
                }
                continue;
            }
            // looking for '--LEXER--' keyword
            if (tempRule[0] === _symbols__WEBPACK_IMPORTED_MODULE_7__["LEXER_RULES"]) {
                isLexerBlock = true;
                continue;
            }
            //NON TERMNINAL RULES
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(this._productions[tempRule[0]])) {
                this._productions[tempRule[0]] = {};
            }
            rule = {
                left: tempRule[0],
                right: [],
                index: 0
            };
            this._grammarSymbols.set(tempRule[0], tempRule[0]);
            if (forceAppendAllMode) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Default;
            }
            else if (allowExposeMode && !Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Default;
            }
            else if (allowAddMode && !Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Expose;
            }
            else if (allowSkipMode && !Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Skip;
            }
            for (j = 2; j < tempRule.length; j++) {
                if (tempRule[j] === "") {
                    continue;
                }
                // handle flag '--add'
                if (tempRule[j] === _symbols__WEBPACK_IMPORTED_MODULE_7__["FLAG_RULE_CREATE_NODE"]) {
                    if (allowAddMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Necessary;
                    }
                    continue;
                }
                if (tempRule[j] === _symbols__WEBPACK_IMPORTED_MODULE_7__["FLAG_RULE_SKIP_NODE"]) {
                    if (allowSkipMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Skip;
                    }
                    continue;
                }
                // handle flag '--expose'
                if (tempRule[j] === _symbols__WEBPACK_IMPORTED_MODULE_7__["FLAG_RULE_EXPOSE_NODE"]) {
                    if (allowExposeMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["ENodeCreateMode"].k_Expose;
                    }
                    continue;
                }
                // looking for additional user functions like '--F includeCode'
                if (tempRule[j] === _symbols__WEBPACK_IMPORTED_MODULE_7__["FLAG_RULE_FUNCTION"]) {
                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {
                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });
                    }
                    const funcInfo = {
                        name: tempRule[j + 1],
                        position: rule.right.length,
                        rule: rule
                    };
                    this._additionalFuncInfoList.push(funcInfo);
                    j++;
                    continue;
                }
                // handle string literlas
                if (tempRule[j][0] === "'" || tempRule[j][0] === "\"") {
                    if (tempRule[j].length !== 3) {
                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {
                            badKeyword: tempRule[j],
                            grammarLine: i
                        });
                    }
                    if (tempRule[j][0] !== tempRule[j][2]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[j][2],
                            expectedSymbol: tempRule[j][0],
                            grammarLine: i
                        });
                    }
                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);
                    rule.right.push(name);
                    this._grammarSymbols.set(name, tempRule[j][1]);
                }
                else {
                    rule.right.push(tempRule[j]);
                    this._grammarSymbols.set(tempRule[j], tempRule[j]);
                }
            }
            rule.index = nRules;
            this._productions[tempRule[0]][rule.index] = rule;
            nRules++;
            // TODO: emit diagnostics error instead.
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["assert"])(nRules != 1 || Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(this._productions[_symbols__WEBPACK_IMPORTED_MODULE_7__["START_SYMBOL"]][0]));
        }
    }
    generateFunctionByStateMap() {
        const stateList = this._states;
        const funcInfoList = this._additionalFuncInfoList;
        const funcByStateDMap = this._adidtionalFunctByStateDMap = {};
        for (let i = 0; i < funcInfoList.length; i++) {
            const funcInfo = funcInfoList[i];
            const rule = funcInfo.rule;
            const pos = funcInfo.position;
            const grammarSymbol = rule.right[pos - 1];
            for (let j = 0; j < stateList.length; j++) {
                if (stateList[j].hasRule(rule, pos)) {
                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};
                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;
                }
            }
        }
    }
    generateFirstState_LR0() {
        const state = new _State__WEBPACK_IMPORTED_MODULE_6__["State"]();
        // START_SYMBOL should be always defined at the beginning of grammar
        const firstRule = this._productions[_symbols__WEBPACK_IMPORTED_MODULE_7__["START_SYMBOL"]][0];
        const item = new _Item__WEBPACK_IMPORTED_MODULE_4__["Item"](firstRule, 0);
        this.pushBaseItem(item);
        state.push(item);
        this.closure_LR0(state);
        this.pushState(state);
    }
    generateFirstState_LR() {
        const state = new _State__WEBPACK_IMPORTED_MODULE_6__["State"]();
        const firstRule = this._productions[_symbols__WEBPACK_IMPORTED_MODULE_7__["START_SYMBOL"]][0];
        state.push(new _Item__WEBPACK_IMPORTED_MODULE_4__["Item"](firstRule, 0, [_symbols__WEBPACK_IMPORTED_MODULE_7__["END_SYMBOL"]]));
        this.closure_LR(state);
        this.pushState(state);
    }
    closure(state, type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR0) {
            this.closure_LR0(state);
        }
        else {
            this.closure_LR(state);
        }
    }
    closure_LR0(state) {
        // NOTE: loop grows implicitly inside state.tryPush() function.
        //       do not change this loop.
        state.eachItem(item => {
            const symbol = item.symbolName();
            if (symbol !== _symbols__WEBPACK_IMPORTED_MODULE_7__["END_POSITION"] && !this.isTerminal(symbol)) {
                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));
            }
        });
    }
    closure_LR(state) {
        let isNewExpected;
        do {
            isNewExpected = false;
            state.eachItem(item => {
                const symbol = item.symbolName();
                if (symbol !== _symbols__WEBPACK_IMPORTED_MODULE_7__["END_POSITION"] && !this.isTerminal(symbol)) {
                    const nextSymbols = item.rule.right.slice(item.pos + 1);
                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);
                    this.rules(symbol).forEach(rule => {
                        expectedTerminals.forEach(expectedTerminal => {
                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {
                                isNewExpected = true;
                            }
                        });
                    });
                }
            });
        } while (isNewExpected);
    }
    static nextState_LR0(state, symbol) {
        const nextState = new _State__WEBPACK_IMPORTED_MODULE_6__["State"]();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                nextState.push(new _Item__WEBPACK_IMPORTED_MODULE_4__["Item"](item.rule, item.pos + 1));
            }
        });
        return nextState;
    }
    static nextState_LR(state, symbol) {
        const nextState = new _State__WEBPACK_IMPORTED_MODULE_6__["State"]();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                const expectedSymbols = Array.from(item.expectedSymbols);
                nextState.push(new _Item__WEBPACK_IMPORTED_MODULE_4__["Item"](item.rule, item.pos + 1, expectedSymbols));
            }
        });
        return nextState;
    }
    deleteNotBaseItems() {
        this._states.forEach(state => state.deleteNotBase());
    }
    closureForItem({ rule, pos }) {
        const indexVal = rule.index + "_" + pos;
        let state = this._closureForItemsCache[indexVal];
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(state)) {
            return state;
        }
        state = new _State__WEBPACK_IMPORTED_MODULE_6__["State"]();
        state.push(new _Item__WEBPACK_IMPORTED_MODULE_4__["Item"](rule, pos, [_symbols__WEBPACK_IMPORTED_MODULE_7__["UNUSED_SYMBOL"]]));
        this.closure_LR(state);
        this._closureForItemsCache[indexVal] = state;
        return state;
    }
    addLinkExpected(item, itemX) {
        let table = this._expectedExtensionDMap;
        let index = item.index;
        table[index] = table[index] || {};
        table[index][itemX.index] = true;
    }
    determineExpected(testState, symbol) {
        const stateNext = testState.nextStates[symbol] || null;
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(stateNext)) {
            return;
        }
        // at this moment all items already 'base' because of
        // deleteNotBase() call before.
        testState.eachBaseItem(baseItem => {
            const state = this.closureForItem(baseItem);
            stateNext.eachBaseItem(baseItemNext => {
                const item = state.hasChildItem(baseItemNext);
                if (item) {
                    item.expectedSymbols.forEach(symbol => {
                        if (symbol === _symbols__WEBPACK_IMPORTED_MODULE_7__["UNUSED_SYMBOL"]) {
                            this.addLinkExpected(baseItem, baseItemNext);
                        }
                        else {
                            baseItemNext.addExpected(symbol);
                        }
                    });
                }
            });
        });
    }
    generateLinksExpected() {
        const states = this._states;
        const symbols = this.symbols();
        states.forEach(state => symbols.forEach(symbol => this.determineExpected(state, symbol)));
    }
    expandExpected() {
        const baseItems = this._baseItems;
        const itemExpected = baseItems.map(item => true);
        const table = this._expectedExtensionDMap;
        baseItems[0].addExpected(_symbols__WEBPACK_IMPORTED_MODULE_7__["END_SYMBOL"]);
        itemExpected[0] = (true);
        let isNewExpected;
        do {
            isNewExpected = false;
            baseItems.forEach((baseItem) => {
                if (itemExpected[baseItem.index] && Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDefAndNotNull"])(table[baseItem.index])) {
                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));
                    baseItem.expectedSymbols.forEach(expectedSymbol => {
                        indexesOfExpectedItems.forEach(expectedIndex => {
                            const baseItemExpected = baseItems[expectedIndex];
                            if (baseItemExpected.addExpected(expectedSymbol)) {
                                itemExpected[expectedIndex] = true;
                                isNewExpected = true;
                            }
                        });
                    });
                }
                itemExpected[baseItem.index] = false;
            });
        } while (isNewExpected);
    }
    generateStates(type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR0) {
            this.generateStates_LR0();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR1) {
            this.generateStates_LR();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LALR) {
            this.generateStates_LALR();
        }
    }
    generateStates_LR0() {
        this.generateFirstState_LR0();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                const symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR0(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR0);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LR() {
        this._firstTerminalsCache = {};
        this.generateFirstState_LR();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                let symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserType"].k_LR1);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LALR() {
        this._baseItems = [];
        this._expectedExtensionDMap = {};
        this._closureForItemsCache = {};
        this._firstTerminalsCache = {};
        this.generateStates_LR0();
        this.deleteNotBaseItems();
        this.generateLinksExpected();
        this.expandExpected();
        this._states.forEach(state => this.closure_LR(state));
    }
    addReducing(syntaxTable, state, reduceOperationsMap) {
        state.eachItem(item => {
            if (item.symbolName() === _symbols__WEBPACK_IMPORTED_MODULE_7__["END_POSITION"]) {
                if (item.rule.left === _symbols__WEBPACK_IMPORTED_MODULE_7__["START_SYMBOL"]) {
                    this.pushInSyntaxTable(syntaxTable, state.index, _symbols__WEBPACK_IMPORTED_MODULE_7__["END_SYMBOL"], { type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Success });
                }
                else {
                    for (const expectedSymbol of item.expectedSymbols) {
                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);
                    }
                }
            }
        });
    }
    addShift(syntaxTable, state, shiftOperationsMap) {
        const nextStates = state.nextStates;
        const nextSymbols = Object.keys(nextStates);
        for (let i = 0; i < nextSymbols.length; i++) {
            const nextState = nextStates[nextSymbols[i]];
            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);
        }
    }
    buildSyntaxTable(type) {
        this._states = [];
        this._syntaxTable = {};
        const stateList = this._states;
        const syntaxTable = this._syntaxTable;
        this.generateStates(type);
        const reduceOperationsMap = {};
        const shiftOperationsMap = {};
        stateList.forEach(state => {
            shiftOperationsMap[state.index] = {
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Shift,
                stateIndex: state.index
            };
        });
        const nonTerminals = this.nonTerminals();
        nonTerminals.forEach(nonTerminal => {
            this.rules(nonTerminal).forEach(rule => {
                reduceOperationsMap[rule.index] = {
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Reduce,
                    rule: rule
                };
            });
        });
        //Build syntax table
        stateList.forEach(state => {
            this.addReducing(syntaxTable, state, reduceOperationsMap);
            this.addShift(syntaxTable, state, shiftOperationsMap);
        });
    }
    statesToString(isBaseOnly = true) {
        if (!this._states) {
            return "";
        }
        let msg = "";
        for (let i = 0; i < this._states.length; i++) {
            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);
            msg += " ";
        }
        return msg;
    }
    static operationToString(operation) {
        let opVal = "";
        switch (operation.type) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Shift:
                opVal = "SHIFT to state " + operation.stateIndex.toString();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Reduce:
                opVal = "REDUCE by rule { " + AbstractParser.ruleToString(operation.rule) + " }";
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Success:
                opVal = "SUCCESS";
                break;
        }
        return opVal;
    }
    static ruleToString(rule) {
        let ruleVal;
        ruleVal = rule.left + " : " + rule.right.join(" ");
        return ruleVal;
    }
    convertGrammarSymbol(symbol) {
        if (!this.isTerminal(symbol)) {
            return symbol;
        }
        return this.lexerEngine.getTerminalValueByName(symbol);
    }
}
AbstractParser.$parserEngine = null;
AbstractParser.$parserParams = null;


/***/ }),

/***/ "9EOq":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProvideInstruction.ts ***!
  \****************************************************************/
/*! exports provided: ProvideInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProvideInstruction", function() { return ProvideInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


class ProvideInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ moduleName, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Provide, ...settings });
        this._value = moduleName;
    }
    get moduleName() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
}


/***/ }),

/***/ "9fu3":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js!./src/sandbox/containers/editor/LanguageServiceProvider.ts ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "ce8785dbd7ad0b8ff096.worker.js");
};

/***/ }),

/***/ "9hKy":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts ***!
  \******************************************************************/
/*! exports provided: ProxyTypeInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProxyTypeInstruction", function() { return ProxyTypeInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "u2cq");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




class ProxyTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"] {
    constructor(settings) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ProxyType, ...settings });
        this._host = null;
    }
    get host() {
        return this._host;
    }
    get writable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get readable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get name() {
        return this.isResolved() ? this.host.name : 'auto';
    }
    get size() {
        return this.isResolved() ? this.host.size : _helpers__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_SIZE;
    }
    get baseType() {
        return this.host;
    }
    get arrayElementType() {
        return this.isResolved() ? this.host.arrayElementType : null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this.isResolved() ? this.host.length : _helpers__WEBPACK_IMPORTED_MODULE_2__["instruction"].UNDEFINE_LENGTH;
    }
    get fieldNames() {
        return this.isResolved() ? this.host.fieldNames : [];
    }
    get fields() {
        return this.isResolved() ? this.host.fields : [];
    }
    get methods() {
        return [];
    }
    isResolved() {
        return !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.host);
    }
    resolve(host) {
        this._host = host;
    }
    isSampler() {
        return this.isResolved() ? this.host.isSampler() : false;
    }
    isTexture() {
        return this.isResolved() ? this.host.isTexture() : false;
    }
    isUAV() {
        return this.isResolved() ? this.host.isUAV() : false;
    }
    toString() {
        return this.isResolved() ? this.host.toString() : this.name;
    }
    /** @deprecated */
    toDeclString() {
        return this.isResolved() ? this.host.toDeclString() : null;
    }
    /** @deprecated */
    isEqual(value) {
        return _helpers__WEBPACK_IMPORTED_MODULE_2__["type"].equals(this, value);
    }
    toCode() {
        return this.isResolved() ? this.host.toCode() : this.name;
    }
    isBase() {
        return this.isResolved() ? this.host.isBase() : false;
    }
    isArray() {
        return this.isResolved() ? this.host.isArray() : false;
    }
    isNotBaseArray() {
        return this.isResolved() ? this.host.isNotBaseArray() : false;
    }
    isComplex() {
        return this.isResolved() ? this.host.isComplex() : false;
    }
    isConst() {
        return this.isResolved() ? this.host.isConst() : false;
    }
    /** @deprecated */
    isContainArray() {
        return this.isResolved() ? this.host.isContainArray() : false;
    }
    /** @deprecated */
    isContainSampler() {
        return this.isResolved() ? this.host.isContainSampler() : false;
    }
    /** @deprecated */
    isContainComplexType() {
        return this.isResolved() ? this.host.isContainComplexType() : false;
    }
    hasField(fieldName) {
        return this.isResolved() ? this.host.hasField(fieldName) : false;
    }
    hasFieldWithSematics(semantic) {
        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;
    }
    getField(fieldName) {
        return this.isResolved() ? this.host.getField(fieldName) : null;
    }
    getMethod(methodName, args) {
        return this.isResolved() ? this.host.getMethod(methodName, args) : null;
    }
    getFieldBySemantics(semantic) {
        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;
    }
    hasFieldWithoutSemantics() {
        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;
    }
    hasAllUniqueSemantics() {
        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;
    }
}


/***/ }),

/***/ "9vj8":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StringInstruction.ts ***!
  \***************************************************************/
/*! exports provided: StringInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringInstruction", function() { return StringInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "hljw");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");




class StringInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_StringExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__["VariableTypeInstruction"].wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_STRING"], _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["SCOPE"]), scope, ...settings });
        this._value = value;
    }
    get value() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
    evaluate() {
        this._evalResult = this._value;
        return true;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "9w3R":
/*!****************************************!*\
  !*** ./src/sandbox/logic/fxRuntime.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "pvc7");
/* harmony import */ var _sandbox_containers_playground_PipelineNEXT__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/containers/playground/PipelineNEXT */ "CdMW");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! redux-logic */ "Mn3S");
// tslint:disable:no-for-in
// tslint:disable:forin





const playgroundUpdateLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_4__["createLogic"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_ANALYSIS_COMPLETE"], _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PLAYGROUND_SELECT_EFFECT"]],
    async process({ getState, action }, dispatch, done) {
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_3__["getFileState"])(getState());
        if (!file.slDocument) {
            done();
            return;
        }
        if (file.slDocument.diagnosticReport.errors > 0) {
            done();
            return;
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('playground has been updated.');
        const scope = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_3__["getScope"])(file);
        const list = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_3__["filterPartFx"])(scope);
        let active = action.type === _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PLAYGROUND_SELECT_EFFECT"] ? action.payload.name : null;
        let emitterPrev = file.emitter;
        let emitterNext = null;
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(emitterPrev) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(active)) {
            if (list.map(fx => fx.name)
                .indexOf(emitterPrev.name) !== -1) {
                active = emitterPrev.name;
            }
        }
        if (!active) {
            for (const fx of list) {
                if (fx.isValid()) {
                    active = fx.name;
                    break;
                }
            }
        }
        if (active) {
            const i = list.map(fx => fx.name)
                .indexOf(active);
            if (!emitterPrev || !(await emitterPrev.shadowReload(list[i]))) {
                emitterNext = await _sandbox_containers_playground_PipelineNEXT__WEBPACK_IMPORTED_MODULE_2__["createEmitter"](list[i]);
                // emitterNext = await Pipeline.createEmitter(list[i]);
                if (emitterNext) {
                    emitterNext.start();
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('next emitter has been created.');
                }
            }
        }
        if (emitterNext && emitterPrev) {
            emitterPrev.stop();
            emitterPrev = null;
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('previous emitter has been dropped.');
        }
        const emitter = emitterNext || emitterPrev;
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PLAYGROUND_EMITER_UPDATE"], payload: { emitter } });
        done();
    }
});
/* harmony default export */ __webpack_exports__["default"] = ([
    playgroundUpdateLogic
]);


/***/ }),

/***/ "BKBR":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: FunctionDeclInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionDeclInstruction", function() { return FunctionDeclInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "mXWi");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
 * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
 */
class FunctionDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__["DeclInstruction"] {
    constructor({ definition, implementation = null, attributes = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionDecl, ...settings });
        this.def = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(definition, this);
        this.impl = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(implementation, this);
        this.attributes = (attributes || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(attr, this));
    }
    get name() {
        return this.def.name;
    }
    get id() {
        return this.def.id;
    }
    get semantic() {
        return this.def.semantic;
    }
    toCode() {
        let code = '';
        code += this.def.toCode();
        if (this.impl) {
            code += this.impl.toCode();
        }
        else {
            code += ';';
        }
        return code;
    }
}


/***/ }),

/***/ "BW2l":
/*!*********************************************!*\
  !*** ./src/lib/idl/bytecode/EOperations.ts ***!
  \*********************************************/
/*! exports provided: EOperation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOperation", function() { return EOperation; });
var EOperation;
(function (EOperation) {
    // note: assuming that Load is 32bit and Move is 32bit too
    EOperation[EOperation["k_I32LoadRegister"] = 0] = "k_I32LoadRegister";
    EOperation[EOperation["k_I32LoadInput"] = 1] = "k_I32LoadInput";
    EOperation[EOperation["k_I32LoadInputPointer"] = 2] = "k_I32LoadInputPointer";
    EOperation[EOperation["k_I32LoadRegistersPointer"] = 3] = "k_I32LoadRegistersPointer";
    EOperation[EOperation["k_I32StoreRegisterPointer"] = 4] = "k_I32StoreRegisterPointer";
    EOperation[EOperation["k_I32StoreInput"] = 5] = "k_I32StoreInput";
    EOperation[EOperation["k_I32StoreInputPointer"] = 6] = "k_I32StoreInputPointer";
    EOperation[EOperation["k_I32SetConst"] = 7] = "k_I32SetConst";
    //
    // Arithemtic operations
    //
    EOperation[EOperation["k_I32Add"] = 8] = "k_I32Add";
    EOperation[EOperation["k_I32Sub"] = 9] = "k_I32Sub";
    EOperation[EOperation["k_I32Mul"] = 10] = "k_I32Mul";
    EOperation[EOperation["k_I32Div"] = 11] = "k_I32Div";
    EOperation[EOperation["k_F32Add"] = 12] = "k_F32Add";
    EOperation[EOperation["k_F32Sub"] = 13] = "k_F32Sub";
    EOperation[EOperation["k_F32Mul"] = 14] = "k_F32Mul";
    EOperation[EOperation["k_F32Div"] = 15] = "k_F32Div";
    //
    // Relational operations
    //
    EOperation[EOperation["k_U32LessThan"] = 16] = "k_U32LessThan";
    EOperation[EOperation["k_U32GreaterThanEqual"] = 17] = "k_U32GreaterThanEqual";
    EOperation[EOperation["k_I32LessThan"] = 18] = "k_I32LessThan";
    EOperation[EOperation["k_I32GreaterThanEqual"] = 19] = "k_I32GreaterThanEqual";
    EOperation[EOperation["k_I32Equal"] = 20] = "k_I32Equal";
    EOperation[EOperation["k_I32NotEqual"] = 21] = "k_I32NotEqual";
    EOperation[EOperation["k_I32Not"] = 22] = "k_I32Not";
    EOperation[EOperation["k_F32LessThan"] = 23] = "k_F32LessThan";
    EOperation[EOperation["k_F32GreaterThanEqual"] = 24] = "k_F32GreaterThanEqual";
    //
    // Logical operations
    //
    EOperation[EOperation["k_I32LogicalOr"] = 25] = "k_I32LogicalOr";
    EOperation[EOperation["k_I32LogicalAnd"] = 26] = "k_I32LogicalAnd";
    //
    // intrinsics
    //
    EOperation[EOperation["k_F32Frac"] = 27] = "k_F32Frac";
    EOperation[EOperation["k_F32Floor"] = 28] = "k_F32Floor";
    EOperation[EOperation["k_F32Ceil"] = 29] = "k_F32Ceil";
    EOperation[EOperation["k_F32Sin"] = 30] = "k_F32Sin";
    EOperation[EOperation["k_F32Cos"] = 31] = "k_F32Cos";
    EOperation[EOperation["k_F32Abs"] = 32] = "k_F32Abs";
    EOperation[EOperation["k_F32Sqrt"] = 33] = "k_F32Sqrt";
    EOperation[EOperation["k_F32Max"] = 34] = "k_F32Max";
    EOperation[EOperation["k_F32Min"] = 35] = "k_F32Min";
    EOperation[EOperation["k_I32Mad"] = 36] = "k_I32Mad";
    EOperation[EOperation["k_I32Min"] = 37] = "k_I32Min";
    EOperation[EOperation["k_I32Max"] = 38] = "k_I32Max";
    // 
    // Cast operations
    //
    EOperation[EOperation["k_F32ToU32"] = 39] = "k_F32ToU32";
    EOperation[EOperation["k_F32ToI32"] = 40] = "k_F32ToI32";
    EOperation[EOperation["k_U32ToF32"] = 41] = "k_U32ToF32";
    EOperation[EOperation["k_I32ToF32"] = 42] = "k_I32ToF32";
    //
    // Flow control
    //
    EOperation[EOperation["k_Jump"] = 43] = "k_Jump";
    EOperation[EOperation["k_JumpIf"] = 44] = "k_JumpIf";
    // the operation is only necessary to maintain the purity of the code, 
    // when generating the code will be replaced by a jump for all 
    // functions except entry point;
    EOperation[EOperation["k_Ret"] = 45] = "k_Ret";
})(EOperation || (EOperation = {}));
;


/***/ }),

/***/ "C2sc":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdInstruction.ts ***!
  \***********************************************************/
/*! exports provided: IdInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdInstruction", function() { return IdInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


class IdInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ name, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Id, ...settings });
        this.name = name;
    }
    toString() {
        return this.name;
    }
    toCode() {
        return this.name;
    }
}


/***/ }),

/***/ "C3oy":
/*!**************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts ***!
  \**************************************************************************/
/*! exports provided: PostfixArithmeticInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostfixArithmeticInstruction", function() { return PostfixArithmeticInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent someExpr ++
 * (-- | ++) Instruction
 */
class PostfixArithmeticInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ expr, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixArithmeticExpr, type: expr.type, ...settings });
        this._operator = operator;
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.expr.toCode();
        code += this.operator;
        return code;
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "CdMW":
/*!***********************************************************!*\
  !*** ./src/sandbox/containers/playground/PipelineNEXT.ts ***!
  \***********************************************************/
/*! exports provided: createEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmitter", function() { return createEmitter; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "oof7");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "2oKZ");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/SLDocument */ "XL/w");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "DSeY");
/* harmony import */ var _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/translators/GlslEmitter */ "SKCH");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ "Womt");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");









function createUAVEx(document, reflection, length) {
    const elementSize = document.root.scope.findType(reflection.elementType).size; // in bytes
    return _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["createUAV"](reflection.name, elementSize, length, reflection.register);
}
// tslint:disable-next-line:max-line-length
function createUAVsEx(document, reflection, capacity, sharedUAVs = []) {
    return reflection.uavs.map(uavReflection => {
        const shraredUAV = sharedUAVs.find(uav => uav.name === uavReflection.name);
        return shraredUAV || createUAVEx(document, uavReflection, capacity);
    });
}
function createBundle(document, reflection) {
    const shader = document.root.scope.findFunction(reflection.name, null);
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(shader);
    // const numthreads = shader.attributes.find(attr => attr.name === 'numthreads');
    // assert(isDefAndNotNull(numthreads));
    const program = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_2__["translate"](shader);
    return _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["load"](program.code);
}
function setupBundle(document, reflection, capacity, sharedUAVs) {
    const bundle = createBundle(document, reflection);
    const uavs = createUAVsEx(document, reflection, capacity, sharedUAVs);
    const numthreads = reflection.numthreads;
    uavs.forEach(uav => { bundle.input[uav.index] = uav.buffer; });
    // update shared uavs
    sharedUAVs.push(...uavs.filter(uav => sharedUAVs.indexOf(uav) === -1));
    function setConstants(constants) {
        Object.keys(constants)
            .forEach(name => _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["setConstant"](bundle, name, constants[name]));
    }
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(numthreads[0] >= 1 && numthreads[1] === 1 && numthreads[2] === 1);
    function run(numgroups) {
        _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["dispatch"](bundle, [numgroups, 1, 1], numthreads);
    }
    return {
        uavs,
        bundle,
        run,
        setConstants,
        groupsizex: numthreads[0]
    };
}
function fxHash(fx) {
    const hashPart = fx.passList
        .map(pass => `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].signature(pass.particleInstance)}:${pass.geometry}:${pass.sorting}:`) // +
        // `${crc32(Code.translate(pass.vertexShader))}:${crc32(Code.translate(pass.pixelShader))}`)
        .reduce((commonHash, passHash) => `${commonHash}:${passHash}`);
    return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].signature(fx.particle)}:${fx.capacity}:${hashPart}`;
}
function createTimelime() {
    let startTime;
    let elapsedTimeLevel;
    let active;
    const constants = {
        elapsedTime: 0,
        elapsedTimeLevel: 0
    };
    function stop() {
        active = false;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter stopped');
    }
    function start() {
        constants.elapsedTime = 0;
        constants.elapsedTimeLevel = 0;
        startTime = Date.now();
        elapsedTimeLevel = 0;
        active = true;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter started');
    }
    function tick() {
        if (!active) {
            return;
        }
        const dt = Date.now() - startTime;
        constants.elapsedTime = (dt - elapsedTimeLevel) / 1000;
        constants.elapsedTimeLevel = elapsedTimeLevel / 1000;
        elapsedTimeLevel = dt;
    }
    function isStopped() {
        return !active;
    }
    return {
        constants,
        start,
        stop,
        tick,
        isStopped
    };
}
// tslint:disable-next-line:max-func-body-length
async function load(fx, uavResources) {
    const emitter = new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__["FxTranslator"]();
    const reflection = emitter.emitPartFxDecl(fx);
    const textDocument = { uri: '://raw', source: emitter.toString() };
    const slDocument = await Object(_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_4__["createSLDocument"])(textDocument);
    if (slDocument.diagnosticReport.errors) {
        console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__["Diagnostics"].stringify(slDocument.diagnosticReport));
        return null;
    }
    const { name, capacity } = reflection;
    const scope = slDocument.root.scope;
    const particle = scope.findType(reflection.particle);
    const resetBundle = setupBundle(slDocument, reflection.CSParticlesResetRoutine, capacity, uavResources);
    const initBundle = setupBundle(slDocument, reflection.CSParticlesInitRoutine, capacity, uavResources);
    const updateBundle = setupBundle(slDocument, reflection.CSParticlesUpdateRoutine, capacity, uavResources);
    const spawnBundle = setupBundle(slDocument, reflection.CSParticlesSpawnRoutine, 4, uavResources);
    const uavDeadIndices = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__["FxTranslator"].UAV_DEAD_INDICES);
    const uavParticles = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__["FxTranslator"].UAV_PARTICLES);
    const uavStates = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__["FxTranslator"].UAV_STATES);
    const uavInitArguments = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_5__["FxTranslator"].UAV_SPAWN_DISPATCH_ARGUMENTS);
    const passes = reflection.passes.map(({ VSParticleShader, PSParticleShader, geometry, sorting, instanceCount, instance, CSParticlesPrerenderRoutine }, i) => {
        const UAV_PRERENDERED = `uavPrerendered${i}`;
        const bundle = setupBundle(slDocument, CSParticlesPrerenderRoutine, capacity * instanceCount, uavResources);
        const uav = bundle.uavs.find(uav => uav.name === UAV_PRERENDERED);
        const vertexShader = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_6__["translate"](scope.findFunction(VSParticleShader, null), { mode: 'vertex' });
        const pixelShader = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_6__["translate"](scope.findFunction(PSParticleShader, null), { mode: 'pixel' });
        const instanceType = scope.findType(instance);
        const stride = instanceType.size >> 2;
        const numRenderedParticles = () => numParticles() * instanceCount;
        const instanceLayout = instanceType.fields.map(field => {
            const size = field.type.size >> 2;
            const offset = field.type.padding >> 2;
            const attrName = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_6__["GlslEmitter"].$declToAttributeName(field);
            return { attrName, size, offset };
        });
        // tslint:disable-next-line:max-line-length
        const uavPrerenderedReflection = CSParticlesPrerenderRoutine.uavs.find(uavReflection => uavReflection.name === UAV_PRERENDERED);
        const elementType = scope.findType(uavPrerenderedReflection.elementType);
        // dump prerendered particles
        const dump = () => {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])(`dump ${uav.readCounter()}/${capacity} prerendred particles: `);
            for (let iElement = 0; iElement < uav.readCounter(); ++iElement) {
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])(_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["asNativeInner"](uav.readElement(iElement), elementType));
            }
        };
        //
        // Sorting
        //
        const uavNonSorted = uav;
        const uavSorted = !sorting ? uavNonSorted : createUAVEx(slDocument, uavPrerenderedReflection, capacity);
        function sort(targetPos) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(sorting);
            // NOTE: yes, I understand this is a crappy and stupid brute force sorting,
            //       I hate javascript for that :/
            const v3 = new three__WEBPACK_IMPORTED_MODULE_7__["Vector3"]();
            const length = numRenderedParticles();
            const nStride = stride * instanceCount; // stride in floats
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(uavSorted.data.byteLength >> 2 === nStride * capacity);
            const src = new Float32Array(uavNonSorted.data.buffer, uavNonSorted.data.byteOffset, uavNonSorted.data.byteLength >> 2);
            const dst = new Float32Array(uavSorted.data.buffer, uavSorted.data.byteOffset, uavSorted.data.byteLength >> 2);
            const indicies = [];
            // NOTE: sort using only first instance's postion
            for (let iPart = 0; iPart < length; ++iPart) {
                const offset = iPart * nStride;
                const dist = v3
                    .fromArray(src, offset /* add offset of POSTION semantic */)
                    .distanceTo(targetPos);
                indicies.push([iPart, dist]);
            }
            indicies.sort((a, b) => -a[1] + b[1]);
            for (let i = 0; i < indicies.length; ++i) {
                const iFrom = indicies[i][0] * nStride;
                const iTo = i * nStride;
                const from = src.subarray(iFrom, iFrom + nStride);
                const copyTo = dst.subarray(iTo, iTo + nStride);
                copyTo.set(from);
            }
        }
        const data = new Uint8Array(uavSorted.data.buffer, uavSorted.data.byteOffset, uavSorted.data.byteLength);
        return {
            data,
            instanceLayout,
            stride,
            geometry,
            sorting,
            vertexShader,
            pixelShader,
            length: numRenderedParticles,
            sort,
            bundle,
            dump
        };
    });
    const numParticles = () => capacity - uavDeadIndices.readCounter();
    function reset() {
        // reset all available particles
        resetBundle.run(Math.ceil(capacity / resetBundle.groupsizex));
        uavDeadIndices.overwriteCounter(capacity);
    }
    function update(timeline) {
        updateBundle.setConstants(timeline.constants);
        updateBundle.run(Math.ceil(capacity / updateBundle.groupsizex));
    }
    function prerender(timelime) {
        passes.forEach(({ bundle }, i) => {
            const uavPrerendered = bundle.uavs.find(uav => uav.name === `uavPrerendered${i}`);
            uavPrerendered.overwriteCounter(0);
            bundle.setConstants(timelime.constants);
            bundle.run(Math.ceil(capacity / bundle.groupsizex));
        });
    }
    function emit(timeline) {
        initBundle.setConstants(timeline.constants);
        // console.log('emit >>', uavInitArguments.data[0],
        //     (new Float32Array(uavInitArguments.data.buffer, uavInitArguments.data.byteOffset))[3],
        //     (new Float32Array(uavInitArguments.data.buffer, uavInitArguments.data.byteOffset))[4]);
        initBundle.run(uavInitArguments.data[0]);
        spawnBundle.setConstants(timeline.constants);
        spawnBundle.run(1);
        // console.log(spawnBundle.uavs, timeline.constants.elapsedTime);
        return;
    }
    function dump() {
        const npart = numParticles();
        const partSize = particle.size;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])(`particles total: ${npart} (${uavDeadIndices.readCounter()}/${capacity})`);
        uavStates.data.forEach((alive, iPart) => {
            if (alive) {
                const partRaw = new Uint8Array(uavParticles.data.buffer, uavParticles.data.byteOffset + iPart * partSize, partSize);
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])(iPart, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__["asNativeInner"](partRaw, particle));
            }
        });
    }
    return {
        name,
        capacity,
        passes,
        numParticles,
        reset,
        emit,
        update,
        prerender,
        dump
    };
}
// tslint:disable-next-line:max-func-body-length
async function createEmitter(fx) {
    const uavResources = []; // << shared UAV resources
    const timeline = createTimelime();
    const emitter = await load(fx, uavResources);
    if (!emitter) {
        return null;
    }
    let { name, capacity, passes, numParticles, reset, emit, update, prerender, dump } = emitter;
    reset();
    const { start, stop, isStopped } = timeline;
    function tick() {
        if (!timeline.isStopped()) {
            update(timeline);
            emit(timeline);
            prerender(timeline);
            timeline.tick();
        }
    }
    async function shadowReload(fxNext) {
        if (fxHash(fxNext) !== fxHash(fx)) {
            return false;
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter reloaded from the shadow');
        const emitter = await load(fxNext, uavResources);
        if (!emitter) {
            return false;
        }
        ({
            name,
            capacity,
            passes,
            numParticles,
            reset,
            emit,
            update,
            prerender,
            dump
        } = emitter);
        return true;
    }
    return {
        get name() {
            return name;
        },
        capacity,
        start,
        stop,
        tick,
        isStopped,
        length: numParticles,
        passes,
        reset,
        shadowReload
    };
}


/***/ }),

/***/ "DAvO":
/*!*************************************!*\
  !*** ./src/lib/idl/part/IPartFx.ts ***!
  \*************************************/
/*! exports provided: EPartFxPassGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPartFxPassGeometry", function() { return EPartFxPassGeometry; });
// import { EPartFxInstructionTypes } from "./IPartFxInstruction";
var EPartFxPassGeometry;
(function (EPartFxPassGeometry) {
    EPartFxPassGeometry[EPartFxPassGeometry["k_Billboard"] = 0] = "k_Billboard";
    EPartFxPassGeometry[EPartFxPassGeometry["k_Cylinder"] = 1] = "k_Cylinder";
    EPartFxPassGeometry[EPartFxPassGeometry["k_Box"] = 2] = "k_Box";
    EPartFxPassGeometry[EPartFxPassGeometry["k_Sphere"] = 3] = "k_Sphere";
    EPartFxPassGeometry[EPartFxPassGeometry["k_Line"] = 4] = "k_Line";
})(EPartFxPassGeometry || (EPartFxPassGeometry = {}));


/***/ }),

/***/ "DSeY":
/*!************************************************!*\
  !*** ./src/lib/fx/translators/FxTranslator.ts ***!
  \************************************************/
/*! exports provided: FxTranslator, translateFlat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FxTranslator", function() { return FxTranslator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateFlat", function() { return translateFlat; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _FxEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FxEmitter */ "eck8");



;
class FxTranslator extends _FxEmitter__WEBPACK_IMPORTED_MODULE_2__["FxEmitter"] {
    constructor() {
        super(...arguments);
        this.knownUAVs = [];
        this.knownSpawnCtors = [];
    }
    emitSpawnStmt(stmt) {
        let guid = this.knownSpawnCtors.findIndex(ctor => ctor === stmt.init) + 1;
        if (guid === 0) {
            this.knownSpawnCtors.push(stmt.init);
            guid = this.knownSpawnCtors.length;
            this.emitSpawnOperator(guid, stmt.init);
        }
        this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitKeyword(`${stmt.count}u`);
        if (stmt.args.length) {
            this.emitChar(',');
            this.emitExpressionList(stmt.args);
        }
        this.emitChar(')');
        this.emitChar(';');
        this.emitNewline();
        // super.emitSpawnStmt(stmt);
    }
    emitUav(type, name, comment) {
        let register = this.knownUAVs.map(uav => uav.name).indexOf(name);
        if (register === -1) {
            this.begin();
            {
                register = this.knownUAVs.length;
                comment && this.emitComment(comment);
                this.emitLine(`${type} ${name}: register(u${register});`);
                const regexp = /^([\w]+)<([\w0-9_]+)>$/;
                const match = type.match(regexp);
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(match);
                const reflection = {
                    name,
                    type,
                    uavType: match[1],
                    elementType: match[2],
                    register
                };
                this.knownUAVs.push(reflection);
            }
            this.end();
        }
        return this.knownUAVs[register];
    }
    emitResetShader(fx) {
        const name = 'CSParticlesResetRoutine';
        const numthreads = [64, 1, 1];
        const uavs = [];
        const reflection = { name, numthreads, uavs };
        const capacity = fx.capacity;
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint tid = DTid.x;`);
                this.emitLine(`if (tid >= ${capacity}) return;`);
                uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));
                this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[tid] = tid;`);
                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));
                this.emitLine(`${FxTranslator.UAV_STATES}[tid] = 0;`);
                const { typeName: partType } = this.resolveType(fx.particle);
                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));
                this.emitLine(`${partType} Particle;`);
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fx.particle.isComplex());
                fx.particle.fields.forEach(({ name, type }) => {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type.length >= 1);
                    let zero = Object(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isFloatBasedType"])(type) ? '0.f' : Object(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isBoolBasedType"])(type) ? 'false' : '0';
                    if (type.length === 1) {
                        this.emitLine(`Particle.${name} = ${zero};`);
                    }
                    else {
                        this.emitLine(`Particle.${name} = ${type.name}(${Array(type.length).fill(zero).join(', ')});`);
                    }
                });
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[tid] = Particle;`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        return reflection;
    }
    // TOOD: sync groupSize with value used inside the emitInitShader();
    emitSpawnOperator(guid, ctor, groupSize = 64) {
        const uavs = [];
        this.begin();
        {
            this.emitKeyword('void');
            this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitKeyword(`uint nPart`);
            if (ctor) {
                this.emitChar(',');
                this.emitParams(ctor.def.params.slice(2));
            }
            this.emitChar(')');
            this.emitChar('{');
            this.push();
            {
                uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));
                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION));
                this.emitLine(`int nGroups = (int)ceil((float)nPart / ${groupSize}.f);`);
                this.emitLine(`for (int i = 0; i < nGroups; ++i)`);
                this.emitChar(`{`);
                this.push();
                {
                    this.emitLine(`uint RequestId;`);
                    this.emitLine(`// layout: [ uint GroupCountX, uint GroupCountY, uint GroupCountZ ]`);
                    this.emitLine(`InterlockedAdd(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0], 1u, RequestId);`);
                    // params
                    const request = `${FxTranslator.UAV_CREATION_REQUESTS}[RequestId]`;
                    this.emitLine(`${request}.count = min(nPart, ${groupSize}u);`);
                    this.emitLine(`${request}.type = ${guid}u;`);
                    if (ctor) {
                        const params = ctor.def.params;
                        let nfloat = 0;
                        // skip first two arguments
                        params.slice(2).forEach(param => {
                            let type = param.type;
                            if (type.isComplex()) {
                                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported', type.toCode());
                            }
                            let n = type.size / _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_FLOAT"].size;
                            for (let i = 0; i < n; ++i) {
                                this.emitLine(`${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}] = asfloat(${param.name}${type.isArray() ? `[${i % 4}]` : ``});`);
                                nfloat++;
                            }
                        });
                    }
                    this.emitLine(`nPart = nPart - ${groupSize}u;`);
                }
                this.pop();
                this.emitChar(`}`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        return uavs;
    }
    emitSpawnShader(fx) {
        const spawnFn = fx.spawnRoutine.function;
        const elapsedTime = fx.scope.findVariable('elapsedTime');
        const name = 'CSParticlesSpawnRoutine';
        const numthreads = [1, 1, 1];
        const uavs = [];
        const reflection = { name, numthreads, uavs };
        uavs.push(...this.emitSpawnOperator(0, null));
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`if (DTid.x != 0u) return;`);
                this.emitNewline();
                this.emitLine(`// usage of 4th element of ${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS} as temp value of number of particles`);
                this.emitFunction(spawnFn);
                this.emitGlobal(elapsedTime);
                this.emitLine(`float nPartAddFloat = asfloat(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3]) + (float)${spawnFn.name}() * elapsedTime;`);
                this.emitLine(`float nPartAdd = floor(nPartAddFloat);`);
                // TODO: replace with InterlockedExchange()
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0] = 0u;`);
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[1] = 1u;`);
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[2] = 1u;`);
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3] = asuint(nPartAddFloat - nPartAdd);`);
                // TODO: check the capacity
                // this.emitLine(`nPartAdd = min(nPartAdd, )`)
                this.emitLine(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}0__((uint)nPartAdd);`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        return reflection;
    }
    emitInitShader(fx) {
        const initFn = fx.initRoutine.function;
        const name = 'CSParticlesInitRoutine';
        const numthreads = [64, 1, 1];
        const uavs = [];
        const reflection = { name, numthreads, uavs };
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint GroupId = Gid.x;`);
                this.emitLine(`uint ThreadId = GTid.x;`);
                // TODO: emit operator instead!
                uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));
                this.emitLine(`uint nPart = ${FxTranslator.UAV_CREATION_REQUESTS}[GroupId].count;`);
                this.emitNewline();
                this.emitLine(`if (ThreadId >= nPart) return;`);
                this.emitNewline();
                uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));
                this.emitLine(`int n = (int)${FxTranslator.UAV_DEAD_INDICES}.DecrementCounter();`);
                this.emitComment(`a bit confusing way to check for particles running out`);
                this.emitLine(`if (n <= 0)`);
                this.emitChar('{');
                this.push();
                {
                    this.emitComment(`not very beautiful, but a cheap way not to`);
                    this.emitComment(`think about the correctness of this counter`);
                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);
                    this.emitLine('return;');
                }
                this.pop();
                this.emitChar('}');
                this.emitNewline();
                this.emitNewline();
                this.emitLine(`uint PartId = ${FxTranslator.UAV_DEAD_INDICES}[n];`);
                const { typeName: partType } = this.resolveType(fx.particle);
                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));
                this.emitLine(`${partType} Particle;`);
                this.emitFunction(initFn);
                const request = `${FxTranslator.UAV_CREATION_REQUESTS}[GroupId]`;
                this.emitLine(`uint type = ${request}.type;`);
                this.emitLine(`if (type == 0u)`);
                this.emitChar('{');
                this.push();
                {
                    this.emitLine(`${initFn.name}(Particle${initFn.def.params.length > 1 ? ', PartId' : ''});`);
                }
                this.pop();
                this.emitChar('}');
                this.emitNewline();
                this.knownSpawnCtors.forEach((ctor, i) => {
                    this.emitFunction(ctor);
                    this.emitLine(`else if (type == ${i + 1}u)`);
                    this.emitChar('{');
                    this.push();
                    {
                        // TODO: move param unpacking to separate function
                        // unpack arguments
                        let nfloat = 0;
                        let params = ctor.def.params.slice(2);
                        params.forEach(param => {
                            this.emitVariableDecl(param);
                            this.emitChar(';');
                            this.emitNewline();
                            const type = param.type;
                            if (type.isComplex()) {
                                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported', type.toCode());
                            }
                            let interpreter = 'asfloat';
                            if (Object(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isFloatBasedType"])(type)) {
                                interpreter = 'asfloat';
                            }
                            if (Object(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isIntBasedType"])(type)) {
                                interpreter = 'asint';
                            }
                            if (Object(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isUIntBasedType"])(type)) {
                                interpreter = 'asuint';
                            }
                            let n = type.size / _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_FLOAT"].size;
                            for (let i = 0; i < n; ++i) {
                                this.emitLine(`${param.name}${type.isArray() ? `[${i % 4}]` : ``} = ${interpreter}(${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}]);`);
                                nfloat++;
                            }
                            this.emitNewline();
                        });
                        this.emitLine(`${ctor.name}(Particle, PartId, ${params.map(param => param.name).join(', ')});`);
                    }
                    this.pop();
                    this.emitChar('}');
                    this.emitNewline();
                });
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);
                this.emitComment('set particles\'s state as \'Alive\'');
                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));
                this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 1;`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        return reflection;
    }
    emitUpdateShader(fx) {
        const updateFn = fx.updateRoutine.function;
        const name = 'CSParticlesUpdateRoutine';
        const numthreads = [64, 1, 1];
        const uavs = [];
        const reflection = { name, numthreads, uavs };
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint PartId = DTid.x;`);
                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));
                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);
                this.emitNewline();
                this.emitLine(`[branch]`);
                this.emitLine(`if(!Alive) return;`);
                this.emitNewline();
                const { typeName: partType } = this.resolveType(fx.particle);
                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));
                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);
                this.emitNewline();
                this.emitFunction(updateFn);
                this.emitLine(`[branch]`);
                this.emitLine(`if (!${updateFn.name}(Particle${updateFn.def.params.length > 1 ? ', PartId' : ''}))`);
                this.emitChar('{');
                this.push();
                {
                    uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));
                    this.emitComment('returning the particle index to the list of the dead');
                    this.emitLine(`uint n = ${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);
                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[n] = PartId;`);
                    this.emitNewline();
                    this.emitComment('set particles\'s state as \'dead\'');
                    this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 0;`);
                    this.emitLine('return;');
                }
                this.pop();
                this.emitChar('}');
                this.emitNewline();
                this.emitNewline();
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        // hack
        uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));
        uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION));
        return reflection;
    }
    emitPrerenderShader(fx, pass, i) {
        const prerenderFn = pass.prerenderRoutine.function;
        const name = `CSParticlesPrerenderShader${i}`;
        const numthreads = [64, 1, 1];
        const uavs = [];
        const reflection = { name, numthreads, uavs };
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint PartId = DTid.x;`);
                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));
                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);
                this.emitNewline();
                this.emitLine(`[branch]`);
                this.emitLine(`if(!Alive) return;`);
                this.emitNewline();
                this.emitFunction(prerenderFn);
                const { typeName: partType } = this.resolveType(fx.particle);
                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));
                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);
                const { typeName: prerenderedType } = this.resolveType(prerenderFn.def.params[1].type);
                uavs.push(this.emitUav(`AppendStructuredBuffer<${prerenderedType}>`, `${FxTranslator.UAV_PRERENDERED}${i}`));
                if (pass.instanceCount > 1) {
                    this.emitLine(`for(int InstanceId = 0; InstanceId < ${pass.instanceCount}; InstanceId++)`);
                    this.emitChar('{');
                    this.push();
                }
                {
                    this.emitLine(`${prerenderedType} Prerendered;`);
                    if (prerenderFn.def.params.length == 3) {
                        if (pass.instanceCount === 1) {
                            this.emitLine(`int InstanceId = 0;`);
                        }
                        this.emitLine(`${prerenderFn.name}(Particle, Prerendered, InstanceId);`);
                    }
                    else {
                        this.emitLine(`${prerenderFn.name}(Particle, Prerendered);`);
                    }
                    this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}.Append(Prerendered);`);
                }
                if (pass.instanceCount > 1) {
                    this.pop();
                    this.emitChar('}');
                    this.emitNewline();
                }
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        return reflection;
    }
    emitSpawnOpContainer() {
        const payloadSize = this.knownSpawnCtors.map(
        // slice 1 or 2 depending on necessity of partID
        ctor => ctor.def.params.slice(2).map(param => param.type.size).reduce((size, summ) => summ + size, 0))
            .reduce((size, summ) => summ + size, 0);
        const alignment = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_FLOAT4"].size;
        const numF4 = Math.ceil(payloadSize / alignment);
        this.begin();
        {
            this.emitLine(`struct ${FxTranslator.SPAWN_OPERATOR_TYPE}`);
            this.emitChar(`{`);
            this.push();
            {
                this.emitLine(`uint count;`);
                this.emitLine(`uint type;`);
                // this.emitLine(`uint _pad[2];`);
                // emit padding?
                if (numF4 > 0) {
                    this.emitNewline();
                    this.emitLine(`float4 payload[${numF4}];`);
                }
            }
            this.pop();
            this.emitChar(`}`);
            this.emitChar(';');
        }
        // NOTE: emit as prologue!
        this.end(true);
    }
    emitPartFxDecl(fx) {
        const { name, capacity } = fx;
        const CSParticlesSpawnRoutine = this.emitSpawnShader(fx);
        const CSParticlesResetRoutine = this.emitResetShader(fx);
        const CSParticlesUpdateRoutine = fx.updateRoutine && this.emitUpdateShader(fx);
        const CSParticlesInitRoutine = fx.initRoutine && this.emitInitShader(fx);
        const passes = fx.passList.map((pass, i) => {
            const { prerenderRoutine, vertexShader, pixelShader } = pass;
            let { sorting, geometry, instanceCount } = pass;
            let VSParticleShader = null;
            let PSParticleShader = null;
            let CSParticlesPrerenderRoutine = null;
            if (prerenderRoutine) {
                CSParticlesPrerenderRoutine = this.emitPrerenderShader(fx, pass, i);
            }
            if (vertexShader) {
                this.emitFunction(vertexShader);
                VSParticleShader = vertexShader.name;
            }
            if (pixelShader) {
                this.emitFunction(pixelShader);
                PSParticleShader = pixelShader.name;
            }
            const { typeName: instance } = this.resolveType(pass.particleInstance);
            return {
                instance,
                sorting,
                geometry,
                instanceCount,
                VSParticleShader,
                PSParticleShader,
                CSParticlesPrerenderRoutine
            };
        });
        this.emitSpawnOpContainer();
        const { typeName: particle } = this.resolveType(fx.particle);
        return {
            name,
            capacity,
            particle,
            passes,
            CSParticlesSpawnRoutine,
            CSParticlesResetRoutine,
            CSParticlesInitRoutine,
            CSParticlesUpdateRoutine
        };
    }
}
FxTranslator.UAV_PARTICLES = 'uavParticles';
FxTranslator.UAV_STATES = 'uavStates';
FxTranslator.UAV_DEAD_INDICES = 'uavDeadIndices';
FxTranslator.UAV_CREATION_REQUESTS = 'uavCreationRequests';
FxTranslator.UAV_PRERENDERED = 'uavPrerendered';
FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS = 'uavSpawnDispatchArguments';
FxTranslator.UAV_PARTICLES_DESCRIPTION = `The buffer contains user-defined particle data.`;
FxTranslator.UAV_STATES_DESCRIPTION = `The buffer contains the state of the particles, Alive or dead.`;
FxTranslator.UAV_DEAD_INDICES_DESCRIPTION = `The buffer contains indicies of dead particles.`;
FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION = 'The buffer contatins information about the number and type of particles to be created';
FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION = '[no description added :/]';
FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME = '__spawn_op';
FxTranslator.SPAWN_OPERATOR_TYPE = '__SPAWN_T__';
function translateFlat(fx) {
    const emitter = new FxTranslator();
    const reflection = emitter.emitPartFxDecl(fx);
    // console.log(JSON.stringify(reflection, null, '\t'));
    return emitter.toString();
}


/***/ }),

/***/ "DTTp":
/*!********************************!*\
  !*** ./src/lib/fx/Visitors.ts ***!
  \********************************/
/*! exports provided: visitor, Visitor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visitor", function() { return visitor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Visitor", function() { return Visitor; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");

// TODO: move it to helpers
function visitor(owner, cb) {
    if (!owner) {
        return;
    }
    const visit = (instr) => {
        if (instr) {
            cb(instr, owner);
            visitor(instr, cb);
        }
    };
    switch (owner.instructionType) {
        //
        // Stmt
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ReturnStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_DeclStmt:
            owner.declList.forEach(decl => visit(decl));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ExprStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IfStmt:
            visit(owner.cond);
            visit(owner.conseq);
            visit(owner.contrary);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_StmtBlock:
            owner.stmtList.forEach(stmt => visit(stmt));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ForStmt:
            visit(owner.init);
            visit(owner.cond);
            visit(owner.body);
            visit(owner.step);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_WhileStmt:
            visit(owner.cond);
            visit(owner.body);
            break;
        //
        // Expr
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ArithmeticExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_AssignmentExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_CastExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_CompileExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as ICompileExprInstruction).function);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ComplexExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ConditionalExpr:
            visit(owner.left);
            visit(owner.right);
            visit(owner.condition);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ConstructorCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IConstructorCallInstruction).ctor);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IFunctionCallInstruction).decl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IdExpr:
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_InitExpr:
            owner.args.forEach(arg => visit(arg));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IntExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FloatExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BoolExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_StringExpr:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_LogicalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixArithmeticExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixIndexExpr:
            visit(owner.element);
            visit(owner.index);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixPointExpr:
            visit(owner.element);
            visit(owner.postfix);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_RelationalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SamplerStateBlockExpr:
            owner.params.forEach(param => visit(param));
            visit(owner.texture);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_UnaryExpr:
            visit(owner.expr);
            break;
        //
        // Others
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ComplexType:
            owner.fields.forEach(field => visit(field));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionDef:
            visit(owner.returnType);
            visit(owner.id);
            owner.params.forEach(param => visit(param));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionDecl:
            visit(owner.def);
            visit(owner.impl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_VariableDecl:
            visit(owner.type);
            visit(owner.initExpr);
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_VariableType:
            visit(owner.subType);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Id:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SystemFunctionDecl:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SystemType:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BreakStmt:
            break;
        default:
            console.error('unsupported instruction type found');
    }
}
const Visitor = {
    each: visitor
};


/***/ }),

/***/ "FrU9":
/*!*************************************!*\
  !*** ./src/lib/idl/IInstruction.ts ***!
  \*************************************/
/*! exports provided: EInstructionTypes, ECheckStage, EVarUsedMode, EExtractExprType, EScopeType, ETechniqueType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EInstructionTypes", function() { return EInstructionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ECheckStage", function() { return ECheckStage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVarUsedMode", function() { return EVarUsedMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EExtractExprType", function() { return EExtractExprType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EScopeType", function() { return EScopeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETechniqueType", function() { return ETechniqueType; });
var EInstructionTypes;
(function (EInstructionTypes) {
    EInstructionTypes[EInstructionTypes["k_Instruction"] = 0] = "k_Instruction";
    EInstructionTypes[EInstructionTypes["k_Id"] = 1] = "k_Id";
    EInstructionTypes[EInstructionTypes["k_Provide"] = 2] = "k_Provide";
    EInstructionTypes[EInstructionTypes["k_Collector"] = 3] = "k_Collector";
    EInstructionTypes[EInstructionTypes["k_Keyword"] = 4] = "k_Keyword";
    EInstructionTypes[EInstructionTypes["k_Simple"] = 5] = "k_Simple";
    EInstructionTypes[EInstructionTypes["k_SamplerState"] = 6] = "k_SamplerState";
    EInstructionTypes[EInstructionTypes["k_Attribute"] = 7] = "k_Attribute";
    EInstructionTypes[EInstructionTypes["k_Annotation"] = 8] = "k_Annotation";
    EInstructionTypes[EInstructionTypes["k_UsageType"] = 9] = "k_UsageType";
    EInstructionTypes[EInstructionTypes["k_Typed"] = 10] = "k_Typed";
    EInstructionTypes[EInstructionTypes["k_VariableType"] = 11] = "k_VariableType";
    EInstructionTypes[EInstructionTypes["k_SystemType"] = 12] = "k_SystemType";
    EInstructionTypes[EInstructionTypes["k_ComplexType"] = 13] = "k_ComplexType";
    EInstructionTypes[EInstructionTypes["k_ProxyType"] = 14] = "k_ProxyType";
    EInstructionTypes[EInstructionTypes["k_Expr"] = 15] = "k_Expr";
    EInstructionTypes[EInstructionTypes["k_IdExpr"] = 16] = "k_IdExpr";
    EInstructionTypes[EInstructionTypes["k_IntExpr"] = 17] = "k_IntExpr";
    EInstructionTypes[EInstructionTypes["k_FloatExpr"] = 18] = "k_FloatExpr";
    EInstructionTypes[EInstructionTypes["k_BoolExpr"] = 19] = "k_BoolExpr";
    EInstructionTypes[EInstructionTypes["k_StringExpr"] = 20] = "k_StringExpr";
    EInstructionTypes[EInstructionTypes["k_ArithmeticExpr"] = 21] = "k_ArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_AssignmentExpr"] = 22] = "k_AssignmentExpr";
    EInstructionTypes[EInstructionTypes["k_RelationalExpr"] = 23] = "k_RelationalExpr";
    EInstructionTypes[EInstructionTypes["k_LogicalExpr"] = 24] = "k_LogicalExpr";
    EInstructionTypes[EInstructionTypes["k_ConditionalExpr"] = 25] = "k_ConditionalExpr";
    EInstructionTypes[EInstructionTypes["k_CastExpr"] = 26] = "k_CastExpr";
    EInstructionTypes[EInstructionTypes["k_UnaryExpr"] = 27] = "k_UnaryExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixIndexExpr"] = 28] = "k_PostfixIndexExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixPointExpr"] = 29] = "k_PostfixPointExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixArithmeticExpr"] = 30] = "k_PostfixArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_ComplexExpr"] = 31] = "k_ComplexExpr";
    EInstructionTypes[EInstructionTypes["k_FunctionCallExpr"] = 32] = "k_FunctionCallExpr";
    EInstructionTypes[EInstructionTypes["k_ConstructorCallExpr"] = 33] = "k_ConstructorCallExpr";
    EInstructionTypes[EInstructionTypes["k_CompileExpr"] = 34] = "k_CompileExpr";
    EInstructionTypes[EInstructionTypes["k_InitExpr"] = 35] = "k_InitExpr";
    EInstructionTypes[EInstructionTypes["k_SamplerStateBlockExpr"] = 36] = "k_SamplerStateBlockExpr";
    EInstructionTypes[EInstructionTypes["k_Decl"] = 37] = "k_Decl";
    EInstructionTypes[EInstructionTypes["k_TypeDecl"] = 38] = "k_TypeDecl";
    EInstructionTypes[EInstructionTypes["k_VariableDecl"] = 39] = "k_VariableDecl";
    EInstructionTypes[EInstructionTypes["k_StructDecl"] = 40] = "k_StructDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDecl"] = 41] = "k_FunctionDecl";
    EInstructionTypes[EInstructionTypes["k_SystemFunctionDecl"] = 42] = "k_SystemFunctionDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDef"] = 43] = "k_FunctionDef";
    EInstructionTypes[EInstructionTypes["k_PassDecl"] = 44] = "k_PassDecl";
    EInstructionTypes[EInstructionTypes["k_TechniqueDecl"] = 45] = "k_TechniqueDecl";
    EInstructionTypes[EInstructionTypes["k_Stmt"] = 46] = "k_Stmt";
    EInstructionTypes[EInstructionTypes["k_ExprStmt"] = 47] = "k_ExprStmt";
    EInstructionTypes[EInstructionTypes["k_BreakStmt"] = 48] = "k_BreakStmt";
    EInstructionTypes[EInstructionTypes["k_WhileStmt"] = 49] = "k_WhileStmt";
    EInstructionTypes[EInstructionTypes["k_ForStmt"] = 50] = "k_ForStmt";
    EInstructionTypes[EInstructionTypes["k_IfStmt"] = 51] = "k_IfStmt";
    EInstructionTypes[EInstructionTypes["k_DeclStmt"] = 52] = "k_DeclStmt";
    EInstructionTypes[EInstructionTypes["k_ReturnStmt"] = 53] = "k_ReturnStmt";
    EInstructionTypes[EInstructionTypes["k_SemicolonStmt"] = 54] = "k_SemicolonStmt";
    EInstructionTypes[EInstructionTypes["k_StmtBlock"] = 55] = "k_StmtBlock";
    // part fx
    EInstructionTypes[EInstructionTypes["k_PartFxDecl"] = 56] = "k_PartFxDecl";
    EInstructionTypes[EInstructionTypes["k_PartFxPass"] = 57] = "k_PartFxPass";
    EInstructionTypes[EInstructionTypes["k_SpawnStmt"] = 58] = "k_SpawnStmt";
})(EInstructionTypes || (EInstructionTypes = {}));
var ECheckStage;
(function (ECheckStage) {
    ECheckStage[ECheckStage["CODE_TARGET_SUPPORT"] = 0] = "CODE_TARGET_SUPPORT";
    ECheckStage[ECheckStage["SELF_CONTAINED"] = 1] = "SELF_CONTAINED"; /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */
    // VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ 
})(ECheckStage || (ECheckStage = {}));
var EVarUsedMode;
(function (EVarUsedMode) {
    EVarUsedMode[EVarUsedMode["k_Read"] = 0] = "k_Read";
    EVarUsedMode[EVarUsedMode["k_Write"] = 1] = "k_Write";
    EVarUsedMode[EVarUsedMode["k_ReadWrite"] = 2] = "k_ReadWrite";
    EVarUsedMode[EVarUsedMode["k_Undefined"] = 3] = "k_Undefined";
    EVarUsedMode[EVarUsedMode["k_Default"] = 2] = "k_Default";
})(EVarUsedMode || (EVarUsedMode = {}));
var EExtractExprType;
(function (EExtractExprType) {
    EExtractExprType[EExtractExprType["k_Header"] = 0] = "k_Header";
    EExtractExprType[EExtractExprType["k_Float"] = 1] = "k_Float";
    EExtractExprType[EExtractExprType["k_Int"] = 2] = "k_Int";
    EExtractExprType[EExtractExprType["k_Bool"] = 3] = "k_Bool";
    EExtractExprType[EExtractExprType["k_Float2"] = 4] = "k_Float2";
    EExtractExprType[EExtractExprType["k_Int2"] = 5] = "k_Int2";
    EExtractExprType[EExtractExprType["k_Bool2"] = 6] = "k_Bool2";
    EExtractExprType[EExtractExprType["k_Float3"] = 7] = "k_Float3";
    EExtractExprType[EExtractExprType["k_Int3"] = 8] = "k_Int3";
    EExtractExprType[EExtractExprType["k_Bool3"] = 9] = "k_Bool3";
    EExtractExprType[EExtractExprType["k_Float4"] = 10] = "k_Float4";
    EExtractExprType[EExtractExprType["k_Int4"] = 11] = "k_Int4";
    EExtractExprType[EExtractExprType["k_Bool4"] = 12] = "k_Bool4";
    EExtractExprType[EExtractExprType["k_Float4x4"] = 13] = "k_Float4x4";
})(EExtractExprType || (EExtractExprType = {}));
var EScopeType;
(function (EScopeType) {
    EScopeType[EScopeType["k_System"] = 0] = "k_System";
    EScopeType[EScopeType["k_Global"] = 1] = "k_Global";
    EScopeType[EScopeType["k_Default"] = 2] = "k_Default";
    EScopeType[EScopeType["k_Struct"] = 3] = "k_Struct";
    EScopeType[EScopeType["k_Annotation"] = 4] = "k_Annotation";
})(EScopeType || (EScopeType = {}));
var ETechniqueType;
(function (ETechniqueType) {
    ETechniqueType[ETechniqueType["k_BasicFx"] = 0] = "k_BasicFx";
    ETechniqueType[ETechniqueType["k_PartFx"] = 1] = "k_PartFx";
    ETechniqueType[ETechniqueType["k_Unknown"] = 2] = "k_Unknown";
})(ETechniqueType || (ETechniqueType = {}));


/***/ }),

/***/ "GH4Y":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts ***!
  \************************************************************************/
/*! exports provided: ConstructorCallInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstructorCallInstruction", function() { return ConstructorCallInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Instruction */ "2b0+");





/**
 * Resresnt ctor(arg1,..., argn)
 * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
 */
class ConstructorCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_3__["ExprInstruction"] {
    constructor({ ctor, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ConstructorCallExpr, type: ctor.subType, ...settings });
        this._args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_4__["Instruction"].$withParent(arg, this));
        this._ctor = _Instruction__WEBPACK_IMPORTED_MODULE_4__["Instruction"].$withParent(ctor, this);
    }
    get args() {
        return this._args;
    }
    get ctor() {
        return this._ctor;
    }
    toCode() {
        var code = "";
        code += this.ctor.toCode();
        code += "(";
        for (var i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        for (var i = 0; i < this.args.length; i++) {
            if (!this.args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
    /** @deprecated */
    evaluate() {
        if (!this.isConst()) {
            return false;
        }
        var res = null;
        var jsTypeCtor = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["getExternalType"](this.type);
        var args = new Array(this.args.length);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(jsTypeCtor)) {
            return false;
        }
        try {
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isScalarType"](this.type)) {
                var pTestedInstruction = this.args[0];
                if (this.args.length > 1 || !pTestedInstruction.evaluate()) {
                    return false;
                }
                res = jsTypeCtor(pTestedInstruction.getEvalValue());
            }
            else {
                for (var i = 0; i < this.args.length; i++) {
                    var pTestedInstruction = this.args[i];
                    if (pTestedInstruction.evaluate()) {
                        args[i - 1] = pTestedInstruction.getEvalValue();
                    }
                    else {
                        return false;
                    }
                }
                res = new jsTypeCtor;
                res.set.apply(res, args);
            }
        }
        catch (e) {
            return false;
        }
        this._evalResult = res;
        return true;
    }
}


/***/ }),

/***/ "GIxw":
/*!********************************!*\
  !*** ./src/lib/parser/Item.ts ***!
  \********************************/
/*! exports provided: Item */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Item", function() { return Item; });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols */ "YPfw");


class Item {
    constructor(rule, pos, expectedSymbols) {
        this.rule = rule;
        this.pos = pos;
        this.index = 0;
        this.expectedSymbols = new Set();
        if (expectedSymbols) {
            expectedSymbols.forEach(symbol => this.addExpected(symbol));
        }
    }
    isEqual(item, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserType"].k_LR0) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserType"].k_LR0) {
            return (this.rule === item.rule && this.pos === item.pos);
        }
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserType"].k_LR1) {
            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {
                return false;
            }
            for (const symbol of this.expectedSymbols) {
                if (!item.isExpected(symbol)) {
                    return false;
                }
            }
            return true;
        }
        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.
        return false;
    }
    isParentItem(item) {
        return (this.rule === item.rule && this.pos === item.pos + 1);
    }
    isChildItem(item) {
        return (this.rule === item.rule && this.pos === item.pos - 1);
    }
    symbolName() {
        const right = this.rule.right;
        if (this.pos === right.length) {
            return _symbols__WEBPACK_IMPORTED_MODULE_1__["END_POSITION"];
        }
        return right[this.pos];
    }
    // lastSymbolName(): string {
    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;
    // }
    // // get next symbol name
    // nextSymbolName(): string {
    //     return this.rule.right[this.pos + 1] || END_POSITION;
    // }
    isExpected(symbol) {
        return this.expectedSymbols.has(symbol);
    }
    addExpected(symbol) {
        if (this.isExpected(symbol)) {
            return false;
        }
        this.expectedSymbols.add(symbol);
        return true;
    }
    toString(grammarSymbols = null) {
        const { left, right } = this.rule;
        let msg = `${left} -> `;
        msg += right
            .map(s => Item.decodeSymbol(s, grammarSymbols))
            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))
            .join(' ');
        if (this.pos === right.length) {
            msg += " . ";
        }
        if (this.expectedSymbols) {
            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));
            if (expectedTokens.length) {
                msg += ", " + expectedTokens.join(' ');
            }
        }
        return msg;
    }
    static decodeSymbol(s, grammarSymbols) {
        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);
    }
}


/***/ }),

/***/ "Gbih":
/*!*********************************************!*\
  !*** ./src/lib/fx/bytecode/ConstantPool.ts ***!
  \*********************************************/
/*! exports provided: ConstantPoolMemory, ConstanPool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantPoolMemory", function() { return ConstantPoolMemory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstanPool", function() { return ConstanPool; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytecode */ "oof7");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PromisedAddress */ "m5Cl");




class ConstantPoolMemory {
    constructor() {
        this.byteArray = new Uint8Array(4);
        this.byteLength = 0;
    }
    get byteCapacity() {
        return this.byteArray.byteLength;
    }
    /** Check capacity and make realloc if needed. */
    check(byteSize) {
        let expected = this.byteLength + byteSize;
        if (expected <= this.byteCapacity) {
            return;
        }
        var oldBuffer = this.byteArray;
        var newBuffer = new Uint8Array(Math.max(expected, this.byteCapacity * 2));
        newBuffer.set(oldBuffer);
        this.byteArray = newBuffer;
    }
    /**
     *
     * @param size Size in bytes.
     */
    addUniform(size, name) {
        this.check(size);
        this.byteLength += size;
    }
}
class ConstanPool {
    constructor() {
        this._data = new ConstantPoolMemory;
        this._knownConstants = [];
    }
    deref(decl) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(decl.isGlobal() && decl.type.isUniform());
        const { name, semantic, initExpr, type: { size } } = decl;
        let reflection = this._knownConstants.find(c => c.name === name);
        if (!reflection) {
            let addr = null;
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(initExpr)) {
                // TODO: add type to description
                addr = this.addUniform(size, `${name}${semantic ? `:${semantic}` : ''}`);
            }
            else {
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported');
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_3__["default"].INVALID;
            }
            const { addr: offset } = addr;
            const type = decl.type.name; // TODO: use signature?
            reflection = {
                name,
                semantic,
                offset,
                size,
                type
            };
            this._knownConstants.push(reflection);
        }
        // NOTE: we return copy because adress will be loaded
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_3__["default"]({
            type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Input,
            inputIndex: _Bytecode__WEBPACK_IMPORTED_MODULE_2__["CBUFFER0_REGISTER"],
            addr: reflection.offset,
            size
        });
    }
    addUniform(size, desc) {
        const addr = this._data.byteLength;
        this._data.addUniform(size, desc);
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_3__["default"]({
            type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Input,
            inputIndex: _Bytecode__WEBPACK_IMPORTED_MODULE_2__["CBUFFER0_REGISTER"],
            addr,
            size
        });
    }
    get data() {
        return this._data;
    }
    get size() {
        return this._data.byteLength;
    }
    dump() {
        return this._knownConstants;
    }
}
/* harmony default export */ __webpack_exports__["default"] = (ConstanPool);


/***/ }),

/***/ "I537":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts ***!
  \******************************************************************/
/*! exports provided: UnaryExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnaryExprInstruction", function() { return UnaryExprInstruction; });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VariableTypeInstruction */ "hljw");





/**
 * Represent + - ! ++ -- expr
 * (+|-|!|++|--|) Instruction
 */
class UnaryExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__["ExprInstruction"] {
    constructor({ expr, operator, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_UnaryExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: operator === '!'
                ? _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__["VariableTypeInstruction"].wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__["T_BOOL"], _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__["SCOPE"])
                : expr.type,
            ...settings
        });
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(expr, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        var sCode = '';
        sCode += this.operator;
        sCode += this.expr.toCode();
        return sCode;
    }
    isConst() {
        return this.expr.isConst();
    }
    evaluate() {
        var op = this.operator;
        var expr = this.expr;
        if (!expr.evaluate()) {
            return false;
        }
        var res = null;
        try {
            res = expr.getEvalValue();
            switch (op) {
                case '+':
                    res = +res;
                    break;
                case '-':
                    res = -res;
                    break;
                case '!':
                    res = !res;
                    break;
                case '++':
                    res = ++res;
                    break;
                case '--':
                    res = --res;
                    break;
            }
        }
        catch (e) {
            return false;
        }
        this._evalResult = res;
        return true;
    }
}


/***/ }),

/***/ "IHXS":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/ProgramScope.ts ***!
  \*********************************************/
/*! exports provided: Scope, ProgramScope */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scope", function() { return Scope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProgramScope", function() { return ProgramScope; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "u2cq");



class Scope {
    constructor({ type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Default, parent = null, strictMode = false }) {
        this.type = type;
        this.parent = parent;
        this.strictMode = strictMode;
        this.variables = {};
        this.types = {};
        this.functions = {};
        this.techniques = {};
        this.typeTemplates = {};
    }
    isStrict() {
        return this.filter(scope => scope.strictMode);
    }
    findVariable(varName) {
        return this.filter(scope => scope.variables[varName] || null);
    }
    findTypeTemplate(typeName) {
        return this.filter(scope => scope.typeTemplates[typeName] || null);
    }
    findType(typeName) {
        return this.filter(scope => scope.types[typeName] || null);
    }
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    findFunction(funcName, args = null) {
        return this.filter(scope => _helpers__WEBPACK_IMPORTED_MODULE_2__["fn"].matchList(scope.functions[funcName], args));
    }
    findTechnique(techName) {
        return this.filter(scope => scope.techniques[techName] || null);
    }
    findFunctionInScope(func) {
        let res = _helpers__WEBPACK_IMPORTED_MODULE_2__["fn"].matchList(this.functions[func.name], func.def.params.map(param => param ? param.type : null));
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(res !== undefined);
        return res;
    }
    addVariable(variable) {
        let variableMap = this.variables;
        let varName = variable.name;
        if (!this.variables[varName]) {
            variableMap[varName] = variable;
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(variable.scope === this);
        }
        else {
            // console.error(`letiable '${varName}' already exists in scope:`, this);
            return false;
        }
        return true;
    }
    addTypeTemplate(template) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(this.typeTemplates[template.name])) {
            return false;
        }
        this.typeTemplates[template.name] = template;
        return true;
    }
    // todo: remove scopeId from argumts, use type.scope instead.
    addType(type) {
        if (this.types[type.name]) {
            return false;
        }
        this.types[type.name] = type;
        console.assert(type.scope === this);
        return true;
    }
    addFunction(func) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Global);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(func.scope === this);
        let funcMap = this.functions;
        let funcName = func.name;
        funcMap[funcName] = funcMap[funcName] || [];
        const funcOverloads = funcMap[funcName];
        let targetFunc = this.findFunctionInScope(func);
        if (!targetFunc) {
            funcOverloads.push(func);
        }
        else {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func.impl));
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(targetFunc.impl));
            let i = funcOverloads.indexOf(targetFunc);
            funcOverloads[i] = func;
        }
        return true;
    }
    addTechnique(technique) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Global);
        if (this.techniques[technique.name]) {
            return false;
        }
        this.techniques[technique.name] = technique;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(technique.scope === this);
        return false;
    }
    filter(cb) {
        let scope = this;
        while (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(scope)) {
            let res = cb(scope);
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(res)) {
                return res;
            }
            scope = scope.parent;
        }
        return null;
    }
}
class ProgramScope {
    constructor(parent) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(parent !== null);
        let type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Global;
        this.globalScope = new Scope({ parent, type });
        this.currentScope = this.globalScope;
    }
    validate() {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.currentScope === this.globalScope);
    }
    push(type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Default) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.currentScope !== null);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type >= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EScopeType"].k_Default);
        let parent = this.currentScope;
        let scope = new Scope({ parent, type });
        this.currentScope = scope;
    }
    pop() {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.currentScope !== null);
        this.currentScope = this.currentScope.parent;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.currentScope !== null);
    }
}


/***/ }),

/***/ "IK5l":
/*!*****************************************!*\
  !*** ./src/sandbox/components/index.ts ***!
  \*****************************************/
/*! exports provided: ASTView, ProgramView, FileListView, MemoryView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ASTView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ASTView */ "yp6H");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ASTView", function() { return _ASTView__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _ProgramView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ProgramView */ "s8BN");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgramView", function() { return _ProgramView__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _FileListView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FileListView */ "SdNh");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileListView", function() { return _FileListView__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _MemoryView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MemoryView */ "UneR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MemoryView", function() { return _MemoryView__WEBPACK_IMPORTED_MODULE_3__["default"]; });





;


/***/ }),

/***/ "IwZZ":
/*!***************************************!*\
  !*** ./src/lib/fx/bytecode/VM/uav.ts ***!
  \***************************************/
/*! exports provided: createUAV */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createUAV", function() { return createUAV; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "oof7");
/* harmony import */ var _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/sizeof */ "ihHD");



function createUAV(name, elementSize, length, register) {
    const counterSize = _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_2__["default"].i32();
    const size = counterSize + length * elementSize; // in bytes
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(size % _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_2__["default"].i32() === 0);
    const buffer = new Int32Array(size >> 2);
    const data = buffer.subarray(counterSize >> 2);
    const counter = new Int32Array(buffer.buffer, buffer.byteOffset, 1);
    const index = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__["UAV0_REGISTER"] + register;
    function overwriteCounter(value) {
        counter[0] = value;
    }
    function readCounter() {
        return counter[0];
    }
    function readElement(iElement) {
        return new Uint8Array(data.buffer, data.byteOffset + iElement * elementSize, elementSize);
    }
    overwriteCounter(0);
    return {
        name,
        readElement,
        readCounter,
        overwriteCounter,
        // byte length of a single element
        elementSize,
        // number of elements
        length,
        // register specified in the shader
        register,
        // [ elements ]
        data,
        // raw data [ counter, ...elements ]
        buffer,
        // input index for VM
        index
    };
}


/***/ }),

/***/ "KGxL":
/*!***************************************!*\
  !*** ./src/sandbox/reducers/index.ts ***!
  \***************************************/
/*! exports provided: getCommon, getLocation, matchLocation, mapProps, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommon", function() { return getCommon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocation", function() { return getLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchLocation", function() { return matchLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapProps", function() { return mapProps; });
/* harmony import */ var _sandbox_logic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/logic */ "3uV/");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router */ "Ty5D");
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux */ "ANjH");
/* harmony import */ var _parserParams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parserParams */ "vHMa");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./router */ "SMK2");
/* harmony import */ var _sourceFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sourceFile */ "NtUi");






/**
 * selectors
 */
// most common selector;
// markers are very expensive for react update :/
const getCommon = (state) => state;
// ({ ...state, sourceFile: { ...state.sourceFile, markers: null } });
const getLocation = (state) => state.router.location.pathname;
const matchLocation = (state) => Object(react_router__WEBPACK_IMPORTED_MODULE_1__["matchPath"])(getLocation(state), { path: _sandbox_logic__WEBPACK_IMPORTED_MODULE_0__["LOCATION_PATTERN"], exact: false });
// helper function in order to get proper props from state using custom selector;
function mapProps(selector) {
    return (state) => selector(state);
}
/* harmony default export */ __webpack_exports__["default"] = (Object(redux__WEBPACK_IMPORTED_MODULE_2__["combineReducers"])({ sourceFile: _sourceFile__WEBPACK_IMPORTED_MODULE_5__["default"], parserParams: _parserParams__WEBPACK_IMPORTED_MODULE_3__["default"], router: _router__WEBPACK_IMPORTED_MODULE_4__["default"] }));


/***/ }),

/***/ "KjJp":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/FxAnalyzer.ts ***!
  \*******************************************/
/*! exports provided: FxAnalyzer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FxAnalyzer", function() { return FxAnalyzer; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "a1Km");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "DAvO");
/* harmony import */ var _Analyzer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Analyzer */ "NzFo");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./instructions/IdInstruction */ "C2sc");
/* harmony import */ var _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instructions/part/PartFxInstruction */ "4PT3");
/* harmony import */ var _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./instructions/part/PartFxPassInstruction */ "bUvT");
/* harmony import */ var _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instructions/part/SpawnInstruction */ "cuAd");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SystemScope */ "Wl5j");












const asType = (instr) => instr ? instr.type : null;
class FxContext extends _Analyzer__WEBPACK_IMPORTED_MODULE_5__["Context"] {
    constructor() {
        super(...arguments);
        this.spawnStmts = [];
    }
    // beginFunc(): void {
    //     super.beginFunc();
    // }
    // endFunc(): void {
    //     super.endFunc();
    // }
    beginPartFxPass() {
        this.beginPass();
        this.particleInstance = null;
    }
    endPartFxPass() {
        this.particleInstance = null;
        this.endPass();
    }
    beginPartFx() {
        this.particleCore = null;
    }
    endPartFx() {
        this.particleCore = null;
    }
}
function sliceNode(source, from, to) {
    const { children, parent, name, value, loc } = source;
    return {
        children: children.slice(from, to),
        parent,
        name,
        value,
        loc
    };
}
class FxAnalyzer extends _Analyzer__WEBPACK_IMPORTED_MODULE_5__["Analyzer"] {
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'Init'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '10'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_SPAWN = 'spawn'
     */
    analyzeSpawnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const count = Number(children.slice(-3, -2)[0].value);
        const name = children.slice(-5, -4)[0].value;
        const args = [];
        for (let i = children.length - 7; i >= 2; i--) {
            if (children[i].value !== ',') {
                const arg = this.analyzeExpr(context, program, children[i]);
                args.push(arg);
            }
        }
        const spawnStmt = new _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_9__["SpawnInstruction"]({ sourceNode, scope, name, args, count });
        context.spawnStmts.push(spawnStmt);
        return spawnStmt;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_SPAWN':
                return this.analyzeSpawnStmt(context, program, sourceNode);
            default:
                return super.analyzeSimpleStmt(context, program, sourceNode);
        }
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'SpawnRoutine'
     */
    analyzePartFXProperty(context, program, sourceNode) {
        const children = sourceNode.children;
        console.log(sourceNode);
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_PASS = 'pass'
     */
    analyzePartFXPassDecl(context, program, sourceNode) {
        context.beginPartFxPass();
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        // temp solution in order to not highlight useless pass states in the next analysis call.
        context.renderStates = renderStates;
        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);
        const sorting = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isBoolean"])(fxStates.sorting) ? fxStates.sorting : true;
        const prerenderRoutine = fxStates.prerenderRoutine || null;
        const geometry = fxStates.geometry || _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_4__["EPartFxPassGeometry"].k_Billboard;
        const instanceCount = fxStates.instanceCount || 1;
        //
        // Validation of the shader input
        //
        let pixelShader = entry.pixel;
        /**
         * Vertex shader validation pattern:
         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);
         */
        let vertexShader = entry.vertex;
        if (vertexShader) {
            const requiredSemantics = ['POSITION', 'POSITION0'];
            let hasInstance = false;
            let hasRequiredSemantics = false;
            for (const param of vertexShader.def.params) {
                hasInstance = hasInstance ||
                    param.type.subType === context.particleInstance;
                hasRequiredSemantics = hasRequiredSemantics ||
                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));
            }
            if (!hasInstance) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].PartFx_VertexShaderParametersMismatch, { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });
                vertexShader = pixelShader = null;
            }
            // if (!hasRequiredSemantics) {
            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,
            //         { tooltip: 'doesn\'t have requiredsemantics.' });
            //     vertexShader = pixelShader = null;
            // }
        }
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_6__["IdInstruction"]({ sourceNode: children[i], scope, name });
            }
        }
        const pass = new _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_8__["PartFxPassInstruction"]({
            scope,
            sourceNode,
            id,
            sorting,
            geometry,
            instanceCount,
            prerenderRoutine,
            renderStates,
            pixelShader,
            vertexShader
        });
        //TODO: add annotation and id
        context.endPartFxPass();
        return pass;
    }
    // TODO: use explicit return type
    analyzePartFxStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };
        }
        return states;
    }
    /**
    * AST example:
    *    PassState
    *         T_PUNCTUATOR_59 = ';'
    *       + PassStateExpr
    *         T_PUNCTUATOR_61 = '='
    *         T_NON_TYPE_ID = 'STATE_ONE'
    */
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'STATE_TWO'
     */
    /**
     * AST example:
     *    PassStateExpr
     *         T_PUNCTUATOR_125 = '}'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_44 = ','
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_123 = '{'
     */
    // TODO: add explicit type for fx statess
    analyzePartFXPassProperies(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateName = children[children.length - 1].value.toUpperCase();
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        let fxStates = {};
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprNode.value) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(stateName)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            // TODO: return correct state list
            return fxStates;
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_PUNCTUATOR_125 = '}'
         *         T_UINT = '1'
         *         T_PUNCTUATOR_44 = ','
         *         T_KW_TRUE = 'true'
         *         T_PUNCTUATOR_123 = '{'
         */
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                // TODO: validate values with names
                values[j] = stateExprNode.children[i].value.toUpperCase();
            }
            switch (stateName) {
                // case ERenderStates.BLENDFUNC:
                //     if (values.length !== 2) {
                //         console.warn('Pass state are incorrect.');
                //         return {};
                //     }
                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];
                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];
                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];
                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];
                //     break;
                default:
                    console.warn('Pass fx state is incorrect.');
                    return fxStates;
            }
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_NON_TYPE_ID = 'FALSE'
         */
        else {
            let value = null;
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            switch (stateName) {
                case ('InstanceCount'.toUpperCase()):
                    fxStates.instanceCount = Number(value) || 1;
                    break;
                case ('Geometry'.toUpperCase()):
                    const types = [
                        'Billboard',
                        'Cylinder',
                        'Box',
                        'Sphere',
                        'Line'
                    ].map(type => type.toUpperCase());
                    fxStates.geometry = Math.max(0, types.indexOf(value));
                    break;
                case ('Sorting'.toUpperCase()):
                    // TODO: use correct validation with diag error output
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(value == 'TRUE' || value == 'FALSE');
                    fxStates.sorting = (value === 'TRUE');
                    break;
                case ('PrerenderRoutine'.toUpperCase()):
                    {
                        /**
                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.
                        */
                        let validators = [
                            /* prerender(Part part, PartInstance instance) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_VOID"], args: [context.particleCore, null] },
                            /* prerender(Part part, PartInstance instance, int instanceId) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_VOID"], args: [context.particleCore, null, _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_INT"]] },
                        ];
                        //
                        // TODO: add string-based validators like this:
                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);
                        //
                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);
                        if (!prerenderRoutine) {
                            break;
                        }
                        //
                        // check arguments
                        //
                        let fn = prerenderRoutine.function;
                        /** first argument's type */
                        let argv = fn.def.params.map(param => param.type);
                        if (argv.length < 2) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });
                            prerenderRoutine = null;
                        }
                        if (!argv[0].readable || /*!argv[0].isEqual(context.particle)*/ argv[0].subType !== context.particleCore ||
                            argv[0].isNotBaseArray() ||
                            !argv[1].hasUsage('out') || !argv[1].writable || argv[1].isNotBaseArray()) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });
                            prerenderRoutine = null;
                        }
                        //         argv[1]: "out PartInstance"
                        // argv[1].subType: "PartInstance"
                        context.particleInstance = argv[1].subType;
                        fxStates.prerenderRoutine = prerenderRoutine;
                    }
                    break;
                default:
            }
        }
        return fxStates;
    }
    analyzePartFXBody(context, program, sourceNode) {
        let passList = [];
        let spawnRoutine = null;
        let initRoutine = null;
        let updateRoutine = null;
        let particle = null;
        let capacity = null;
        const children = sourceNode.children;
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassState':
                    {
                        let sourceNode = children[i];
                        let stateName = sourceNode.children[3].value; // "T_NON_TYPE_ID"
                        switch (stateName.toUpperCase()) {
                            case ('Capacity'.toUpperCase()):
                                {
                                    // TODO: make correct validation of the capacity value and emit errors
                                    //       through diagnostics system. 
                                    const snum = sourceNode.children[1].children[0].value;
                                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(Number(snum)));
                                    capacity = Number(snum) || -1;
                                    break;
                                }
                            case ('SpawnRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Spawn routine expected as 'int spawn(void)'.
                                     */
                                    let validator = { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_INT"], args: [] };
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, [validator]);
                                }
                                break;
                            case ('InitRoutine'.toUpperCase()):
                                {
                                    /** Init routine expected as 'void init(in Part part)'. */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_VOID"], args: [null, _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_INT"]] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_VOID"], args: [null, _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_UINT"]] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_VOID"], args: [null] },
                                    ];
                                    // TODO: show error in case of both functions are found
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!initRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    let fn = initRoutine.function;
                                    /** first argument's type */
                                    let type = fn.def.params[0].type;
                                    if ((!type.hasUsage('out') && !type.hasUsage('inout')) || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        initRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                            case ('UpdateRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Update routine expected as 'void update(inout Part part)'.
                                     */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_BOOL"], args: [null, _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_INT"]] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_BOOL"], args: [null] },
                                    ];
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    const fn = updateRoutine.function;
                                    const fdef = fn.def;
                                    const paramList = fdef.params;
                                    if (paramList.length < 1 || paramList.length > 2) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    /** first argument's type */
                                    let type = paramList[0].type;
                                    if (!type.hasUsage('out') && !type.hasUsage('inout') || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    //
                                    // Check return type
                                    //
                                    if (!fdef.returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_BOOL"])) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });
                                        updateRoutine = null;
                                    }
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                        }
                    }
                    break;
            }
        }
        // Note: all fx properties should be parsed prior to pass declaraion analysis
        // because some of them are critical for pass validation
        context.particleCore = particle;
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassDecl':
                    {
                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);
                        if (!pass.isValid()) {
                            context.warn((pass.id && pass.id.sourceNode) || children[i], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__["EAnalyzerWarnings"].IncompletePass, {
                                techniqueName: pass.name,
                                tooltip: `The pass is not completed. Not all required parameters are specified.`
                            });
                        }
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(pass));
                        passList.push(pass);
                    }
                    break;
            }
        }
        return { passList, spawnRoutine, initRoutine, updateRoutine, particle, capacity };
    }
    /**
     * AST example:
     *    PartFxDecl
     *       + PartFxBody
     *       + Annotation
     *       + Semantic
     *       + ComplexNameOpt
     *         T_KW_FXPART = 'partFx'
     */
    analyzePartFXDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let props = null;
        context.beginPartFx();
        for (let i = children.length - 3; i >= 0; i--) {
            switch (children[i].name) {
                case 'Annotation':
                    annotation = this.analyzeAnnotation(children[i]);
                    break;
                case 'Semantic':
                    semantic = this.analyzeSemantic(children[i]);
                    break;
                case 'PartFxBody':
                    props = this.analyzePartFXBody(context, program, children[i]);
                    break;
            }
        }
        context.endPartFx();
        const partFx = new _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_7__["PartFxInstruction"]({
            sourceNode, name, semantic, annotation, scope, ...props
        });
        if (!partFx.isValid()) {
            // highlight name only
            context.warn(children[children.length - 2], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__["EAnalyzerWarnings"].IncompleteTechnique, {
                techniqueName: partFx.name,
                tooltip: `The technique is not completed. Not all required parameters are specified.`
            });
        }
        FxAnalyzer.addTechnique(context, program, partFx);
        return partFx;
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'PartFxDecl':
                return [this.analyzePartFXDecl(context, program, sourceNode)];
            default:
                return super.analyzeUnknDecl(context, program, sourceNode);
        }
    }
    createContext(uri) {
        return new FxContext(uri);
    }
    validate(context, program, root) {
        super.validate(context, program, root);
        const scope = program.globalScope;
        // NOTE: all effects are assumed to be valid
        const fxList = root.instructions.filter(instr => instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_PartFxDecl);
        //
        // spawn operator validation
        //
        for (const spawnStmt of context.spawnStmts) {
            const bImportedEffect = false;
            //parse as the spawn from the same effect
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!bImportedEffect, 'unsupported');
            if (!bImportedEffect) {
                let initializer = null;
                for (const fx of fxList) {
                    // looking for Init(out Part part, int partId: PART_ID, ...parameters)
                    let args = [fx.particle, _SystemScope__WEBPACK_IMPORTED_MODULE_10__["T_INT"], ...spawnStmt.args.map(asType)];
                    initializer = scope.findFunction(spawnStmt.name, args);
                    // in case of signature not found:
                    // looking for signature like: Init(out Part part, ...parameters)
                    if (!initializer) {
                        // looaking for signature like: Init(out Part part, ...parameters)
                        // TODO: check that second parameter doesn't have PART_ID semantic in 
                        //       order to not find false positive signature
                        args = [fx.particle, ...spawnStmt.args.map(asType)];
                        initializer = scope.findFunction(spawnStmt.name, args);
                    }
                    if (initializer) {
                        spawnStmt.$resolve(fx, initializer);
                        break;
                    }
                }
                if (!initializer) {
                    context.error(spawnStmt.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].PartFx_InvalidSpawnStmtInitializerNotFound, { tooltip: 'Invalid spawn statement. Effect initializer not found.' });
                }
            }
        }
    }
}


/***/ }),

/***/ "LZQc":
/*!***********************************!*\
  !*** ./src/lib/util/StringRef.ts ***!
  \***********************************/
/*! exports provided: StringRef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringRef", function() { return StringRef; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");

// helper class to always pass strings by pointer and not by value;
class StringRef {
    constructor(content) {
        this.content = content;
    }
    valueOf() {
        return this.content;
    }
    toString() {
        return this.content;
    }
    toSource() {
        return this.content;
    }
    static make(val) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(val)) {
            return val;
        }
        return new StringRef(`${val}`);
    }
}


/***/ }),

/***/ "LhMq":
/*!***************************************!*\
  !*** ./src/lib/idl/parser/IParser.ts ***!
  \***************************************/
/*! exports provided: ENodeCreateMode, EParserCode, EParserType, IASTDocumentFlags, EParserFlags, ETokenType, EOperationType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENodeCreateMode", function() { return ENodeCreateMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EParserCode", function() { return EParserCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EParserType", function() { return EParserType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IASTDocumentFlags", function() { return IASTDocumentFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EParserFlags", function() { return EParserFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETokenType", function() { return ETokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOperationType", function() { return EOperationType; });
var ENodeCreateMode;
(function (ENodeCreateMode) {
    ENodeCreateMode[ENodeCreateMode["k_Default"] = 0] = "k_Default";
    ENodeCreateMode[ENodeCreateMode["k_Necessary"] = 1] = "k_Necessary";
    ENodeCreateMode[ENodeCreateMode["k_Expose"] = 2] = "k_Expose";
    ENodeCreateMode[ENodeCreateMode["k_Skip"] = 3] = "k_Skip";
})(ENodeCreateMode || (ENodeCreateMode = {}));
var EParserCode;
(function (EParserCode) {
    // k_Pause,
    EParserCode[EParserCode["k_Ok"] = 0] = "k_Ok";
    EParserCode[EParserCode["k_Error"] = 1] = "k_Error";
})(EParserCode || (EParserCode = {}));
var EParserType;
(function (EParserType) {
    EParserType[EParserType["k_LR0"] = 0] = "k_LR0";
    EParserType[EParserType["k_LR1"] = 1] = "k_LR1";
    EParserType[EParserType["k_LALR"] = 2] = "k_LALR";
})(EParserType || (EParserType = {}));
var IASTDocumentFlags;
(function (IASTDocumentFlags) {
    IASTDocumentFlags[IASTDocumentFlags["k_Optimize"] = 8] = "k_Optimize";
    IASTDocumentFlags[IASTDocumentFlags["k_DeveloperMode"] = 16] = "k_DeveloperMode";
})(IASTDocumentFlags || (IASTDocumentFlags = {}));
var EParserFlags;
(function (EParserFlags) {
    EParserFlags[EParserFlags["k_ForceAppendAll"] = 1] = "k_ForceAppendAll";
    EParserFlags[EParserFlags["k_AllowExposeMode"] = 2] = "k_AllowExposeMode";
    EParserFlags[EParserFlags["k_AllowAddMode"] = 4] = "k_AllowAddMode";
    EParserFlags[EParserFlags["k_AllowSkipMode"] = 8] = "k_AllowSkipMode";
    EParserFlags[EParserFlags["k_Default"] = 14] = "k_Default";
    EParserFlags[EParserFlags["k_Debug"] = 16] = "k_Debug";
})(EParserFlags || (EParserFlags = {}));
var ETokenType;
(function (ETokenType) {
    ETokenType[ETokenType["k_NumericLiteral"] = 1] = "k_NumericLiteral";
    ETokenType[ETokenType["k_SinglelineCommentLiteral"] = 2] = "k_SinglelineCommentLiteral";
    ETokenType[ETokenType["k_MultilineCommentLiteral"] = 3] = "k_MultilineCommentLiteral";
    ETokenType[ETokenType["k_StringLiteral"] = 4] = "k_StringLiteral";
    ETokenType[ETokenType["k_PunctuatorLiteral"] = 5] = "k_PunctuatorLiteral";
    ETokenType[ETokenType["k_WhitespaceLiteral"] = 6] = "k_WhitespaceLiteral";
    ETokenType[ETokenType["k_NewlineLiteral"] = 7] = "k_NewlineLiteral";
    ETokenType[ETokenType["k_IdentifierLiteral"] = 8] = "k_IdentifierLiteral";
    ETokenType[ETokenType["k_KeywordLiteral"] = 9] = "k_KeywordLiteral";
    ETokenType[ETokenType["k_Unknown"] = 10] = "k_Unknown";
    ETokenType[ETokenType["k_End"] = 11] = "k_End";
})(ETokenType || (ETokenType = {}));
var EOperationType;
(function (EOperationType) {
    EOperationType[EOperationType["k_Error"] = 100] = "k_Error";
    EOperationType[EOperationType["k_Shift"] = 101] = "k_Shift";
    EOperationType[EOperationType["k_Reduce"] = 102] = "k_Reduce";
    EOperationType[EOperationType["k_Success"] = 103] = "k_Success";
    EOperationType[EOperationType["k_Ok"] = 104] = "k_Ok";
})(EOperationType || (EOperationType = {}));


/***/ }),

/***/ "M2fT":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts ***!
  \*******************************************************************/
/*! exports provided: ReturnStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReturnStmtInstruction", function() { return ReturnStmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");



/**
 * Represent return expr;
 * return ExprInstruction
 */
class ReturnStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__["StmtInstruction"] {
    constructor({ expr = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ReturnStmt, ...settings });
        this._operator = "return";
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(expr, this);
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        if (this.expr) {
            return "return " + this.expr.toCode() + ";";
        }
        else {
            return "return;";
        }
    }
}


/***/ }),

/***/ "MJEd":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: EVariableUsageFlags, VariableDeclInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVariableUsageFlags", function() { return EVariableUsageFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VariableDeclInstruction", function() { return VariableDeclInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "mXWi");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




/**
 * @deprecated
 */
var EVariableUsageFlags;
(function (EVariableUsageFlags) {
    EVariableUsageFlags[EVariableUsageFlags["k_Local"] = 1] = "k_Local";
    EVariableUsageFlags[EVariableUsageFlags["k_Global"] = 2] = "k_Global";
    EVariableUsageFlags[EVariableUsageFlags["k_Argument"] = 4] = "k_Argument";
})(EVariableUsageFlags || (EVariableUsageFlags = {}));
/**
 * Represent type var_name [= init_expr]
 * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
 */
class VariableDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__["DeclInstruction"] {
    constructor({ id, type, init = null, usageFlags = 0, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(id, this);
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withNoParent(type);
        this._initExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(init, this);
        this._usageFlags = usageFlags;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!this.isParameter() || (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.parent) || this.parent.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_FunctionDef));
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.isLocal() || !this.isLocal());
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!this.isParameter() || this.isLocal());
    }
    get initExpr() {
        return this._initExpr;
    }
    /** @deprecated */
    get defaultValue() {
        this._initExpr.evaluate();
        return this._initExpr.getEvalValue();
    }
    get type() {
        return this._type;
    }
    get name() {
        return this._id.name;
    }
    get id() {
        return this._id;
    }
    isGlobal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Global);
    }
    isLocal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Local);
    }
    isParameter() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);
    }
    isField() {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.parent)) {
            return false;
        }
        var eParentType = this.parent.instructionType;
        if (eParentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableType ||
            eParentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ComplexType ||
            eParentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_SystemType) {
            return true;
        }
        return false;
    }
    toCode() {
        var code = '';
        code = this.type.toCode();
        code += ' ' + this.id.toCode();
        if (this.type.isNotBaseArray()) {
            var iLength = this.type.length;
            code += '[' + iLength + ']';
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.initExpr) &&
            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?
            !this.type.isUniform()) {
            code += '=' + this.initExpr.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ "MT7/":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts ***!
  \******************************************************************/
/*! exports provided: WhileStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WhileStmtInstruction", function() { return WhileStmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");



/**
 * Represent while(expr) stmt
 * ( while || do_while) ExprInstruction StmtInstruction
 */
class WhileStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__["StmtInstruction"] {
    constructor({ cond, body, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_WhileStmt, ...settings });
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(cond, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(body, this);
        this._operator = operator;
    }
    get cond() {
        return this.cond;
    }
    get body() {
        return this._body;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        if (this.operator === "while") {
            code += "while(";
            code += this.cond.toCode();
            code += ")";
            code += this.body.toCode();
        }
        else {
            code += "do";
            code += this.body.toCode();
            code += "while(";
            code += this.cond.toCode();
            code += ");";
        }
        return code;
    }
}


/***/ }),

/***/ "Mg1O":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts ***!
  \********************************************************************/
/*! exports provided: ComplexExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComplexExprInstruction", function() { return ComplexExprInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "2b0+");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");



/**
 * Represent (expr)
 * EMPTY_OPERATOR ExprInstruction
 */
class ComplexExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ComplexExpr, type: expr.type, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return "(" + this.expr.toCode() + ")";
    }
    isConst() {
        return this.expr.isConst();
    }
    evaluate() {
        if (this.expr.evaluate()) {
            this._evalResult = this.expr.getEvalValue();
            return true;
        }
        else {
            return false;
        }
    }
}


/***/ }),

/***/ "Mu1Z":
/*!***************************************!*\
  !*** ./src/lib/util/DistinctColor.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class DistinctColor {
    constructor(idx = 0) {
        this._curIdx = idx;
    }
    value() {
        return this._curIdx;
    }
    pickNext() {
        this._curIdx = (this._curIdx + 1) % DistinctColor.list.length;
        return this.value();
    }
    toRGBAString() {
        return DistinctColor.toRGBAString(DistinctColor.resolveColor(this.value()));
    }
    static resolveColor(idx) {
        return DistinctColor.list[idx % DistinctColor.list.length];
    }
    static toRGBAString(val) {
        let r = ((val >> 16) & 0xff);
        let g = ((val >> 8) & 0xff);
        let b = ((val >> 0) & 0xff);
        return `rgb(${r}, ${g}, ${b})`;
    }
    static make(idx) {
        return new DistinctColor(idx);
    }
    static buildVariousClasses(prefix = 'dc') {
        return DistinctColor.list.reduce((styles, color) => (styles[`${prefix}_${color}`] = {
            opacity: 0.3,
            backgroundColor: `${DistinctColor.toRGBAString(color)}`
        }, styles), {});
        // [`dc_${0xe6194b}`]: { opacity: 0.3, backgroundColor: '#e6194b' },
        // [`dc_${0x3cb44b}`]: { opacity: 0.3, backgroundColor: '#3cb44b' },
        // ...
        // ...
        // [`dc_${0x000075}`]: { opacity: 0.3, backgroundColor: '#000075' },
        // [`dc_${0x808080}`]: { opacity: 0.3, backgroundColor: '#808080' }
    }
}
DistinctColor.list = [
    0xe6194b, 0x3cb44b, 0xffe119, 0x4363d8, 0xf58231, 0x911eb4,
    0x46f0f0, 0xf032e6, 0xbcf60c, 0xfabebe, 0x008080, 0xe6beff,
    0x9a6324, 0xfffac8, 0x800000, 0xaaffc3, 0x808000, 0xffd8b1,
    0x000075, 0x808080 //, 0xffffff, 0x000000
];
/* harmony default export */ __webpack_exports__["default"] = (DistinctColor);


/***/ }),

/***/ "N/7J":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SamplerStateInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: SamplerStateInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SamplerStateInstruction", function() { return SamplerStateInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


class SamplerStateInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ name, value, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SamplerState, ...settings });
        this._name = name;
        this._value = _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(value, this);
    }
    get name() {
        return this._name;
    }
    get value() {
        return this.value;
    }
    toString() {
        console.error("@not_implemented");
        return null;
    }
    toCode() {
        console.error("@not_implmented");
        return null;
    }
}


/***/ }),

/***/ "N9P3":
/*!***************************************!*\
  !*** ./src/lib/idl/bytecode/index.ts ***!
  \***************************************/
/*! exports provided: EOperation, EAddrType, EChunkType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAddrType", function() { return EAddrType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EChunkType", function() { return EChunkType; });
/* harmony import */ var _EOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EOperations */ "BW2l");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EOperation", function() { return _EOperations__WEBPACK_IMPORTED_MODULE_0__["EOperation"]; });


var EAddrType;
(function (EAddrType) {
    EAddrType[EAddrType["k_Registers"] = 0] = "k_Registers";
    EAddrType[EAddrType["k_Input"] = 1] = "k_Input";
    EAddrType[EAddrType["k_PointerRegisters"] = 2] = "k_PointerRegisters";
    EAddrType[EAddrType["k_PointerInput"] = 3] = "k_PointerInput";
})(EAddrType || (EAddrType = {}));
;
var EChunkType;
(function (EChunkType) {
    EChunkType[EChunkType["k_Constants"] = 0] = "k_Constants";
    EChunkType[EChunkType["k_Layout"] = 1] = "k_Layout";
    EChunkType[EChunkType["k_Code"] = 2] = "k_Code";
})(EChunkType || (EChunkType = {}));
;
// export interface IMemoryRecord {
//     range: number;
//     value: number | string;
//     type: 'f32' | 'i32' | 'uniform' | 'unknown';
// }


/***/ }),

/***/ "NoIe":
/*!***************************************!*\
  !*** ./src/lib/fx/autotests/index.ts ***!
  \***************************************/
/*! exports provided: parse, run */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "2oKZ");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "0DIJ");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/Lexer */ "TYG3");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/symbols */ "YPfw");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/parser/util */ "wYUO");







function nativeFromString(str) {
    switch (str.toLowerCase()) {
        case 'true': return true;
        case 'false': return false;
        default:
            return Number(str) || 0;
    }
}
function exractComments(document) {
    const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__["Lexer"]({ skipComments: false });
    lexer.setup(document);
    let comments = [];
    let token;
    while ((token = lexer.getNextToken()).value !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_5__["END_SYMBOL"]) {
        if (token.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__["ETokenType"].k_MultilineCommentLiteral) {
            comments.push(token);
        }
    }
    return comments;
}
/**
 *
 * @param source SL text document with test markup inside.
 */
async function parse(textDocument) {
    let description = null;
    let tests = [];
    // NOTE: temp solution (until the parser gets comment support)
    exractComments(textDocument).forEach((commentToken) => {
        let comment = commentToken.value.slice(2, -2);
        let list = comment
            .split('\n')
            .map(str => str.replace(/^\s*\*{1,2}\s*|\s*$/g, ''));
        let accum = [];
        let lastRule = null;
        let content;
        let rules = [];
        let line = -1;
        while (list.length) {
            line++;
            [content, list] = [list[0], list.slice(1)];
            if (content.match(/^\s*$/g)) {
                continue;
            }
            if (!content.match(/^@[\w]+/g)) {
                accum.push(content);
                continue;
            }
            if (lastRule) {
                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
            }
            lastRule = { content, line };
        }
        ;
        if (lastRule && lastRule.content) {
            rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
        }
        let test = null;
        error: for (let rule of rules) {
            const { line, content } = rule;
            const parts = content.split(' ');
            const ruleName = parts[0].trim().toLowerCase();
            const loc = Object(_lib_parser_util__WEBPACK_IMPORTED_MODULE_6__["cloneRange"])(commentToken.loc);
            // FIXME: dirty hack in order to make the range correct
            loc.start.line += line;
            // loc.start.offset = -1;
            loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '
            loc.end.line = loc.start.line;
            // loc.end.offset = loc.start.offset;
            loc.end.column = loc.start.column + parts.join(' ').length;
            switch (ruleName) {
                case '@autotests':
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(description));
                    description = parts.slice(1).join(' ');
                    break;
                case '@test':
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(test));
                    if (test) {
                        break error;
                    }
                    test = {
                        name: parts.slice(1).join(' '),
                        cases: [],
                        loc
                    };
                    break;
                case '@expected':
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(test));
                    if (!test) {
                        break error;
                    }
                    let [expr, expectedString] = parts.slice(1).join(' ').trim().slice(1, -1).split('==').map(str => str.trim());
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(expr && expectedString);
                    let expected = nativeFromString(expectedString);
                    test.cases.push({ expr, expected, loc });
                    break;
            }
        }
        ;
        if (test) {
            tests.push(test);
        }
    });
    const document = await Object(_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_2__["createFXSLDocument"])(textDocument);
    return { description, document, tests };
}
async function runTest(test, document) {
    const { cases } = test;
    for (let exam of cases) {
        const { expr, expected } = exam;
        const result = await _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__["evaluate"](expr, document);
        exam.passed = result === expected;
        if (!exam.passed) {
            exam.note = `Test failed. Expected is '${expected}', but given is '${result}'`;
        }
    }
    test.passed = cases.reduce((acc, exam) => (acc && exam.passed), true);
}
async function run(autotests) {
    autotests.passed = true;
    for (const test of autotests.tests) {
        await runTest(test, autotests.document);
        autotests.passed = autotests.passed && test.passed;
    }
}


/***/ }),

/***/ "NtUi":
/*!********************************************!*\
  !*** ./src/sandbox/reducers/sourceFile.ts ***!
  \********************************************/
/*! exports provided: default, getFileState, getDebugger, getScope, getEmitterName, filterPartFx */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFileState", function() { return getFileState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugger", function() { return getDebugger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScope", function() { return getScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEmitterName", function() { return getEmitterName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterPartFx", function() { return filterPartFx; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "pvc7");
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "WdmE");




const initialState = {
    uri: null,
    content: null,
    contentModified: null,
    error: null,
    markers: {},
    breakpoints: [],
    slastDocument: null,
    slDocument: null,
    debugger: {
        expression: null,
        runtime: null,
        options: {
            colorize: true,
            disableOptimizations: true,
            autocompile: false
        }
    },
    emitter: null,
    // HACK: additional counter in order to call component's update in case of shadow pipeline reloading
    $pipeline: 0
};
/* harmony default export */ __webpack_exports__["default"] = (Object(_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_3__["handleActions"])({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_FILE_REQUEST"]]: (state, action) => ({ ...state, uri: action.payload.filename }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_FILE_LOADED"]]: (state, action) => ({ ...state, content: action.payload.content }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_FILE_LOADING_FAILED"]]: (state, action) => ({
        ...state,
        error: action.payload.error,
        // NOTE: temp solution (clean up all info about prev file)
        content: null,
        debugger: { ...state.debugger, runtime: null },
        breakpoints: [],
        slASTDocument: null,
        slDocument: null,
        emitter: null,
        $pipeline: 0
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_FILE_DROP_STATE"]]: (state, action) => ({
        ...state,
        error: null,
        content: null,
        debugger: { ...state.debugger, runtime: null },
        breakpoints: [],
        slASTDocument: null,
        slDocument: null,
        emitter: null,
        $pipeline: 0
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_MODIFED"]]: (state, action) => ({
        ...state, markers: {}, content: action.payload.content, uri: action.payload.filename || state.uri
        // , debugger: { entryPoint: null, runtime: null, ...state.debugger } =
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_PARSING_COMPLETE"]]: (state, action) => ({ ...state, slastDocument: action.payload.slastDocument }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_ANALYSIS_COMPLETE"]]: (state, action) => ({ ...state, slDocument: action.payload.result }),
    //
    // markers
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_ADD_MARKER"]]: (state, action) => ({ ...state, markers: { ...state.markers, [action.payload.name]: action.payload } }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_REMOVE_MARKER"]]: (state, action) => {
        const markers = { ...state.markers };
        delete markers[action.payload.name];
        return { ...state, markers };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_ADD_MARKER_BATCH"]]: (state, action) => {
        const markers = { ...state.markers };
        action.payload.batch.forEach(desc => markers[desc.name] = desc);
        return { ...state, markers };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_REMOVE_MARKER_BATCH"]]: (state, action) => {
        const markers = { ...state.markers };
        action.payload.batch.forEach(name => {
            delete markers[name];
        });
        return { ...state, markers };
    },
    //
    // breakpoints
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_ADD_BREAKPOINT"]]: (state, action) => {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(state.breakpoints.indexOf(action.payload.line) === -1);
        return ({ ...state, breakpoints: [...state.breakpoints, action.payload.line] });
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["SOURCE_CODE_REMOVE_BREAKPOINT"]]: (state, action) => {
        return { ...state, breakpoints: state.breakpoints.filter(ln => ln !== action.payload.line) };
    },
    //
    // debugger
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["DEBUGGER_START_DEBUG"]]: (state, action) => {
        const options = state.debugger.options;
        const { expression, runtime } = action.payload;
        return { ...state, debugger: { expression, runtime, options } };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["DEBUGGER_RESET"]]: (state) => {
        const { debugger: { options } } = state;
        return { ...state, debugger: { expression: null, runtime: null, options, layout: 'i32' } };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["DEBUGGER_OPTIONS_CHANGED"]]: (state, action) => {
        const options = { ...state.debugger.options, ...action.payload.options };
        const $debugger = { ...state.debugger, options };
        // console.log(JSON.stringify(options, null, '\t'));
        return { ...state, debugger: $debugger };
    },
    //
    // playground
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__["PLAYGROUND_EMITER_UPDATE"]]: (state, action) => ({ ...state, emitter: action.payload.emitter, $pipeline: state.$pipeline + 1 })
}, initialState));
//- Selectors
// export const getFileStateNoMarkers = (state: IStoreState): IFileState => ({ ...state.sourceFile, markers: null });
const getFileState = (state) => state.sourceFile;
const getDebugger = (state) => getFileState(state).debugger;
const getScope = (file) => file.slDocument ? file.slDocument.root.scope : null;
const getEmitterName = (file) => file.emitter ? file.emitter.name : null;
function filterPartFx(scope) {
    if (!scope) {
        return [];
    }
    const map = scope.techniques;
    return Object.keys(map)
        .filter(name => map[name].type === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["ETechniqueType"].k_PartFx)
        .map(name => map[name]);
}


/***/ }),

/***/ "NzFo":
/*!*****************************************!*\
  !*** ./src/lib/fx/analisys/Analyzer.ts ***!
  \*****************************************/
/*! exports provided: Context, Analyzer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Context", function() { return Context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Analyzer", function() { return Analyzer; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "6dfp");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "2blz");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../AnalyzerDiagnostics */ "RTx6");
/* harmony import */ var _Visitors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Visitors */ "DTTp");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers */ "u2cq");
/* harmony import */ var _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instructions/ArithmeticExprInstruction */ "l4+G");
/* harmony import */ var _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./instructions/AssignmentExprInstruction */ "XQla");
/* harmony import */ var _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instructions/AttributeInstruction */ "pq1u");
/* harmony import */ var _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./instructions/BoolInstruction */ "5EX4");
/* harmony import */ var _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./instructions/BreakStmtInstruction */ "7VRG");
/* harmony import */ var _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./instructions/CastExprInstruction */ "2xh7");
/* harmony import */ var _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./instructions/CompileExprInstruction */ "fjuh");
/* harmony import */ var _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./instructions/ComplexExprInstruction */ "Mg1O");
/* harmony import */ var _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./instructions/ComplexTypeInstruction */ "i81d");
/* harmony import */ var _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./instructions/ConditionalExprInstruction */ "bxdW");
/* harmony import */ var _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./instructions/ConstructorCallInstruction */ "GH4Y");
/* harmony import */ var _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./instructions/DeclStmtInstruction */ "Zd6l");
/* harmony import */ var _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./instructions/ExprStmtInstruction */ "huhI");
/* harmony import */ var _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./instructions/FloatInstruction */ "49qt");
/* harmony import */ var _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./instructions/ForStmtInstruction */ "Wv+o");
/* harmony import */ var _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./instructions/FunctionCallInstruction */ "4cxW");
/* harmony import */ var _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./instructions/FunctionDeclInstruction */ "BKBR");
/* harmony import */ var _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./instructions/FunctionDefInstruction */ "hsO8");
/* harmony import */ var _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./instructions/IdExprInstruction */ "5fm/");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./instructions/IdInstruction */ "C2sc");
/* harmony import */ var _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./instructions/IfStmtInstruction */ "1O8D");
/* harmony import */ var _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./instructions/InitExprInstruction */ "ggRF");
/* harmony import */ var _instructions_Instruction__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./instructions/Instruction */ "2b0+");
/* harmony import */ var _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./instructions/InstructionCollector */ "iYqf");
/* harmony import */ var _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./instructions/IntInstruction */ "QsPN");
/* harmony import */ var _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./instructions/LogicalExprInstruction */ "wEKK");
/* harmony import */ var _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./instructions/PassInstruction */ "jfm7");
/* harmony import */ var _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./instructions/PostfixArithmeticInstruction */ "C3oy");
/* harmony import */ var _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./instructions/PostfixIndexInstruction */ "fuca");
/* harmony import */ var _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./instructions/PostfixPointInstruction */ "sQ1Q");
/* harmony import */ var _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./instructions/ProvideInstruction */ "9EOq");
/* harmony import */ var _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./instructions/ProxyTypeInstruction */ "9hKy");
/* harmony import */ var _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./instructions/RelationalExprInstruction */ "wsMd");
/* harmony import */ var _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./instructions/ReturnStmtInstruction */ "M2fT");
/* harmony import */ var _instructions_SamplerStateBlockInstruction__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./instructions/SamplerStateBlockInstruction */ "PLhK");
/* harmony import */ var _instructions_SamplerStateInstruction__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./instructions/SamplerStateInstruction */ "N/7J");
/* harmony import */ var _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./instructions/SemicolonStmtInstruction */ "ip/g");
/* harmony import */ var _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./instructions/StmtBlockInstruction */ "kGK+");
/* harmony import */ var _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./instructions/StringInstruction */ "9vj8");
/* harmony import */ var _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./instructions/TechniqueInstruction */ "+Z36");
/* harmony import */ var _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./instructions/TypeDeclInstruction */ "onqc");
/* harmony import */ var _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./instructions/UnaryExprInstruction */ "I537");
/* harmony import */ var _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./instructions/VariableDeclInstruction */ "MJEd");
/* harmony import */ var _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./instructions/VariableTypeInstruction */ "hljw");
/* harmony import */ var _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./instructions/WhileStmtInstruction */ "MT7/");
/* harmony import */ var _ProgramScope__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./ProgramScope */ "IHXS");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./SystemScope */ "Wl5j");

























































function validate(instr, expectedType) {
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(instr.instructionType === expectedType);
}
// TODO: refactor it
function findConstructor(type, args) {
    return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ type, scope: null });
}
function _errorFromInstruction(context, sourceNode, pError) {
    context.error(sourceNode, pError.code, Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(pError.info) ? {} : pError.info);
}
function checkInstruction(context, inst, stage) {
    // TODO: rework this api
    if (!inst._check(stage)) {
        _errorFromInstruction(context, inst.sourceNode, inst._getLastError());
        return null;
    }
    return inst;
}
const asType = (instr) => instr ? instr.type : null;
// FIXME: refuse from the regular expressions in favor of a full typecasting graph
const asRelaxedType = (instr) => {
    if (!instr) {
        return null;
    }
    // if (instruction.isLiteral(instr)) {
    if (instr.type.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"]) || instr.type.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"])) {
        // temp workaround in order to match int to uint and etc. 
        return /^int$|^uint$/g;
    }
    // }
    return instr.type;
};
// TODO: rework 'auto' api
function tryResolveProxyType(type, host) {
    if (type.subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_ProxyType) {
        const proxy = type.subType;
        if (!proxy.isResolved()) {
            proxy.resolve(host);
        }
    }
}
function getRenderStateValue(state, value) {
    let eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].UNDEF;
    switch (state) {
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].ALPHABLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].ALPHATESTENABLE:
            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');
            return _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].UNDEF;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].CULLFACEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].ZENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].ZWRITEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DITHERENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SCISSORTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].STENCILTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].POLYGONOFFSETFILLENABLE:
            switch (value) {
                case 'TRUE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].TRUE;
                    break;
                case 'FALSE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FALSE;
                    break;
                default:
                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '
                        + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].CULLFACE:
            switch (value) {
                case 'FRONT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FRONT;
                    break;
                case 'BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].BACK;
                    break;
                case 'FRONT_AND_BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FRONT_AND_BACK;
                    break;
                default:
                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].FRONTFACE:
            switch (value) {
                case 'CW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].CW;
                    break;
                case 'CCW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].CCW;
                    break;
                default:
                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDFUNC:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDFUNCSEPARATE:
            switch (value) {
                case 'ZERO':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].ZERO;
                    break;
                case 'ONE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].ONE;
                    break;
                case 'SRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].SRCCOLOR;
                    break;
                case 'INVSRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].INVSRCCOLOR;
                    break;
                case 'SRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].SRCALPHA;
                    break;
                case 'INVSRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].INVSRCALPHA;
                    break;
                case 'DESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].DESTALPHA;
                    break;
                case 'INVDESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].INVDESTALPHA;
                    break;
                case 'DESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].DESTCOLOR;
                    break;
                case 'INVDESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].INVDESTCOLOR;
                    break;
                case 'SRCALPHASAT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].SRCALPHASAT;
                    break;
                default:
                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATION:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONSEPARATE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONALPHA:
            switch (value) {
                case 'FUNCADD':
                case 'ADD':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FUNCADD;
                    break;
                case 'FUNCSUBTRACT':
                case 'SUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FUNCSUBTRACT;
                    break;
                case 'FUNCREVERSESUBTRACT':
                case 'REVERSESUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].FUNCREVERSESUBTRACT;
                    break;
                default:
                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].ZFUNC:
            switch (value) {
                case 'NEVER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].NEVER;
                    break;
                case 'LESS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].LESS;
                    break;
                case 'EQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].EQUAL;
                    break;
                case 'LESSEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].LESSEQUAL;
                    break;
                case 'GREATER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].GREATER;
                    break;
                case 'NOTEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].NOTEQUAL;
                    break;
                case 'GREATEREQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].GREATEREQUAL;
                    break;
                case 'ALWAYS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].ALWAYS;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].PRIMITIVETOPOLOGY:
            switch (value) {
                case 'TRIANGLELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].TRIANGLELIST;
                    break;
                case 'LINELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].LINELIST;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
    }
    return eValue;
}
function addTypeDecl(context, scope, typeDecl) {
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["findType"](typeDecl.name)) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].SystemTypeRedefinition, { typeName: typeDecl.name });
    }
    let isAdded = scope.addType(typeDecl.type);
    if (!isAdded) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].TypeRedefinition, { typeName: typeDecl.name });
    }
}
function checkFunctionForRecursion(context, func, stack) {
    if (stack.indexOf(func.instructionID) !== -1) {
        context.error(func.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFunctionRecursionNotAllowed, { funcName: func.name });
        return false;
    }
    let recursionFound = false;
    stack = [...stack, func.instructionID];
    const recursionChecker = (instr) => {
        if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_FunctionCallExpr) {
            let fcall = instr;
            let fdecl = fcall.decl;
            if (fdecl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_SystemFunctionDecl) {
                return;
            }
            // NOTE: it is possible that the declaration was not complete 
            //       at the time of the call, so you need to look for a 
            //       version with implementation
            fdecl = fdecl.scope.findFunctionInScope(fdecl);
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(fdecl.impl)) {
                context.error(instr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFunctionImplementationNotFound, { funcName: fdecl.name });
                return;
            }
            // visitor(fdecl.impl, recursionChecker);
            recursionFound = recursionFound ||
                checkFunctionForRecursion(context, fdecl, stack);
        }
    };
    Object(_Visitors__WEBPACK_IMPORTED_MODULE_7__["visitor"])(func.impl, recursionChecker);
    return !recursionFound;
}
function checkFunctionsForRecursion(context, program) {
    const gs = program.globalScope;
    let recusrionFound = false;
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["mwalk"])(gs.functions, funcOverloads => {
        funcOverloads.forEach(func => {
            recusrionFound = recusrionFound ||
                !checkFunctionForRecursion(context, func, []);
        });
    });
    return !recusrionFound;
}
function checkForVertexUsage(funcDef) {
    if (!checkReturnTypeForVertexUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForVertexUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkForPixelUsage(funcDef) {
    if (!checkReturnTypeForPixelUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForPixelUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkReturnTypeForVertexUsage(funcDef) {
    const returnType = funcDef.returnType;
    if (returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"])) {
        return true;
    }
    if (returnType.isComplex()) {
        if (returnType.hasFieldWithoutSemantics()) {
            return false;
        }
        if (!returnType.hasAllUniqueSemantics()) {
            return false;
        }
        // isGood = returnType._hasFieldWithSematic("POSITION");
        // if(!isGood){
        // 	return false;
        // }
        // samplers cant be interpolators
        if (returnType.isContainSampler()) {
            return false;
        }
        // Forbid fileds with user-defined types
        // or any other complex types.
        if (returnType.isContainComplexType()) {
            return false;
        }
    }
    else {
        if (!returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_FLOAT4"])) {
            return false;
        }
        if (funcDef.semantic !== "POSITION") {
            return false;
        }
    }
    return true;
}
// todo: add support for dual source blending
// todo: add support for MRT
function checkReturnTypeForPixelUsage(funcDef) {
    let returnType = funcDef.returnType;
    if (returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"])) {
        return true;
    }
    // TODO: add MRT support
    if (!returnType.isBase()) {
        return false;
    }
    if (!returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_FLOAT4"])) {
        return false;
    }
    if (funcDef.semantic !== "COLOR") {
        return false;
    }
    return true;
}
function checkArgumentsForVertexUsage(funcDef) {
    let params = funcDef.params;
    let isAttributeByStruct = false;
    let isAttributeByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(param.semantic)) {
                if (param.type.isBase() ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics()) {
                    return false;
                }
                isAttributeByStruct = true;
            }
            else if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(param.semantic)) {
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isAttributeByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isAttributeByStruct) {
            return false;
        }
        else if (isAttributeByParams) {
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(param.semantic)) {
                return false;
            }
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
function checkArgumentsForPixelUsage(funcDef) {
    let params = funcDef.params;
    let isVaryingsByStruct = false;
    let isVaryingsByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if (param.semantic === "") {
                if (param.type.isBase() ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics() ||
                    param.type.isContainSampler()) {
                    return false;
                }
                isVaryingsByStruct = true;
            }
            else if (param.semantic !== "") {
                if (param.type.isContainSampler() ||
                    _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isSamplerType"](param.type)) {
                    return false;
                }
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isVaryingsByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isVaryingsByStruct) {
            return false;
        }
        else if (isVaryingsByParams) {
            if (param.semantic === "") {
                return false;
            }
            if (param.type.isContainSampler() ||
                _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isSamplerType"](param.type)) {
                return false;
            }
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
class Context {
    constructor(uri) {
        this.diagnostics = new _AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_6__["AnalyzerDiagnostics"];
        this.uri = uri;
        this.moduleName = null;
        this.haveCurrentFunctionReturnOccur = false;
    }
    beginFunc() {
        this.func = true;
        this.haveCurrentFunctionReturnOccur = false;
        this.funcDef = null; // << will be set inside analyzeFunctionDecl();
    }
    endFunc() {
        this.func = false;
    }
    beginPass() {
        this.renderStates = null;
    }
    endPass() {
        this.renderStates = null;
    }
    error(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.error(code, { file, loc, info });
    }
    critical(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.critical(code, { file, loc, info });
    }
    warn(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.warning(code, { file, loc, info });
    }
    resolveNodeSourceLocation(sourceNode) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(sourceNode)) {
            return null;
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(sourceNode.loc)) {
            return sourceNode.loc;
        }
        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);
    }
}
class Analyzer {
    analyzeUseDecl(context, program, sourceNode) {
        program.currentScope.strictMode = true;
    }
    analyzeComplexName(sourceNode) {
        const children = sourceNode.children;
        let name = '';
        for (let i = children.length - 1; i >= 0; i--) {
            name += children[i].value;
        }
        return name;
    }
    /**
     * AST example:
     *    ProvideDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_PROVIDE = 'provide'
     */
    analyzeProvideDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (children.length === 3) {
            let moduleName = this.analyzeComplexName(children[1]);
            ;
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(context.moduleName)) {
                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);
            }
            context.moduleName = moduleName;
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(children[2].name === 'T_KW_PROVIDE');
            return new _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_39__["ProvideInstruction"]({ sourceNode, moduleName, scope });
        }
        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnsupportedProvideAs);
        return null;
    }
    /**
     * AST example:
     *    InitExpr
     *         T_UINT = '0'
     */
    analyzeInitExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let args = [];
        if (children.length === 1) {
            args.push(this.analyzeExpr(context, program, children[0]));
        }
        else {
            for (let i = 0; i < children.length; i++) {
                if (children[i].name === 'InitExpr') {
                    args.push(this.analyzeInitExpr(context, program, children[i]));
                }
            }
        }
        // TODO: determ type!!
        const initExpr = new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_30__["InitExprInstruction"]({ scope, sourceNode, args, type: null });
        return initExpr;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeVariableDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);
        const vars = [];
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(generalType)) {
            return null;
        }
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars.push(this.analyzeVariable(context, program, children[i], generalType));
            }
        }
        return vars;
    }
    /**
     * AST example:
     *    UsageType
     *       + Type
     *       + Usage
     */
    analyzeUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        let usagesRaw = [];
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                type = this.analyzeType(context, program, children[i]);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'Usage') {
                usagesRaw.push(this.analyzeUsage(children[i]));
            }
        }
        const usageIn = usagesRaw.indexOf('in') !== -1;
        const usageOut = usagesRaw.indexOf('out') !== -1;
        const usageInout = usagesRaw.indexOf('inout') !== -1;
        const usageConst = usagesRaw.indexOf('const') !== -1;
        const usageUniform = usagesRaw.indexOf('uniform') !== -1;
        // TODO: emit errors in case of inconsistent usages
        // TODO: remplace with bitflags
        let usages = [];
        if (usageInout) {
            usages.push('inout');
            // emit error in case of uniform
            // emit error in case of const
        }
        else {
            if (usageIn && usageOut) {
                usages.push('inout');
                // emit error in case of uniform
                // emit error in case of const
            }
            else {
                if (usageIn) {
                    usages.push('in');
                }
                if (usageOut) {
                    usages.push('out');
                    // emit error in case of const
                    // emit error in case of uniform
                }
                else {
                    if (usageConst)
                        usages.push('const');
                    if (usageUniform)
                        usages.push('uniform');
                }
            }
        }
        let varType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ scope, sourceNode, type, usages });
        return checkInstruction(context, varType, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    Type
     *         T_TYPE_ID = 'float3'
     */
    analyzeType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        switch (sourceNode.name) {
            case 'T_TYPE_ID':
                if (sourceNode.value === 'auto') {
                    type = new _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_40__["ProxyTypeInstruction"]({ scope });
                    break;
                }
                type = scope.findType(sourceNode.value);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeNameNotType, { typeName: sourceNode.value });
                }
                break;
            case 'Struct':
                type = this.analyzeStruct(context, program, sourceNode);
                break;
            case 'T_KW_VOID':
                type = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"];
                break;
            case 'ScalarType':
            case 'ObjectType':
                {
                    let typeName = children[children.length - 1].value;
                    if (children.length !== 1) {
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(children[children.length - 2].value === '<' && children[0].value === '>');
                        const tplName = typeName;
                        const args = children
                            .slice(1, -2)
                            .reverse()
                            .filter((v, i) => i % 2 == 0)
                            .map(sourceNode => this.analyzeType(context, program, sourceNode));
                        const template = scope.findTypeTemplate(typeName);
                        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(template)) {
                            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeNameTemplateNotFound, { tplName, args: args.map(arg => arg.toCode()) });
                            return null;
                        }
                        // TODO: validate register
                        // TODO: use ESystemTypes enumeration
                        const SYSTEM_TYPES = ['RWBuffer', 'RWStructuredBuffer', 'AppendStructuredBuffer'];
                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {
                            if (scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Global) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeScope, { typeName: template.name, tooltip: 'only global scope allowed' });
                                return null;
                            }
                        }
                        typeName = template.typeName(args);
                        type = scope.findType(typeName);
                        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                            type = template.produceType(scope, args);
                            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].CannotProduceType, { typeName });
                                return null;
                            }
                            scope.addType(type);
                        }
                    }
                    else {
                        type = scope.findType(typeName);
                    }
                    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeNameNotType, { typeName });
                        return null;
                    }
                }
                break;
            case 'VectorType':
            case 'MatrixType':
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeVectorMatrix);
                break;
            case 'BaseType':
            case 'Type':
                return this.analyzeType(context, program, children[0]);
        }
        return type;
    }
    analyzeUsage(sourceNode) {
        sourceNode = sourceNode.children[0];
        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout'];
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(supportedUsages.indexOf(sourceNode.value) !== -1);
        return sourceNode.value;
    }
    /**
     * AST example:
     *    Variable
     *       + Initializer
     *       + Semantic
     *       + VariableDim
     *              T_PUNCTUATOR_93 = ']'
     *              T_NON_TYPE_ID = 'N'
     *              T_PUNCTUATOR_91 = '['
     *            + VariableDim
     *                   T_NON_TYPE_ID = 'x'
     *                   ^^^^^^^^^^^^^^^^^^
     */
    analyzeVariable(context, program, sourceNode, generalType) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let annotation = null;
        let init = null;
        let semantic = '';
        let usageFlags = 0;
        if (!context.func) {
            usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__["EVariableUsageFlags"].k_Global;
        }
        else {
            // All variables found inside function definition are arguments.
            if (!context.funcDef) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__["EVariableUsageFlags"].k_Argument;
            }
            usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__["EVariableUsageFlags"].k_Local;
        }
        let id = null;
        let arrayIndex = null;
        let type = null;
        let vdimNode = children[children.length - 1];
        do {
            let vdimChildren = vdimNode.children;
            if (vdimChildren.length === 1) {
                const name = vdimChildren[0].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, sourceNode, name });
                break;
            }
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(vdimChildren.length == 4);
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(arrayIndex)) {
                // usage of generalType.source node instead of sourceNode was done for more clear debugging
                generalType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
            }
            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);
            vdimNode = vdimChildren[vdimChildren.length - 1];
        } while (true);
        // using generalType.source node instead of sourceNode was done for more clear degging
        type = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
        for (let i = children.length - 2; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else if (children[i].name === 'Initializer') {
                let args = this.analyzeInitializerArguments(context, program, children[i]);
                init = new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_30__["InitExprInstruction"]({ scope, sourceNode: children[i], args, type });
                let isValidInit = false;
                try {
                    isValidInit = init.optimizeForVariableType(type);
                }
                catch (e) { }
                ;
                if (!isValidInit) {
                    // TODO: make it warning
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidVariableInitializing, { varName: id.name });
                    init = null;
                }
            }
        }
        const varDecl = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__["VariableDeclInstruction"]({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_System);
        if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["hasVariable"](varDecl.name)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].SystemVariableRedefinition, { varName: varDecl.name });
        }
        const isAdded = scope.addVariable(varDecl);
        if (!isAdded) {
            switch (scope.type) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Global:
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Default:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].VariableRedefinition, { varName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Struct:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidNewFieldForStructName, { fieldName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Annotation:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidNewAnnotationVar, { varName: varDecl.name });
                    break;
            }
        }
        return checkInstruction(context, varDecl, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    Annotation
     *         T_PUNCTUATOR_62 = '>'
     *         T_PUNCTUATOR_60 = '<'
     */
    analyzeAnnotation(sourceNode) {
        // todo
        return null;
    }
    /**
     * AST example:
     *    Semantic
     *         T_NON_TYPE_ID = 'SEMANTIC'
     *         T_PUNCTUATOR_58 = ':'
     */
    /**
     * AST example:
     *    Semantic
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'u2'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_REGISTER = 'register'
     *         T_PUNCTUATOR_58 = ':'
     */
    analyzeSemantic(sourceNode) {
        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');
    }
    /**
     * AST example:
     *    Initializer
     *         T_UINT = '10'
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *       + CastExpr
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_44 = ','
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     *         T_PUNCTUATOR_61 = '='
     */
    analyzeInitializerArguments(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let args = [];
        if (children.length === 2) {
            args.push(this.analyzeExpr(context, program, children[0]));
        }
        else {
            for (let i = children.length - 3; i >= 1; i--) {
                if (children[i].name === 'InitExpr') {
                    args.push(this.analyzeInitExpr(context, program, children[i]));
                }
            }
        }
        return args;
    }
    analyzeExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        switch (name) {
            case 'ObjectExpr':
                return this.analyzeObjectExpr(context, program, sourceNode);
            case 'ComplexExpr':
                return this.analyzeComplexExpr(context, program, sourceNode);
            case 'PostfixExpr':
                return this.analyzePostfixExpr(context, program, sourceNode);
            case 'UnaryExpr':
                return this.analyzeUnaryExpr(context, program, sourceNode);
            case 'CastExpr':
                return this.analyzeCastExpr(context, program, sourceNode);
            case 'ConditionalExpr':
                return this.analyzeConditionalExpr(context, program, sourceNode);
            case 'MulExpr':
            case 'AddExpr':
                return this.analyzeArithmeticExpr(context, program, sourceNode);
            case 'RelationalExpr':
            case 'EqualityExpr':
                return this.analyzeRelationExpr(context, program, sourceNode);
            case 'AndExpr':
            case 'OrExpr':
                return this.analyzeLogicalExpr(context, program, sourceNode);
            case 'AssignmentExpr':
                return this.analyzeAssignmentExpr(context, program, sourceNode);
            case 'T_NON_TYPE_ID':
                return this.analyzeIdExpr(context, program, sourceNode);
            case 'T_STRING':
            case 'T_UINT':
            case 'T_FLOAT':
            case 'T_KW_TRUE':
            case 'T_KW_FALSE':
                return this.analyzeSimpleExpr(context, program, sourceNode);
            default:
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnsupportedExpr, { exprName: name });
                break;
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *       + StateBlock
     *         T_KW_SAMPLER_STATE = 'sampler_state'
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'fs_skybox'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeObjectExpr(context, program, sourceNode) {
        let name = sourceNode.children[sourceNode.children.length - 1].name;
        switch (name) {
            case 'T_KW_COMPILE':
                return this.analyzeCompileExpr(context, program, sourceNode);
            case 'T_KW_SAMPLER_STATE':
                return this.analyzeSamplerStateBlock(context, program, sourceNode);
            default:
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'main'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeCompileExpr(context, program, sourceNode, validators) {
        const children = sourceNode.children;
        const shaderFuncName = children[children.length - 2].value;
        const scope = program.currentScope;
        let compileArgs = null;
        let retType = null;
        let args = null;
        if (children.length > 4) {
            compileArgs = [];
            for (let i = children.length - 4; i > 0; i--) {
                if (children[i].value !== ',') {
                    compileArgs.push(this.analyzeExpr(context, program, children[i]));
                }
            }
        }
        args = compileArgs ? compileArgs.map(asType) : null;
        let func = null;
        if (validators) {
            for (let validator of validators) {
                args = compileArgs ? compileArgs.map(asType) : null;
                retType = null;
                args = validator.args || args;
                retType = validator.ret || retType;
                func = program.globalScope.findFunction(shaderFuncName, args);
                if (func) {
                    break;
                }
            }
        }
        else {
            func = program.globalScope.findFunction(shaderFuncName, args);
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileNotFunction, { funcName: shaderFuncName });
            return null;
        }
        if (retType) {
            if (!func.def.returnType.isEqual(retType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCompileFunctionNotValid, {
                    funcName: shaderFuncName,
                    funcType: retType.toCode(),
                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `
                });
                return null;
            }
        }
        let type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"].wrap(func.def.returnType, scope);
        let expr = new _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_15__["CompileExprInstruction"]({ args: compileArgs, scope, type, operand: func, sourceNode });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    ObjectExpr
     *       + StateBlock
     *         T_KW_SAMPLER_STATE = 'sampler_state'
     */
    analyzeSamplerStateBlock(context, program, sourceNode) {
        sourceNode = sourceNode.children[0];
        let scope = program.currentScope;
        let children = sourceNode.children;
        let operator = "sampler_state";
        let texture = null;
        let params = [];
        for (let i = children.length - 2; i >= 1; i--) {
            let param = this.analyzeSamplerState(context, program, children[i]);
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(param)) {
                params.push(param);
            }
        }
        let expr = new _instructions_SamplerStateBlockInstruction__WEBPACK_IMPORTED_MODULE_43__["SamplerStateBlockInstruction"]({ sourceNode, scope, operator, params });
        checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return expr;
    }
    /**
     * AST example:
     *    State
     *         T_PUNCTUATOR_59 = ';'
     *         StateExpr
     *              T_PUNCTUATOR_62 = '>'
     *              T_NON_TYPE_ID = 'tex0'
     *              T_PUNCTUATOR_60 = '<'
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'Texture'
     */
    analyzeSamplerState(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (children[children.length - 2].name === 'StateIndex') {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnsupportedStateIndex);
            return null;
        }
        let stateExprNode = children[children.length - 3];
        let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];
        let stateType = children[children.length - 1].value.toUpperCase();
        let stateValue = '';
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(subStateExprNode.value)) {
            context.error(subStateExprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidSamplerTexture);
            return null;
        }
        switch (stateType) {
            case 'TEXTURE':
                if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {
                    context.error(subStateExprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidSamplerTexture);
                    return null;
                }
                let texNameNode = stateExprNode.children[1];
                let texName = texNameNode.value;
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(texName) || !scope.findVariable(texName)) {
                    context.error(stateExprNode.children[1], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidSamplerTexture);
                    return null;
                }
                let texDecl = scope.findVariable(texName);
                let texId = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, sourceNode: texNameNode, name: texName });
                let tex = new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_27__["IdExprInstruction"]({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });
                return new _instructions_SamplerStateInstruction__WEBPACK_IMPORTED_MODULE_44__["SamplerStateInstruction"]({ scope, sourceNode, name: stateType, value: tex });
            case 'ADDRESSU': /* WRAP_S */
            case 'ADDRESSV': /* WRAP_T */
                stateValue = subStateExprNode.value.toUpperCase();
                switch (stateValue) {
                    case 'WRAP':
                    case 'CLAMP':
                    case 'MIRROR':
                        break;
                    default:
                        // TODO: move to errors
                        // console.warn('Webgl don`t support this wrapmode: ' + stateValue);
                        return null;
                }
                break;
            case 'MAGFILTER':
            case 'MINFILTER':
                stateValue = subStateExprNode.value.toUpperCase();
                switch (stateValue) {
                    case 'POINT':
                        stateValue = 'NEAREST';
                        break;
                    case 'POINT_MIPMAP_POINT':
                        stateValue = 'NEAREST_MIPMAP_NEAREST';
                        break;
                    case 'LINEAR_MIPMAP_POINT':
                        stateValue = 'LINEAR_MIPMAP_NEAREST';
                        break;
                    case 'POINT_MIPMAP_LINEAR':
                        stateValue = 'NEAREST_MIPMAP_LINEAR';
                        break;
                    case 'NEAREST':
                    case 'LINEAR':
                    case 'NEAREST_MIPMAP_NEAREST':
                    case 'LINEAR_MIPMAP_NEAREST':
                    case 'NEAREST_MIPMAP_LINEAR':
                    case 'LINEAR_MIPMAP_LINEAR':
                        break;
                    default:
                        // TODO: move to erros api
                        // console.warn('Webgl don`t support this texture filter: ' + stateValue);
                        return null;
                }
                break;
            default:
                // TODO: move to erros api
                console.warn('Don`t support this texture param: ' + stateType);
                return null;
        }
        return new _instructions_SamplerStateInstruction__WEBPACK_IMPORTED_MODULE_44__["SamplerStateInstruction"]({
            sourceNode,
            scope,
            name: stateType,
            value: new _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_47__["StringInstruction"]({ sourceNode: stateExprNode, scope, value: stateValue })
        });
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_FLOAT = '2.'
     *         T_PUNCTUATOR_44 = ','
     *         T_FLOAT = '1.'
     *         T_PUNCTUATOR_40 = '('
     *         T_TYPE_ID = 'float4'
     */
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *       + PostfixPointExpr
     */
    analyzeComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'PostfixPointExpr':
            case 'T_NON_TYPE_ID':
                return this.analyzeFunctionCallExpr(context, program, sourceNode);
            case 'BaseType':
            case 'T_TYPE_ID':
                return this.analyzeConstructorCallExpr(context, program, sourceNode);
            default:
                return this.analyzeSimpleComplexExpr(context, program, sourceNode);
        }
    }
    analyzeCallee(context, program, sourceNode) {
        const children = sourceNode.children;
        return this.analyzeExpr(context, program, children[children.length - 1]);
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_44 = ','
     *         T_NON_TYPE_ID = 'a'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'foo'
     */
    /**
     * AST example:
     *    PostfixPointExpr
     *         T_NON_TYPE_ID = 'IncrementCounter'
     *         T_PUNCTUATOR_46 = '.'
     *       + PostfixExpr
     */
    analyzeFunctionCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const firstNodeName = children[children.length - 1].name;
        const args = [];
        if (children.length > 3) {
            for (let i = children.length - 3; i > 0; i--) {
                if (children[i].value !== ',') {
                    const arg = this.analyzeExpr(context, program, children[i]);
                    args.push(arg);
                }
            }
        }
        let funcName = null;
        let func = null;
        let callee = null;
        switch (firstNodeName) {
            // call as function
            case 'T_NON_TYPE_ID':
                {
                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address
                    funcName = children[children.length - 1].value;
                    func = globalScope.findFunction(funcName, args.map(asRelaxedType));
                }
                break;
            // call as method
            case 'PostfixPointExpr':
                {
                    callee = this.analyzeCallee(context, program, children[children.length - 1]);
                    funcName = children[children.length - 1].children[0].value; // method name
                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));
                }
                break;
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidComplexNotFunction, { funcName });
            return null;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].CannotChooseFunction, { funcName });
            return null;
        }
        if (func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_FunctionDecl &&
            func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_SystemFunctionDecl) {
            console.error("@undefined_behavior");
            return null;
        }
        const params = func.def.params;
        for (let i = 0; i < args.length; i++) {
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(args[i])) {
                continue;
            }
            if (params[i].type.hasUsage('out')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_8__["expression"].unwind(args[i]);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidExprIsNotLValue);
                    return null;
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForWriting);
                    return null;
                }
            }
            else if (params[i].type.hasUsage('inout')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_8__["expression"].unwind(args[i]);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidExprIsNotLValue);
                    return null;
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForWriting);
                    return null;
                }
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                    return null;
                }
            }
            else {
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                    return null;
                }
            }
        }
        const type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"].wrap(func.def.returnType, scope); // TODO: remove wrap?
        const expr = new _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_24__["FunctionCallInstruction"]({ scope, type, decl: func, args, sourceNode, callee });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *       + BaseType
     */
    analyzeConstructorCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const ctorType = this.analyzeType(context, program, children[children.length - 1]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(ctorType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidComplexNotType);
            return null;
        }
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 3; i > 0; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeExpr(context, program, children[i]);
                    args.push(argumentExpr);
                }
            }
        }
        // TODO: add correct implementation! 
        const exprType = findConstructor(ctorType, args);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidComplexNotConstructor, { typeName: String(ctorType) });
            return null;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(args)) {
            for (let i = 0; i < args.length; i++) {
                if (!args[i].type.readable) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                    return null;
                }
            }
        }
        const expr = new _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_19__["ConstructorCallInstruction"]({ scope, sourceNode, ctor: exprType, args });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        ;
    }
    // TODO: add comment!
    analyzeSimpleComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[1]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(expr)) {
            return null;
        }
        // let type = <IVariableTypeInstruction>expr.type;
        let complexExpr = new _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_16__["ComplexExprInstruction"]({ scope, sourceNode, expr });
        return checkInstruction(context, complexExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const symbol = children[children.length - 2].value;
        switch (symbol) {
            case '[':
                return this.analyzePostfixIndex(context, program, sourceNode);
            case '.':
                return this.analyzePostfixPoint(context, program, sourceNode);
            case '++':
            case '--':
                return this.analyzePostfixArithmetic(context, program, sourceNode);
        }
        return null;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixIndex(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(postfixExpr)) {
            // TODO: emit error?
            return null;
        }
        const postfixExprType = postfixExpr.type;
        if (!postfixExprType.isArray()) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidPostfixNotArray, { typeName: String(postfixExprType) });
            return null;
        }
        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const indexExprType = indexExpr.type;
        if (!(indexExprType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"]) || indexExprType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"]))) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });
            return null;
        }
        const expr = new _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_37__["PostfixIndexInstruction"]({ scope, sourceNode, element: postfixExpr, index: indexExpr });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     * @param fieldName
     */
    createFieldDecl(elementType, fieldName) {
        if (!elementType.hasField(fieldName)) {
            return null;
        }
        // in case of typical postfix exp. like "element.postfix":
        //      elementType => type defrived from the parameter or variable declaration or derived from another expr
        //      elementType.subType => original complex (structure) type
        // in case of something else, like ccall with postfix "float2(1.0, 2.0).yx":
        //      elementType => original system type
        const scope = elementType.scope;
        const { id, type, type: { padding, length }, semantic } = 
        // FIXME: remove 'logical OR' operation, always use subType
        (elementType.subType || elementType).getField(fieldName); // arrayIndex
        // note: sourceNode for field is being used from the original complex structure.
        // let arrayIndex: IExprInstruction = null;
        // if (type.isNotBaseArray()) {
        //     // using of length instead of arrayIndex because of lack of api functionality :/
        //     assert(length != Instruction.UNDEFINE_LENGTH, "undefined behaviour found");
        //     arrayIndex = new IntInstruction({ scope, value: String(length) });
        // }
        const fieldType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ type, scope, padding, sourceNode: type.sourceNode /*, arrayIndex*/ });
        const fieldId = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, name: id.name, sourceNode: id.sourceNode });
        const field = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_51__["VariableDeclInstruction"]({ scope, id: fieldId, type: fieldType, semantic, sourceNode: fieldId.sourceNode });
        return _instructions_Instruction__WEBPACK_IMPORTED_MODULE_31__["Instruction"].$withParent(field, elementType);
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     */
    analyzePostfixPointField(context, program, sourceNode, elementType) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(elementType)) {
            return null;
        }
        const scope = program.currentScope;
        const name = sourceNode.value; // fiedl name
        // const decl = this.createFieldDecl(elementType, name);   // field decl
        const decl = elementType.getField(name);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl)) {
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, sourceNode, name });
        const expr = new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_27__["IdExprInstruction"]({ scope, sourceNode, id, decl });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        ;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     */
    /**
     * Expressions like:
     *      **(element.postfix)**
     */
    analyzePostfixPoint(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const element = this.analyzeExpr(context, program, children[children.length - 1]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(element)) {
            // TODO: emit error?
            return null;
        }
        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(postfix)) {
            const fieldName = children[children.length - 3].value;
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidPostfixNotField, { typeName: String(element.type), fieldName });
            return null;
        }
        const expr = new _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_38__["PostfixPointInstruction"]({ sourceNode, scope, element, postfix });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'b'
     */
    analyzePostfixArithmetic(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[0].value;
        const postfixExpr = this.analyzeExpr(context, program, children[1]);
        const postfixExprType = postfixExpr.type;
        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidPostfixArithmetic, {
                operator: operator,
                typeName: String(postfixExprType)
            });
            return null;
        }
        const expr = new _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_36__["PostfixArithmeticInstruction"]({ scope, sourceNode, operator, expr: postfixExpr });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    UnaryExpr
     *         T_NON_TYPE_ID = 'x'
     *         T_PUNCTUATOR_33 = '!'
     */
    analyzeUnaryExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const operator = children[1].value;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[0]);
        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidUnaryOperation, {
                operator: operator,
                tyename: String(expr.type)
            });
            return null;
        }
        let unaryExpr = null;
        // shortcut for replacment of unary expressions with literals
        if (operator === '-' || operator === '+') {
            if (_helpers__WEBPACK_IMPORTED_MODULE_8__["instruction"].isLiteral(expr)) {
                switch (expr.instructionType) {
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_IntExpr:
                        {
                            let lit = expr;
                            let signed = operator === '-' || lit.signed;
                            unaryExpr = new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_33__["IntInstruction"]({ scope, sourceNode, value: Number(`${operator}${lit.value}`), signed });
                        }
                        break;
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_FloatExpr:
                        unaryExpr = new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_22__["FloatInstruction"]({ scope, sourceNode, value: Number(`${operator}${expr.value}`) });
                }
            }
        }
        if (!unaryExpr) {
            unaryExpr = new _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_50__["UnaryExprInstruction"]({ scope, sourceNode, expr, operator });
        }
        return checkInstruction(context, unaryExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    CastExpr
     *         T_NON_TYPE_ID = 'y'
     *         T_PUNCTUATOR_41 = ')'
     *       + ConstType
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeCastExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const type = this.analyzeConstTypeDim(context, program, children[2]);
        const sourceExpr = this.analyzeExpr(context, program, children[0]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(sourceExpr)) {
            return null;
        }
        if (!sourceExpr.type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        const expr = new _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_14__["CastExprInstruction"]({ scope, sourceNode, sourceExpr, type });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        ;
    }
    /**
     * AST example:
     *    ConditionalExpr
     *         T_KW_FALSE = 'false'
     *         T_PUNCTUATOR_58 = ':'
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_63 = '?'
     *         T_NON_TYPE_ID = 'isOk'
     */
    analyzeConditionalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const rightExpr = this.analyzeExpr(context, program, children[0]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(conditionExpr) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(leftExpr) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(rightExpr)) {
            context.error(conditionExpr ? conditionExpr.sourceNode : sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        const conditionType = conditionExpr.type;
        const leftExprType = leftExpr.type;
        const rightExprType = rightExpr.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"];
        if (!conditionType.isEqual(boolType)) {
            context.error(conditionExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidConditionType, { typeName: String(conditionType) });
            return null;
        }
        if (!leftExprType.isEqual(rightExprType)) {
            context.error(leftExprType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidConditonValueTypes, {
                leftTypeName: String(leftExprType),
                rightTypeName: String(rightExprType)
            });
            return null;
        }
        if (!conditionType.readable) {
            context.error(conditionType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        if (!leftExprType.readable) {
            context.error(leftExprType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        if (!rightExprType.readable) {
            context.error(rightExprType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        const condExpr = new _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_18__["ConditionalExprInstruction"]({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });
        return checkInstruction(context, condExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        ;
    }
    /**
     * AST example:
     *    AddExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_43 = '+'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeArithmeticExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        if (!left || !right) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: '[unknown]',
                rightTypeName: '[unknown]'
            });
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: String(leftType),
                rightTypeName: String(rightType)
            });
            return null;
        }
        const arithmeticExpr = new _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_9__["ArithmeticExprInstruction"]({ scope, sourceNode, left, right, operator, type });
        return checkInstruction(context, arithmeticExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    RelationalExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_60 = '<'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeRelationExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left ? left.type : null;
        const rightType = right ? right.type : null;
        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left ? left.sourceNode : null, right ? right.sourceNode : null);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidRelationalOperation, {
                operator: operator,
                leftTypeName: leftType ? _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(leftType) : '[unknown]',
                rightTypeName: rightType ? _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(rightType) : '[unknown]'
            });
            return null;
        }
        if (!left || !right) {
            return null;
        }
        const relationExpr = new _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_41__["RelationalExprInstruction"]({ sourceNode, scope, left, right, operator });
        return checkInstruction(context, relationExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    OrExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_OP_OR = '||'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeLogicalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left.type;
        const rightType = right.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"];
        if (!leftType.isEqual(boolType)) {
            context.error(leftType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidLogicOperation, {
                operator: operator,
                typeName: String(leftType)
            });
            return null;
        }
        if (!rightType.isEqual(boolType)) {
            context.error(rightType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidLogicOperation, {
                operator: operator,
                typeName: String(rightType)
            });
            return null;
        }
        if (!leftType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        if (!rightType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        let logicalExpr = new _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_34__["LogicalExprInstruction"]({ scope, sourceNode, left, right, operator });
        return checkInstruction(context, logicalExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    AssignmentExpr
     *         T_UINT = '10'
     *         T_OP_AE = '+='
     *         T_NON_TYPE_ID = 'x'
     */
    analyzeAssignmentExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        if (!_helpers__WEBPACK_IMPORTED_MODULE_8__["expression"].unwind(left)) {
            // Invalid left-hand side in assignment
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidLeftHandSideInAssignment, {
                operator: operator
            });
        }
        const right = this.analyzeExpr(context, program, children[0]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(left) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(right)) {
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        let exprType = null;
        if (operator !== '=') {
            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidArithmeticAssigmentOperation, {
                    operator: operator,
                    leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(leftType),
                    rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(rightType)
                });
            }
        }
        else {
            exprType = rightType;
        }
        // FIXME: show corrent source nodes for left and right expression.
        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidAssigmentOperation, {
                leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(leftType),
                rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_8__["type"].signature(rightType)
            });
        }
        let assigmentExpr = new _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_10__["AssignmentExprInstruction"]({ scope, sourceNode, left, right, operator });
        return checkInstruction(context, assigmentExpr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    T_NON_TYPE_ID = 'name'
     */
    analyzeIdExpr(context, program, sourceNode) {
        const scope = program.currentScope;
        const name = sourceNode.value;
        const decl = scope.findVariable(name);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnknownVarName, { varName: name });
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, sourceNode, name });
        const expr = new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_27__["IdExprInstruction"]({ scope, sourceNode, id, decl });
        return checkInstruction(context, expr, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    analyzeSimpleExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        const value = sourceNode.value;
        const scope = program.currentScope;
        switch (name) {
            case 'T_UINT':
                {
                    const match = value.match(/^([0-9]+)(u?)$/);
                    const signed = match[2] !== 'u';
                    return new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_33__["IntInstruction"]({ scope, sourceNode, value: Number(match[1]), signed });
                }
            case 'T_FLOAT':
                return new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_22__["FloatInstruction"]({ scope, sourceNode, value: Number(value) });
            case 'T_STRING':
                return new _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_47__["StringInstruction"]({ scope, sourceNode, value });
            case 'T_KW_TRUE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_12__["BoolInstruction"]({ scope, sourceNode, value: true });
            case 'T_KW_FALSE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_12__["BoolInstruction"]({ scope, sourceNode, value: false });
        }
        return null;
    }
    /**
     * AST example:
     *    ConstType
     *       + Type
     */
    analyzeConstTypeDim(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length > 1) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCastTypeUsage);
            return null;
        }
        const type = (this.analyzeType(context, program, children[0]));
        if (!type.isBase()) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidCastTypeNotBase, { typeName: String(type) });
        }
        return checkInstruction(context, type, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *       + UsageType
     */
    analyzeVarStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);
        let vars = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));
            }
        }
        return vars;
    }
    analyzeUsageStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'StructDecl') {
                type = this.analyzeStructDecl(context, program, children[i]);
                const typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_49__["TypeDeclInstruction"]({ scope, sourceNode: children[i], type });
                addTypeDecl(context, scope, typeDecl);
            }
            else if (children[i].name === 'Usage') {
                const usage = this.analyzeUsage(children[i]);
                usages.push(usage);
            }
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type));
        let varType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ scope, sourceNode, usages, type });
        return checkInstruction(context, varType, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *       + VariableDecl
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     *    Struct
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStruct(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let name = null;
        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {
            name = children[children.length - 2].value;
        }
        let fields = [];
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Struct);
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        const struct = new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_17__["ComplexTypeInstruction"]({ scope, sourceNode, fields, name });
        return checkInstruction(context, struct, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + Annotation
     *       + FunctionDef
     */
    analyzeFunctionDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const lastNodeValue = children[0].value;
        let annotation = null;
        let implementation = null;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Default);
        const attributes = [];
        while (children[children.length - 1 - attributes.length].name === 'Attribute') {
            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));
        }
        const definition = this.analyzeFunctionDef(context, program, children[children.length - 1 - attributes.length]);
        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)
        let func = globalScope.findFunction(definition.name, definition.params.map(asType));
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].CannotChooseFunction, { funcName: definition.name });
            program.pop();
            return null;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func) && func.impl) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].FunctionRedefinition, { funcName: definition.name });
            program.pop();
            return null;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func)) {
            if (!func.def.returnType.isEqual(definition.returnType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFuncDefenitionReturnType, { funcName: definition.name });
                program.pop();
                return null;
            }
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(context.funcDef === null);
        // TODO: rewrite context ?
        context.funcDef = definition;
        if (children.length === 3) {
            annotation = this.analyzeAnnotation(children[1]);
        }
        if (lastNodeValue !== ';') {
            // TODO: do to increase scope depth inside stmt block!!
            implementation = this.analyzeStmtBlock(context, program, children[0]);
        }
        program.pop();
        let hasVoidType = definition.returnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"]);
        // validate unreachable code.
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(implementation)) {
            let stmtList = implementation.stmtList;
            // stmtList = stmtList.slice().reverse();
            for (let i = stmtList.length - 1; i >= 0; --i) {
                if (stmtList[i].instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_ReturnStmt) {
                    if (i != stmtList.length - 1) {
                        context.error(stmtList[i + 1].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnreachableCode);
                    }
                    break;
                }
            }
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(scope == globalScope);
        func = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_25__["FunctionDeclInstruction"]({ sourceNode, scope, definition, implementation, annotation, attributes });
        // NOTE: possible implicit replacement of function 
        //       without implementaion inside addFunction() call.
        if (!globalScope.addFunction(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].FunctionRedifinition, { funcName: definition.name });
        }
        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(implementation)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFunctionReturnStmtNotFound, { funcName: definition.name });
        }
        return func;
    }
    /**
     * AST example:
     *    FunctionDef
     *       + ParamList
     *         T_NON_TYPE_ID = 'bar'
     *       + UsageType
     */
    analyzeFunctionDef(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nameNode = children[children.length - 2];
        const name = nameNode.value;
        const retTypeNode = children[children.length - 1];
        let returnType = this.analyzeUsageType(context, program, retTypeNode);
        // TODO: is it really needed?
        if (returnType.isContainSampler()) {
            context.error(retTypeNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFunctionReturnType, { funcName: name });
            return null;
        }
        let id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, name, sourceNode: nameNode });
        let semantic = null;
        if (children.length === 4) {
            semantic = this.analyzeSemantic(children[0]);
        }
        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);
        let funcDef = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_26__["FunctionDefInstruction"]({ scope, sourceNode, returnType, id, paramList, semantic });
        checkInstruction(context, funcDef, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return funcDef;
    }
    /**
     * AST example:
     *    ParamList
     *         T_PUNCTUATOR_41 = ')'
     *       + ParameterDecl
     *         T_PUNCTUATOR_44 = ','
     *       + ParameterDecl
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeParamList(context, program, sourceNode) {
        const children = sourceNode.children;
        let paramList = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'ParameterDecl') {
                let param = this.analyzeParameterDecl(context, program, children[i]);
                paramList.push(param);
            }
        }
        return paramList;
    }
    /**
     * AST example:
     *    ParameterDecl
     *       + Variable
     *       + ParamUsageType
     */
    analyzeParameterDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const type = this.analyzeParamUsageType(context, program, children[1]);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
            return null;
        }
        const param = this.analyzeVariable(context, program, children[0], type);
        return param;
    }
    /**
     * AST example:
     *    ParamUsageType
     *       + Type
     *       + ParamUsage
     */
    analyzeParamUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                type = this.analyzeType(context, program, children[i]);
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'ParamUsage') {
                usages.push(this.analyzeUsage(children[i]));
            }
        }
        let paramType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"]({ scope, sourceNode, type, usages });
        checkInstruction(context, paramType, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return paramType;
    }
    /**
     * AST example:
     *    StmtBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + Stmt
     *       + Stmt
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeStmtBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (!children) {
            return null;
        }
        let stmtList = [];
        for (let i = children.length - 2; i > 0; i--) {
            let stmt = this.analyzeStmt(context, program, children[i]);
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(stmt)) {
                stmtList.push(stmt);
            }
        }
        const stmtBlock = new _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_46__["StmtBlockInstruction"]({ sourceNode, scope, stmtList });
        checkInstruction(context, stmtBlock, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return stmtBlock;
    }
    analyzeStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        let nonAttrNode = children.length;
        let nonAttrNodeName;
        do {
            nonAttrNodeName = children[--nonAttrNode].name;
        } while (nonAttrNodeName === 'Attribute');
        switch (nonAttrNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'UseDecl':
                this.analyzeUseDecl(context, program, children[0]);
                return null;
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
            case 'T_KW_IF':
                return this.analyzeIfStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_RETURN':
                return this.analyzeReturnStmt(context, program, sourceNode);
            case 'T_KW_DO':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'StmtBlock':
                {
                    program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Default);
                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);
                    program.pop();
                    return stmtBlock;
                }
            case 'T_KW_DISCARD':
            case 'T_KW_BREAK':
            case 'T_KW_CONTINUE':
                return this.analyzeBreakStmt(context, program, sourceNode);
            case 'TypeDecl':
            case 'VariableDecl':
            case 'VarStructDecl':
                return this.analyzeDeclStmt(context, program, children[0]);
            default:
                if (children.length === 2) {
                    return this.analyzeExprStmt(context, program, sourceNode);
                }
                return new _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_45__["SemicolonStmtInstruction"]({ sourceNode, scope });
        }
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_NON_TYPE_ID = 'y'
     *         T_KW_RETURN = 'return'
     */
    analyzeReturnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(context.func);
        const funcReturnType = context.funcDef.returnType;
        context.haveCurrentFunctionReturnOccur = true;
        if (children.length === 2) {
            tryResolveProxyType(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"]);
        }
        if (funcReturnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"]) && children.length === 3) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtVoid);
            return null;
        }
        else if (!funcReturnType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_VOID"]) && children.length === 2) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtEmpty);
            return null;
        }
        let expr = null;
        if (children.length === 3) {
            expr = this.analyzeExpr(context, program, children[1]);
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(expr)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtTypesNotEqual);
                return null;
            }
            tryResolveProxyType(funcReturnType, expr.type);
            if (!funcReturnType.isEqual(expr.type)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtTypesNotEqual);
                return null;
            }
        }
        const returnStmtInstruction = new _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_42__["ReturnStmtInstruction"]({ sourceNode, scope, expr });
        checkInstruction(context, returnStmtInstruction, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return returnStmtInstruction;
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_KW_BREAK = 'break'
     */
    analyzeBreakStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        if (operator === 'discard' && !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(context.funcDef)) {
            // context.currentFunction.vertex = (false);
        }
        const breakStmtInstruction = new _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_13__["BreakStmtInstruction"]({ sourceNode, scope, operator });
        checkInstruction(context, breakStmtInstruction, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return breakStmtInstruction;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeDeclStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nodeName = sourceNode.name;
        let declList = [];
        switch (nodeName) {
            case 'TypeDecl':
                declList.push(this.analyzeTypeDecl(context, program, sourceNode));
                break;
            case 'VariableDecl':
                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));
                break;
            case 'VarStructDecl':
                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));
                break;
        }
        const declStmtInstruction = new _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_20__["DeclStmtInstruction"]({ sourceNode, scope, declList });
        checkInstruction(context, declStmtInstruction, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return declStmtInstruction;
    }
    analyzeExprStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const expr = this.analyzeExpr(context, program, children[1]);
        const exprStmt = new _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_21__["ExprStmtInstruction"]({ sourceNode, scope, expr });
        checkInstruction(context, exprStmt, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return exprStmt;
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *       + Stmt
     *         T_KW_DO = 'do'
     */
    analyzeWhileStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isDoWhile = (children[children.length - 1].value === 'do');
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"];
        let cond = null;
        let conditionType = null;
        let body = null;
        let operator = "do";
        if (isDoWhile) {
            operator = "do";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!conditionType.isEqual(boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidDoWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            body = this.analyzeStmt(context, program, children[0]);
        }
        else {
            operator = "while";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!conditionType.isEqual(boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            if (isNonIfStmt) {
                body = this.analyzeNonIfStmt(context, program, children[0]);
            }
            else {
                body = this.analyzeStmt(context, program, children[0]);
            }
        }
        const whileStmt = new _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_53__["WhileStmtInstruction"]({ sourceNode, scope, cond, body, operator });
        checkInstruction(context, whileStmt, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return whileStmt;
    }
    /**
     * AST example:
     *    Attribute
     *         T_PUNCTUATOR_93 = ']'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '3'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '2'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'loop'
     *         T_PUNCTUATOR_91 = '['
     */
    analyzeAttribute(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const name = children[children.length - 2].value;
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 4; i > 1; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeSimpleExpr(context, program, children[i]);
                    // TODO: emit diagnostics error
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_BoolExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_FloatExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EInstructionTypes"].k_IntExpr);
                    args.push(argumentExpr);
                }
            }
        }
        return new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_11__["AttributeInstruction"]({ scope, sourceNode, name, args });
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_KW_ELSE = 'else'
     *       + NonIfStmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_IF = 'if'
     *       + Attribute
     *       + Attribute
     */
    analyzeIfStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        let attributes = [];
        while (children[children.length - 1 - attributes.length].name === 'Attribute') {
            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));
        }
        const isIfElse = (children.length - attributes.length === 7);
        const cond = this.analyzeExpr(context, program, children[children.length - 3 - attributes.length]);
        if (!cond || !cond.type.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"])) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });
        }
        let conseq = null;
        let contrary = null;
        if (isIfElse) {
            conseq = this.analyzeNonIfStmt(context, program, children[2]);
            contrary = this.analyzeStmt(context, program, children[0]);
        }
        else {
            conseq = this.analyzeNonIfStmt(context, program, children[0]);
        }
        if (!cond) {
            return null;
        }
        const ifStmt = new _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_29__["IfStmtInstruction"]({ sourceNode, scope, cond, conseq, contrary, attributes });
        checkInstruction(context, ifStmt, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return ifStmt;
    }
    /**
     * AST example:
     *    NonIfStmt
     *       + SimpleStmt
     */
    analyzeNonIfStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeForStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');
        let body = null;
        let init = null;
        let cond = null;
        let step = null;
        if (children[1].name === 'ERROR') {
            return null;
        }
        program.push();
        init = this.analyzeForInit(context, program, children[children.length - 3]);
        cond = this.analyzeForCond(context, program, children[children.length - 4]);
        step = null;
        if (children.length === 7) {
            step = this.analyzeForStep(context, program, children[2]);
        }
        if (isNonIfStmt) {
            body = this.analyzeNonIfStmt(context, program, children[0]);
        }
        else {
            body = this.analyzeStmt(context, program, children[0]);
        }
        program.pop();
        const pForStmtInstruction = new _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_23__["ForStmtInstruction"]({ sourceNode, scope, init, cond, step, body });
        checkInstruction(context, pForStmtInstruction, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
        return pForStmtInstruction;
    }
    /**
     * AST example:
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + AssignmentExpr
     *    ForInit
     *       + VariableDecl
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + Expr
     */
    analyzeForInit(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'VariableDecl':
                // TODO: fixme!! 
                // add support for expressions like "a = 1, b = 2, c = 3"
                return this.analyzeVariableDecl(context, program, children[0])[0] || null;
            case 'Expr':
                // TODO: fixme!! 
                // add support for expressions like "a = 1, b = 2, c = 3"
                return this.analyzeExpr(context, program, children[0]);
        }
        // ForInit : ';'
        return null;
    }
    /**
     * AST example:
     *    ForCond
     *         T_PUNCTUATOR_59 = ';'
     *       + RelationalExpr
     */
    analyzeForCond(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length === 1) {
            return null;
        }
        return this.analyzeExpr(context, program, children[1]);
    }
    /**
     * AST example:
     *    ForStep
     *       + UnaryExpr
     */
    analyzeForStep(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length == 0) {
            return null;
        }
        const step = this.analyzeExpr(context, program, children[0]);
        return step;
    }
    analyzeTechniqueDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let passList = null;
        let techniqueType = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ETechniqueType"].k_BasicFx;
        for (let i = children.length - 3; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else {
                passList = this.analyzeTechnique(context, program, children[i]);
            }
        }
        const technique = new _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_48__["TechniqueInstruction"]({ sourceNode, name, techniqueType, semantic, annotation, passList, scope });
        Analyzer.addTechnique(context, program, technique);
        return technique;
    }
    /**
     * AST example:
     *    TechniqueBody
     *         T_PUNCTUATOR_125 = '}'
     *       + PassDecl
     *       + PassDecl
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeTechnique(context, program, sourceNode) {
        const children = sourceNode.children;
        let passList = [];
        for (let i = children.length - 2; i >= 1; i--) {
            let pass = this.analyzePassDecl(context, program, children[i]);
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(pass));
            passList.push(pass);
        }
        return passList;
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *       + Annotation
     *         T_NON_TYPE_ID = 'name'
     *         T_KW_PASS = 'pass'
     */
    analyzePassDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_28__["IdInstruction"]({ scope, name });
            }
        }
        const pass = new _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_35__["PassInstruction"]({
            scope,
            sourceNode,
            renderStates,
            id,
            pixelShader: entry.pixel,
            vertexShader: entry.vertex
        });
        //TODO: add annotation and id
        return pass;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'VertexShader'
     */
    analyzePassStateBlockForShaders(context, program, sourceNode) {
        const children = sourceNode.children;
        let pixel = null;
        let vertex = null;
        const supportedTypeNames = ['vertexshader', 'pixelshader'];
        for (let i = children.length - 2; i >= 1; i--) {
            let func = null;
            const childrenIth = children[i].children;
            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();
            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {
                continue;
            }
            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(func)) {
                switch (shaderTypeName) {
                    case 'vertexshader':
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(vertex == null);
                        vertex = func;
                        break;
                    case 'pixelshader':
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(pixel == null);
                        pixel = func;
                        break;
                    default:
                        // TODO: make error!
                        console.error('function is not suitable as shader entry point');
                }
            }
        }
        return { vertex, pixel };
    }
    analyzePassStateForShader(context, program, sourceNode, shaderType) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(shaderType === 'vertexshader' || shaderType === 'pixelshader');
        const children = sourceNode.children;
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        const compileExpr = this.analyzeExpr(context, program, exprNode);
        const shaderFunc = compileExpr.function;
        if (shaderType === 'vertexshader') {
            if (!checkForVertexUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });
            }
        }
        else {
            if (!checkForPixelUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });
            }
        }
        return shaderFunc;
    }
    /**
     * AST example:
     *    PassStateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + PassState
     *       + PassState
     *       + PassState
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzePassStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePassState(context, program, children[i]) };
        }
        return states;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'ZWRITE'
     */
    analyzePassState(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateType = children[children.length - 1].value.toUpperCase();
        const stateName = _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"][stateType] || null;
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(stateName)) {
            return {};
        }
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(exprNode.value)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            return {};
        }
        let renderStates = {};
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());
            }
            switch (stateName) {
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDFUNC:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDALPHA] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDALPHA] = values[1];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDFUNCSEPARATE:
                    if (values.length !== 4) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDALPHA] = values[2];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDALPHA] = values[3];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONSEPARATE:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONALPHA] = values[1];
                    break;
                default:
                    console.warn('Pass state is incorrect.');
                    return {};
            }
        }
        else {
            let value = '';
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            const stateValue = getRenderStateValue(stateName, value);
            if (stateValue !== _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_3__["ERenderStateValues"].UNDEF) {
                switch (stateName) {
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].SRCBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].DESTBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATION:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_2__["ERenderStates"].BLENDEQUATIONALPHA] = stateValue;
                        break;
                    default:
                        renderStates[stateName] = stateValue;
                        break;
                }
            }
        }
        return renderStates;
    }
    /**
     * AST example:
     *    ImportDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_IMPORT = 'import'
     */
    // TODO: restore functionality! 
    analyzeImportDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const componentName = this.analyzeComplexName(children[children.length - 2]);
        // if (!isNull(technique)) {
        //     //We can import techniques from the same file, but on this stage they don`t have component yet.
        //     //So we need special mehanism to add them on more belated stage
        //     // let sShortedComponentName: string = componentName;
        //     if (!isNull(context.moduleName)) {
        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + ".", "");
        //     }
        //     throw null;
        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];
        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {
        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);
        //     //     return;
        //     // }
        // }
        const sourceTechnique = null; //fx.techniques[componentName];
        if (!sourceTechnique) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].ImportedComponentNotExists, { componentName: componentName });
            return null;
        }
        return null;
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children[children.length - 2].value;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["EScopeType"].k_Struct);
        let fields = [];
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        const struct = new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_17__["ComplexTypeInstruction"]({ scope, sourceNode, name, fields });
        return checkInstruction(context, struct, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + StructDecl
     */
    analyzeTypeDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        if (children.length === 2) {
            type = this.analyzeStructDecl(context, program, children[1]);
        }
        else {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].UnsupportedTypeDecl);
        }
        let typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_49__["TypeDeclInstruction"]({ scope, sourceNode, type });
        addTypeDecl(context, scope, typeDecl);
        return checkInstruction(context, typeDecl, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__["ECheckStage"].CODE_TARGET_SUPPORT);
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'TechniqueDecl':
                return [this.analyzeTechniqueDecl(context, program, sourceNode)];
            case 'UseDecl':
                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!
                return null;
            case 'ImportDecl':
                return [this.analyzeImportDecl(context, program, sourceNode)];
            case 'ProvideDecl':
                return [this.analyzeProvideDecl(context, program, sourceNode)];
            case 'TypeDecl':
                return [this.analyzeTypeDecl(context, program, sourceNode)];
            case 'VariableDecl':
                return this.analyzeVariableDecl(context, program, sourceNode);
            case 'VarStructDecl':
                return this.analyzeVarStructDecl(context, program, sourceNode);
            case 'FunctionDecl':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(program.currentScope == program.globalScope);
                let fdecl = null;
                context.beginFunc();
                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);
                context.endFunc();
                return [fdecl];
        }
        return null;
    }
    analyzeGlobals(context, program, slastDocument) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(slastDocument) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(slastDocument.root)) {
            return null;
        }
        const children = slastDocument.root.children;
        let globals = [];
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(children)) {
            return [];
        }
        for (let i = children.length - 1; i >= 0; i--) {
            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));
        }
        return globals.filter(decl => !!decl);
    }
    createContext(uri) {
        return new Context(uri);
    }
    createProgram(document = null) {
        let parent = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["SCOPE"];
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(document)) {
            parent = document.root.scope;
        }
        return new _ProgramScope__WEBPACK_IMPORTED_MODULE_54__["ProgramScope"](parent);
    }
    /**
     * Post-analysis validation.
     */
    validate(context, program, root) {
        checkFunctionsForRecursion(context, program);
        program.validate();
    }
    async parse(slastDocument, document) {
        const uri = slastDocument.uri;
        // console.time(`analyze(${uri})`);
        const program = this.createProgram(document);
        const context = this.createContext(uri);
        let instructions = null;
        try {
            instructions = this.analyzeGlobals(context, program, slastDocument);
        }
        catch (e) {
            // critical errors were occured
            // throw e;
            console.error(e);
        }
        // console.timeEnd(`analyze(${uri})`);
        const root = new _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_32__["InstructionCollector"]({ scope: program.globalScope, instructions });
        this.validate(context, program, root);
        const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_5__["Diagnostics"].mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);
        return { root, diagnosticReport, uri };
    }
    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {
    //     if (isSystemFunction(func)) {
    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });
    //     }
    //     let isFunctionAdded: boolean = program.addFunction(func);
    //     if (!isFunctionAdded) {
    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });
    //     }
    // }
    static addTechnique(context, program, technique) {
        let name = technique.name;
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(program.globalScope.findTechnique(name))) {
            context.error(technique.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].TechniqueNameRedefinition, { techName: name });
            return;
        }
        program.globalScope.addTechnique(technique);
    }
    /**
    * Check the possibility of using the operator between the two types.
    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.
     *
     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =
     * @leftType {IVariableTypeInstruction} Type of the left side of the expression.
     * @rightType {IVariableTypeInstruction} Type of the right side of the expression.
     */
    static checkTwoOperandExprTypes(context, operator, leftType, rightType, leftSourceNode = leftType.sourceNode, rightSourceNode = rightType.sourceNode) {
        if (!leftType || !rightType) {
            return null;
        }
        const isComplex = leftType.isComplex() || rightType.isComplex();
        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();
        const isSampler = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isSamplerType"](leftType) || _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isSamplerType"](rightType);
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"];
        // const constBoolType = VariableTypeInstruction.wrapAsConst(T_BOOL, SystemScope.SCOPE);
        if (isArray || isSampler) {
            return null;
        }
        if (operator === '%' || operator === '%=') {
            return null;
        }
        if (Analyzer.isAssignmentOperator(operator)) {
            if (!leftType.writable) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForWriting);
                return null;
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                return null;
            }
            if (operator !== '=' && !leftType.readable) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            }
        }
        else {
            if (!leftType.readable) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                return null;
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
                return null;
            }
        }
        if (isComplex) {
            if (operator === '=' && leftType.isEqual(rightType)) {
                return leftType;
            }
            // samplers and arrays can't be compared directly
            else if (Analyzer.isEqualOperator(operator) && !leftType.isContainArray() && !leftType.isContainSampler()) {
                return boolType;
            }
            else {
                return null;
            }
        }
        // FIXME: use operands' scope instead of system scope?
        const leftBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"].wrap(leftType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_55__["SCOPE"]);
        const rightBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_52__["VariableTypeInstruction"].wrap(rightType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_55__["SCOPE"]);
        if (leftType.isConst() && Analyzer.isAssignmentOperator(operator)) {
            // TODO: emit proper error
            return null;
        }
        if (leftType.isEqual(rightType)) {
            if (Analyzer.isArithmeticalOperator(operator)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isMatrixType"](leftType) || (operator !== '/' && operator !== '/=')) {
                    return leftBaseType;
                }
                else {
                    return null;
                }
            }
            else if (Analyzer.isRelationalOperator(operator)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isScalarType"](leftType)) {
                    return boolType;
                }
                else {
                    return null;
                }
            }
            else if (Analyzer.isEqualOperator(operator)) {
                return boolType;
            }
            else if (operator === '=') {
                return leftBaseType;
            }
            else {
                return null;
            }
        }
        // temp workaround for INT/UINT comparison
        if (Analyzer.isRelationalOperator(operator)) {
            if ((leftType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"]) && rightType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"])) ||
                (leftType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"]) && rightType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"]))) {
                return boolType;
            }
        }
        if (Analyzer.isArithmeticalOperator(operator)) {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isBoolBasedType"](leftType) || _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isBoolBasedType"](rightType) ||
                _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isFloatBasedType"](leftType) !== _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isFloatBasedType"](rightType) ||
                _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isIntBasedType"](leftType) !== _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isIntBasedType"](rightType) ||
                _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isUIntBasedType"](leftType) !== _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isUIntBasedType"](rightType)) {
                return null;
            }
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isScalarType"](leftType)) {
                return rightBaseType;
            }
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isScalarType"](rightType)) {
                return leftBaseType;
            }
            if (operator === '*' || operator === '*=') {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isMatrixType"](leftType) && _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isVectorType"](rightType) &&
                    leftType.length === rightType.length) {
                    return rightBaseType;
                }
                else if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isMatrixType"](rightType) && _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isVectorType"](leftType) &&
                    leftType.length === rightType.length) {
                    return leftBaseType;
                }
                else {
                    return null;
                }
            }
        }
        if (operator === '=') {
            // TODO: move conversion logic inside TypeInstruction.
            if ((leftType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"]) && rightType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"])) ||
                (leftType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_UINT"]) && rightType.isEqual(_SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_INT"]))) {
                return leftType;
            }
        }
        return null;
    }
    /**
     * Проверят возможность использования оператора к типу данных.
     * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
     *
     * @operator {string} Один из операторов: + - ! ++ --
     * @leftType {IVariableTypeInstruction} Тип операнда
     */
    static checkOneOperandExprType(context, sourceNode, operator, type) {
        const isComplex = type.isComplex();
        const isArray = type.isNotBaseArray();
        const isSampler = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["isSamplerType"](type);
        if (isComplex || isArray || isSampler) {
            return null;
        }
        if (!type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForReading);
            return null;
        }
        if (operator === '++' || operator === '--') {
            if (!type.writable) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidTypeForWriting);
                return null;
            }
            return type;
        }
        if (operator === '!') {
            const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_55__["T_BOOL"];
            // validate(boolType, EInstructionTypes.k_VariableDecl);
            if (type.isEqual(boolType)) {
                return boolType;
            }
            else {
                return null;
            }
        }
        else {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_55__["isBoolBasedType"](type)) {
                return null;
            }
            else {
                return type.baseType; // << TODO: fixme!!!! remove "any"!
            }
        }
        return null;
    }
    static isAssignmentOperator(operator) {
        return operator === '+=' || operator === '-=' ||
            operator === '*=' || operator === '/=' ||
            operator === '%=' || operator === '=';
    }
    static isArithmeticalOperator(operator) {
        return operator === '+' || operator === '+=' ||
            operator === '-' || operator === '-=' ||
            operator === '*' || operator === '*=' ||
            operator === '/' || operator === '/=';
    }
    static isRelationalOperator(operator) {
        return operator === '>' || operator === '>=' ||
            operator === '<' || operator === '<=';
    }
    static isEqualOperator(operator) {
        return operator === '==' || operator === '!=';
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "3UD+")(module)))

/***/ }),

/***/ "O8iw":
/*!********************************!*\
  !*** ./src/lib/fx/SLParser.ts ***!
  \********************************/
/*! exports provided: SLParser, defaultSLGrammar, defaultSLParser, createDefaultSLParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLParser", function() { return SLParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultSLGrammar", function() { return defaultSLGrammar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultSLParser", function() { return defaultSLParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultSLParser", function() { return createDefaultSLParser; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/AbstractParser */ "7vWe");
/* harmony import */ var raw_loader_HLSL_gr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! raw-loader!./HLSL.gr */ "yosG");




class SLParser extends _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__["AbstractParser"] {
    init({ grammar = raw_loader_HLSL_gr__WEBPACK_IMPORTED_MODULE_3__["default"], type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LALR, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_Default }) {
        super.init({ grammar, type, flags });
    }
}
let paramsDefault = null;
let parserDefault = null;
function defaultSLGrammar() {
    return raw_loader_HLSL_gr__WEBPACK_IMPORTED_MODULE_3__["default"];
}
function defaultSLParser() {
    if (!parserDefault) {
        createDefaultSLParser();
    }
    return parserDefault;
}
/**
 * Internal debugging functionality, no need to use without necessary.
 */
function createDefaultSLParser(params = { grammar: raw_loader_HLSL_gr__WEBPACK_IMPORTED_MODULE_3__["default"] }) {
    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["deepEqual"])(paramsDefault, params)) {
        return;
    }
    paramsDefault = params;
    parserDefault = new SLParser(params);
}


/***/ }),

/***/ "ONqV":
/*!*****************************************************!*\
  !*** ./src/sandbox/containers/ParserParameters.tsx ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf/bf */ "/Wjm");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers/parserParams */ "vHMa");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-monaco-editor */ "gL5p");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_monaco_editor__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










const setFlags = (dest, src, value) => {
    return value ? _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__["setFlags"](dest, src) : _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__["clearFlags"](dest, src);
};
class ParserParameters extends react__WEBPACK_IMPORTED_MODULE_6__["Component"] {
    UNSAFE_componentWillMount() {
        this.setState(this.props);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        this.setState(nextProps);
    }
    // tslint:disable-next-line:max-func-body-length
    render() {
        const { type, flags, grammar, parsingFlags } = this.state;
        return (react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"], null,
            react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"].Row, { columns: 2 },
                react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"].Column, { computer: "10", tablet: "8", mobile: "6" },
                    react__WEBPACK_IMPORTED_MODULE_6__["createElement"](react_monaco_editor__WEBPACK_IMPORTED_MODULE_7___default.a, { language: "powershell", theme: "vs", value: grammar || '', width: "100%", height: "calc(100vh - 41px)" // todo: fixme
                        , options: {
                            selectOnLineNumbers: true,
                            fontSize: 12,
                            lineNumbers: "on",
                            lineHeight: 14,
                            automaticLayout: true
                        }, onChange: grammar => this.setState({ grammar }) })),
                react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"].Column, { computer: "6", tablet: "8", mobile: "10" },
                    react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Segment"], { style: { marginTop: '1em', marginRight: '2em' } },
                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"], null,
                            react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"], { columns: 'equal', divided: true, padded: true },
                                react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"].Column, null,
                                    react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Group, { grouped: true },
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"]("label", null, "Parser type:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Radio, { label: 'LR0', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LR0], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LR0, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][value] }), disabled: true }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Radio, { label: 'LR1', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LR1], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LR1, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][value] }) }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Radio, { label: 'LALR', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LALR], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"].k_LALR, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserType"][value] }) }))),
                                react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Grid"].Column, null,
                                    react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Group, { grouped: true },
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"]("label", null, "Parser flags:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowAddMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowAddMode), label: 'Allow `--add` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowExposeMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowExposeMode), label: 'Allow `--expose` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowSkipMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowSkipMode), label: 'Allow `--skip` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_ForceAppendAll), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_ForceAppendAll), label: 'Force create all nodes' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_Debug), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_Debug), label: 'Debug mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"]("label", null, "Parsing flags:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(parsingFlags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["IASTDocumentFlags"].k_Optimize), onChange: this.handleParsingFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["IASTDocumentFlags"].k_Optimize), label: 'Created nodes if it has more than one child' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Checkbox, { checked: !!(parsingFlags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["IASTDocumentFlags"].k_DeveloperMode), onChange: this.handleParsingFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["IASTDocumentFlags"].k_DeveloperMode), label: 'Developer mode' })))),
                            react__WEBPACK_IMPORTED_MODULE_6__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["Form"].Button, { onClick: this.reinit }, "Reinit parser")))))));
    }
    reinit() {
        const { type, flags, grammar, parsingFlags } = this.state;
        this.props.actions.setParams(type, flags);
        this.props.actions.setGrammar(grammar);
        this.props.actions.setParsingParams(parsingFlags);
    }
    handleParserFlags(flag, event, { checked: value }) {
        let { flags } = this.state;
        switch (flag) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowAddMode:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowExposeMode:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowSkipMode:
                if (value) {
                    flags = _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__["clearFlags"](flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_ForceAppendAll);
                }
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_ForceAppendAll:
                if (value) {
                    flags = _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__["clearFlags"](flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowExposeMode |
                        _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowAddMode | _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__["EParserFlags"].k_AllowSkipMode);
                }
                break;
            default:
        }
        flags = setFlags(flags, flag, value);
        this.setState({ flags });
    }
    handleParsingFlags(flag, event, { checked: value }) {
        let { parsingFlags } = this.state;
        parsingFlags = setFlags(parsingFlags, flag, value);
        this.setState({ parsingFlags });
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "reinit", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "handleParserFlags", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "handleParsingFlags", null);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_8__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__["mapProps"])(_sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_4__["getParser"]), Object(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__["mapActions"])(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__["parser"]))(ParserParameters));


/***/ }),

/***/ "PKWX":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/instruction.ts ***!
  \****************************************************/
/*! exports provided: instruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instruction", function() { return instruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");

var instruction;
(function (instruction) {
    instruction.UNDEFINE_LENGTH = 0xffffff;
    instruction.UNDEFINE_SIZE = 0xffffff;
    instruction.UNDEFINE_PADDING = 0xffffff;
    instruction.UNDEFINE_NAME = "undef";
    function isExpression(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ConditionalExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ConstructorCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_AssignmentExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_InitExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IdExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FunctionCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixIndexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixPointExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ComplexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_CastExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_UnaryExpr:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isExpression = isExpression;
    function isStatement(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Stmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_DeclStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ReturnStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IfStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_StmtBlock:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ExprStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_WhileStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ForStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BreakStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SemicolonStmt:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isStatement = isStatement;
    function isLiteral(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_StringExpr:
                return true;
        }
        return false;
    }
    instruction.isLiteral = isLiteral;
})(instruction || (instruction = {}));


/***/ }),

/***/ "PLhK":
/*!**************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SamplerStateBlockInstruction.ts ***!
  \**************************************************************************/
/*! exports provided: SamplerStateBlockInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SamplerStateBlockInstruction", function() { return SamplerStateBlockInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/ITexture */ "gf1s");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "2b0+");






/**
  * Represetn sampler_state { states }
  */
class SamplerStateBlockInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__["ExprInstruction"] {
    constructor({ operator, params = [], ...settings }) {
        // todo: resolve type from texture type!
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SamplerStateBlockExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_SAMPLER"], ...settings });
        this._samplerParams = params.map(param => _Instruction__WEBPACK_IMPORTED_MODULE_5__["Instruction"].$withParent(param, this));
        this._operator = operator;
    }
    get texture() {
        let params = this._samplerParams;
        for (let i = 0; i < params.length; ++i) {
            if (params[i].name === "TEXTURE") {
                return params[i].value;
            }
        }
        return null;
    }
    get params() {
        return this._samplerParams;
    }
    get operator() {
        return this._operator;
    }
    isConst() {
        return true;
    }
    // todo: rewrite it!
    evaluate() {
        var samplerState = {
            textureName: "",
            wrap_s: 0,
            wrap_t: 0,
            mag_filter: 0,
            min_filter: 0
        };
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.texture)) {
            samplerState.textureName = this.texture.name;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._samplerParams)) {
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this._samplerParams["ADDRESSU"])) {
                samplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams["ADDRESSU"]);
            }
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this._samplerParams["ADDRESSV"])) {
                samplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams["ADDRESSV"]);
            }
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this._samplerParams["MAGFILTER"])) {
                samplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams["MAGFILTER"]);
            }
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this._samplerParams["MINFILTER"])) {
                samplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams["MINFILTER"]);
            }
        }
        this._evalResult = samplerState;
        return true;
    }
    // TODO: move it to helpers
    static convertWrapMode(sState) {
        switch (sState) {
            case "WRAP":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureWrapModes"].REPEAT;
            case "CLAMP":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureWrapModes"].CLAMP_TO_EDGE;
            case "MIRROR":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureWrapModes"].MIRRORED_REPEAT;
            default:
                return 0;
        }
    }
    // TODO: move it to helpers
    static convertFilters(sState) {
        switch (sState) {
            case "NEAREST":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].NEAREST;
            case "LINEAR":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].LINEAR;
            case "NEAREST_MIPMAP_NEAREST":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].NEAREST_MIPMAP_NEAREST;
            case "LINEAR_MIPMAP_NEAREST":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].LINEAR_MIPMAP_NEAREST;
            case "NEAREST_MIPMAP_LINEAR":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].NEAREST_MIPMAP_LINEAR;
            case "LINEAR_MIPMAP_LINEAR":
                return _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_3__["ETextureFilters"].LINEAR_MIPMAP_LINEAR;
            default:
                return 0;
        }
    }
}


/***/ }),

/***/ "QsPN":
/*!************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IntInstruction.ts ***!
  \************************************************************/
/*! exports provided: IntInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntInstruction", function() { return IntInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "hljw");




class IntInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, signed, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IntExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes 
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_3__["VariableTypeInstruction"].wrapAsConst(signed ? _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_INT"] : _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_UINT"], _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["SCOPE"]), scope, ...settings });
        this.value = value;
        this.signed = signed;
        if (!signed) {
            this.value >>>= 0;
        }
    }
    toString() {
        // return `${this.value}${this.signed? '' : 'u'}`;
        return `${this.value}`;
    }
    toCode() {
        return this.toString();
    }
    evaluate() {
        this._evalResult = this.value;
        return true;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "RTx6":
/*!*******************************************!*\
  !*** ./src/lib/fx/AnalyzerDiagnostics.ts ***!
  \*******************************************/
/*! exports provided: AnalyzerDiagnostics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnalyzerDiagnostics", function() { return AnalyzerDiagnostics; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "a1Km");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "zX2+");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");





class AnalyzerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__["Diagnostics"] {
    constructor() {
        super("Analyzer Diagnostics", 'A');
    }
    resolveFilename(code, desc) {
        return desc.file;
    }
    resolveRange(code, desc) {
        return desc.loc;
    }
    diagnosticMessages() {
        // TODO: fill all errors.
        // TODO: add support for warnings
        return {
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \'*type*\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \'void\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].FunctionRedefinition]: 'Function redefinition. Function with name \'{info.funcName}\' already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \'{info.funcName}\' but another type already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidFunctionReturnStmtNotFound]: 'Return statement expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidVariableInitializing]: 'Invalid variable initializing.',
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__["EDiagnosticCategory"].k_Warning) {
            return `${_lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__["EAnalyzerWarnings"][code]}: ${JSON.stringify(data)}`;
        }
        return `${_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"][code]}: ${JSON.stringify(data)}`;
    }
}


/***/ }),

/***/ "RZSc":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts ***!
  \***********************************************************************/
/*! exports provided: SystemFunctionInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SystemFunctionInstruction", function() { return SystemFunctionInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FunctionDeclInstruction */ "BKBR");



class SystemFunctionInstruction extends _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__["FunctionDeclInstruction"] {
    constructor({ vertex = true, pixel = true, implementation = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_SystemFunctionDecl, implementation: null, ...settings });
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(implementation));
        this._bForVertex = vertex;
        this._bForPixel = pixel;
    }
    checkVertexUsage() {
        return this._bForVertex;
    }
    checkPixelUsage() {
        return this._bForPixel;
    }
    $makeVertexCompatible(val) {
        console.warn("@deprecated");
        this._bForVertex = val;
    }
    $makePixelCompatible(val) {
        console.warn("@deprecated");
        this._bForPixel = val;
    }
}


/***/ }),

/***/ "RvT5":
/*!************************************************!*\
  !*** ./src/lib/fx/bytecode/InstructionList.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "BW2l");


// todo: use more compact format than 4 x int32
class InstructionList {
    constructor() {
        this._data = new Uint32Array(8);
        this._length = 0;
    }
    get capacity() {
        return this._data.length;
    }
    get data() {
        return this._data.subarray(0, this._length);
    }
    get length() {
        return this._length;
    }
    get pc() {
        return this.length / InstructionList.STRIDE;
    }
    // convert bytes adresses to register numbers
    // validate number of arguments
    // premultiply jump counters with instructions stride
    static prepareInstruction(op, args) {
        // NOTE: keep order as it is done in the VM.ts
        switch (op) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32SetConst:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                args[0] >>= 2;
                // args[1] => constant itself
                // args[2] => hint about what type lies in the constant
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LoadRegister:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LoadRegistersPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32StoreRegisterPointer:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2; // byte offset => register offset
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LoadInput:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32StoreInput:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                // args[0] => input index    
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LoadInputPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32StoreInputPointer:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 4);
                // args[0] => input index
                args[1] >>= 2;
                args[2] >>= 2;
                args[3] >>= 2; // byte offset => register offset
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Not:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Mul:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Mul:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_U32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_U32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Equal:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32NotEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32GreaterThanEqual:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Mad:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 4);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                args[3] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LogicalOr:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32LogicalAnd:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Frac:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Floor:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Ceil:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Sin:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Cos:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Abs:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Sqrt:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32Max:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32Max:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32ToI32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_I32ToF32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_F32ToU32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_U32ToF32:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Jump:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length === 1);
                // multiply jump in order to facilitate the operation of the VM
                args[0] *= InstructionList.STRIDE;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_JumpIf:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length === 1);
                args[0] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Ret:
                // nothing todo
                break;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `unknown operation found: ${op} (${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"][op]})`);
        }
    }
    add(op, args) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length <= 4);
        this.check(InstructionList.STRIDE);
        InstructionList.prepareInstruction(op, args);
        this.push(op);
        args.forEach((v) => this.push(v));
        this._length += 4 - args.length;
    }
    /**
     * Replace specified instruction with new one;
     * @param pc number of instruction to be replaced
     * @param op new operation
     * @param args new arguments
     */
    replace(pc, op, args) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(pc < this.pc);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length <= 4);
        const pc5 = pc * InstructionList.STRIDE; // stride is 5
        // FIXME: remove this assert
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.data[pc5] === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Ret || this.data[pc5] === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Jump, `expected ${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Ret}/${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__["EOperation"].k_Jump}, but given is ${this.data[pc5]} for pc = ${pc}`);
        InstructionList.prepareInstruction(op, args);
        // replace op
        this.data[pc5] = op;
        // replace arguments
        args.forEach((v, i) => { this.data[pc5 + 1 + i] = v; });
    }
    push(val) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.capacity - this._length >= 1);
        this._data[this._length++] = val;
    }
    check(count) {
        let expected = this._length + count;
        if (expected <= this.capacity) {
            return;
        }
        var oldData = this._data;
        var newData = new Uint32Array(Math.max(expected, this.capacity * 2));
        newData.set(oldData);
        this._data = newData;
    }
}
InstructionList.STRIDE = 5;
/* harmony default export */ __webpack_exports__["default"] = (InstructionList);


/***/ }),

/***/ "SKCH":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/GlslEmitter.ts ***!
  \***********************************************/
/*! exports provided: GlslEmitter, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlslEmitter", function() { return GlslEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _CodeEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CodeEmitter */ "yAC2");



const GlslTypeNames = {
    'int': 'int',
    'float': 'float',
    'float2': 'vec2',
    'float3': 'vec3',
    'float4': 'vec4',
    'float4x4': 'mat4'
};
const sname = {
    attr: (decl) => decl.semantic ?
        `a_${decl.semantic.toLowerCase()}` :
        `a_${decl.name}_${decl.instructionID}`,
    varying: (decl) => decl.semantic ?
        `v_${decl.semantic.toLowerCase()}` :
        `v_${decl.name}_${decl.instructionID}`,
};
class GlslEmitter extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_2__["CodeEmitter"] {
    resolveTypeName(type) {
        const typeName = GlslTypeNames[type.name];
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(typeName)) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unknown built in type found');
            return null;
        }
        return typeName;
    }
    isVaryingOrAttributeAlias(pfxp) {
        if (this.isMain() && this.mode !== 'raw') {
            if (pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_IdExpr) {
                const id = pfxp.element;
                if (id.decl.isParameter() && !id.decl.type.isUniform()) {
                    return true;
                }
            }
        }
        return false;
    }
    emitSemantic(semantic) {
        // disabling of semantics emission.
    }
    emitPrologue(def) {
        this.begin();
        {
            this.emitLine(`precision highp float;`);
            this.emitLine(`precision highp int;`);
        }
        this.end();
        this.begin();
        {
            for (const param of def.params) {
                if (param.type.isUniform()) {
                    continue;
                }
                const type = param.type;
                this.emitComment(param.toCode());
                this.emitNewline();
                if (!type.isComplex()) {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type.isNotBaseArray());
                    this.emitVaryingOrAttribute(param);
                    continue;
                }
                type.fields.forEach(field => {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!field.type.isNotBaseArray() && !field.type.isComplex());
                    this.emitVaryingOrAttribute(field);
                });
            }
        }
        this.end();
        this.begin();
        {
            for (const param of def.params) {
                if (!param.type.isUniform()) {
                    continue;
                }
                this.emitVariableDecl(param);
            }
        }
        this.end();
        if (this.mode === 'vertex') {
            this.begin();
            {
                const retType = def.returnType;
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(retType.isComplex(), 'basic types unsupported yet');
                retType.fields.forEach(field => {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!field.type.isNotBaseArray() && !field.type.isComplex());
                    this.emitVarying(field);
                });
            }
            this.end();
        }
    }
    emitAttribute(decl) {
        return (this.emitKeyword('attribute'), this.emitVariableDecl(decl, sname.attr), this.emitChar(';'), this.emitNewline());
    }
    emitVarying(decl) {
        return (this.emitKeyword('varying'), this.emitVariableDecl(decl, sname.varying), this.emitChar(';'), this.emitNewline());
    }
    emitVaryingOrAttribute(decl) {
        switch (this.mode) {
            case 'vertex':
                return this.emitAttribute(decl);
            case 'pixel':
                return this.emitVarying(decl);
        }
    }
    emitFloat(lit) {
        const sval = String(lit.value);
        this.emitKeyword(sval);
        (sval.indexOf('.') === -1) && this.emitChar('.0');
    }
    emitPostfixPoint(pfxp) {
        if (this.isVaryingOrAttributeAlias(pfxp)) {
            this.emitKeyword(this.mode === 'vertex' ? sname.attr(pfxp.postfix.decl) : sname.varying(pfxp.postfix.decl));
            return;
        }
        super.emitPostfixPoint(pfxp);
    }
    emitIdentifier(id) {
        super.emitIdentifier(id);
    }
    emitFCall(call) {
        const decl = call.decl;
        const args = call.args;
        switch (decl.name) {
            case 'mul':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length == 2);
                this.emitMulIntrinsic(args[0], args[1]);
                return;
        }
        super.emitFCall(call);
    }
    emitFunction(fn) {
        const def = fn.def;
        const retType = def.returnType;
        if (this.depth() === 0 && this.mode !== 'raw') {
            this.emitPrologue(fn.def);
            const { typeName } = this.resolveType(def.returnType);
            // emit original function witout parameters
            this.begin();
            {
                this.emitKeyword(typeName);
                this.emitKeyword(fn.name);
                this.emitChar('(');
                this.emitChar(')');
                this.emitNewline();
                this.emitBlock(fn.impl);
            }
            this.end();
            // emit main()
            this.begin();
            {
                this.emitChar('void main(void)');
                this.emitNewline();
                this.emitChar('{');
                this.push();
                {
                    const tempName = 'temp';
                    this.emitKeyword(typeName);
                    this.emitKeyword(tempName);
                    this.emitKeyword('=');
                    this.emitKeyword(fn.name);
                    this.emitChar('()');
                    this.emitChar(';');
                    this.emitNewline();
                    if (this.mode === 'vertex') {
                        retType.fields.forEach(field => {
                            const varyingName = sname.varying(field);
                            this.emitKeyword(varyingName);
                            this.emitKeyword('=');
                            this.emitKeyword(tempName);
                            this.emitChar('.');
                            this.emitChar(field.name);
                            this.emitChar(';');
                            this.emitNewline();
                        });
                        const fieldPos = retType.fields.filter(field => (field.semantic === 'POSITION'))[0];
                        this.emitKeyword('gl_Position');
                        this.emitKeyword('=');
                        this.emitKeyword(tempName);
                        this.emitChar('.');
                        this.emitChar(fieldPos.name);
                        this.emitChar(';');
                        this.emitNewline();
                    }
                    else { // pixel
                        this.emitKeyword('gl_FragColor');
                        this.emitKeyword('=');
                        this.emitKeyword(tempName);
                        this.emitChar(';');
                        this.emitNewline();
                    }
                }
                this.pop();
                this.emitChar('}');
            }
            this.end();
            return;
        }
        super.emitFunction(fn);
    }
    //
    // intrinsics
    //
    emitMulIntrinsic(left, right) {
        this.emitChar('(');
        this.emitExpression(left);
        this.emitKeyword('*');
        this.emitExpression(right);
        this.emitChar(')');
    }
    static $declToAttributeName(decl) {
        return sname.attr(decl);
    }
}
function translate(instr, options) {
    return (new GlslEmitter(options)).emit(instr).toString();
}


/***/ }),

/***/ "SMK2":
/*!****************************************!*\
  !*** ./src/sandbox/reducers/router.ts ***!
  \****************************************/
/*! exports provided: history, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "history", function() { return history; });
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! connected-react-router */ "u4tm");
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "LhCv");


const history = Object(history__WEBPACK_IMPORTED_MODULE_1__["createHashHistory"])();
/* harmony default export */ __webpack_exports__["default"] = (Object(connected_react_router__WEBPACK_IMPORTED_MODULE_0__["connectRouter"])(history));


/***/ }),

/***/ "SdNh":
/*!*************************************************!*\
  !*** ./src/sandbox/components/FileListView.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "Po9p");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var is_electron_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-electron-renderer */ "Ze1B");
/* harmony import */ var is_electron_renderer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(is_electron_renderer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "tpqs");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ "MCLT");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);
/* tslint:disable:typedef */







const FileDirectoryIcon = 'file directory';
const FileCodeIcon = 'file code';
const fs = {
    stat: is_electron_renderer__WEBPACK_IMPORTED_MODULE_2__ ?
        Object(util__WEBPACK_IMPORTED_MODULE_6__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_1__["lstat"]) :
        (dir) => ({
            isDirectory() { return false; },
            isFile() { return false; }
        }),
    readdir: is_electron_renderer__WEBPACK_IMPORTED_MODULE_2__ ?
        Object(util__WEBPACK_IMPORTED_MODULE_6__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_1__["readdir"]) : null
};
// todo: remove "sync" calls
async function scan($dir, node, filters) {
    if (!is_electron_renderer__WEBPACK_IMPORTED_MODULE_2__) {
        node.files = [
            'sphere.fx',
            'part.fx',
            'holographicTable.fx',
            'messy.fx',
            'speed.fx',
            'errorHandling.fx',
            'autotests.fx',
            'tail.fx',
            'tree.fx'
        ].map(file => `./assets/fx/tests/${file}`).sort();
        node.path = 'tests';
        node.totalFiles = 5;
        return;
    }
    try {
        node.path = $dir;
        const dir = path__WEBPACK_IMPORTED_MODULE_3__["join"](path__WEBPACK_IMPORTED_MODULE_3__["dirname"](window.location.pathname.substr(1)), $dir);
        let stats = await fs.stat(dir);
        if (!stats.isDirectory()) {
            return;
        }
        (await fs.readdir(dir)).forEach(async (filename) => {
            let $filepath = path__WEBPACK_IMPORTED_MODULE_3__["join"]($dir, filename);
            let filepath = path__WEBPACK_IMPORTED_MODULE_3__["join"](dir, filename);
            let filestats = await fs.stat(filepath);
            if (filestats.isFile()) {
                if (!filters || filters.indexOf(path__WEBPACK_IMPORTED_MODULE_3__["extname"](filename)) != -1) {
                    node.files = node.files || [];
                    node.files.push($filepath);
                    node.totalFiles++;
                }
            }
            if (filestats.isDirectory()) {
                node.folders = node.folders || [];
                let subfolder = { path: $filepath, totalFiles: 0 };
                scan($filepath, subfolder, filters);
                node.folders.push(subfolder);
                node.totalFiles += subfolder.totalFiles;
            }
        });
    }
    catch (e) {
        console.log(e);
    }
}
class FileListView extends react__WEBPACK_IMPORTED_MODULE_4__["Component"] {
    constructor(props) {
        super(props);
        this.state = { root: { path: null, shown: true, totalFiles: 0 } };
    }
    UNSAFE_componentWillUpdate(nextProps, nextState) {
        const { state } = this;
        if (state.root.path === nextProps.path) {
            return;
        }
        scan(nextProps.path, state.root, nextProps.filters);
    }
    renderFolder(folder) {
        if (!folder || !folder.path || !folder.totalFiles) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Item, { key: folder.path },
            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Icon, { name: FileDirectoryIcon }),
            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Header, { onClick: () => { folder.shown = !folder.shown; this.forceUpdate(); } }, path__WEBPACK_IMPORTED_MODULE_3__["basename"](folder.path)),
                folder.shown && (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isArray"])(folder.folders) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isArray"])(folder.files)) &&
                    react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].List, null,
                        (folder.folders || []).map(folder => this.renderFolder(folder)),
                        (folder.files || []).map(file => this.renderFile(file))))));
    }
    renderFile(file) {
        if (!file) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Item, { onClick: () => this.props.onFileClick(file), key: file },
            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Icon, { name: FileCodeIcon }),
            react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"].Header, null, path__WEBPACK_IMPORTED_MODULE_3__["basename"](file)))));
    }
    render() {
        // temp check in order to be compatible with browsers;
        // if (!isElectron) {
        //     return null;
        // }
        const { root } = this.state;
        return (react__WEBPACK_IMPORTED_MODULE_4__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["List"], { selection: true }, this.renderFolder(root)));
    }
}
/* harmony default export */ __webpack_exports__["default"] = (FileListView);


/***/ }),

/***/ "TYG3":
/*!*********************************!*\
  !*** ./src/lib/parser/Lexer.ts ***!
  \*********************************/
/*! exports provided: LexerEngine, Lexer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LexerEngine", function() { return LexerEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/StringRef */ "LZQc");
/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbols */ "YPfw");




var ELexerErrors;
(function (ELexerErrors) {
    ELexerErrors[ELexerErrors["UnknownToken"] = 2101] = "UnknownToken";
    ELexerErrors[ELexerErrors["InvalidToken"] = 2102] = "InvalidToken";
})(ELexerErrors || (ELexerErrors = {}));
;
class LexerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_1__["Diagnostics"] {
    constructor() {
        super("Lexer Diagnostics", 'L');
    }
    resolveFilename(code, desc) {
        return desc.file;
    }
    resolveRange(code, desc) {
        return desc.token.loc;
    }
    diagnosticMessages() {
        return {
            [ELexerErrors.UnknownToken]: "Unknown token: {token.value}.",
            [ELexerErrors.InvalidToken]: "Invalid token: {token.value}."
        };
    }
}
class LexerEngine {
    constructor() {
        this.keywords = {};
        this.punctuators = {};
        this.punctuatorsFirstSymbols = {};
    }
    addPunctuator(value, name = LexerEngine.getPunctuatorName(value)) {
        this.punctuators[value] = name;
        this.punctuatorsFirstSymbols[value[0]] = true;
        return name;
    }
    addKeyword(value, name) {
        this.keywords[value] = name;
        return name;
    }
    getTerminalValueByName(name) {
        let value = "";
        for (value in this.punctuators) {
            if (this.punctuators[value] === name) {
                return value;
            }
        }
        for (value in this.keywords) {
            if (this.keywords[value] === name) {
                return value;
            }
        }
        return name;
    }
    isLineTerminator(symbol) {
        return (symbol === "\n" || symbol === "\r" || symbol === "\u2028" || symbol === "\u2029");
    }
    isKeyword(value) {
        return !!(this.keywords[value]);
    }
    isPunctuator(value) {
        return !!(this.punctuators[value]);
    }
    isNumberStart(ch, ch1) {
        if ((ch >= "0") && (ch <= "9")) {
            return true;
        }
        if (ch === "." && (ch1 >= "0") && (ch1 <= "9")) {
            return true;
        }
        return false;
    }
    isCommentStart(ch, ch1) {
        if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
            return true;
        }
        return false;
    }
    isStringStart(ch) {
        if (ch === "\"" || ch === "'") {
            return true;
        }
        return false;
    }
    isPunctuatorStart(ch) {
        if (this.punctuatorsFirstSymbols[ch]) {
            return true;
        }
        return false;
    }
    isWhiteSpaceStart(ch) {
        if (ch === " " || ch === "\t") {
            return true;
        }
        return false;
    }
    isNewlineStart(ch) {
        if (ch === "\n" || ch === "\r") {
            return true;
        }
        return false;
    }
    isIdentifierStart(ch) {
        if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
            return true;
        }
        return false;
    }
    static getPunctuatorName(value) {
        return "T_PUNCTUATOR_" + value.charCodeAt(0);
    }
}
class Lexer {
    constructor({ engine = new LexerEngine, knownTypes = new Set(), skipComments = true }) {
        this.lineNumber = 0;
        this.columnNumber = 0;
        this.index = 0;
        this.diagnostics = new LexerDiagnostics;
        this.knownTypes = knownTypes;
        this.engine = engine;
        this.skipComments = skipComments;
    }
    setup(textDocument) {
        this.uri = _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_2__["StringRef"].make(textDocument.uri);
        this.source = textDocument.source;
    }
    getDiagnosticReport() {
        return this.diagnostics.resolve();
    }
    getNextToken(allowLineTerminators) {
        let ch = this.currentChar();
        if (!ch) {
            let pos = this.pos();
            return {
                index: this.index,
                name: _symbols__WEBPACK_IMPORTED_MODULE_3__["END_SYMBOL"],
                value: _symbols__WEBPACK_IMPORTED_MODULE_3__["END_SYMBOL"],
                loc: {
                    start: pos,
                    end: { ...pos }
                }
            };
        }
        let tokenType = this.identityTokenType();
        let token = null;
        switch (tokenType) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_NumericLiteral:
                token = this.scanNumber();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_SinglelineCommentLiteral:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_MultilineCommentLiteral:
                token = this.scanComment();
                if (this.skipComments) {
                    token = this.getNextToken();
                }
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_StringLiteral:
                token = this.scanString();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_PunctuatorLiteral:
                token = this.scanPunctuator();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_IdentifierLiteral:
                token = this.scanIdentifier();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_NewlineLiteral:
                token = this.scanLineTerminators();
                if (!allowLineTerminators) {
                    token = this.getNextToken();
                }
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_WhitespaceLiteral:
                this.scanWhiteSpace();
                token = this.getNextToken();
                break;
            default:
                {
                    // TODO: move this code to scanInvalid()
                    const start = this.pos();
                    let value = '';
                    while (this.identityTokenType() === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_Unknown && this.index < this.source.length) {
                        value += this.currentChar();
                        this.readNextChar();
                    }
                    token = {
                        index: this.index,
                        name: _symbols__WEBPACK_IMPORTED_MODULE_3__["UNKNOWN_TOKEN"],
                        value,
                        loc: { start, end: this.pos() }
                    };
                    // console.warn(value);
                    this.emitError(ELexerErrors.UnknownToken, token);
                    return token;
                }
        }
        return token;
    }
    /** @deprecated */
    getLocation() {
        return { line: this.lineNumber, file: this.uri };
    }
    /** @deprecated */
    setSource(sSource) {
        this.source = sSource;
    }
    /** @deprecated */
    setIndex(iIndex) {
        this.index = iIndex;
    }
    pos(n = 0) {
        return {
            file: this.uri,
            line: this.lineNumber,
            column: this.columnNumber + n,
            offset: this.index + n
        };
    }
    emitError(code, token) {
        this.diagnostics.error(code, { file: `${this.uri}`, token });
    }
    identityTokenType() {
        if (this.isIdentifierStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_IdentifierLiteral;
        }
        if (this.isWhiteSpaceStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_WhitespaceLiteral;
        }
        if (this.isNewlineStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_NewlineLiteral;
        }
        if (this.isStringStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_StringLiteral;
        }
        if (this.isCommentStart()) {
            // TODO: return exact type (separate multiline/singleline comment parsings)
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_SinglelineCommentLiteral;
        }
        if (this.isNumberStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_NumericLiteral;
        }
        if (this.isPunctuatorStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_PunctuatorLiteral;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_Unknown;
    }
    isNumberStart() {
        return this.engine.isNumberStart(this.currentChar(), this.nextChar());
    }
    isCommentStart() {
        return this.engine.isCommentStart(this.currentChar(), this.nextChar());
    }
    isStringStart() {
        return this.engine.isStringStart(this.currentChar());
    }
    isPunctuatorStart() {
        return this.engine.isPunctuatorStart(this.currentChar());
    }
    isWhiteSpaceStart() {
        return this.engine.isWhiteSpaceStart(this.currentChar());
    }
    isNewlineStart() {
        return this.engine.isNewlineStart(this.currentChar());
    }
    isIdentifierStart() {
        return this.engine.isIdentifierStart(this.currentChar());
    }
    nextChar() {
        return this.source[this.index + 1];
    }
    currentChar() {
        return this.source[this.index];
    }
    readNextChar() {
        this.index++;
        this.columnNumber++;
        return this.source[this.index];
    }
    scanString() {
        let chFirst = this.currentChar();
        let value = chFirst;
        let ch = "";
        let chPrevious = chFirst;
        let isGoodFinish = false;
        let start = this.pos();
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                break;
            }
            value += ch;
            if (ch === chFirst && chPrevious !== "\\") {
                isGoodFinish = true;
                this.readNextChar();
                break;
            }
            chPrevious = ch;
        }
        if (isGoodFinish) {
            return {
                index: this.index,
                name: _symbols__WEBPACK_IMPORTED_MODULE_3__["T_STRING"],
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _symbols__WEBPACK_IMPORTED_MODULE_3__["EOF"];
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_StringLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanPunctuator() {
        let value = this.currentChar();
        let start = this.pos();
        let ch;
        while (true) {
            ch = this.readNextChar();
            if (ch) {
                value += ch;
                if (!this.engine.isPunctuator(value)) {
                    value = value.slice(0, value.length - 1);
                    break;
                }
            }
            else {
                break;
            }
        }
        return {
            index: this.index,
            name: this.engine.punctuators[value],
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanNumber() {
        let ch = this.currentChar();
        let value = "";
        let isFloat = false;
        let chPrevious = ch;
        let isGoodFinish = false;
        let isE = false; // exponential
        let isU = false; // unsigned
        let start = this.pos();
        if (ch === ".") {
            value += 0;
            isFloat = true;
        }
        value += ch;
        while (true) {
            ch = this.readNextChar();
            if (ch === ".") {
                if (isFloat || isU) {
                    break;
                }
                else {
                    isFloat = true;
                }
            }
            else if (ch === "e") {
                if (isE || isU) {
                    break;
                }
                else {
                    isE = true;
                }
            }
            else if (ch === "u") {
                if (isE || isU) {
                    break;
                }
                else {
                    isU = true;
                }
            }
            else if (((ch === "+" || ch === "-") && chPrevious === "e")) {
                value += ch;
                chPrevious = ch;
                continue;
            }
            else if (ch === "f" && isFloat) {
                ch = this.readNextChar();
                if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                    break;
                }
                isGoodFinish = true;
                break;
            }
            else if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                break;
            }
            else if (!((ch >= "0") && (ch <= "9")) || !ch || isU) {
                if ((isE && chPrevious !== "+" && chPrevious !== "-" && chPrevious !== "e") || !isE) {
                    isGoodFinish = true;
                }
                break;
            }
            value += ch;
            chPrevious = ch;
        }
        if (isGoodFinish) {
            let name = isFloat ? _symbols__WEBPACK_IMPORTED_MODULE_3__["T_FLOAT"] : _symbols__WEBPACK_IMPORTED_MODULE_3__["T_UINT"];
            return {
                index: this.index,
                name,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _symbols__WEBPACK_IMPORTED_MODULE_3__["EOF"];
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_NumericLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanIdentifier() {
        let ch = this.currentChar();
        let value = ch;
        let start = this.pos();
        let isGoodFinish = false;
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                isGoodFinish = true;
                break;
            }
            if (!((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || (ch >= "0" && ch <= "9"))) {
                isGoodFinish = true;
                break;
            }
            value += ch;
        }
        if (isGoodFinish) {
            if (this.engine.isKeyword(value)) {
                return {
                    index: this.index,
                    name: this.engine.keywords[value],
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                let name = this.knownTypes.has(value) ? _symbols__WEBPACK_IMPORTED_MODULE_3__["T_TYPE_ID"] : _symbols__WEBPACK_IMPORTED_MODULE_3__["T_NON_TYPE_ID"];
                return {
                    index: this.index,
                    name,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
        }
        else {
            if (!ch) {
                ch = _symbols__WEBPACK_IMPORTED_MODULE_3__["EOF"];
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_IdentifierLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanLineTerminators() {
        let ch = this.currentChar();
        let value = '';
        let start = this.pos();
        while (true) {
            if (!ch) {
                break;
            }
            if (this.engine.isLineTerminator(ch)) {
                value += ch;
                if (ch === "\r" && this.nextChar() === "\n") {
                    this.lineNumber--;
                }
                this.lineNumber++;
                ch = this.readNextChar();
                this.columnNumber = 0;
                continue;
            }
            break;
        }
        let name = _symbols__WEBPACK_IMPORTED_MODULE_3__["T_LINE_TERMINATOR"];
        return {
            index: this.index,
            name,
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanWhiteSpace() {
        let ch = this.currentChar();
        while (true) {
            if (!ch) {
                break;
            }
            else if (ch === "\t") {
                // possible way to convert tab to multiple spaces
                this.columnNumber += 0;
            }
            else if (ch !== " ") {
                break;
            }
            ch = this.readNextChar();
        }
        return true;
    }
    scanComment() {
        let value = this.currentChar();
        let ch = this.readNextChar();
        let start = this.pos();
        value += ch;
        if (ch === "/") {
            //Line Comment
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.readNextChar();
                    this.columnNumber = 0;
                    break;
                }
                value += ch;
            }
            return {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_SinglelineCommentLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            //Multiline Comment
            let chPrevious = ch;
            let isGoodFinish = false;
            let start = this.pos();
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                value += ch;
                if (ch === "/" && chPrevious === "*") {
                    isGoodFinish = true;
                    this.readNextChar();
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.columnNumber = -1;
                }
                chPrevious = ch;
            }
            if (isGoodFinish) {
                return {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                if (!ch) {
                    ch = _symbols__WEBPACK_IMPORTED_MODULE_3__["EOF"];
                }
                value += ch;
                const token = {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["ETokenType"].k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
                this.emitError(ELexerErrors.InvalidToken, token);
                return Lexer.makeUnknownToken(token);
            }
        }
    }
    static makeUnknownToken(token) {
        return {
            ...token,
            type: undefined,
            name: _symbols__WEBPACK_IMPORTED_MODULE_3__["UNKNOWN_TOKEN"],
            loc: {
                start: { ...token.loc.start },
                end: { ...token.loc.end }
            }
        };
    }
}


/***/ }),

/***/ "TyAm":
/*!**************************************************!*\
  !*** ./src/sandbox/containers/editor/Editor.tsx ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/DebugLayout */ "UMcR");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/DistinctColor */ "Mu1Z");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/parserParams */ "vHMa");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! comlink */ "PRU4");
/* harmony import */ var monaco_editor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! monaco-editor */ "wsa1");
/* harmony import */ var monaco_editor__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(monaco_editor__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! monaco-languageclient/lib/monaco-converter */ "kjvz");
/* harmony import */ var monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-jss */ "p8yR");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(react_jss__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-monaco-editor */ "gL5p");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(react_monaco_editor__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vscode-languageserver-types */ "kmEW");
/* harmony import */ var worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! worker-loader!./LanguageServiceProvider */ "9fu3");
/* harmony import */ var worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _styles_jss__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./styles.jss */ "moWP");
/* tslint:disable:no-for-in */
/* tslint:disable:forin */
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SourceEditor_1;
















// tslint:disable-next-line:no-submodule-imports


const m2p = new monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_10__["MonacoToProtocolConverter"]();
const p2m = new monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_10__["ProtocolToMonacoConverter"]();
const provider = comlink__WEBPACK_IMPORTED_MODULE_8__["wrap"](new worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_16___default.a());
function defer() {
    const deferred = {
        promise: null,
        resolve: null,
        reject: null
    };
    // tslint:disable-next-line:promise-must-complete
    deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
const LANGUAGE_ID = 'hlsl';
async function loadLanguage(def) {
    const mod = await def.loader();
    monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].setMonarchTokensProvider(def.id, mod.language);
    monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].setLanguageConfiguration(def.id, mod.conf);
}
function registerLanguage(def) {
    monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].register(def);
    monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].onLanguage(def.id, () => { loadLanguage(def); });
}
// register the HLSL language with Monaco
registerLanguage({
    id: LANGUAGE_ID,
    extensions: ['.fx', '.vsh', '.psh', '.hsh', '.dsh', '.csh'],
    aliases: ['HLSL', 'hlsl', 'openhlsl'],
    mimetypes: ['application/hlsl'],
    loader: () => __webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./hlsl */ "Tnde"))
});
const options = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: true,
    theme: 'vs-dark',
    language: LANGUAGE_ID,
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: true,
    fontLigatures: true
};
let SourceEditor = SourceEditor_1 = class SourceEditor extends react__WEBPACK_IMPORTED_MODULE_11__["Component"] {
    constructor() {
        super(...arguments);
        this.codeLensProvider = null;
        this.hoverProvider = null;
        this.completionProvider = null;
        this.documentSymbolProvider = null;
        this.signatureHelpProvider = null;
        this.mouseDownEvent = null;
        // cache for previously set decorations/breakpoints
        this.decorations = [];
        this.pendingValidationRequests = new Map();
        this.deferredRequests = [];
        // cache for params
        this.parserParamsCache = {};
    }
    setupDecorations() {
        const { props } = this;
        const { classes } = props;
        const decorations = [];
        const cls = {
            error: classes.errorMarker,
            warning: classes.warningMarker
        };
        const file = this.getFile();
        for (const key in file.markers) {
            const { range, type, tooltip, range: { start, end }, payload } = file.markers[key];
            if (!tooltip && type === 'marker') {
                decorations.push({
                    range: new monaco_editor__WEBPACK_IMPORTED_MODULE_9__["Range"](start.line + 1, start.column + 1, end.line + 1, end.column + 1),
                    options: { inlineClassName: classes.yellowMarker }
                });
            }
            else {
                switch (type) {
                    case 'error':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_9__["Range"](start.line + 1, start.column + 1, end.line + 1, end.column + 1),
                            options: { className: cls[type], hoverMessage: { value: tooltip } },
                        });
                        break;
                    case 'line':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_9__["Range"](start.line + 1, 0, start.line + 1, 0),
                            options: {
                                isWholeLine: true,
                                className: classes[`dc_${_lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_2__["default"].resolveColor(payload['color'])}`]
                            }
                        });
                        break;
                    default:
                }
            }
        }
        // fixme: clumsy code :/
        for (const key in file.breakpoints) {
            const lineNumber = file.breakpoints[key] + 1;
            decorations.push({
                range: new monaco_editor__WEBPACK_IMPORTED_MODULE_9__["Range"](lineNumber, 1, lineNumber, 1),
                options: { glyphMarginClassName: classes.breakpoint },
            });
        }
        return decorations;
    }
    // handle content's update from outside of the editor
    UNSAFE_componentWillUpdate(nextProps) {
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getFileState"])(nextProps);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(file.content)) {
            return;
        }
        if (file.content !== this.getContent()) {
            this.validate(file.content, file.uri);
            this.getEditor().setValue(file.content);
            console.log('%c force reload content from outside', 'background: #ffd1c9; color: #ff3714');
        }
    }
    componentDidUpdate() {
        this.updateDecorations();
        // TEMP: temp solution for parser param sync
        const parserStateNext = Object(_sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_5__["getParser"])(this.props);
        this.validateParser(parserStateNext);
    }
    componentDidMount() {
        // TEMP: temp solution for parser param sync
        const parserStateNext = Object(_sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_5__["getParser"])(this.props);
        this.validateParser(parserStateNext);
    }
    validateParser(parserStateNext) {
        const parserProps = ['flags', 'type', 'grammar', 'parsingFlags'];
        const paramsChanges = !parserProps.every(propName => this.parserParamsCache[propName] === parserStateNext[propName]);
        if (paramsChanges) {
            parserProps.forEach(propName => this.parserParamsCache[propName] = parserStateNext[propName]);
            const { grammar, flags, type, parsingFlags } = parserStateNext;
            if (grammar) {
                provider.init({ grammar, flags, type }, parsingFlags);
            }
        }
    }
    editorWillMount(editor) { }
    pendingValidations() {
        const def = defer();
        if (this.pendingValidationRequests.size > 0) {
            this.deferredRequests.push(def);
            return def.promise;
        }
        def.resolve();
        return def.promise;
    }
    // tslint:disable-next-line:max-func-body-length
    editorDidMount(editor) {
        editor.getModel()
            .updateOptions({ tabSize: 4 });
        //
        // naive breakpoints implementation
        //
        this.mouseDownEvent = editor.onMouseDown((e) => {
            if (e.target.type !== monaco_editor__WEBPACK_IMPORTED_MODULE_9__["editor"].MouseTargetType.GUTTER_GLYPH_MARGIN) {
                return;
            }
            const file = this.getFile();
            const { props } = this;
            const { breakpoints } = file;
            let { lineNumber } = e.target.position;
            lineNumber = Object(_lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_1__["cdlview"])(file.debugger.runtime.cdl)
                .resolveBreakpointLocation(lineNumber - 1);
            if (lineNumber === -1) {
                return;
            }
            if (breakpoints.indexOf(lineNumber) === -1) {
                props.actions.addBreakpoint(lineNumber);
            }
            else {
                props.actions.removeBreakpoint(lineNumber);
            }
        });
        const self = this;
        this.codeLensProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].registerCodeLensProvider(LANGUAGE_ID, {
            async provideCodeLenses(model, token) {
                // validation should always be done before any other requests
                await self.pendingValidations();
                const lenses = p2m.asCodeLenses(await provider.provideFxCodeLenses(self.asTextDocumentIdentifier()));
                return { lenses, dispose() { } };
            }
        });
        this.completionProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].registerCompletionItemProvider(LANGUAGE_ID, {
            triggerCharacters: ['(', ',', '=', '+'],
            provideCompletionItems(model, position, context, token) {
                // const document = self.createDocument(model);
                const wordUntil = model.getWordUntilPosition(position);
                const defaultRange = new monaco_editor__WEBPACK_IMPORTED_MODULE_9__["Range"](position.lineNumber, wordUntil.startColumn, position.lineNumber, wordUntil.endColumn);
                // return jsonService.doComplete(document,
                // m2p.asPosition(position.lineNumber, position.column), jsonDocument).then((list) => {
                //     return p2m.asCompletionResult(list, defaultRange);
                // });
                console.log('provideCompletionItems', defaultRange, wordUntil);
                return null;
            },
            resolveCompletionItem(model, position, item, token) {
                // return jsonService.doResolve(m2p.asCompletionItem(item)).then(result => p2m.asCompletionItem(result, item.range));
                console.log('resolveCompletionItem', m2p.asCompletionItem(item));
                return null;
            }
        });
        // TODO: do not pass whole document
        this.signatureHelpProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_9__["languages"].registerSignatureHelpProvider(LANGUAGE_ID, {
            signatureHelpTriggerCharacters: ['('],
            signatureHelpRetriggerCharacters: [','],
            async provideSignatureHelp(model, position, token, context) {
                // validation should always be done before any other requests
                await self.pendingValidations();
                const signatureHelp = await provider.provideSignatureHelp(self.asTextDocumentIdentifier(), m2p.asPosition(position.lineNumber, position.column));
                return signatureHelp && { value: p2m.asSignatureHelp(signatureHelp), dispose() { } };
            }
        });
        // this.documentSymbolProvider = monaco.languages.registerDocumentSymbolProvider(
        //     LANGUAGE_ID, 
        //     {
        //     provideDocumentSymbols(model, token): monaco.languages.DocumentSymbol[] | monaco.Thenable<monaco.languages.DocumentSymbol[]> {
        //         const document = self.createDocument(model);
        //         // const jsonDocument = jsonService.parseJSONDocument(document);
        //         // return p2m.asSymbolInformations(jsonService.findDocumentSymbols(document, jsonDocument));
        //         // return p2m.asSymbolInformations();
        //     }
        // });
        // // const self = this;
        // this.hoverProvider = monaco.languages.registerHoverProvider(
        //     LANGUAGE_ID,
        //     {
        //         provideHover(model, position, token): monaco.languages.Hover | monaco.Thenable<monaco.languages.Hover> {
        //             // const document = self.createDocument(model);
        //             // const jsonDocument = jsonService.parseJSONDocument(document);
        //             // console.log(model, position, token);
        //             return null;
        //         }
        //     });
    }
    asTextDocumentIdentifier() {
        return {
            uri: this.getFile().uri
        };
    }
    cleanPendingValidation(document) {
        const request = this.pendingValidationRequests.get(document.uri);
        if (request !== undefined) {
            clearTimeout(request);
            this.pendingValidationRequests.delete(document.uri);
        }
    }
    validate(newContent, newUri) {
        const document = this.createDocument(this.getModel(), newContent, newUri);
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(document.uri)) {
            return;
        }
        this.cleanPendingValidation(document);
        this.pendingValidationRequests.set(document.uri, setTimeout(async () => {
            await this.doValidate(document);
            this.pendingValidationRequests.delete(document.uri);
        }));
    }
    // tslint:disable-next-line:member-ordering
    static asMarker(diag) {
        const { code, message, range: { start, end }, severity } = diag;
        const severities = {
            [vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_15__["DiagnosticSeverity"].Error]: monaco_editor__WEBPACK_IMPORTED_MODULE_9__["MarkerSeverity"].Error,
            [vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_15__["DiagnosticSeverity"].Warning]: monaco_editor__WEBPACK_IMPORTED_MODULE_9__["MarkerSeverity"].Warning
        };
        return {
            severity: severities[severity],
            code: code,
            message,
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    async doValidate(document) {
        if (document.getText().length === 0) {
            this.cleanDiagnostics();
            return;
        }
        // const messages = await LanguageService.validate(document);
        const diagnostics = await provider.validate(document);
        monaco_editor__WEBPACK_IMPORTED_MODULE_9__["editor"].setModelMarkers(this.getModel(), 'default', diagnostics.map(diag => SourceEditor_1.asMarker(diag)));
        this.deferredRequests.forEach(def => def.resolve());
        this.deferredRequests = [];
    }
    cleanDiagnostics() {
        monaco_editor__WEBPACK_IMPORTED_MODULE_9__["editor"].setModelMarkers(this.getModel(), 'default', []);
    }
    async onChange(content, e) {
        this.validate(content);
        this.props.actions.setContent(content);
    }
    getEditor() {
        // don't know better way :/
        return this.refs.monaco.editor;
    }
    getModel() {
        // tslint:disable-next-line:newline-per-chained-call
        return this.getEditor().getModel();
    }
    getContent() {
        // tslint:disable-next-line:newline-per-chained-call
        return this.getModel().getValue();
    }
    createDocument(model, newContent, newUri) {
        return vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_15__["TextDocument"].create(newUri || this.getFile().uri, model.getModeId(), model.getVersionId(), newContent || model.getValue());
    }
    updateDecorations() {
        this.decorations = this.getEditor().deltaDecorations(this.decorations, this.setupDecorations());
        return this.decorations;
    }
    shouldComponentUpdate(nextProps) {
        const src = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getFileState"])(this.props);
        const dst = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getFileState"])(nextProps);
        return this.getContent() !== dst.content ||
            !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["deepEqual"])(src.markers, dst.markers) ||
            !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["deepEqual"])(src.breakpoints, dst.breakpoints);
    }
    componentWillUnmount() {
        if (this.codeLensProvider) {
            this.codeLensProvider.dispose();
        }
        if (this.hoverProvider) {
            this.hoverProvider.dispose();
        }
    }
    // componentWillMount() {
    //     const file = this.getFile();
    //     const uri = monaco.Uri.parse(`inmemory://${file.filename}`);
    //     this.model = monaco.editor.createModel(file.content, LANGUAGE_ID, uri);
    // }
    render() {
        const file = this.getFile();
        // const uri = monaco.Uri.parse(`inmemory://${file.filename}`);
        const content = file.content;
        return (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_monaco_editor__WEBPACK_IMPORTED_MODULE_13___default.a, { ref: 'monaco', value: content, width: '100%', height: 'calc(100vh - 67px)' // todo: fixme
            , options: options, onChange: this.onChange, editorDidMount: this.editorDidMount, editorWillMount: this.editorWillMount }));
    }
    getFile() {
        return Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getFileState"])(this.props);
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "editorWillMount", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "editorDidMount", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "onChange", null);
SourceEditor = SourceEditor_1 = __decorate([
    react_jss__WEBPACK_IMPORTED_MODULE_12___default()(_styles_jss__WEBPACK_IMPORTED_MODULE_17__["default"])
], SourceEditor);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_14__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__["mapProps"])(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__["getCommon"]), Object(_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__["mapActions"])(_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__["sourceCode"]))(SourceEditor));


/***/ }),

/***/ "U+xq":
/*!*****************************!*\
  !*** ./src/lib/bf/index.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bf */ "/Wjm");

/* harmony default export */ __webpack_exports__["default"] = (_bf__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "UMcR":
/*!********************************************!*\
  !*** ./src/lib/fx/bytecode/DebugLayout.ts ***!
  \********************************************/
/*! exports provided: DebugLineRecord, debug, cdlview, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DebugLineRecord", function() { return DebugLineRecord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cdlview", function() { return cdlview; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/util/DistinctColor */ "Mu1Z");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ "MCLT");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);



var EDebugLineFlags;
(function (EDebugLineFlags) {
    EDebugLineFlags[EDebugLineFlags["k_NewStatement"] = 1] = "k_NewStatement";
})(EDebugLineFlags || (EDebugLineFlags = {}));
;
class DebugLineRecord {
}
function debugLine(pc) {
    const files = [];
    const layout = [];
    const lastRecord = () => layout[layout.length - 1] || null;
    // mark last record as 'new statement';
    function ns() {
        let rec = lastRecord();
        // TOOD: allow breakpoints in case of no instructions have already beed added
        if (rec) {
            rec.flags |= EDebugLineFlags.k_NewStatement;
        }
    }
    // add last instruction to record table;
    function step() {
        layout.push({ pc: pc(), flags: 0 });
    }
    // add filename to source files table and return index;
    function fileToIndex(file) {
        let idx = files.indexOf(file);
        if (idx == -1) {
            idx = files.length;
            files.push(file);
        }
        return idx;
    }
    function map(inst) {
        const loc = (inst && inst.sourceNode && inst.sourceNode.loc) || null;
        if (Object(util__WEBPACK_IMPORTED_MODULE_2__["isNull"])(loc)) {
            return;
        }
        const pos = loc.start;
        const rec = lastRecord();
        rec.line = pos.line || 0;
        rec.column = pos.column || 0;
        rec.file = fileToIndex(`${pos.file}`);
    }
    function dump() {
        let line = undefined;
        let color = new _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_1__["default"];
        let cache = {};
        for (let i = layout.length - 1; i >= 0; i--) {
            let entry = layout[i];
            if (line != entry.line)
                color.pickNext();
            line = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(entry.line) ? entry.line : line;
            entry.line = line;
            cache[line] = Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(cache[line]) ? cache[line] : color.value();
            entry.color = cache[line];
        }
        return { files, layout };
    }
    return {
        ns,
        step,
        map,
        dump
    };
}
var ETagType;
(function (ETagType) {
    ETagType[ETagType["k_CompilationUnit"] = 0] = "k_CompilationUnit";
    ETagType[ETagType["k_SubProgram"] = 1] = "k_SubProgram";
})(ETagType || (ETagType = {}));
function debugInfo(pc) {
    let unitLayout;
    function locate(decl, reg) {
    }
    function beginCompilationUnit(name = null, layout) {
        unitLayout = layout;
    }
    function endCompilationUnit() { }
    ;
    function beginSubProgram(func) { }
    function endSubProgram() { }
    function dump() {
        return {
            layout: unitLayout
        };
    }
    return {
        beginCompilationUnit,
        endCompilationUnit,
        beginSubProgram,
        endSubProgram,
        locate,
        dump
    };
}
function debug(pc) {
    const line = debugLine(pc);
    const info = debugInfo(pc);
    function dump() {
        return {
            line: line.dump(),
            info: info.dump()
        };
    }
    // const { ns } = line;
    // const { beginCompilationUnit, endCompilationUnit, beginSubProgram, endSubProgram } = info;
    return { ...line, ...info, dump }; // todo: export only required;
}
/**
 * Code Debug Layout View.
 */
function cdlview(cdlRaw) {
    if (Object(util__WEBPACK_IMPORTED_MODULE_2__["isNull"])(cdlRaw)) {
        return null;
    }
    const { line, info } = cdlRaw;
    /**
     * @param pc Number of instruction.
     */
    function resolveFileLocation(pc) {
        let rec = line.layout[pc];
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(rec.pc == pc);
        return {
            file: Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(rec.file) ? line.files[rec.file] : null,
            line: rec.line,
            column: rec.column
        };
    }
    /**
     * @returns Valid breakpoint position from arbitrary line.
     */
    function resolveBreakpointLocation(ln) {
        // todo: optimize it;
        let rec = line.layout.find(r => r.line >= ln && (r.flags & EDebugLineFlags.k_NewStatement) != 0);
        return (rec && rec.line) || -1;
    }
    function resolvePcColor(pc) {
        return line.layout[pc] ? line.layout[pc].color : 0xffffff;
    }
    function resolveLineColor(ln, file) {
        let rec = line.layout.find(r => r.line === ln && r.file === line.files.indexOf(file));
        return rec ? rec.color : -1;
    }
    return {
        resolveFileLocation,
        resolveBreakpointLocation,
        resolvePcColor,
        resolveLineColor
    };
}
/* harmony default export */ __webpack_exports__["default"] = (debug);


/***/ }),

/***/ "UneR":
/*!***********************************************!*\
  !*** ./src/sandbox/components/MemoryView.tsx ***!
  \***********************************************/
/*! exports provided: styles, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styles", function() { return styles; });
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "oof7");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "2oKZ");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-jss */ "p8yR");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jss__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





const styles = {
    memoryVal: {
        display: `inline-block`,
        textAlign: `center`,
        zoom: 1
    }
};
let MemoryView = class MemoryView extends react__WEBPACK_IMPORTED_MODULE_2__["Component"] {
    render() {
        if (!this.props.program) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"], { unstackable: true, fixed: true, style: { fontFamily: 'consolas', border: '0' } },
            react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"].Body, null, this.renderContent())));
    }
    renderContent() {
        const { props } = this;
        const bundle = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__["load"](props.program.code);
        const binaryData = bundle.input[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__["CBUFFER0_REGISTER"]];
        const layout = bundle.layout;
        const WIDTH_MAX = 12;
        const u8view = new Uint8Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        // const f32view = new Float32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        // const i32view = new Int32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        let n = 0;
        let rows = [];
        let columns = [];
        let colLen = 0;
        let bLeftClosed;
        let bRightClosed;
        layout.map((constant, i) => {
            let written = 0;
            bLeftClosed = columns.length === 0;
            do {
                const segWidth = Math.min(constant.size - written, WIDTH_MAX - colLen);
                const n4 = n >> 2;
                const content = [];
                for (let i = 0; i < segWidth; ++i) {
                    content.push(react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("div", { key: `mvk-d-${n}`, className: `${props.classes.memoryVal}`, style: { width: `${100 / segWidth}%` } }, `${u8view[n] < 16 ? '0' : ''}${u8view[n++].toString(16).toUpperCase()}`));
                    written++;
                }
                bRightClosed = written >= constant.size;
                const style = {
                    padding: 0,
                    borderLeft: `1px solid ${bLeftClosed ? '#ccc' : 'transparent'}`,
                    borderRight: `1px solid ${bRightClosed ? '#ccc' : 'transparent'}`,
                    borderTop: `${rows.length === 0 ? 1 : 0}px solid #ccc`,
                    borderBottom: `1px solid #ccc`,
                };
                columns.push(react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"].Cell, { key: `mvk-tc-${colLen}`, textAlign: "center", colSpan: segWidth, style: style },
                    react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Popup"], { inverted: true, content: react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("div", { style: { fontFamily: 'consolas' } }, constant.name), trigger: react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("span", { style: { opacity: 0.5 } }, content) })));
                colLen += segWidth;
                bLeftClosed = false;
                if (n % WIDTH_MAX === 0) {
                    rows.push(react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"].Row, { key: `mvk-tc-${rows.length}` }, columns));
                    columns = [];
                    colLen = 0;
                }
            } while (written < constant.size);
        });
        if (columns.length > 0) {
            const csRest = WIDTH_MAX - n % WIDTH_MAX;
            if (csRest !== WIDTH_MAX) {
                columns.push(react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"].Cell, { key: `mvk-tc-${colLen}`, textAlign: "center", colSpan: csRest, style: { padding: 0 } }));
            }
            rows.push(react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Table"].Row, { key: `mvk-tc-${rows.length}` }, columns));
        }
        return rows;
    }
};
MemoryView = __decorate([
    react_jss__WEBPACK_IMPORTED_MODULE_3___default()(styles)
], MemoryView);
/* harmony default export */ __webpack_exports__["default"] = (MemoryView);


/***/ }),

/***/ "UsCK":
/*!*************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/variable.ts ***!
  \*************************************************/
/*! exports provided: variable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return variable; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type */ "79MH");



var variable;
(function (variable) {
    /**
 * @param decl Variable declaraion (decl.isParameter() must be true).
 * @returns Serial number of the declaration among the function parameters or -1 otherwise.
 */
    function parameterIndex(decl) {
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return -1;
        }
        // all parameters must be a children on function definition!
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(decl.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_FunctionDef);
        return decl.parent.params.indexOf(decl);
    }
    variable.parameterIndex = parameterIndex;
    /**
     * @returns Offset in bytes from the beginning of the parameters' list.
     */
    function parameterOffset(decl) {
        // todo: add support for 'inout', 'out' usages 
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return 0;
        }
        let idx = parameterIndex(decl);
        let offset = 0;
        for (let i = 0; i < idx; ++i) {
            offset += decl.parent.params[i].type.size;
        }
        return offset;
    }
    variable.parameterOffset = parameterOffset;
    /**
 * Helper:
 *  Returns 'structName.fieldName' for structs;
 *  Returns 'varName' for variables;
 */
    function fullName(decl) {
        if (decl.isField() &&
            _type__WEBPACK_IMPORTED_MODULE_2__["type"].findParentVariableDecl(decl.parent)) {
            let name = '';
            let parentType = decl.parent.instructionType;
            if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_VariableType) {
                name = _type__WEBPACK_IMPORTED_MODULE_2__["type"].resolveVariableDeclFullName(decl.parent);
            }
            name += '.' + decl.name;
            return name;
        }
        return decl.name;
    }
    variable.fullName = fullName;
    ;
    function resolveRegister(decl) {
        let type = null;
        let index = -1;
        const semantic = decl.semantic;
        if (semantic) {
            const match = semantic.match(/^register\(([utbs]{1})([\d]+)\)$/);
            if (match) {
                type = match[1];
                index = Number(match[2]);
            }
        }
        if (decl.type.isUAV()) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type === null || type === 'u');
            type = 'u';
        }
        if (decl.type.isTexture()) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type === null || type === 't');
            type = 't';
        }
        if (decl.type.isSampler()) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type === null || type === 's');
            type = 's';
        }
        // TODO: buffers
        return { type, index };
    }
    variable.resolveRegister = resolveRegister;
})(variable || (variable = {}));


/***/ }),

/***/ "Vh/Z":
/*!*********************************************************!*\
  !*** ./src/sandbox/containers/ShaderTranslatorView.tsx ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "yAC2");
/* harmony import */ var _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/translators/FxEmitter */ "eck8");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "DSeY");
/* harmony import */ var _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/translators/GlslEmitter */ "SKCH");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-monaco-editor */ "gL5p");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_monaco_editor__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-router */ "Ty5D");
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





// import { getCommon, mapProps, matchLocation } from '@lib/idl/parser/IParser';







// function cutSourceRange(content: string, range: IRange): string {
//     const { start, end } = range;
//     // console.log(range);
//     const lines = content.split('\n').slice(start.line, end.line + 1);
//     lines[0] = lines[0].substr(start.column);
//     lines[lines.length - 1] = lines[lines.length - 1].substr(0, end.column);
//     return lines.join('\n');
// }
const diffOptions = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: false,
    theme: 'vs-dark',
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: false,
    fontLigatures: true,
    // diff specific options
    occurrencesHighlight: false,
    renderLineHighlight: 'none',
    renderIndentGuides: false,
    readOnly: true,
    renderControlCharacters: false,
    ignoreTrimWhitespace: true
};
let ShaderTranslatorView = class ShaderTranslatorView extends react__WEBPACK_IMPORTED_MODULE_8__["Component"] {
    editorDidMount(editor) {
        const { modified, original } = editor.getModel();
        modified.updateOptions({ tabSize: 4 });
        original.updateOptions({ tabSize: 4 });
    }
    // shouldComponentUpdate(nextProps: IShaderTranslatorViewProps) {
    //     return getFileState(this.props).content !== getFileState(nextProps).content;
    // }
    // tslint:disable-next-line:typedef
    render() {
        // console.log('ShaderTranslatorView::render()');
        const { props } = this;
        const match = Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__["matchLocation"])(props);
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getFileState"])(props);
        const scope = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["getScope"])(file);
        if (!scope) {
            return null;
        }
        const fxList = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__["filterPartFx"])(scope);
        const fx = fxList.find(tech => tech.name === match.params.name);
        if (!fx) {
            return null;
        }
        let original;
        let value;
        if (match.params.pass) {
            const pass = fx.passList.find((instr, i) => Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(match.params.pass)
                ? i === Number(match.params.pass)
                : instr.name === match.params.pass);
            const mode = match.params.property === 'VertexShader' ? 'vertex' : 'pixel';
            const shader = mode === 'vertex' ? pass.vertexShader : pass.pixelShader;
            original = _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_1__["translate"](shader, { mode });
            value = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_4__["translate"](shader, { mode });
        }
        else {
            original = _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_2__["translate"](fx);
            value = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__["translateFlat"](fx);
        }
        return (react__WEBPACK_IMPORTED_MODULE_8__["createElement"](react_monaco_editor__WEBPACK_IMPORTED_MODULE_9__["MonacoDiffEditor"], { ref: 'monaco', original: original, value: value, width: '100%', height: 'calc(100vh - 74px)' // todo: fixme
            , options: diffOptions, editorDidMount: this.editorDidMount }));
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], ShaderTranslatorView.prototype, "editorDidMount", null);
ShaderTranslatorView = __decorate([
    react_router__WEBPACK_IMPORTED_MODULE_11__["withRouter"]
], ShaderTranslatorView);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_10__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__["mapProps"])(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__["getCommon"]), null)(ShaderTranslatorView));


/***/ }),

/***/ "WZwn":
/*!***************************************!*\
  !*** ./src/sandbox/index-webpack.pug ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pug = __webpack_require__(/*! ../../node_modules/pug-runtime/index.js */ "cHQP");

function template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;;var locals_for_with = (locals || {});(function (htmlWebpackPlugin) {var pug_indent = [];
pug_html = pug_html + "\u003C!DOCTYPE html\u003E\n\u003Chtml\u003E\n  \u003Ctitle\u003E" + (pug.escape(null == (pug_interp = htmlWebpackPlugin.options.title) ? "" : pug_interp)) + "\u003C\u002Ftitle\u003E\n  \u003Chead\u003E\n    \u003Cmeta http-equiv=\"Content-Type\" content=\"text\u002Fhtml; charset=UTF-8\"\u003E\n  \u003C\u002Fhead\u003E\n  \u003Cbody\u003E\n    \u003Cdiv id=\"app\"\u003E\u003C\u002Fdiv\u003E\n  \u003C\u002Fbody\u003E\n\u003C\u002Fhtml\u003E";}.call(this,"htmlWebpackPlugin" in locals_for_with?locals_for_with.htmlWebpackPlugin:typeof htmlWebpackPlugin!=="undefined"?htmlWebpackPlugin:undefined));;return pug_html;};
module.exports = template;

/***/ }),

/***/ "WdmE":
/*!***********************************************!*\
  !*** ./src/sandbox/reducers/handleActions.ts ***!
  \***********************************************/
/*! exports provided: handleActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleActions", function() { return handleActions; });
function handleActions(map, initialState) {
    return (state, action) => {
        state = state ? state : initialState;
        if (map.hasOwnProperty(action.type)) {
            return map[action.type](state, action);
        }
        return state;
    };
}


/***/ }),

/***/ "Wl5j":
/*!********************************************!*\
  !*** ./src/lib/fx/analisys/SystemScope.ts ***!
  \********************************************/
/*! exports provided: ESystemTypes, SCOPE, T_VOID, T_STRING, T_FLOAT, T_FLOAT2, T_FLOAT3, T_FLOAT4, T_FLOAT2X2, T_FLOAT3X3, T_FLOAT4X4, T_BOOL, T_BOOL2, T_BOOL3, T_BOOL4, T_BOOL2X2, T_BOOL3X3, T_BOOL4X4, T_INT, T_INT2, T_INT3, T_INT4, T_UINT, T_UINT2, T_UINT3, T_UINT4, T_INT2X2, T_INT3X3, T_INT4X4, T_SAMPLER, T_SAMPLER_2D, T_SAMPLER_CUBE, findType, findVariable, findTechnique, findFunction, hasType, hasVariable, hasTechnique, isMatrixType, isVectorType, isScalarType, isFloatBasedType, isIntBasedType, isUIntBasedType, isBoolBasedType, isSamplerType, getExternalType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ESystemTypes", function() { return ESystemTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCOPE", function() { return SCOPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_VOID", function() { return T_VOID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_STRING", function() { return T_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT", function() { return T_FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT2", function() { return T_FLOAT2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT3", function() { return T_FLOAT3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT4", function() { return T_FLOAT4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT2X2", function() { return T_FLOAT2X2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT3X3", function() { return T_FLOAT3X3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT4X4", function() { return T_FLOAT4X4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL", function() { return T_BOOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL2", function() { return T_BOOL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL3", function() { return T_BOOL3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL4", function() { return T_BOOL4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL2X2", function() { return T_BOOL2X2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL3X3", function() { return T_BOOL3X3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_BOOL4X4", function() { return T_BOOL4X4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT", function() { return T_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT2", function() { return T_INT2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT3", function() { return T_INT3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT4", function() { return T_INT4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_UINT", function() { return T_UINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_UINT2", function() { return T_UINT2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_UINT3", function() { return T_UINT3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_UINT4", function() { return T_UINT4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT2X2", function() { return T_INT2X2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT3X3", function() { return T_INT3X3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_INT4X4", function() { return T_INT4X4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_SAMPLER", function() { return T_SAMPLER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_SAMPLER_2D", function() { return T_SAMPLER_2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_SAMPLER_CUBE", function() { return T_SAMPLER_CUBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findType", function() { return findType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findVariable", function() { return findVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findTechnique", function() { return findTechnique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFunction", function() { return findFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasType", function() { return hasType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasVariable", function() { return hasVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasTechnique", function() { return hasTechnique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMatrixType", function() { return isMatrixType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVectorType", function() { return isVectorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isScalarType", function() { return isScalarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFloatBasedType", function() { return isFloatBasedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIntBasedType", function() { return isIntBasedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUIntBasedType", function() { return isUIntBasedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolBasedType", function() { return isBoolBasedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSamplerType", function() { return isSamplerType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExternalType", function() { return getExternalType; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "hsO8");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "C2sc");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "RZSc");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "bqkk");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "MJEd");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "hljw");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "IHXS");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");











// TODO: use it
var ESystemTypes;
(function (ESystemTypes) {
    ESystemTypes[ESystemTypes["k_Sampler"] = 0] = "k_Sampler";
    ESystemTypes[ESystemTypes["k_Sampler2D"] = 1] = "k_Sampler2D";
    ESystemTypes[ESystemTypes["k_Sampler3D"] = 2] = "k_Sampler3D";
    ESystemTypes[ESystemTypes["k_SamplerCube"] = 3] = "k_SamplerCube";
    ESystemTypes[ESystemTypes["k_RWBuffer"] = 4] = "k_RWBuffer";
    ESystemTypes[ESystemTypes["k_RWStructuredBuffer"] = 5] = "k_RWStructuredBuffer";
    ESystemTypes[ESystemTypes["k_AppendStructuredBuffer"] = 6] = "k_AppendStructuredBuffer";
})(ESystemTypes || (ESystemTypes = {}));
;
const scope = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_8__["Scope"]({ type: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_10__["EScopeType"].k_System });
const systemFunctionHashMap = {};
const TEMPLATE_TYPE = "template";
function _emitException(message) {
    throw new Error(message);
}
// todo: rewrite it!
function _error(code, info = {}) {
    _emitException(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_9__["EAnalyzerErrors"][code]);
}
// function generateSystemType({ name, length, elementType, fields, size, methods }: ITypeInfo): SystemTypeInstruction;
function generateSystemType(...args) {
    let name;
    let size;
    let elementType;
    let length;
    let fields;
    let methods;
    // if (isObject(args[0])) {
    //     ({ name, size, elementType, length, fields, methods } = args[0]);
    // } else{
    [name, size, elementType, length, fields, methods] = args;
    // }
    if (getSystemType(name)) {
        console.error(`type already exists: ${name}`);
        return null;
    }
    const type = new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__["SystemTypeInstruction"]({ scope, name, elementType, length, fields, size, methods });
    scope.addType(type);
    return type;
}
class TypeTemplate {
    constructor(name, scope) {
        this.name = name;
        this.scope = scope;
    }
    produceType(scope, args) {
        return null;
    }
    typeName(args) {
        if (args) {
            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;
        }
        return this.name;
    }
}
class RWBufferTemplate extends TypeTemplate {
    constructor() {
        super('RWBuffer', scope);
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        if (!args[0].isBase()) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        const uav = true;
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__["SystemTypeInstruction"]({ scope, name, elementType, length, fields, size, methods, uav });
    }
}
class RWStructuredBufferTemplate extends TypeTemplate {
    constructor() {
        super('RWStructuredBuffer', scope);
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        const uav = true;
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name: 'IncrementCounter' });
            let definition = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_2__["FunctionDefInstruction"]({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__["SystemFunctionInstruction"]({ scope, definition, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name: 'DecrementCounter' });
            let definition = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_2__["FunctionDefInstruction"]({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__["SystemFunctionInstruction"]({ scope, definition, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__["SystemTypeInstruction"]({ scope, name, elementType, length, fields, size, methods, uav });
    }
}
class AppendStructuredBufferTemplate extends TypeTemplate {
    constructor() {
        super('AppendStructuredBuffer', scope);
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        const uav = true;
        {
            const paramList = [];
            {
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type: args[0], scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name: 'Append' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__["EVariableUsageFlags"].k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__["EVariableUsageFlags"].k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__["VariableDeclInstruction"]({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            const returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type: scope.findType("void"), scope });
            const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name: 'Append' });
            const definition = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_2__["FunctionDefInstruction"]({ scope, returnType, id, paramList });
            const func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__["SystemFunctionInstruction"]({ scope, definition, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__["SystemTypeInstruction"]({ scope, name, elementType, length, fields, size, methods, uav });
    }
}
function addFieldsToVectorFromSuffixObject(fields, suffixMap, baseType) {
    for (let suffix in suffixMap) {
        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : "");
        const fieldBaseType = getSystemType(fieldTypeName);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fieldBaseType);
        const fieldId = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name: suffix });
        const fieldType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ scope, type: fieldBaseType, writable: suffixMap[suffix] });
        fields.push(new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__["VariableDeclInstruction"]({ scope, id: fieldId, type: fieldType }));
    }
}
function addSystemTypeScalar() {
    generateSystemType("void", 0);
    generateSystemType("int", 4);
    generateSystemType("uint", 4);
    generateSystemType("bool", 4);
    generateSystemType("float", 4);
    generateSystemType("string");
    generateSystemType("texture");
    generateSystemType("sampler");
    generateSystemType("sampler2D");
    generateSystemType("samplerCUBE");
}
function addSystemTypeVector() {
    let XYSuffix = {};
    let XYZSuffix = {};
    let XYZWSuffix = {};
    let RGSuffix = {};
    let RGBSuffix = {};
    let RGBASuffix = {};
    let STSuffix = {};
    let STPSuffix = {};
    let STPQSuffix = {};
    generateSuffixLiterals(["x", "y"], XYSuffix);
    generateSuffixLiterals(["x", "y", "z"], XYZSuffix);
    generateSuffixLiterals(["x", "y", "z", "w"], XYZWSuffix);
    generateSuffixLiterals(["r", "g"], RGSuffix);
    generateSuffixLiterals(["r", "g", "b"], RGBSuffix);
    generateSuffixLiterals(["r", "g", "b", "a"], RGBASuffix);
    generateSuffixLiterals(["s", "t"], STSuffix);
    generateSuffixLiterals(["s", "t", "p"], STPSuffix);
    generateSuffixLiterals(["s", "t", "p", "q"], STPQSuffix);
    let float = getSystemType("float");
    let int = getSystemType("int");
    let uint = getSystemType("uint");
    let bool = getSystemType("bool");
    let float2 = generateSystemType("float2", -1, float, 2);
    let float3 = generateSystemType("float3", -1, float, 3);
    let float4 = generateSystemType("float4", -1, float, 4);
    let int2 = generateSystemType("int2", -1, int, 2);
    let int3 = generateSystemType("int3", -1, int, 3);
    let int4 = generateSystemType("int4", -1, int, 4);
    let uint2 = generateSystemType("uint2", -1, uint, 2);
    let uint3 = generateSystemType("uint3", -1, uint, 3);
    let uint4 = generateSystemType("uint4", -1, uint, 4);
    let bool2 = generateSystemType("bool2", -1, bool, 2);
    let bool3 = generateSystemType("bool3", -1, bool, 3);
    let bool4 = generateSystemType("bool4", -1, bool, 4);
    {
        let suf2f = [];
        // program.push(EScopeType.k_Struct);
        addFieldsToVectorFromSuffixObject(suf2f, XYSuffix, "float");
        addFieldsToVectorFromSuffixObject(suf2f, RGSuffix, "float");
        addFieldsToVectorFromSuffixObject(suf2f, STSuffix, "float");
        // program.pop();
        suf2f.forEach(field => float2.addField(field));
    }
    {
        let suf3f = [];
        addFieldsToVectorFromSuffixObject(suf3f, XYZSuffix, "float");
        addFieldsToVectorFromSuffixObject(suf3f, RGBSuffix, "float");
        addFieldsToVectorFromSuffixObject(suf3f, STPSuffix, "float");
        suf3f.forEach(field => float3.addField(field));
    }
    {
        let suf4f = [];
        addFieldsToVectorFromSuffixObject(suf4f, XYZWSuffix, "float");
        addFieldsToVectorFromSuffixObject(suf4f, RGBASuffix, "float");
        addFieldsToVectorFromSuffixObject(suf4f, STPQSuffix, "float");
        suf4f.forEach(field => float4.addField(field));
    }
    {
        let suf2i = [];
        addFieldsToVectorFromSuffixObject(suf2i, XYSuffix, "int");
        addFieldsToVectorFromSuffixObject(suf2i, RGSuffix, "int");
        addFieldsToVectorFromSuffixObject(suf2i, STSuffix, "int");
        suf2i.forEach(field => int2.addField(field));
    }
    {
        let suf3i = [];
        addFieldsToVectorFromSuffixObject(suf3i, XYZSuffix, "int");
        addFieldsToVectorFromSuffixObject(suf3i, RGBSuffix, "int");
        addFieldsToVectorFromSuffixObject(suf3i, STPSuffix, "int");
        suf3i.forEach(field => int3.addField(field));
    }
    {
        let suf4i = [];
        addFieldsToVectorFromSuffixObject(suf4i, XYZWSuffix, "int");
        addFieldsToVectorFromSuffixObject(suf4i, RGBASuffix, "int");
        addFieldsToVectorFromSuffixObject(suf4i, STPQSuffix, "int");
        suf4i.forEach(field => int4.addField(field));
    }
    {
        let suf2ui = [];
        addFieldsToVectorFromSuffixObject(suf2ui, XYSuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf2ui, RGSuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf2ui, STSuffix, "uint");
        suf2ui.forEach(field => uint2.addField(field));
    }
    {
        let suf3ui = [];
        addFieldsToVectorFromSuffixObject(suf3ui, XYZSuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf3ui, RGBSuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf3ui, STPSuffix, "uint");
        suf3ui.forEach(field => uint3.addField(field));
    }
    {
        let suf4ui = [];
        addFieldsToVectorFromSuffixObject(suf4ui, XYZWSuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf4ui, RGBASuffix, "uint");
        addFieldsToVectorFromSuffixObject(suf4ui, STPQSuffix, "uint");
        suf4ui.forEach(field => uint4.addField(field));
    }
    {
        let suf2b = [];
        addFieldsToVectorFromSuffixObject(suf2b, XYSuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf2b, RGSuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf2b, STSuffix, "bool");
        suf2b.forEach(field => bool2.addField(field));
    }
    {
        let suf3b = [];
        addFieldsToVectorFromSuffixObject(suf3b, XYZSuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf3b, RGBSuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf3b, STPSuffix, "bool");
        suf3b.forEach(field => bool3.addField(field));
    }
    {
        let suf4b = [];
        addFieldsToVectorFromSuffixObject(suf4b, XYZWSuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf4b, RGBASuffix, "bool");
        addFieldsToVectorFromSuffixObject(suf4b, STPQSuffix, "bool");
        suf4b.forEach(field => bool4.addField(field));
    }
}
function addSystemTypeMatrix() {
    let float2 = getSystemType("float2");
    let float3 = getSystemType("float3");
    let float4 = getSystemType("float4");
    let int2 = getSystemType("int2");
    let int3 = getSystemType("int3");
    let int4 = getSystemType("int4");
    let uint2 = getSystemType("uint2");
    let uint3 = getSystemType("uint3");
    let uint4 = getSystemType("uint4");
    let bool2 = getSystemType("bool2");
    let bool3 = getSystemType("bool3");
    let bool4 = getSystemType("bool4");
    generateSystemType("float2x2", -1, float2, 2);
    generateSystemType("float2x3", -1, float2, 3);
    generateSystemType("float2x4", -1, float2, 4);
    generateSystemType("float3x2", -1, float3, 2);
    generateSystemType("float3x3", -1, float3, 3);
    generateSystemType("float3x4", -1, float3, 4);
    generateSystemType("float4x2", -1, float4, 2);
    generateSystemType("float4x3", -1, float4, 3);
    generateSystemType("float4x4", -1, float4, 4);
    generateSystemType("int2x2", -1, int2, 2);
    generateSystemType("int2x3", -1, int2, 3);
    generateSystemType("int2x4", -1, int2, 4);
    generateSystemType("int3x2", -1, int3, 2);
    generateSystemType("int3x3", -1, int3, 3);
    generateSystemType("int3x4", -1, int3, 4);
    generateSystemType("int4x2", -1, int4, 2);
    generateSystemType("int4x3", -1, int4, 3);
    generateSystemType("int4x4", -1, int4, 4);
    generateSystemType("bool2x2", -1, bool2, 2);
    generateSystemType("bool2x3", -1, bool2, 3);
    generateSystemType("bool2x4", -1, bool2, 4);
    generateSystemType("bool3x2", -1, bool3, 2);
    generateSystemType("bool3x3", -1, bool3, 3);
    generateSystemType("bool3x4", -1, bool3, 4);
    generateSystemType("bool4x2", -1, bool4, 2);
    generateSystemType("bool4x3", -1, bool4, 3);
    generateSystemType("bool4x4", -1, bool4, 4);
}
function generateSuffixLiterals(literals, output, depth = 0) {
    if (depth >= literals.length) {
        return;
    }
    if (depth === 0) {
        for (let i = 0; i < literals.length; i++) {
            output[literals[i]] = true;
        }
        depth = 1;
    }
    const outputKeys = Object.keys(output);
    for (let i = 0; i < literals.length; i++) {
        for (let j = 0; j < outputKeys.length; j++) {
            if (outputKeys[j].indexOf(literals[i]) !== -1) {
                output[outputKeys[j] + literals[i]] = false;
            }
            else {
                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;
            }
        }
    }
    depth++;
    generateSuffixLiterals(literals, output, depth);
}
function generateSystemFunctionInstance(type, name, paramTypes, vertex, pixel) {
    let paramList = paramTypes.map((type, n) => {
        return new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__["VariableDeclInstruction"]({
            type: new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type, scope }),
            id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ name: `p${n}`, scope }),
            scope
        });
    });
    let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__["VariableTypeInstruction"]({ type, scope });
    let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__["IdInstruction"]({ scope, name });
    let definition = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_2__["FunctionDefInstruction"]({ scope, returnType, id, paramList });
    let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__["SystemFunctionInstruction"]({ scope, definition, pixel, vertex });
    scope.addFunction(func);
}
/**
 * Exampler:
 *  generateSystemFunction("dot", "dot($1,$2)",   "float",    [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
 *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                         name   translationExpr returnType  argsTypes                       templateTypes
 */
function generateSystemFunction(name, returnTypeName, paramTypeNames, templateTypes, isForVertex = true, isForPixel = true) {
    if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(templateTypes)) {
        for (let i = 0; i < templateTypes.length; i++) {
            let funcHash = name + "(";
            let returnType = (returnTypeName === TEMPLATE_TYPE) ?
                getSystemType(templateTypes[i]) :
                getSystemType(returnTypeName);
            let paramTypes = [];
            for (let j = 0; j < paramTypeNames.length; j++) {
                if (paramTypeNames[j] === TEMPLATE_TYPE) {
                    paramTypes.push(getSystemType(templateTypes[i]));
                    funcHash += templateTypes[i] + ",";
                }
                else {
                    paramTypes.push(getSystemType(paramTypeNames[j]));
                    funcHash += paramTypeNames[j] + ",";
                }
            }
            funcHash += ")";
            if (systemFunctionHashMap[funcHash]) {
                _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_9__["EAnalyzerErrors"].SystemFunctionRedefinition, { funcName: funcHash });
            }
            generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);
            systemFunctionHashMap[funcHash] = true;
        }
    }
    else {
        if (returnTypeName === TEMPLATE_TYPE) {
            _emitException("Bad return type(TEMPLATE_TYPE) for system function '" + name + "'.");
        }
        let funcHash = name + "(";
        let returnType = getSystemType(returnTypeName);
        let paramTypes = [];
        for (let i = 0; i < paramTypeNames.length; i++) {
            if (paramTypeNames[i] === TEMPLATE_TYPE) {
                _emitException("Bad argument type(TEMPLATE_TYPE) for system function '" + name + "'.");
            }
            else {
                paramTypes.push(getSystemType(paramTypeNames[i]));
                funcHash += paramTypeNames[i] + ",";
            }
        }
        funcHash += ")";
        if (systemFunctionHashMap[funcHash]) {
            _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_9__["EAnalyzerErrors"].SystemFunctionRedefinition, { funcName: funcHash });
        }
        generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);
        systemFunctionHashMap[funcHash] = true;
    }
}
// function generateNotBuiltInSystemFunction(name: string, definition: string, implementation: string,
//     returnTypeName: string,
//     usedTypes: string[],
//     usedFunctions: string[]): void {
//     if (scope.hasFunction(name)) {
//         console.warn(`Builtin function ${name} already exists.`);
//         return;
//     }
//     let builtIn = false;
//     let returnType = getSystemType(returnTypeName);
//     let id = new IdInstruction({ scope, name })
//     let func = new SystemFunctionInstruction({ scope, id, returnType, definition, implementation, builtIn });
//     let usedExtSystemTypes: ITypeDeclInstruction[] = [];
//     let usedExtSystemFunctions: IFunctionDeclInstruction[] = [];
//     if (!isNull(usedTypes)) {
//         for (let i = 0; i < usedTypes.length; i++) {
//             let typeDecl: ITypeDeclInstruction = <ITypeDeclInstruction>getSystemType(usedTypes[i]).parent;
//             if (!isNull(typeDecl)) {
//                 usedExtSystemTypes.push(typeDecl);
//             }
//         }
//     }
//     if (!isNull(usedFunctions)) {
//         for (let i = 0; i < usedFunctions.length; i++) {
//             let pFindFunction: IFunctionDeclInstruction = scope.findFunction(usedFunctions[i]);
//             usedExtSystemFunctions.push(pFindFunction);
//         }
//     }
//     func.$setUsedSystemData(usedExtSystemTypes, usedExtSystemFunctions);
//     func.$closeSystemDataInfo();
//     scope.addFunction(func);
// }
// TODO: rework system function templates for better readability
function addSystemFunctions() {
    generateSystemFunction("dot", "float", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul
    // TODO: add support for int|uint|bool based vectors 
    generateSystemFunction("mul", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "int"]);
    generateSystemFunction("mul", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    generateSystemFunction("mul", TEMPLATE_TYPE, ["float", TEMPLATE_TYPE], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    generateSystemFunction("mul", "float4", ["float4", TEMPLATE_TYPE], ["float4x4", "float4x3", "float4x2"]);
    generateSystemFunction("mul", "float3", ["float3", TEMPLATE_TYPE], ["float3x4", "float3x3", "float3x2"]);
    generateSystemFunction("mul", "float2", ["float2", TEMPLATE_TYPE], ["float2x4", "float2x3", "float2x2"]);
    generateSystemFunction("mul", "float4", [TEMPLATE_TYPE, "float4"], ["float4x4", "float3x4", "float2x4"]);
    generateSystemFunction("mul", "float3", [TEMPLATE_TYPE, "float3"], ["float4x3", "float3x3", "float2x3"]);
    generateSystemFunction("mul", "float2", [TEMPLATE_TYPE, "float2"], ["float4x2", "float3x2", "float2x2"]);
    /**
     * scalar = int|uint|float
     * vector = vector<int|uint|float, n>, n = 2,3,4
     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4
     *
     * scalar mul(scalar, scalar)
     * vector mul(scalar, vector)
     * vector mul(vector, scalar)
     * vector mul(vector, vector)
     * matrix mul(scalar, matrix)
     * matrix mul(matrix, scalar)
     * vector mul(vector, matrix)
     * vector mul(matrix, vector)
     * matrix mul(matrix, matrix)
     */
    generateSystemFunction("mod", "float", ["float", "float"], null);
    generateSystemFunction("floor", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("ceil", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction("fract", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("abs", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("sign", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("normalize", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("length", "float", [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("cross", "float3", ["float3", "float3"], null);
    generateSystemFunction("reflect", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    // generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, "int"], ["int2", "int3", "int4"]);
    // generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    // generateSystemFunction("max", TEMPLATE_TYPE, [TEMPLATE_TYPE, "uint"], ["uint2", "uint3", "uint4"]);
    generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    // generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, "int"], ["int2", "int3", "int4"]);
    // generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    // generateSystemFunction("min", TEMPLATE_TYPE, [TEMPLATE_TYPE, "uint"], ["uint2", "uint3", "uint4"]);
    generateSystemFunction("clamp", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("clamp", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float", "float"], ["float2", "float3", "float4"]);
    generateSystemFunction("pow", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("mod", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    generateSystemFunction("mod", TEMPLATE_TYPE, [TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    generateSystemFunction("exp", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("exp2", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("log", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("log2", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("inversesqrt", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("sqrt", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("all", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    generateSystemFunction("any", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    generateSystemFunction("not", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    generateSystemFunction("distance", "float", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("lessThan", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("lessThan", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("lessThan", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("lessThanEqual", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("lessThanEqual", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("lessThanEqual", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("equal", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("equal", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("equal", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("equal", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    generateSystemFunction("notEqual", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("notEqual", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("notEqual", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("notEqual", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    generateSystemFunction("greaterThan", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("greaterThan", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("greaterThan", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("greaterThanEqual", "bool2", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    generateSystemFunction("greaterThanEqual", "bool3", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    generateSystemFunction("greaterThanEqual", "bool4", [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    generateSystemFunction("radians", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("degrees", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("sin", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("cos", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("tan", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("asin", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("acos", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("atan", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("atan", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("tex2D", "float4", ["sampler", "float2"], null);
    generateSystemFunction("tex2D", "float4", ["sampler2D", "float2"], null);
    generateSystemFunction("tex2DProj", "float4", ["sampler", "float3"], null);
    generateSystemFunction("tex2DProj", "float4", ["sampler2D", "float3"], null);
    generateSystemFunction("tex2DProj", "float4", ["sampler", "float4"], null);
    generateSystemFunction("tex2DProj", "float4", ["sampler2D", "float4"], null);
    generateSystemFunction("texCUBE", "float4", ["sampler", "float3"], null);
    generateSystemFunction("texCUBE", "float4", ["samplerCUBE", "float3"], null);
    generateSystemFunction("tex2D", "float4", ["sampler", "float2", "float"], null, false, true);
    generateSystemFunction("tex2D", "float4", ["sampler2D", "float2", "float"], null, false, true);
    generateSystemFunction("tex2DProj", "float4", ["sampler", "float3", "float"], null, false, true);
    generateSystemFunction("tex2DProj", "float4", ["sampler2D", "float3", "float"], null, false, true);
    generateSystemFunction("tex2DProj", "float4", ["sampler", "float4", "float"], null, false, true);
    generateSystemFunction("tex2DProj", "float4", ["sampler2D", "float4", "float"], null, false, true);
    generateSystemFunction("texCUBE", "float4", ["sampler", "float3", "float"], null, false, true);
    generateSystemFunction("texCUBE", "float4", ["samplerCUBE", "float3", "float"], null, false, true);
    generateSystemFunction("tex2DLod", "float4", ["sampler", "float2", "float"], null, true, false);
    generateSystemFunction("tex2DLod", "float4", ["sampler2D", "float2", "float"], null, true, false);
    generateSystemFunction("tex2DProjLod", "float4", ["sampler", "float3", "float"], null, true, false);
    generateSystemFunction("tex2DProjLod", "float4", ["sampler2D", "float3", "float"], null, true, false);
    generateSystemFunction("tex2DProjLod", "float4", ["sampler", "float4", "float"], null, true, false);
    generateSystemFunction("tex2DProjLod", "float4", ["sampler2D", "float4", "float"], null, true, false);
    generateSystemFunction("texCUBELod", "float4", ["sampler", "float3", "float"], null, true, false);
    generateSystemFunction("texCUBELod", "float4", ["samplerCUBE", "float3", "float"], null, true, false);
    //OES_standard_derivatives
    generateSystemFunction("dFdx", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("dFdy", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("width", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("fwidth", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction("smoothstep", "float3", ["float3", "float3", "float3"], null);
    generateSystemFunction("smoothstep", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("smoothstep", TEMPLATE_TYPE, ["float", "float", TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    generateSystemFunction("frac", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("lerp", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("lerp", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    generateSystemFunction("saturate", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    generateSystemFunction("asfloat", "float", [TEMPLATE_TYPE], ["float" /*, "uint"*/]);
    generateSystemFunction("asfloat", "float", [TEMPLATE_TYPE], ["int" /*, "uint"*/]);
    generateSystemFunction("asfloat", "float2", [TEMPLATE_TYPE], ["int2" /*, "uint2"*/]);
    generateSystemFunction("asfloat", "float3", [TEMPLATE_TYPE], ["int3" /*, "uint3"*/]);
    generateSystemFunction("asfloat", "float4", [TEMPLATE_TYPE], ["int4" /*, "uint4"*/]);
    generateSystemFunction("asint", "int", [TEMPLATE_TYPE], ["float", "uint"]);
    generateSystemFunction("asint", "int2", [TEMPLATE_TYPE], ["float2", "uint2"]);
    generateSystemFunction("asint", "int3", [TEMPLATE_TYPE], ["float3", "uint3"]);
    generateSystemFunction("asint", "int4", [TEMPLATE_TYPE], ["float4", "uint4"]);
    generateSystemFunction("asuint", "uint", [TEMPLATE_TYPE], ["float", "int"]);
    generateSystemFunction("asuint", "uint2", [TEMPLATE_TYPE], ["float2", "int2"]);
    generateSystemFunction("asuint", "uint3", [TEMPLATE_TYPE], ["float3", "int3"]);
    generateSystemFunction("asuint", "uint4", [TEMPLATE_TYPE], ["float4", "int4"]);
    generateSystemFunction("InterlockedAdd", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["int"]);
    // generateSystemFunction("InterlockedAdd", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["uint"]);
    // generateSystemFunction("asint", "int", [TEMPLATE_TYPE], ["float", "float2", "float3", "float4", "uint", "uint2", "uint3", "uint4"]);
    // generateSystemFunction("asfloat", "float", [TEMPLATE_TYPE], ["int", "int2", "int3", "int4", "uint", "uint2", "uint3", "uint4"]);
    // generateSystemFunction("asint", "int", [TEMPLATE_TYPE], ["float", "float2", "float3", "float4", "uint", "uint2", "uint3", "uint4"]);
}
// function generateSystemVariable(name: string, typeName: string,
//     isForVertex: boolean, isForPixel: boolean, readonly: boolean): void {
//     if (scope.hasVariable(name)) {
//         return;
//     }
//     let id = new IdInstruction({ scope, name });
//     let type = new VariableTypeInstruction({ scope, type: getSystemType(typeName), writable: readonly });
//     let variableDecl = new VariableDeclInstruction({ scope, id, type, builtIn: true });
//     variableDecl.$makeVertexCompatible(isForVertex);
//     variableDecl.$makePixelCompatible(isForPixel);
//     scope.addVariable(variableDecl);
// }
function getSystemType(typeName) {
    //boolean, string, float and others
    let type = scope.findType(typeName);
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!type || (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_10__["EInstructionTypes"].k_SystemType));
    return type;
}
// function addSystemVariables(): void {
// generateSystemVariable("fragColor", "gl_FragColor", "float4", false, true, true);
// generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
// generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
// generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);
// }
function initSystemTypes() {
    addSystemTypeScalar();
    addSystemTypeVector();
    addSystemTypeMatrix();
    scope.addTypeTemplate(new RWBufferTemplate);
    scope.addTypeTemplate(new RWStructuredBufferTemplate);
    scope.addTypeTemplate(new AppendStructuredBufferTemplate);
}
function initSystemFunctions() {
    addSystemFunctions();
}
// function initSystemVariables(): void {
//     addSystemVariables();
// }
initSystemTypes();
initSystemFunctions();
// initSystemVariables();
/**
 * Export API
 */
const SCOPE = scope;
const T_VOID = scope.findType("void");
const T_STRING = scope.findType("string");
const T_FLOAT = scope.findType("float");
const T_FLOAT2 = scope.findType("float2");
const T_FLOAT3 = scope.findType("float3");
const T_FLOAT4 = scope.findType("float4");
const T_FLOAT2X2 = scope.findType("float2x2");
const T_FLOAT3X3 = scope.findType("float3x3");
const T_FLOAT4X4 = scope.findType("float4x4");
const T_BOOL = scope.findType("bool");
const T_BOOL2 = scope.findType("bool2");
const T_BOOL3 = scope.findType("bool3");
const T_BOOL4 = scope.findType("bool4");
const T_BOOL2X2 = scope.findType("bool2x2");
const T_BOOL3X3 = scope.findType("bool3x3");
const T_BOOL4X4 = scope.findType("bool4x4");
const T_INT = scope.findType("int");
const T_INT2 = scope.findType("int2");
const T_INT3 = scope.findType("int3");
const T_INT4 = scope.findType("int4");
const T_UINT = scope.findType("uint");
const T_UINT2 = scope.findType("uint2");
const T_UINT3 = scope.findType("uint3");
const T_UINT4 = scope.findType("uint4");
const T_INT2X2 = scope.findType("int2x2");
const T_INT3X3 = scope.findType("int3x3");
const T_INT4X4 = scope.findType("int4x4");
const T_SAMPLER = scope.findType("sampler");
const T_SAMPLER_2D = scope.findType("sampler2D");
const T_SAMPLER_CUBE = scope.findType("samplerCUBE");
const findType = (typeName) => scope.findType(typeName);
const findVariable = (varName) => scope.findVariable(varName);
const findTechnique = (techName) => scope.findTechnique(techName);
const findFunction = (funcName, args) => scope.findFunction(funcName, args);
const hasType = (typeName) => !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(scope.findType(typeName));
const hasVariable = (varName) => !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(scope.findVariable(varName));
const hasTechnique = (techName) => !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(scope.findTechnique(techName));
function isMatrixType(type) {
    return type.isEqual(getSystemType("float2x2")) ||
        type.isEqual(getSystemType("float3x3")) ||
        type.isEqual(getSystemType("float4x4")) ||
        type.isEqual(getSystemType("int2x2")) ||
        type.isEqual(getSystemType("int3x3")) ||
        type.isEqual(getSystemType("int4x4")) ||
        type.isEqual(getSystemType("bool2x2")) ||
        type.isEqual(getSystemType("bool3x3")) ||
        type.isEqual(getSystemType("bool4x4"));
}
function isVectorType(type) {
    return type.isEqual(getSystemType("float2")) ||
        type.isEqual(getSystemType("float3")) ||
        type.isEqual(getSystemType("float4")) ||
        type.isEqual(getSystemType("bool2")) ||
        type.isEqual(getSystemType("bool3")) ||
        type.isEqual(getSystemType("bool4")) ||
        type.isEqual(getSystemType("int2")) ||
        type.isEqual(getSystemType("int3")) ||
        type.isEqual(getSystemType("int4")) ||
        type.isEqual(getSystemType("uint2")) ||
        type.isEqual(getSystemType("uint3")) ||
        type.isEqual(getSystemType("uint4"));
}
function isScalarType(type) {
    return type.isEqual(T_BOOL) ||
        type.isEqual(T_INT) ||
        type.isEqual(T_UINT) ||
        type.isEqual(T_FLOAT);
}
function isFloatBasedType(type) {
    return type.isEqual(T_FLOAT) ||
        type.isEqual(T_FLOAT2) ||
        type.isEqual(T_FLOAT3) ||
        type.isEqual(T_FLOAT4) ||
        type.isEqual(T_FLOAT2X2) ||
        type.isEqual(T_FLOAT3X3) ||
        type.isEqual(T_FLOAT4X4);
}
function isIntBasedType(type) {
    return type.isEqual(T_INT) ||
        type.isEqual(T_INT2) ||
        type.isEqual(T_INT3) ||
        type.isEqual(T_INT4) ||
        type.isEqual(T_INT2X2) ||
        type.isEqual(T_INT3X3) ||
        type.isEqual(T_INT4X4);
}
function isUIntBasedType(type) {
    return type.isEqual(T_UINT) ||
        type.isEqual(T_UINT2) ||
        type.isEqual(T_UINT3) ||
        type.isEqual(T_UINT4);
}
function isBoolBasedType(type) {
    return type.isEqual(T_BOOL) ||
        type.isEqual(T_BOOL2) ||
        type.isEqual(T_BOOL3) ||
        type.isEqual(T_BOOL4) ||
        type.isEqual(T_BOOL2X2) ||
        type.isEqual(T_BOOL3X3) ||
        type.isEqual(T_BOOL4X4);
}
function isSamplerType(type) {
    return type.isEqual(T_SAMPLER) ||
        type.isEqual(getSystemType("sampler2D")) ||
        type.isEqual(getSystemType("samplerCUBE"));
}
/** @deprecated */
function getExternalType(type) {
    if (type.isEqual(T_INT) ||
        type.isEqual(T_UINT) ||
        type.isEqual(T_FLOAT)) {
        return Number;
    }
    else if (type.isEqual(T_BOOL)) {
        return "Boolean";
    }
    else if (type.isEqual(T_FLOAT2) ||
        type.isEqual(T_BOOL2) ||
        type.isEqual(T_INT2) ||
        type.isEqual(T_UINT2)) {
        return "Vec2";
    }
    else if (type.isEqual(T_FLOAT3) ||
        type.isEqual(T_BOOL3) ||
        type.isEqual(T_INT3) ||
        type.isEqual(T_UINT3)) {
        return "Vec3";
    }
    else if (type.isEqual(T_FLOAT4) ||
        type.isEqual(T_BOOL4) ||
        type.isEqual(T_INT4) ||
        type.isEqual(T_UINT4)) {
        return "Vec4";
    }
    else if (type.isEqual(T_FLOAT2X2) ||
        type.isEqual(T_BOOL2X2) ||
        type.isEqual(T_INT2X2)) {
        return "Vec2";
    }
    else if (type.isEqual(T_FLOAT3X3) ||
        type.isEqual(T_BOOL3X3) ||
        type.isEqual(T_INT3X3)) {
        return "Mat3";
    }
    else if (type.isEqual(T_FLOAT4X4) ||
        type.isEqual(T_BOOL4X4) ||
        type.isEqual(T_INT4X4)) {
        return "Mat4";
    }
    else {
        return null;
    }
}


/***/ }),

/***/ "Wv+o":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ForStmtInstruction.ts ***!
  \****************************************************************/
/*! exports provided: ForStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ForStmtInstruction", function() { return ForStmtInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");





/**
 * Represent for(forInit forCond ForStep) stmt
 * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
 */
class ForStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_4__["StmtInstruction"] {
    constructor({ init = null, cond = null, step = null, body = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ForStmt, ...settings });
        this._init = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(init, this);
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(cond, this);
        this._step = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(step, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(body, this);
    }
    get init() {
        return this._init;
    }
    get cond() {
        return this._cond;
    }
    get step() {
        return this._step;
    }
    get body() {
        return this._body;
    }
    toCode() {
        var code = "for(";
        code += this._init.toCode() + ";";
        code += this._cond.toCode() + ";";
        code += this._step.toCode() + ")";
        code += this._body.toCode();
        return code;
    }
    // TODO: move it to Analysis.ts
    check(stage, info = null) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._step)) {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForStepEmpty);
            return false;
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._init)) {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForInitEmptyIterator);
            return false;
        }
        if (this._init.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableDecl) {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForInitExpr);
            return false;
        }
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._cond)) {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForConditionEmpty);
            return false;
        }
        if (this._cond.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_RelationalExpr) {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForConditionRelation);
            return false;
        }
        if (this._step.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_UnaryExpr ||
            this._step.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_AssignmentExpr ||
            this._step.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixArithmeticExpr) {
            // todo: rewrite this check!!
            // var sOperator: string = this._step.operator;
            // if (sOperator !== "++" && sOperator !== "--" &&
            //     sOperator !== "+=" && sOperator !== "-=") {
            //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });
            //     return false;
            // }
        }
        else {
            this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__["EAnalyzerErrors"].InvalidForStepExpr);
            return false;
        }
        return true;
    }
}


/***/ }),

/***/ "XL/w":
/*!**********************************!*\
  !*** ./src/lib/fx/SLDocument.ts ***!
  \**********************************/
/*! exports provided: createSLDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSLDocument", function() { return createSLDocument; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analisys/Analyzer */ "NzFo");
/* harmony import */ var _SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SLASTDocument */ "ahmV");



async function createSLDocument(document, flags) {
    let textDocument = document;
    let slastDocument = document;
    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(textDocument.source)) {
        slastDocument = await Object(_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__["createSLASTDocument"])(textDocument, flags);
    }
    const analyzer = new _analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__["Analyzer"];
    return await analyzer.parse(slastDocument);
}


/***/ }),

/***/ "XQla":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts ***!
  \***********************************************************************/
/*! exports provided: AssignmentExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentExprInstruction", function() { return AssignmentExprInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent someExpr = += -= /= *= %= someExpr
 * (=|+=|-=|*=|/=|%=) Instruction Instruction
 */
class AssignmentExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_AssignmentExpr, type: left.type, ...settings });
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = "";
        code += this.left.toCode();
        code += this.operator;
        code += this.right.toCode();
        return code;
    }
}


/***/ }),

/***/ "Y1wX":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypedInstruction.ts ***!
  \**************************************************************/
/*! exports provided: TypedInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypedInstruction", function() { return TypedInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



class TypedInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"] {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_Typed, ...settings });
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withNoParent(type);
        // todo: remove this check
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._type)) {
            console.warn("Something goes wrong! Type is not specified!", this);
        }
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "YPfw":
/*!***********************************!*\
  !*** ./src/lib/parser/symbols.ts ***!
  \***********************************/
/*! exports provided: END_POSITION, T_EMPTY, UNKNOWN_TOKEN, START_SYMBOL, UNUSED_SYMBOL, INLINE_COMMENT_SYMBOL, ERROR, END_SYMBOL, LEXER_RULES, FLAG_RULE_CREATE_NODE, FLAG_RULE_SKIP_NODE, FLAG_RULE_EXPOSE_NODE, FLAG_RULE_FUNCTION, EOF, T_STRING, T_FLOAT, T_UINT, T_TYPE_ID, T_NON_TYPE_ID, T_LINE_TERMINATOR */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "END_POSITION", function() { return END_POSITION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_EMPTY", function() { return T_EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNKNOWN_TOKEN", function() { return UNKNOWN_TOKEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "START_SYMBOL", function() { return START_SYMBOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNUSED_SYMBOL", function() { return UNUSED_SYMBOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INLINE_COMMENT_SYMBOL", function() { return INLINE_COMMENT_SYMBOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR", function() { return ERROR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "END_SYMBOL", function() { return END_SYMBOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEXER_RULES", function() { return LEXER_RULES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLAG_RULE_CREATE_NODE", function() { return FLAG_RULE_CREATE_NODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLAG_RULE_SKIP_NODE", function() { return FLAG_RULE_SKIP_NODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLAG_RULE_EXPOSE_NODE", function() { return FLAG_RULE_EXPOSE_NODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLAG_RULE_FUNCTION", function() { return FLAG_RULE_FUNCTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOF", function() { return EOF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_STRING", function() { return T_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_FLOAT", function() { return T_FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_UINT", function() { return T_UINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_TYPE_ID", function() { return T_TYPE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_NON_TYPE_ID", function() { return T_NON_TYPE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T_LINE_TERMINATOR", function() { return T_LINE_TERMINATOR; });
const END_POSITION = 'END'; // item, parser
const T_EMPTY = 'EMPTY'; // item, parser
const UNKNOWN_TOKEN = 'UNKNOWN'; // lexer
const START_SYMBOL = 'S'; // parser
const UNUSED_SYMBOL = '##'; // parser
const INLINE_COMMENT_SYMBOL = '#'; // parser
// TODO: do not use ambigious name 'ERROR'
const ERROR = 'ERROR'; // parser
const END_SYMBOL = '$'; // lexer, parser
const LEXER_RULES = '--LEXER--'; // parser
const FLAG_RULE_CREATE_NODE = '--add'; // parser
const FLAG_RULE_SKIP_NODE = '--skip'; // parser
const FLAG_RULE_EXPOSE_NODE = '--expose'; // parser
const FLAG_RULE_FUNCTION = '--F'; // parser
const EOF = 'EOF'; // lexer
const T_STRING = 'T_STRING'; // lexer
const T_FLOAT = 'T_FLOAT'; // lexer
const T_UINT = 'T_UINT'; // lexer
const T_TYPE_ID = 'T_TYPE_ID'; // lexer
const T_NON_TYPE_ID = 'T_NON_TYPE_ID'; // lexer
const T_LINE_TERMINATOR = 'T_LINE_TERMINATOR'; // lexer


/***/ }),

/***/ "ZPkl":
/*!*************************************************!*\
  !*** ./src/sandbox/containers/BytecodeView.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "bTLv");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "p34+");
/* harmony import */ var _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/InstructionList */ "RvT5");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "2oKZ");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "BW2l");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/DistinctColor */ "Mu1Z");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
// tslint:disable:typedef
// tslint:disable:max-func-body-length
// tslint:disable:cyclomatic-complexity














function minWidth(str, len = 0, char = ' ') {
    for (let i = 0, slen = str.length; i < Math.max(0, len - slen); ++i) {
        str = char + str;
    }
    return str;
}
const REG_NAMES = {
    [0x100]: 'rax' // todo: get register adresses from bytecode generator
};
const constant = (v) => `"${v}"`;
const float = (v) => String(v).indexOf('.') === -1 ? `${v}.f` : `${v}f`;
const fixPrecision = (v, precision = 2) => Math.floor(v * Math.pow(10, 2)) / Math.pow(10, 2);
const hex2 = (v) => `0x${minWidth(v.toString(16), 2, '0')}`;
const hex4 = (v) => `0x${minWidth(v.toString(16), 4, '0')}`;
const reg = (v) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`; // register address;
const addr = (v) => `%${hex4(v >>> 0)}%`; // global memory address;
const any4 = (v) => `${minWidth(String(v), 4, ' ')}`;
const scode = (c) => {
    let s = String(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"][c]);
    s = s.substr(2);
    let v = '';
    for (const char of s) {
        if (char === char.toUpperCase() && (char < '0' || char > '9') && v.length > 0) {
            v += '_';
        }
        v += char.toLowerCase();
    }
    switch (c) {
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32SetConst: return 'i32_set';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegister: return 'i32_load';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegistersPointer: return 'i32_load*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreRegisterPointer: return 'i32_store*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadInputPointer: return 'i32_load_input*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreInputPointer: return 'i32_store_input*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32GreaterThanEqual: return 'i32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LessThan: return 'i32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_U32GreaterThanEqual: return 'u32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_U32LessThan: return 'u32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32GreaterThanEqual: return 'f32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32LessThan: return 'f32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Not: return 'i32_not';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32NotEqual: return 'i32_ne';
        default:
            return v;
    }
};
class BytecodeView extends react__WEBPACK_IMPORTED_MODULE_11__["Component"] {
    constructor() {
        super(...arguments);
        this.state = {
            count: 0,
            cdlView: null
        };
    }
    static getDerivedStateFromProps(props, state) {
        const count = 0;
        const cdlView = Object(_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["cdlview"])(props.runtime.cdl);
        return { count, cdlView };
    }
    render() {
        const { props } = this;
        const { runtime: { code, cdl } } = props;
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(code)) {
            return null;
        }
        const chunks = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_4__["decodeChunks"](code);
        const ilist = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_4__["decodeCodeChunk"](chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_5__["EChunkType"].k_Code]);
        return (
        // fixed
        react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null,
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"], { size: 'small', unstackable: true, basic: true, compact: true, style: { fontFamily: 'consolas', whiteSpace: 'pre' } },
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Body, { style: {
                        maxHeight: 'calc(100vh - 432px)',
                        overflowY: 'auto',
                        display: 'block'
                    } }, this.renderOpList(ilist)),
                props.options.disableOptimizations &&
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Footer, null,
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Row, null,
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Cell, { colSpan: 5, inverted: true, warning: true, textAlign: 'center', style: { padding: '2px', fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif' } }, "optimizations are disabled")))),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Button"], { animated: true, onClick: async () => {
                    const result = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_4__["asNative"](await _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_4__["evaluate"](code), cdl);
                    alert(JSON.stringify(result, null, '   '));
                } },
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Button"].Content, { visible: true }, "Run"),
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Button"].Content, { hidden: true },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Icon"], { name: 'rocket' })))));
    }
    renderOpList(ilist) {
        const list = [];
        for (let i = 0; i < ilist.length; i += 5) {
            list.push(this.renderOp(ilist.subarray(i, i + 5)));
        }
        return list;
    }
    renderOp(op) {
        const code = op[0];
        const args = [op[1], op[2], op[3], op[4]];
        switch (op[3]) {
            default:
                return this.renderOpInternal(code, args);
        }
    }
    showSourceLine(pc) {
        // console.log(this.state.cdlView.resolveFileLocation(pc));
    }
    hideSourceLine(oc) {
    }
    // tslint:disable-next-line:max-func-body-length:
    // tslint:disable-next-line:cyclomatic-complexity
    renderOpInternal(code, args) {
        const i = this.state.count++;
        const { cdlView } = this.state;
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32SetConst:
                args.length = 3;
                // op, const, hint
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegister:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegistersPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreRegisterPointer:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadInput:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreInput:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadInputPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreInputPointer:
                args.length = 4;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Not:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Equal:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32NotEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_U32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_U32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LogicalOr:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LogicalAnd:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32ToI32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32ToF32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32ToU32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_U32ToF32:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Mul:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32Max:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Mul:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Sin:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Cos:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Frac:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Sqrt:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Floor:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Ceil:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_F32Max:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_JumpIf:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_Jump:
                args.length = 1;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_Ret:
                args.length = 0;
                break;
            default:
        }
        // tslint:disable-next-line:switch-default
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32SetConst:
                args[1] = args[2] === 1 ? fixPrecision(Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__["u32Asf32"])(args[1])) : Object(_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__["u32Asi32"])(args[1]);
        }
        //
        // Convert all arguments to strings
        //
        let sArgs = args.map(String);
        const pointer = (x) => `%${x}`;
        const register = (x) => `r${x}`;
        // tslint:disable-next-line:switch-default
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32SetConst:
                sArgs[0] = register(args[0]);
                if (args[2] === 1) { // is float
                    sArgs[1] = float(args[1]);
                }
                sArgs[1] = constant(sArgs[1]);
                sArgs.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegister:
                sArgs[0] = register(args[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadRegistersPointer:
                sArgs[0] = register(args[0]);
                sArgs[1] = pointer(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreRegisterPointer:
                sArgs[0] = pointer(args[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadInput:
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreInput:
                sArgs[2] = register(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32LoadInputPointer:
                sArgs[1] = register(args[1]);
                sArgs[2] = pointer(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_I32StoreInputPointer:
                sArgs[1] = pointer(args[1]);
                sArgs[2] = register(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_6__["EOperation"].k_Jump:
                sArgs[0] = hex2(args[0] / _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__["default"].STRIDE);
                break;
            default:
                sArgs = args.map(register);
        }
        sArgs = sArgs.map(any4);
        // let htmlArgs: JSX.Element[] = [];
        // const asSpan = (v: string) => (<span>&nbsp;{ v }&nbsp;</span>);
        // switch (code) {
        //     case EOperation.k_I32SetConst:
        //         htmlArgs[0] = asSpan(sArgs[0]);
        //         htmlArgs[1] = (<span style={ { color: 'gray' } }>&nbsp;{ sArgs[1] }&nbsp;</span>);
        //         break;
        //     default:
        //         htmlArgs = sArgs.map(asSpan);
        // }
        let specColor = null;
        if (this.props.options.colorize) {
            specColor = {
                padding: '0.2em 0',
                opacity: 0.5,
                background: _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_7__["default"].make(cdlView.resolvePcColor(i)).toRGBAString(),
                width: '4px'
            };
        }
        return (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Row, { key: `op-${code}-${i}`, style: { width: '100%', display: 'table', tableLayout: 'fixed', borderBottom: 'none' }, onMouseOver: () => this.showSourceLine(i), onMouseOut: () => this.hideSourceLine(i) },
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Cell, { style: specColor }),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Cell, { style: { padding: '0.2em 0.7em', width: '50px' } }, hex4(i)),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Cell, { style: { padding: '0.2em 0.7em' } }, scode(code)),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["Table"].Cell, { colSpan: 2, style: { padding: '0.2em 0.7em' } }, sArgs.join(' '))));
    }
}
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_12__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_9__["mapProps"])(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__["getDebugger"]), Object(_sandbox_actions__WEBPACK_IMPORTED_MODULE_8__["mapActions"])(_sandbox_actions__WEBPACK_IMPORTED_MODULE_8__["sourceCode"]))(BytecodeView));


/***/ }),

/***/ "Zd6l":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts ***!
  \*****************************************************************/
/*! exports provided: DeclStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeclStmtInstruction", function() { return DeclStmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");



/**
 * Represent TypeDecl or VariableDecl or VarStructDecl
 * EMPTY DeclInstruction
 */
class DeclStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__["StmtInstruction"] {
    constructor({ declList = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_DeclStmt, ...settings });
        this._declList = (declList || []).map(decl => _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(decl, this));
    }
    get declList() {
        return this._declList;
    }
    toCode() {
        var code = '';
        var declList = this.declList;
        for (var i = 0; i < this.declList.length; i++) {
            code += declList[i].toCode() + ";\n";
        }
        return code;
    }
}


/***/ }),

/***/ "a1Km":
/*!******************************************!*\
  !*** ./src/lib/idl/EAnalyzerWarnings.ts ***!
  \******************************************/
/*! exports provided: EAnalyzerWarnings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAnalyzerWarnings", function() { return EAnalyzerWarnings; });
var EAnalyzerWarnings;
(function (EAnalyzerWarnings) {
    EAnalyzerWarnings[EAnalyzerWarnings["UnsupportedRenderStateTypeUsed"] = 3000] = "UnsupportedRenderStateTypeUsed";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompleteTechnique"] = 3001] = "IncompleteTechnique";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompletePass"] = 3002] = "IncompletePass";
    EAnalyzerWarnings[EAnalyzerWarnings["UselessPassState"] = 3003] = "UselessPassState";
    // part fx
})(EAnalyzerWarnings || (EAnalyzerWarnings = {}));


/***/ }),

/***/ "ahmV":
/*!*************************************!*\
  !*** ./src/lib/fx/SLASTDocument.ts ***!
  \*************************************/
/*! exports provided: SLASTDocument, createSLASTDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLASTDocument", function() { return SLASTDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSLASTDocument", function() { return createSLASTDocument; });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/ASTDocument */ "h4FD");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/Lexer */ "TYG3");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/symbols */ "YPfw");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/uri/uri */ "rMqy");
/* harmony import */ var _SLParser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SLParser */ "O8iw");






// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));
const PREDEFINED_TYPES = [
    'float2', 'float3', 'float4',
    'float2x2', 'float3x3', 'float4x4',
    'int2', 'int3', 'int4',
    'uint2', 'uint3', 'uint4',
    'bool2', 'bool3', 'bool4',
    'auto'
];
class SLASTDocument extends _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__["ASTDocument"] {
    constructor({ parser = Object(_SLParser__WEBPACK_IMPORTED_MODULE_5__["defaultSLParser"])() } = {}) {
        super({ parser, knownTypes: new Set(PREDEFINED_TYPES) });
    }
    get includes() {
        return this.includeList;
    }
    async parse(textDocument, flags) {
        this.includeList.set(textDocument.uri, null);
        return await super.parse(textDocument, flags);
    }
    init(config) {
        super.init(config);
        this.includeList = new Map();
        this.lexers = [];
        this.tokens = [];
        this.ruleFunctions.set('addType', this._addType.bind(this));
        this.ruleFunctions.set('includeCode', this._includeCode.bind(this));
    }
    _addType() {
        const tree = this.tree;
        const node = tree.lastNode;
        const typeId = node.children[node.children.length - 2].value;
        this.knownTypes.add(typeId);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EOperationType"].k_Ok;
    }
    emitFileNotFound(file, range) {
        this.diag.error(_lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__["EParsingErrors"].GeneralCouldNotReadFile, { ...this.lexer.getLocation(), loc: range, target: file });
    }
    readToken() {
        const token = super.readToken();
        if (token.value === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_3__["END_SYMBOL"]) {
            if (this.lexers.length > 0) {
                this.lexer = this.lexers.pop();
                return this.tokens.pop();
            }
        }
        return token;
    }
    async _includeCode() {
        let tree = this.tree;
        let node = tree.lastNode;
        let file = node.value;
        //cuttin qoutes
        const includeURL = file.substr(1, file.length - 2);
        const uri = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_4__["resolve"](includeURL, `${this.uri}`);
        if (this.includeList.has(uri)) {
            console.warn(`'${uri}' file has already been included previously.`);
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EOperationType"].k_Ok;
        }
        this.includeList.set(uri, node.loc);
        try {
            const response = await fetch(uri);
            if (!response.ok) {
                this.emitFileNotFound(uri, node.loc);
                return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EOperationType"].k_Error;
            }
            const source = await response.text();
            //
            // Replace lexer with new one 
            //
            this.lexers.push(this.lexer);
            this.tokens.push(this.token);
            this.lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_2__["Lexer"]({
                engine: this.parser.lexerEngine,
                knownTypes: this.knownTypes
            });
            this.lexer.setup({ source, uri });
            this.token = this.readToken();
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EOperationType"].k_Ok;
        }
        catch (e) {
            console.error(e);
            this.emitFileNotFound(file, node.loc);
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EOperationType"].k_Error;
    }
}
async function createSLASTDocument(textDocument, flags) {
    const document = new SLASTDocument();
    await document.parse(textDocument, flags);
    return document;
}


/***/ }),

/***/ "bB3A":
/*!*****************************************!*\
  !*** ./src/sandbox/containers/index.ts ***!
  \*****************************************/
/*! exports provided: ParserParameters, SourceEditor2, BytecodeView, App, Playground, ShaderTranslatorView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ParserParameters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParserParameters */ "ONqV");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParserParameters", function() { return _ParserParameters__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _editor_Editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/Editor */ "TyAm");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SourceEditor2", function() { return _editor_Editor__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _BytecodeView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BytecodeView */ "ZPkl");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BytecodeView", function() { return _BytecodeView__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App */ "hdbZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "App", function() { return _App__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _playground__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./playground */ "iT/H");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Playground", function() { return _playground__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderTranslatorView */ "Vh/Z");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderTranslatorView", function() { return _ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "bTLv":
/*!**************************************!*\
  !*** ./src/lib/fx/bytecode/index.ts ***!
  \**************************************/
/*! exports provided: translate, translateExpression, DEFAULT_ENTRY_POINT_NAME, REG_INVALID, cdlview */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytecode */ "oof7");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return _Bytecode__WEBPACK_IMPORTED_MODULE_0__["translate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "translateExpression", function() { return _Bytecode__WEBPACK_IMPORTED_MODULE_0__["translateExpression"]; });

/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "p34+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ENTRY_POINT_NAME", function() { return _common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_ENTRY_POINT_NAME"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "REG_INVALID", function() { return _common__WEBPACK_IMPORTED_MODULE_1__["REG_INVALID"]; });

/* harmony import */ var _DebugLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DebugLayout */ "UMcR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cdlview", function() { return _DebugLayout__WEBPACK_IMPORTED_MODULE_2__["cdlview"]; });






/***/ }),

/***/ "bUvT":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts ***!
  \************************************************************************/
/*! exports provided: PartFxPassInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartFxPassInstruction", function() { return PartFxPassInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PassInstruction */ "jfm7");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");



class PartFxPassInstruction extends _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__["PassInstruction"] {
    constructor({ sorting = false, instanceCount = 1, prerenderRoutine, geometry, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PartFxPass, ...settings });
        this.sorting = sorting;
        this.prerenderRoutine = prerenderRoutine;
        this.geometry = geometry;
        this.instanceCount = instanceCount;
    }
    get particleInstance() {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.prerenderRoutine)) {
            return null;
        }
        return this.prerenderRoutine.function.def.params[1].type.subType;
    }
    isValid() {
        return !!this.particleInstance && !!this.prerenderRoutine;
    }
}


/***/ }),

/***/ "bqkk":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts ***!
  \*******************************************************************/
/*! exports provided: SystemTypeInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SystemTypeInstruction", function() { return SystemTypeInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




class SystemTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"] {
    constructor({ name, size = 0, elementType = null, length = 1, fields = [], methods = [], writable = true, readable = true, complex = false, sampler = false, texture = false, uav = false, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SystemType, ...settings });
        this._name = name;
        this._size = size;
        this._elementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withNoParent(elementType);
        this._length = length;
        this._fields = [];
        this._methods = [];
        this._bIsWritable = writable;
        this._bIsReadable = readable;
        this._bIsComplex = complex;
        this._bIsSampler = sampler;
        this._bIsTexture = texture;
        this._bIsUAV = uav;
        fields.forEach(field => this.addField(field));
        methods.forEach(method => this.addMethod(method));
    }
    get writable() {
        return this._bIsWritable;
    }
    get readable() {
        return this._bIsReadable;
    }
    set name(sName) {
        this._name = sName;
    }
    get name() {
        return this._name;
    }
    get hash() {
        return this._name;
    }
    get strongHash() {
        return this._name;
    }
    get size() {
        if (this.isArray()) {
            if (this.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH;
            }
            return this.arrayElementType.size * this.length;
        }
        return this._size;
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return this._elementType;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this._length;
    }
    get fields() {
        return this._fields;
    }
    get methods() {
        return this._methods;
    }
    get fieldNames() {
        return this._fields.map(field => field.name);
    }
    isSampler() {
        return this._bIsSampler;
    }
    isTexture() {
        return this._bIsTexture;
    }
    isUAV() {
        return this._bIsUAV;
    }
    /** @deprecated */
    isEqual(value) {
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].equals(this, value);
    }
    toDeclString() {
        console.warn('@pure_virtual');
        return '';
    }
    isBase() {
        return true;
    }
    isArray() {
        return !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.arrayElementType);
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return this._bIsComplex;
    }
    isConst() {
        return false;
    }
    isContainArray() {
        return false;
    }
    isContainSampler() {
        return false;
    }
    isContainPointer() {
        return false;
    }
    isContainComplexType() {
        return false;
    }
    toString() {
        return this.name || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].hash(this);
    }
    toCode() {
        return this._name;
    }
    hasField(fieldName) {
        return !!this.getField(fieldName);
    }
    hasFieldWithSematics(semantic) {
        return false;
    }
    hasAllUniqueSemantics() {
        return false;
    }
    hasFieldWithoutSemantics() {
        return false;
    }
    getField(fieldName) {
        return this._fields.find(field => field.name === fieldName) || null;
    }
    getMethod(methodName, args) {
        const list = this._methods.filter(method => method.name === methodName);
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["fn"].matchList(list, args);
    }
    getFieldBySemantics(semantic) {
        console.error("@undefined_behavior");
        return null;
    }
    /** internal api */
    addField(field) {
        console.assert(this.getField(field.name) === null);
        this._fields.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(field, this));
    }
    /** internal api */
    addMethod(method) {
        console.assert(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.getMethod(method.name, method.def.params.map(param => param.type))));
        this._methods.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(method, this));
    }
}


/***/ }),

/***/ "bxdW":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts ***!
  \************************************************************************/
/*! exports provided: ConditionalExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConditionalExprInstruction", function() { return ConditionalExprInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




/**
 * Represen boolExpr ? someExpr : someExpr
 * EMPTY_OPERATOR Instruction Instruction Instruction
 */
class ConditionalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__["ExprInstruction"] {
    constructor({ cond, left, right, ...settings }) {
        // todo: do not use {left.type} here
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_ConditionalExpr, type: left.type, ...settings });
        console.assert(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].equals(left.type, right.type, true));
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(cond, this);
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(right, this);
    }
    get condition() {
        return this._cond;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    toCode() {
        var code = '(';
        code += this.condition.toCode();
        code += '?';
        code += this.left.toCode();
        code += ':';
        code += this.right.toCode();
        code += ')';
        return code;
    }
    isConst() {
        return this.condition.isConst() &&
            this.left.isConst();
    }
}


/***/ }),

/***/ "cuAd":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts ***!
  \*******************************************************************/
/*! exports provided: SpawnInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpawnInstruction", function() { return SpawnInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StmtInstruction */ "oseZ");


class SpawnInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__["StmtInstruction"] {
    constructor({ count, name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SpawnStmt, ...settings });
        this._fx = null;
        this._init = null;
        this.count = count;
        this.args = args;
        this.name = name;
    }
    get fx() {
        return this._fx;
    }
    get init() {
        return this._init;
    }
    toCode() {
        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;
    }
    // delayed resolve of the spawn instructions
    $resolve(fx, init) {
        this._fx = fx;
        this._init = init;
    }
}


/***/ }),

/***/ "dNjM":
/*!******************************************!*\
  !*** ./src/lib/fx/bytecode/VM/native.ts ***!
  \******************************************/
/*! exports provided: asNativeInner, asNative */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asNativeInner", function() { return asNativeInner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asNative", function() { return asNative; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "p34+");


function asNativeVector(elementDecoder, value, length, stride = 4) {
    const vector = [];
    for (let i = 0; i < length; ++i) {
        vector.push(elementDecoder(value.subarray(stride * i, stride * i + stride)));
    }
    return vector;
}
const asInt = _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__["u8ArrayAsI32"];
const asUint = u8a => (asInt(u8a) >>> 0);
const asFloat = _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__["u8ArrayAsF32"];
const asBool = u8a => asInt(u8a) !== 0;
function asNativeInner(result, layout) {
    // TODO: remove it?
    while (layout !== layout.baseType) {
        layout = layout.baseType;
    }
    switch (layout.name) {
        case 'bool':
            return asBool(result);
        case 'int':
            return asInt(result);
        case 'float':
            return asFloat(result);
        case 'uint':
            return asUint(result);
        case 'uint2':
        case 'uint3':
        case 'uint4':
            return asNativeVector(asUint, result, layout.length, 4);
        case 'int2':
        case 'int3':
        case 'int4':
            return asNativeVector(asInt, result, layout.length, 4);
        case 'float2':
        case 'float3':
        case 'float4':
            return asNativeVector(asFloat, result, layout.length, 4);
    }
    if (layout.isComplex()) {
        let complex = {};
        layout.fields.forEach(field => {
            const { type, type: { padding, size } } = field;
            complex[field.name] = asNativeInner(result.subarray(padding, padding + size), type);
        });
        return complex;
    }
    if (layout.isNotBaseArray()) {
        return asNativeVector(u8a => asNativeInner(u8a, layout.arrayElementType), result, layout.length, layout.arrayElementType.size);
    }
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `not implemented: ${layout.toCode()}`);
    return null;
}
function asNative(result, cdl) {
    let layout = cdl.info.layout;
    return asNativeInner(result, layout);
}


/***/ }),

/***/ "eck8":
/*!*********************************************!*\
  !*** ./src/lib/fx/translators/FxEmitter.ts ***!
  \*********************************************/
/*! exports provided: FxEmitter, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FxEmitter", function() { return FxEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "DAvO");
/* harmony import */ var _CodeEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CodeEmitter */ "yAC2");



class FxEmitter extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_2__["CodeEmitter"] {
    emitRoutineProperty(name, routine) {
        this.emitKeyword(name);
        this.emitKeyword('=');
        this.emitSpace();
        this.emitCompile(routine);
        this.emitChar(';');
        this.emitNewline();
    }
    emitStringProperty(name, id) {
        this.emitKeyword(name),
            this.emitKeyword('='),
            this.emitKeyword(id),
            this.emitChar(';'),
            this.emitNewline();
    }
    emitSpawnStmt(stmt) {
        this.emitKeyword(`spawn(${stmt.count})`);
        this.emitKeyword(stmt.name);
        this.emitChar('(');
        this.emitNoSpace();
        stmt.args.forEach((arg, i, list) => {
            this.emitExpression(arg);
            (i + 1 != list.length) && this.emitChar(',');
        });
        this.emitChar(')');
        this.emitChar(';');
    }
    emitPartFxDecl(fx) {
        this.begin();
        {
            this.emitKeyword('partFx');
            fx.name && this.emitKeyword(fx.name);
            fx.semantic && this.emitSemantic(fx.semantic);
            fx.annotation && this.emitAnnotation(fx.annotation);
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                fx.capacity && this.emitStringProperty('Capacity', String(fx.capacity));
                fx.spawnRoutine && this.emitRoutineProperty('SpawnRoutine', fx.spawnRoutine);
                fx.initRoutine && this.emitRoutineProperty('InitRoutine', fx.initRoutine);
                fx.updateRoutine && this.emitRoutineProperty('UpdateRoutine', fx.updateRoutine);
                this.emitNewline();
                fx.passList.forEach((pass, i) => (this.emitPartFxPass(pass),
                    i !== fx.passList.length - 1 && this.emitNewline()));
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
    }
    emitPartFxPass(pass) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        {
            pass.prerenderRoutine && this.emitRoutineProperty('PrerenderRoutine', pass.prerenderRoutine);
            pass.sorting && this.emitStringProperty('Sorting', String(pass.sorting));
            this.emitStringProperty('Geometry', _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"][pass.geometry].substr(2));
            pass.instanceCount !== 1 && this.emitStringProperty('InstanceCount', String(pass.instanceCount));
            super.emitPassBody(pass);
        }
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitStmt(stmt) {
        switch (stmt.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SpawnStmt:
                this.emitSpawnStmt(stmt);
                break;
            default:
                super.emitStmt(stmt);
        }
    }
    emit(instr) {
        if (!instr) {
            return this;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PartFxDecl:
                this.emitPartFxDecl(instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PartFxPass:
                this.emitPartFxPass(instr);
                break;
            default:
                super.emit(instr);
        }
        return this;
    }
}
function translate(instr) {
    const emitter = new FxEmitter();
    emitter.emit(instr);
    return emitter.toString();
}


/***/ }),

/***/ "fb8x":
/*!***************************!*\
  !*** ./src/lib/common.ts ***!
  \***************************/
/*! exports provided: typeOf, isDef, isDefAndNotNull, isEmpty, isNull, isBoolean, isString, isNumber, isFloat, isInt, isUint, isFunction, isObject, isArrayBuffer, isTypedArray, isBlob, isArray, deepEqual, assert, verbose, mwalk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeOf", function() { return typeOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDef", function() { return isDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDefAndNotNull", function() { return isDefAndNotNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return isBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFloat", function() { return isFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInt", function() { return isInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUint", function() { return isUint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return isArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return isTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return isBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepEqual", function() { return deepEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verbose", function() { return verbose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mwalk", function() { return mwalk; });
let typeOf = (x) => {
    const s = typeof x;
    if (s === 'object') {
        if (x) {
            if (x instanceof Array) {
                return 'array';
            }
            else if (x instanceof Object) {
                return s;
            }
            const sClassName = Object.prototype.toString.call(x);
            if (sClassName === '[object Window]') {
                return 'object';
            }
            if ((sClassName === '[object Array]' ||
                (typeof x.length) === 'number' &&
                    (typeof x.splice) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('splice'))) {
                return 'array';
            }
            if ((sClassName === '[object Function]' ||
                (typeof x.call) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                return 'function';
            }
        }
        else {
            return 'null';
        }
    }
    else if (s === 'function' && (typeof x.call) === 'undefined') {
        return 'object';
    }
    return s;
};
let isDef = (x) => x !== undefined;
let isDefAndNotNull = (x) => x != null;
let isEmpty = (x) => x.length === 0;
let isNull = (x) => x === null;
let isBoolean = (x) => typeof x === 'boolean';
let isString = (x) => typeof x === 'string';
let isNumber = (x) => typeof x === 'number';
let isFloat = isNumber;
let isInt = (x) => isNumber(x) && (~~x === x);
let isUint = (x) => isInt(x) && x > 0;
let isFunction = (x) => typeOf(x) === 'function';
let isObject = (x) => {
    const T = typeOf(x);
    return T === 'object' || T === 'array' || T === 'function';
};
let isArrayBuffer = (x) => x instanceof ArrayBuffer;
let isTypedArray = (x) => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';
let isBlob = (x) => x instanceof Blob;
let isArray = (x) => typeOf(x) === 'array';
// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);
let deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
const assert = console.assert.bind(console);
const verbose = console.log.bind(console);
/** 'ForEach' for maps. */
function mwalk(map, cb) {
    let i = 0;
    for (const key in map) {
        if (cb(map[key], key, i++) === false) {
            break;
        }
    }
}


/***/ }),

/***/ "fjuh":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CompileExprInstruction.ts ***!
  \********************************************************************/
/*! exports provided: CompileExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompileExprInstruction", function() { return CompileExprInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
  * Represetn compile vs_func(...args)
  * compile IdExprInstruction ExprInstruction ... ExprInstruction
  */
class CompileExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ operand, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_CompileExpr, ...settings });
        this._operand = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(operand, this);
        this._args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(arg, this));
    }
    get function() {
        return this._operand;
    }
    get args() {
        return this._args;
    }
}


/***/ }),

/***/ "fuca":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: PostfixIndexInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostfixIndexInstruction", function() { return PostfixIndexInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent element[index]
 * EMPTY_OPERATOR Instruction ExprInstruction
 */
class PostfixIndexInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ element, index, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixIndexExpr,
            type: element.type.arrayElementType, ...settings
        });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(element, this);
        this.index = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(index, this);
    }
    toCode() {
        return `${this.element.toCode()}[${this.index.toCode()}]`;
    }
    isConst() {
        return this.element.isConst() && this.index.isConst();
    }
}


/***/ }),

/***/ "gf1s":
/*!*********************************!*\
  !*** ./src/lib/idl/ITexture.ts ***!
  \*********************************/
/*! exports provided: ETextureFilters, ETextureWrapModes, ETextureParameters, ETextureTypes, ECubeFace, ETextureCubeFlags, ETextureUnits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureFilters", function() { return ETextureFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureWrapModes", function() { return ETextureWrapModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureParameters", function() { return ETextureParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureTypes", function() { return ETextureTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ECubeFace", function() { return ECubeFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureCubeFlags", function() { return ETextureCubeFlags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETextureUnits", function() { return ETextureUnits; });
var ETextureFilters;
(function (ETextureFilters) {
    ETextureFilters[ETextureFilters["UNDEF"] = 0] = "UNDEF";
    ETextureFilters[ETextureFilters["NEAREST"] = 9728] = "NEAREST";
    ETextureFilters[ETextureFilters["LINEAR"] = 9729] = "LINEAR";
    ETextureFilters[ETextureFilters["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    ETextureFilters[ETextureFilters["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    ETextureFilters[ETextureFilters["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    ETextureFilters[ETextureFilters["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilters || (ETextureFilters = {}));
var ETextureWrapModes;
(function (ETextureWrapModes) {
    ETextureWrapModes[ETextureWrapModes["UNDEF"] = 0] = "UNDEF";
    ETextureWrapModes[ETextureWrapModes["REPEAT"] = 10497] = "REPEAT";
    ETextureWrapModes[ETextureWrapModes["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    ETextureWrapModes[ETextureWrapModes["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(ETextureWrapModes || (ETextureWrapModes = {}));
var ETextureParameters;
(function (ETextureParameters) {
    ETextureParameters[ETextureParameters["MAG_FILTER"] = 10240] = "MAG_FILTER";
    ETextureParameters[ETextureParameters["MIN_FILTER"] = 10241] = "MIN_FILTER";
    ETextureParameters[ETextureParameters["WRAP_S"] = 10242] = "WRAP_S";
    ETextureParameters[ETextureParameters["WRAP_T"] = 10243] = "WRAP_T";
})(ETextureParameters || (ETextureParameters = {}));
var ETextureTypes;
(function (ETextureTypes) {
    ETextureTypes[ETextureTypes["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    ETextureTypes[ETextureTypes["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
})(ETextureTypes || (ETextureTypes = {}));
var ECubeFace;
(function (ECubeFace) {
    ECubeFace[ECubeFace["POSITIVE_X"] = 0] = "POSITIVE_X";
    ECubeFace[ECubeFace["NEGATIVE_X"] = 1] = "NEGATIVE_X";
    ECubeFace[ECubeFace["POSITIVE_Y"] = 2] = "POSITIVE_Y";
    ECubeFace[ECubeFace["NEGATIVE_Y"] = 3] = "NEGATIVE_Y";
    ECubeFace[ECubeFace["POSITIVE_Z"] = 4] = "POSITIVE_Z";
    ECubeFace[ECubeFace["NEGATIVE_Z"] = 5] = "NEGATIVE_Z";
})(ECubeFace || (ECubeFace = {}));
var ETextureCubeFlags;
(function (ETextureCubeFlags) {
    ETextureCubeFlags[ETextureCubeFlags["POSITIVE_X"] = 1] = "POSITIVE_X";
    ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_X"] = 2] = "NEGATIVE_X";
    ETextureCubeFlags[ETextureCubeFlags["POSITIVE_Y"] = 4] = "POSITIVE_Y";
    ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_Y"] = 8] = "NEGATIVE_Y";
    ETextureCubeFlags[ETextureCubeFlags["POSITIVE_Z"] = 12] = "POSITIVE_Z";
    ETextureCubeFlags[ETextureCubeFlags["NEGATIVE_Z"] = 16] = "NEGATIVE_Z";
})(ETextureCubeFlags || (ETextureCubeFlags = {}));
var ETextureUnits;
(function (ETextureUnits) {
    ETextureUnits[ETextureUnits["TEXTURE0"] = 33984] = "TEXTURE0";
})(ETextureUnits || (ETextureUnits = {}));


/***/ }),

/***/ "ggRF":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InitExprInstruction.ts ***!
  \*****************************************************************/
/*! exports provided: InitExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitExprInstruction", function() { return InitExprInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "2b0+");






class InitExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__["ExprInstruction"] {
    constructor({ type, args = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_InitExpr, type, ...settings });
        this._isArray = false;
        this._args = args.map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_5__["Instruction"].$withParent(arg, this));
        // if (!this.optimizeForVariableType(type)) {
        //     context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });
        //     return null;
        // }
    }
    get args() {
        return this._args;
    }
    isArray() {
        return this._isArray;
    }
    toCode() {
        let code = '';
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.type)) {
            code += this.type.toCode();
        }
        code += "(";
        for (let i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        let bConst;
        let args = this.args;
        for (let i = 0; i < args.length; i++) {
            if (!args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
    /**
     *
     * @param type The type of the variable for which the initializer was created.
     */
    // TODO: move it to Analysis.ts
    optimizeForVariableType(type) {
        // It's a global user defined array or just not unit array;
        // Trying to exclude types like float1.
        if ((type.isNotBaseArray() && type.scope.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EScopeType"].k_Global) ||
            (type.isArray() && this.args.length > 1)) {
            if (type.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH ||
                (type.isNotBaseArray() && this.args.length !== type.length) ||
                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {
                return false;
            }
            if (type.isNotBaseArray()) {
                this._isArray = true;
            }
            let arrayElementType = type.arrayElementType;
            let isOk = false;
            let testedInstruction = null;
            for (let i = 0; i < this.args.length; i++) {
                testedInstruction = this.args[i];
                if (testedInstruction.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_InitExpr) {
                    isOk = testedInstruction.optimizeForVariableType(arrayElementType);
                    if (!isOk) {
                        return false;
                    }
                }
                else {
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isSamplerType"](arrayElementType)) {
                        if (testedInstruction.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_SamplerStateBlockExpr) {
                            return false;
                        }
                    }
                    else {
                        isOk = testedInstruction.type.isEqual(arrayElementType);
                        if (!isOk) {
                            return false;
                        }
                    }
                }
            }
            this._type = type.baseType;
            return true;
        }
        else {
            let firstInstruction = this.args[0];
            if (this.args.length === 1 &&
                firstInstruction.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_InitExpr) {
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isSamplerType"](type)) {
                    if (firstInstruction.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_SamplerStateBlockExpr) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                if (firstInstruction.type.isEqual(type)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (this.args.length === 1) {
                return false;
            }
            let args = this.args;
            let fieldNameList = type.fieldNames;
            for (let i = 0; i < args.length; i++) {
                let pFieldType = type.getField(fieldNameList[i]).type;
                if (!args[i].optimizeForVariableType(pFieldType)) {
                    return false;
                }
            }
            this._type = type.baseType;
            return true;
        }
    }
    /** @deprecated */
    evaluate() {
        if (!this.isConst()) {
            this._evalResult = null;
            return false;
        }
        let res = null;
        if (this._isArray) {
            res = new Array(this.args.length);
            for (let i = 0; i < this.args.length; i++) {
                let evalInstruction = this.args[i];
                if (evalInstruction.evaluate()) {
                    res[i] = evalInstruction.getEvalValue();
                }
            }
        }
        else if (this.args.length === 1) {
            let pEvalInstruction = this.args[0];
            pEvalInstruction.evaluate();
            res = pEvalInstruction.getEvalValue();
        }
        else {
            let jsTypeCtor = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["getExternalType"](this.type);
            let args = new Array(this.args.length);
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(jsTypeCtor)) {
                return false;
            }
            try {
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isScalarType"](this.type)) {
                    let testedInstruction = this.args[1];
                    if (this.args.length > 2 || !testedInstruction.evaluate()) {
                        return false;
                    }
                    res = jsTypeCtor(testedInstruction.getEvalValue());
                }
                else {
                    for (let i = 0; i < this.args.length; i++) {
                        let testedInstruction = this.args[i];
                        if (testedInstruction.evaluate()) {
                            args[i] = testedInstruction.getEvalValue();
                        }
                        else {
                            return false;
                        }
                    }
                    res = new jsTypeCtor;
                    res.set.apply(res, args);
                }
            }
            catch (e) {
                return false;
            }
        }
        this._evalResult = res;
        return true;
    }
}


/***/ }),

/***/ "h4FD":
/*!***************************************!*\
  !*** ./src/lib/parser/ASTDocument.ts ***!
  \***************************************/
/*! exports provided: EParsingErrors, ParsingDiagnostics, ASTDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EParsingErrors", function() { return EParsingErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParsingDiagnostics", function() { return ParsingDiagnostics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASTDocument", function() { return ASTDocument; });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "U+xq");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Lexer */ "TYG3");
/* harmony import */ var _ParseTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ParseTree */ "2D+5");
/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbols */ "YPfw");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ "wYUO");









var EParsingErrors;
(function (EParsingErrors) {
    EParsingErrors[EParsingErrors["SyntaxUnknownError"] = 2051] = "SyntaxUnknownError";
    EParsingErrors[EParsingErrors["SyntaxUnexpectedEOF"] = 2052] = "SyntaxUnexpectedEOF";
    EParsingErrors[EParsingErrors["SyntaxRecoverableStateNotFound"] = 2053] = "SyntaxRecoverableStateNotFound";
    EParsingErrors[EParsingErrors["GeneralCouldNotReadFile"] = 2200] = "GeneralCouldNotReadFile";
    EParsingErrors[EParsingErrors["GeneralParsingLimitIsReached"] = 2201] = "GeneralParsingLimitIsReached";
})(EParsingErrors || (EParsingErrors = {}));
;
class ParsingDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__["Diagnostics"] {
    constructor() {
        super("Parsing diagnostics", 'P');
    }
    resolveFilename(code, desc) {
        return desc.file;
    }
    resolveRange(code, desc) {
        switch (code) {
            case EParsingErrors.SyntaxUnknownError:
            case EParsingErrors.SyntaxUnexpectedEOF:
                return desc.token.loc;
            case EParsingErrors.GeneralCouldNotReadFile:
                return desc.loc;
        }
        return null;
    }
    resolvePosition(code, desc) {
        console.assert(code != EParsingErrors.SyntaxUnknownError);
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParsingErrors.SyntaxUnknownError]: "Syntax error during parsing. Token: '{token.value}'\n" +
                "Line: {token.loc.start.line}. Column: {token.loc.start.column}.",
            [EParsingErrors.SyntaxUnexpectedEOF]: "Syntax error. Unexpected EOF.",
            [EParsingErrors.GeneralCouldNotReadFile]: "Could not read file '{target}'.",
            [EParsingErrors.GeneralParsingLimitIsReached]: "Parsing limit is reached.",
            [EParsingErrors.SyntaxRecoverableStateNotFound]: "Recoverable state not found."
        };
    }
}
function cloneToken(token) {
    return {
        ...token,
        loc: {
            start: { ...token.loc.start },
            end: { ...token.loc.end }
        }
    };
}
// class Context {
//     allowErrorRecoverty: boolean = true;
//     developerMode: boolean = false;
//     lexer: Lexer;
//     diagnostics: ParsingDiagnostics;
//     knownTypes: Set<string>;
//     ruleFunctions: Map<string, IRuleFunction>;
//     stack: number[] = [0];
//     constructor() {
//         this.diagnostics = new ParsingDiagnostics;
//     }
//     readToken() {
//         return this.lexer.getNextToken();
//     }
//     private error(code: number, token: IToken) {
//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });
//     }
//     private critical(code: number, token: IToken = null) {
//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });
//     }
// }
class ASTDocument {
    constructor(config) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["assert"])(config.parser, 'parser engine is not defined');
        this.init(config);
    }
    init({ parser, knownTypes = new Set(), ruleFunctions = new Map }) {
        const lexerEngine = parser.lexerEngine;
        this.parser = parser;
        this.knownTypes = knownTypes;
        this.ruleFunctions = ruleFunctions;
        this.lexer = new _Lexer__WEBPACK_IMPORTED_MODULE_4__["Lexer"]({
            engine: lexerEngine,
            knownTypes
        });
    }
    get uri() {
        return this.lexer.uri.toString();
    }
    get diagnosticReport() {
        let lexerReport = this.lexer.getDiagnosticReport();
        let parserReport = this.diag.resolve();
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__["Diagnostics"].mergeReports([lexerReport, parserReport]);
    }
    get root() {
        return this.tree.root;
    }
    async parse(textDocument, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["IASTDocumentFlags"].k_Optimize) {
        const developerMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["IASTDocumentFlags"].k_DeveloperMode);
        const allowErrorRecoverty = true;
        const optimizeTree = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["IASTDocumentFlags"].k_Optimize);
        this.diag = new ParsingDiagnostics;
        this.tree = new _ParseTree__WEBPACK_IMPORTED_MODULE_5__["ParseTree"](optimizeTree);
        this.stack = [0];
        this.lexer.setup(textDocument);
        this.token = this.readToken();
        if (this.token.value === _symbols__WEBPACK_IMPORTED_MODULE_6__["END_SYMBOL"]) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserCode"].k_Ok;
        }
        await this.run({ developerMode, allowErrorRecoverty });
        // clear context
        // this.stack = null;
        // this.lexer = null;
        // this.token = null;
        // diag
        // tree
        // end of clear
        if (this.diag.hasErrors()) {
            console.error('parsing was ended with errors.');
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserCode"].k_Error;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EParserCode"].k_Ok;
    }
    readToken() {
        return this.lexer.getNextToken();
    }
    emitError(code, token) {
        this.diag.error(code, { ...this.lexer.getLocation(), token });
    }
    emitCritical(code, token = null) {
        this.diag.critical(code, { ...this.lexer.getLocation(), token });
    }
    restoreState(syntaxTable, parseTree, stack, causingErrorToken, errorToken) {
        while (true) {
            let recoverableState = -1;
            for (let i = stack.length - 1; i >= 0; --i) {
                const errorOp = syntaxTable[stack[i]][_symbols__WEBPACK_IMPORTED_MODULE_6__["ERROR"]];
                const isRecoverableState = (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(errorOp) &&
                    errorOp.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Shift &&
                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);
                if (isRecoverableState) {
                    recoverableState = i;
                    break;
                }
            }
            if (recoverableState !== -1) {
                const recoveredStateIndex = stack[recoverableState];
                // current op will be: syntaxTable[recoveredStateIndex][ERROR];
                let stackDiff = stack.length - 1 - recoverableState;
                while (stackDiff != 0) {
                    // extend error token location with the already processed tokens
                    parseTree.$pop(errorToken.loc);
                    stack.pop();
                    stackDiff--;
                }
                // recoverable state found so continue normal processing as it would be before the error
                return recoveredStateIndex;
            }
            Object(_util__WEBPACK_IMPORTED_MODULE_7__["extendRange"])(errorToken.loc, causingErrorToken.loc);
            if (causingErrorToken.value === _symbols__WEBPACK_IMPORTED_MODULE_6__["END_SYMBOL"]) {
                // state cant be recovered
                break;
            }
            // try to restore from the next token
            // FIXME: 
            const nextToken = this.readToken();
            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);
        }
        return -1;
    }
    async operationAdditionalAction(stateIndex, grammarSymbol) {
        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(funcName)) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["assert"])(!!this.ruleFunctions.has(funcName));
            return await this.ruleFunctions.get(funcName)();
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Ok;
    }
    async run({ developerMode = false, allowErrorRecoverty = true }) {
        const { syntaxTable } = this.parser;
        const { stack, tree } = this;
        const undefinedToken = { index: -1, name: null, value: null };
        let causingErrorToken = undefinedToken;
        // debug mode
        const opLimit = 10000;
        let opCounter = 0;
        try {
            breakProcessing: while (true) {
                // global recursion prevention in debug mode
                if (developerMode) {
                    if (opCounter > opLimit) {
                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);
                    }
                    opCounter++;
                }
                let currStateIndex = stack[stack.length - 1];
                let op = syntaxTable[currStateIndex][this.token.name];
                if (allowErrorRecoverty) {
                    if (!op) {
                        // recursion prevention
                        if (causingErrorToken.index !== this.token.index) {
                            if (this.token.value === _symbols__WEBPACK_IMPORTED_MODULE_6__["END_SYMBOL"]) {
                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);
                            }
                            else {
                                this.emitError(EParsingErrors.SyntaxUnknownError, this.token);
                            }
                        }
                        else {
                            // one more attempt to recover but from the next token
                            this.token = this.readToken();
                            // NOTE: in order to prevent recusrion on END_SYMBOL
                            causingErrorToken = undefinedToken;
                            continue;
                        }
                        causingErrorToken = cloneToken(this.token);
                        // token = { ...token, name: ERROR };
                        this.token = { ...cloneToken(this.token), name: _symbols__WEBPACK_IMPORTED_MODULE_6__["ERROR"] };
                    }
                    op = syntaxTable[currStateIndex][this.token.name];
                    const errorProcessing = this.token.name === _symbols__WEBPACK_IMPORTED_MODULE_6__["ERROR"];
                    const errorReductionEnded = !op || (errorProcessing && (op.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Shift));
                    // state must be recovered if operation is undefined or error reduction was ended. 
                    if (errorReductionEnded) {
                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. 
                        let recoveryToken = cloneToken(causingErrorToken);
                        while (recoveryToken.name === _symbols__WEBPACK_IMPORTED_MODULE_6__["UNKNOWN_TOKEN"]) {
                            recoveryToken = this.readToken();
                        }
                        currStateIndex = this.restoreState(syntaxTable, tree, stack, recoveryToken, this.token /* error token */);
                        if (currStateIndex === -1) {
                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);
                        }
                        // perform error shift op.
                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'
                        stack.push(op.stateIndex);
                        tree.addToken(this.token /* error token */);
                        this.token = recoveryToken;
                        // const nextOp = syntaxTable[op.stateIndex][token.name];
                        // if (nextOp.type === EOperationType.k_Reduce) {
                        //     tokenBuffer.push(rec);
                        // }
                        // return to normal precesing loop
                        continue;
                    }
                }
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isDef"])(op)) {
                    switch (op.type) {
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Success:
                            break breakProcessing;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Shift:
                            {
                                const stateIndex = op.stateIndex;
                                stack.push(stateIndex);
                                tree.addToken(this.token);
                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, this.token.name);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                                else if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Ok) {
                                    this.token = this.readToken();
                                }
                            }
                            break;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Reduce:
                            {
                                const ruleLength = op.rule.right.length;
                                stack.length -= ruleLength;
                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;
                                stack.push(stateIndex);
                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));
                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, op.rule.left);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__["EOperationType"].k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                            }
                            break;
                    }
                }
                else {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["assert"])(!allowErrorRecoverty, `unexpected end, something went wrong :/`);
                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                }
            }
            tree.finishTree();
        }
        catch (e) {
            if (!(e instanceof _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__["DiagnosticException"])) {
                throw e;
            }
        }
    }
}


/***/ }),

/***/ "hdbZ":
/*!****************************************!*\
  !*** ./src/sandbox/containers/App.tsx ***!
  \****************************************/
/*! exports provided: styles, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styles", function() { return styles; });
/* harmony import */ var _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/autotests */ "NoIe");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "bTLv");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/components */ "IK5l");
/* harmony import */ var _sandbox_containers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/containers */ "bB3A");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/router */ "SMK2");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! connected-react-router */ "u4tm");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! path */ "tpqs");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-jss */ "p8yR");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(react_jss__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react-router-dom */ "55Ip");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/* tslint:disable:max-func-body-length */
/* tslint:disable:typedef */
/* tslint:disable:no-single-line-block-comment */















const styles = {
    sidebarLeftHotfix: {
        width: `79px !important`,
        backgroundColor: '#1e1e1e !important'
    },
    mainContentHotfix: {
        marginLeft: `calc(79px)`
    },
    mainViewHeightHotfix: {
        marginBottom: '0 !important'
    },
    fileBrowserSidebarFix: {
        padding: '10px !important',
        background: 'rgba(255,255,255,0.95) !important'
    },
    containerMarginFix: {
        border: '0px !important',
        padding: '0 !important'
    },
    topMenuFix: {
        '& > div:first-child': {
            marginBottom: '0',
            position: 'relative',
            zIndex: '2',
            // boxShadow: '0 2px 5px rgba(10,10,10, 0.1) !important',
            backgroundColor: 'white !important'
        },
        '& > .menu:first-child': {
            '& .item': {
                '&.active': {
                    border: '0 !important'
                }
            }
        }
    },
    rightColumnFix: {
        // boxShadow: '-5px 0 5px black',
        zIndex: 1,
        paddingLeft: '0 !important',
        backgroundColor: 'white',
        '& > .container': {
            paddingTop: '15px'
        }
    },
    leftColumnFix: {
        paddingRight: '0px !important'
    },
    versionFix: {
        padding: '5px !important',
        margin: '-5px !important'
    },
    tabHeaderFix: {
        marginTop: 0,
        boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.075)'
    },
    //
    // SourceCodeMenu
    //
    mebFix: {
        background: '#1e1e1e !important',
        position: 'relative',
        zIndex: 1,
        height: 'auto !important',
        minHeight: 'auto !important',
        '& .item': {
            opacity: '0.6 !important',
            alignSelf: 'baseline !important',
            paddingRight: '0 !important',
            paddingTop: '5px !important',
            paddingBottom: '5px !important',
            '&:not(:first-child)': {
                paddingLeft: '0 !important',
            },
            '&.active': {
                border: '0 !important',
                opacity: '0.75 !important',
                fontWeight: 'normal !important'
            }
        }
    }
};
const Version = (props) => {
    return (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Popup"], { trigger: react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null,
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Message"], { warning: "development" !== 'production', size: 'tiny', compact: true, className: props.classes.versionFix },
                 true && react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Icon"], { name: 'issue opened' }),
                "development",
                " | ",
                "develop",
                "-",
                "0.0.1.f10c4fa")), 
        // position='left center'
        size: 'small', content: "Tue Jan 14 2020 18:16:03 GMT+0300 (GMT+03:00)", inverted: true }));
};
let SourceCodeMenu = class SourceCodeMenu extends react__WEBPACK_IMPORTED_MODULE_11__["Component"] {
    constructor() {
        super(...arguments);
        this.state = { activeItem: 'vertexshader' };
        this.handleItemClick = (e, { name }) => this.setState({ activeItem: name });
    }
    render() {
        const { state: { activeItem }, props: { path } } = this;
        return (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { size: 'mini', pointing: true, secondary: true, inverted: true, attached: true, className: this.props.classes.mebFix },
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Item, { name: 'sourcecode', 
                // position='right'
                active: activeItem === 'sourcecode', onClick: this.handleItemClick },
                "source code ",
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Icon"], { name: 'chevron right' })),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Item, { name: 'vertexshader', 
                // position='right'
                active: activeItem === 'vertexshader', onClick: this.handleItemClick },
                path.name &&
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null,
                        path.name,
                        " ",
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Icon"], { name: 'chevron right' })),
                path.pass &&
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null,
                        `pass[${path.pass}]`,
                        " ",
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Icon"], { name: 'chevron right' })),
                path.property &&
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null, path.property))));
    }
};
SourceCodeMenu = __decorate([
    react_jss__WEBPACK_IMPORTED_MODULE_12___default()(styles)
], SourceCodeMenu);
let App = class App extends react__WEBPACK_IMPORTED_MODULE_11__["Component"] {
    constructor(props) {
        super(props);
        this.expressionRef = react__WEBPACK_IMPORTED_MODULE_11__["createRef"]();
        this.handleShowFileBrowser = () => this.setState({ showFileBrowser: !this.state.showFileBrowser });
        this.hideFileBrowser = () => this.setState({ showFileBrowser: false });
        this.state = {
            showFileBrowser: false,
            testProcessing: false
        };
    }
    static getDerivedStateFromProps(props, state) {
        const nextAnalysis = props.sourceFile.slDocument;
        const contentChanged = !(state.prevAnalysis === nextAnalysis);
        let stateDiff = null;
        if (contentChanged) {
            stateDiff = { prevAnalysis: nextAnalysis };
        }
        return stateDiff;
    }
    async runAutotests() {
        this.setState({ testProcessing: true });
        // timeout for playing animation in UI
        setTimeout(async () => {
            const { content: source, uri } = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(this.props);
            const autotests = await _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__["parse"]({ source, uri });
            await _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__["run"](autotests);
            if (!autotests.passed) {
                console.warn(autotests);
            }
            autotests.tests.forEach((test, iTest) => {
                const testName = `${test.name}-${iTest}`;
                this.highlightTest(test.name, test.loc, false);
                this.highlightTest(test.name, test.loc, true, test.passed);
                test.cases.forEach((exam, iExam) => {
                    const examName = `${testName}-${iExam}`;
                    this.highlightTest(examName, exam.loc, false);
                    this.highlightTest(examName, exam.loc, true, exam.passed, exam.note);
                });
            });
            this.setState({ testProcessing: false });
        }, 10);
    }
    compile() {
        const { state, props, expressionRef } = this;
        // fixme: kinda hack!
        const input = expressionRef.current.inputRef.current;
        props.actions.compile(input.value || null);
    }
    setAutocompile(autocompile) {
        this.props.actions.specifyOptions({ autocompile });
    }
    setBytecodeColorization(colorize) {
        this.props.actions.specifyOptions({ colorize });
    }
    resolveLocation(src) {
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(this.props);
        const uri = file.uri;
        const slastDocument = file.slastDocument;
        if (!slastDocument) {
            return null;
        }
        const includes = slastDocument.includes;
        let dst = src;
        while (dst && String(uri) !== String(dst.start.file)) {
            dst = includes.get(String(dst.start.file));
        }
        return dst;
    }
    /** @deprecated */
    highlightTest(testName, loc, show = true, passed, tooltip) {
        const name = `autotest-${testName}`;
        if (show) {
            const range = this.resolveLocation(loc);
            const color = passed ? 10 : 14;
            this.props.actions.addMarker({ name, range, type: `line`, payload: { color } });
            if (!passed && tooltip) {
                this.props.actions.addMarker({ name: `${name}-error`, range, type: `error`, payload: { color }, tooltip });
            }
        }
        else {
            this.props.actions.removeMarker(`${name}`);
            this.props.actions.removeMarker(`${name}-error`);
        }
    }
    /** @deprecated */
    highlightInstruction(inst, show = true) {
        const markerName = `ast-range-${inst.instructionID}`;
        if (show) {
            const range = this.resolveLocation(inst.sourceNode.loc);
            this.props.actions.addMarker({
                name: markerName,
                range,
                type: `marker`
            });
        }
        else {
            this.props.actions.removeMarker(markerName);
        }
    }
    /** @deprecated */
    highlightPNode(id, pnode = null, show = true) {
        if (show) {
            const range = this.resolveLocation(pnode.loc);
            this.props.actions.addMarker({
                name: `ast-range-${id}`,
                range,
                type: 'marker'
            });
        }
        else {
            this.props.actions.removeMarker(`ast-range-${id}`);
        }
    }
    canCompile() {
        const { sourceFile } = this.props;
        return sourceFile.slDocument && sourceFile.slDocument.diagnosticReport.errors === 0;
    }
    buildShaderMenu() {
        const props = this.props;
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(props);
        const list = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["filterPartFx"])(Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getScope"])(file));
        if (!file.uri) {
            return [];
        }
        const links = [];
        const basepath = `/playground/${path__WEBPACK_IMPORTED_MODULE_10__["basename"](file.uri)}`;
        for (const fx of list) {
            links.push(`${fx.name}`);
            links.push(...fx.passList
                .filter(pass => !!pass.vertexShader)
                .map((pass, i) => `${fx.name}/${pass.name || i}/VertexShader`));
            links.push(...fx.passList
                .filter(pass => !!pass.pixelShader)
                .map((pass, i) => `${fx.name}/${pass.name || i}/PixelShader`));
        }
        return links.map(name => ({ name, basepath, link: `${basepath}/${name}` }));
    }
    render() {
        const { props, state, props: { sourceFile } } = this;
        const $debugger = sourceFile.debugger;
        // console.log(props.match.params);
        // console.log(`/${props.match.params.view}/${props.match.params.fx}`);
        // console.log(JSON.stringify(props.match, null, '\t'));
        const showAutotestMenu = (sourceFile.content || '').substr(0, 40).indexOf('@autotests') !== -1;
        const analysisResults = [
            {
                menuItem: {
                    as: react_router_dom__WEBPACK_IMPORTED_MODULE_14__["NavLink"],
                    content: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Header, null, "Playground")),
                    to: `/playground/${props.match.params.fx}`,
                    // exact: true,
                    key: 'playground'
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/playground' },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"], { item: true, icon: 'gear', simple: true },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Menu, null, this.buildShaderMenu().map(item => (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Item, { as: react_router_dom__WEBPACK_IMPORTED_MODULE_14__["NavLink"], to: item.link }, item.name))))),
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", { className: 'ui right aligned category search item' }, "Playground"))),
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { attached: 'bottom', key: 'playground-view' },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["Playground"], null))))
            },
            {
                menuItem: {
                    as: react_router_dom__WEBPACK_IMPORTED_MODULE_14__["NavLink"],
                    content: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Header, null,
                        "Bytecode",
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("br", null),
                        "Debugger")),
                    to: `/bytecode/${props.match.params.fx}`,
                    // exact: true,
                    key: 'bytecode'
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/bytecode' },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", { className: 'ui right aligned category search item' }, "Bytecode Debugger"))),
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { attached: 'bottom', key: 'bytecode-view' },
                        showAutotestMenu &&
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Segment"], { color: 'orange' },
                                !this.state.testProcessing &&
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Button"], { onClick: this.runAutotests, width: '100%' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("span", null, "Run autotests!")),
                                this.state.testProcessing &&
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Loader"], { active: true, inline: true })),
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Table"], { size: 'small', basic: 'very', compact: 'very' },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Table"].Body, null,
                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Table"].Row, { style: { paddingTop: 0 } },
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Table"].Cell, null,
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Input"], { fluid: true, size: 'small', label: 'expression', placeholder: `${_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_ENTRY_POINT_NAME"]}()`, ref: this.expressionRef })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Table"].Cell, null,
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Button"], { disabled: ($debugger.options.autocompile || !this.canCompile()), onClick: this.compile, width: 10 }, "Compile"),
                                        "\u00A0",
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"], { text: 'Options', pointing: 'left' },
                                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Menu, null,
                                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Item, null,
                                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Checkbox"], { label: 'auto compilation', size: 'small', checked: $debugger.options.autocompile, onMouseDown: e => this.setAutocompile(!$debugger.options.autocompile) })),
                                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Item, null,
                                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Checkbox"], { disabled: true, label: 'no optimisations', size: 'small', checked: true })),
                                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Dropdown"].Item, null,
                                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Checkbox"], { label: 'colorize', size: 'small', checked: $debugger.options.colorize, onMouseDown: e => this.setBytecodeColorization(!$debugger.options.colorize) })))))))),
                        $debugger.runtime ? (react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", null,
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_components__WEBPACK_IMPORTED_MODULE_3__["MemoryView"], { program: $debugger.runtime }),
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["BytecodeView"], null))) : null)))
            },
            {
                menuItem: {
                    as: react_router_dom__WEBPACK_IMPORTED_MODULE_14__["NavLink"],
                    content: react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Header, null,
                        "Semantic",
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("br", null),
                        "Analyzer"),
                    to: `/program/${props.match.params.fx}`,
                    // exact: true,
                    key: 'program'
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/program' },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", { className: 'ui right aligned category search item' }, "Semantic Analisys"))),
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { attached: 'bottom', key: 'program-view' },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_components__WEBPACK_IMPORTED_MODULE_3__["ProgramView"], { onNodeOver: inst => this.highlightInstruction(inst, true), onNodeOut: inst => this.highlightInstruction(inst, false), onNodeClick: inst => { } }))))
            },
            {
                menuItem: {
                    as: react_router_dom__WEBPACK_IMPORTED_MODULE_14__["NavLink"],
                    content: react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Header, null,
                        "Syntax",
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("br", null),
                        "Analyzer"),
                    to: `/ast/${props.match.params.fx}`,
                    // exact: true,
                    key: 'ast'
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/ast' },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", { className: 'ui right aligned category search item' }, "Syntax Analysis"))),
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { attached: 'bottom', key: 'ast-view' },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_components__WEBPACK_IMPORTED_MODULE_3__["ASTView"], { onNodeOver: (idx, node) => this.highlightPNode(idx, node, true), onNodeOut: idx => this.highlightPNode(idx, null, false) }))))
            }
        ];
        const defaultActiveIndex = analysisResults.findIndex(pane => {
            return !!Object(react_router_dom__WEBPACK_IMPORTED_MODULE_14__["matchPath"])(window.location.pathname, {
                path: pane.menuItem.to,
                exact: false
            });
        });
        const panes = [
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Item, null,
                    "Source File",
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("span", { style: { fontWeight: 'normal', color: 'rgba(0, 0, 0, 0.6)' } },
                        "\u00A0|\u00A0",
                        path__WEBPACK_IMPORTED_MODULE_10__["basename"](props.sourceFile.uri || '')))),
                render: () => (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { key: 'source', className: `${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}` },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Grid"], { divided: false },
                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Grid"].Row, { columns: 2 },
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Grid"].Column, { computer: '10', tablet: '8', mobile: '6', className: props.classes.leftColumnFix },
                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](SourceCodeMenu, { path: props.match.params }),
                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Switch"], null,
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/playground/:fx/:name/:pass/(vertexshader|pixelshader)' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["ShaderTranslatorView"], { name: 'shader-translator-view' })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { path: '/playground/:fx/:name' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["ShaderTranslatorView"], { name: 'shader-translator-view' })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { exact: true, path: '/playground/:fx' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["SourceEditor2"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { exact: true, path: '/bytecode/:fx' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["SourceEditor2"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { exact: true, path: '/program/:fx' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["SourceEditor2"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_14__["Route"], { exact: true, path: '/ast/:fx' },
                                        react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["SourceEditor2"], { name: 'source-code' })))),
                            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Grid"].Column, { computer: '6', tablet: '8', mobile: '10', className: props.classes.rightColumnFix },
                                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Container"], null,
                                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"], { defaultActiveIndex: defaultActiveIndex, menu: { attached: false, secondary: true, pointing: false, size: 'mini' }, panes: analysisResults, renderActiveOnly: false })))))))
            },
            {
                menuItem: 'Grammar',
                render: () => (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"].Pane, { key: 'grammar', className: `${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}` },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_containers__WEBPACK_IMPORTED_MODULE_4__["ParserParameters"], null)))
            },
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Item, { key: 'ver', position: 'right', inverted: true, disabled: true, color: 'red' },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](Version, { classes: props.classes }))),
                render: () => null
            }
        ];
        return (react__WEBPACK_IMPORTED_MODULE_11__["createElement"]("div", { className: props.classes.mainContentHotfix },
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Sidebar"].Pushable, null,
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Sidebar"], { as: semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Segment"], animation: 'overlay', vertical: true, visible: this.state.showFileBrowser, className: this.props.classes.fileBrowserSidebarFix },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](_sandbox_components__WEBPACK_IMPORTED_MODULE_3__["FileListView"], { path: './assets/fx/tests/', filters: ['.fx'], onFileClick: (file) => { _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__["history"].push(`/${props.match.params.view}/${path__WEBPACK_IMPORTED_MODULE_10__["basename"](file)}`); } })),
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Sidebar"].Pusher, { dimmed: this.state.showFileBrowser },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Tab"], { menu: { secondary: true, pointing: true }, panes: panes, renderActiveOnly: true, size: 'tiny', className: props.classes.topMenuFix }))),
            react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"], { vertical: true, icon: 'labeled', color: 'black', inverted: true, fixed: 'left', className: props.classes.sidebarLeftHotfix },
                react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Menu"].Item, { name: 'home', onClick: this.handleShowFileBrowser },
                    react__WEBPACK_IMPORTED_MODULE_11__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Icon"], { name: 'three bars' }),
                    "File Browser"))));
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_8__["default"]
], App.prototype, "runAutotests", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_8__["default"]
], App.prototype, "compile", null);
App = __decorate([
    react_jss__WEBPACK_IMPORTED_MODULE_12___default()(styles),
    react_router_dom__WEBPACK_IMPORTED_MODULE_14__["withRouter"] // << NOTE: known issue with TS decorators :/
], App);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_13__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__["mapProps"])(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__["getCommon"]), Object(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__["mapActions"])({ ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_2__["sourceCode"], ...connected_react_router__WEBPACK_IMPORTED_MODULE_9__["routerActions"] }))(App));


/***/ }),

/***/ "hljw":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: VariableTypeInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VariableTypeInstruction", function() { return VariableTypeInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




class VariableTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"] {
    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_PADDING, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableType, ...settings });
        type = type.$withNoParent();
        this._usageList = [];
        let instrType = type.instructionType;
        if (instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ProxyType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SystemType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ComplexType) {
            this._subType = type;
        }
        else {
            let varType = type;
            // TODO: review this code
            if (!varType.isNotBaseArray()) {
                this._subType = varType.subType;
                varType.usages.forEach(usage => this.addUsage(usage));
            }
            else {
                this._subType = type;
            }
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(this._subType));
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(this._usageList));
        this._isWritable = writable;
        this._isReadable = readable;
        this._arrayIndexExpr = null;
        this._arrayElementType = null;
        this._padding = padding;
        if (arrayIndex) {
            //TODO: add support for v[][10]
            this._arrayElementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType, usages: this._usageList }), this);
            this._arrayIndexExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(arrayIndex, this);
        }
        usages.forEach(usage => this.addUsage(usage));
        // todo: construct arrayElementType here! with proper usages!
        // if (this.isArray()) {
        //     if (isNull(this._arrayElementType)) {
        //         this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType.arrayElementType, usages: this.usageList }), this);
        //     }
        // }
    }
    get name() {
        return this.baseType.name;
    }
    get writable() {
        if (!this._isWritable) {
            return false;
        }
        if ((this.isArray() && !this.isBase()) || this.isUniform()) {
            return false;
        }
        if (this.isConst()) {
            return false;
        }
        // check for hasUsage('in') ?
        return this.subType.writable;
    }
    get readable() {
        if (!this._isReadable) {
            return false;
        }
        if (this.hasUsage("out")) {
            return false;
        }
        return this.subType.readable;
    }
    get methods() {
        return this.subType.methods;
    }
    // TODO: move to helpers
    get size() {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._arrayElementType)) {
            const size = this._arrayElementType.size;
            const length = this.length;
            if (length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH || size === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_SIZE) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_SIZE;
            }
            return size * length;
        }
        return this.subType.size;
    }
    get baseType() {
        return this.subType.baseType;
    }
    get length() {
        if (!this.isNotBaseArray()) {
            return this.subType.length;
        }
        if (this.isNotBaseArray() && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._arrayElementType)) {
            return this.subType.length;
        }
        // TODO: rework evaluation api!
        let isEval = this._arrayIndexExpr.evaluate();
        if (isEval) {
            let iValue = this._arrayIndexExpr.getEvalValue();
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(iValue)) {
                return iValue;
            }
        }
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH;
    }
    get padding() {
        return this._padding;
    }
    get arrayElementType() {
        if (!this.isArray()) {
            return null;
        }
        // todo: fix this.subType.arrayElementType!
        return this._arrayElementType || this.subType.arrayElementType;
    }
    get fieldNames() {
        return this.subType.fieldNames;
    }
    get usages() {
        return this._usageList;
    }
    get subType() {
        return this._subType;
    }
    get fields() {
        return this.subType.fields;
    }
    toString() {
        // TODO: fix this condition
        return this.name || this.subType.toString() || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].hash(this);
    }
    toCode() {
        let code = "";
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._usageList)) {
            for (let i = 0; i < this._usageList.length; i++) {
                code += this._usageList[i] + " ";
            }
        }
        code += this.subType.toCode();
        return code;
    }
    /** @deprecated */
    isEqual(value) {
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].equals(this, value);
    }
    /** @deprecated */
    toDeclString() {
        return this.subType.toDeclString();
    }
    // todo: add explanation!
    isBase() {
        return this.subType.isBase() && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._arrayElementType);
    }
    isArray() {
        return !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._arrayElementType) || this.subType.isArray();
    }
    // Returns true if the type is user defined array.
    // like an ordinary array: int a[5]
    // not a base array like: float4/int3 etc.
    isNotBaseArray() {
        return !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._arrayElementType) || this.subType.isNotBaseArray();
    }
    isComplex() {
        return this.subType.isComplex();
    }
    /** @deprecated */
    isContainArray() {
        return this.subType.isContainArray();
    }
    /** @deprecated */
    isContainSampler() {
        return this.subType.isContainSampler();
    }
    /** @deprecated */
    isContainComplexType() {
        return this.subType.isContainComplexType();
    }
    isUniform() {
        return this.hasUsage("uniform");
    }
    isConst() {
        return this.hasUsage("const");
    }
    isSampler() {
        return !this.isNotBaseArray() && this.subType.isSampler();
    }
    isTexture() {
        return !this.isNotBaseArray() && this.subType.isTexture();
    }
    isUAV() {
        return !this.isNotBaseArray() && this.subType.isUAV();
    }
    $overwritePadding(val) {
        this._padding = val;
    }
    addUsage(usage) {
        if (!this.hasUsage(usage)) {
            this._usageList.push(usage);
        }
    }
    hasField(fieldName) {
        return this.subType.hasField(fieldName);
    }
    hasFieldWithSematics(semantic) {
        return this.subType.hasFieldWithSematics(semantic);
    }
    hasAllUniqueSemantics() {
        return this.subType.hasAllUniqueSemantics();
    }
    hasFieldWithoutSemantics() {
        return this.subType.hasFieldWithoutSemantics();
    }
    getField(fieldName) {
        // TODO: propogate usages?
        return this.subType.getField(fieldName);
    }
    getMethod(methodName, args) {
        return this.subType.getMethod(methodName, args);
    }
    getFieldBySemantics(semantic) {
        // TODO: propogate usages?
        return this.subType.getFieldBySemantics(semantic);
    }
    hasUsage(usage) {
        if (this._usageList.find(knownUsage => knownUsage === usage)) {
            return true;
        }
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this.subType) && this.subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableType) {
            return this.subType.hasUsage(usage);
        }
        return false;
    }
    /**
     * Helpers
     */
    static wrap(type, scope) {
        return new VariableTypeInstruction({ type, scope });
    }
    static wrapAsConst(type, scope) {
        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });
    }
}


/***/ }),

/***/ "hsO8":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts ***!
  \********************************************************************/
/*! exports provided: FunctionDefInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionDefInstruction", function() { return FunctionDefInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/DeclInstruction */ "mXWi");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "2b0+");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");




/**
 * Represent type func(...args)[:Semantic]
 * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
 */
class FunctionDefInstruction extends _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__["DeclInstruction"] {
    constructor({ returnType, id, paramList = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FunctionDef, ...settings });
        this.params = paramList.map(param => _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(param, this));
        this.returnType = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(returnType, this);
        this._id = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(id, this);
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._id.name;
    }
    toString() {
        let def = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__["type"].signature(this.returnType) + " " + this.name + "(";
        for (let i = 0; i < this.params.length; i++) {
            def += _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__["type"].signature(this.params[i].type) + ",";
        }
        def += ")";
        // TODO: add semantic
        return def;
    }
    toCode() {
        const { _id: id, returnType, params } = this;
        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;
    }
}


/***/ }),

/***/ "huhI":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts ***!
  \*****************************************************************/
/*! exports provided: ExprStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExprStmtInstruction", function() { return ExprStmtInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "2b0+");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "oseZ");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");



/**
 * Represent expr;
 * EMPTY_OPERTOR ExprInstruction
 */
class ExprStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__["StmtInstruction"] {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ExprStmt, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__["Instruction"].$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return this._expr.toCode() + ';';
    }
}


/***/ }),

/***/ "i81d":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts ***!
  \********************************************************************/
/*! exports provided: ComplexTypeInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComplexTypeInstruction", function() { return ComplexTypeInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "zioJ");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers */ "u2cq");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "2b0+");






class ComplexTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_5__["Instruction"] {
    constructor({ name = null, fields, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_ComplexType, ...settings });
        this._name = name;
        this._fields = {};
        this._isContainArray = false;
        this._isContainSampler = false;
        this._isContainComplexType = false;
        this.addFields(fields.filter(field => !Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(field)).map(field => _Instruction__WEBPACK_IMPORTED_MODULE_5__["Instruction"].$withParent(field, this)));
    }
    get writable() {
        return true;
    }
    get readable() {
        return true;
    }
    get name() {
        return this._name;
    }
    get size() {
        return this.calcSize();
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return 0;
    }
    get fieldNames() {
        return Object.keys(this._fields);
    }
    get fields() {
        return this.fieldNames.map(name => this._fields[name]);
    }
    get methods() {
        return [];
    }
    isSampler() {
        return false;
    }
    isTexture() {
        return false;
    }
    isUAV() {
        return false;
    }
    toString() {
        return this.name || _helpers__WEBPACK_IMPORTED_MODULE_4__["type"].hash(this);
    }
    /** @deprecated */
    toDeclString() {
        var code = "struct " + this._name + "{";
        for (var i = 0; i < this.fields.length; i++) {
            code += "\t" + this.fields[i].toCode() + ";\n";
        }
        code += "}";
        return code;
    }
    /** @deprecated */
    isEqual(value) {
        return _helpers__WEBPACK_IMPORTED_MODULE_4__["type"].equals(this, value);
    }
    toCode() {
        return this._name;
    }
    isBase() {
        return false;
    }
    isArray() {
        return false;
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return true;
    }
    isConst() {
        return false;
    }
    /** @deprecated */
    isContainArray() {
        return this._isContainArray;
    }
    /** @deprecated */
    isContainSampler() {
        return this._isContainSampler;
    }
    /** @deprecated */
    isContainComplexType() {
        return this._isContainComplexType;
    }
    addField(variable) {
        var varName = variable.name;
        this._fields[varName] = variable;
        var type = variable.type;
        if (type.isNotBaseArray() || type.isContainArray()) {
            this._isContainArray = true;
        }
        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["isSamplerType"](type) || type.isContainSampler()) {
            this._isContainSampler = true;
        }
        if (type.isComplex()) {
            this._isContainComplexType = true;
        }
    }
    addFields(fields) {
        for (var i = 0; i < fields.length; i++) {
            this.addField(fields[i]);
        }
        this.calculatePaddings();
    }
    hasField(fieldName) {
        return Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this._fields[fieldName]);
    }
    hasFieldWithSematics(semantic) {
        return !!this.getFieldBySemantics(semantic);
    }
    getField(fieldName) {
        return this._fields[fieldName] || null;
    }
    getMethod(methodName, args) {
        return null;
    }
    getFieldBySemantics(semantic) {
        for (let i in this._fields) {
            let field = this._fields[i];
            if (semantic == field.semantic) {
                return field;
            }
        }
        return null;
    }
    calcSize() {
        let size = 0;
        for (let i = 0; i < this.fields.length; i++) {
            let iFieldSize = this.fields[i].type.size;
            if (iFieldSize === _helpers__WEBPACK_IMPORTED_MODULE_4__["instruction"].UNDEFINE_SIZE) {
                size = _helpers__WEBPACK_IMPORTED_MODULE_4__["instruction"].UNDEFINE_SIZE;
                break;
            }
            else {
                size += iFieldSize;
            }
        }
        return size;
    }
    hasFieldWithoutSemantics() {
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if (semantic == null || semantic == '') {
                return true;
            }
            if (field.type.hasFieldWithoutSemantics()) {
                return true;
            }
        }
        return false;
    }
    hasAllUniqueSemantics() {
        let fieldBySemantics = {};
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(fieldBySemantics[semantic])) {
                return false;
            }
            fieldBySemantics[semantic] = field;
            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {
                return false;
            }
        }
        return true;
    }
    calculatePaddings() {
        let padding = 0;
        for (let i = 0; i < this.fields.length; i++) {
            let varType = this.fields[i].type;
            let varSize = varType.size;
            if (varSize === _helpers__WEBPACK_IMPORTED_MODULE_4__["instruction"].UNDEFINE_SIZE) {
                this._setError(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__["EAnalyzerErrors"].CannotCalcPadding, { typeName: this.name });
                return;
            }
            varType.$overwritePadding(padding);
            padding += varSize;
        }
    }
}


/***/ }),

/***/ "iT/H":
/*!****************************************************!*\
  !*** ./src/sandbox/containers/playground/index.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Playground__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Playground */ "66j4");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Playground__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "iYqf":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InstructionCollector.ts ***!
  \******************************************************************/
/*! exports provided: InstructionCollector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructionCollector", function() { return InstructionCollector; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


class InstructionCollector extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ instructions = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Collector, ...settings });
        this._instructions = instructions;
    }
    get instructions() {
        return this._instructions;
    }
    push(instr) {
        this._instructions.push(instr);
    }
    toCode() {
        let code = "";
        for (const instr of this.instructions) {
            switch (instr.instructionType) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_VariableDecl:
                    code += instr.toCode() + ';\n';
                    break;
                default:
                    code += instr.toCode() + '\n';
            }
        }
        return code;
    }
}


/***/ }),

/***/ "ihHD":
/*!***************************************!*\
  !*** ./src/lib/fx/bytecode/sizeof.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const sizeof = {
    u32: () => 4,
    i32: () => 4,
    f32: () => 4,
    bool: () => sizeof.i32(),
    addr: () => sizeof.i32()
};
/* harmony default export */ __webpack_exports__["default"] = (sizeof);


/***/ }),

/***/ "ikYS":
/*!**********************************************************!*\
  !*** ./src/sandbox/containers/playground/ThreeScene.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "DAvO");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! autobind-decorator */ "usyV");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "Womt");
/* harmony import */ var three_orbitcontrols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-orbitcontrols */ "Y5c8");
/* harmony import */ var three_orbitcontrols__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(three_orbitcontrols__WEBPACK_IMPORTED_MODULE_6__);
/* tslint:disable:typedef */
/* tslint:disable:forin */
/* tslint:disable:no-for-in */
/* tslint:disable:newline-per-chained-call */
/* tslint:disable:number-literal-format */
/* tslint:disable:no-string-literal */
/* tslint:disable:insecure-random */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







const $vertexShader = `
precision highp float;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;
attribute vec4 color;
attribute float size;
attribute vec3 offset;

varying vec4 vColor;

void main() {
    vColor = color;
    vec4 viewPos = modelViewMatrix * vec4(offset, 1.0) + vec4(position * size, 0.0);
    gl_Position = projectionMatrix * viewPos;
}
`;
const $fragmentShader = `
precision highp float;

varying vec4 vColor;

void main() {
    gl_FragColor = vColor;
}
`;
class Particle {
}
const statsStyleFix = {
    position: 'absolute',
    color: 'white',
    padding: '2px 5px',
    fontFamily: 'consolas',
    fontSize: '10px',
    right: '0',
    lineHeight: '11px',
    textShadow: '0 0 1px grey'
};
const progressStyleFix = {
    background: '#eee',
    borderRadius: '0'
};
class ThreeScene extends react__WEBPACK_IMPORTED_MODULE_3__["Component"] {
    constructor() {
        super(...arguments);
        this.state = {
            emitter: null,
            nParticles: 0
        };
        this.start = () => {
            if (!this.frameId) {
                this.frameId = requestAnimationFrame(this.animate);
            }
        };
        this.stop = () => {
            cancelAnimationFrame(this.frameId);
        };
        this.animate = (time) => {
            const emitter = this.state.emitter;
            if (!emitter) {
                return;
            }
            emitter.tick();
            for (let iPass = 0; iPass < this.passes.length; ++iPass) {
                const rendPass = this.passes[iPass];
                const emitPass = emitter.passes[iPass];
                if (emitPass.sorting) {
                    emitPass.sort(this.camera.position);
                }
                const geometry = rendPass.mesh.geometry;
                rendPass.instancedBuffer.needsUpdate = true;
                if (emitPass.geometry === _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Line) {
                    geometry.setDrawRange(0, emitPass.length());
                }
                else {
                    geometry.maxInstancedCount = emitPass.length();
                }
            }
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
            this.frameId = requestAnimationFrame(this.animate);
            this.setState({ nParticles: emitter.length() });
        };
    }
    componentDidMount() {
        const width = this.mount.clientWidth;
        const height = this.mount.clientHeight;
        this.scene = new three__WEBPACK_IMPORTED_MODULE_5__["Scene"]();
        this.scene.background = new three__WEBPACK_IMPORTED_MODULE_5__["Color"](0xCCCCCC);
        this.createCamera(width, height);
        this.createRenderer(width, height);
        this.controls = new three_orbitcontrols__WEBPACK_IMPORTED_MODULE_6__(this.camera, this.renderer.domElement);
        this.controls.enabled = false;
        // temp solution in order to not moving text cursor during movement
        this.controls.enableKeys = false;
        this.createGridHelper();
        // this.createCube();
        this.addEmitter(this.props.emitter);
        this.start();
        window.addEventListener('resize', this.onWindowResize, false);
        // small hack for disabling arrow keys actings during the typing
        this.canvas.addEventListener('mouseover', e => { this.controls.enabled = true; });
        this.canvas.addEventListener('mouseout', e => { this.controls.enabled = false; });
        // this.canvas.addEventListener('keydown', e => { if (this.controls.enabled) e.stopPropagation() });
        // this.canvas.addEventListener('keyup', e => { if (this.controls.enabled) e.stopPropagation() });
        // console.log('ThreeScene::componentDidMount()');
    }
    get canvas() {
        return this.renderer.domElement;
    }
    addPassLine(pass) {
        const geometry = new three__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBuffer"](new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);
        //
        // Instance data
        //
        pass.instanceLayout.forEach(desc => {
            const interleavedAttr = new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBufferAttribute"](instancedBuffer, desc.size, desc.offset);
            geometry.addAttribute(desc.attrName, interleavedAttr);
        });
        const material = new three__WEBPACK_IMPORTED_MODULE_5__["RawShaderMaterial"]({
            uniforms: {},
            vertexShader: pass.vertexShader,
            fragmentShader: pass.pixelShader,
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_5__["NormalBlending"],
            depthTest: false
            // linewidth: 5
        });
        // geometry.setIndex(Array(pass.capacity).fill(0).map((x, i) => i));
        geometry.setDrawRange(0, pass.length());
        // geometry.index = new THREE.Uint16BufferAttribute(Array(pass.length).fill(0).map((x, i) => i), 1);
        const mesh = new three__WEBPACK_IMPORTED_MODULE_5__["LineSegments"](geometry, material);
        mesh.name = 'emitter';
        this.scene.add(mesh);
        this.passes.push({ mesh, instancedBuffer });
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter added.');
    }
    addPass(pass) {
        if (pass.geometry === _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Line) {
            this.addPassLine(pass);
            return;
        }
        const geometry = new three__WEBPACK_IMPORTED_MODULE_5__["InstancedBufferGeometry"]();
        const instanceGeometry = this.createInstinceGeometry(pass);
        // tslint:disable-next-line:max-line-length
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_5__["InstancedInterleavedBuffer"](new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);
        //
        // Instance data
        //
        pass.instanceLayout.forEach(desc => {
            const interleavedAttr = new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBufferAttribute"](instancedBuffer, desc.size, desc.offset);
            geometry.addAttribute(desc.attrName, interleavedAttr);
        });
        //
        // Geometry
        //
        // FIXME: do not use hardcoded layout
        const geometryFixedLayout = {
            a_position0: instanceGeometry.attributes.position,
            a_normal0: instanceGeometry.attributes.normal,
            a_texcoord0: instanceGeometry.attributes.uv
        };
        geometry.index = instanceGeometry.index;
        for (const attrName in geometryFixedLayout) {
            geometry.attributes[attrName] = geometryFixedLayout[attrName];
        }
        const material = new three__WEBPACK_IMPORTED_MODULE_5__["RawShaderMaterial"]({
            uniforms: {},
            vertexShader: pass.vertexShader,
            fragmentShader: pass.pixelShader,
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_5__["NormalBlending"],
            depthTest: false,
            // TODO: do not use for billboards
            side: three__WEBPACK_IMPORTED_MODULE_5__["DoubleSide"]
        });
        const mesh = new three__WEBPACK_IMPORTED_MODULE_5__["Mesh"](geometry, material);
        mesh.name = 'emitter';
        this.scene.add(mesh);
        this.passes.push({ mesh, instancedBuffer });
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter added.');
    }
    addPassDefaultMat(pass) {
        const geometry = new three__WEBPACK_IMPORTED_MODULE_5__["InstancedBufferGeometry"]();
        const instanceGeometry = this.createInstinceGeometry(pass);
        // tslint:disable-next-line:max-line-length
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_5__["InstancedInterleavedBuffer"](new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);
        //
        // Geometry
        //
        geometry.index = instanceGeometry.index;
        geometry.attributes.position = instanceGeometry.attributes.position;
        geometry.attributes.normal = instanceGeometry.attributes.normal;
        geometry.attributes.uv = instanceGeometry.attributes.uv;
        //
        // Instanced data
        //
        instancedBuffer.setDynamic(true);
        // todo: remove hardcoded layout or check it's validity.
        geometry.addAttribute('offset', new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBufferAttribute"](instancedBuffer, 3, 0));
        geometry.addAttribute('color', new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBufferAttribute"](instancedBuffer, 4, 3));
        geometry.addAttribute('size', new three__WEBPACK_IMPORTED_MODULE_5__["InterleavedBufferAttribute"](instancedBuffer, 1, 7));
        geometry.maxInstancedCount = pass.length();
        const material = new three__WEBPACK_IMPORTED_MODULE_5__["RawShaderMaterial"]({
            uniforms: {},
            vertexShader: $vertexShader,
            fragmentShader: $fragmentShader,
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_5__["NormalBlending"],
            depthTest: false
        });
        const mesh = new three__WEBPACK_IMPORTED_MODULE_5__["Mesh"](geometry, material);
        mesh.name = 'emitter';
        this.scene.add(mesh);
        this.passes.push({ mesh, instancedBuffer });
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter added.');
    }
    createInstinceGeometry(pass) {
        let instanceGeometry = null;
        switch (pass.geometry) {
            case _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Box:
                instanceGeometry = new three__WEBPACK_IMPORTED_MODULE_5__["BoxBufferGeometry"]();
                break;
            case _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Sphere:
                instanceGeometry = new three__WEBPACK_IMPORTED_MODULE_5__["SphereBufferGeometry"](0.5);
                break;
            case _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Cylinder:
                instanceGeometry = new three__WEBPACK_IMPORTED_MODULE_5__["CylinderBufferGeometry"](0.5, 0.5, 1.0);
                break;
            case _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Line:
                break;
            case _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_1__["EPartFxPassGeometry"].k_Billboard:
            default:
                instanceGeometry = new three__WEBPACK_IMPORTED_MODULE_5__["PlaneBufferGeometry"]();
        }
        return instanceGeometry;
    }
    // tslint:disable-next-line:max-func-body-length
    addEmitter(emitter) {
        this.passes = [];
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(emitter)) {
            console.warn('no emitters found.');
            return;
        }
        // tslint:disable-next-line:max-func-body-length
        emitter.passes.forEach((pass, i) => {
            if (pass.vertexShader && pass.pixelShader) {
                this.addPass(pass);
            }
            else {
                this.addPassDefaultMat(pass);
            }
        });
    }
    createCamera(width, height) {
        this.camera = new three__WEBPACK_IMPORTED_MODULE_5__["PerspectiveCamera"](75, width / height, 0.1, 10000);
        this.camera.position.z = 3;
        this.camera.position.y = 2;
        this.camera.position.x = 2;
        this.camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_5__["Vector3"](0, 0, 0));
    }
    createRenderer(width, height) {
        this.renderer = new three__WEBPACK_IMPORTED_MODULE_5__["WebGLRenderer"]({ antialias: true });
        // this.renderer.setClearColor('#000000');
        this.renderer.setSize(width, height - 3);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.mount.appendChild(this.renderer.domElement);
        // FIXME: remove this ui hack
        this.renderer.domElement.style.borderBottomLeftRadius = '3px';
        this.renderer.domElement.style.borderBottomRightRadius = '3px';
    }
    createGridHelper() {
        const size = 10;
        const divisions = 10;
        const gridHelper = new three__WEBPACK_IMPORTED_MODULE_5__["GridHelper"](size, divisions);
        this.scene.add(gridHelper);
    }
    onWindowResize() {
        this.camera.aspect = this.mount.clientWidth / this.mount.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight);
    }
    componentWillUnmount() {
        this.stop();
        window.removeEventListener('resize', this.onWindowResize, false);
        this.mount.removeChild(this.renderer.domElement);
    }
    shouldComponentUpdate(nextProps, nexState) {
        return this.state.emitter !== nextProps.emitter || this.state.nParticles !== nexState.nParticles;
    }
    // tslint:disable-next-line:member-ordering
    static getDerivedStateFromProps(props, state) {
        if (state.emitter === props.emitter) {
            return null;
        }
        return { emitter: props.emitter };
    }
    componentDidUpdate(prevProps, prevState) {
        if (prevState.emitter === this.state.emitter) {
            const emitter = this.props.emitter;
            emitter.passes.forEach((pass, i) => {
                let { mesh } = this.passes[i];
                let material = mesh.material;
                // let geometry = mesh.geometry as THREE.InstancedBufferGeometry;
                if (!pass.vertexShader || !pass.pixelShader) {
                    return;
                }
                const { vertexShader, pixelShader: fragmentShader } = pass;
                if (material.vertexShader !== vertexShader ||
                    material.fragmentShader !== fragmentShader) {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('material shadow reload.');
                    material.dispose();
                    material = new three__WEBPACK_IMPORTED_MODULE_5__["RawShaderMaterial"]({
                        uniforms: {},
                        vertexShader,
                        fragmentShader,
                        transparent: true,
                        blending: three__WEBPACK_IMPORTED_MODULE_5__["NormalBlending"],
                        depthTest: false
                    });
                    // this.scene.remove(mesh);
                    mesh.material = material;
                    // mesh = new THREE.Mesh(geometry, material);
                }
            });
            return;
        }
        this.passes.forEach(pass => {
            this.scene.remove(pass.mesh);
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["verbose"])('emitter removed.');
        });
        if (this.props.emitter) {
            this.addEmitter(this.props.emitter);
        }
    }
    render() {
        // console.log('ThreeScene::render()');
        return (react__WEBPACK_IMPORTED_MODULE_3__["createElement"]("div", { style: this.props.style, ref: (mount) => { this.mount = mount; } },
            react__WEBPACK_IMPORTED_MODULE_3__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["Progress"], { value: this.state.nParticles, total: this.state.emitter.capacity, attached: 'top', size: 'medium', indicating: true, style: progressStyleFix }),
            react__WEBPACK_IMPORTED_MODULE_3__["createElement"]("div", { style: statsStyleFix },
                react__WEBPACK_IMPORTED_MODULE_3__["createElement"]("span", null,
                    "\u00A0\u00A0\u00A0\u00A0\u00A0count: ",
                    this.state.nParticles),
                react__WEBPACK_IMPORTED_MODULE_3__["createElement"]("br", null),
                react__WEBPACK_IMPORTED_MODULE_3__["createElement"]("span", null, "simulation: CPU"))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_2__["default"]
], ThreeScene.prototype, "onWindowResize", null);
/* harmony default export */ __webpack_exports__["default"] = (ThreeScene);


/***/ }),

/***/ "ip/g":
/*!**********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts ***!
  \**********************************************************************/
/*! exports provided: SemicolonStmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SemicolonStmtInstruction", function() { return SemicolonStmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");


/**
 * Represent empty statement only semicolon ;
 * ;
 */
class SemicolonStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__["StmtInstruction"] {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_SemicolonStmt, ...settings });
    }
    toCode() {
        return ";";
    }
}


/***/ }),

/***/ "jfm7":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PassInstruction.ts ***!
  \*************************************************************/
/*! exports provided: PassInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PassInstruction", function() { return PassInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "6dfp");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "2blz");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/ITexture */ "gf1s");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DeclInstruction */ "mXWi");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Instruction */ "2b0+");








class PassInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_5__["DeclInstruction"] {
    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__["EInstructionTypes"].k_PassDecl, ...settings });
        this._passStateMap = {};
        PassInstruction.clearRenderStateMap(this._passStateMap);
        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);
        this._vertexShader = _Instruction__WEBPACK_IMPORTED_MODULE_6__["Instruction"].$withNoParent(vertexShader);
        this._pixelShader = _Instruction__WEBPACK_IMPORTED_MODULE_6__["Instruction"].$withNoParent(pixelShader);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get name() {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(this._id)) {
            return null;
        }
        return this._id.name;
    }
    get vertexShader() {
        return this._vertexShader;
    }
    get pixelShader() {
        return this._pixelShader;
    }
    getState(state) {
        return this._passStateMap[state];
    }
    get renderStates() {
        return this._passStateMap;
    }
    // TODO: move it to helpers
    static createRenderStateMap() {
        let map = {};
        PassInstruction.clearRenderStateMap(map);
        return map;
    }
    // TODO: move it to helpers
    static copyRenderStateMap(from, to) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(from)) {
            return;
        }
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"])
            .filter(k => Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"][k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"][k])
            .forEach(rs => { to[rs] = from[rs] || to[rs]; });
    }
    // TODO: move it to helpers
    static clearRenderStateMap(map) {
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"])
            .filter(k => Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"][k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__["ERenderStates"][k])
            .forEach(rs => { map[rs] = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__["ERenderStateValues"].UNDEF; });
    }
    /** @deprecated */
    // TODO: move it to helpers
    static createSamplerState() {
        return {
            textureName: "",
            texture: null,
            wrap_s: _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_4__["ETextureWrapModes"].UNDEF,
            wrap_t: _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_4__["ETextureWrapModes"].UNDEF,
            mag_filter: _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_4__["ETextureFilters"].UNDEF,
            min_filter: _lib_idl_ITexture__WEBPACK_IMPORTED_MODULE_4__["ETextureFilters"].UNDEF
            /*wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
            wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
            mag_filter: ETextureFilters.LINEAR,
            min_filter: ETextureFilters.LINEAR*/
        };
    }
}


/***/ }),

/***/ "kGK+":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts ***!
  \******************************************************************/
/*! exports provided: StmtBlockInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StmtBlockInstruction", function() { return StmtBlockInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "oseZ");



/**
 * Represent {stmts}
 * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
 */
class StmtBlockInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__["StmtInstruction"] {
    constructor({ stmtList, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_StmtBlock, ...settings });
        this._stmtList = stmtList.map(stmt => _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(stmt, this));
    }
    get stmtList() {
        return this._stmtList;
    }
    toCode() {
        var code = "{" + "\n";
        for (var i = 0; i < this.stmtList.length; i++) {
            code += "\t" + this.stmtList[i].toCode() + "\n";
        }
        code += "}";
        return code;
    }
}


/***/ }),

/***/ "l4+G":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts ***!
  \***********************************************************************/
/*! exports provided: ArithmeticExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArithmeticExprInstruction", function() { return ArithmeticExprInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




/**
 * Represent someExpr + / - * % someExpr
 * (+|-|*|/|%) Instruction Instruction
 */
class ArithmeticExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__["ExprInstruction"] {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_ArithmeticExpr, ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    evaluate() {
        var pValL = this._leftOperand.evaluate() ? this._leftOperand.getEvalValue() : null;
        var pValR = this._rightOperand.evaluate() ? this._rightOperand.getEvalValue() : null;
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(pValL) || Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(pValR)) {
            return false;
        }
        try {
            switch (this.operator) {
                case "+":
                    this._evalResult = pValL + pValR;
                    break;
                case "-":
                    this._evalResult = pValL - pValR;
                    break;
                case "*":
                    this._evalResult = pValL * pValR;
                    break;
                case "/":
                    this._evalResult = pValL / pValR;
                    break;
                case "%":
                    this._evalResult = pValL % pValR;
                    break;
            }
            return true;
        }
        catch (e) {
            return false;
        }
    }
    toCode() {
        var sCode = "";
        sCode += this._leftOperand.toCode();
        sCode += this.operator;
        sCode += this._rightOperand.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() && this.right.isConst();
    }
}


/***/ }),

/***/ "m5Cl":
/*!************************************************!*\
  !*** ./src/lib/fx/bytecode/PromisedAddress.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "p34+");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sizeof */ "ihHD");




class PromisedAddress {
    constructor({ type, addr, size = 0, inputIndex = -1, swizzle = null }) {
        this.type = type;
        this.addr = Number(addr);
        this.inputIndex = inputIndex;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!swizzle || !size || swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32() === size, 'size and swizzling are not compatible');
        if (swizzle) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(swizzle.length > 1, 'unary swizzles must be removed in favor of offsetted adress');
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(swizzle.length <= 4, 'only xyzw/rgba swizzles are supported');
            size = swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32();
        }
        this.size = size;
        this.swizzle = swizzle;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(addr === _common__WEBPACK_IMPORTED_MODULE_2__["REG_INVALID"] || size > 0, 'invalid address size found');
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(size % _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32() === 0, 'invalid address alignment found');
    }
    get length() {
        return this.size / _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32();
    }
    valueOf() {
        // guard of implicit loading
        if (this.type != _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `address has implicitly moved to ${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"][_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers]} from ${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"][this.type]}`);
            return _common__WEBPACK_IMPORTED_MODULE_2__["REG_INVALID"];
        }
        return this.addr;
    }
    isPointer() {
        return this.type >= _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters;
    }
    isInput() {
        return this.type == _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Input || this.type == _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerInput;
    }
    toNumber() {
        return this.addr;
    }
    toString() {
        const { type, inputIndex, addr, swizzle, size } = this;
        const isPointer = this.isPointer();
        const isInput = this.isInput();
        return `${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"][type]} [${isPointer ? '%' : isInput ? '' : 'r'}${addr / 4} ${isInput ? `input(${inputIndex})` : ``}, ${size} bytes, [${(swizzle || []).join(', ')}]]`;
    }
    // non-pointer address type => pointer
    static castToPointer(type) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(type < _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters);
        return (type + _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters);
    }
}
PromisedAddress.INVALID = new PromisedAddress({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers, addr: _common__WEBPACK_IMPORTED_MODULE_2__["REG_INVALID"], size: 0 });
/* harmony default export */ __webpack_exports__["default"] = (PromisedAddress);


/***/ }),

/***/ "mXWi":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclInstruction.ts ***!
  \*************************************************************/
/*! exports provided: DeclInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeclInstruction", function() { return DeclInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


class DeclInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ semantic = null, annotation = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Decl, ...settings });
        this._semantic = semantic;
        this._annotation = _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"].$withParent(annotation, this);
    }
    get semantic() {
        return this._semantic;
    }
    get annotation() {
        return this._annotation;
    }
    get name() {
        return null;
    }
    get id() {
        return null;
    }
}


/***/ }),

/***/ "moWP":
/*!*****************************************************!*\
  !*** ./src/sandbox/containers/editor/styles.jss.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/util/DistinctColor */ "Mu1Z");

/* harmony default export */ __webpack_exports__["default"] = ({
    yellowMarker: {
        backgroundColor: 'rgba(255,255,0,0.3)'
    },
    errorMarker: {
        top: '1px',
        background: `url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E") repeat-x bottom left`
    },
    warningMarker: {
        top: '1px',
        filter: 'hue-rotate(45deg)',
        background: `url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E") repeat-x bottom left`
    },
    breakpoint: {
        background: 'red'
    },
    ..._lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_0__["default"].buildVariousClasses('dc')
});


/***/ }),

/***/ "nImT":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/Context.ts ***!
  \****************************************/
/*! exports provided: EErrors, TranslatorDiagnostics, ContextBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EErrors", function() { return EErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TranslatorDiagnostics", function() { return TranslatorDiagnostics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextBuilder", function() { return ContextBuilder; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "BW2l");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "zX2+");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "p34+");
/* harmony import */ var _ConstantPool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConstantPool */ "Gbih");
/* harmony import */ var _DebugLayout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DebugLayout */ "UMcR");
/* harmony import */ var _InstructionList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InstructionList */ "RvT5");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PromisedAddress */ "m5Cl");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sizeof */ "ihHD");
/* harmony import */ var _SymbolTable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SymbolTable */ "tzgE");
/* harmony import */ var _UAVPool__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./UAVPool */ "3ks+");













var EErrors;
(function (EErrors) {
    EErrors[EErrors["k_UnsupportedConstantType"] = 0] = "k_UnsupportedConstantType";
    EErrors[EErrors["k_UnsupportedExprType"] = 1] = "k_UnsupportedExprType";
    EErrors[EErrors["k_UnsupoortedTypeConversion"] = 2] = "k_UnsupoortedTypeConversion";
    EErrors[EErrors["k_UnsupportedArithmeticExpr"] = 3] = "k_UnsupportedArithmeticExpr";
    EErrors[EErrors["k_UnsupportedRelationalExpr"] = 4] = "k_UnsupportedRelationalExpr";
})(EErrors || (EErrors = {}));
class TranslatorDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__["Diagnostics"] {
    constructor() {
        super("Translator Diagnostics", 'T');
    }
    resolveFilename(code, desc) {
        return '[unknown]'; // FIXME: return correct filename
    }
    resolveRange(code, desc) {
        return { start: { line: 0, column: 0, file: null }, end: { line: 0, column: 0, file: null } }; // todo: fixme
    }
    resolveDescription(code, category, desc) {
        let { ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__["EDiagnosticCategory"].k_Warning) {
            return `warning: ${JSON.stringify(data)}`;
        }
        return `${EErrors[code]}: ${JSON.stringify(data)}`;
    }
}
function ContextBuilder() {
    // occupied registers count 
    // same as stack pointer; 
    // counter grows forward;
    let rc = 0;
    // stack of functions and logical blocks for ex: braces.
    const stack = [];
    const instructions = new _InstructionList__WEBPACK_IMPORTED_MODULE_8__["default"];
    const constants = new _ConstantPool__WEBPACK_IMPORTED_MODULE_6__["default"];
    const uavs = new _UAVPool__WEBPACK_IMPORTED_MODULE_12__["UAVPool"];
    const diag = new TranslatorDiagnostics; // todo: remove it?
    /** @returns Description of the top of the callstack */
    const top = () => stack[stack.length - 1];
    const depth = () => stack.length;
    const ret = () => top().ret;
    const pc = () => instructions.pc;
    const debug = Object(_DebugLayout__WEBPACK_IMPORTED_MODULE_7__["default"])(pc);
    /* (assuming that all registers for all types are placed in the same memory) */
    function alloca(size) {
        if (size === 0) {
            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
        }
        const dest = Addr.loc({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers, addr: rc, size });
        rc += size;
        return dest;
    }
    /** insert code */
    function icode(code, ...args) {
        if (code === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_Ret) {
            // add the instruction address to the description of the
            // function on the top of the colstack; when the code
            // generation for this function is completed, all return
            // instructions must receive the correct addresses for
            // jumping to the end of the function
            addReturn();
        }
        // add this instruction to debug layout;
        debug.step();
        instructions.add(code, args.map(Number));
    }
    /**
     * Apply per component operation between two register-based adresses
     * op(a[i])
     */
    function iop1(op, dest) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * a[i] = op(b[i])
     */
    function iop2(op, dest, a) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === a.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * dest[i] = op(a[i], b[i])
     */
    function iop3(op, dest, a, b) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(b.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === a.length);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === b.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), b.addr + (b.swizzle ? b.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * dest[i] = op(a[i], b[i], c[i])
     */
    function iop4(op, dest, a, b, c) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(b.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(c.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === a.length);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === b.length);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.length === c.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), b.addr + (b.swizzle ? b.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), c.addr + (c.swizzle ? c.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Write something to this location/address
     * @param src Source address.
     * @param size Size of the source location.
     */
    function imove(dest, src) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.length === dest.length, `source size is ${src.size} and less then the requested size ${dest.size}.`);
        switch (dest.type) {
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers:
                {
                    switch (src.type) {
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers:
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32LoadRegister, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Input:
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32LoadInput, src.inputIndex, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters:
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32LoadRegistersPointer, 
                                // destination register
                                dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                                // source pointer
                                src.addr, 
                                // pointer offset
                                (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerInput:
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32LoadInputPointer, src.inputIndex, 
                                // destination register
                                dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                                // source pointer
                                src.addr, 
                                // pointer offset
                                (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        default:
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported memory type found.');
                    }
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Input:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32StoreInput, dest.inputIndex, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerInput:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32StoreInputPointer, dest.inputIndex, 
                    // destination pointer
                    dest.addr, 
                    // source register
                    src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                    // destination offset
                    (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32StoreRegisterPointer, 
                    // destination pointer
                    dest.addr, 
                    // source register
                    src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                    // destination offset
                    (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported memory type found.');
        }
        return dest;
    }
    /**
     * Resolve/move this address/region to registers
     */
    function iload(src) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        return imove(alloca(src.size), src);
    }
    const I32_HINT = 0;
    const F32_HINT = 1;
    // hint: 0 -> i32, 1 -> f32 (hints for bytecode viewer only)
    function iset(dest, i32, i32Hint) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32SetConst, dest.addr + (dest.swizzle ? dest.swizzle[0] : 0) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), i32, i32Hint);
        return dest;
    }
    function iconst_i32(i32) {
        return iset(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32()), i32, I32_HINT);
    }
    function iconst_f32(f32) {
        return iset(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].f32()), Object(_common__WEBPACK_IMPORTED_MODULE_5__["f32Asi32"])(f32), F32_HINT);
    }
    /**
     * Add referene of the local variable.
     * @param decl Variable declaration.
     * @param src Register number.
     */
    function ref(decl, src) {
        const name = _common__WEBPACK_IMPORTED_MODULE_5__["sname"].var(decl);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers);
        const scopes = top().scopes;
        const symbols = scopes[scopes.length - 1].symbols;
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(symbols[name]));
        symbols[name] = src;
    }
    /**
     * @returns Register address of variable/constant or REG_INVALID.
     * @param decl
     */
    function deref(decl) {
        const name = _common__WEBPACK_IMPORTED_MODULE_5__["sname"].var(decl);
        // is zero register available?
        for (let iFn = stack.length - 1; iFn >= 0; --iFn) {
            const scopes = stack[iFn].scopes;
            for (let iScope = scopes.length - 1; iScope >= 0; --iScope) {
                const symbols = scopes[iScope].symbols;
                if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(symbols[name])) {
                    return symbols[name];
                }
            }
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `cannot dereference varaible ${name} (${decl.toCode()})`);
        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
    }
    /** @returns Address of the return value. */
    function push(fn, ret) {
        const pc = instructions.pc;
        const retRequests = [];
        const scopes = [];
        stack.push({ fn, scopes, ret, pc, retRequests });
        open();
    }
    function pop() {
        // check that there are no non-closed blocks left inside the function
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(top().scopes.length === 1);
        close();
        const entry = stack.pop();
        const entryPoint = stack.length === 0;
        // updating all return adresses to correct values
        if (!entryPoint) {
            entry.retRequests.forEach(pc => instructions.replace(pc, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_Jump, [instructions.pc]));
            //                                                                          ^^^^^^^^^^^^^^^^^
            //                                                     instruction immediately after function
        }
    }
    /** Open new block */
    function open() {
        const symbols = new _SymbolTable__WEBPACK_IMPORTED_MODULE_11__["default"]();
        top().scopes.push({ symbols, rc });
    }
    /** CLose last block */
    function close() {
        const scope = top().scopes.pop();
        rc = scope.rc;
    }
    // next operation will be 'k_Ret'
    function addReturn() {
        top().retRequests.push(pc());
    }
    const Addr = {
        loc({ type = _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers, addr, inputIndex, size, swizzle }) {
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr, inputIndex, size, swizzle });
        },
        // override layout
        override(src, swizzle) {
            let offset = 0;
            let size = 0;
            swizzle = swizzle.map(i => src.swizzle ? src.swizzle[i] : i);
            // NOTE: 
            // All this optimizations are need only for debug purposes.
            if (!src.isPointer()) {
                // removment of the unary swizzles
                if (swizzle.length === 1) {
                    offset = swizzle[0] * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    size = _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = null;
                    return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ ...src, addr: src.addr + offset, size, swizzle });
                }
                const ordered = [...swizzle].sort((a, b) => a - b);
                // removment of the gap
                // example: v.zw => (&v + 2).xy
                if (ordered[0] !== 0) {
                    offset = ordered[0] * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = swizzle.map(si => si - ordered[0]);
                }
                // removment of the useless swizzles
                // example: v.xy => v
                const useless = swizzle.every((si, i) => si === i);
                if (useless) {
                    size = swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = null;
                }
            }
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ ...src, addr: src.addr + offset, size, swizzle });
        },
        subPointer(src, indexAddr, arrayElementSize) {
            const { type, addr, size, inputIndex, swizzle } = src;
            if (indexAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_Registers) {
                indexAddr = iload(indexAddr);
            }
            //
            // no swizzling (pointers & non-pointers)
            //
            if (!swizzle) {
                // convert byte offset to register index (cause VM uses registers not byte offsets)
                const sizeAddr = iconst_i32(arrayElementSize >> 2);
                // convert byte offset to register index
                const baseAddr = !src.isPointer() ? iconst_i32(addr >> 2) : addr;
                const pointerType = !src.isPointer() ? _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].castToPointer(type) : type;
                const pointerAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].addr()); // addr <=> i32
                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32Mad, pointerAddr, baseAddr, indexAddr, sizeAddr);
                return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });
            }
            //
            // swizzling (pointers & non-pointers)
            //
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(arrayElementSize === _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(swizzle.length <= 4);
            const swBaseRegister = rc;
            swizzle.forEach(si => iconst_i32(si));
            // ----- sw base rigister
            // [z]
            // [x]
            // [y]
            // -----
            const swAddr = iconst_i32(swBaseRegister >> 2);
            // swAddr ==> [ sw base rigister ]
            icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32Add, swAddr, swAddr, indexAddr);
            // swAddr ==> [ sw base rigister + offset ]
            // pointer to value of the swizzle for given offset
            const offsetPointer = new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__["EAddrType"].k_PointerRegisters, addr: swAddr, size: _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() });
            const pointerAddr = iload(offsetPointer);
            // destAddr ==> [ swizzles[offset] ]
            const baseAddr = !src.isPointer() ? iconst_i32(addr >> 2) : addr;
            const pointerType = !src.isPointer() ? _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].castToPointer(type) : type;
            // add given swizzle to base pointer (all pointers already aligned in registers, so 'mad' isn't not needed here)
            icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32Add, pointerAddr, baseAddr, pointerAddr);
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });
        },
        sub(src, offset, range) {
            const { type, addr, size, inputIndex, swizzle } = src;
            range = range || (size - offset);
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(range % _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() === 0);
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(offset % _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() === 0);
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(size >= offset + range);
            if (src.isPointer()) {
                if (!swizzle) {
                    if (offset !== 0) {
                        // calc the summ of the original addr and given offset
                        const newAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].addr());
                        const offsetAddr = iconst_i32(offset >> 2);
                        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__["EOperation"].k_I32Add, newAddr, addr, offsetAddr);
                        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr: newAddr, size: range, inputIndex });
                    }
                    // nothing todo, just shrink the size
                    return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr, size: range, inputIndex });
                }
                // offsets from the swizzled pointers are unsupported
                // ex: uav[i].xyz.field
                //                ^^^^^
                //                there are not such case can be! 
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported branch');
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
            }
            // just shift the address
            if (!swizzle) {
                return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr: addr + offset, size: range, inputIndex });
            }
            // implicitly move padding inside swizzles
            const ordered = [...Array(range / _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32()).keys()].map(i => i + offset / _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
            return Addr.override(src, ordered);
        },
        shrink(src, size) {
            return Addr.sub(src, 0, size);
        }
    };
    const addr = Addr;
    return {
        pc,
        addr,
        instructions,
        debug,
        deref,
        ref,
        alloca,
        icode,
        imove,
        iload,
        iconst_i32,
        iconst_f32,
        iop4,
        iop3,
        iop2,
        iop1,
        push,
        pop,
        open,
        close,
        ret,
        constants,
        uavs,
        depth,
        diag
    };
}


/***/ }),

/***/ "o2sq":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/BaseEmitter.ts ***!
  \***********************************************/
/*! exports provided: BaseEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseEmitter", function() { return BaseEmitter; });
/* harmony import */ var _Output__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Output */ "34N8");

class BaseEmitter {
    constructor() {
        this.blocks = [];
        this.stack = [];
    }
    top() { return this.stack[this.depth() - 1]; }
    depth() {
        return this.stack.length;
    }
    begin() {
        this.stack.push(Object(_Output__WEBPACK_IMPORTED_MODULE_0__["createOutput"])());
    }
    /**
     * @param prologue Move block to the beginning.
     */
    end(prologue = false) {
        if (!prologue) {
            this.blocks.push(this.stack.pop());
        }
        else {
            this.blocks = [this.stack.pop(), ...this.blocks];
        }
    }
    push(pad) {
        this.top().push(pad);
    }
    pop() {
        this.top().pop();
    }
    emitNewline() { this.top().newline(); }
    emitKeyword(kw) { this.top().keyword(kw); }
    emitNoSpace() { this.top().ignoreNextSpace(); }
    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }
    emitChar(char) { this.top().add(char); }
    emitLine(line) {
        this.emitChar(line);
        this.emitNewline();
    }
    toString() {
        return this.blocks
            .map(block => block.toString())
            .filter(code => !!code)
            .join('\n\n');
    }
    valueOf() {
        return this.toString();
    }
}


/***/ }),

/***/ "oBNb":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/helpers/fn.ts ***!
  \*******************************************/
/*! exports provided: fn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fn", function() { return fn; });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "fb8x");


var fn;
(function (fn) {
    function signatureParam(param, strong) {
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__["type"].signature(param.type, strong)}${param.initExpr ? '?' : ''}`;
    }
    function signature(def, strong = false) {
        const { name, params } = def;
        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signature = signature;
    function signatureEx(def, strong = false) {
        const { name, returnType, params } = def;
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__["type"].signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signatureEx = signatureEx;
    function numArgsRequired(def) {
        return def.params.filter((param) => !param || !param.initExpr).length;
    }
    fn.numArgsRequired = numArgsRequired;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function match(def, args, strong = false) {
        if (!strong && Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(args)) {
            return true;
        }
        if (args.length > def.params.length || numArgsRequired(def) > args.length) {
            return false;
        }
        return args.every((arg, i) => (!strong && Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(arg)) ||
            (!strong && Object(_lib_common__WEBPACK_IMPORTED_MODULE_1__["isNull"])(def.params[i].type)) ||
            _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__["type"].equals(arg, def.params[i].type, strong));
    }
    fn.match = match;
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function matchList(funcList, args, strong = false) {
        if (!funcList) {
            return null;
        }
        const res = funcList.filter(func => fn.match(func.def, args, strong));
        if (res.length > 1) {
            return undefined;
        }
        if (res.length === 1) {
            return res[0];
        }
        return null;
    }
    fn.matchList = matchList;
})(fn || (fn = {}));


/***/ }),

/***/ "onqc":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts ***!
  \*****************************************************************/
/*! exports provided: TypeDeclInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeDeclInstruction", function() { return TypeDeclInstruction; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "mXWi");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




// TODO: add description comment.
class TypeDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__["DeclInstruction"] {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_TypeDecl, ...settings });
        this.type = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(type, this);
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(this.type));
    }
    get name() {
        return this.type.name;
    }
    toCode() {
        return this.type.toDeclString() + ";";
    }
}


/***/ }),

/***/ "oof7":
/*!*****************************************!*\
  !*** ./src/lib/fx/bytecode/Bytecode.ts ***!
  \*****************************************/
/*! exports provided: CBUFFER0_REGISTER, INPUT0_REGISTER, UAV0_REGISTER, UAV_TOTAL, INPUT_TOTAL, CBUFFER_TOTAL, translate, translateExpression */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CBUFFER0_REGISTER", function() { return CBUFFER0_REGISTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INPUT0_REGISTER", function() { return INPUT0_REGISTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UAV0_REGISTER", function() { return UAV0_REGISTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UAV_TOTAL", function() { return UAV_TOTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INPUT_TOTAL", function() { return INPUT_TOTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CBUFFER_TOTAL", function() { return CBUFFER_TOTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateExpression", function() { return translateExpression; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "0DIJ");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bytecode */ "N9P3");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "BW2l");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/Diagnostics */ "/zHR");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./common */ "p34+");
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Context */ "nImT");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PromisedAddress */ "m5Cl");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sizeof */ "ihHD");













const CBUFFER0_REGISTER = 0;
const INPUT0_REGISTER = 1;
const UAV0_REGISTER = 17;
const UAV_TOTAL = 33 - UAV0_REGISTER;
const INPUT_TOTAL = UAV_TOTAL - INPUT0_REGISTER;
const CBUFFER_TOTAL = INPUT0_REGISTER - CBUFFER0_REGISTER;
const UNRESOLVED_JUMP_LOCATION = -1;
function writeString(u8data, offset, value) {
    u8data.set(Object(_common__WEBPACK_IMPORTED_MODULE_8__["i32ToU8Array"])(value.length), offset);
    offset += 4;
    u8data.set(value.split('').map(c => c.charCodeAt(0)), offset);
    offset += value.length;
    return offset;
}
function writeInt(u8data, offset, value) {
    u8data.set(Object(_common__WEBPACK_IMPORTED_MODULE_8__["i32ToU8Array"])(value), offset);
    offset += 4;
    return offset;
}
// TODO: rewrite with cleaner code
function constLayoutChunk(ctx) {
    const { constants } = ctx;
    const reflection = constants.dump();
    const byteLength = 4 /* names.length */ +
        reflection.map(entry => entry.name.length +
            entry.type.length +
            entry.semantic.length +
            4 + /* sizeof(name.length) */
            4 + /* sizeof(type.length) */
            4 + /* sizeof(semantic.length) */
            4 + /* sizeof(addr) */
            4 + /* sizeof(size) */
            4 /* sizeof(type.length) */).reduce((prev, curr) => prev + curr, 0);
    const size = (byteLength + 4) >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EChunkType"].k_Layout, size];
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    const u8data = new Uint8Array(data.buffer, 8 /* int header type + int size */);
    let written = writeInt(u8data, 0, reflection.length);
    for (let i = 0; i < reflection.length; ++i) {
        const { name, offset, type, size, semantic } = reflection[i];
        written = writeString(u8data, written, name);
        written = writeString(u8data, written, type);
        written = writeString(u8data, written, semantic || '');
        written = writeInt(u8data, written, offset);
        written = writeInt(u8data, written, size);
    }
    // console.log('after write', u8data.length, 'bytes', written);
    return data.buffer;
}
function constChunk(ctx) {
    const { constants } = ctx;
    const mem = constants.data;
    const size = mem.byteLength >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EChunkType"].k_Constants, size];
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])((size << 2) == mem.byteLength);
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    data.set(new Uint32Array(mem.byteArray.buffer, 0, mem.byteLength >> 2), chunkHeader.length);
    return data.buffer;
}
function codeChunk(ctx) {
    const { instructions } = ctx;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EChunkType"].k_Code, instructions.length];
    const data = new Uint32Array(chunkHeader.length + instructions.length);
    data.set(chunkHeader);
    data.set(instructions.data, chunkHeader.length);
    return data.buffer;
}
function binary(ctx) {
    const chunks = [constLayoutChunk(ctx), constChunk(ctx), codeChunk(ctx)].map(ch => new Uint8Array(ch));
    const byteLength = chunks.map(x => x.byteLength).reduce((a, b) => a + b);
    let data = new Uint8Array(byteLength);
    let offset = 0;
    chunks.forEach(ch => {
        data.set(ch, offset);
        offset += ch.byteLength;
    });
    return data;
}
function translateProgram(ctx, fn) {
    const { constants, debug, alloca, push, pop, addr, imove, ref } = ctx;
    // NOTE: it does nothing at the momemt :/
    debug.beginCompilationUnit('[todo]', fn.def.returnType);
    // simulate function call()
    const fdef = fn.def;
    let ret = alloca(fdef.returnType.size);
    push(fn, ret);
    // TODO: use the same code as FunctionCall;
    // loading of all non-inpt parameters to registers
    for (let i = 0; i < fdef.params.length; ++i) {
        const param = fdef.params[i];
        if (param.type.hasUsage('out') || param.type.hasUsage('inout')) {
            continue;
        }
        const inputIndex = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["variable"].parameterIndex(param) + INPUT0_REGISTER;
        const size = param.type.size;
        const src = addr.loc({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Input, inputIndex, addr: 0, size });
        const dest = alloca(size);
        imove(dest, src);
        debug.map(fdef); // FIXME: is it ok?
        ref(param, dest);
    }
    translateUnknown(ctx, fn);
    pop();
    debug.endCompilationUnit();
    let code = binary(ctx); // TODO: stay only binary view
    let cdl = debug.dump(); // code debug layout;
    return {
        code,
        cdl // same as PDB
    };
}
function translateUnknown(ctx, instr) {
    const { pc, diag, constants, uavs, alloca, addr, debug, push, pop, open, close, deref, ref, icode, imove, iop4, iop3, iop2, iop1, iload, iconst_i32, iconst_f32, ret, depth, instructions } = ctx;
    // NOTE: pc - number of written instructions
    // NOTE: rc - number of occupied registers
    const isEntryPoint = () => depth() === 1;
    const intrinsics = {
        /**
         * Float based arithmetics
         * vector [op] vector | vector [op] scalar | scalar [op] vector
         */
        arithf(opName, dest, left, right) {
            const size = Math.max(left.size, right.size);
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
            // handle case: scalar * vector => scalar.xxxx * vector
            if (left.size != right.size) {
                if (left.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()) {
                    left = addr.override(left, Array(n).fill(0));
                }
                else if (right.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()) {
                    right = addr.override(right, Array(n).fill(0));
                }
                else {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'vectors with differen length cannot be multipled');
                }
            }
            const opFloatMap = {
                '+': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Add,
                '-': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sub,
                '*': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Mul,
                '/': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Div
            };
            const op = opFloatMap[opName];
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(op)) {
                diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedArithmeticExpr, {});
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
            }
            iop3(op, dest, left, right);
            return dest;
        },
        // TODO: merhe with function above
        arithi(opName, dest, left, right) {
            const size = Math.max(left.size, right.size);
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
            // handle case: scalar * vector => scalar.xxxx * vector
            if (left.size !== right.size) {
                if (left.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()) {
                    left = addr.override(left, Array(n).fill(0));
                }
                else if (right.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()) {
                    right = addr.override(right, Array(n).fill(0));
                }
                else {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'vectors with differen length cannot be multipled');
                }
            }
            const opIntMap = {
                '+': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Add,
                '-': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Sub,
                '*': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Mul,
                '/': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Div
            };
            const op = opIntMap[opName];
            if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(op)) {
                diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedArithmeticExpr, {});
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
            }
            iop3(op, dest, left, right);
            return dest;
        },
        mulf: (dest, left, right) => intrinsics.arithf('*', dest, left, right),
        divf: (dest, left, right) => intrinsics.arithf('/', dest, left, right),
        addf: (dest, left, right) => intrinsics.arithf('+', dest, left, right),
        subf: (dest, left, right) => intrinsics.arithf('-', dest, left, right),
        muli: (dest, left, right) => intrinsics.arithi('*', dest, left, right),
        divi: (dest, left, right) => intrinsics.arithi('/', dest, left, right),
        addi: (dest, left, right) => intrinsics.arithi('+', dest, left, right),
        subi: (dest, left, right) => intrinsics.arithi('-', dest, left, right),
        dotf(dest, left, right) {
            let temp = alloca(Math.max(left.size, right.size));
            let mlr = intrinsics.mulf(temp, left, right);
            let n = mlr.size / _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
            // copy first element of 'mlr' to dest
            imove(dest, addr.shrink(mlr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()));
            for (let i = 1; i < n; ++i) {
                let padding = i * _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
                let size = _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
                intrinsics.addf(dest, dest, addr.sub(mlr, padding, size));
            }
            return dest;
        },
        /** dest = a + b * c */
        madi(dest, a, b, c) {
            iop4(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Mad, dest, a, b, c);
            return dest;
        },
        noti(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Not, dest, src);
            return dest;
        },
        mini(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Min, dest, left, right);
            return dest;
        },
        maxi(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Max, dest, left, right);
            return dest;
        },
        fracf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Frac, dest, src);
            return dest;
        },
        floorf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Floor, dest, src);
            return dest;
        },
        ceilf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Ceil, dest, src);
            return dest;
        },
        sinf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sin, dest, src);
            return dest;
        },
        cosf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Cos, dest, src);
            return dest;
        },
        absf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Abs, dest, src);
            return dest;
        },
        sqrtf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Sqrt, dest, src);
            return dest;
        },
        minf(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Min, dest, left, right);
            return dest;
        },
        maxf(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32Max, dest, left, right);
            return dest;
        },
        lengthf(dest, src) {
            intrinsics.dotf(dest, src, src);
            intrinsics.sqrtf(dest, dest);
            return dest;
        },
        normalizef(dest, src) {
            const len = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32());
            intrinsics.lengthf(len, src);
            intrinsics.divf(dest, src, len);
            return dest;
        },
        lerpf(dest, from, to, k) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(from.size === to.size);
            const size = from.size;
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32();
            const swizzle = Array(n).fill(0);
            let one = iconst_f32(1.0);
            // todo: fix bu with vectored koef.
            let kInv;
            if (k.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32()) {
                kInv = intrinsics.subf(one, one, k);
            }
            else {
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(k.size === from.size);
                one = addr.override(one, swizzle);
                kInv = intrinsics.subf(alloca(dest.size), one, k);
            }
            let temp = alloca(size);
            intrinsics.mulf(temp, to, k);
            intrinsics.mulf(dest, from, kInv);
            intrinsics.addf(dest, dest, temp);
            return dest;
        }
    };
    function resolveAddressType(decl) {
        if (decl.isParameter()) {
            if (decl.type.hasUsage('out') || decl.type.hasUsage('inout')) {
                // entry point function can refer to input memory, for ex. vertex shader
                return isEntryPoint() ? _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Input : _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers;
            }
        }
        if (decl.isGlobal()) {
            if (decl.type.isUniform()) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Input;
            }
            if (decl.type.isUAV()) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Input;
            }
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `could not resolve address type for '${decl.toCode()}'`);
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(decl.isLocal());
        return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers;
    }
    const POSTFIX_COMPONENT_MAP = {
        'r': 0, 'x': 0, 's': 0,
        'g': 1, 'y': 1, 't': 1,
        'b': 2, 'z': 2, 'p': 2,
        'a': 3, 'w': 3, 'q': 3
    };
    const checkPostfixNameForSwizzling = (postfixName) => postfixName
        .split('')
        .map(c => POSTFIX_COMPONENT_MAP[c])
        .map(i => i >= 0 && i < 4)
        .reduce((accum, val) => accum && val);
    // xxwy => [0, 0, 3, 1]
    const swizzlePatternFromName = (postfixName) => postfixName.split('').map(c => POSTFIX_COMPONENT_MAP[c]);
    // const swizzlePatternFromPadding = (padding: number, size: number) => {
    //     assert(padding % sizeof.i32() === 0);
    //     assert(size % sizeof.i32() === 0);
    //     return [...Array(size / sizeof.i32()).keys()].map(i => i + padding / sizeof.i32());
    // };
    function iintrinsic(call) {
        const fdecl = call.decl;
        const fdef = fdecl.def;
        const retType = fdef.returnType;
        const dest = alloca(retType.size);
        let forceLoadArgumentsToRegisters;
        switch (fdecl.name) {
            case 'InterlockedAdd':
                // expected InterlockedAdd(UAV pointer [uint/int], any [uint/int], any [uint/int])
                forceLoadArgumentsToRegisters = false;
                break;
            default:
                forceLoadArgumentsToRegisters = true;
        }
        const args = preloadArguments(fdef, forceLoadArgumentsToRegisters);
        // TODO: add support for INT type
        function preloadArguments(fdef, forceLoad) {
            const args = [];
            for (let i = 0; i < fdef.params.length; ++i) {
                const arg = call.args[i];
                let argAddr = raddr(arg);
                if (argAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers && forceLoad) {
                    argAddr = iload(argAddr);
                }
                args.push(argAddr);
            }
            return args;
        }
        switch (fdecl.name) {
            case 'asuint':
            case 'asfloat':
            case 'asint':
                // NOTE: nothing todo
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return args[0];
            case 'mul':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 2);
                return intrinsics.mulf(dest, args[0], args[1]);
            case 'dot':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 2 && dest.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32());
                return intrinsics.dotf(dest, args[0], args[1]);
            case 'frac':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.fracf(dest, args[0]);
            case 'sin':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.sinf(dest, args[0]);
            case 'cos':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.cosf(dest, args[0]);
            case 'abs':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.absf(dest, args[0]);
            case 'sqrt':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.sqrtf(dest, args[0]);
            case 'normalize':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.normalizef(dest, args[0]);
            case 'length':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.lengthf(dest, args[0]);
            case 'floor':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.floorf(dest, args[0]);
            case 'ceil':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 1);
                return intrinsics.ceilf(dest, args[0]);
            case 'min':
                // TODO: separate INT/FLOAT intrisics
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isFloatBasedType"](fdef.params[0].type)) {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 2);
                    return intrinsics.minf(dest, args[0], args[1]);
                }
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](fdef.params[0].type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isUIntBasedType"](fdef.params[0].type));
                // handle INT/UINT params as int intrinsic
                return intrinsics.mini(dest, args[0], args[1]);
            case 'max':
                // TODO: separate INT/FLOAT intrisics
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isFloatBasedType"](fdef.params[0].type)) {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 2);
                    return intrinsics.maxf(dest, args[0], args[1]);
                }
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](fdef.params[0].type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isUIntBasedType"](fdef.params[0].type));
                // handle INT/UINT params as int intrinsic
                return intrinsics.maxi(dest, args[0], args[1]);
            case 'lerp':
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 3);
                return intrinsics.lerpf(dest, args[0], args[1], args[2]);
            case 'InterlockedAdd':
                {
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(fdef.params.length === 3);
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args[0].type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_PointerInput, 'destination must be UAV address');
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args[0].size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32(), 'only int/uint values are supported');
                    if (args[1].type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        args[1] = iload(args[1]);
                    }
                    let originalAddr = args[2];
                    if (args[2].type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        originalAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                    }
                    imove(originalAddr, args[0]);
                    const changedAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32()), originalAddr, args[1]);
                    imove(args[0], changedAddr);
                    if (args[2] !== originalAddr) {
                        imove(args[2], originalAddr);
                    }
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                }
            //
            // UAVs
            //
            /** @returns: The post-decremented counter value. */
            case 'DecrementCounter':
                {
                    const uav = call.callee;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                    const valueAddr = iload(uavCounterAddr);
                    const nextValueAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32()), valueAddr, iconst_i32(-1));
                    imove(uavCounterAddr, nextValueAddr);
                    return nextValueAddr;
                }
            /** @returns: The pre-incremented counter value. */
            case 'IncrementCounter':
                {
                    const uav = call.callee;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                    const valueAddr = iload(uavCounterAddr);
                    const nextValueAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32()), valueAddr, iconst_i32(+1));
                    imove(uavCounterAddr, nextValueAddr);
                    return valueAddr;
                }
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
            case 'Append':
                {
                    const { callee: uav, args } = call;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(args.length === 1);
                    const srcAddr = raddr(args[0]);
                    const valueAddr = iload(uavCounterAddr);
                    const arrayElementSize = args[0].type.size;
                    const uavDataAddr = addr.sub(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                    const elementPointer = addr.subPointer(uavDataAddr, valueAddr, arrayElementSize);
                    imove(elementPointer, srcAddr);
                    // TODO: replace with intrinsics.inc();
                    intrinsics.addi(valueAddr, valueAddr, iconst_i32(1));
                    imove(uavCounterAddr, valueAddr);
                    return elementPointer;
                }
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
        }
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, `unsupported intrinsic found '${fdecl.name}'`);
        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
    }
    /** resolve address => returns address of temprary result of expression */
    function raddr(expr) {
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_InitExpr:
                {
                    const init = expr;
                    if (init.isArray()) {
                        diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedExprType, {});
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                    }
                    let arg = init.args[0];
                    return raddr(arg);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_BoolExpr:
                {
                    const i32 = expr.value ? 1 : 0;
                    return iconst_i32(i32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_IntExpr:
                {
                    const i32 = expr.value;
                    return iconst_i32(i32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_FloatExpr:
                {
                    const f32 = expr.value;
                    return iconst_f32(f32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_IdExpr:
                {
                    let id = expr;
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(id.decl === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["expression"].unwind(id));
                    const size = id.decl.type.size;
                    const decl = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["expression"].unwind(id);
                    const addrType = resolveAddressType(decl);
                    switch (addrType) {
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers:
                            {
                                return deref(id.decl);
                            }
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Input:
                            {
                                // CBUFFER0_REGISTER input is always being used for hidden constant buffer (uniform constants)
                                if (decl.type.isUniform()) {
                                    return constants.deref(decl);
                                }
                                if (decl.type.isUAV()) {
                                    return uavs.deref(decl);
                                }
                                // implies that each parameter is loaded from its stream, so 
                                // the offset is always zero. 
                                // Otherwise use 'variable.getParameterOffset(decl);'
                                // in order to determ correct offset between parameters
                                const offset = 0;
                                const src = offset;
                                const inputIndex = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["variable"].parameterIndex(decl) + INPUT0_REGISTER;
                                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["variable"].parameterIndex(decl) < INPUT_TOTAL);
                                return addr.loc({ inputIndex, addr: src, size, type: addrType });
                            }
                    }
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported branch found');
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ComplexExpr:
                return raddr(expr.expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ArithmeticExpr:
                {
                    const arithExpr = expr;
                    const dest = alloca(arithExpr.type.size);
                    const opName = arithExpr.operator;
                    const left = arithExpr.left;
                    const right = arithExpr.right;
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isScalarType"](left.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isVectorType"](left.type));
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isScalarType"](right.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isVectorType"](right.type));
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isFloatBasedType"](left.type)) {
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isFloatBasedType"](right.type));
                        intrinsics.arithf(opName, dest, leftAddr, rightAddr);
                    }
                    else if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](left.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isUIntBasedType"](left.type)) {
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](right.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isUIntBasedType"](right.type));
                        intrinsics.arithi(opName, dest, leftAddr, rightAddr);
                    }
                    else {
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                    }
                    debug.map(arithExpr);
                    return dest;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_AssignmentExpr:
                {
                    const assigment = expr;
                    const size = assigment.type.size;
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(size % _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32() === 0);
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(assigment.operator === '=');
                    // left address can be both from the registers and in the external memory
                    const leftAddr = raddr(assigment.left);
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(assigment.right), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"][assigment.right.instructionType]);
                    // right address always from the registers
                    let rightAddr = raddr(assigment.right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(assigment.right);
                    }
                    imove(leftAddr, rightAddr);
                    debug.map(assigment);
                    // breakpoint right after assingment
                    debug.ns();
                    return leftAddr;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_PostfixArithmeticExpr:
                {
                    const postfix = expr;
                    const operand = postfix.expr;
                    const op = postfix.operator;
                    const size = postfix.type.size;
                    let src = raddr(operand);
                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        src = iload(src);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](operand.type)) {
                        switch (op) {
                            case '++':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithi('+', src, src, iconst_i32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithi('-', src, src, iconst_i32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    else {
                        switch (op) {
                            case '++':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithf('+', src, src, iconst_f32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithf('-', src, src, iconst_f32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    console.error(`unsupported type of unary expression found: '${op}'(${postfix.toCode()})`);
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_UnaryExpr:
                {
                    const unary = expr;
                    const operand = unary.expr;
                    const op = unary.operator;
                    const size = unary.type.size;
                    let src = raddr(operand);
                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        src = iload(src);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isBoolBasedType"](operand.type)) {
                        if (op === '!') {
                            const dest = intrinsics.noti(alloca(size), src);
                            debug.map(unary);
                            return dest;
                        }
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isIntBasedType"](operand.type)) {
                        switch (op) {
                            case '-':
                                {
                                    const dest = intrinsics.arithi('*', alloca(size), src, iconst_i32(-1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '+':
                                // nothing todo
                                return src;
                            case '++':
                                {
                                    const dest = intrinsics.arithi('+', src, src, iconst_i32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = intrinsics.arithi('-', src, src, iconst_i32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    else {
                        switch (op) {
                            case '-':
                                {
                                    const dest = intrinsics.arithf('*', alloca(size), src, iconst_f32(-1.0));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '++':
                                {
                                    const dest = intrinsics.arithf('+', src, src, iconst_f32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = intrinsics.arithf('-', src, src, iconst_f32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    console.error(`unsupported type of unary expression found: '${op}'(${unary.toCode()})`);
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_LogicalExpr:
                {
                    const logicExpr = expr;
                    const opMap = {
                        '||': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LogicalOr,
                        '&&': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LogicalAnd
                    };
                    let op = opMap[logicExpr.operator];
                    ;
                    const { left, right } = logicExpr;
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    const size = logicExpr.type.size;
                    const dest = alloca(size);
                    iop3(op, dest, leftAddr, rightAddr);
                    debug.map(logicExpr);
                    return addr.loc({ addr: dest, size });
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_RelationalExpr:
                {
                    const relExpr = expr;
                    const opUintMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32NotEqual // << compare with I32 operator
                    };
                    const opIntMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32NotEqual // ne
                    };
                    const opFloatMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32NotEqual // << compare with I32 operator
                    };
                    let op;
                    let { left, right } = relExpr;
                    let operator = relExpr.operator;
                    // (left > right) => (right < left)
                    if (operator === '>') {
                        operator = '<';
                        [right, left] = [left, right];
                    }
                    // (left <= right) => (right >= left)
                    if (operator === '<=') {
                        operator = '>=';
                        [right, left] = [left, right];
                    }
                    if (left.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"])) {
                        op = opIntMap[operator];
                        // print warning if right type is UINT;
                        if (!right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"]) && !right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"])) {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    else if (left.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"])) {
                        op = opUintMap[operator];
                        // print warning if right type is INT;
                        if (!right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"]) && !right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"])) {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    else if (left.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"])) {
                        op = opFloatMap[operator];
                        if (!right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"])) {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    else if (left.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_BOOL"])) {
                        op = opIntMap[operator];
                        if (!right.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_BOOL"])) {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    if (!op) {
                        diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupportedRelationalExpr, {});
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                    }
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    const size = relExpr.type.size;
                    const dest = alloca(size);
                    iop3(op, dest, leftAddr, rightAddr);
                    debug.map(relExpr);
                    return addr.loc({ addr: dest, size });
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_CastExpr:
                {
                    const castExpr = expr;
                    if (castExpr.isUseless()) {
                        console.warn(`Useless cast found: ${castExpr.toCode()}`);
                        return raddr(castExpr.expr);
                    }
                    const srcType = castExpr.expr.type;
                    const dstType = castExpr.type;
                    let op;
                    // TODO: add support for vectors
                    if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_BOOL"])) {
                        const size = castExpr.type.size;
                        const dest = alloca(size);
                        let exprAddr = raddr(castExpr.expr);
                        if (exprAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                            exprAddr = iload(exprAddr);
                        }
                        iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32NotEqual, dest, exprAddr, iconst_i32(0));
                        debug.map(castExpr);
                        return addr.loc({ addr: dest, size });
                    }
                    if (srcType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"])) {
                        if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"])) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32ToI32;
                        }
                        else if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"])) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_F32ToU32;
                        }
                        else {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    else if (srcType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"])) {
                        if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"])) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_I32ToF32;
                        }
                        else if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"])) {
                            // useless conversion
                            return raddr(castExpr.expr);
                        }
                        else {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    else if (srcType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"])) {
                        if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_FLOAT"])) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_U32ToF32;
                        }
                        else if (dstType.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"])) {
                            // useless conversion
                            return raddr(castExpr.expr);
                        }
                        else {
                            diag.error(_Context__WEBPACK_IMPORTED_MODULE_9__["EErrors"].k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                        }
                    }
                    const size = castExpr.type.size;
                    const dest = alloca(size);
                    let exprAddr = raddr(castExpr.expr);
                    if (exprAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        exprAddr = iload(exprAddr);
                    }
                    iop2(op, dest, exprAddr);
                    debug.map(castExpr);
                    return addr.loc({ addr: dest, size });
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_PostfixIndexExpr:
                {
                    const postfixIndex = expr;
                    // element[index]
                    const { element, index } = postfixIndex;
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].equals(index.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_INT"]) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].equals(index.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_UINT"]));
                    // assert(element.type.isNotBaseArray());
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(element.type.arrayElementType));
                    if ( /*index.isConstExpr()*/false) {}
                    else {
                        let elementAddr = raddr(element);
                        // NOTE: element can be not loaded yet
                        //       we don't want to load all the array (all 'element' object)
                        if (element.type.isUAV()) {
                            // some UAVs can have hidden counter at the beginning of the data
                            // in such cases we need to step forward before fetching the data
                            elementAddr = addr.sub(elementAddr, _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32());
                        }
                        // sizeof(element[i])
                        let arrayElementSize = element.type.arrayElementType.size;
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(arrayElementSize % _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32() === 0, `all sizes must be multiple of ${_sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32()}`);
                        // index => index of element in the array (element)
                        let indexAddr = raddr(index);
                        // NOTE: index can be unresolved yet
                        const dest = addr.subPointer(elementAddr, indexAddr, arrayElementSize);
                        debug.map(postfixIndex);
                        return dest;
                    }
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID; // << FIXME
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_PostfixPointExpr:
                {
                    const point = expr;
                    const { element, postfix } = point;
                    const elementAddr = raddr(element);
                    let { size, padding } = postfix.type;
                    let swizzle = null;
                    // Does expression have dynamic indexing?
                    // TODO: rename isConstExpr() method to something more suitable
                    if (point.isConstExpr()) {
                        // handle such types like float2, float3, int2, int3 etc.
                        // all system types except matrix and samplers support swizzling
                        const isSwizzlingSupported = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isVectorType"](element.type) ||
                            _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isScalarType"](element.type);
                        if (isSwizzlingSupported) {
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(checkPostfixNameForSwizzling(postfix.name));
                            swizzle = swizzlePatternFromName(postfix.name);
                            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(padding === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_PADDING, 'padding of swizzled components must be undefined');
                            // If loading not allowed then we are inside the recursive call to calculate the final address
                            // so in this case we just have to return address with padding added to it.
                            return addr.override(elementAddr, swizzle);
                        }
                        else {
                            return addr.sub(elementAddr, padding, size);
                        }
                    }
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'not implemented!');
                    // todo: add support for move_reg_ptr, move_ptr_ptr, move_ptr_reg
                    return elementAddr;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_FunctionCallExpr:
                {
                    const call = expr;
                    const fdecl = call.decl;
                    const fdef = fdecl.def;
                    const retType = fdef.returnType;
                    if (fdecl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_SystemFunctionDecl) {
                        // breakpoint before intrinsic call
                        // TODO: is it's breakpoint really usefull?
                        debug.ns();
                        const dest = iintrinsic(call);
                        debug.map(call);
                        return dest;
                    }
                    const ret = alloca(retType.size);
                    const params = fdef.params;
                    const args = params
                        .map((param, i) => i < call.args.length ? call.args[i] : param.initExpr);
                    const paramSources = args
                        .map(arg => raddr(arg))
                        .map(arg => arg.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers ? arg : iload(arg));
                    push(fdecl, ret);
                    for (let i = 0; i < fdef.params.length; ++i) {
                        const src = paramSources[i];
                        // by default all parameters are interpreted as 'in'
                        if (params[i].type.hasUsage('out') || params[i].type.hasUsage('inout')) {
                            ref(params[i], src);
                        }
                        else {
                            // todo: handle expressions like "float4 v = 5.0;"
                            const size = params[i].type.size;
                            const dest = alloca(size);
                            imove(dest, src);
                            debug.map(args[i]);
                            ref(params[i], dest);
                        }
                    }
                    translateUnknown(ctx, fdecl);
                    pop();
                    return ret;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ConstructorCallExpr:
                {
                    const ctorCall = expr;
                    // todo: add correct constructor call support for builtin type at the level of analyzer
                    const type = ctorCall.type;
                    const args = ctorCall.args;
                    const size = type.size;
                    const dest = alloca(size);
                    switch (type.name) {
                        case 'float':
                        case 'float1':
                        case 'float2':
                        case 'float3':
                        case 'float4':
                        case 'int':
                        case 'int1':
                        case 'int2':
                        case 'int3':
                        case 'int4':
                        case 'uint':
                        case 'uint1':
                        case 'uint2':
                        case 'uint3':
                        case 'uint4':
                            switch (args.length) {
                                case 1:
                                    // TODO: convert float to int if necessary
                                    // handling for the case single same type argument and multiple floats
                                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(args[0]), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"][args[0].instructionType]);
                                    let src = raddr(args[0]);
                                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                                        src = iload(src);
                                        debug.map(args[0]);
                                    }
                                    const elementSize = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["isFloatBasedType"](type) ? _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].f32() : _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].i32();
                                    // FIXME: use 'length' property
                                    let length = type.size / elementSize;
                                    let swizzle = null;
                                    if (src.size === elementSize) {
                                        swizzle = [...Array(length).fill(0)];
                                        src = addr.override(src, swizzle);
                                    }
                                    else {
                                        swizzle = [...Array(length).keys()];
                                        src = addr.override(src, swizzle);
                                    }
                                    imove(dest, src);
                                    debug.map(ctorCall);
                                    break;
                                default:
                                    let padding = 0;
                                    for (let i = 0; i < args.length; ++i) {
                                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(args[i]), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"][args[i].instructionType]);
                                        let src = raddr(args[i]);
                                        if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                                            src = iload(src);
                                            debug.map(args[i]);
                                        }
                                        imove(addr.sub(dest, padding, src.size), src);
                                        debug.map(ctorCall);
                                        padding += args[i].type.size;
                                    }
                                    break;
                            }
                            return addr.loc({ addr: dest, size });
                        default:
                    }
                    console.warn(`Unknown constructor found: ${ctorCall.toCode()}`);
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
                }
                break;
            default:
                console.warn(`Unknown expression found: ${expr.instructionName} (${expr.toCode()})`);
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_10__["default"].INVALID;
        }
    }
    // 
    // Handle all instruction types
    //
    function translate(instr) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(instr)) {
            return;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_VariableDecl:
                {
                    let decl = instr;
                    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(decl.initExpr)) {
                        // There is no initial value, but allocation should be done anyway
                        // in order to assign register for this variable.
                        ref(decl, alloca(decl.type.size));
                        return;
                    }
                    /*
                    0: int a = 1;           | 0x00: load %a   #1        | NS 0
                    1: int b = 2;           | 0x01: load %b   #2        | NS 1
                    2: int c = a + b * 10;  | 0x02: load %t0  #10       |
                                            | 0x03: mul  $t1  %b %t0    |
                                            | 0x02: add  %c   %a %t1    | NS 2
                    3: return c;            | 0x03: move %rax %c        | NS 3
                                            | 0x04: ret                 |
                                            |
                    */
                    let dest = raddr(decl.initExpr);
                    if (dest.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        //breakpoint before variable initialization
                        debug.ns();
                        dest = iload(dest);
                        debug.map(decl.initExpr);
                        // breakpoint right after variable initialization
                        debug.ns();
                    }
                    ref(decl, dest);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_DeclStmt:
                {
                    let stmt = instr;
                    stmt.declList.forEach(translate);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_IfStmt:
                {
                    // [out of if code]
                    //  jif:
                    // jump: 'jump to end of if'    ---+
                    // ....                            |
                    // ....                            |
                    // ....                            |
                    // [out of if code]             <--+
                    // [out of if code]
                    //  jif:
                    // jump: 'jump to contrary'     ---+
                    // ....                            |
                    // ....                            |
                    // jump:  'jump to skip contraty'  |  ---+
                    // ....                         <--+     |
                    // ....                                  |
                    // [out of if code]                   <--+ 
                    let ifStmt = instr;
                    let { cond, conseq, contrary } = ifStmt;
                    let condAddr = raddr(cond);
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(condAddr.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].bool());
                    if (condAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        condAddr = iload(condAddr);
                    }
                    iop1(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_JumpIf, condAddr);
                    let unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, UNRESOLVED_JUMP_LOCATION);
                    translate(conseq);
                    // jump co contrary or out of if
                    let jumpTo = pc() + (contrary ? 1 : 0);
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, [jumpTo]);
                    if (contrary) {
                        unresolvedJump = pc();
                        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, UNRESOLVED_JUMP_LOCATION);
                        translate(contrary);
                        // jump to skip contrary
                        jumpTo = pc();
                        instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, [jumpTo]);
                    }
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ReturnStmt:
                {
                    let retStmt = instr;
                    const expr = retStmt.expr;
                    if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(expr)) {
                        let src = raddr(expr);
                        if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                            src = iload(src);
                            debug.map(expr);
                        }
                        const dest = ret();
                        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(src.size === ret().size);
                        imove(dest, src);
                        debug.map(expr);
                    }
                    // breakpoint before leaving function
                    debug.ns();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Ret);
                    debug.map(retStmt);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_StmtBlock:
                {
                    open(); // open block
                    let block = instr;
                    for (let stmt of block.stmtList) {
                        translate(stmt);
                    }
                    close(); // close block
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_FunctionDecl:
                {
                    let func = instr;
                    // resolve function's implementation
                    func = func.scope.findFunctionInScope(func);
                    let def = func.def; // todo: handle all arguments!!
                    let impl = func.impl;
                    translate(impl);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ExprStmt:
                {
                    let stmt = instr;
                    raddr(stmt.expr);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_6__["EInstructionTypes"].k_ForStmt:
                {
                    const loop = instr;
                    const { init, cond, step, body } = loop;
                    open(); // open block
                    // TODO: make the code more readable
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(init)) {
                        // translate as expression
                        raddr(init);
                    }
                    else {
                        // translate as varaible declaration
                        translate(init);
                    }
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(cond.type.isEqual(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__["T_BOOL"]));
                    // before cond:
                    let beforeCondPc = pc();
                    let condAddr = raddr(cond);
                    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(condAddr.size === _sizeof__WEBPACK_IMPORTED_MODULE_11__["default"].bool());
                    if (condAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__["EAddrType"].k_Registers) {
                        condAddr = iload(condAddr);
                    }
                    // TOOD: add support for break statement.
                    iop1(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_JumpIf, condAddr);
                    let unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, UNRESOLVED_JUMP_LOCATION);
                    translate(body);
                    // step:
                    raddr(step);
                    // goto to before condition
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, beforeCondPc);
                    // out of loop:
                    let outofLoopPc = pc();
                    // resolve jump in case of invalid condition => go to out of loop
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_5__["EOperation"].k_Jump, [outofLoopPc]);
                    close(); // close block
                    return;
                }
            default:
                console.warn(`Unknown statement found: ${instr.instructionName} (${instr.toCode()})`);
        }
    }
    translate(instr);
}
const hex2 = (v) => `0x${v.toString(16).padStart(2, '0')}`;
const hex4 = (v) => `0x${v.toString(16).padStart(4, '0')}`;
// const reg = (v: number) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`;    // register address;
// const addr = (v: number) => `%${hex4(v >>> 0)}%`;                   // global memory address;
function translate(entryFunc) {
    let ctx = Object(_Context__WEBPACK_IMPORTED_MODULE_9__["ContextBuilder"])();
    let res = null;
    try {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(entryFunc)) {
            console.error(`Entry point '${entryFunc.name}' not found.`);
            return null;
        }
        res = translateProgram(ctx, entryFunc);
    }
    catch (e) {
        throw e;
        console.error(_Context__WEBPACK_IMPORTED_MODULE_9__["TranslatorDiagnostics"].stringify(ctx.diag.resolve()));
    }
    let report = ctx.diag.resolve();
    if (report.errors) {
        console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__["Diagnostics"].stringify(report));
    }
    return res;
}
async function translateExpression(expr, document) {
    const uri = `://expression`;
    const anonymousFuncName = `anonymous`;
    const source = `auto ${anonymousFuncName}() { return (${expr}); }`;
    const documentEx = await Object(_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__["createFXSLDocument"])({ source, uri }, undefined, document);
    if (!documentEx.diagnosticReport.errors) {
        return translate(documentEx.root.scope.findFunction(anonymousFuncName, null));
    }
    console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__["Diagnostics"].stringify(documentEx.diagnosticReport));
    return null;
}


/***/ }),

/***/ "oseZ":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtInstruction.ts ***!
  \*************************************************************/
/*! exports provided: StmtInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StmtInstruction", function() { return StmtInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


/**
 * Represent all kind of statements
 */
class StmtInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Stmt, ...settings });
    }
}


/***/ }),

/***/ "p34+":
/*!***************************************!*\
  !*** ./src/lib/fx/bytecode/common.ts ***!
  \***************************************/
/*! exports provided: REG_INVALID, DEFAULT_ENTRY_POINT_NAME, sname, i32ToU8Array, u8ArrayToI32, u8ArrayAsI32, u8ArrayAsF32, f32Asi32, i32Asf32, u32Asf32, i32Asu32, u32Asi32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REG_INVALID", function() { return REG_INVALID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ENTRY_POINT_NAME", function() { return DEFAULT_ENTRY_POINT_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sname", function() { return sname; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i32ToU8Array", function() { return i32ToU8Array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u8ArrayToI32", function() { return u8ArrayToI32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u8ArrayAsI32", function() { return u8ArrayAsI32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u8ArrayAsF32", function() { return u8ArrayAsF32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f32Asi32", function() { return f32Asi32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i32Asf32", function() { return i32Asf32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u32Asf32", function() { return u32Asf32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i32Asu32", function() { return i32Asu32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u32Asi32", function() { return u32Asi32; });
const REG_INVALID = (-1 >>> 0);
const DEFAULT_ENTRY_POINT_NAME = 'main';
// symbol name id generation;
const sname = {
    i32: (i32) => `%i32:${i32}`,
    f32: (f32) => `%f32:${f32}`,
    var: (vdecl) => `${vdecl.name}:${vdecl.instructionID}`,
    fun: (fdecl) => `${fdecl.name}:${fdecl.instructionID}`,
};
// aux functions for packing routines
const i32ToU8Array = (i32) => Array(4).fill(0).map((u8, i, self) => (i32 >> (i) * 8) & (0xff));
const u8ArrayToI32 = (arr) => arr.reduce((acc, cv, i, self) => acc | (cv << (i) * 8), 0);
// Uint8Array => Int32Array conversion
const u8ArrayAsI32 = (arr) => ((arr[0]) | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24));
const u8ArrayAsF32 = (arr) => new Float32Array(arr.buffer, arr.byteOffset)[0];
const ab = new ArrayBuffer(4);
const f32a = new Float32Array(ab);
const i32a = new Int32Array(ab);
const u32a = new Uint32Array(ab);
function f32Asi32(f32) {
    f32a[0] = f32;
    return i32a[0];
}
function i32Asf32(i32) {
    i32a[0] = i32;
    return f32a[0];
}
function u32Asf32(u32) {
    u32a[0] = u32;
    return f32a[0];
}
function i32Asu32(i32) {
    i32a[0] = i32;
    return u32a[0];
}
function u32Asi32(u32) {
    u32a[0] = u32;
    return i32a[0];
}


/***/ }),

/***/ "pq1u":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AttributeInstruction.ts ***!
  \******************************************************************/
/*! exports provided: AttributeInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeInstruction", function() { return AttributeInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "2b0+");


/**
 * Represent attributes:
 *  [numthreads(1, 2, 3)]
 *  [loop]
 *  [branch]
 */
class AttributeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__["Instruction"] {
    constructor({ name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_Attribute, ...settings });
        this.name = name;
        this.args = args;
    }
    toCode() {
        return `[${this.name}${this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})` : ``}]`;
    }
}


/***/ }),

/***/ "pvc7":
/*!***********************************************!*\
  !*** ./src/sandbox/actions/ActionTypeKeys.ts ***!
  \***********************************************/
/*! exports provided: SOURCE_FILE_REQUEST, SOURCE_FILE_LOADED, SOURCE_FILE_LOADING_FAILED, SOURCE_FILE_DROP_STATE, GRAMMAR_CONTENT_SPECIFIED, PARSER_PARAMS_CHANGED, PARSING_PARAMS_CHANGED, SOURCE_CODE_MODIFED, SOURCE_CODE_PARSING_COMPLETE, SOURCE_CODE_ANALYSIS_COMPLETE, SOURCE_CODE_ADD_MARKER, SOURCE_CODE_ADD_MARKER_BATCH, SOURCE_CODE_REMOVE_MARKER, SOURCE_CODE_REMOVE_MARKER_BATCH, SOURCE_CODE_ADD_BREAKPOINT, SOURCE_CODE_REMOVE_BREAKPOINT, DEBUGGER_COMPILE, DEBUGGER_START_DEBUG, DEBUGGER_RESET, DEBUGGER_COLORIZE, DEBUGGER_OPTIONS_CHANGED, PLAYGROUND_EMITER_UPDATE, PLAYGROUND_SELECT_EFFECT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_FILE_REQUEST", function() { return SOURCE_FILE_REQUEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_FILE_LOADED", function() { return SOURCE_FILE_LOADED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_FILE_LOADING_FAILED", function() { return SOURCE_FILE_LOADING_FAILED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_FILE_DROP_STATE", function() { return SOURCE_FILE_DROP_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRAMMAR_CONTENT_SPECIFIED", function() { return GRAMMAR_CONTENT_SPECIFIED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARSER_PARAMS_CHANGED", function() { return PARSER_PARAMS_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARSING_PARAMS_CHANGED", function() { return PARSING_PARAMS_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_MODIFED", function() { return SOURCE_CODE_MODIFED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_PARSING_COMPLETE", function() { return SOURCE_CODE_PARSING_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_ANALYSIS_COMPLETE", function() { return SOURCE_CODE_ANALYSIS_COMPLETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_ADD_MARKER", function() { return SOURCE_CODE_ADD_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_ADD_MARKER_BATCH", function() { return SOURCE_CODE_ADD_MARKER_BATCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_REMOVE_MARKER", function() { return SOURCE_CODE_REMOVE_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_REMOVE_MARKER_BATCH", function() { return SOURCE_CODE_REMOVE_MARKER_BATCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_ADD_BREAKPOINT", function() { return SOURCE_CODE_ADD_BREAKPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE_CODE_REMOVE_BREAKPOINT", function() { return SOURCE_CODE_REMOVE_BREAKPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUGGER_COMPILE", function() { return DEBUGGER_COMPILE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUGGER_START_DEBUG", function() { return DEBUGGER_START_DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUGGER_RESET", function() { return DEBUGGER_RESET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUGGER_COLORIZE", function() { return DEBUGGER_COLORIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUGGER_OPTIONS_CHANGED", function() { return DEBUGGER_OPTIONS_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLAYGROUND_EMITER_UPDATE", function() { return PLAYGROUND_EMITER_UPDATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLAYGROUND_SELECT_EFFECT", function() { return PLAYGROUND_SELECT_EFFECT; });
const SOURCE_FILE_REQUEST = 'source-file-request';
const SOURCE_FILE_LOADED = 'source-file-loaded';
const SOURCE_FILE_LOADING_FAILED = 'source-file-loading-failed';
const SOURCE_FILE_DROP_STATE = 'source-file-drop-state';
const GRAMMAR_CONTENT_SPECIFIED = 'grammar-content-specified';
const PARSER_PARAMS_CHANGED = 'parser-params-changed';
const PARSING_PARAMS_CHANGED = 'parsing-params-changed';
const SOURCE_CODE_MODIFED = 'source-code-modified';
const SOURCE_CODE_PARSING_COMPLETE = 'source-code-parsing-complete';
const SOURCE_CODE_ANALYSIS_COMPLETE = 'source-code-analysis-complete';
const SOURCE_CODE_ADD_MARKER = 'source-code-add-marker';
const SOURCE_CODE_ADD_MARKER_BATCH = 'source-code-add-marker-batch';
const SOURCE_CODE_REMOVE_MARKER = 'source-code-remove-marker';
const SOURCE_CODE_REMOVE_MARKER_BATCH = 'source-code-remove-marker-batch';
const SOURCE_CODE_ADD_BREAKPOINT = 'source-code-add-breakpoint';
const SOURCE_CODE_REMOVE_BREAKPOINT = 'source-code-remove-breakpoint';
const DEBUGGER_COMPILE = 'debugger-compile';
const DEBUGGER_START_DEBUG = 'debugger-start-debug';
// cancel compilation or jut clean up all previous results from store
const DEBUGGER_RESET = 'debugger-reset';
const DEBUGGER_COLORIZE = 'debugger-colorize';
const DEBUGGER_OPTIONS_CHANGED = 'debugger-options-changed';
const PLAYGROUND_EMITER_UPDATE = 'playground-emitter-update';
const PLAYGROUND_SELECT_EFFECT = 'playground-select-effect';


/***/ }),

/***/ "qUwp":
/*!*******************************!*\
  !*** ./src/sandbox/index.tsx ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/SLParser */ "O8iw");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions */ "x6p4");
/* harmony import */ var _sandbox_containers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/containers */ "bB3A");
/* harmony import */ var _sandbox_logic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/logic */ "3uV/");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/router */ "SMK2");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! connected-react-router */ "u4tm");
/* harmony import */ var is_electron_renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! is-electron-renderer */ "Ze1B");
/* harmony import */ var is_electron_renderer__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(is_electron_renderer__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-dom */ "i8i4");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-router-dom */ "55Ip");
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! redux */ "ANjH");
/* harmony import */ var redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! redux-immutable-state-invariant */ "BQ0V");
/* harmony import */ var redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var redux_logger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! redux-logger */ "1mXj");
/* harmony import */ var redux_logger__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(redux_logger__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
















__webpack_require__(/*! semantic-ui-less/semantic.less */ "tDNE");
if (is_electron_renderer__WEBPACK_IMPORTED_MODULE_7__) {
    __webpack_require__(/*! electron-react-devtools */ "FW/+").install();
}
const logger = Object(redux_logger__WEBPACK_IMPORTED_MODULE_14__["createLogger"])({
    collapsed: true,
    diff: false
});
const reduxImmutableState = redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_13___default()({
    ignore: [
        'sourceFile.slastDocument',
        'sourceFile.slDocument',
        'sourceFile.debugger.runtime',
        'sourceFile.emitter'
    ]
});
// todo: add support for retail configuration
const middleware =  true ?
    [/*thunk, */ _sandbox_logic__WEBPACK_IMPORTED_MODULE_3__["default"], logger, reduxImmutableState] :
    undefined;
const store = Object(redux__WEBPACK_IMPORTED_MODULE_12__["createStore"])(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__["default"], Object(redux__WEBPACK_IMPORTED_MODULE_12__["applyMiddleware"])(...middleware));
// const initialState: IStoreState = store.getState();
// const defaultName = initialState.sourceFile.filename;
Object(react_dom__WEBPACK_IMPORTED_MODULE_9__["render"])(react__WEBPACK_IMPORTED_MODULE_8__["createElement"](react_redux__WEBPACK_IMPORTED_MODULE_10__["Provider"], { store: store },
    react__WEBPACK_IMPORTED_MODULE_8__["createElement"](connected_react_router__WEBPACK_IMPORTED_MODULE_6__["ConnectedRouter"], { history: _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_5__["history"] },
        react__WEBPACK_IMPORTED_MODULE_8__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_11__["Switch"], null,
            react__WEBPACK_IMPORTED_MODULE_8__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_11__["Route"], { path: _sandbox_logic__WEBPACK_IMPORTED_MODULE_3__["LOCATION_PATTERN"], component: _sandbox_containers__WEBPACK_IMPORTED_MODULE_2__["App"] }),
            react__WEBPACK_IMPORTED_MODULE_8__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_11__["Route"], { exact: true, path: _sandbox_logic__WEBPACK_IMPORTED_MODULE_3__["LOCATION_NOT_FOUND"] },
                react__WEBPACK_IMPORTED_MODULE_8__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Modal"], { open: true, basic: true, size: 'small' },
                    react__WEBPACK_IMPORTED_MODULE_8__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Header"], { icon: 'archive', content: 'Location not found :/' }),
                    react__WEBPACK_IMPORTED_MODULE_8__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["Modal"].Content, null)))))), document.getElementById('app'));
// make grammar available for editing
store.dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_1__["parser"].setGrammar(Object(_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_0__["defaultSLGrammar"])()));
console.log(`%c Is this running in electron.js?: ${is_electron_renderer__WEBPACK_IMPORTED_MODULE_7__}`, 'background: #222; color: #bada55');
console.log(`%c This is ${is_electron_renderer__WEBPACK_IMPORTED_MODULE_7__ ? 'electron' : 'a web browser'}!!!`, 'background: #222; color: #bada55');
console.log(`%c ver: ${"0.0.1.f10c4fa"} (${"f10c4fa0e5d9bab3d50ac438ba25b6af836afee8"}, ${"develop"}), mode=${"development"}, production=${false}`, 'background: #222; color: #bada55');


/***/ }),

/***/ "rMqy":
/*!****************************!*\
  !*** ./src/lib/uri/uri.ts ***!
  \****************************/
/*! exports provided: resolve, parseDataURI, parse, currentScript, currentPath, here */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDataURI", function() { return parseDataURI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "currentScript", function() { return currentScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "currentPath", function() { return currentPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "here", function() { return here; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "fb8x");
/* harmony import */ var _path_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/path */ "5D93");


class URI {
    constructor(uri) {
        this._scheme = null;
        this._userinfo = null;
        this._host = null;
        this._port = 0;
        this._path = null;
        this._query = null;
        this._fragment = null;
        if (uri) {
            this.set(uri);
        }
    }
    get urn() {
        return (this._path ? this._path : "") +
            (this._query ? '?' + this._query : "") +
            (this._fragment ? '#' + this._fragment : "");
    }
    get url() {
        return (this._scheme ? this._scheme : "") + this.authority;
    }
    get authority() {
        return (this._host ? '//' + (this._userinfo ? this._userinfo + '@' : "") +
            this._host + (this._port ? ':' + this._port : "") : "");
    }
    get scheme() {
        return this._scheme;
    }
    get protocol() {
        if (!this._scheme) {
            return this._scheme;
        }
        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));
    }
    get userInfo() {
        return this._userinfo;
    }
    get host() {
        return this._host;
    }
    set host(sHost) {
        //TODO: check host format
        this._host = sHost;
    }
    get port() {
        return this._port;
    }
    set port(iPort) {
        this._port = iPort;
    }
    get path() {
        return this._path;
    }
    set path(sPath) {
        // debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))), 
        //     "invalid path used: " + sPath);
        //TODO: check path format
        this._path = sPath;
    }
    get query() {
        //TODO: check query format
        return this._query;
    }
    set query(sQuery) {
        this._query = sQuery;
    }
    get fragment() {
        return this._fragment;
    }
    set(data) {
        if (Object(_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(data)) {
            var uri = URI.uriExp.exec(data);
            console.assert(uri !== null, 'Invalid URI format used.\nused uri: ' + data);
            if (!uri) {
                return null;
            }
            this._scheme = uri[1] || null;
            this._userinfo = uri[2] || null;
            this._host = uri[3] || null;
            this._port = parseInt(uri[4]) || null;
            this._path = uri[5] || uri[6] || null;
            this._query = uri[7] || null;
            this._fragment = uri[8] || null;
            return this;
        }
        else if (data instanceof URI) {
            return this.set(data.toString());
        }
        console.error('Unexpected data type was used.');
        return null;
    }
    toString() {
        return this.url + this.urn;
    }
}
//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment
URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
function normalizeURIPath(file) {
    if (!Object(_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(file.path)) {
        if (file.scheme === "filesystem:") {
            var uri = parse(file.path);
            uri.path = _path_path__WEBPACK_IMPORTED_MODULE_1__["normalize"](uri.path);
            file.path = uri.toString();
        }
        else {
            file.path = _path_path__WEBPACK_IMPORTED_MODULE_1__["normalize"](file.path);
        }
    }
    return file;
}
function resolve(from, to = document.location.href) {
    var currentPath = parse(to);
    var file = parse(from);
    var dirname;
    normalizeURIPath(file);
    normalizeURIPath(currentPath);
    if (!Object(_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(file.scheme) || !Object(_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(file.host) || _path_path__WEBPACK_IMPORTED_MODULE_1__["parse"](file.path).isAbsolute()) {
        //another server or absolute path
        return from;
    }
    dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__["parse"](currentPath.path).dirname;
    currentPath.path = dirname ? (dirname + "/" + from) : from;
    return normalizeURIPath(currentPath).toString();
}
function parseDataURI(uri) {
    var re = /^data:([\w\d\-\/]+)?(;charset=[\w\d\-]*)?(;base64)?,(.*)$/;
    var m = uri.match(re);
    return {
        //like [text/plain]
        mediatype: m[1] || null,
        //like [;charset=windows-1251]
        charset: Object(_common__WEBPACK_IMPORTED_MODULE_0__["isString"])(m[2]) ? m[2].substr(9) : null,
        //like [;base64]
        base64: Object(_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(m[3]),
        data: m[4] || null
    };
}
function parse(uri) {
    return new URI(uri);
}
function currentScript() {
    if (Object(_common__WEBPACK_IMPORTED_MODULE_0__["isDef"])(document['currentScript'])) {
        return document['currentScript'];
    }
    var scripts = document.getElementsByTagName("script");
    return scripts[scripts.length - 1];
}
function currentPath() {
    var uri = parse(currentScript().src);
    let dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__["parse"](uri.path).dirname;
    return uri.url + dirname + "/";
}
function here() {
    return new URI(document.location.href);
}


/***/ }),

/***/ "s8BN":
/*!************************************************!*\
  !*** ./src/sandbox/components/ProgramView.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-jss */ "p8yR");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_jss__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");
/* tslint:disable:typedef */
/* tslint:disable:use-simple-attributes */
/* tslint:disable:react-a11y-event-has-role */
/* tslint:disable:no-for-in */
/* tslint:disable:cyclomatic-complexity */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









const styles = {
    parentIcon: {
        '&:hover': {
            textShadow: '1px 1px 1px #ccc'
        }
    }
};
const PropertyStyles = {
    selected: {
    // backgroundColor: `rgba(128, 128, 128, 0.125)`,
    // boxShadow: `0 0 3px rgba(55, 55, 55, 0.33)`,
    // borderRadius: `2px`
    },
    system: {
    // opacity: '0.75'
    }
};
function PropertyStyle(names) {
    let styles = {};
    for (let k in names) {
        if (names[k] && PropertyStyles[k]) {
            styles = { ...styles, ...PropertyStyles[k] };
        }
    }
    return styles;
}
function prettifyEName(econstName) {
    let m;
    return (m = /k_([a-zA-Z]+)/g.exec(econstName), (m && m[1]) || econstName);
}
const Property = ({ name, value, children, onMouseOver, onMouseOut, onClick, selected, opened, system, parent, onParentMouseDown, onParentMouseUp, classes }) => {
    let iconName = system ? `code` : (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(children) ? `chevron down` : `code`);
    if (!children) {
        opened = true;
    }
    if (opened === false) {
        iconName = 'chevron right';
        children = null;
    }
    const isHelper = !onClick;
    const simpleProperty = (value && !children) && !parent;
    const helperProperty = (!value && children) && isHelper;
    const showIcon = !simpleProperty && !helperProperty;
    return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].Item, { className: 'astnode', onMouseOver: onMouseOver, onMouseOut: onMouseOut, onClick: onClick, style: { ...PropertyStyle({ selected, system }), ...(simpleProperty ? { fontSize: '85%' } : {}) } },
        showIcon &&
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].Icon, { name: iconName }),
        react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].Content, null,
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(name) &&
                react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].Header, { style: helperProperty ? { fontSize: '85%', color: '#ccc' } : {} },
                    parent &&
                        react__WEBPACK_IMPORTED_MODULE_5__["createElement"]("span", null,
                            react__WEBPACK_IMPORTED_MODULE_5__["createElement"]("a", { style: { color: 'rgba(0,0,0,0.3)' }, onMouseOver: onParentMouseDown, onMouseOut: onParentMouseUp },
                                react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["Icon"], { className: classes.parentIcon, name: `git pull request`, size: 'small' }))),
                    helperProperty ? `[${name}]` : name),
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(value) &&
                react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].Description, null, value),
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(children) &&
                react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"].List, { className: 'astlist' }, children))));
};
const isNotEmptyArray = (arr) => (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr) || (arr).length > 0);
const PropertyOpt = (props) => {
    const { value, children } = props;
    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(value) || (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isDefAndNotNull"])(children) && isNotEmptyArray(children))) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, props)));
    }
    return null;
};
const SystemProperty = (props) => {
    return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, Object.assign({}, props, { system: true }), props.children));
};
let ProgramView = class ProgramView extends react__WEBPACK_IMPORTED_MODULE_5__["Component"] {
    constructor(props) {
        super(props);
        this.documentCache = null;
        this.state = {
            instrList: {}
        };
        this.rootRef = react__WEBPACK_IMPORTED_MODULE_5__["createRef"]();
    }
    shouldComponentUpdate(nextProps, nextState) {
        return this.documentCache !== nextProps.slDocument;
        // return true;
    }
    componentDidUpdate() {
        this.documentCache = this.props.slDocument;
        // const rect = this.rootRef.current.getBoundingClientRect();
        // just a rude hack
        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;
    }
    render() {
        const { slDocument: analysis } = this.props;
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(analysis)) {
            return null;
        }
        const root = analysis.root;
        const style = {
            height: 'calc(100vh - 205px)',
            overflowY: 'auto'
        };
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"]("div", { ref: this.rootRef },
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["List"], { style: style, selection: true, size: 'small', className: 'astlist' }, this.InstructionCollector(root))));
    }
    Unknown(instr) {
        if (!instr) {
            return null;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_Collector:
                return this.InstructionCollector(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_TypeDecl:
                return this.TypeDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ComplexType:
                return this.ComplexType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_Provide:
                return this.ProvideDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_TechniqueDecl:
                return this.Technique(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableDecl:
                return this.VariableDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableType:
                return this.VariableType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SystemType:
                return this.SystemType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FunctionDecl:
                return this.FunctionDecl(instr);
            //
            // Expressions
            //
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_InitExpr:
                return this.InitExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IdExpr:
                return this.IdExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixPointExpr:
                return this.PostfixPointExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixIndexExpr:
                return this.PostfixIndexExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_AssignmentExpr:
                return this.Assigment(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixArithmeticExpr:
                return this.PostfixArithmetic(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ConstructorCallExpr:
                return this.ConstructorCall(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IntExpr:
                return this.Int(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FloatExpr:
                return this.Float(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_StringExpr:
                return this.String(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_BoolExpr:
                return this.Bool(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ArithmeticExpr:
                return this.ArithmeticExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_CastExpr:
                return this.Cast(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ComplexExpr:
                return this.ComplexExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FunctionCallExpr:
                return this.FunctionCall(instr);
            default:
                return this.NotImplemented(instr);
        }
    }
    InstructionCollector(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, Object.assign({}, this.bindProps(instr, true), { name: 'Program' }), (instr.instructions || []).map((instr) => this.Unknown(instr))));
    }
    ProvideDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'moduleName', value: instr.moduleName })));
    }
    TypeDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { name: 'type' }), this.Unknown(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'name', value: instr.name })));
    }
    ComplexType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, Object.assign({}, this.bindProps(instr), { name: 'fields' }), instr.fields.map((field) => this.Unknown(field))),
            this.typeInfo(instr)));
    }
    // todo: implement it properly
    SystemType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)), this.typeInfo(instr)));
    }
    typeInfo(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, Object.assign({}, this.bindProps(instr, false), { name: _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["type"].signature(instr, true) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'writable', value: `${instr.writable}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'readable', value: `${instr.readable}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'size', value: `${instr.size === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_SIZE ? 'undef' : instr.size} bytes` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'length', value: `${instr.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_LENGTH ? 'undef' : instr.length}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'base', value: `${instr.isBase()}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'array', value: `${instr.isArray()}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'complex', value: `${instr.isComplex()}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: 'const', value: `${instr.isConst()}` }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'element type' }, this.Unknown(instr.arrayElementType)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'methods' }, instr.methods.map(method => _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["fn"].signatureEx(method.def, true))
                .map(signature => react__WEBPACK_IMPORTED_MODULE_5__["createElement"](SystemProperty, { name: react__WEBPACK_IMPORTED_MODULE_5__["createElement"]("span", null, "\u00A0\u00A0"), value: signature })))));
    }
    Pass(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'name', value: instr.name })));
    }
    Technique(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'passes' }, instr.passList.map((pass) => this.Pass(pass)))));
    }
    VariableDecl(instr) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'id', value: instr.id.toString() }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'type', opened: true }, this.VariableType(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'init', opened: true }, this.InitExpr(instr.initExpr))));
    }
    FunctionDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'attributes' }, instr.attributes.map((attr) => this.Attribute(attr))),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'definition' }, this.FunctionDefinition(instr.def)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'implementation' }, this.StmtBlock(instr.impl))));
    }
    IdExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            this.Id(instr.id),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'declaration' }, this.Unknown(instr.decl))));
    }
    Id(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { name: 'name', value: instr.name })));
    }
    PostfixPointExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'element' }, this.Unknown(instr.element)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'postfix' }, this.Unknown(instr.postfix))));
    }
    PostfixIndexExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'element' }, this.Unknown(instr.element)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'index' }, this.Unknown(instr.index))));
    }
    Assigment(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'lval' }, this.Unknown(instr.left)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'rval' }, this.Unknown(instr.right))));
    }
    PostfixArithmetic(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    ConstructorCall(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'type' }, this.VariableType(instr.ctor)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'arguments' }, instr.args.map((arg) => this.Unknown(arg)))));
    }
    ArithmeticExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'operands' },
                this.Unknown(instr.left),
                this.Unknown(instr.right))));
    }
    Cast(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'type' }, this.Type(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    ComplexExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    FunctionCall(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'declaration' }, this.FunctionDecl(instr.decl)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'callee' }, this.Unknown(instr.callee)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'arguments' }, instr.args.map((arg) => this.Unknown(arg)))));
    }
    Int(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { value: String(instr.value) }))
        // <Property { ...this.bindProps(instr) } >
        //     <Property { ...this.bindProps(instr) } value={ String(instr.value) } />
        //     <Property name='type'>
        //         { this.Unknown(instr.type) }
        //     </Property>
        // </Property>
        );
    }
    Float(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { value: String(instr.value) })));
    }
    Bool(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { value: String(instr.value) })));
    }
    String(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { value: String(instr.value) })));
    }
    Attribute(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { name: instr.name }), instr.args.map((arg) => this.Unknown(arg))));
    }
    FunctionDefinition(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'signature', value: _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["fn"].signatureEx(instr, true) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'type', value: instr.returnType.name }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'numArgsRequired', value: String(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["fn"].numArgsRequired(instr)) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'arguments' }, instr.params.map((param) => this.VariableDecl(param)))));
    }
    StmtBlock(instr) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)), instr.stmtList.map(stmt => this.Stmt(stmt))));
    }
    Stmt(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_DeclStmt:
                return this.DeclStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ReturnStmt:
                return this.ReturnStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_StmtBlock:
                return this.StmtBlock(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ExprStmt:
                return this.ExprStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ForStmt:
                return this.ForStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SemicolonStmt:
                return this.SemicolonStmt(instr);
            default:
                return this.NotImplemented(instr); // TODO: remove it
        }
    }
    Type(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableType:
                return this.VariableType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SystemType:
                return this.SystemType(instr);
            default:
                return this.NotImplemented(instr); // TODO: remove it
        }
    }
    DeclStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'declarations' }, instr.declList.map(decl => this.Unknown(decl)))));
    }
    ReturnStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'value' }, this.Unknown(instr.expr))));
    }
    ExprStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)), this.Unknown(instr.expr)));
    }
    SemicolonStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true))));
    }
    ForStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr, true)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'init' }, this.Unknown(instr.init)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'cond' }, this.Unknown(instr.cond)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'step' }, this.Unknown(instr.step)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'body' }, this.Stmt(instr.body))));
    }
    VariableType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'usages', value: (instr.usages.join(' ') || null) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'padding', value: instr.padding === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].UNDEFINE_PADDING ? 'undef' : instr.padding }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](PropertyOpt, { name: 'subType', opened: true }, this.Unknown(instr.subType)),
            this.typeInfo(instr)));
    }
    InitExpr(instr) {
        if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr)),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'const', value: String(instr.isConst()) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'array', value: String(instr.isArray()) }),
            react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, { name: 'arguments' }, instr.args.map(arg => this.Unknown(arg)))));
    }
    NotImplemented(instr) {
        if (!instr) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_5__["createElement"](Property, Object.assign({}, this.bindProps(instr), { onClick: () => console.log(instr), name: react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["Message"], { size: 'mini', color: 'red' },
                react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["Message"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_5__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["Message"].Header, null, "Not implemented"),
                    react__WEBPACK_IMPORTED_MODULE_5__["createElement"]("p", null, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"][instr.instructionType]))), key: instr.instructionID })));
    }
    bindProps(instr, opened = false) {
        const { instrList } = this.state;
        const instrState = instrList[instr.instructionID];
        if (!instrState) {
            instrList[instr.instructionID] = { opened, selected: false };
            return this.bindProps(instr, opened);
        }
        return {
            name: `${prettifyEName(instr.instructionName)}`,
            key: `${instr.instructionID}`,
            onMouseOver: this.handleMouseOver.bind(this, instr),
            onMouseOut: this.handleMouseOut.bind(this, instr),
            onClick: this.handleMouseClick.bind(this, instr),
            selected: !!instrState.selected,
            opened: !!instrState.opened,
            parent: instr.parent && `I${instr.parent.instructionID}`,
            onParentMouseDown: this.handleParentMouseDown.bind(this, instr),
            onParentMouseUp: this.handleParentMouseUp.bind(this, instr),
            classes: this.props.classes
        };
    }
    handleParentMouseDown(instr, e) {
        e.stopPropagation();
        let parent = instr.parent;
        if (parent && parent.sourceNode)
            this.props.onNodeOver(parent);
    }
    handleParentMouseUp(instr, e) {
        e.stopPropagation();
        let parent = instr.parent;
        if (parent && parent.sourceNode)
            this.props.onNodeOut(parent);
    }
    handleMouseOver(instr, e) {
        e.stopPropagation();
        this.invertInstructionProperty(instr, 'selected');
        if (instr.sourceNode) {
            this.props.onNodeOver(instr);
        }
    }
    handleMouseOut(instr, e) {
        e.stopPropagation();
        this.invertInstructionProperty(instr, 'selected');
        if (instr.sourceNode) {
            this.props.onNodeOut(instr);
        }
    }
    handleMouseClick(instr, e) {
        e.stopPropagation();
        this.documentCache = null;
        this.invertInstructionProperty(instr, 'opened');
        if (instr.sourceNode) {
            this.props.onNodeClick(instr);
        }
    }
    invertInstructionProperty(instr, prop) {
        let { instrList } = this.state;
        let instrState = { opened: false, selected: false, ...instrList[instr.instructionID] };
        instrState[prop] = !instrState[prop];
        instrList = { ...instrList, [instr.instructionID]: instrState };
        this.setState({ instrList });
    }
};
ProgramView = __decorate([
    react_jss__WEBPACK_IMPORTED_MODULE_6___default()(styles)
], ProgramView);
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_7__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__["mapProps"])(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__["getFileState"]), {})(ProgramView));


/***/ }),

/***/ "sQ1Q":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts ***!
  \*********************************************************************/
/*! exports provided: PostfixPointInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostfixPointInstruction", function() { return PostfixPointInstruction; });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "2b0+");



/**
 * Represent someExpr.id
 * EMPTY_OPERATOR Instruction IdInstruction
 */
class PostfixPointInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__["ExprInstruction"] {
    constructor({ element, postfix, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__["EInstructionTypes"].k_PostfixPointExpr, type: postfix.type, ...settings });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(element, this);
        this.postfix = _Instruction__WEBPACK_IMPORTED_MODULE_2__["Instruction"].$withParent(postfix, this);
    }
    toCode() {
        return `${this.element.toCode()}.${this.postfix.toCode()}`;
    }
    isConst() {
        return this.element.isConst();
    }
}


/***/ }),

/***/ "tzgE":
/*!********************************************!*\
  !*** ./src/lib/fx/bytecode/SymbolTable.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A simplified symbol table containing the correspondence of unique
 * hashes of symbols and their addresses in registers.
 * The table is global and does not depend on the stack of functions,
 * because hashes are built on the basis of identifiers of instructions
 * unique to each function and context.
 */
class SymbolTable {
    *[Symbol.iterator]() {
        for (let i in this) {
            yield this[i];
        }
    }
}
/* harmony default export */ __webpack_exports__["default"] = (SymbolTable);


/***/ }),

/***/ "u2cq":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/index.ts ***!
  \**********************************************/
/*! exports provided: expression, fn, instruction, type, variable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _expression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression */ "/oOw");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expression", function() { return _expression__WEBPACK_IMPORTED_MODULE_0__["expression"]; });

/* harmony import */ var _fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fn */ "oBNb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fn", function() { return _fn__WEBPACK_IMPORTED_MODULE_1__["fn"]; });

/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "PKWX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "instruction", function() { return _instruction__WEBPACK_IMPORTED_MODULE_2__["instruction"]; });

/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type */ "79MH");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "type", function() { return _type__WEBPACK_IMPORTED_MODULE_3__["type"]; });

/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variable */ "UsCK");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return _variable__WEBPACK_IMPORTED_MODULE_4__["variable"]; });








/***/ }),

/***/ "uXIj":
/*!*********************************!*\
  !*** ./src/lib/parser/State.ts ***!
  \*********************************/
/*! exports provided: State */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _Item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Item */ "GIxw");


class State {
    constructor() {
        this.nextStates = {};
        this.index = 0;
        this.items = [];
        this.numBaseItems = 0;
        this.numOtherItems = 0;
    }
    eachItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.items.length; ++i) {
            cb(this.items[i], i);
        }
    }
    eachBaseItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.numBaseItems; ++i) {
            cb(this.items[i], i);
        }
    }
    isExpected(symbol) {
        return !!this.items.find(item => item.isExpected(symbol));
    }
    hasItem(value, type) {
        return this.items.find(item => item.isEqual(value, type)) || null;
    }
    hasParentItem(value) {
        return this.items.find(item => item.isParentItem(value)) || null;
    }
    hasChildItem(value) {
        return this.items.find(item => item.isChildItem(value)) || null;
    }
    hasRule(rule, pos) {
        for (let i = 0; i < this.numBaseItems; ++i) {
            const item = this.items[i];
            if (item.rule === rule && item.pos === pos) {
                return true;
            }
        }
        return false;
    }
    isEmpty() {
        return !(this.items.length);
    }
    isEqual(state, type) {
        if (this.numBaseItems !== state.numBaseItems) {
            return false;
        }
        for (let i = 0; i < this.numBaseItems; ++i) {
            const baseItemA = this.items[i];
            let isEqual = false;
            for (let i = 0; i < state.numBaseItems; ++i) {
                const baseItemB = state.items[i];
                if (baseItemA.isEqual(baseItemB, type)) {
                    isEqual = true;
                    break;
                }
            }
            if (!isEqual) {
                return false;
            }
        }
        return true;
    }
    push(item) {
        if (this.items.length === 0 || item.pos > 0) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.numOtherItems === 0);
            this.numBaseItems++;
        }
        else {
            this.numOtherItems++;
        }
        this.items.push(item);
    }
    tryPush_LR0(rule, pos) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return false;
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__["Item"](rule, pos);
        this.push(item);
        return true;
    }
    tryPush_LR(rule, pos, expectedSymbol) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return sameItem.addExpected(expectedSymbol);
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__["Item"](rule, pos, [expectedSymbol]);
        this.push(item);
        return true;
    }
    addNextState(symbol, state) {
        if (this.nextStates[symbol]) {
            return false;
        }
        this.nextStates[symbol] = state;
        return true;
    }
    deleteNotBase() {
        this.items.length = this.numBaseItems;
    }
    toString(isBase = true, grammarSymbols = null) {
        const items = isBase ? this.items.slice(0, this.numBaseItems) : this.items;
        return `State ${this.index}:\n` +
            items.map(item => `\t\t${item.toString(grammarSymbols)}\n`).join();
    }
}


/***/ }),

/***/ "vHMa":
/*!**********************************************!*\
  !*** ./src/sandbox/reducers/parserParams.ts ***!
  \**********************************************/
/*! exports provided: default, getParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParser", function() { return getParser; });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "LhMq");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "pvc7");
/* harmony import */ var _handleActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handleActions */ "WdmE");



const initialState = {
    filename: null,
    grammar: null,
    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserType"].k_LALR,
    flags: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserFlags"].k_Default,
    // TODO: rename option (or move it out of this scope)
    parsingFlags: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["IASTDocumentFlags"].k_Optimize
};
if (true) {
    initialState.flags |= _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["EParserFlags"].k_Debug;
    initialState.parsingFlags |= _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__["IASTDocumentFlags"].k_DeveloperMode;
}
/* harmony default export */ __webpack_exports__["default"] = (Object(_handleActions__WEBPACK_IMPORTED_MODULE_2__["handleActions"])({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["GRAMMAR_CONTENT_SPECIFIED"]]: (state, action) => ({ ...state, grammar: action.payload.content }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PARSER_PARAMS_CHANGED"]]: (state, action) => {
        const { flags, type } = action.payload;
        return { ...state, flags, type };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PARSING_PARAMS_CHANGED"]]: (state, action) => {
        const { flags } = action.payload;
        return { ...state, parsingFlags: flags };
    }
}, initialState));
//- Selectors
const getParser = (state) => state.parserParams;


/***/ }),

/***/ "wEKK":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts ***!
  \********************************************************************/
/*! exports provided: LogicalExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogicalExprInstruction", function() { return LogicalExprInstruction; });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "4AA8");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "2b0+");




/**
 * Represent boolExpr && || boolExpr
 * (&& | ||) Instruction Instruction
 */
class LogicalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__["ExprInstruction"] {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__["EInstructionTypes"].k_LogicalExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__["T_BOOL"], ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__["Instruction"].$withParent(right, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    toCode() {
        var sCode = "";
        sCode += this.left.toCode();
        sCode += this.operator;
        sCode += this.right.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "wYUO":
/*!********************************!*\
  !*** ./src/lib/parser/util.ts ***!
  \********************************/
/*! exports provided: positionMin, positionMax, cloneRange, extendRange, commonRange, checkRange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionMin", function() { return positionMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionMax", function() { return positionMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneRange", function() { return cloneRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRange", function() { return extendRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonRange", function() { return commonRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRange", function() { return checkRange; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");

function positionMin(a, b) {
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(String(a.file) === String(b.file));
    return {
        offset: Math.min(a.offset, b.offset),
        line: Math.min(a.line, b.line),
        column: Math.min(a.column, b.column),
        file: a.file
    };
}
function positionMax(a, b) {
    Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(String(a.file) === String(b.file));
    return {
        offset: Math.max(a.offset, b.offset),
        line: Math.max(a.line, b.line),
        column: Math.max(a.column, b.column),
        file: a.file
    };
}
function cloneRange(range) {
    return { start: { ...range.start }, end: { ...range.end } };
}
function extendRange(parent, child) {
    if (child.start.file !== parent.start.file) {
        return parent;
    }
    if (child.start.line < parent.start.line) {
        parent.start = { ...child.start };
    }
    else if (child.start.line === parent.start.line) {
        parent.start = positionMin(child.start, parent.start);
    }
    if (child.end.line > parent.end.line) {
        parent.end = { ...child.end };
    }
    else if (child.end.line === parent.end.line) {
        parent.end = positionMax(child.end, parent.end);
    }
    return parent;
}
function commonRange(...rangeList) {
    const MAX_I32 = Number.MAX_SAFE_INTEGER;
    const MIN_I32 = Number.MIN_SAFE_INTEGER;
    const file = rangeList[0].start.file;
    let start = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };
    let end = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };
    rangeList.forEach(range => start = positionMin(start, range.start));
    rangeList.forEach(range => end = positionMax(end, range.end));
    return { start, end };
}
const checkRange = (range, offset) => range.start.offset <= offset && range.end.offset > offset;


/***/ }),

/***/ "wsMd":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts ***!
  \***********************************************************************/
/*! exports provided: RelationalExprInstruction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RelationalExprInstruction", function() { return RelationalExprInstruction; });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "4AA8");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "Wl5j");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");



/**
 * Represent someExpr == != < > <= >= someExpr
 * (==|!=|<|>|<=|>=) Instruction Instruction
 */
class RelationalExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__["ExprInstruction"] {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_RelationalExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__["T_BOOL"], ...settings });
        this._leftOperand = left;
        this._rightOperand = right;
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.left.toCode();
        code += this.operator;
        code += this.right.toCode();
        return code;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "wzb3":
/*!********************************************!*\
  !*** ./src/lib/fx/bytecode/VM/dispatch.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "oof7");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "2oKZ");


// uint3 Gid: SV_GroupID    
const Gid = new Int32Array([0, 0, 0]);
// uint GI: SV_GroupIndex
const Gi = new Int32Array([0]);
// uint3 GTid: SV_GroupThreadID
const GTid = new Int32Array([0, 0, 0]);
// uint3 DTid: SV_DispatchThreadID
const DTid = new Int32Array([0, 0, 0]);
function dispatch(bundle, numgroups, numthreads = [1, 1, 1]) {
    const [nGroupX, nGroupY, nGroupZ] = numgroups;
    const [nThreadX, nThreadY, nThreadZ] = numthreads;
    // TODO: get order from bundle
    const SV_GroupID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__["INPUT0_REGISTER"] + 0;
    const SV_GroupIndex = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__["INPUT0_REGISTER"] + 1;
    const SV_GroupThreadID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__["INPUT0_REGISTER"] + 2;
    const SV_DispatchThreadID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__["INPUT0_REGISTER"] + 3;
    bundle.input[SV_GroupID] = Gid;
    bundle.input[SV_GroupIndex] = Gi;
    bundle.input[SV_GroupThreadID] = GTid;
    bundle.input[SV_DispatchThreadID] = DTid;
    for (let iGroupZ = 0; iGroupZ < nGroupZ; ++iGroupZ) {
        for (let iGroupY = 0; iGroupY < nGroupY; ++iGroupY) {
            for (let iGroupX = 0; iGroupX < nGroupX; ++iGroupX) {
                Gid[0] = iGroupX;
                Gid[1] = iGroupY;
                Gid[2] = iGroupZ;
                for (let iThreadZ = 0; iThreadZ < nThreadZ; ++iThreadZ) {
                    for (let iThreadY = 0; iThreadY < nThreadY; ++iThreadY) {
                        for (let iThreadX = 0; iThreadX < nThreadX; ++iThreadX) {
                            GTid[0] = iThreadX;
                            GTid[1] = iThreadY;
                            GTid[2] = iThreadZ;
                            DTid[0] = iGroupX * nThreadX + iThreadX;
                            DTid[1] = iGroupY * nThreadY + iThreadY;
                            DTid[2] = iGroupZ * nThreadZ + iThreadZ;
                            Gi[0] = iThreadZ * nThreadX * nThreadY + iThreadY * nThreadX + iThreadX;
                            _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__["play"](bundle);
                        }
                    }
                }
            }
        }
    }
}
/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "x/eC":
/*!**************************************!*\
  !*** ./src/sandbox/logic/parsing.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "bTLv");
/* harmony import */ var _lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/DebugLayout */ "UMcR");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "0DIJ");
/* harmony import */ var _lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/SLASTDocument */ "ahmV");
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/SLParser */ "O8iw");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "pvc7");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "NtUi");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! redux-logic */ "Mn3S");
/* tslint:disable:typedef */









const DEBUGGER_COLORIZATION_PREFIX = 'debug-ln-clr';
function cleanupMarkersBatch(state, prefix) {
    return Object
        .keys(state.sourceFile.markers)
        .filter(name => name.startsWith(`${prefix}-`));
}
function cleanupMarkers(dispatch, batch) {
    if (batch.length > 0) {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_REMOVE_MARKER_BATCH"], payload: { batch } });
    }
}
function emitMarkersBatch(list, type, prefix) {
    return list.map((desc, i) => {
        const { loc, message, payload } = desc;
        return {
            name: `${prefix}-${message}-${i}`,
            range: loc,
            type,
            tooltip: message,
            payload
        };
    });
}
function emitMarkers(dispatch, batch) {
    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_ADD_MARKER_BATCH"], payload: { batch } });
}
const emitDebuggerColorization = (list) => emitMarkersBatch(list, 'line', DEBUGGER_COLORIZATION_PREFIX);
const cleanupDebuggerColorization = (state) => cleanupMarkersBatch(state, DEBUGGER_COLORIZATION_PREFIX);
async function processParsing(state, dispatch) {
    const { content: source, uri } = state.sourceFile;
    const { parsingFlags: flags } = state.parserParams;
    if (!source) {
        return;
    }
    const slastDocument = await Object(_lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_4__["createSLASTDocument"])({ source, uri }, flags);
    if (true) {
        // verbose(Diagnostics.stringify(diag));
    }
    // if (!diag.errors)
    {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_PARSING_COMPLETE"], payload: { slastDocument } });
    }
}
async function processAnalyze(state, dispatch) {
    const { slastDocument } = state.sourceFile;
    if (!slastDocument) {
        return;
    }
    const slDocument = await Object(_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__["createFXSLDocument"])(slastDocument);
    if (true) {
        // verbose(Diagnostics.stringify(diag));
    }
    // if (!diag.errors)
    {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_ANALYSIS_COMPLETE"], payload: { result: slDocument } });
    }
}
const updateParserLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["GRAMMAR_CONTENT_SPECIFIED"], _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["PARSER_PARAMS_CHANGED"]],
    async process({ getState, action }, dispatch, done) {
        const parserParams = getState().parserParams;
        const { grammar, type, flags } = parserParams;
        /**
         * !!! note: all inline functionality inside analyze.ts depends on this setup
         */
        console.log('%c Creating parser...', 'background: #222; color: #bada55');
        try {
            Object(_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_5__["createDefaultSLParser"])({ grammar, type, flags });
            console.log('%c [ DONE ]', 'background: #222; color: #bada55');
        }
        catch (e) {
            console.error('could not initialize parser.');
            return null;
        }
        // todo: add support for failed setup
        done();
    }
});
const updateSourceContentLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_MODIFED"], _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_FILE_LOADED"]],
    latest: true,
    debounce: 500,
    async process({ getState, action, action$ }, dispatch, done) {
        const $debugger = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState());
        if (!$debugger.options.autocompile) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_RESET"] });
        }
        await processParsing(getState(), dispatch);
        done();
    }
});
const parsingCompleteLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_PARSING_COMPLETE"]],
    async process({ getState, action, action$ }, dispatch, done) {
        await processAnalyze(getState(), dispatch);
        done();
    }
});
function buildDebuggerSourceColorization(debuggerState, fileState) {
    // const fn = fileState.slDocument.root.scope.findFunction(debuggerState.expression, null);
    const locList = [];
    if (debuggerState.runtime) {
        // const from = fn.sourceNode.loc.start.line;
        // const to = fn.sourceNode.loc.end.line;
        const from = 0;
        const to = fileState.content.split('\n').length;
        const cdl = Object(_lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_2__["cdlview"])(debuggerState.runtime.cdl);
        for (let ln = from; ln <= to; ++ln) {
            const color = cdl.resolveLineColor(ln, fileState.uri);
            if (color !== -1) {
                const loc = { start: { file: null, line: ln, column: 0 }, end: null };
                locList.push({ loc, payload: { color } });
            }
        }
    }
    return locList;
}
const debuggerCompileLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_COMPILE"],
    cancelType: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_RESET"],
    latest: true,
    async process({ getState, action }, dispatch, done) {
        const file = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(getState());
        const debuggerState = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState());
        const expression = (action.payload && action.payload.expression) || debuggerState.expression || `${_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_ENTRY_POINT_NAME"]}()`;
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(file.slDocument)) {
            const func = file.slDocument.root.scope.findFunction(expression, null);
            // workaround for debug purposes (interpretations of the expressions string as function name)
            if (func) {
                const program = _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["translate"](func);
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_START_DEBUG"], payload: { expression, runtime: program } });
            }
            else {
                const program = await _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__["translateExpression"](expression, file.slDocument);
                if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["isNull"])(program)) {
                    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_START_DEBUG"], payload: { expression, runtime: program } });
                }
                else {
                    alert('could not evaluate expression, see console log for details');
                }
            }
        }
        else {
            console.error('invalid compile request!');
        }
        done();
    }
});
// const markersAddLogic = createLogic<IStoreState>({
//     type: evt.SOURCE_CODE_ADD_MARKER_BATCH,
//     debounce: 10000,
//     process: ({ getState, action }, dispatch, done) => done()
// });
// const markersDelLogic = createLogic<IStoreState>({
//     type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH,
//     debounce: 500,
//     process: ({ getState, action }, dispatch, done) => done()
// });
const debuggerResetLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_RESET"],
    async process({ getState, action }, dispatch, done) {
        const $debugger = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState());
        if ($debugger.options.colorize) {
            cleanupMarkers(dispatch, cleanupDebuggerColorization(getState()));
        }
        done();
    }
});
const debuggerOptionsChangedLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_OPTIONS_CHANGED"],
    async process({ getState, action }, dispatch, done) {
        if (action.payload.options.autocompile === true) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_COMPILE"] });
        }
        if (action.payload.options.colorize === false) {
            cleanupMarkers(dispatch, cleanupDebuggerColorization(getState()));
        }
        else {
            const markers = buildDebuggerSourceColorization(Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState()), Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(getState()));
            emitMarkers(dispatch, emitDebuggerColorization(markers));
        }
        done();
    }
});
const debuggerStartLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_START_DEBUG"],
    async process({ getState, action }, dispatch, done) {
        const fileState = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getFileState"])(getState());
        const debuggerState = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState());
        if (debuggerState.options.colorize) {
            const markers = buildDebuggerSourceColorization(debuggerState, fileState);
            emitMarkers(dispatch, emitDebuggerColorization(markers));
        }
        done();
    }
});
const debuggerAutocompileLogic = Object(redux_logic__WEBPACK_IMPORTED_MODULE_8__["createLogic"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["SOURCE_CODE_ANALYSIS_COMPLETE"],
    process({ getState }, dispatch, done) {
        const debuggerState = Object(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__["getDebugger"])(getState());
        if (debuggerState.options.autocompile) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_6__["DEBUGGER_COMPILE"] });
        }
        done();
    }
});
/* harmony default export */ __webpack_exports__["default"] = ([
    updateParserLogic,
    updateSourceContentLogic,
    parsingCompleteLogic,
    debuggerCompileLogic,
    debuggerResetLogic,
    debuggerOptionsChangedLogic,
    debuggerStartLogic,
    debuggerAutocompileLogic,
]);


/***/ }),

/***/ "x6p4":
/*!**************************************!*\
  !*** ./src/sandbox/actions/index.ts ***!
  \**************************************/
/*! exports provided: parser, sourceCode, mapActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parser", function() { return parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sourceCode", function() { return sourceCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() { return mapActions; });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "ANjH");
/* harmony import */ var _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ActionTypeKeys */ "pvc7");


const parser = {
    setGrammar(content) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["GRAMMAR_CONTENT_SPECIFIED"], payload: { content } };
    },
    setParams(type, flags) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PARSER_PARAMS_CHANGED"], payload: { type, flags } };
    },
    setParsingParams(flags) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PARSING_PARAMS_CHANGED"], payload: { flags } };
    }
};
const sourceCode = {
    openFile(filename) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_FILE_REQUEST"], payload: { filename } };
    },
    setContent(content, filename) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_MODIFED"], payload: { content, filename } };
    },
    // setContent (content): IActionCreator {
    //     return async (dispatch: IDispatch, getState) => {
    //         await dispatch({ type: evt.SOURCE_CODE_MODIFED, payload: { content } });
    //         return getState();
    //     };
    // },
    // IP: Just an incredible example of a AC power!!
    // someRoutine (...argv): IActionCreator {
    //     return async (dispatch: IDispatch, getState) => {
    //         await dispatch({ type: 'some routine', payload: argv });
    //         return getState();
    //     };
    // },
    //
    // markers api
    //
    addMarker(marker) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_ADD_MARKER"], payload: marker };
    },
    removeMarker(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_REMOVE_MARKER"], payload: { name } };
    },
    //
    //
    //
    addBreakpoint(line) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_ADD_BREAKPOINT"], payload: { line } };
    },
    removeBreakpoint(line) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["SOURCE_CODE_REMOVE_BREAKPOINT"], payload: { line } };
    },
    //
    //
    //
    compile(expression) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["DEBUGGER_COMPILE"], payload: { expression } };
    },
    specifyOptions(options) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["DEBUGGER_OPTIONS_CHANGED"], payload: { options } };
    },
    //
    //
    //
    selectEffect(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["PLAYGROUND_SELECT_EFFECT"], payload: { name } };
    },
    //
    //
    //
    resetDebugger() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__["DEBUGGER_RESET"] };
    }
};
function mapActions(actions) {
    return (dispatch) => {
        return {
            actions: Object(redux__WEBPACK_IMPORTED_MODULE_0__["bindActionCreators"])(actions, dispatch),
            // debug functionality
            $dispatch: dispatch,
            $rowActions: actions
        };
    };
}


/***/ }),

/***/ "yAC2":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/CodeEmitter.ts ***!
  \***********************************************/
/*! exports provided: CodeEmitter, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeEmitter", function() { return CodeEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "fb8x");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "u2cq");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "FrU9");
/* harmony import */ var _BaseEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseEmitter */ "o2sq");




class CodeEmitter extends _BaseEmitter__WEBPACK_IMPORTED_MODULE_3__["BaseEmitter"] {
    constructor(options = { mode: 'raw' }) {
        super();
        this.knownGlobals = [];
        this.knownTypes = [];
        this.knownFunctions = [];
        this.options = options;
    }
    get mode() {
        return this.options.mode;
    }
    isMain() {
        return this.depth() === 1;
    }
    resolveTypeName(type) {
        return type.name;
    }
    resolveType(type) {
        let complex = type.isComplex();
        let length;
        let typeName;
        let usages;
        let usage;
        if (!complex) {
            typeName = this.resolveTypeName(type);
        }
        else {
            typeName = type.name;
            if (this.knownTypes.indexOf(typeName) === -1) {
                this.begin();
                this.emitComplexType(type);
                this.emitChar(';');
                this.end();
                this.knownTypes.push(typeName);
            }
        }
        if (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableType) {
            const vtype = type;
            usages = vtype.usages;
        }
        if (type.isNotBaseArray()) {
            length = type.length;
        }
        if (usages && usages.length) {
            usage = usages.join(' ');
        }
        return { typeName, length, usage };
    }
    emitLine(line, comment) {
        this.emitChar(line);
        comment && Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(comment.split('\n').length === 1);
        comment && (this.emitChar('\t'), this.emitComment(comment));
        this.emitNewline();
    }
    emitComment(comment) {
        //
        if (comment.indexOf('\n') === -1) {
            this.emitLine(`// ${comment}`);
            return;
        }
        /**
         *
         */
        this.emitLine('/**');
        this.push(' * ');
        comment.split('\n').forEach(line => this.emitLine(line));
        this.pop();
        this.emitLine(' */');
    }
    emitComplexType(ctype) {
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(ctype.isComplex());
        this.emitKeyword('struct');
        this.emitKeyword(ctype.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        ctype.fields.map(field => (this.emitStmt(field), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitVariableDecl(src, rename) {
        const { typeName, length, usage } = this.resolveType(src.type);
        const name = rename ? rename(src) : src.name;
        usage && this.emitKeyword(usage);
        this.emitKeyword(typeName);
        this.emitKeyword(name);
        length && this.emitChar(`[${length}]`);
        src.initExpr && (this.emitKeyword('='), this.emitSpace(), this.emitExpression(src.initExpr));
        src.semantic && this.emitSemantic(src.semantic);
        src.annotation && this.emitAnnotation(src.annotation);
    }
    emitIfStmt(stmt) {
        this.emitKeyword('if');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(stmt.cond);
        this.emitChar(')');
        this.emitNewline();
        this.emitStmt(stmt.conseq);
        if (stmt.contrary) {
            this.emitNewline();
            this.emitKeyword('else');
            this.emitStmt(stmt.contrary);
        }
    }
    emitSemantic(semantic) {
        this.emitChar(':');
        this.emitKeyword(semantic);
    }
    emitAnnotation(anno) {
        // TODO: add annotation emission.
    }
    emitCompile(compile) {
        this.emitFunction(compile.function);
        this.emitKeyword('compile');
        this.emitKeyword(compile.function.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(compile.args);
        this.emitChar(')');
    }
    emitFunction(fn) {
        if (fn.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SystemFunctionDecl) {
            return;
        }
        if (this.knownFunctions.indexOf(fn.instructionID) !== -1) {
            return;
        }
        this.knownFunctions.push(fn.instructionID);
        const def = fn.def;
        const { typeName } = this.resolveType(def.returnType);
        this.begin();
        {
            this.emitKeyword(typeName);
            this.emitKeyword(fn.name);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitParams(def.params);
            this.emitChar(')');
            this.emitNewline();
            this.emitBlock(fn.impl);
        }
        this.end();
    }
    emitExpression(expr) {
        if (!expr) {
            return;
        }
        /*
        | ICastExprInstruction
        | ILogicalExprInstruction
        | IPostfixIndexInstruction
        | ISamplerStateBlockInstruction
        */
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ArithmeticExpr:
                return this.emitArithmetic(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_AssignmentExpr:
                return this.emitAssigment(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixPointExpr:
                return this.emitPostfixPoint(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IdExpr:
                return this.emitIdentifier(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FunctionCallExpr:
                return this.emitFCall(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ConstructorCallExpr:
                return this.emitCCall(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FloatExpr:
                return this.emitFloat(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IntExpr:
                return this.emitInteger(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_BoolExpr:
                return this.emitBool(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ComplexExpr:
                return this.emitComplexExpr(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_CompileExpr:
                return this.emitCompile(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ConditionalExpr:
                return this.emitConditionalExpr(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_RelationalExpr:
                return this.emitRelationalExpr(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_UnaryExpr:
                return this.emitUnaryExpr(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_PostfixArithmeticExpr:
                return this.emitPostfixArithmetic(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_InitExpr:
                return this.emitInitExpr(expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_CastExpr:
                return this.emitCast(expr);
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported instruction found');
        }
    }
    emitFloat(lit) {
        const sval = String(lit.value);
        this.emitKeyword(sval);
        (sval.indexOf('.') === -1) && this.emitChar('.');
        this.emitChar('f');
    }
    emitBool(lit) {
        this.emitKeyword(lit.value ? 'true' : 'false');
    }
    emitComplexExpr(complex) {
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(complex.expr);
        this.emitChar(')');
    }
    emitConditionalExpr(cond) {
        this.emitExpression(cond.condition);
        this.emitKeyword('?');
        this.emitExpression(cond.left);
        this.emitKeyword(':');
        this.emitExpression(cond.right);
    }
    emitInteger(lit) {
        // TODO: use IIntInstructions instead of ILiteralInstruction
        this.emitKeyword(`${lit.value.toFixed(0)}${!lit.signed ? 'u' : ''}`);
    }
    emitRelationalExpr(rel) {
        this.emitExpression(rel.left);
        this.emitKeyword(rel.operator);
        this.emitExpression(rel.right);
    }
    emitUnaryExpr(unary) {
        this.emitChar(unary.operator);
        this.emitExpression(unary.expr);
    }
    emitPostfixArithmetic(par) {
        this.emitExpression(par.expr);
        this.emitChar(par.operator);
    }
    emitExpressionList(list) {
        list.forEach((expr, i) => {
            this.emitExpression(expr);
            (i != list.length - 1) && this.emitChar(',');
        });
    }
    emitParams(params) {
        params.forEach((param, i, list) => {
            this.emitVariableDecl(param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    emitInitExpr(init) {
        if (init.args.length > 1) {
            this.emitChar('{');
            this.emitNoSpace();
            this.emitExpressionList(init.args);
            this.emitChar('}');
            return;
        }
        this.emitExpression(init.args[0]);
    }
    emitCast(cast) {
        if (cast.isUseless()) {
            return;
        }
        this.emitChar('(');
        this.emitNoSpace();
        const { typeName } = this.resolveType(cast.type);
        this.emitKeyword(typeName);
        this.emitChar(')');
        this.emitNoSpace();
        this.emitExpression(cast.expr);
    }
    emitArithmetic(arthm) {
        this.emitExpression(arthm.left);
        this.emitKeyword(arthm.operator);
        this.emitExpression(arthm.right);
    }
    emitAssigment(asgm) {
        this.emitExpression(asgm.left);
        this.emitKeyword('=');
        this.emitSpace();
        Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(asgm.right));
        this.emitExpression(asgm.right);
    }
    emitPostfixPoint(pfxp) {
        this.emitExpression(pfxp.element);
        this.emitChar('.');
        this.emitChar(pfxp.postfix.name);
    }
    emitGlobal(decl) {
        const name = decl.name;
        // if (isMain() && decl.isParameter() && !decl.isUniform()) {
        // TODO: add support of main arguments with basic types (attributes)
        // }
        const isUniformArg = this.isMain() && decl.isParameter() && decl.type.isUniform();
        if (decl.isGlobal() || isUniformArg) {
            Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(decl.type.isUniform());
            if (this.knownGlobals.indexOf(name) === -1) {
                this.begin();
                this.emitStmt(decl);
                this.end();
                this.knownGlobals.push(name);
            }
        }
    }
    emitIdentifier(id) {
        const { decl, name } = id;
        this.emitGlobal(decl);
        this.emitKeyword(name);
    }
    emitCCall(call) {
        const args = call.args;
        const { typeName } = this.resolveType(call.ctor);
        this.emitKeyword(typeName);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(args);
        this.emitChar(')');
    }
    emitFCall(call) {
        const decl = call.decl;
        const args = call.args;
        this.emitFunction(decl);
        this.emitKeyword(decl.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(args);
        this.emitChar(')');
    }
    emitReturnStmt(stmt) {
        this.emitKeyword('return');
        this.emitExpression(stmt.expr);
        this.emitChar(';');
    }
    emitExpressionStmt(stmt) {
        this.emitExpression(stmt.expr);
        this.emitChar(';');
    }
    /*
        | IStmtBlockInstruction
        | IWhileStmtInstruction
        | IForStmtInstruction;
    */
    emitStmt(stmt) {
        switch (stmt.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_DeclStmt:
                stmt.declList.forEach(dcl => (this.emitStmt(dcl)));
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ExprStmt:
                this.emitExpressionStmt(stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_ReturnStmt:
                this.emitReturnStmt(stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_VariableDecl:
                this.emitVariableDecl(stmt);
                this.emitChar(';');
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_SemicolonStmt:
                this.emitChar(';');
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_IfStmt:
                this.emitIfStmt(stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_StmtBlock:
                this.emitBlock(stmt);
                break;
            default:
                console.warn(`unknown stmt found: '${stmt.instructionName}'`);
        }
    }
    emitBlock(blk) {
        this.emitChar('{');
        this.push();
        blk.stmtList.forEach(stmt => (this.emitStmt(stmt), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitPass(pass) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        this.emitPassBody(pass);
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitPassBody(pass) {
        // TODO: replace with emitCompile();
        pass.vertexShader && (this.emitFunction(pass.vertexShader),
            this.emitKeyword('VertexShader'),
            this.emitKeyword('='),
            this.emitKeyword('compile'),
            this.emitKeyword(pass.vertexShader.name),
            this.emitChar('()'),
            this.emitChar(';'),
            this.emitNewline());
        pass.pixelShader && (this.emitFunction(pass.pixelShader),
            this.emitKeyword('PixelShader'),
            this.emitKeyword('='),
            this.emitKeyword('compile'),
            this.emitKeyword(pass.pixelShader.name),
            this.emitChar('()'),
            this.emitChar(';'),
            this.emitNewline());
        this.emitNewline();
        // mwalk(pass.renderStates, (val, key) => {
        //     console.log(ERenderStates[key], ERenderStateValues[val]);
        // });
    }
    emit(instr) {
        if (!instr) {
            // TODO: emit error.
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isExpression(instr)) {
            this.emitExpression(instr);
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__["instruction"].isStatement(instr)) {
            this.emitStmt(instr);
            return this;
        }
        //
        // Other types
        //
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__["EInstructionTypes"].k_FunctionDecl:
                this.emitFunction(instr);
                break;
            default:
                Object(_lib_common__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 'unsupported instruction found');
        }
        return this;
    }
}
function translate(instr, options) {
    return (new CodeEmitter(options)).emit(instr).toString();
}


/***/ }),

/***/ "yosG":
/*!******************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/lib/fx/HLSL.gr ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("S : Program\r\nProgram : --add\r\nProgram : Decls\r\n\r\nDecls : Decl --expose\r\nDecls : Decls Decl\r\n\r\nDecl : ';'\r\nDecl : TypeDecl\r\nDecl : VariableDecl\r\nDecl : VarStructDecl\r\nDecl : FunctionDecl\r\nDecl : TechniqueDecl\r\n#if FX_PART\r\n    Decl : PartFxDecl\r\n#endif \r\nDecl : UseDecl\r\nDecl : ImportDecl\r\nDecl : ProvideDecl\r\nDecl : IncludeDecl\r\nDecl : ERROR\r\n\r\nIncludeDecl : '#' T_KW_INCLUDE String --skip --F includeCode\r\n\r\nImportDecl : T_KW_IMPORT String ';'\r\n\r\nProvideDecl : T_KW_PROVIDE ComplexNameOpt ';'\r\nProvideDecl : T_KW_PROVIDE ComplexNameOpt T_KW_AS ComplexNameOpt ';'\r\n\r\nUseDecl : T_KW_USE Mode\r\nMode : T_KW_STRICT\r\n\r\nUsages : Usage --expose\r\nUsages : Usages Usage\r\nUsage : T_KW_STATIC --add\r\nUsage : T_KW_UNIFORM\r\nUsage : T_KW_EXTERN\r\nUsage : T_KW_VOLATILE\r\nUsage : T_KW_INLINE\r\nUsage : ConstUsage\r\n\r\nConstUsages : ConstUsage --expose\r\nConstUsages : ConstUsages ConstUsage\r\nConstUsage : T_KW_CONST\r\nConstUsage : T_KW_ROW_MAJOR\r\nConstUsage : T_KW_COLUMN_MAJOR\r\n\r\nUsageType : Type --add\r\nUsageType : Usages Type\r\n\r\nUsageStructDecl : StructDecl --add\r\nUsageStructDecl : Usages StructDecl\r\n\r\nTypeDecl : T_KW_TYPEDEF ConstType TypeDefs ';' --add\r\nTypeDecl : T_KW_TYPEDEF ConstStructDecl TypeDefs ';'\r\nTypeDecl : StructDecl --F addType ';'\r\nTypeDefs : VariableDim\r\nTypeDefs : VariableDim ',' TypeDefs\r\n\r\n# GenericParams : '<' Arguments '>'\r\n# GenericParamsOpt: --expose\r\n# GenericParamsOpt: GenericParams\r\n\r\nType : BaseType --add\r\nType : Struct\r\nType : TypeId\r\nType : T_KW_STRUCT TypeId\r\n\r\nConstType : Type --add\r\nConstType : ConstUsages Type\r\nConstTypeDim : ConstType --expose\r\nConstTypeDim : ConstTypeDim '[' ConstantExpr ']'\r\n\r\nBaseType : T_KW_VOID --add\r\nBaseType : ScalarType\r\nBaseType : VectorType\r\nBaseType : MatrixType\r\nBaseType : ObjectType\r\n\r\nScalarType : T_KW_BOOL --add\r\nScalarType : T_KW_INT\r\nScalarType : T_KW_UINT\r\nScalarType : T_KW_HALF\r\nScalarType : T_KW_FLOAT\r\nScalarType : T_KW_DOUBLE\r\n\r\nVectorType : T_KW_VECTOR --add\r\nVectorType : T_KW_VECTOR '<' ScalarType ',' AddExpr '>'\r\n\r\nMatrixType : T_KW_MATRIX --add\r\nMatrixType : T_KW_MATRIX '<' ScalarType ',' ConstantExpr ',' AddExpr '>'\r\n\r\nObjectType : T_KW_STRING --add\r\nObjectType : T_KW_TEXTURE\r\nObjectType : T_KW_TEXTURE1D\r\nObjectType : T_KW_TEXTURE2D\r\nObjectType : T_KW_TEXTURE3D\r\nObjectType : T_KW_TEXTURECUBE\r\nObjectType : T_KW_SAMPLER\r\nObjectType : T_KW_SAMPLER1D\r\nObjectType : T_KW_SAMPLER2D\r\nObjectType : T_KW_SAMPLER3D\r\nObjectType : T_KW_SAMPLERCUBE\r\nObjectType : T_KW_PIXELSHADER\r\nObjectType : T_KW_VERTEXSHADER\r\nObjectType : T_KW_PIXELFRAGMENT\r\nObjectType : T_KW_VERTEXFRAGMENT\r\nObjectType : T_KW_STATEBLOCK\r\nObjectType : T_KW_RWBUFFER '<' Type '>'\r\nObjectType : T_KW_RWSTRUCTUREDBUFFER '<' Type '>'\r\nObjectType : T_KW_APPENDSTRUCTUREDBUFFER '<' Type '>'\r\n\r\n\r\n# struct Name\r\n# {\r\n#     [InterpolationModifier] Type[RxC] MemberName;\r\n#     ...\r\n# };\r\n# \r\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509668(v=vs.85).aspx\r\n\r\nStruct : T_KW_STRUCT '{' '}' --add\r\nStruct : T_KW_STRUCT '{' StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id '{' '}' --add\r\nStructDecl : T_KW_STRUCT Id '{' UseDecl StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id '{' StructDecls '}'\r\n\r\nConstStructDecl : StructDecl\r\nConstStructDecl : ConstUsages StructDecl\r\n\r\nStructDecls : VariableDecl --expose\r\nStructDecls : VariableDecl StructDecls\r\n\r\nSemantic : ':' Id --add\r\nSemantic : ':' T_KW_REGISTER '(' Register ')'\r\nSemantics : Semantic\r\nSemantics : Semantics Semantic\r\nSemanticsOpt :\r\nSemanticsOpt : Semantics\r\n\r\nRegister : Id\r\nRegister : Target ',' Id\r\n\r\nAnnotation : AnnotationBegin AnnotationEnd  --add\r\nAnnotation : AnnotationBegin AnnotationDecls AnnotationEnd\r\nAnnotationOpt :\r\nAnnotationOpt : Annotation\r\nAnnotationBegin : '<'\r\nAnnotationDecls : VariableDecl\r\nAnnotationDecls : VariableDecl AnnotationDecls\r\nAnnotationEnd : '>'\r\n\r\nInitializer : '=' AssignmentExpr --add\r\nInitializer : '=' ERROR --add\r\nInitializer : '=' '{' InitExprs '}'\r\nInitializer : '=' '{' InitExprs ',' '}'\r\n\r\n# InitializerOpt :\r\n# InitializerOpt : Initializer\r\n\r\n\r\n# [Storage_Class] [Type_Modifier] Type Name[Index]\r\n#    [: Semantic]\r\n#    [: Packoffset]\r\n#    [: Register];\r\n#    [Annotations]\r\n#    [= Initial_Value]\r\n#\r\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509706(v=vs.85).aspx\r\n\r\nVariableDecl : UsageType Variables ';' --add\r\nVariableDecl : UsageType Variables ERROR --add\r\nVarStructDecl : UsageStructDecl Variables ';' --add\r\nVariables : Variable --expose\r\nVariables : Variables ',' Variable\r\n# Variables : Variables ERROR Variable\r\nVariables : Variables ',' ERROR\r\nVariable : VariableDim SemanticsOpt AnnotationOpt Initializer --add\r\nVariable : VariableDim SemanticsOpt AnnotationOpt --add\r\nVariableDim : NonTypeId --add\r\nVariableDim : VariableDim '[' ConstantExpr ']'\r\n\r\n\r\n# [StorageClass] [clipplanes()] [precise] Return_Value Name ( [ArgumentList] ) [: Semantic]\r\n# {ок\r\n#   [StatementBlock]\r\n# };\r\n# \r\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509607(v=vs.85).aspx\r\n\r\nFunctionDecl : Attributes FunctionDef ';' --add\r\nFunctionDecl : FunctionDef ';' --add\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt StmtBlock\r\nFunctionDecl : FunctionDef AnnotationOpt StmtBlock\r\n\r\n# TODO: remove it;\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt ERROR\r\nFunctionDecl : FunctionDef AnnotationOpt ERROR\r\n\r\nFunctionDef : UsageType NonTypeId ParamList SemanticsOpt\r\n\r\nAttribute : '[' Id '(' ArgumentsOpt ')' ']'\r\nAttribute : '[' Id ']'\r\nAttributes : Attribute --expose\r\nAttributes : Attributes Attribute\r\nAttributesOpt : --expose\r\nAttributesOpt : Attributes\r\n\r\nParamList : '(' ')'\r\nParamList : '(' T_KW_VOID ')'\r\nParamList : '(' ParameterDecls ')'\r\n\r\n\r\n# [InputModifier] Type Name [: Semantic] [InterpolationModifier] [= Initializers]\r\n# \r\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509606(v=vs.85).aspx\r\n\r\nParameterDecls : ParameterDecl --expose\r\nParameterDecls : ParameterDecls ',' ParameterDecl\r\nParameterDecls : ParameterDecls ERROR ParameterDecl\r\nParameterDecls : ParameterDecls ',' ERROR\r\nParameterDecls : ERROR\r\nParameterDecl : ParamUsageType Variable\r\n\r\nParamUsageType : Type --add\r\nParamUsageType : ParamUsages Type\r\n\r\nParamUsages : ParamUsage --expose\r\nParamUsages : ParamUsages ParamUsage\r\nParamUsage : T_KW_IN --add\r\nParamUsage : T_KW_OUT\r\nParamUsage : T_KW_INOUT\r\nParamUsage : T_KW_UNIFORM\r\nParamUsage : ConstUsage\r\n\r\n\r\nTechniqueDecl : T_KW_TECHNIQUE ComplexNameOpt SemanticsOpt AnnotationOpt TechniqueBody --add\r\nTechniqueBody : '{' '}'  --add\r\nTechniqueBody : '{' PassDecls '}'\r\n\r\nComplexNameOpt : ComplexName --add\r\nComplexName : Id --expose\r\nComplexName : ComplexName '.' Id\r\n\r\nPassDecls : PassDecl --expose\r\nPassDecls : PassDecls PassDecl\r\nPassDecl : T_KW_PASS IdOpt AnnotationOpt PassStateBlock --add\r\nPassDecl : ';'\r\n\r\nPassStateBlock : '{' '}' --add\r\nPassStateBlock : '{' PassStates '}'\r\nPassStates : PassState --expose\r\nPassStates : PassStates PassState\r\n\r\nPassState : Id StateIndex '=' PassStateExpr ';' --add\r\n\r\n# todo: move all particles declarations to separate grammar!\r\n#if FX_PART\r\n\r\nPartFxDecl : T_KW_FXPART ComplexNameOpt SemanticsOpt AnnotationOpt PartFxBody --add\r\n\r\nPartFxBody : '{' '}' \r\nPartFxBody : '{' PartFxProperties '}'\r\n\r\nPartFxProperties : PartFxProperty --expose\r\nPartFxProperties : PartFxProperties PartFxProperty\r\n\r\nPartFxProperty : PassState\r\nPartFxProperty : PassDecl\r\n\r\n#endif // FX_PART\r\n\r\nStateBlock : '{' '}' --add\r\nStateBlock : '{' States '}'\r\n\r\n\r\nStates : State --expose\r\nStates : States State\r\nState : Id StateIndex '=' StateExpr ';' --add\r\n\r\nStateIndex :\r\nStateIndex : '[' Uint ']'\r\n\r\nStmtBlock : '{' '}' --add\r\nStmtBlock : '{' Stmts '}'  \r\n\r\nStmts : Stmt --expose\r\nStmts : Stmts Stmt\r\n\r\n# SimpleStmt : ERROR ';' \r\n# SimpleStmt : ';' --add\r\n\r\nSimpleStmt : Expr ';'\r\nSimpleStmt : Expr ERROR\r\nSimpleStmt : T_KW_RETURN ';'\r\nSimpleStmt : T_KW_RETURN Expr ';'\r\nSimpleStmt : T_KW_RETURN ERROR ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' Expr ')' ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' ERROR ')' ';'\r\nSimpleStmt : StmtBlock\r\nSimpleStmt : T_KW_DISCARD ';'\r\nSimpleStmt : TypeDecl\r\nSimpleStmt : VariableDecl --add\r\nSimpleStmt : VarStructDecl\r\nSimpleStmt : T_KW_BREAK ';'\r\nSimpleStmt : T_KW_BREAK ERROR\r\nSimpleStmt : T_KW_CONTINUE ';'\r\nSimpleStmt : T_KW_CONTINUE ERROR\r\n\r\n#if FX_PART\r\nSimpleStmt : T_KW_SPAWN '(' Uint ')' NonTypeId '(' ArgumentsOpt ')' ';'\r\n#endif\r\n\r\n\r\nNonIfStmt : SimpleStmt --add\r\nNonIfStmt : WhileStmt NonIfStmt\r\nNonIfStmt : ForStmt NonIfStmt\r\n\r\nStmt : SimpleStmt --add\r\nStmt : UseDecl\r\nStmt : WhileStmt Stmt\r\nStmt : ForStmt Stmt\r\nStmt : IfStmt Stmt\r\nStmt : IfStmt NonIfStmt T_KW_ELSE Stmt\r\nStmt : ERROR\r\nStmt : ';'\r\n\r\nIfStmt : AttributesOpt T_KW_IF '(' Expr ')' --expose\r\nIfStmt : AttributesOpt T_KW_IF '(' ERROR ')' --expose\r\n\r\nWhileStmt : T_KW_WHILE '(' Expr ')' --expose\r\nWhileStmt : T_KW_WHILE '(' ERROR ')' --expose\r\n\r\nForStmt : For '(' ForInit ForCond ForStep ')' --expose\r\nForStmt : For ERROR --expose\r\n\r\nFor : T_KW_FOR\r\n\r\nForInit : ';' --add\r\nForInit : Expr ';'\r\nForInit : VariableDecl\r\nForInit : ERROR ';'\r\n\r\nForCond : ';' --add\r\nForCond : Expr ';'\r\nForCond : ERROR ';'\r\n\r\nForStep : --add\r\nForStep : Expr\r\nForStep : ERROR\r\n\r\nDwordExpr : Dword\r\nDwordExpr : Dword '|' DwordExpr\r\n\r\nDwordExprSeq : DwordExpr --expose\r\nDwordExprSeq : DwordExpr ',' DwordExprSeq\r\n\r\nPassStateExpr : DwordExpr --add\r\nPassStateExpr : ComplexExpr\r\nPassStateExpr : '{' DwordExprSeq '}'\r\n\r\nStateExpr : DwordExpr --add\r\nStateExpr : ComplexExpr\r\nStateExpr : '{' InitExprs '}'\r\nStateExpr : '{' InitExprs ',' '}'\r\nStateExpr : '<' RelationalExpr '>'\r\n\r\nSimpleExpr : T_KW_TRUE\r\nSimpleExpr : T_KW_FALSE\r\nSimpleExpr : Uint\r\nSimpleExpr : Float\r\nSimpleExpr : String\r\nSimpleExpr : NonTypeId\r\n\r\nComplexExpr : '(' Expr ')'\r\nComplexExpr : TypeId '(' ArgumentsOpt ')'\r\nComplexExpr : BaseType '(' ArgumentsOpt ')'\r\nComplexExpr : NonTypeId '(' ArgumentsOpt ')'\r\nComplexExpr : PostfixPointExpr '(' ArgumentsOpt ')'\r\nComplexExpr : ObjectExpr\r\n\r\nObjectExpr : T_KW_COMPILE NonTypeId '(' ArgumentsOpt ')'\r\nObjectExpr : T_KW_SAMPLER_STATE StateBlock\r\nObjectExpr : T_KW_COMPILE_FRAGMENT Target NonTypeId '(' ArgumentsOpt ')'\r\nObjectExpr : T_KW_STATEBLOCK_STATE StateBlock\r\n\r\nPrimaryExpr : ComplexExpr\r\nPrimaryExpr : SimpleExpr\r\nPostfixExpr : PrimaryExpr\r\nPostfixExpr : PostfixExpr '[' Expr ']'\r\nPostfixExpr : PostfixExpr '[' ERROR ']'\r\nPostfixExpr : PostfixExpr '.' Id\r\nPostfixExpr : PostfixExpr T_OP_INC\r\nPostfixExpr : PostfixExpr T_OP_DEC\r\n\r\nPostfixPointExpr : PostfixExpr '.' Id\r\n\r\nUnaryExpr : PostfixExpr\r\nUnaryExpr : T_OP_INC UnaryExpr\r\nUnaryExpr : T_OP_DEC UnaryExpr\r\n# UnaryExpr : T_OP_INC ERROR\r\n# UnaryExpr : T_OP_DEC ERROR\r\nUnaryExpr : '!' CastExpr\r\n# UnaryExpr : '!' ERROR\r\nUnaryExpr : '-' CastExpr\r\nUnaryExpr : '+' CastExpr\r\n\r\nCastExpr : UnaryExpr\r\nCastExpr : '(' ConstTypeDim ')' CastExpr\r\nCastExpr : '(' ERROR ')' CastExpr\r\n\r\nMulExpr : CastExpr\r\nMulExpr : MulExpr '*' CastExpr\r\nMulExpr : MulExpr '/' CastExpr\r\nMulExpr : MulExpr '%' CastExpr\r\n\r\nMulExpr : ERROR '*' CastExpr\r\nMulExpr : ERROR '/' CastExpr\r\nMulExpr : ERROR '%' CastExpr\r\nMulExpr : MulExpr '*' ERROR\r\nMulExpr : MulExpr '/' ERROR\r\nMulExpr : MulExpr '%' ERROR\r\n# MulExpr : ERROR '*' ERROR\r\n# MulExpr : ERROR '/' ERROR\r\n# MulExpr : ERROR '%' ERROR\r\n\r\nAddExpr : MulExpr\r\nAddExpr : AddExpr '+' MulExpr\r\nAddExpr : AddExpr '-' MulExpr\r\n\r\nAddExpr : AddExpr '+' ERROR\r\nAddExpr : AddExpr '-' ERROR\r\n\r\nRelationalExpr : AddExpr\r\nRelationalExpr : RelationalExpr '<' AddExpr\r\nRelationalExpr : RelationalExpr '>' AddExpr\r\nRelationalExpr : RelationalExpr T_OP_LE AddExpr\r\nRelationalExpr : RelationalExpr T_OP_GE AddExpr\r\n\r\nRelationalExpr : ERROR '<' AddExpr\r\nRelationalExpr : RelationalExpr '<' ERROR\r\nRelationalExpr : ERROR '<' ERROR\r\n\r\nRelationalExpr : RelationalExpr '>' ERROR\r\nRelationalExpr : ERROR '>' AddExpr\r\nRelationalExpr : ERROR '>' ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_LE ERROR\r\nRelationalExpr : ERROR T_OP_LE AddExpr\r\nRelationalExpr : ERROR T_OP_LE ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_GE ERROR\r\nRelationalExpr : ERROR T_OP_GE AddExpr\r\nRelationalExpr : ERROR T_OP_GE ERROR\r\n\r\nEqualityExpr : RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE RelationalExpr\r\nEqualityExpr : ERROR T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE ERROR\r\nEqualityExpr : ERROR T_OP_NE ERROR\r\n\r\nAndExpr : EqualityExpr\r\nAndExpr : AndExpr T_OP_AND EqualityExpr\r\nAndExpr : ERROR T_OP_AND EqualityExpr\r\nAndExpr : AndExpr T_OP_AND ERROR\r\n\r\nOrExpr : AndExpr\r\nOrExpr : OrExpr T_OP_OR AndExpr\r\nOrExpr : OrExpr T_OP_OR ERROR\r\nOrExpr : ERROR T_OP_OR AndExpr\r\n\r\nConditionalExpr : OrExpr\r\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : ERROR '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : OrExpr '?' ERROR ':' ConditionalExpr\r\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ERROR\r\nConditionalExpr : OrExpr '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ConditionalExpr\r\n\r\nAssignmentExpr : ConditionalExpr\r\nAssignmentExpr : CastExpr '=' AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_ME AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_DE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_RE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_AE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SE AssignmentExpr\r\n\r\nArguments : AssignmentExpr --expose\r\nArguments : Arguments ',' AssignmentExpr\r\nArguments : Arguments ERROR AssignmentExpr\r\nArguments : Arguments ',' ERROR\r\nArgumentsOpt : --expose\r\nArgumentsOpt : Arguments\r\n\r\nInitExpr : AssignmentExpr --add\r\nInitExpr : '{' InitExprs '}'\r\nInitExpr : '{' InitExprs ',' '}'\r\nInitExprs : InitExpr --expose\r\nInitExprs : InitExprs ',' InitExpr\r\n\r\nConstantExpr : AssignmentExpr\r\nExpr : AssignmentExpr\r\nExpr : Expr ',' AssignmentExpr\r\nExpr : Expr ',' ERROR\r\nExpr : ERROR ',' ERROR\r\nExpr : ERROR ',' AssignmentExpr\r\n\r\nDword : Uint\r\nDword : '-' Uint\r\nDword : Float\r\nDword : '-' Float\r\nDword : DwordId\r\nDword : Uint DwordId\r\nDwordId : Id\r\nDwordId : T_KW_TRUE\r\nDwordId : T_KW_FALSE\r\nDwordId : T_KW_TEXTURE\r\n\r\nId : TypeId\r\nId : NonTypeId\r\nIdOpt :\r\nIdOpt : Id\r\n\r\nTarget : NonTypeId\r\n\r\nUint : T_UINT\r\nFloat : T_FLOAT\r\n\r\nStrings : String\r\nStrings : Strings String\r\nString : T_STRING\r\n\r\nTypeId : T_TYPE_ID\r\nNonTypeId : T_NON_TYPE_ID\r\nLineTerminator : T_LINE_TERMINATOR\r\n\r\nAsmDecl : T_KW_DECL '{'\r\nAsm : T_KW_ASM '{'\r\nAsmFragment : T_KW_ASM_FRAGMENT '{'\r\n\r\n--LEXER--\r\n\r\nT_KW_STATIC : \"static\"\r\nT_KW_UNIFORM : \"uniform\"\r\nT_KW_EXTERN : \"extern\"\r\nT_KW_VOLATILE : \"volatile\"\r\nT_KW_INLINE : \"inline\"\r\nT_KW_CONST : \"const\"\r\nT_KW_ROW_MAJOR : \"row_major\"\r\nT_KW_COLUMN_MAJOR : \"column_major\"\r\nT_KW_TYPEDEF : \"typedef\"\r\nT_KW_STRUCT : \"struct\"\r\nT_KW_VOID : \"void\"\r\nT_KW_BOOL : \"bool\"\r\nT_KW_INT : \"int\"\r\nT_KW_UINT : \"uint\"\r\nT_KW_HALF : \"half\"\r\nT_KW_FLOAT : \"float\"\r\nT_KW_DOUBLE : \"double\"\r\nT_KW_VECTOR : \"vector\"\r\nT_KW_MATRIX : \"matrix\"\r\nT_KW_STRING : \"string\"\r\nT_KW_TEXTURE : \"texture\"\r\nT_KW_TEXTURE1D : \"texture1D\"\r\nT_KW_TEXTURE2D : \"texture2D\"\r\nT_KW_TEXTURE3D : \"texture3D\"\r\nT_KW_TEXTURECUBE : \"texturecube\"\r\nT_KW_SAMPLER : \"sampler\"\r\nT_KW_SAMPLER1D : \"sampler1D\"\r\nT_KW_SAMPLER2D : \"sampler2D\"\r\nT_KW_SAMPLER3D : \"sampler3D\"\r\nT_KW_SAMPLERCUBE : \"samplerCUBE\"\r\nT_KW_RWBUFFER : \"RWBuffer\"\r\nT_KW_RWSTRUCTUREDBUFFER : \"RWStructuredBuffer\"\r\nT_KW_APPENDSTRUCTUREDBUFFER : \"AppendStructuredBuffer\"\r\nT_KW_PIXELSHADER : \"pixelshader\"\r\nT_KW_VERTEXSHADER : \"vertexshader\"\r\nT_KW_PIXELFRAGMENT : \"pixelfragment\"\r\nT_KW_VERTEXFRAGMENT : \"vertexfragment\"\r\nT_KW_STATEBLOCK : \"stateblock\"\r\nT_KW_REGISTER : \"register\"\r\nT_KW_IN : \"in\"\r\nT_KW_OUT : \"out\"\r\nT_KW_INOUT : \"inout\"\r\nT_KW_TECHNIQUE : \"technique\"\r\n#if FX_PART\r\n    T_KW_FXPART : \"partFx\"\r\n#endif\r\nT_KW_PASS : \"pass\"\r\nT_KW_RETURN : \"return\"\r\nT_KW_DO : \"do\"\r\nT_KW_DISCARD : \"discard\"\r\nT_KW_WHILE : \"while\"\r\nT_KW_IF : \"if\"\r\nT_KW_ELSE : \"else\"\r\nT_KW_FOR : \"for\"\r\nT_KW_TRUE : \"true\"\r\nT_KW_FALSE : \"false\"\r\nT_KW_COMPILE : \"compile\"\r\nT_KW_SAMPLER_STATE : \"sampler_state\"\r\nT_KW_COMPILE_FRAGMENT : \"compile_fragment\"\r\nT_KW_STATEBLOCK_STATE : \"stateblock_state\"\r\nT_KW_DECL : \"decl\"\r\nT_KW_ASM : \"asm\"\r\nT_KW_ASM_FRAGMENT : \"asm_fragment\"\r\nT_KW_USE : \"use\"\r\nT_KW_STRICT : \"strict\"\r\nT_KW_IMPORT : \"import\"\r\nT_KW_PROVIDE : \"provide\"\r\nT_KW_SWITCH : \"switch\"\r\nT_KW_CASE : \"case\"\r\nT_KW_DEFAULT : \"default\"\r\nT_KW_BREAK : \"break\"\r\n#if FX_PART\r\nT_KW_SPAWN : \"spawn\"\r\n#endif\r\nT_KW_CONTINUE : \"continue\"\r\nT_KW_AS : \"as\"\r\nT_KW_INCLUDE : \"include\"\r\nT_OP_INC : \"++\"\r\nT_OP_DEC : \"--\"\r\nT_OP_LE : \">=\"\r\nT_OP_GE : \"<=\"\r\nT_OP_EQ : \"==\"\r\nT_OP_NE : \"!=\"\r\nT_OP_AND : \"&&\"\r\nT_OP_OR : \"||\"\r\nT_OP_ME : \"*=\"\r\nT_OP_DE : \"/=\"\r\nT_OP_RE : \"%=\"\r\nT_OP_AE : \"+=\"\r\nT_OP_SE : \"-=\"");

/***/ }),

/***/ "yp6H":
/*!********************************************!*\
  !*** ./src/sandbox/components/ASTView.tsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/reducers */ "KGxL");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! copy-to-clipboard */ "+QRC");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "q1tI");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ "/MKj");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "FvIY");





class ASTView extends react__WEBPACK_IMPORTED_MODULE_2__["Component"] {
    constructor(props) {
        super(props);
        this.state = {
            nodeStats: {}
        };
        this.rootRef = react__WEBPACK_IMPORTED_MODULE_2__["createRef"]();
    }
    componentDidUpdate() {
        // const rect = this.rootRef.current.getBoundingClientRect();
        // just a rude hack
        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;
    }
    shouldComponentUpdate(nextProps, nextState) {
        // TODO: implement it
        return true;
    }
    // tslint:disable-next-line:typedef
    render() {
        const slastDocument = this.props.sourceFile.slastDocument;
        const style = {
            height: 'calc(100vh - 205px)',
            overflowY: 'auto'
        };
        return (react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("div", { ref: this.rootRef },
            react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"], { style: style, selection: true, size: 'small', className: 'astlist' }, this.renderASTNode(slastDocument ? slastDocument.root : null))));
    }
    renderASTNode(node, idx = '0') {
        if (!node) {
            return null;
        }
        const { nodeStats } = this.state;
        const forceShow = idx.split('.').length < 2;
        const show = forceShow || (nodeStats[idx] || { opened: false, selected: false }).opened;
        const selected = (nodeStats[idx] || { opened: false, selected: false }).selected;
        if (node.value) {
            return (react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Item, { key: idx, onClick: this.handleNodeClick.bind(this, idx, node), onMouseOver: this.handleNodeOver.bind(this, idx, node), onMouseOut: this.handleNodeOut.bind(this, idx, node), className: 'astnode' },
                react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Icon, { style: { minWidth: '12px' } }),
                react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Header, null, node.name),
                    react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Description, null, node.value))));
        }
        else {
            let children = null;
            if (show) {
                children = (react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].List, { className: 'astlist' }, node.children.map((node, i) => this.renderASTNode(node, `${idx}.${i}`)).reverse()));
            }
            return (react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Item, { key: idx, onClick: this.handleNodeClick.bind(this, idx, node), onMouseOver: this.handleNodeOver.bind(this, idx, node), onMouseOut: this.handleNodeOut.bind(this, idx, node), className: 'astnode' },
                react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Icon, { name: (show ? `chevron down` : `chevron right`) }),
                react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_2__["createElement"](semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["List"].Header, null,
                        node.name,
                        "\u00A0",
                        react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("a", { href: '/', style: ({ display: (selected ? 'inline' : 'none') }), onClick: this.handleCopyClick.bind(this, idx, node) }, "Copy")),
                    children)));
        }
    }
    async handleCopyClick(idx, node, e) {
        e.preventDefault();
        e.stopPropagation();
        let out = [];
        out.push(`/**`);
        out.push(` * AST example:`);
        out.push(` *    ${node.name}`);
        out = out
            .concat(node.children.slice()
            .map(node => ` *       ${node.children ? '+' : ' '} ${node.name} ${node.value ? `= \'${node.value}\'` : ''}`));
        out.push(` */`);
        copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__(out.join('\n'), { debug: true });
    }
    async handleNodeOver(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        let val = { opened: false, selected: false, ...nodeStats[idx] };
        val.selected = !val.selected;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
        this.props.onNodeOver(idx, node);
    }
    async handleNodeOut(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        const val = { opened: false, selected: false, ...nodeStats[idx] };
        val.selected = !val.selected;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
        this.props.onNodeOut(idx);
    }
    handleNodeClick(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        const val = { opened: false, selected: false, ...nodeStats[idx] };
        val.opened = !val.opened;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
    }
}
/* harmony default export */ __webpack_exports__["default"] = (Object(react_redux__WEBPACK_IMPORTED_MODULE_3__["connect"])(Object(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__["mapProps"])(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__["getCommon"]), {})(ASTView));


/***/ }),

/***/ "zX2+":
/*!*************************************!*\
  !*** ./src/lib/idl/IDiagnostics.ts ***!
  \*************************************/
/*! exports provided: EDiagnosticCategory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDiagnosticCategory", function() { return EDiagnosticCategory; });
var EDiagnosticCategory;
(function (EDiagnosticCategory) {
    EDiagnosticCategory[EDiagnosticCategory["k_Warning"] = 0] = "k_Warning";
    EDiagnosticCategory[EDiagnosticCategory["k_Error"] = 1] = "k_Error";
})(EDiagnosticCategory || (EDiagnosticCategory = {}));


/***/ }),

/***/ "zioJ":
/*!****************************************!*\
  !*** ./src/lib/idl/EAnalyzerErrors.ts ***!
  \****************************************/
/*! exports provided: EAnalyzerErrors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAnalyzerErrors", function() { return EAnalyzerErrors; });
var EAnalyzerErrors;
(function (EAnalyzerErrors) {
    EAnalyzerErrors[EAnalyzerErrors["SystemTypeRedefinition"] = 2202] = "SystemTypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["TypeRedefinition"] = 2203] = "TypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["VariableRedefinition"] = 2204] = "VariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemVariableRedefinition"] = 2205] = "SystemVariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedifinition"] = 2206] = "FunctionRedifinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemFunctionRedefinition"] = 2207] = "SystemFunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedTypeDecl"] = 2208] = "UnsupportedTypeDecl";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedExpr"] = 2209] = "UnsupportedExpr";
    EAnalyzerErrors[EAnalyzerErrors["UnknownVarName"] = 2210] = "UnknownVarName";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticOperation"] = 2211] = "InvalidArithmeticOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticAssigmentOperation"] = 2212] = "InvalidArithmeticAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidAssigmentOperation"] = 2213] = "InvalidAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLeftHandSideInAssignment"] = 2214] = "InvalidLeftHandSideInAssignment";
    EAnalyzerErrors[EAnalyzerErrors["InvalidRelationalOperation"] = 2215] = "InvalidRelationalOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLogicOperation"] = 2216] = "InvalidLogicOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditionType"] = 2217] = "InvalidConditionType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditonValueTypes"] = 2218] = "InvalidConditonValueTypes";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeUsage"] = 2219] = "InvalidCastTypeUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeNotBase"] = 2220] = "InvalidCastTypeNotBase";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastUnknownType"] = 2221] = "InvalidCastUnknownType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidUnaryOperation"] = 2222] = "InvalidUnaryOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotArray"] = 2223] = "InvalidPostfixNotArray";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotIntIndex"] = 2224] = "InvalidPostfixNotIntIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotField"] = 2225] = "InvalidPostfixNotField";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixArithmetic"] = 2226] = "InvalidPostfixArithmetic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotFunction"] = 2227] = "InvalidComplexNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotType"] = 2228] = "InvalidComplexNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotConstructor"] = 2229] = "InvalidComplexNotConstructor";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileNotFunction"] = 2230] = "InvalidCompileNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileFunctionNotValid"] = 2231] = "InvalidCompileFunctionNotValid";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedefinition"] = 2232] = "FunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidWhileCondition"] = 2233] = "InvalidWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidDoWhileCondition"] = 2234] = "InvalidDoWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidIfCondition"] = 2235] = "InvalidIfCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitExpr"] = 2236] = "InvalidForInitExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitEmptyIterator"] = 2237] = "InvalidForInitEmptyIterator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionEmpty"] = 2238] = "InvalidForConditionEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionRelation"] = 2239] = "InvalidForConditionRelation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepEmpty"] = 2240] = "InvalidForStepEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepOperator"] = 2241] = "InvalidForStepOperator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepExpr"] = 2242] = "InvalidForStepExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructName"] = 2243] = "InvalidNewFieldForStructName";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructSematic"] = 2244] = "InvalidNewFieldForStructSematic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewAnnotationVar"] = 2245] = "InvalidNewAnnotationVar";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterDefenitionDefaultNeeded"] = 2246] = "InvalidFunctionParameterDefenitionDefaultNeeded";
    EAnalyzerErrors[EAnalyzerErrors["CannotChooseFunction"] = 2247] = "CannotChooseFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFuncDefenitionReturnType"] = 2248] = "InvalidFuncDefenitionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSystemFunctionReturnType"] = 2249] = "InvalidSystemFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameNotType"] = 2250] = "InvalidTypeNameNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameTemplateNotFound"] = 2251] = "InvalidTypeNameTemplateNotFound";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeScope"] = 2252] = "InvalidTypeScope";
    EAnalyzerErrors[EAnalyzerErrors["CannotProduceType"] = 2253] = "CannotProduceType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeVectorMatrix"] = 2254] = "InvalidTypeVectorMatrix";
    EAnalyzerErrors[EAnalyzerErrors["TechniqueNameRedefinition"] = 2255] = "TechniqueNameRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionRecursionNotAllowed"] = 2256] = "InvalidFunctionRecursionNotAllowed";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionImplementationNotFound"] = 2257] = "InvalidFunctionImplementationNotFound";
    // InvalidFunctionUsageVertex,
    // InvalidFunctionUsagePixel,
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithVertexShader"] = 2258] = "FunctionIsNotCompatibleWithVertexShader";
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithPixelShader"] = 2259] = "FunctionIsNotCompatibleWithPixelShader";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtVoid"] = 2260] = "InvalidReturnStmtVoid";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtEmpty"] = 2261] = "InvalidReturnStmtEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtTypesNotEqual"] = 2262] = "InvalidReturnStmtTypesNotEqual";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnType"] = 2263] = "InvalidFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterUsage"] = 2264] = "InvalidFunctionParameterUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForWriting"] = 2265] = "InvalidTypeForWriting";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForReading"] = 2266] = "InvalidTypeForReading";
    EAnalyzerErrors[EAnalyzerErrors["InvalidExprIsNotLValue"] = 2267] = "InvalidExprIsNotLValue";
    EAnalyzerErrors[EAnalyzerErrors["InvalidVariableInitializing"] = 2268] = "InvalidVariableInitializing";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedStateIndex"] = 2269] = "UnsupportedStateIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSamplerTexture"] = 2270] = "InvalidSamplerTexture";
    EAnalyzerErrors[EAnalyzerErrors["CannotCalcPadding"] = 2271] = "CannotCalcPadding";
    EAnalyzerErrors[EAnalyzerErrors["ImportedComponentNotExists"] = 2272] = "ImportedComponentNotExists";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnStmtNotFound"] = 2273] = "InvalidFunctionReturnStmtNotFound";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedProvideAs"] = 2274] = "UnsupportedProvideAs";
    EAnalyzerErrors[EAnalyzerErrors["UnreachableCode"] = 2275] = "UnreachableCode";
    //
    //
    //
    EAnalyzerErrors[EAnalyzerErrors["PartFx_VertexShaderParametersMismatch"] = 2276] = "PartFx_VertexShaderParametersMismatch";
    EAnalyzerErrors[EAnalyzerErrors["PartFx_InvalidSpawnStmtInitializerNotFound"] = 2277] = "PartFx_InvalidSpawnStmtInitializerNotFound";
})(EAnalyzerErrors || (EAnalyzerErrors = {}));
;


/***/ })

},[[0,"runtime","vendors"]]]);
//# sourceMappingURL=main.10dba135df35f901326b.bundle.js.map