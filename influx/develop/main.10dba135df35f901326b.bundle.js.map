{"version":3,"sources":["webpack:///./src/lib/fx/analisys/instructions/TechniqueInstruction.ts","webpack:///./src/lib/bf/bf.ts","webpack:///./src/lib/fx/analisys/helpers/expression.ts","webpack:///./src/lib/util/Diagnostics.ts","webpack:///./src/lib/fx/FXSLDocument.ts","webpack:///util (ignored)","webpack:///./src/lib/fx/analisys/instructions/IfStmtInstruction.ts","webpack:///util (ignored)?9cd9","webpack:///./src/lib/parser/ParseTree.ts","webpack:///./src/lib/fx/analisys/instructions/Instruction.ts","webpack:///./src/lib/idl/ERenderStateValues.ts","webpack:///./src/lib/fx/bytecode/VM/index.ts","webpack:///./src/lib/fx/analisys/instructions/CastExprInstruction.ts","webpack:///buffer (ignored)","webpack:///./src/lib/fx/translators/Output.ts","webpack:///./src/lib/fx/bytecode/UAVPool.ts","webpack:///./src/sandbox/logic/index.ts","webpack:///crypto (ignored)","webpack:///./src/lib/fx/analisys/instructions/FloatInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts","webpack:///fs (ignored)","webpack:///./src/lib/path/path.ts","webpack:///./src/lib/fx/analisys/instructions/BoolInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/IdExprInstruction.ts","webpack:///./src/sandbox/containers/playground/Playground.tsx","webpack:///./src/lib/idl/ERenderStates.ts","webpack:///./src/lib/fx/analisys/helpers/type.ts","webpack:///./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts","webpack:///./src/lib/parser/AbstractParser.ts","webpack:///./src/lib/fx/analisys/instructions/ProvideInstruction.ts","webpack:///./src/sandbox/containers/editor/LanguageServiceProvider.ts","webpack:///./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/StringInstruction.ts","webpack:///./src/sandbox/logic/fxRuntime.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts","webpack:///./src/lib/idl/bytecode/EOperations.ts","webpack:///./src/lib/fx/analisys/instructions/IdInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts","webpack:///./src/sandbox/containers/playground/PipelineNEXT.ts","webpack:///./src/lib/idl/part/IPartFx.ts","webpack:///./src/lib/fx/translators/FxTranslator.ts","webpack:///./src/lib/fx/Visitors.ts","webpack:///./src/lib/idl/IInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts","webpack:///./src/lib/parser/Item.ts","webpack:///./src/lib/fx/bytecode/ConstantPool.ts","webpack:///./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts","webpack:///./src/lib/fx/analisys/ProgramScope.ts","webpack:///./src/sandbox/components/index.ts","webpack:///./src/lib/fx/bytecode/VM/uav.ts","webpack:///./src/sandbox/reducers/index.ts","webpack:///./src/lib/fx/analisys/FxAnalyzer.ts","webpack:///./src/lib/util/StringRef.ts","webpack:///./src/lib/idl/parser/IParser.ts","webpack:///./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts","webpack:///./src/lib/util/DistinctColor.ts","webpack:///./src/lib/fx/analisys/instructions/SamplerStateInstruction.ts","webpack:///./src/lib/idl/bytecode/index.ts","webpack:///./src/lib/fx/autotests/index.ts","webpack:///./src/sandbox/reducers/sourceFile.ts","webpack:///./src/lib/fx/analisys/Analyzer.ts","webpack:///./src/lib/fx/SLParser.ts","webpack:///./src/sandbox/containers/ParserParameters.tsx","webpack:///./src/lib/fx/analisys/helpers/instruction.ts","webpack:///./src/lib/fx/analisys/instructions/SamplerStateBlockInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/IntInstruction.ts","webpack:///./src/lib/fx/AnalyzerDiagnostics.ts","webpack:///./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts","webpack:///./src/lib/fx/bytecode/InstructionList.ts","webpack:///./src/lib/fx/translators/GlslEmitter.ts","webpack:///./src/sandbox/reducers/router.ts","webpack:///./src/sandbox/components/FileListView.tsx","webpack:///./src/lib/parser/Lexer.ts","webpack:///./src/sandbox/containers/editor/Editor.tsx","webpack:///./src/lib/bf/index.ts","webpack:///./src/lib/fx/bytecode/DebugLayout.ts","webpack:///./src/sandbox/components/MemoryView.tsx","webpack:///./src/lib/fx/analisys/helpers/variable.ts","webpack:///./src/sandbox/containers/ShaderTranslatorView.tsx","webpack:///./src/sandbox/index-webpack.pug","webpack:///./src/sandbox/reducers/handleActions.ts","webpack:///./src/lib/fx/analisys/SystemScope.ts","webpack:///./src/lib/fx/analisys/instructions/ForStmtInstruction.ts","webpack:///./src/lib/fx/SLDocument.ts","webpack:///./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/TypedInstruction.ts","webpack:///./src/lib/parser/symbols.ts","webpack:///./src/sandbox/containers/BytecodeView.tsx","webpack:///./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts","webpack:///./src/lib/idl/EAnalyzerWarnings.ts","webpack:///./src/lib/fx/SLASTDocument.ts","webpack:///./src/sandbox/containers/index.ts","webpack:///./src/lib/fx/bytecode/index.ts","webpack:///./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts","webpack:///./src/lib/fx/bytecode/VM/native.ts","webpack:///./src/lib/fx/translators/FxEmitter.ts","webpack:///./src/lib/common.ts","webpack:///./src/lib/fx/analisys/instructions/CompileExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts","webpack:///./src/lib/idl/ITexture.ts","webpack:///./src/lib/fx/analisys/instructions/InitExprInstruction.ts","webpack:///./src/lib/parser/ASTDocument.ts","webpack:///./src/sandbox/containers/App.tsx","webpack:///./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts","webpack:///./src/sandbox/containers/playground/index.ts","webpack:///./src/lib/fx/analisys/instructions/InstructionCollector.ts","webpack:///./src/lib/fx/bytecode/sizeof.ts","webpack:///./src/sandbox/containers/playground/ThreeScene.tsx","webpack:///./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PassInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts","webpack:///./src/lib/fx/bytecode/PromisedAddress.ts","webpack:///./src/lib/fx/analisys/instructions/DeclInstruction.ts","webpack:///./src/sandbox/containers/editor/styles.jss.ts","webpack:///./src/lib/fx/bytecode/Context.ts","webpack:///./src/lib/fx/translators/BaseEmitter.ts","webpack:///./src/lib/fx/analisys/helpers/fn.ts","webpack:///./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts","webpack:///./src/lib/fx/bytecode/Bytecode.ts","webpack:///./src/lib/fx/analisys/instructions/StmtInstruction.ts","webpack:///./src/lib/fx/bytecode/common.ts","webpack:///./src/lib/fx/analisys/instructions/AttributeInstruction.ts","webpack:///./src/sandbox/actions/ActionTypeKeys.ts","webpack:///./src/sandbox/index.tsx","webpack:///./src/lib/uri/uri.ts","webpack:///./src/sandbox/components/ProgramView.tsx","webpack:///./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts","webpack:///./src/lib/fx/bytecode/SymbolTable.ts","webpack:///./src/lib/fx/analisys/helpers/index.ts","webpack:///./src/lib/parser/State.ts","webpack:///./src/sandbox/reducers/parserParams.ts","webpack:///./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts","webpack:///./src/lib/parser/util.ts","webpack:///./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts","webpack:///./src/lib/fx/bytecode/VM/dispatch.ts","webpack:///./src/sandbox/logic/parsing.ts","webpack:///./src/sandbox/actions/index.ts","webpack:///./src/lib/fx/translators/CodeEmitter.ts","webpack:///./src/lib/fx/HLSL.gr","webpack:///./src/sandbox/components/ASTView.tsx","webpack:///./src/lib/idl/IDiagnostics.ts","webpack:///./src/lib/idl/EAnalyzerErrors.ts"],"names":[],"mappings":"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","file":"main.10dba135df35f901326b.bundle.js","sourcesContent":["import { EInstructionTypes, ETechniqueType, IPassInstruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings<PassType extends IPassInstruction> extends IDeclInstructionSettings {\r\n    name: string;\r\n    techniqueType: ETechniqueType;\r\n    passList: PassType[];\r\n}\r\n\r\n\r\nexport class TechniqueInstruction<PassType extends IPassInstruction> extends DeclInstruction implements ITechniqueInstruction {\r\n    protected _name: string;\r\n    protected _techniqueType: ETechniqueType;\r\n    protected _passList: PassType[];\r\n\r\n    constructor({ name, techniqueType, passList, ...settings }: ITechniqueInstructionSettings<PassType>) {\r\n        super({ instrType: EInstructionTypes.k_TechniqueDecl, ...settings });\r\n        \r\n        this._name = name;\r\n        this._passList = passList.map(pass => Instruction.$withParent(pass, this));\r\n        this._techniqueType = techniqueType;\r\n    }\r\n\r\n    // todo: add id support?\r\n    // get id();\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    get passList(): PassType[] {\r\n        return this._passList;\r\n    }\r\n\r\n    get type(): ETechniqueType {\r\n        return this._techniqueType;\r\n    }\r\n}\r\n","/**\r\n * Сдвиг единицы на @a x позиций влево.\r\n */\r\nexport var flag = (x: number) => (1 << (x));\r\n/**\r\n * Проверка того что у @a value бит под номером @a bit равен единице.\r\n */\r\nexport var testBit = (value: number, bit: number) => ((value & flag(bit)) != 0);\r\n/**\r\n * Проверка того что у @a value равны единице все биты,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAll = (value: number, set: number) => (((value) & (set)) == (set));\r\n/**\r\n * Проверка того что у @a value равны единице хотя бы какие то из битов,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAny = (value: number, set: number) => (((value) & (set)) != 0);\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным единице\r\n */\r\nexport var setBit = (value: number, bit: number, setting: boolean = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));\r\n/**\r\n *\r\n */\r\nexport var clearBit = (value: number, bit: number) => ((value) &= ~flag((bit)));\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным нулю\r\n */\r\nexport var setAll = (value: number, set: number, setting: boolean = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var clearAll = (value: number, set: number) => ((value) &= ~(set));\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var equal = (value: number, src: number) => { value = src; };\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var isEqual = (value: number, src: number) => value == src;\r\n/**\r\n * Если число @a value равно числу @a src возвращается true\r\n */\r\nexport var isNotEqaul = (value: number, src: number) => value != src;\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var set = (value: number, src: number) => { value = src; };\r\n/**\r\n * Обнуляет число @a value\r\n */\r\nexport var clear = (value: number) => { value = 0; };\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var setFlags = (value: number, src: number) => (value |= src);\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var clearFlags = (value: number, src: number) => value &= ~src;\r\n/**\r\n * Проверяет равно ли число @a value нулю. Если равно возвращает true.\r\n * Если не равно возвращает false.\r\n */\r\nexport var isEmpty = (value: number) => (value == 0);\r\n/**\r\n * Возвращает общее количество бит числа @a value.\r\n * На самом деле возвращает всегда 32.\r\n */\r\nexport var totalBits = (value: number) => 32;\r\n\r\n\r\n/**\r\n * Возвращает общее количество ненулевых бит числа @a value.\r\n */\r\nexport var totalSet = (value: number): number => {\r\n    var count: number = 0;\r\n    var total: number = totalBits(value);\r\n\r\n    for (var i: number = total; i; --i) {\r\n        count += (value & 1);\r\n        value >>= 1;\r\n    }\r\n\r\n    return (count);\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace expression {\r\n    /**\r\n     * unwind operation returns declaration in case of correct l-value expression;\r\n     */\r\n    export function unwind(expr: IExprInstruction): IVariableDeclInstruction {\r\n        if (isNull(expr)) {\r\n            return null;\r\n        }\r\n\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return unwind((<IPostfixPointInstruction>expr).element);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return unwind((<IPostfixIndexInstruction>expr).element);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return (<IIdExprInstruction>expr).decl;\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                // arithmetic expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_InitExpr:\r\n                assert(false, 'init expression doesn\\'t support unwind operation');\r\n                return null;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                // todo: reseach how it work in HLSL\r\n                //// assigment expression returns right-hand value;\r\n                return unwind((<IAssignmentExprInstruction>expr).left);\r\n            case EInstructionTypes.k_CastExpr:\r\n                // cast expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // unary expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                // relation expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                // ctor call expression is not allowed as l-value;\r\n                // todo: allow it?\r\n                return null;\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return unwind((<IComplexExprInstruction>expr).expr);\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n                // literal cannot be a left-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                // function call expression returns right-hand value;\r\n                return null;\r\n            default:\r\n                assert(false, \"unsupported expr found\");\r\n                return null;\r\n        }\r\n    }\r\n}\r\n","import { EDiagnosticCategory, IDiagnosticEntry, IDiagnosticMessage, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\n\r\nimport { IMap } from \"../idl/IMap\";\r\nimport { IPosition, IRange } from \"../idl/parser/IParser\";\r\n\r\nfunction locToString(loc: IPosition) {\r\n    return `${loc.line},${loc.column}`;\r\n}\r\n\r\n\r\nfunction rangeToString(range: IRange) {\r\n    return `${locToString(range.start)}:${locToString(range.end)}`;\r\n}\r\n\r\n\r\nfunction readKey(desc: Object, key: string) {\r\n    let keyParts: string[] = key.split('.');\r\n    if (keyParts.length > 1) {\r\n        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));\r\n    }\r\n    return desc[keyParts[0]];\r\n}\r\n\r\n\r\nfunction fillPattern(pattern: string, desc: Object): string {\r\n    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {\r\n        return readKey(desc, key);\r\n    });\r\n}\r\n\r\nexport class DiagnosticException<DESC_T> extends Error {\r\n    host: Diagnostics<DESC_T>;\r\n\r\n    constructor(host: Diagnostics<DESC_T>, mesg: IDiagnosticMessage) {\r\n        super(mesg.content);\r\n        Error.captureStackTrace(this, DiagnosticException);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Diagnostics <DESC_T>{\r\n    protected _name: string;\r\n    protected _codePrefix: string;\r\n    protected _entries: IDiagnosticEntry<DESC_T>[];\r\n\r\n    constructor(name: string, codePrefix: string) {\r\n        this._name = name;\r\n        this._codePrefix = (codePrefix || '').toUpperCase();\r\n        this.reset();\r\n    }\r\n\r\n    protected emitException(): void {\r\n        throw new DiagnosticException<DESC_T>(this, this.getLastError());\r\n    }\r\n\r\n    reset() {\r\n        this._entries = [];\r\n    }\r\n\r\n    resolve(): IDiagnosticReport {\r\n        let report: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        for (let entry of this._entries) {\r\n            let message = this.resolveEntry(entry);\r\n\r\n            switch(message.category) {\r\n                case EDiagnosticCategory.k_Warning:\r\n                    report.warnings ++;\r\n                    break;\r\n                case EDiagnosticCategory.k_Error:\r\n                    report.errors ++;\r\n                    break;\r\n            }\r\n            report.messages.push(message);\r\n        }\r\n\r\n        return report;\r\n    }\r\n\r\n    private resolveEntry(entry: IDiagnosticEntry<DESC_T>): IDiagnosticMessage {\r\n        // let { category, desc } = entry;\r\n\r\n        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();\r\n        let loc: string = null;\r\n        let range: IRange;\r\n        let start: IPosition;\r\n        let end: IPosition;\r\n        let file = this.resolveFilename(entry.code, entry.desc);\r\n\r\n        if (range = this.resolveRange(entry.code, entry.desc)) {\r\n            ({ start, end } = range);\r\n            loc = rangeToString(range);\r\n        } \r\n        else {\r\n            start = this.resolvePosition(entry.code, entry.desc);\r\n            loc = locToString(start);\r\n        }\r\n\r\n        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;\r\n        let code = `${this._codePrefix}${entry.code}`;\r\n        let category = entry.category;\r\n        return { code, category, content, file, start, end };\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: DESC_T): string {\r\n        return '[unknown]';\r\n    }\r\n\r\n    protected resolvePosition(code: number, desc: DESC_T): IPosition {\r\n        return { file: null, line: 0, column: 0 };\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: DESC_T): IRange {\r\n        return null;\r\n    }\r\n\r\n    protected resolveDescription(code:number, category: EDiagnosticCategory, desc: DESC_T): string {\r\n        let diagMesgs = this.diagnosticMessages();\r\n        if (!diagMesgs) {\r\n            console.error(`Diagnostic messages of '${this._name}' not found.`);\r\n            return '[no description found]';\r\n        }\r\n\r\n        if (!diagMesgs[code]) {\r\n            return `[no description found for code '${code}']`;\r\n        }\r\n\r\n        return fillPattern(diagMesgs[code], desc);\r\n    }\r\n\r\n    protected diagnosticMessages(): IMap<string> {\r\n        return null;\r\n    }\r\n\r\n    error(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Error, code, desc });\r\n    }\r\n\r\n    warning(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Warning, code, desc });\r\n    }\r\n\r\n    // add error and emit an exception in order to interrupt processing\r\n    critical(code: number, desc: DESC_T) {\r\n        this.error(code, desc);\r\n        this.emitException();\r\n    }\r\n\r\n    prettyPrint(): string {\r\n        return null;//JSON.stringify(this._errors, null, '\\t');\r\n    }\r\n\r\n    hasErrors(): boolean {\r\n        return this._entries.filter(entry => entry.category === EDiagnosticCategory.k_Error).length > 0;\r\n    }\r\n\r\n    getLastError(): IDiagnosticMessage {\r\n        for (let i = this._entries.length - 1; i >= 0; --i) {\r\n            if (this._entries[i].category === EDiagnosticCategory.k_Error) {\r\n                return this.resolveEntry(this._entries[i]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static mergeReports(reportList: IDiagnosticReport[]): IDiagnosticReport {\r\n        let result: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        reportList.forEach((report) => {\r\n            result.errors += report.errors;\r\n            result.warnings += report.warnings;\r\n            result.messages = result.messages.concat(report.messages);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    static stringify(report: IDiagnosticReport): string {\r\n        return report.messages.map(mesg => mesg.content).join('\\n');\r\n    }\r\n\r\n    static asRange(mesg: IDiagnosticMessage): IRange {\r\n        let range: IRange = { start: mesg.start, end: mesg.end };\r\n\r\n        if (!range.end) {\r\n            range.end = { ...range.start };\r\n        }\r\n\r\n        const { start, end } = range;\r\n\r\n        if (end.line == start.line && end.column == start.column) {\r\n            end.column +=1;\r\n        }\r\n\r\n        return range;\r\n    }\r\n}","import { isNumber, isObject, isString } from \"@lib/common\";\r\nimport { IScope } from \"@lib/idl/IInstruction\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\n\r\nimport { FxAnalyzer } from \"./analisys/FxAnalyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\nexport async function createFXSLDocument(textDocument: ITextDocument, flags?: number, document?: ISLDocument): Promise<ISLDocument>;\r\nexport async function createFXSLDocument(slastDocument: ISLASTDocument, document?: ISLDocument): Promise<ISLDocument>;\r\nexport async function createFXSLDocument(param1: ISLASTDocument | ITextDocument, param2?: number | ISLDocument, param3?: ISLDocument): Promise<ISLDocument> {\r\n    let textDocument: ITextDocument;\r\n    let slastDocument: ISLASTDocument;\r\n    let slDocument: ISLDocument;\r\n\r\n    if (isString(arguments[0].source)) {    \r\n        const flags = isNumber(arguments[1]) ? <number>arguments[1] : undefined;\r\n        textDocument = <ITextDocument>arguments[0];\r\n        slastDocument = await createSLASTDocument(textDocument, flags);\r\n        slDocument = arguments[2];\r\n    } else {\r\n        slastDocument = <ISLASTDocument>arguments[0];\r\n        slDocument = arguments[1];\r\n    }\r\n    \r\n    const analyzer = new FxAnalyzer;\r\n    return await analyzer.parse(slastDocument, slDocument);\r\n}\r\n\r\n","/* (ignored) */","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAttributeInstruction, IExprInstruction, IIfStmtInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IIfStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    conseq: IStmtInstruction;\r\n    contrary?: IStmtInstruction;\r\n    attributes?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent if(expr) stmt or if(expr) stmt else stmt\r\n * ( if || if_else ) Expr Stmt [Stmt]\r\n */\r\nexport class IfStmtInstruction extends StmtInstruction implements IIfStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n    \r\n    constructor({ cond, conseq, attributes = null, contrary = null, ...settings }: IIfStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IfStmt, ...settings });\r\n\r\n        this.cond = Instruction.$withParent(cond, this);\r\n        this.conseq = Instruction.$withParent(conseq, this);\r\n        this.contrary = Instruction.$withParent(contrary, this);\r\n        this.attributes = (attributes || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        if (isNull(this.contrary)) {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \")\";\r\n            code += this.conseq.toCode();\r\n        }\r\n        else {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \") \";\r\n            code += this.conseq.toCode();\r\n            code += \"else \";\r\n            code += this.contrary.toCode();\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n","/* (ignored) */","import { assert } from \"@lib/common\";\r\nimport { ENodeCreateMode, IParseNode, IParseTree, IPosition, IRange, IRule, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { extendRange } from \"./util\";\r\n\r\nexport class ParseTree implements IParseTree {\r\n    root: IParseNode;\r\n    nodes: IParseNode[];\r\n    \r\n    readonly optimized: boolean;\r\n    \r\n    private nodesCountStack: number[];\r\n\r\n\r\n    constructor(optimized: boolean, root: IParseNode = null) {\r\n        this.root = root;\r\n        this.nodes = [];\r\n        this.optimized = optimized;\r\n\r\n        this.nodesCountStack = [];\r\n    }\r\n\r\n\r\n    get lastNode(): IParseNode {\r\n        return this.nodes[this.nodes.length - 1];\r\n    }\r\n\r\n\r\n    finishTree(): void {\r\n        this.root = this.nodes.pop();\r\n    }\r\n\r\n\r\n    addToken({ name, value, loc }: IToken): void {\r\n        const children = null;\r\n        const parent = null;\r\n        this.addNode({ name, value, loc, children, parent });\r\n    }\r\n\r\n    reduceByRule(rule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {\r\n        let iReduceCount = 0;\r\n        let nodesCountStack = this.nodesCountStack;\r\n        let ruleLength = rule.right.length;\r\n        let nodes = this.nodes;\r\n        let optimize = this.optimized ? 1 : 0;\r\n\r\n        while (ruleLength) {\r\n            iReduceCount += nodesCountStack.pop();\r\n            ruleLength--;\r\n        }\r\n\r\n        if (eCreate === ENodeCreateMode.k_Skip && iReduceCount > optimize) {\r\n            nodes.length -= iReduceCount;\r\n            nodesCountStack.push(0);\r\n        }  else if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > optimize) || \r\n            (eCreate === ENodeCreateMode.k_Necessary)) {\r\n\r\n            assert(iReduceCount > 0);\r\n            \r\n            let temp = nodes.pop();\r\n            iReduceCount--;\r\n            \r\n            const name = rule.left;\r\n            // TODO: use correct location in case of include macro. \r\n            const loc = { ...temp.loc };\r\n\r\n            const node: IParseNode = { name, children: null, parent: null, value: '', loc };\r\n\r\n            this.addLink(node, temp);\r\n\r\n            while (iReduceCount) {\r\n                assert(nodes.length > 0);\r\n                this.addLink(node, nodes.pop());\r\n                iReduceCount--;\r\n            }\r\n            \r\n            nodes.push(node);\r\n            nodesCountStack.push(1);      \r\n        }\r\n        else {\r\n            nodesCountStack.push(iReduceCount);\r\n        }\r\n    }\r\n\r\n    private addNode(node: IParseNode): void {\r\n        this.nodes.push(node);\r\n        this.nodesCountStack.push(1);\r\n    }\r\n\r\n    $pop(loc: IRange = null): void {\r\n        let count = this.nodesCountStack.pop();\r\n        while (count) {\r\n            let node = this.nodes.pop();\r\n            if (loc) {\r\n                extendRange(loc, node.loc);\r\n            }\r\n            count--;\r\n        }\r\n    }\r\n \r\n    private addLink(parent: IParseNode, child: IParseNode): void {\r\n        parent.children = parent.children || [];\r\n        \r\n        extendRange(parent.loc, child.loc);\r\n        \r\n        parent.children.push(child);\r\n        child.parent = parent;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree {\r\n        return new ParseTree(this.optimized, this.cloneNode(this.root));\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // FIXME: location should be clonned too\r\n    private cloneNode({ name, value, children }: IParseNode): IParseNode {\r\n        const clone: IParseNode = { name, value, children: null, parent: null };\r\n        if (children) { \r\n            children.forEach(child => this.addLink(clone, this.cloneNode(child)))\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toString(): string {\r\n        if (this.root) {\r\n            return this.toStringNode(this.root);\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    /** @deprecated */\r\n    private toStringNode(node: IParseNode, padding: string = \"\"): string {\r\n        let res: string = padding + \"{\\n\";\r\n        let oldPadding: string = padding;\r\n        let defaultPadding: string = \"  \";\r\n\r\n        padding += defaultPadding;\r\n\r\n        if (node.value) {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"value : \\\"\" + node.value + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"children : [\";\r\n\r\n            let children: IParseNode[] = node.children;\r\n\r\n            if (children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n\r\n                for (let i = children.length - 1; i >= 0; i--) {\r\n                    res += this.toStringNode(children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toHTMLString(node: IParseNode, padding: string = \"\") {\r\n        node = node || this.root;\r\n        let res = padding + \"{\\n\";\r\n        let oldPadding = padding;\r\n        let defaultPadding = \"  \";\r\n        padding += defaultPadding;\r\n        if (node.value) {\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">name</b>: \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">value</b>: \\\"\" + node.value + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            let i;\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">name</i>: \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">children</i>: [\";\r\n            if (node.children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n                for (i = node.children.length - 1; i >= 0; i--) {\r\n                    res += this.toHTMLString(node.children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { ECheckStage, EInstructionTypes, IInstruction, IInstructionError, IScope } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport interface IInstructionSettings {\r\n    scope: IScope;\r\n\r\n    sourceNode?: IParseNode;\r\n    visible?: boolean;\r\n\r\n    instrType?: EInstructionTypes;\r\n}\r\n\r\nexport class Instruction implements IInstruction {\r\n    private _sourceNode: IParseNode;\r\n    private _instructionID: number;\r\n    private _instructionType: EInstructionTypes;\r\n    private _scope: IScope;\r\n    private _parent: IInstruction;\r\n    private _lastError: IInstructionError;\r\n\r\n    private static INSTRUCTION_COUNTER: number = 0;\r\n\r\n    constructor({\r\n        scope,\r\n        instrType/* = EInstructionTypes.k_Instruction*/,\r\n        sourceNode = null,\r\n        visible = true\r\n    }: IInstructionSettings) {\r\n\r\n        this._sourceNode = sourceNode;\r\n        this._instructionType = instrType;\r\n        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);\r\n        this._scope = scope;\r\n        this._parent = null;\r\n        this._lastError = null;\r\n    }\r\n\r\n\r\n    get parent(): IInstruction {\r\n        // console.assert(this._parent, \"Parent is not defined!\");\r\n        return this._parent;\r\n    }\r\n\r\n\r\n    get instructionType(): EInstructionTypes {\r\n        console.assert(this._instructionType != EInstructionTypes.k_Instruction, \"Instruction type 'k_Instruction' is forbidden.\");\r\n        return this._instructionType;\r\n    }\r\n\r\n    get instructionName(): string {\r\n        return EInstructionTypes[this.instructionType];\r\n    }\r\n\r\n\r\n    get instructionID(): number {\r\n        return this._instructionID;\r\n    }\r\n\r\n\r\n    get scope(): IScope {\r\n        if (!isNull(this._scope)) {\r\n            return this._scope;\r\n        }\r\n\r\n        if (!isNull(this.parent)) {\r\n            return this.parent.scope;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    get sourceNode(): IParseNode {\r\n        return this._sourceNode;\r\n    }\r\n\r\n    _getLastError(): IInstructionError {\r\n        return this._lastError;\r\n    }\r\n\r\n    _setError(eCode: number, pInfo: any = null): void {\r\n        this._lastError = { code: eCode, info: pInfo }\r\n    }\r\n\r\n    _clearError(): void {\r\n        this._lastError = null\r\n    }\r\n\r\n    _isErrorOccured(): boolean {\r\n        return !isNull(this._lastError);\r\n    }\r\n\r\n\r\n    /**\r\n     * Check that instuction is valid.\r\n     */\r\n    _check(eStage: ECheckStage, pInfo: any = null): boolean {\r\n        if (this._isErrorOccured()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    $withParent<T extends IInstruction>(parent: IInstruction | null): T {\r\n        console.assert(this._parent == null, \"parent redefenition detected!\");\r\n        if (this.instructionType === EInstructionTypes.k_SystemType && (this as any).name === 'float' && this._parent == null && parent != null) {\r\n            debugger;\r\n        }\r\n        this._parent = parent;\r\n        // todo: remove this hack!\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    // An auxiliary function created to maintain the clarity of the code.\r\n    $withNoParent<T extends IInstruction>(): T {\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    static $withParent<T extends IInstruction>(child: T, parent: IInstruction): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withParent(parent);\r\n    }\r\n\r\n    static $withNoParent<T extends IInstruction>(child: T): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withNoParent();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","\r\nexport enum ERenderStateValues {\r\n    UNDEF = 0,\r\n\r\n    TRUE,\r\n    FALSE,\r\n    ZERO,\r\n    ONE,\r\n    SRCCOLOR,\r\n    INVSRCCOLOR,\r\n    SRCALPHA,\r\n    INVSRCALPHA,\r\n    DESTALPHA,\r\n    INVDESTALPHA,\r\n    DESTCOLOR,\r\n    INVDESTCOLOR,\r\n    SRCALPHASAT,\r\n    NONE,\r\n    CW,\r\n    CCW,\r\n    FRONT,\r\n    BACK,\r\n    FRONT_AND_BACK,\r\n    NEVER,\r\n    LESS,\r\n    EQUAL,\r\n    LESSEQUAL,\r\n    GREATER,\r\n    NOTEQUAL,\r\n    GREATEREQUAL,\r\n    ALWAYS,\r\n\r\n    FUNCADD,\r\n    FUNCSUBTRACT,\r\n    FUNCREVERSESUBTRACT,\r\n\r\n    // HACK: temp hack\r\n    LINELIST,\r\n    LINESTRIP,\r\n    TRIANGLELIST,\r\n    TRAINGLESTRIP,\r\n    POINTLIST\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull, isString } from \"@lib/common\";\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport { CBUFFER0_REGISTER, INPUT0_REGISTER } from \"@lib/fx/bytecode/Bytecode\";\r\nimport { u8ArrayToI32 } from \"@lib/fx/bytecode/common\";\r\nimport InstructionList from \"@lib/fx/bytecode/InstructionList\";\r\nimport { EChunkType, EOperation } from \"@lib/idl/bytecode\";\r\nimport { IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\nimport { IConstantReflection } from \"../ConstantPool\";\r\nimport { asNative } from \"./native\";\r\n\r\nexport { default as dispatch } from \"./dispatch\";\r\nexport { asNative, asNativeInner } from './native';\r\nexport { createUAV } from './uav';\r\n\r\n\r\n\r\n\r\n// // import { remote } from 'electron';\r\n// import * as isElectron from 'is-electron-renderer';\r\n\r\ndeclare const MODE: string;\r\n\r\ntype Chunk = Uint8Array;\r\ntype ChunkMap = IMap<Chunk>;\r\n\r\nexport function decodeChunks(code: Uint8Array, chunks?: ChunkMap): ChunkMap {\r\n    if (!isDefAndNotNull(chunks)) {\r\n        chunks = {};\r\n    }\r\n\r\n    const view = new DataView(code.buffer, code.byteOffset, code.byteLength);\r\n    const type = view.getUint32(0, true);\r\n    const byteLength = view.getUint32(4, true) << 2;\r\n    const content = new Uint8Array(code.buffer, code.byteOffset + 8, byteLength);\r\n\r\n    chunks[type] = content;\r\n\r\n    const nextChunkOffset = content.byteOffset + content.byteLength;\r\n    if (nextChunkOffset < code.buffer.byteLength) {\r\n        decodeChunks(new Uint8Array(content.buffer, nextChunkOffset), chunks);\r\n    }\r\n\r\n    return chunks;\r\n}\r\n\r\n\r\nexport function decodeCodeChunk(codeChunk: Uint8Array): Uint32Array {\r\n    return new Uint32Array(codeChunk.buffer, codeChunk.byteOffset, codeChunk.byteLength >> 2);\r\n}\r\n\r\nexport function decodeConstChunk(constChunk: Uint8Array): Uint8Array {\r\n    return constChunk;\r\n}\r\n\r\n\r\n\r\n// TODO: rewrite with cleaner code\r\nexport function decodeLayoutChunk(layoutChunk: Uint8Array): IConstantReflection[] {\r\n    let readed = 0;\r\n    let count = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n    readed += 4;\r\n\r\n    let layout: IConstantReflection[] = [];\r\n    for (let i = 0; i < count; ++i) {\r\n        const nameLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const name = String.fromCharCode(...layoutChunk.subarray(readed, readed + nameLength));\r\n        readed += nameLength;\r\n\r\n        const typeLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const type = String.fromCharCode(...layoutChunk.subarray(readed, readed + typeLength));\r\n        readed += typeLength;\r\n\r\n        const semanticLength = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const semantic = String.fromCharCode(...layoutChunk.subarray(readed, readed + semanticLength));\r\n        readed += semanticLength;\r\n\r\n        const offset = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        const size = u8ArrayToI32(layoutChunk.subarray(readed, readed + 4));\r\n        readed += 4;\r\n        \r\n        layout.push({ name, type, offset, size, semantic });\r\n    }\r\n    return layout;\r\n}\r\n\r\nexport type INT32 = number;\r\n\r\nclass VM {\r\n    static $regs = new ArrayBuffer(512 * 4);\r\n    static iregs = new Int32Array(VM.$regs);\r\n    static fregs = new Float32Array(VM.$regs);\r\n    static regs = new Uint8Array(VM.$regs);\r\n\r\n    static play(data: Bundle): Uint8Array {\r\n        const ilist = data.instructions;\r\n        const iregs = VM.iregs;\r\n        const fregs = VM.fregs;\r\n        const iinput = data.input;\r\n\r\n        let i5 = 0;                      // current instruction;\r\n        end:\r\n        while (i5 < ilist.length) {\r\n            let op = ilist[i5];\r\n            let a = ilist[i5 + 1];\r\n            let b = ilist[i5 + 2];\r\n            let c = ilist[i5 + 3];\r\n            let d = ilist[i5 + 4];\r\n\r\n            switch (op) {\r\n                // registers\r\n                case EOperation.k_I32SetConst:\r\n                    iregs[a] = b;\r\n                    break;\r\n                case EOperation.k_I32LoadRegister:\r\n                    iregs[a] = iregs[b];\r\n                    break;\r\n                // inputs\r\n                case EOperation.k_I32LoadInput:\r\n                    iregs[b] = iinput[a][c];\r\n                    break;\r\n                case EOperation.k_I32StoreInput:\r\n                    iinput[a][b] = iregs[c];\r\n                    break;\r\n                // registers pointers    \r\n                // a => dest\r\n                // b => source pointer\r\n                // c => offset\r\n                case EOperation.k_I32LoadRegistersPointer:\r\n                    iregs[a] = iregs[iregs[b] + c];\r\n                    break;\r\n                case EOperation.k_I32StoreRegisterPointer:\r\n                    iregs[iregs[a] + c] = iregs[b];\r\n                    break;\r\n                // input pointers\r\n                // a => input index\r\n                // b => dest\r\n                // c => source pointer\r\n                // d => offset\r\n                case EOperation.k_I32LoadInputPointer:\r\n                    iregs[b] = iinput[a][iregs[c] + d];\r\n                    break;\r\n                case EOperation.k_I32StoreInputPointer:\r\n                    iinput[a][iregs[b] + d] = iregs[c];\r\n                    break;\r\n\r\n                //\r\n                // Arithmetic operations\r\n                //\r\n\r\n                case EOperation.k_I32Add:\r\n                    iregs[a] = iregs[b] + iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Sub:\r\n                    iregs[a] = iregs[b] - iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Mul:\r\n                    iregs[a] = iregs[b] * iregs[c];\r\n                    break;\r\n                case EOperation.k_I32Div:\r\n                    iregs[a] = iregs[b] / iregs[c];\r\n                    break;\r\n\r\n                case EOperation.k_I32Mad:\r\n                    iregs[a] = iregs[b] + iregs[c] * iregs[d];\r\n                    break;\r\n                \r\n                case EOperation.k_I32Min:\r\n                    iregs[a] = Math.min(iregs[b], iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Max:\r\n                    iregs[a] = Math.max(iregs[b], iregs[c]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Add:\r\n                    fregs[a] = fregs[b] + fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Sub:\r\n                    fregs[a] = fregs[b] - fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Mul:\r\n                    fregs[a] = fregs[b] * fregs[c];\r\n                    break;\r\n                case EOperation.k_F32Div:\r\n                    fregs[a] = fregs[b] / fregs[c];\r\n                    break;\r\n\r\n\r\n                //\r\n                // Relational operations\r\n                //\r\n\r\n                case EOperation.k_U32LessThan:\r\n                    iregs[a] = +((iregs[b] >>> 0) < (iregs[c] >>> 0));\r\n                    break;\r\n                case EOperation.k_U32GreaterThanEqual:\r\n                    iregs[a] = +((iregs[b] >>> 0) >= (iregs[c] >>> 0));\r\n                    break;\r\n                case EOperation.k_I32LessThan:\r\n                    iregs[a] = +(iregs[b] < iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32GreaterThanEqual:\r\n                    iregs[a] = +(iregs[b] >= iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Equal:\r\n                    iregs[a] = +(iregs[b] === iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32NotEqual:\r\n                    iregs[a] = +(iregs[b] !== iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32Not:\r\n                    iregs[a] = +(!iregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32LessThan:\r\n                    fregs[a] = +(fregs[b] < fregs[c]);\r\n                    break;\r\n                case EOperation.k_F32GreaterThanEqual:\r\n                    fregs[a] = +(fregs[b] >= fregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // Logical operations\r\n                //\r\n\r\n\r\n                case EOperation.k_I32LogicalOr:\r\n                    iregs[a] = +(iregs[b] || iregs[c]);\r\n                    break;\r\n                case EOperation.k_I32LogicalAnd:\r\n                    iregs[a] = +(iregs[b] && iregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // intrinsics\r\n                //\r\n\r\n                case EOperation.k_F32Frac:\r\n                    // same as frac() in HLSL\r\n                    fregs[a] = fregs[b] - Math.floor(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Floor:\r\n                    fregs[a] = Math.floor(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Ceil:\r\n                    fregs[a] = Math.ceil(fregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Sin:\r\n                    fregs[a] = Math.sin(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Cos:\r\n                    fregs[a] = Math.cos(fregs[b]);\r\n                    break;\r\n\r\n                case EOperation.k_F32Abs:\r\n                    fregs[a] = Math.abs(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Sqrt:\r\n                    fregs[a] = Math.sqrt(fregs[b]);\r\n                    break;\r\n                case EOperation.k_F32Min:\r\n                    fregs[a] = Math.min(fregs[b], fregs[c]);\r\n                    break;\r\n                case EOperation.k_F32Max:\r\n                    fregs[a] = Math.max(fregs[b], fregs[c]);\r\n                    break;\r\n\r\n                //\r\n                // Cast\r\n                //\r\n\r\n\r\n                case EOperation.k_U32ToF32:\r\n                    fregs[a] = iregs[b] >>> 0;\r\n                    break;\r\n                case EOperation.k_I32ToF32:\r\n                    fregs[a] = iregs[b];\r\n                    break;\r\n                case EOperation.k_F32ToU32: // TODO: remove it?\r\n                case EOperation.k_F32ToI32:\r\n                    iregs[a] = Math.trunc(fregs[b]);\r\n                    break;\r\n\r\n                //\r\n                // Flow controls\r\n                //\r\n\r\n                case EOperation.k_Jump:\r\n                    // TODO: don't use multiplication here\r\n                    i5 = a;\r\n                    continue;\r\n                case EOperation.k_JumpIf:\r\n                    i5 = iregs[a] !== 0\r\n                        ? i5 + InstructionList.STRIDE /* skip one instruction */\r\n                        : i5;                         /* do nothing (cause next instruction must always be Jump) */\r\n                    break;\r\n                case EOperation.k_Ret:\r\n                    {\r\n                        break end;\r\n                    }\r\n                    break;\r\n                default:\r\n                    console.error(`unknown operation found: ${op}`);\r\n            }\r\n            i5 += InstructionList.STRIDE;\r\n        }\r\n\r\n        return VM.regs;\r\n    }\r\n}\r\n\r\nexport interface Bundle {\r\n    readonly instructions: Uint32Array;\r\n    readonly input: Int32Array[];\r\n    readonly layout: IConstantReflection[];\r\n}\r\n\r\nexport function load(code: Uint8Array): Bundle {\r\n    const chunks = decodeChunks(code);\r\n\r\n    const codeChunk = chunks[EChunkType.k_Code];\r\n    assert(isDefAndNotNull(codeChunk) && isDefAndNotNull(chunks[EChunkType.k_Constants]));\r\n    const constChunk = chunks[EChunkType.k_Constants];\r\n    const layoutChunk = chunks[EChunkType.k_Layout];\r\n\r\n    const instructions = decodeCodeChunk(codeChunk);\r\n    const constants = decodeConstChunk(constChunk);\r\n    const layout = decodeLayoutChunk(layoutChunk);\r\n    const input = Array<Int32Array>(64).fill(null);\r\n\r\n    input[CBUFFER0_REGISTER] = new Int32Array(constants.buffer, constants.byteOffset, constants.length >> 2);\r\n\r\n    return { instructions, input, layout };\r\n}\r\n\r\nexport function play(bundle: Bundle, inputs: Int32Array[] = null): Uint8Array {\r\n    if (inputs) {\r\n        for (let i = 0; i < inputs.length; ++i) {\r\n            bundle.input[INPUT0_REGISTER + i] = inputs[i];\r\n        }\r\n    }\r\n    return VM.play(bundle);\r\n}\r\n\r\n\r\nexport function resetRegisters(): void {\r\n    VM.regs.fill(0);\r\n}\r\n\r\n\r\nexport function asNativeFunction(fn: IFunctionDeclInstruction): Function\r\n{\r\n    const { code, cdl } = Bytecode.translate(fn);\r\n    const bundle = load(code);\r\n    return (...args: any[]) => {\r\n        assert(!args || args.length === 0, 'arguments not supported');\r\n        return asNative(VM.play(bundle), cdl);\r\n    };\r\n}\r\n\r\n// export async function prebuildExpression(code: Uint8Array): Promise<Bundle>;\r\n// export async function prebuildExpression(expr: string, document: ISLDocument): Promise<Bundle>;\r\n// export async function prebuildExpression(param: string | Uint8Array, param2?: ISLDocument): Promise<Bundle> {\r\n//     if (MODE === 'development') {\r\n//         resetRegisters();\r\n//     }\r\n\r\n//     let code: Uint8Array;\r\n//     if (isString(arguments[0])) {\r\n//         const expr = <string>arguments[0];\r\n//         const slDocument = <ISLDocument>arguments[1];\r\n//         const program = await Bytecode.translateExpression(expr, slDocument);\r\n//         if (isNull(program)) {\r\n//             return null;\r\n//         }\r\n//         code = program.code;\r\n//     } else {\r\n//         code = arguments[0];\r\n//     }\r\n\r\n//     return load(code);\r\n// }\r\n\r\n// TODO: use bundle inside\r\nexport async function evaluate(code: Uint8Array): Promise<any>;\r\nexport async function evaluate(expr: string, document: ISLDocument): Promise<any>;\r\nexport async function evaluate(param: string | Uint8Array, param2?: ISLDocument): Promise<any> {\r\n    if (MODE === 'development') {\r\n        resetRegisters();\r\n    }\r\n\r\n    let code: Uint8Array;\r\n    if (isString(arguments[0])) {\r\n        const expr = <string>arguments[0];\r\n        const slDocument = <ISLDocument>arguments[1];\r\n        const program = await Bytecode.translateExpression(expr, slDocument);\r\n        if (isNull(program)) {\r\n            return null;\r\n        }\r\n        const { code, cdl } = program;\r\n        return asNative(VM.play(load(code)), cdl);\r\n    } else {\r\n        code = arguments[0];\r\n    }\r\n\r\n    return VM.play(load(code));\r\n}\r\n\r\n\r\nexport function setConstant(bundle: Bundle, name: string, value: number): boolean {\r\n    const layout = bundle.layout;\r\n    const reflection = layout.find(entry => entry.name === name);\r\n    const constants = bundle.input[CBUFFER0_REGISTER];\r\n\r\n    if (!reflection) {\r\n        return false;\r\n    }\r\n\r\n    const view = new DataView(constants.buffer, constants.byteOffset + reflection.offset);\r\n\r\n    // TODO: validate layout / constant type in memory / size\r\n    switch (reflection.type) {\r\n        case 'float':\r\n            view.setFloat32(0, <number>value, true);\r\n            break;\r\n        case 'int':\r\n            view.setInt32(0, <number>value, true);\r\n            break;\r\n        case 'uint':\r\n            view.setUint32(0, <number>value, true);\r\n            break;\r\n        default:\r\n            assert(false, 'unsupported');\r\n    }\r\n\r\n    return true;\r\n}\r\n","import { type } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, ICastExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICastExprInstructionSettings extends IExprInstructionSettings {\r\n    sourceExpr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (type) expr\r\n * EMPTY_OPERATOR VariableTypeInstruction Instruction\r\n */\r\nexport class CastExprInstruction extends ExprInstruction implements ICastExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    constructor({ sourceExpr, ...settings }: ICastExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CastExpr, ...settings });\r\n        this.expr = Instruction.$withParent(sourceExpr, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `(${this.type.toCode()})${this.expr.toCode()}`;\r\n    }\r\n\r\n    \r\n    isUseless() {\r\n        return this.type.isEqual(this.expr.type);\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","/* (ignored) */","export function createOutput({ tab = '\\t', nl = '\\n' } = {}) {\r\n    let data: string[] = [''];\r\n    let nesting = [];\r\n    let count = 0;\r\n    let noNextSpace = false;\r\n\r\n    const push = (pad = tab) => (nesting.push(pad), count && newline());\r\n    const pop = () => (nesting.pop(), count && newline());\r\n    const toString = () => data.join(nl);\r\n    const ignoreNextSpace = () => noNextSpace = true;\r\n\r\n    function add(val: string) {\r\n        if (!count) {\r\n            for (let i = 0; i < nesting.length; ++i) val = nesting[i] + val;\r\n        }\r\n        \r\n        data[data.length - 1] += val;\r\n        count++;\r\n        noNextSpace = false;\r\n    }\r\n\r\n    function keyword(token: string) {\r\n        !noNextSpace && count && add(' ');\r\n        add(token);\r\n    }\r\n\r\n    function newline() {\r\n        data.push('');\r\n        count = 0;\r\n    }\r\n\r\n    return {\r\n        keyword,\r\n        ignoreNextSpace,\r\n        push,\r\n        pop,\r\n        newline,\r\n        add,\r\n        toString\r\n    };\r\n}\r\n\r\n\r\nexport type IOutput = ReturnType<typeof createOutput>;","import { assert, isNull } from \"@lib/common\";\r\nimport { variable } from \"@lib/fx/analisys/helpers\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { UAV_TOTAL, UAV0_REGISTER } from \"./Bytecode\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\n\r\nexport class UAVPool {\r\n    private _knownUAVs: IVariableDeclInstruction[];\r\n\r\n    constructor() {\r\n        this._knownUAVs = Array(UAV_TOTAL).fill(null);\r\n    }\r\n\r\n    deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        const knownUAVs = this._knownUAVs;\r\n\r\n        assert(decl.type.isUAV());\r\n\r\n        let { index, type } = variable.resolveRegister(decl);\r\n        assert(type === 'u');\r\n\r\n        const knownIndex = knownUAVs.indexOf(decl);\r\n        assert(knownIndex === -1 || knownIndex === index);\r\n\r\n        if (index === -1) {\r\n            index = knownUAVs.findIndex(decl => isNull(decl));\r\n            assert(index !== -1, `uav limit is reached (uav total: ${UAV_TOTAL})`);\r\n            knownUAVs[index] = decl;\r\n        }\r\n\r\n        knownUAVs[index] = decl;\r\n\r\n        assert(index !== -1);\r\n        assert(index < UAV_TOTAL);\r\n\r\n        const inputIndex = UAV0_REGISTER + index;\r\n        const addr = 0;\r\n        // NOTE: UAV's size is unknown in advance\r\n        // so we use maximum aligned int as possible\r\n        return new PromisedAddress({ type: EAddrType.k_Input, addr, size: 1 << 30, inputIndex });\r\n    }\r\n}","import { sourceCode as sourceActions } from '@sandbox/actions';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { ISourceFileRequest } from '@sandbox/actions/ActionTypes';\r\nimport fxRuntime from '@sandbox/logic/fxRuntime';\r\nimport parsing from '@sandbox/logic/parsing';\r\nimport { history } from '@sandbox/reducers/router';\r\nimport { getFileState } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { LOCATION_CHANGE, LocationChangeAction } from 'connected-react-router';\r\nimport { matchPath } from 'react-router';\r\nimport { createLogic, createLogicMiddleware } from 'redux-logic';\r\n\r\n\r\nconst readFile = fname => fetch(fname).then(resp => resp.text());\r\n\r\nconst fetchSourceFileLogic = createLogic<IStoreState, ISourceFileRequest['payload']>({\r\n    type: evt.SOURCE_FILE_REQUEST,\r\n    latest: true,\r\n    async process({ getState, action }, dispatch, done) {\r\n        try {\r\n            const content = await readFile(action.payload.filename);\r\n            dispatch({ type: evt.SOURCE_FILE_DROP_STATE });\r\n            dispatch({ type: evt.SOURCE_FILE_LOADED, payload: { content } });\r\n        } catch (error) {\r\n            console.warn(`Could not find file ${action.payload.filename}.`);\r\n            dispatch({ type: evt.SOURCE_FILE_DROP_STATE });\r\n            dispatch({ type: evt.SOURCE_FILE_LOADING_FAILED, payload: { error } });\r\n            // dispatch({ type: evt.SOURCE_FILE_LOADING_FAILED, payload: { error } });\r\n        } finally {\r\n            done();\r\n        }\r\n    }\r\n});\r\n\r\n\r\n\r\nexport const LOCATION_NOT_FOUND = '/NotFound';\r\nexport const LOCATION_PATTERN = '/:view/:fx?/:name?/:pass?/:property?';\r\nexport const DEFAULT_FILENAME = '@new';\r\n\r\nexport type PATH_PARAMS_TYPE = { view: string; fx?: string; name?: string; pass?: string; property?: string };\r\n\r\n\r\nconst navigationLogic = createLogic<IStoreState, LocationChangeAction['payload']>({\r\n    type: LOCATION_CHANGE,\r\n    latest: true,\r\n    debounce: 10,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const location = action.payload.location.pathname;\r\n        const sourceFile = getFileState(getState());\r\n\r\n        if (location === '/') {\r\n            // dispatch(push(`/playground/${DEFAULT_FILENAME}/`));\r\n            history.push(`/playground/${DEFAULT_FILENAME}/`);\r\n            return done();\r\n        }\r\n\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx, name } = match.params;\r\n\r\n            const supportedViews = ['playground', 'bytecode', 'program', 'ast'];\r\n            if (supportedViews.indexOf(view) !== -1) {\r\n                if (!fx) {\r\n                    // dispatch(push(`/${view}/${DEFAULT_FILENAME}/`));\r\n                    history.push(`/${view}/${DEFAULT_FILENAME}`);\r\n                    return done();\r\n                }\r\n\r\n                const fxRequest = `./assets/fx/tests/${fx}`;\r\n\r\n                if (sourceFile.uri !== fxRequest) {\r\n                    dispatch(sourceActions.openFile(fxRequest));\r\n                }\r\n            }\r\n\r\n            return done();\r\n        }\r\n\r\n        if (location !== LOCATION_NOT_FOUND) {\r\n            history.push(LOCATION_NOT_FOUND);\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Redirect to default source (@new) if requested file was not found.\r\n */\r\nconst sourceFileNotFoundLogic = createLogic<IStoreState>({\r\n    type: evt.SOURCE_FILE_LOADING_FAILED,\r\n    async process({ getState }, dispatch, done) {\r\n        const location = getState().router.location.pathname;\r\n        const match = matchPath<PATH_PARAMS_TYPE>(location, {\r\n            path: LOCATION_PATTERN,\r\n            exact: false\r\n        });\r\n\r\n        if (match) {\r\n            const { view, fx } = match.params;\r\n            if (fx !== DEFAULT_FILENAME) {\r\n                history.push(`/${view}/${DEFAULT_FILENAME}`);\r\n            }\r\n        }\r\n\r\n        return done();\r\n    }\r\n});\r\n\r\n\r\nexport default createLogicMiddleware([\r\n    fetchSourceFileLogic,\r\n    navigationLogic,\r\n    sourceFileNotFoundLogic,\r\n    ...parsing,\r\n    ...fxRuntime\r\n]);\r\n","/* (ignored) */","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_FLOAT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IFloatInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n}\r\n\r\nexport class FloatInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, scope, ...settings }: IFloatInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FloatExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_FLOAT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.value}${this.value % 1 === 0? '.': ''}`;\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { ITypedInstructionSettings, TypedInstruction } from \"@lib/fx/analisys/instructions/TypedInstruction\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprInstructionSettings extends ITypedInstructionSettings {\r\n    \r\n}\r\n\r\nexport class ExprInstruction extends TypedInstruction implements IExprInstruction {\r\n    protected _evalResult: any;\r\n\r\n    constructor({ ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Expr, ...settings });\r\n        this._evalResult = null;\r\n    }\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>super.type;\r\n    }\r\n\r\n    evaluate(): boolean {\r\n        console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    getEvalValue(): any {\r\n        return this._evalResult;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        // console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    isConstExpr(): boolean {\r\n        // todo: implement it properly\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IStructDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ICompileExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { ITechniqueInstructionSettings, TechniqueInstruction } from \"../TechniqueInstruction\";\r\n\r\n// prohibition of explicitly indicating the type of technique\r\nexport interface IPartFxInstructionSettings extends Omit<ITechniqueInstructionSettings<IPartFxPassInstruction>, \"techniqueType\"> {\r\n    spawnRoutine: ICompileExprInstruction;\r\n    initRoutine: ICompileExprInstruction;\r\n    updateRoutine: ICompileExprInstruction;\r\n    particle: ITypeInstruction;\r\n    capacity?: number;\r\n}\r\n\r\n// var s: IPartFxInstructionSettings;\r\n// s.te\r\n\r\nexport class PartFxInstruction extends TechniqueInstruction<IPartFxPassInstruction> implements IPartFxInstruction {\r\n    protected _spawnRoutine: ICompileExprInstruction;\r\n    protected _initRoutine: ICompileExprInstruction;\r\n    protected _updateRoutine: ICompileExprInstruction;\r\n    protected _particle: ITypeInstruction;\r\n    protected _material: ITypeInstruction;\r\n    protected _capacity: number;\r\n\r\n    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }: IPartFxInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxDecl, techniqueType: ETechniqueType.k_PartFx, ...settings });\r\n\r\n        this._spawnRoutine = spawnRoutine;\r\n        this._initRoutine = initRoutine;\r\n        this._updateRoutine = updateRoutine;\r\n        this._particle = particle;\r\n        this._capacity = capacity;\r\n    }\r\n\r\n    get spawnRoutine(): ICompileExprInstruction {\r\n        return this._spawnRoutine;\r\n    }\r\n\r\n    \r\n    get initRoutine(): ICompileExprInstruction {\r\n        return this._initRoutine;\r\n    }\r\n\r\n    \r\n    get updateRoutine(): ICompileExprInstruction {\r\n        return this._updateRoutine;\r\n    }\r\n\r\n    get particle(): ITypeInstruction {\r\n        return this._particle;\r\n    }\r\n\r\n    get capacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    isValid() {\r\n        const routineCheck = !!this.spawnRoutine && !!this.initRoutine && !!this.updateRoutine;\r\n        const particleCheck = !!this.particle;\r\n        const passCheck = this.passList && this.passList.filter((pass: IPartFxPassInstruction) => pass.isValid()).length > 0;\r\n\r\n        return routineCheck && particleCheck && passCheck;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionCallInstructionSettings extends IExprInstructionSettings {\r\n    decl: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n    callee?: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Respresnt func(arg1,..., argn)\r\n * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class FunctionCallInstruction extends ExprInstruction implements IFunctionCallInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // helpers\r\n    readonly decl: IFunctionDeclInstruction; // << move to resolveDecl() method.\r\n    \r\n    constructor({ decl, args, callee, ...settings }: IFunctionCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionCallExpr, ...settings });\r\n        \r\n        this.callee = callee;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n\r\n    toCode(): string {\r\n        const { callee, decl: { def }, args } = this;\r\n        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;\r\n    }\r\n}\r\n\r\n\r\n","/* (ignored) */","import { isString, isDef, isNull } from \"../common\";\r\n\r\nclass Pathinfo {\r\n    private _dirname: string = null;\r\n    private _extension: string = null;\r\n    private _filename: string = null;\r\n\r\n    get path(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    set path(path: string) {\r\n        this.set(path);\r\n    }\r\n\r\n    get dirname(): string {\r\n        return this._dirname;\r\n    }\r\n\r\n    set dirname(dirname: string) {\r\n        this._dirname = dirname;\r\n    }\r\n\r\n    get filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    set filename(filename: string) {\r\n        this._filename = filename;\r\n    }\r\n\r\n    get ext(): string {\r\n        return this._extension;\r\n    }\r\n\r\n    set ext(extension: string) {\r\n        this._extension = extension;\r\n    }\r\n\r\n    get basename(): string {\r\n        return (this._filename ? this._filename + (this._extension ? \".\" + this._extension : \"\") : \"\");\r\n    }\r\n\r\n    set basename(basename: string) {\r\n        var nPos: number = basename.lastIndexOf(\".\");\r\n\r\n        if (nPos < 0) {\r\n            this._filename = basename.substr(0);\r\n            this._extension = null;\r\n        }\r\n        else {\r\n            this._filename = basename.substr(0, nPos);\r\n            this._extension = basename.substr(nPos + 1);\r\n        }\r\n    }\r\n\r\n\r\n    constructor(path: Pathinfo);\r\n    constructor(path: string);\r\n    constructor(path?: any) {\r\n        if (isDef(path)) {\r\n            this.set(<string>path);\r\n        }\r\n    }\r\n\r\n\r\n    set(path: string): void;\r\n    set(path: Pathinfo): void;\r\n    set(path?: any) {\r\n        if (isString(path)) {\r\n            var pParts: string[] = path.replace('\\\\', '/').split('/');\r\n\r\n            this.basename = (pParts.pop());\r\n\r\n            this._dirname = pParts.join('/');\r\n        }\r\n        else if (path instanceof Pathinfo) {\r\n            this._dirname = path.dirname;\r\n            this._filename = path.filename;\r\n            this._extension = path.ext;\r\n        }\r\n        else if (isNull(path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            //critical_error\r\n            throw new Error(`Unexpected data type was used: ${path}`);\r\n        }\r\n    }\r\n\r\n    isAbsolute(): boolean { return this._dirname[0] === \"/\"; }\r\n\r\n\r\n    toString(): string {\r\n        return (this._dirname ? this._dirname + \"/\" : \"\") + (this.basename);\r\n    }\r\n}\r\n\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n        var last = parts[i];\r\n        if (last === '.') {\r\n            parts.splice(i, 1);\r\n        } else if (last === \"..\") {\r\n            parts.splice(i, 1);\r\n            up++;\r\n        } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n        }\r\n    }\r\n\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n        for (; up--;) {\r\n            parts.unshift(\"..\");\r\n        }\r\n    }\r\n\r\n    return parts;\r\n}\r\n\r\n\r\nexport function normalize(path: string): string {\r\n    var info: Pathinfo = parse(path);\r\n    var isAbsolute: boolean = info.isAbsolute();\r\n    var tail: string = info.dirname;\r\n    var trailingSlash: boolean = /[\\\\\\/]$/.test(tail);\r\n\r\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/).filter(function (p) {\r\n        return !!p;\r\n    }), !isAbsolute).join(\"/\");\r\n\r\n    if (tail && trailingSlash) {\r\n        tail += \"/\";\r\n    }\r\n\r\n    info.dirname = ((isAbsolute ? \"/\" : \"\") + tail);\r\n\r\n    return info.toString();\r\n}\r\n\r\nexport function parse(path: Pathinfo): Pathinfo;\r\nexport function parse(path: string): Pathinfo;\r\nexport function parse(path?): Pathinfo {\r\n    return new Pathinfo(path);\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_BOOL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IBoolInstructionSettings extends IInstructionSettings {\r\n    value: boolean;\r\n}\r\n\r\nexport class BoolInstruction extends ExprInstruction implements ILiteralInstruction<boolean> {\r\n    readonly value: boolean;\r\n\r\n    constructor({ value, scope, ...settings }: IBoolInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BoolExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    toCode(): string {\r\n        return this.value ? \"true\" : \"false\";\r\n    }\r\n\r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IIdExprInstruction, IIdInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdExprInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport class IdExprInstruction extends ExprInstruction implements IIdExprInstruction {\r\n    readonly id: IIdInstruction;\r\n    // helpers\r\n    readonly decl: IVariableDeclInstruction; // << move to resolveDecl() method.\r\n\r\n    constructor({ id, decl, ...settings }: IIdExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IdExpr, type: decl.type, ...settings });\r\n\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.type.isConst();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this.decl.id.toCode();\r\n    }\r\n}\r\n\r\n","/* tslint:disable:typedef */\r\n/* tslint:disable:forin */\r\n/* tslint:disable:no-for-in */\r\n/* tslint:disable:newline-per-chained-call */\r\n\r\n\r\nimport { ETechniqueType, IScope } from '@lib/idl/IInstruction';\r\nimport { IPartFxInstruction } from '@lib/idl/part/IPartFx';\r\nimport { mapActions, sourceCode as sourceActions } from '@sandbox/actions';\r\nimport { mapProps } from '@sandbox/reducers';\r\nimport { filterPartFx, getEmitterName, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport { IFileState } from '@sandbox/store/IStoreState';\r\nimport autobind from 'autobind-decorator';\r\nimport * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Button, List, Message } from 'semantic-ui-react';\r\n\r\nimport ThreeScene from './ThreeScene';\r\n\r\ninterface IPlaygroundProps extends IFileState {\r\n    actions: typeof sourceActions;\r\n}\r\n\r\n\r\n\r\n// TODO: remove it\r\nconst threeStylesHotfix: React.CSSProperties = {\r\n    height: 'calc(100vh - 275px - 1em)',\r\n    position: 'relative',\r\n    left: '0',\r\n    right: '0',\r\n    margin: '1em -20px -20px -20px'\r\n};\r\n\r\n\r\nclass Playground extends React.Component<IPlaygroundProps> {\r\n    $emitterName: string = null;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    // static getDerivedStateFromProps(props: IPlaygroundProps, state: IPlaygroundState) {\r\n    //     return null;\r\n    // }\r\n\r\n    @autobind\r\n    handlePlayClick() {\r\n        const props = this.props;\r\n        if (props.emitter) {\r\n            if (props.emitter.isStopped()) {\r\n                props.emitter.start();\r\n                this.forceUpdate();\r\n            }\r\n        }\r\n    }\r\n\r\n    @autobind\r\n    handlePauseClick() {\r\n        const props = this.props;\r\n        if (props.emitter) {\r\n            if (!props.emitter.isStopped()) {\r\n                props.emitter.stop();\r\n                this.forceUpdate();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @autobind\r\n    handleResetClick() {\r\n        const props = this.props;\r\n        if (props.emitter) {\r\n            props.emitter.reset();\r\n        }\r\n    }\r\n\r\n\r\n    pickEffect(active) {\r\n        this.props.actions.selectEffect(active);\r\n    }\r\n\r\n\r\n    shouldComponentUpdate(nextProps: IPlaygroundProps) {\r\n        return nextProps.emitter !== this.props.emitter ||\r\n            (this.props.emitter && this.$emitterName !== this.props.emitter.name);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        if (this.props.emitter) {\r\n            this.$emitterName = this.props.emitter.name;\r\n        } else {\r\n            this.$emitterName = null;\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        // console.log('Playground:render()');\r\n        const props = this.props;\r\n        const emitter = props.emitter;\r\n        const scope = getScope(props);\r\n\r\n        const list: IPartFxInstruction[] = filterPartFx(scope);\r\n        const active = getEmitterName(props);\r\n\r\n        return (\r\n            <div>\r\n                { !list.length &&\r\n                    <Message info textAlign='center'>\r\n                        <Message.Content>\r\n                            No effects found :/\r\n                    </Message.Content>\r\n                    </Message>\r\n                }\r\n                { emitter &&\r\n                    <div>\r\n                        <List bulleted horizontal>\r\n                            { list.map(fx => (\r\n                                <List.Item\r\n                                    disabled={ !fx.isValid() }\r\n                                    as={ (fx.name === active ? 'b' : 'a') }\r\n                                    onClick={ () => this.pickEffect(fx.name) }\r\n                                >\r\n                                    { fx.name }\r\n                                </List.Item>\r\n                            )) }\r\n                        </List>\r\n                        <div>\r\n                            <Button.Group compact >\r\n                                <Button\r\n                                    icon='playback pause'\r\n                                    color={ (emitter.isStopped() ? 'black' : null) }\r\n                                    disabled={ emitter.isStopped() }\r\n                                    onClick={ this.handlePauseClick }\r\n                                />\r\n                                <Button\r\n                                    icon='sync'\r\n                                    onClick={ this.handleResetClick }\r\n                                />\r\n                                <Button\r\n                                    icon='playback play'\r\n                                    color={ (!emitter.isStopped() ? 'black' : null) }\r\n                                    disabled={ !emitter.isStopped() }\r\n                                    onClick={ this.handlePlayClick }\r\n                                />\r\n                            </Button.Group>\r\n                            <ThreeScene\r\n                                style={ threeStylesHotfix }\r\n                                emitter={ emitter }\r\n                            />\r\n                        </div>\r\n                    </div>\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default connect<{}, {}, IPlaygroundProps>(mapProps(getFileState), mapActions(sourceActions))(Playground) as any;\r\n","\r\nexport enum ERenderStates {\r\n\tBLENDENABLE,\r\n\tCULLFACEENABLE,\r\n\tZENABLE,\r\n\tZWRITEENABLE,\r\n\tDITHERENABLE,\r\n\tSCISSORTESTENABLE,\r\n\tSTENCILTESTENABLE,\r\n\tPOLYGONOFFSETFILLENABLE,\r\n\r\n\tCULLFACE,\r\n\tFRONTFACE,\r\n\r\n\tSRCBLENDCOLOR,\r\n\tDESTBLENDCOLOR,\r\n\r\n\tSRCBLENDALPHA,\r\n\tDESTBLENDALPHA,\r\n\r\n\tBLENDEQUATIONCOLOR,\r\n\tBLENDEQUATIONALPHA,\r\n\r\n\tZFUNC,\r\n\r\n\tALPHABLENDENABLE,\r\n\tALPHATESTENABLE,\r\n\r\n\tSRCBLEND, // Fake, set SRCBLENDCOLOR, SRCBLENDALPHA. Not use in setRenderState\r\n\tDESTBLEND, // Fake, set DESTBLENDCOLOR, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDFUNC, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\tBLENDFUNCSEPARATE, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDEQUATION, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\tBLENDEQUATIONSEPARATE, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\r\n\r\n\t// HACK:\r\n\tPRIMITIVETOPOLOGY,\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction } from \"./instruction\";\r\nimport { variable } from \"./variable\";\r\n\r\nexport namespace type {\r\n    // todo: rename it\r\n    /** @deprecated */\r\n    export function isInheritedFromVariableDecl(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n        const parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return true;\r\n        }\r\n        else if (parentType === EInstructionTypes.k_VariableType) {\r\n            return isInheritedFromVariableDecl(<IVariableTypeInstruction>type.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function isTypeOfField(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n\r\n        if (type.parent.instructionType === EInstructionTypes.k_VariableDecl) {\r\n            let pParentDecl: IVariableDeclInstruction = <IVariableDeclInstruction>type.parent;\r\n            return pParentDecl.isField();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentContainer(type: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {\r\n            return null;\r\n        }\r\n\r\n        let containerType: IVariableTypeInstruction = <IVariableTypeInstruction>findParentVariableDecl(type).parent;\r\n        if (!isInheritedFromVariableDecl(containerType)) {\r\n            return null;\r\n        }\r\n\r\n        return findParentVariableDecl(containerType);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDecl(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType: EInstructionTypes = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return <IVariableDeclInstruction>type.parent;\r\n        }\r\n\r\n        return findParentVariableDecl(<IVariableTypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDeclName(type: ITypeInstruction): string {\r\n        let varDecl = findParentVariableDecl(type)\r\n        return isNull(varDecl) ? null : varDecl.name;\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDecl(type: ITypeInstruction): ITypeDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_TypeDecl) {\r\n            return <ITypeDeclInstruction>type.parent;\r\n        }\r\n        return finParentTypeDecl(<ITypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDeclName(type: IVariableTypeInstruction): string {\r\n        let typeDecl = finParentTypeDecl(type);\r\n        return isNull(typeDecl) ? null : typeDecl.name;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function resolveVariableDeclFullName(type: ITypeInstruction): string {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            console.error(\"Not from variable decl\");\r\n            return null;\r\n        }\r\n\r\n        return variable.fullName(findParentVariableDecl(type));\r\n    }\r\n\r\n\r\n    // todo: add comment\r\n    // todo: review this code\r\n    /** @deprecated */\r\n    export function findMainVariable(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        if (isTypeOfField(type)) {\r\n            return findMainVariable(<IVariableTypeInstruction>type.parent.parent);\r\n        }\r\n        return findParentVariableDecl(type);\r\n    }\r\n\r\n    //\r\n    // Signatures\r\n    //\r\n\r\n    function signatureVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let prefix = '';\r\n        if (strong) {\r\n            if (vtype.usages.length > 0) {\r\n                prefix = `${vtype.usages.join('_')}_`;\r\n            }\r\n        }\r\n        let postfix = '';\r\n        if (vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${prefix}${signature(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n\r\n    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)\r\n\r\n\r\n    export function signature(type: ITypeInstruction, strong: boolean = false): string {\r\n        if (isNull(type)) {\r\n            assert(!strong);\r\n            return '*';\r\n        }\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return signatureVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return `${type.name}${type.instructionID}`;\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? signature(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    //\r\n    // hash\r\n    //\r\n\r\n    function hashVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let postfix = '';\r\n        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${hash(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n    function hashComplex(ctype: ITypeInstruction, strong: boolean): string {\r\n        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;\r\n    }\r\n\r\n    export function hash(type: ITypeInstruction, strong: boolean = false): string {\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return hashVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return hashComplex(type, strong);\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? hash(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    export function compareRelaxed(a: ITypeInstruction, b: ITypeInstruction, strong: boolean = false): boolean {\r\n        return hash(a, strong) === hash(b, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function compare(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        if (isNull(a) || isNull(b)) {\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp && b instanceof RegExp) {\r\n            assert(false);\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp) {\r\n            let ra = <RegExp>a;\r\n            let sb = signature(<ITypeInstruction>b, strong);\r\n            return !!sb.match(ra);\r\n        }\r\n\r\n        if (b instanceof RegExp) {\r\n            let sa = signature(<ITypeInstruction>a, strong);\r\n            let rb = <RegExp>b;\r\n            return !!sa.match(rb);\r\n        }\r\n\r\n        let ta = <ITypeInstruction>a;\r\n        let tb = <ITypeInstruction>b;\r\n        if (ta.isArray() && tb.isArray()) {\r\n            if (ta.length === instruction.UNDEFINE_LENGTH ||\r\n                tb.length === instruction.UNDEFINE_LENGTH) {\r\n                return false;\r\n            }\r\n        }\r\n        return signature(ta, strong) === signature(tb, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function equals(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        return compare(a, b, strong);\r\n    }\r\n}\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\n\r\nexport type BreakOperator = \"break\" | \"discard\";\r\n\r\nexport interface IBreakStmtInstructionSettings extends IInstructionSettings {\r\n    operator?: BreakOperator;\r\n}\r\n\r\n/**\r\n * Reprsernt continue; break; discard;\r\n * (continue || break || discard) \r\n */\r\nexport class BreakStmtInstruction extends StmtInstruction {\r\n    protected _operator: BreakOperator;\r\n\r\n    constructor({ operator = \"break\", ...settings }: IBreakStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BreakStmt, ...settings });\r\n        this._operator = operator;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    // todo: validate operator's name\r\n    toCode(): string {\r\n        console.assert(this.operator == \"break\");\r\n        return this.operator + \";\";\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { IDMap, IMap } from \"@lib/idl/IMap\";\r\nimport { ENodeCreateMode as ENodeCreationMode, EOperationType, EParserFlags, EParserType, ExpectedSymbols, IAdditionalFuncInfo, IOperation, IOperationMap, IParser, IParserParams, IPosition, IProductions, IRange, IRule, IRuleFunctionDMap, IRuleMap, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { Item } from \"./Item\";\r\nimport { LexerEngine } from \"./Lexer\";\r\nimport { State } from \"./State\";\r\nimport { END_POSITION, END_SYMBOL, FLAG_RULE_CREATE_NODE, FLAG_RULE_FUNCTION, FLAG_RULE_EXPOSE_NODE, INLINE_COMMENT_SYMBOL, LEXER_RULES, START_SYMBOL, T_EMPTY, UNUSED_SYMBOL, FLAG_RULE_SKIP_NODE } from \"./symbols\";\r\n\r\nexport enum EParserErrors {\r\n    GrammarAddOperation = 2001,\r\n    GrammarAddStateLink,\r\n    GrammarUnexpectedSymbol,\r\n    GrammarInvalidAdditionalFuncName,\r\n    GrammarInvalidKeyword\r\n};\r\n\r\n\r\ntype Terminals = Set<string>;\r\n\r\n\r\nexport class GrammarDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Grammar diagnostics\", 'G');\r\n    }\r\n\r\n\r\n    protected resolveFilename(code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(code: number, desc: IMap<any>): IRange {\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(code: number, desc: IMap<any>): IPosition {\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParserErrors.GrammarAddOperation]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old operation: {oldOperation}\\n\" +\r\n                \"New operation: {newOperation}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\" +\r\n                `\\n\\n{stateDesc}`,\r\n            [EParserErrors.GrammarAddStateLink]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old next state: {oldNextStateIndex}\\n\" +\r\n                \"New next state: {newNextStateIndex}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\",\r\n            [EParserErrors.GrammarUnexpectedSymbol]: \"Grammar error. Can`t generate rules from grammar\\n\" +\r\n                \"Unexpected symbol: {unexpectedSymbol}\\n\" +\r\n                \"Expected: {expectedSymbol}\",\r\n            [EParserErrors.GrammarInvalidAdditionalFuncName]: \"Grammar error. Empty additional function name.\",\r\n            [EParserErrors.GrammarInvalidKeyword]: \"Grammar error. Bad keyword: {badKeyword}\\n\" +\r\n                \"All keyword must be define in lexer rule block.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class AbstractParser implements IParser {\r\n    //Process params\r\n\r\n    // TODO: make readonly\r\n    lexerEngine: LexerEngine;\r\n\r\n    //\r\n    // Grammar based Info\r\n    //\r\n\r\n    private _syntaxTable: ISyntaxTable;\r\n\r\n\r\n    /**\r\n     * General structure:\r\n     *  { [symbol name]: { [rule index]: IRule } }\r\n     */\r\n    private _productions: IProductions;\r\n    private _states: State[];\r\n\r\n    /**\r\n * Auxiliary map for all symbols from grammar: symbolName => symbolName.\r\n * For ex.: T_PUNCTUATOR_61 => '='\r\n */\r\n    private _grammarSymbols: Map<string, string>;\r\n\r\n    // functions described in grammar's flags\r\n    private _additionalFuncInfoList: IAdditionalFuncInfo[];\r\n    private _adidtionalFunctByStateDMap: IRuleFunctionDMap;\r\n\r\n    // Additioanal info\r\n\r\n    // flags for rules (extracted from grammar's flags)\r\n    private _ruleCreationModeMap: IMap<number>;\r\n\r\n    // Temp\r\n\r\n    // aux. cache for first terminals\r\n    private _firstTerminalsCache: IMap<Terminals>;\r\n    // private _followTerminalsCache: IDMap<boolean>;\r\n\r\n\r\n    //\r\n    // LALR specific\r\n    //\r\n\r\n    /**\r\n     * Auxiliary map: [item index] => { [item index]: true }\r\n     * Expectation correspondence map.\r\n     */\r\n    // NOTE: default JS object significantly faster than Map<number, Set<number>>\r\n    //       for this case :/\r\n    private _expectedExtensionDMap: IDMap<boolean>;\r\n    private _baseItems: Item[];\r\n    private _closureForItemsCache: IMap<State>;\r\n\r\n    // TODO: use dedicated type for parser engine\r\n    private _diag: GrammarDiagnostics;\r\n\r\n    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR\r\n    constructor({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this._syntaxTable = null;\r\n\r\n        this._productions = null;\r\n        this._baseItems = null;\r\n        this._states = null;\r\n\r\n        this._additionalFuncInfoList = null;\r\n        this._adidtionalFunctByStateDMap = null;\r\n\r\n        this._ruleCreationModeMap = null;\r\n\r\n        this._firstTerminalsCache = null;\r\n        // this._followTerminalsCache = null;\r\n        this._closureForItemsCache = null;\r\n\r\n        this._expectedExtensionDMap = null;\r\n        this._diag = new GrammarDiagnostics;\r\n\r\n        this.init({ grammar, flags, type });\r\n    }\r\n\r\n    get syntaxTable(): ISyntaxTable {\r\n        return this._syntaxTable;\r\n    }\r\n\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string {\r\n        const funcDMap = this._adidtionalFunctByStateDMap;\r\n\r\n        if (!isNull(funcDMap) &&\r\n            isDef(funcDMap[stateIndex]) &&\r\n            isDef(funcDMap[stateIndex][grammarSymbol])) {\r\n            return funcDMap[stateIndex][grammarSymbol];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreationMode {\r\n        return this._ruleCreationModeMap[nonTerminal];\r\n    }\r\n\r\n\r\n    getGrammarSymbols(): Map<string, string> {\r\n        return this._grammarSymbols;\r\n    }\r\n\r\n    protected init({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this.lexerEngine = new LexerEngine();\r\n\r\n        this.generateRules(grammar, flags);\r\n        this.buildSyntaxTable(type);\r\n        this.generateFunctionByStateMap();\r\n\r\n        if (!bf.testAll(flags, EParserFlags.k_Debug)) {\r\n            this.clearMem();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    printStates(isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.warn(\"It`s impossible to print states. You must init parser in debug-mode\");\r\n            return;\r\n        }\r\n        const mesg = \"\\n\" + this.statesToString(isBaseOnly);\r\n        console.log(mesg);\r\n    }\r\n\r\n\r\n    printState(stateIndex: number, isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.log(\"It`s impossible to print states. You must init parser in debug-mode.\");\r\n            return;\r\n        }\r\n\r\n        var state = this._states[stateIndex];\r\n        if (!isDef(state)) {\r\n            console.log(\"Can not print stete with index: \" + stateIndex.toString());\r\n            return;\r\n        }\r\n\r\n        console.log(`\\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);\r\n    }\r\n\r\n\r\n    protected critical(code, desc) {\r\n        this._diag.critical(code, desc);\r\n    }\r\n\r\n    private grammarError(code: number, desc) {\r\n        let file = \"grammar\";\r\n\r\n        switch (code) {\r\n            case EParserErrors.GrammarAddOperation:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;\r\n                    this.critical(code, {\r\n                        file, line: 0, stateIndex, grammarSymbol,\r\n                        oldOperation: AbstractParser.operationToString(oldOperation),\r\n                        newOperation: AbstractParser.operationToString(newOperation),\r\n                        stateDesc: this._states[stateIndex].toString()\r\n                    });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarAddStateLink:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;\r\n                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarUnexpectedSymbol:\r\n                {\r\n                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;\r\n                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidAdditionalFuncName:\r\n                {\r\n                    const { grammarLine } = desc;\r\n                    this.critical(code, { file, line: grammarLine });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidKeyword:\r\n                {\r\n                    const { grammarLine, badKeyword } = desc;\r\n                    this.critical(code, { file, line: grammarLine, badKeyword })\r\n                }\r\n                break;\r\n            default:\r\n                throw \"invalid case!!!!\";\r\n        }\r\n    }\r\n\r\n\r\n    private clearMem(): void {\r\n        delete this._states;\r\n\r\n        delete this._productions;\r\n        delete this._baseItems;\r\n        // delete this._followTerminalsCache;\r\n        delete this._firstTerminalsCache;\r\n        delete this._closureForItemsCache;\r\n        delete this._expectedExtensionDMap;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for the state's dublicate.\r\n     */\r\n    private hasState(state: State, type: EParserType): State {\r\n        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;\r\n    }\r\n\r\n\r\n    private nonTerminals(): string[] {\r\n        return Object.keys(this._productions);\r\n    }\r\n\r\n    private rules(nonTerminal: string): IRule[] {\r\n        const prods = this._productions[nonTerminal];\r\n        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;\r\n    }\r\n\r\n    private ruleCreationMode(symbol: string) {\r\n        return this._ruleCreationModeMap[symbol];\r\n    }\r\n\r\n    /**\r\n     * terminals & non-terminals;\r\n     */\r\n    private symbols(): string[] {\r\n        return [...this._grammarSymbols.keys()];\r\n    }\r\n\r\n    private isTerminal(symbol: string): boolean {\r\n        return !(this._productions[symbol]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'stateList' and set item's index in it.\r\n     */\r\n    private pushState(state: State): void {\r\n        state.index = this._states.length;\r\n        this._states.push(state);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'baseItemList' and set item's index in it.\r\n     */\r\n    private pushBaseItem(item: Item): void {\r\n        item.index = this._baseItems.length;\r\n        this._baseItems.push(item);\r\n    }\r\n\r\n\r\n    private tryAddState(state: State, type: EParserType): State {\r\n        let res = this.hasState(state, type);\r\n\r\n        if (isNull(res)) {\r\n            if (type === EParserType.k_LR0) {\r\n                state.eachItem(item => this.pushBaseItem(item));\r\n            }\r\n\r\n            this.pushState(state);\r\n            this.closure(state, type);\r\n\r\n            return state;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private hasEmptyRule(symbol: string): boolean {\r\n        if (this.isTerminal(symbol)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this.rules(symbol).find(rule => rule.right.length === 0);\r\n    }\r\n\r\n\r\n    private pushInSyntaxTable(syntaxTable: ISyntaxTable, stateIndex: number, symbol: string, operation: IOperation): void {\r\n        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};\r\n\r\n        if (isDef(syntaxTable[stateIndex][symbol])) {\r\n            this.grammarError(EParserErrors.GrammarAddOperation, {\r\n                stateIndex: stateIndex,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol),\r\n                oldOperation: this._syntaxTable[stateIndex][symbol],\r\n                newOperation: operation\r\n            });\r\n        }\r\n\r\n        syntaxTable[stateIndex][symbol] = operation;\r\n    }\r\n\r\n\r\n    private addStateLink(state: State, nextState: State, symbol: string): void {\r\n        let isAddState = state.addNextState(symbol, nextState);\r\n        if (!isAddState) {\r\n            this.grammarError(EParserErrors.GrammarAddStateLink, {\r\n                stateIndex: state.index,\r\n                oldNextStateIndex: state.nextStates[symbol] || null,\r\n                newNextStateIndex: nextState.index,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol)\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    private firstTerminals(symbol: string): Terminals {\r\n        if (this.isTerminal(symbol)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(this._firstTerminalsCache[symbol])) {\r\n            return this._firstTerminalsCache[symbol];\r\n        }\r\n\r\n        const rules = this.rules(symbol);\r\n        const res: Terminals = this._firstTerminalsCache[symbol] = new Set<string>();\r\n\r\n        if (this.hasEmptyRule(symbol)) {\r\n            res.add(T_EMPTY);\r\n        }\r\n\r\n        if (isNull(rules)) {\r\n            return res;\r\n        }\r\n\r\n        for (let i = 0; i < rules.length; ++i) {\r\n            const rule = rules[i];\r\n            const right = rule.right;\r\n\r\n            let isFinish = false;\r\n\r\n            for (let j = 0; j < right.length; j++) {\r\n                if (right[j] === symbol) {\r\n                    if (res.has(T_EMPTY)) {\r\n                        continue;\r\n                    }\r\n\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n\r\n                const terminals = this.firstTerminals(right[j]);\r\n\r\n                if (isNull(terminals)) {\r\n                    res.add(right[j]);\r\n                } else {\r\n                    for (const terminal of terminals) {\r\n                        res.add(terminal);\r\n                    }\r\n                }\r\n\r\n                if (!this.hasEmptyRule(right[j])) {\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!isFinish) {\r\n                res.add(T_EMPTY);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // private followTerminal(symbolVal: string): IMap<boolean> {\r\n    //     if (isDef(this._followTerminalsCache[symbolVal])) {\r\n    //         return this._followTerminalsCache[symbolVal];\r\n    //     }\r\n\r\n    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;\r\n    //     var pRulesDMap: IRuleDMap = this._rulesDMap;\r\n    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];\r\n\r\n    //     var rule: IRule;\r\n    //     var pTempRes: IMap<boolean>;\r\n    //     var pTempKeys: string[];\r\n    //     var res: IMap<boolean>;\r\n\r\n    //     var right: string[];\r\n    //     var isFinish: boolean;\r\n\r\n    //     var sFirstKey: string;\r\n    //     var sSecondKey: string;\r\n\r\n    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};\r\n\r\n    //     if (isNull(pRulesDMap)) {\r\n    //         return res;\r\n    //     }\r\n\r\n    //     rulesDMapKeys = Object.keys(pRulesDMap);\r\n    //     for (i = 0; i < rulesDMapKeys.length; i++) {\r\n    //         sFirstKey = rulesDMapKeys[i];\r\n\r\n    //         if (isNull(pRulesDMap[sFirstKey])) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);\r\n\r\n    //         for (j = 0; j < pRulesMapKeys.length; j++) {\r\n    //             rule = pRulesDMap[sFirstKey][sSecondKey];\r\n    //             right = rule.right;\r\n\r\n    //             for (k = 0; k < right.length; k++) {\r\n    //                 if (right[k] === symbolVal) {\r\n    //                     if (k === right.length - 1) {\r\n    //                         pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                         pTempKeys = Object.keys(pTempRes);\r\n    //                         for (m = 0; m < pTempKeys.length; i++) {\r\n    //                             res[pTempKeys[m]] = true;\r\n    //                         }\r\n    //                     }\r\n    //                     else {\r\n    //                         isFinish = false;\r\n\r\n    //                         for (l = k + 1; l < right.length; l++) {\r\n    //                             pTempRes = this.firstTerminal(right[l]);\r\n\r\n    //                             if (isNull(pTempRes)) {\r\n    //                                 res[right[l]] = true;\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                             else {\r\n    //                                 pTempKeys = Object.keys(pTempRes);\r\n    //                                 for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                     res[pTempKeys[m]] = true;\r\n    //                                 }\r\n    //                             }\r\n\r\n    //                             if (!pTempRes[T_EMPTY]) {\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                         }\r\n\r\n    //                         if (!isFinish) {\r\n    //                             pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                             pTempKeys = Object.keys(pTempRes);\r\n    //                             for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                 res[pTempKeys[m]] = true;\r\n    //                             }\r\n    //                         }\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     return res;\r\n    // }\r\n\r\n    private firstTerminalsForSet(symbolList: string[], expectedSymbols: ExpectedSymbols): Terminals {\r\n        const res = new Set<string>();\r\n\r\n        for (let i = 0; i < symbolList.length; i++) {\r\n            const terminals = this.firstTerminals(symbolList[i]);\r\n\r\n            if (isNull(terminals)) {\r\n                res.add(symbolList[i]);\r\n                return res;\r\n            }\r\n\r\n            let isEmpty = false;\r\n            for (const symbol of terminals) {\r\n                if (symbol === T_EMPTY) {\r\n                    isEmpty = true;\r\n                    continue;\r\n                }\r\n                res.add(symbol);\r\n            }\r\n\r\n            if (!isEmpty) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        if (!isNull(expectedSymbols)) {\r\n            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private generateRules(grammarSource: string, flags: EParserFlags): void {\r\n        let allRuleList: string[] = grammarSource.split(/\\r?\\n/);\r\n        let tempRule: string[];\r\n        let rule: IRule;\r\n        let isLexerBlock = false;\r\n\r\n        this._productions = <IProductions>{};\r\n        this._additionalFuncInfoList = <IAdditionalFuncInfo[]>[];\r\n        this._ruleCreationModeMap = <IMap<number>>{};\r\n        this._grammarSymbols = new Map([['END_SYMBOL', END_SYMBOL]]);\r\n\r\n        let i = 0, j = 0;\r\n\r\n        // append all nodes ignoring any flags\r\n        const forceAppendAllMode = bf.testAll(flags, EParserFlags.k_ForceAppendAll);\r\n        // force unwind node if it is marked as '--expose'\r\n        const allowExposeMode = bf.testAll(flags, EParserFlags.k_AllowExposeMode);\r\n        // force add node if it is marked as '--add'\r\n        const allowAddMode = bf.testAll(flags, EParserFlags.k_AllowAddMode);\r\n        // remove node from parsing tree if it is marked as '--skip'\r\n        const allowSkipMode = bf.testAll(flags, EParserFlags.k_AllowSkipMode);\r\n\r\n        let symbolsWithNodeMap: IMap<number> = this._ruleCreationModeMap;\r\n\r\n        let name: string;\r\n\r\n        let nRules = 0;\r\n\r\n        for (i = 0; i < allRuleList.length; i++) {\r\n            if (allRuleList[i] === \"\" || allRuleList[i] === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // split rule like 'S : Program'\r\n            tempRule = allRuleList[i].trim().split(/\\s* \\s*/);\r\n\r\n            // ignore rules starting with '#'\r\n            if (tempRule[0][0] == INLINE_COMMENT_SYMBOL) {\r\n                continue;\r\n            }\r\n\r\n            if (isLexerBlock) {\r\n                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === \"\")) &&\r\n                    ((tempRule[2][0] === \"\\\"\" || tempRule[2][0] === \"'\") && tempRule[2].length > 3)) {\r\n\r\n                    //TERMINALS\r\n                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],\r\n                            expectedSymbol: tempRule[2][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);\r\n\r\n                    var ch: string = tempRule[2][0];\r\n\r\n\r\n                    if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);\r\n                    }\r\n                    else {\r\n                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);\r\n                    }\r\n\r\n                    this._grammarSymbols.set(name, tempRule[2]);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // looking for '--LEXER--' keyword\r\n            if (tempRule[0] === LEXER_RULES) {\r\n                isLexerBlock = true;\r\n                continue;\r\n            }\r\n\r\n            //NON TERMNINAL RULES\r\n            if (!isDef(this._productions[tempRule[0]])) {\r\n                this._productions[tempRule[0]] = <IRuleMap>{};\r\n            }\r\n\r\n            rule = {\r\n                left: tempRule[0],\r\n                right: <string[]>[],\r\n                index: 0\r\n            };\r\n\r\n            this._grammarSymbols.set(tempRule[0], tempRule[0]);\r\n\r\n            if (forceAppendAllMode) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowExposeMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowAddMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n            } else if (allowSkipMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n            }\r\n\r\n            for (j = 2; j < tempRule.length; j++) {\r\n                if (tempRule[j] === \"\") {\r\n                    continue;\r\n                }\r\n                // handle flag '--add'\r\n                if (tempRule[j] === FLAG_RULE_CREATE_NODE) {\r\n                    if (allowAddMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Necessary;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (tempRule[j] === FLAG_RULE_SKIP_NODE) {\r\n                    if (allowSkipMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n                    }\r\n                    continue;\r\n                }\r\n                // handle flag '--expose'\r\n                if (tempRule[j] === FLAG_RULE_EXPOSE_NODE) {\r\n                    if (allowExposeMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n                    }\r\n                    continue;\r\n                }\r\n                // looking for additional user functions like '--F includeCode'\r\n                if (tempRule[j] === FLAG_RULE_FUNCTION) {\r\n                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });\r\n                    }\r\n\r\n                    const funcInfo = <IAdditionalFuncInfo>{\r\n                        name: tempRule[j + 1],\r\n                        position: rule.right.length,\r\n                        rule: rule\r\n                    };\r\n                    this._additionalFuncInfoList.push(funcInfo);\r\n                    j++;\r\n                    continue;\r\n                }\r\n                // handle string literlas\r\n                if (tempRule[j][0] === \"'\" || tempRule[j][0] === \"\\\"\") {\r\n                    if (tempRule[j].length !== 3) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {\r\n                            badKeyword: tempRule[j],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n                    if (tempRule[j][0] !== tempRule[j][2]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[j][2],\r\n                            expectedSymbol: tempRule[j][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);\r\n                    rule.right.push(name);\r\n                    this._grammarSymbols.set(name, tempRule[j][1]);\r\n                }\r\n                else {\r\n                    rule.right.push(tempRule[j]);\r\n                    this._grammarSymbols.set(tempRule[j], tempRule[j]);\r\n                }\r\n            }\r\n\r\n            rule.index = nRules;\r\n            this._productions[tempRule[0]][rule.index] = rule;\r\n            nRules++;\r\n\r\n            // TODO: emit diagnostics error instead.\r\n            assert(nRules != 1 || isDef(this._productions[START_SYMBOL][0]));\r\n        }\r\n    }\r\n\r\n\r\n    private generateFunctionByStateMap(): void {\r\n        const stateList = this._states;\r\n        const funcInfoList = this._additionalFuncInfoList;\r\n        const funcByStateDMap = this._adidtionalFunctByStateDMap = <IRuleFunctionDMap>{};\r\n\r\n        for (let i = 0; i < funcInfoList.length; i++) {\r\n            const funcInfo = funcInfoList[i];\r\n            const rule = funcInfo.rule;\r\n            const pos = funcInfo.position;\r\n            const grammarSymbol = rule.right[pos - 1];\r\n\r\n            for (let j = 0; j < stateList.length; j++) {\r\n                if (stateList[j].hasRule(rule, pos)) {\r\n                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};\r\n                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateFirstState_LR0(): void {\r\n        const state = new State();\r\n        // START_SYMBOL should be always defined at the beginning of grammar\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n        const item = new Item(firstRule, 0);\r\n\r\n        this.pushBaseItem(item);\r\n        state.push(item);\r\n\r\n        this.closure_LR0(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private generateFirstState_LR(): void {\r\n        const state = new State();\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n\r\n        state.push(new Item(firstRule, 0, [END_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private closure(state: State, type: EParserType) {\r\n        if (type === EParserType.k_LR0) {\r\n            this.closure_LR0(state);\r\n        } else {\r\n            this.closure_LR(state);\r\n        }\r\n    }\r\n\r\n\r\n    private closure_LR0(state: State) {\r\n        // NOTE: loop grows implicitly inside state.tryPush() function.\r\n        //       do not change this loop.\r\n        state.eachItem(item => {\r\n            const symbol = item.symbolName();\r\n            if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private closure_LR(state: State) {\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            state.eachItem(item => {\r\n                const symbol = item.symbolName();\r\n                if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                    const nextSymbols = item.rule.right.slice(item.pos + 1);\r\n                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);\r\n\r\n                    this.rules(symbol).forEach(rule => {\r\n                        expectedTerminals.forEach(expectedTerminal => {\r\n                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private static nextState_LR0(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                nextState.push(new Item(item.rule, item.pos + 1));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private static nextState_LR(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                const expectedSymbols = Array.from(item.expectedSymbols);\r\n                nextState.push(new Item(item.rule, item.pos + 1, expectedSymbols));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private deleteNotBaseItems(): void {\r\n        this._states.forEach(state => state.deleteNotBase());\r\n    }\r\n\r\n\r\n    private closureForItem({ rule, pos }: Item): State {\r\n        const indexVal = rule.index + \"_\" + pos;\r\n\r\n        let state = this._closureForItemsCache[indexVal];\r\n        if (isDef(state)) {\r\n            return state;\r\n        }\r\n\r\n        state = new State();\r\n        state.push(new Item(rule, pos, [UNUSED_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this._closureForItemsCache[indexVal] = state;\r\n\r\n        return state;\r\n    }\r\n\r\n\r\n    private addLinkExpected(item: Item, itemX: Item): void {\r\n        let table = this._expectedExtensionDMap;\r\n        let index = item.index;\r\n\r\n        table[index] = table[index] || {};\r\n        table[index][itemX.index] = true;\r\n    }\r\n\r\n\r\n    private determineExpected(testState: State, symbol: string): void {\r\n        const stateNext = testState.nextStates[symbol] || null;\r\n\r\n        if (isNull(stateNext)) {\r\n            return;\r\n        }\r\n\r\n        // at this moment all items already 'base' because of\r\n        // deleteNotBase() call before.\r\n        testState.eachBaseItem(baseItem => {\r\n            const state = this.closureForItem(baseItem);\r\n            stateNext.eachBaseItem(baseItemNext => {\r\n                const item = state.hasChildItem(baseItemNext);\r\n                if (item) {\r\n                    item.expectedSymbols.forEach(symbol => {\r\n                        if (symbol === UNUSED_SYMBOL) {\r\n                            this.addLinkExpected(baseItem, baseItemNext);\r\n                        } else {\r\n                            baseItemNext.addExpected(symbol);\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    private generateLinksExpected(): void {\r\n        const states = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        states.forEach(state =>\r\n            symbols.forEach(symbol =>\r\n                this.determineExpected(state, symbol)));\r\n    }\r\n\r\n\r\n    private expandExpected(): void {\r\n        const baseItems = this._baseItems;\r\n        const itemExpected = baseItems.map(item => true);\r\n        const table = this._expectedExtensionDMap;\r\n\r\n        baseItems[0].addExpected(END_SYMBOL);\r\n        itemExpected[0] = (true);\r\n\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            baseItems.forEach((baseItem) => {\r\n                if (itemExpected[baseItem.index] && isDefAndNotNull(table[baseItem.index])) {\r\n                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));\r\n\r\n                    baseItem.expectedSymbols.forEach(expectedSymbol => {\r\n                        indexesOfExpectedItems.forEach(expectedIndex => {\r\n                            const baseItemExpected = baseItems[expectedIndex];\r\n                            if (baseItemExpected.addExpected(expectedSymbol)) {\r\n                                itemExpected[expectedIndex] = true;\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                itemExpected[baseItem.index] = false;\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private generateStates(type: EParserType): void {\r\n        if (type === EParserType.k_LR0) {\r\n            this.generateStates_LR0();\r\n        }\r\n        else if (type === EParserType.k_LR1) {\r\n            this.generateStates_LR();\r\n        }\r\n        else if (type === EParserType.k_LALR) {\r\n            this.generateStates_LALR();\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR0(): void {\r\n        this.generateFirstState_LR0();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                const symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR0(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR0);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR(): void {\r\n        this._firstTerminalsCache = {};\r\n        this.generateFirstState_LR();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                let symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR1);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private generateStates_LALR(): void {\r\n        this._baseItems = [];\r\n        this._expectedExtensionDMap = {};\r\n        this._closureForItemsCache = {};\r\n        this._firstTerminalsCache = {};\r\n\r\n        this.generateStates_LR0();\r\n        this.deleteNotBaseItems();\r\n        this.generateLinksExpected();\r\n        this.expandExpected();\r\n\r\n        this._states.forEach(state => this.closure_LR(state));\r\n    }\r\n\r\n\r\n    private addReducing(syntaxTable: ISyntaxTable, state: State, reduceOperationsMap: IOperationMap): void {\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === END_POSITION) {\r\n                if (item.rule.left === START_SYMBOL) {\r\n                    this.pushInSyntaxTable(syntaxTable, state.index, END_SYMBOL, { type: EOperationType.k_Success });\r\n                } else {\r\n                    for (const expectedSymbol of item.expectedSymbols) {\r\n                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private addShift(syntaxTable: ISyntaxTable, state: State, shiftOperationsMap: IOperationMap) {\r\n        const nextStates = state.nextStates;\r\n        const nextSymbols = Object.keys(nextStates);\r\n        for (let i = 0; i < nextSymbols.length; i++) {\r\n            const nextState = nextStates[nextSymbols[i]];\r\n            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);\r\n        }\r\n    }\r\n\r\n    private buildSyntaxTable(type: EParserType): void {\r\n        this._states = [];\r\n        this._syntaxTable = {};\r\n\r\n        const stateList = this._states;\r\n        const syntaxTable = this._syntaxTable;\r\n\r\n        this.generateStates(type);\r\n\r\n        const reduceOperationsMap: IOperationMap = {};\r\n        const shiftOperationsMap: IOperationMap = {};\r\n\r\n        stateList.forEach(state => {\r\n            shiftOperationsMap[state.index] = <IOperation>{\r\n                type: EOperationType.k_Shift,\r\n                stateIndex: state.index\r\n            };\r\n        })\r\n\r\n        const nonTerminals = this.nonTerminals();\r\n        nonTerminals.forEach(nonTerminal => {\r\n            this.rules(nonTerminal).forEach(rule => {\r\n                reduceOperationsMap[rule.index] = {\r\n                    type: EOperationType.k_Reduce,\r\n                    rule: rule\r\n                };\r\n            });\r\n        });\r\n\r\n        //Build syntax table\r\n        stateList.forEach(state => {\r\n            this.addReducing(syntaxTable, state, reduceOperationsMap);\r\n            this.addShift(syntaxTable, state, shiftOperationsMap);\r\n        });\r\n    }\r\n\r\n\r\n    private statesToString(isBaseOnly: boolean = true): string {\r\n        if (!this._states) {\r\n            return \"\";\r\n        }\r\n\r\n        let msg = \"\";\r\n        for (let i = 0; i < this._states.length; i++) {\r\n            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);\r\n            msg += \" \";\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    private static operationToString(operation: IOperation): string {\r\n        let opVal: string = \"\";\r\n\r\n        switch (operation.type) {\r\n            case EOperationType.k_Shift:\r\n                opVal = \"SHIFT to state \" + operation.stateIndex.toString();\r\n                break;\r\n            case EOperationType.k_Reduce:\r\n                opVal = \"REDUCE by rule { \" + AbstractParser.ruleToString(operation.rule) + \" }\";\r\n                break;\r\n            case EOperationType.k_Success:\r\n                opVal = \"SUCCESS\";\r\n                break;\r\n        }\r\n\r\n        return opVal;\r\n    }\r\n\r\n\r\n    private static ruleToString(rule: IRule): string {\r\n        let ruleVal: string;\r\n\r\n        ruleVal = rule.left + \" : \" + rule.right.join(\" \");\r\n\r\n        return ruleVal;\r\n    }\r\n\r\n\r\n    private convertGrammarSymbol(symbol: string): string {\r\n        if (!this.isTerminal(symbol)) {\r\n            return symbol;\r\n        }\r\n        return this.lexerEngine.getTerminalValueByName(symbol);\r\n    }\r\n\r\n\r\n\r\n    private static $parserEngine: IParser = null;\r\n    private static $parserParams: IParserParams = null;\r\n\r\n    // /**\r\n    //  * Create a singleton instance of parser for internal use.\r\n    //  */\r\n    // static init(\r\n    //     parserParams: IParserParams, \r\n    //     ParserEngineConstructor: new (grammar, flags, type) => IParserEngine = null\r\n    //     ): IParserEngine {\r\n    //     const { grammar, flags, type } = parserParams;\r\n\r\n    //     if (!grammar) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (deepEqual(parserParams, ParserEngine.$parserParams)) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (isNull(ParserEngineConstructor)) {\r\n    //         ParserEngineConstructor = ParserEngine;\r\n    //     }\r\n\r\n    //     console.time();\r\n    //     console.log('%c Creating parser engine....', 'background: #222; color: #bada55');\r\n    //     ParserEngine.$parserParams = parserParams;\r\n\r\n    //     try {\r\n    //         ParserEngine.$parserEngine = new ParserEngineConstructor(grammar, flags, type);\r\n    //         console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n    //     } catch (e) {\r\n    //         ParserEngine.$parserEngine = null;\r\n    //         console.error('%c [ FAILED ]', 'background: #ffdcd6; color: #ff0000');\r\n\r\n    //         if (e instanceof DiagnosticException) {\r\n    //             verbose(e.stack);\r\n    //         }\r\n    //         throw e;\r\n    //     }\r\n\r\n    //     console.timeEnd();\r\n\r\n    //     return ParserEngine.$parserEngine;\r\n    // }\r\n\r\n\r\n    // static async parse(source: string, uri = \"stdin\", flags = EParsingFlags.k_Optimize) {\r\n\r\n    //     const engine = ParserEngine.$parserEngine;\r\n\r\n    //     const timeLabel = `parse ${uri}`;\r\n    //     console.time(timeLabel);\r\n    //     // All diagnostic exceptions should be already handled inside parser.\r\n    //     const parser = new ParserEngine.$parserEngine.parse(source, filename, flags)\r\n    //     let result = await ;\r\n    //     console.timeEnd(timeLabel);\r\n\r\n    //     let diag = ParserEngine.$parserEngine.getDiagnostics();\r\n    //     let ast = ParserEngine.$parserEngine.getSyntaxTree();\r\n\r\n    //     return { result, diag, ast };\r\n    // }\r\n}\r\n\r\n","import { EInstructionTypes, IProvideInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IProvideInstructionSettings extends IInstructionSettings {\r\n    moduleName: string;\r\n}\r\n\r\nexport class ProvideInstruction extends Instruction implements IProvideInstruction {\r\n    protected _value: string;\r\n\r\n    constructor({ moduleName, ...settings }: IProvideInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Provide, ...settings });\r\n        \r\n        this._value = moduleName;\r\n    }\r\n\r\n    get moduleName(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n}\r\n\r\n","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"ce8785dbd7ad0b8ff096.worker.js\");\n};","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction, type } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport class ProxyTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _host: ITypeInstruction;\r\n\r\n    constructor(settings: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ProxyType, ...settings });\r\n        this._host = null;\r\n    }\r\n\r\n    get host(): ITypeInstruction {\r\n        return this._host;\r\n    }\r\n    \r\n    get writable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this.isResolved() ? this.host.name : 'auto';\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.isResolved() ? this.host.size : instruction.UNDEFINE_SIZE;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.host;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return this.isResolved() ? this.host.arrayElementType : null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return this.isResolved() ? this.host.length : instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n    \r\n    get fieldNames(): string[] {\r\n        return this.isResolved() ? this.host.fieldNames : [];\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.isResolved() ? this.host.fields : [];\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isResolved(): boolean {\r\n        return !isNull(this.host);\r\n    }\r\n\r\n\r\n    resolve(host: ITypeInstruction) {\r\n        this._host = host;\r\n    }\r\n\r\n    isSampler(): boolean {\r\n        return this.isResolved() ? this.host.isSampler() : false;\r\n    }\r\n\r\n    isTexture(): boolean {\r\n        return this.isResolved() ? this.host.isTexture() : false;\r\n    }\r\n\r\n    isUAV(): boolean {\r\n        return this.isResolved() ? this.host.isUAV() : false;\r\n    }\r\n    \r\n    toString(): string {\r\n        return this.isResolved() ? this.host.toString() : this.name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.isResolved() ? this.host.toDeclString() : null;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.isResolved() ? this.host.toCode() : this.name;\r\n    }\r\n\r\n    \r\n    isBase(): boolean {\r\n        return this.isResolved() ? this.host.isBase() : false;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return this.isResolved() ? this.host.isArray() : false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return this.isResolved() ? this.host.isNotBaseArray() : false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return this.isResolved() ? this.host.isComplex() : false;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.isResolved() ? this.host.isConst() : false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this.isResolved() ? this.host.isContainArray() : false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this.isResolved() ? this.host.isContainSampler() : false;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this.isResolved() ? this.host.isContainComplexType() : false;\r\n    }\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return this.isResolved() ? this.host.hasField(fieldName) : false;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getField(fieldName) : null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.isResolved() ? this.host.getMethod(methodName, args) : null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;\r\n    }\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_STRING } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IStringInstructionSettings extends IInstructionSettings {\r\n    value: string;\r\n}\r\n\r\n\r\nexport class StringInstruction extends ExprInstruction implements ILiteralInstruction<string> {\r\n    protected _value: string;\r\n\r\n\t/**\r\n\t * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n\t */\r\n    constructor({ value, scope, ...settings }: IStringInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StringExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_STRING, SCOPE), scope, ...settings });\r\n        \r\n        this._value = value;\r\n    }\r\n\r\n    \r\n    get value(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    evaluate(): boolean {\r\n        this._evalResult = this._value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","// tslint:disable:no-for-in\r\n// tslint:disable:forin\r\n\r\nimport { isNull, verbose } from '@lib/common';\r\nimport { IPartFxInstruction } from '@lib/idl/part/IPartFx';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IPlaygroundSelectEffect } from '@sandbox/actions/ActionTypes';\r\nimport * as Pipeline from '@sandbox/containers/playground/Pipeline';\r\nimport * as PipelineNEXT from '@sandbox/containers/playground/PipelineNEXT';\r\nimport { filterPartFx, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { createLogic } from 'redux-logic';\r\n\r\nconst playgroundUpdateLogic = createLogic<IStoreState, IPlaygroundSelectEffect['payload']>({\r\n    type: [ evt.SOURCE_CODE_ANALYSIS_COMPLETE, evt.PLAYGROUND_SELECT_EFFECT ],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const file = getFileState(getState());\r\n\r\n        if (!file.slDocument) {\r\n            done();\r\n            return;\r\n        }\r\n\r\n        if (file.slDocument.diagnosticReport.errors > 0) {\r\n            done();\r\n            return;\r\n        }\r\n\r\n        verbose('playground has been updated.');\r\n\r\n        const scope = getScope(file);\r\n        const list: IPartFxInstruction[] = filterPartFx(scope);\r\n\r\n        let active = action.type === evt.PLAYGROUND_SELECT_EFFECT ? action.payload.name : null;\r\n        let emitterPrev = file.emitter;\r\n        let emitterNext = null;\r\n\r\n        if (!isNull(emitterPrev) && isNull(active)) {\r\n            if (list.map(fx => fx.name)\r\n                .indexOf(emitterPrev.name) !== -1) {\r\n                active = emitterPrev.name;\r\n            }\r\n        }\r\n\r\n        if (!active) {\r\n            for (const fx of list) {\r\n                if (fx.isValid()) {\r\n                    active = fx.name;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (active) {\r\n            const i = list.map(fx => fx.name)\r\n                .indexOf(active);\r\n\r\n            if (!emitterPrev || !(await emitterPrev.shadowReload(list[i]))) {\r\n                emitterNext = await PipelineNEXT.createEmitter(list[i]);\r\n                // emitterNext = await Pipeline.createEmitter(list[i]);\r\n                if (emitterNext) {\r\n                    emitterNext.start();\r\n                    verbose('next emitter has been created.');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (emitterNext && emitterPrev) {\r\n            emitterPrev.stop();\r\n            emitterPrev = null;\r\n            verbose('previous emitter has been dropped.');\r\n        }\r\n\r\n        const emitter = emitterNext || emitterPrev;\r\n        dispatch({ type: evt.PLAYGROUND_EMITER_UPDATE, payload: { emitter } });\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nexport default [\r\n    playgroundUpdateLogic\r\n];\r\n","import { EInstructionTypes, IAttributeInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IStmtBlockInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionDeclInstructionSettings extends IDeclInstructionSettings {\r\n    definition: IFunctionDefInstruction;\r\n    implementation?: IStmtBlockInstruction;\r\n    attributes?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]\r\n * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction\r\n */\r\nexport class FunctionDeclInstruction extends DeclInstruction implements IFunctionDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n    \r\n\r\n    constructor({ definition, implementation = null, attributes = null, ...settings }: IFunctionDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDecl, ...settings });\r\n\r\n        this.def = Instruction.$withParent(definition, this);\r\n        this.impl = Instruction.$withParent(implementation, this);\r\n        this.attributes = (attributes || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.def.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this.def.id;\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this.def.semantic;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code = '';\r\n        code += this.def.toCode();\r\n        if (this.impl) {\r\n            code += this.impl.toCode();\r\n        } else {\r\n            code += ';';\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","export enum EOperation {\r\n    // note: assuming that Load is 32bit and Move is 32bit too\r\n    k_I32LoadRegister,          // registers => registers\r\n    k_I32LoadInput,             // input => registers\r\n    \r\n    k_I32LoadInputPointer,      // input pointer => register\r\n    k_I32LoadRegistersPointer,  // register pointer => register\r\n    \r\n    k_I32StoreRegisterPointer,  // register => register pointer\r\n    \r\n    k_I32StoreInput,            // registers => input\r\n    k_I32StoreInputPointer,     // register => input pointer\r\n    \r\n    k_I32SetConst,              // set constant => registers\r\n\r\n    //\r\n    // Arithemtic operations\r\n    //\r\n\r\n    k_I32Add,\r\n    k_I32Sub,\r\n    k_I32Mul,\r\n    k_I32Div,\r\n\r\n    k_F32Add,\r\n    k_F32Sub,\r\n    k_F32Mul,\r\n    k_F32Div,\r\n\r\n    //\r\n    // Relational operations\r\n    //\r\n\r\n    k_U32LessThan,\r\n    k_U32GreaterThanEqual,\r\n    k_I32LessThan,\r\n    k_I32GreaterThanEqual, \r\n    k_I32Equal,\r\n    k_I32NotEqual,\r\n    k_I32Not,\r\n    k_F32LessThan,\r\n    k_F32GreaterThanEqual,\r\n\r\n    //\r\n    // Logical operations\r\n    //\r\n\r\n    k_I32LogicalOr,\r\n    k_I32LogicalAnd,\r\n\r\n    //\r\n    // intrinsics\r\n    //\r\n\r\n    k_F32Frac,\r\n    k_F32Floor,\r\n    k_F32Ceil,\r\n    k_F32Sin,\r\n    k_F32Cos,\r\n    k_F32Abs,\r\n    k_F32Sqrt,\r\n    k_F32Max,\r\n    k_F32Min,\r\n    \r\n    k_I32Mad,\r\n    k_I32Min,\r\n    k_I32Max,\r\n    \r\n    // \r\n    // Cast operations\r\n    //\r\n\r\n    k_F32ToU32,\r\n    k_F32ToI32,\r\n    k_U32ToF32,\r\n    k_I32ToF32,\r\n\r\n    //\r\n    // Flow control\r\n    //\r\n\r\n    k_Jump,\r\n    k_JumpIf,\r\n\r\n    // the operation is only necessary to maintain the purity of the code, \r\n    // when generating the code will be replaced by a jump for all \r\n    // functions except entry point;\r\n    k_Ret\r\n};","import { EInstructionTypes, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n}\r\n\r\nexport class IdInstruction extends Instruction implements IIdInstruction {\r\n    readonly name: string;\r\n\r\n    constructor({ name, ...settings }: IIdInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Id, ...settings });\r\n        this.name = name;\r\n    }\r\n    \r\n    \r\n    toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixArithmeticInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type PostfixOperator = \"++\" | \"--\";\r\n\r\nexport interface IPostfixArithmeticInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: PostfixOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr ++\r\n * (-- | ++) Instruction\r\n */\r\nexport class PostfixArithmeticInstruction extends ExprInstruction implements IPostfixArithmeticInstruction {\r\n    protected _operator: PostfixOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    \r\n    constructor({ expr, operator, ...settings }: IPostfixArithmeticInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });\r\n\r\n        this._operator = operator;\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n\r\n        code += this.expr.toCode();\r\n        code += this.operator;\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n\r\n","import { assert, isDefAndNotNull, verbose } from '@lib/common';\r\nimport { type } from '@lib/fx/analisys/helpers';\r\nimport * as Bytecode from '@lib/fx/bytecode/Bytecode';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { createSLDocument } from '@lib/fx/SLDocument';\r\nimport { FxTranslator, ICSShaderReflection, IUavReflection } from '@lib/fx/translators/FxTranslator';\r\nimport * as Glsl from '@lib/fx/translators/GlslEmitter';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IPartFxInstruction } from '@lib/idl/part/IPartFx';\r\nimport * as THREE from 'three';\r\n\r\nimport { IPass } from './IEmitter';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\n// TODO: use CDL instead of reflection\r\n\r\n/* tslint:disable:typedef */\r\n/* tslint:disable:variable-name */\r\n/* tslint:disable:member-ordering */\r\n\r\ntype IUAVResource = ReturnType<typeof VM.createUAV>;\r\n\r\n\r\nfunction createUAVEx(document: ISLDocument, reflection: IUavReflection, length: number): IUAVResource {\r\n    const elementSize = document.root.scope.findType(reflection.elementType).size; // in bytes\r\n    return VM.createUAV(reflection.name, elementSize, length, reflection.register);\r\n}\r\n\r\n// tslint:disable-next-line:max-line-length\r\nfunction createUAVsEx(document: ISLDocument, reflection: ICSShaderReflection, capacity: number, sharedUAVs: IUAVResource[] = []): IUAVResource[] {\r\n    return reflection.uavs.map(uavReflection => {\r\n        const shraredUAV = sharedUAVs.find(uav => uav.name === uavReflection.name);\r\n        return shraredUAV || createUAVEx(document, uavReflection, capacity);\r\n    });\r\n}\r\n\r\nfunction createBundle(document: ISLDocument, reflection: ICSShaderReflection): VM.Bundle {\r\n    const shader = document.root.scope.findFunction(reflection.name, null);\r\n    assert(shader);\r\n\r\n    // const numthreads = shader.attributes.find(attr => attr.name === 'numthreads');\r\n    // assert(isDefAndNotNull(numthreads));\r\n\r\n    const program = Bytecode.translate(shader);\r\n    return VM.load(program.code);\r\n}\r\n\r\nfunction setupBundle(document: ISLDocument, reflection: ICSShaderReflection, capacity: number, sharedUAVs: IUAVResource[]) {\r\n    const bundle = createBundle(document, reflection);\r\n    const uavs = createUAVsEx(document, reflection, capacity, sharedUAVs);\r\n    const numthreads = reflection.numthreads;\r\n    uavs.forEach(uav => { bundle.input[uav.index] = uav.buffer; });\r\n\r\n    // update shared uavs\r\n    sharedUAVs.push(...uavs.filter(uav => sharedUAVs.indexOf(uav) === -1));\r\n\r\n    function setConstants(constants: IMap<number>) {\r\n        Object.keys(constants)\r\n            .forEach(name => VM.setConstant(bundle, name, constants[name]));\r\n    }\r\n\r\n    assert(numthreads[0] >= 1 && numthreads[1] === 1 && numthreads[2] === 1);\r\n\r\n    function run(numgroups: number) {\r\n        VM.dispatch(bundle, [numgroups, 1, 1], numthreads);\r\n    }\r\n\r\n    return {\r\n        uavs,\r\n        bundle,\r\n        run,\r\n        setConstants,\r\n        groupsizex: numthreads[0]\r\n    };\r\n}\r\n\r\n\r\nfunction fxHash(fx: IPartFxInstruction) {\r\n    const hashPart = fx.passList\r\n        .map(pass => `${type.signature(pass.particleInstance)}:${pass.geometry}:${pass.sorting}:`) // +\r\n        // `${crc32(Code.translate(pass.vertexShader))}:${crc32(Code.translate(pass.pixelShader))}`)\r\n        .reduce((commonHash, passHash) => `${commonHash}:${passHash}`);\r\n    return `${type.signature(fx.particle)}:${fx.capacity}:${hashPart}`;\r\n}\r\n\r\n\r\nfunction createTimelime() {\r\n    let startTime: number;\r\n    let elapsedTimeLevel: number;\r\n    let active: boolean;\r\n\r\n    const constants = {\r\n        elapsedTime: 0,\r\n        elapsedTimeLevel: 0\r\n    };\r\n\r\n    function stop() {\r\n        active = false;\r\n        verbose('emitter stopped');\r\n    }\r\n\r\n    function start() {\r\n        constants.elapsedTime = 0;\r\n        constants.elapsedTimeLevel = 0;\r\n\r\n        startTime = Date.now();\r\n        elapsedTimeLevel = 0;\r\n        active = true;\r\n        verbose('emitter started');\r\n    }\r\n\r\n    function tick() {\r\n        if (!active) {\r\n            return;\r\n        }\r\n\r\n        const dt = Date.now() - startTime;\r\n        constants.elapsedTime = (dt - elapsedTimeLevel) / 1000;\r\n        constants.elapsedTimeLevel = elapsedTimeLevel / 1000;\r\n        elapsedTimeLevel = dt;\r\n    }\r\n\r\n    function isStopped() {\r\n        return !active;\r\n    }\r\n\r\n    return {\r\n        constants,\r\n        start,\r\n        stop,\r\n        tick,\r\n        isStopped\r\n    };\r\n}\r\n\r\ntype ITimeline = ReturnType<typeof createTimelime>;\r\n\r\ninterface IPassEx extends IPass {\r\n    bundle: ReturnType<typeof setupBundle>;\r\n    dump(): void;\r\n}\r\n\r\n// tslint:disable-next-line:max-func-body-length\r\nasync function load(fx: IPartFxInstruction, uavResources: IUAVResource[]) {\r\n    const emitter = new FxTranslator();\r\n    const reflection = emitter.emitPartFxDecl(fx);\r\n    const textDocument = { uri: '://raw', source: emitter.toString() };\r\n    const slDocument = await createSLDocument(textDocument);\r\n\r\n    if (slDocument.diagnosticReport.errors) {\r\n        console.error(Diagnostics.stringify(slDocument.diagnosticReport));\r\n        return null;\r\n    }\r\n\r\n    const { name, capacity } = reflection;\r\n    const scope = slDocument.root.scope;\r\n    const particle = scope.findType(reflection.particle);\r\n\r\n    const resetBundle = setupBundle(slDocument, reflection.CSParticlesResetRoutine, capacity, uavResources);\r\n    const initBundle = setupBundle(slDocument, reflection.CSParticlesInitRoutine, capacity, uavResources);\r\n    const updateBundle = setupBundle(slDocument, reflection.CSParticlesUpdateRoutine, capacity, uavResources);\r\n    const spawnBundle = setupBundle(slDocument, reflection.CSParticlesSpawnRoutine, 4, uavResources);\r\n\r\n    const uavDeadIndices = uavResources.find(uav => uav.name === FxTranslator.UAV_DEAD_INDICES);\r\n    const uavParticles = uavResources.find(uav => uav.name === FxTranslator.UAV_PARTICLES);\r\n    const uavStates = uavResources.find(uav => uav.name === FxTranslator.UAV_STATES);\r\n    const uavInitArguments = uavResources.find(uav => uav.name === FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS);\r\n\r\n    const passes = reflection.passes.map(({ VSParticleShader,\r\n        PSParticleShader,\r\n        geometry,\r\n        sorting,\r\n        instanceCount,\r\n        instance,\r\n        CSParticlesPrerenderRoutine\r\n    }, i): IPassEx => {\r\n\r\n        const UAV_PRERENDERED = `uavPrerendered${i}`;\r\n\r\n        const bundle = setupBundle(slDocument, CSParticlesPrerenderRoutine, capacity * instanceCount, uavResources);\r\n        const uav = bundle.uavs.find(uav => uav.name === UAV_PRERENDERED);\r\n\r\n        const vertexShader = Glsl.translate(scope.findFunction(VSParticleShader, null), { mode: 'vertex' });\r\n        const pixelShader = Glsl.translate(scope.findFunction(PSParticleShader, null), { mode: 'pixel' });\r\n        const instanceType = scope.findType(instance);\r\n        const stride = instanceType.size >> 2;\r\n\r\n        const numRenderedParticles = () => numParticles() * instanceCount;\r\n\r\n        const instanceLayout = instanceType.fields.map(field => {\r\n            const size = field.type.size >> 2;\r\n            const offset = field.type.padding >> 2;\r\n            const attrName = Glsl.GlslEmitter.$declToAttributeName(field);\r\n            return { attrName, size, offset };\r\n        });\r\n\r\n        // tslint:disable-next-line:max-line-length\r\n        const uavPrerenderedReflection = CSParticlesPrerenderRoutine.uavs.find(uavReflection => uavReflection.name === UAV_PRERENDERED);\r\n        const elementType = scope.findType(uavPrerenderedReflection.elementType);\r\n\r\n        // dump prerendered particles\r\n        const dump = (): void => {\r\n            verbose(`dump ${uav.readCounter()}/${capacity} prerendred particles: `);\r\n            for (let iElement = 0; iElement < uav.readCounter(); ++iElement) {\r\n                verbose(VM.asNativeInner(uav.readElement(iElement), elementType));\r\n            }\r\n        };\r\n\r\n\r\n        //\r\n        // Sorting\r\n        //\r\n\r\n        const uavNonSorted = uav;\r\n        const uavSorted = !sorting ? uavNonSorted : createUAVEx(slDocument, uavPrerenderedReflection, capacity);\r\n\r\n        function sort(targetPos: THREE.Vector3) {\r\n            assert(sorting);\r\n\r\n            // NOTE: yes, I understand this is a crappy and stupid brute force sorting,\r\n            //       I hate javascript for that :/\r\n\r\n            const v3 = new THREE.Vector3();\r\n            const length = numRenderedParticles();\r\n\r\n            const nStride = stride * instanceCount; // stride in floats\r\n\r\n            assert(uavSorted.data.byteLength >> 2 === nStride * capacity);\r\n\r\n            const src = new Float32Array(uavNonSorted.data.buffer, uavNonSorted.data.byteOffset, uavNonSorted.data.byteLength >> 2);\r\n            const dst = new Float32Array(uavSorted.data.buffer, uavSorted.data.byteOffset, uavSorted.data.byteLength >> 2);\r\n\r\n            const indicies = [];\r\n\r\n            // NOTE: sort using only first instance's postion\r\n            for (let iPart = 0; iPart < length; ++iPart) {\r\n                const offset = iPart * nStride;\r\n                const dist = v3\r\n                    .fromArray(src, offset/* add offset of POSTION semantic */)\r\n                    .distanceTo(targetPos);\r\n                indicies.push([iPart, dist]);\r\n            }\r\n\r\n            indicies.sort((a, b) => -a[1] + b[1]);\r\n\r\n            for (let i = 0; i < indicies.length; ++i) {\r\n                const iFrom = indicies[i][0] * nStride;\r\n                const iTo = i * nStride;\r\n\r\n                const from = src.subarray(iFrom, iFrom + nStride);\r\n                const copyTo = dst.subarray(iTo, iTo + nStride);\r\n                copyTo.set(from);\r\n            }\r\n        }\r\n\r\n        const data = new Uint8Array(uavSorted.data.buffer, uavSorted.data.byteOffset, uavSorted.data.byteLength);\r\n        return {\r\n            data,\r\n            instanceLayout,\r\n            stride,\r\n            geometry,\r\n            sorting,\r\n            vertexShader,\r\n            pixelShader,\r\n            length: numRenderedParticles,\r\n            sort,\r\n            bundle,\r\n            dump\r\n        };\r\n    });\r\n\r\n    const numParticles = () => capacity - uavDeadIndices.readCounter();\r\n\r\n    function reset() {\r\n        // reset all available particles\r\n        resetBundle.run(Math.ceil(capacity / resetBundle.groupsizex));\r\n        uavDeadIndices.overwriteCounter(capacity);\r\n    }\r\n\r\n\r\n    function update(timeline: ITimeline) {\r\n        updateBundle.setConstants(timeline.constants);\r\n        updateBundle.run(Math.ceil(capacity / updateBundle.groupsizex));\r\n    }\r\n\r\n\r\n    function prerender(timelime: ITimeline) {\r\n        passes.forEach(({ bundle }, i) => {\r\n            const uavPrerendered = bundle.uavs.find(uav => uav.name === `uavPrerendered${i}`);\r\n            uavPrerendered.overwriteCounter(0);\r\n            bundle.setConstants(timelime.constants);\r\n            bundle.run(Math.ceil(capacity / bundle.groupsizex));\r\n        });\r\n    }\r\n\r\n\r\n    function emit(timeline: ITimeline) {\r\n        initBundle.setConstants(timeline.constants);\r\n        // console.log('emit >>', uavInitArguments.data[0],\r\n        //     (new Float32Array(uavInitArguments.data.buffer, uavInitArguments.data.byteOffset))[3],\r\n        //     (new Float32Array(uavInitArguments.data.buffer, uavInitArguments.data.byteOffset))[4]);\r\n        initBundle.run(uavInitArguments.data[0]);\r\n\r\n        spawnBundle.setConstants(timeline.constants);\r\n        spawnBundle.run(1);\r\n        // console.log(spawnBundle.uavs, timeline.constants.elapsedTime);\r\n        return;\r\n    }\r\n\r\n\r\n    function dump() {\r\n        const npart = numParticles();\r\n        const partSize = particle.size;\r\n\r\n        verbose(`particles total: ${npart} (${uavDeadIndices.readCounter()}/${capacity})`);\r\n\r\n        uavStates.data.forEach((alive, iPart) => {\r\n            if (alive) {\r\n                const partRaw = new Uint8Array(uavParticles.data.buffer, uavParticles.data.byteOffset + iPart * partSize, partSize);\r\n                verbose(iPart, VM.asNativeInner(partRaw, particle));\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    return {\r\n        name,\r\n        capacity,\r\n        passes,\r\n        numParticles,\r\n        reset,\r\n        emit,\r\n        update,\r\n        prerender,\r\n        dump\r\n    };\r\n}\r\n\r\n\r\n// tslint:disable-next-line:max-func-body-length\r\nexport async function createEmitter(fx: IPartFxInstruction) {\r\n\r\n    const uavResources: IUAVResource[] = []; // << shared UAV resources\r\n    const timeline = createTimelime();\r\n    const emitter = await load(fx, uavResources);\r\n\r\n    if (!emitter) {\r\n        return null;\r\n    }\r\n\r\n    let {\r\n        name,\r\n        capacity,\r\n        passes,\r\n        numParticles,\r\n        reset,\r\n        emit,\r\n        update,\r\n        prerender,\r\n        dump\r\n    } = emitter;\r\n\r\n    reset();\r\n\r\n    const { start, stop, isStopped } = timeline;\r\n\r\n    function tick() {\r\n        if (!timeline.isStopped()) {\r\n            update(timeline);\r\n            emit(timeline);\r\n            prerender(timeline);\r\n            timeline.tick();\r\n        }\r\n    }\r\n\r\n\r\n    async function shadowReload(fxNext: IPartFxInstruction): Promise<boolean> {\r\n        if (fxHash(fxNext) !== fxHash(fx)) {\r\n            return false;\r\n        }\r\n\r\n        verbose('emitter reloaded from the shadow');\r\n\r\n        const emitter = await load(fxNext, uavResources);\r\n\r\n        if (!emitter) {\r\n            return false;\r\n        }\r\n\r\n        ({\r\n            name,\r\n            capacity,\r\n            passes,\r\n            numParticles,\r\n            reset,\r\n            emit,\r\n            update,\r\n            prerender,\r\n            dump\r\n        } = emitter);\r\n\r\n        return true;\r\n    }\r\n\r\n    return {\r\n        get name() {\r\n            return name;\r\n        },\r\n\r\n        capacity,\r\n\r\n        start,\r\n        stop,\r\n        tick,\r\n        isStopped,\r\n        length: numParticles,\r\n        passes,\r\n\r\n        reset,\r\n        shadowReload\r\n    };\r\n}\r\n\r\n\r\nexport type Emitter = ReturnType<typeof createEmitter>;\r\nexport type Pass = IPass;\r\n","import { ICompileExprInstruction, IFunctionDeclInstruction, IPassInstruction, IStructDeclInstruction, ITechniqueInstruction, ITypeInstruction, IStmtInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// import { EPartFxInstructionTypes } from \"./IPartFxInstruction\";\r\n\r\nexport enum EPartFxPassGeometry {\r\n    k_Billboard,\r\n    k_Cylinder,\r\n    k_Box,\r\n    k_Sphere,\r\n    k_Line\r\n}\r\n\r\nexport interface IPartFxPassInstruction extends IPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly particleInstance: ITypeInstruction;\r\n    readonly geometry: EPartFxPassGeometry;\r\n    readonly instanceCount: number;\r\n\r\n    /** check if the pass is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\n\r\n export interface IPartFxInstruction extends ITechniqueInstruction {\r\n\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    readonly passList: IPartFxPassInstruction[];\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n }\r\n\r\n\r\n export interface ISpawnStmtInstruction extends IStmtInstruction {\r\n    readonly name: string;\r\n    readonly count: number;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    // resolved properties\r\n    readonly fx: IPartFxInstruction;\r\n    readonly init: IFunctionDeclInstruction;\r\n }","import { assert, isUint } from \"@lib/common\";\r\nimport { isBoolBasedType, isFloatBasedType, isIntBasedType, isUIntBasedType, T_FLOAT, T_FLOAT4 } from \"@lib/fx/analisys/SystemScope\";\r\nimport { IFunctionDeclInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPartFxPassGeometry, IPartFxInstruction, IPartFxPassInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { FxEmitter } from \"./FxEmitter\";\r\n\r\nexport interface IUavReflection {\r\n    register: number;\r\n    name: string;\r\n    type: string;\r\n    uavType: string;\r\n    elementType: string;\r\n};\r\n\r\nexport interface ICSShaderReflection {\r\n    name: string;\r\n    numthreads: number[];\r\n    uavs: IUavReflection[];\r\n}\r\n\r\nexport interface IFxReflection {\r\n    name: string;\r\n    capacity: number;\r\n    particle: string; // << particle type name\r\n    CSParticlesSpawnRoutine: ICSShaderReflection;\r\n    CSParticlesResetRoutine: ICSShaderReflection;\r\n    CSParticlesInitRoutine: ICSShaderReflection;\r\n    CSParticlesUpdateRoutine: ICSShaderReflection;\r\n\r\n    passes: {\r\n        instance: string;\r\n        sorting: boolean;\r\n        geometry: EPartFxPassGeometry;\r\n        instanceCount: number;\r\n        VSParticleShader: string;\r\n        PSParticleShader: string;\r\n        CSParticlesPrerenderRoutine: ICSShaderReflection;\r\n    }[];\r\n}\r\n\r\nexport class FxTranslator extends FxEmitter {\r\n    static UAV_PARTICLES = 'uavParticles';\r\n    static UAV_STATES = 'uavStates';\r\n    static UAV_DEAD_INDICES = 'uavDeadIndices';\r\n    static UAV_CREATION_REQUESTS = 'uavCreationRequests';\r\n    static UAV_PRERENDERED = 'uavPrerendered';\r\n    static UAV_SPAWN_DISPATCH_ARGUMENTS = 'uavSpawnDispatchArguments';\r\n\r\n    private static UAV_PARTICLES_DESCRIPTION = `The buffer contains user-defined particle data.`;\r\n    private static UAV_STATES_DESCRIPTION = `The buffer contains the state of the particles, Alive or dead.`;\r\n    private static UAV_DEAD_INDICES_DESCRIPTION = `The buffer contains indicies of dead particles.`;\r\n    private static UAV_CREATION_REQUESTS_DESCRIPTION = 'The buffer contatins information about the number and type of particles to be created';\r\n    private static UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION = '[no description added :/]';\r\n\r\n    private static SPAWN_OPERATOR_POLYFILL_NAME = '__spawn_op';\r\n    private static SPAWN_OPERATOR_TYPE = '__SPAWN_T__';\r\n\r\n\r\n    protected knownUAVs: IUavReflection[] = [];\r\n    protected knownSpawnCtors: IFunctionDeclInstruction[] = [];\r\n\r\n\r\n    protected emitSpawnStmt(stmt: ISpawnStmtInstruction) {\r\n\r\n        let guid = this.knownSpawnCtors.findIndex(ctor => ctor === stmt.init) + 1;\r\n\r\n        if (guid === 0) {\r\n            this.knownSpawnCtors.push(stmt.init);\r\n            guid = this.knownSpawnCtors.length;\r\n\r\n            this.emitSpawnOperator(guid, stmt.init);\r\n        }\r\n\r\n        this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitKeyword(`${stmt.count}u`);\r\n        if (stmt.args.length) {\r\n            this.emitChar(',');\r\n            this.emitExpressionList(stmt.args);\r\n        }\r\n        this.emitChar(')');\r\n        this.emitChar(';');\r\n        this.emitNewline();\r\n\r\n        // super.emitSpawnStmt(stmt);\r\n    }\r\n\r\n\r\n    emitUav(type: string, name: string, comment?: string): IUavReflection {\r\n        let register = this.knownUAVs.map(uav => uav.name).indexOf(name);\r\n        if (register === -1) {\r\n            this.begin();\r\n            {\r\n                register = this.knownUAVs.length;\r\n                comment && this.emitComment(comment);\r\n                this.emitLine(`${type} ${name}: register(u${register});`);\r\n\r\n                const regexp = /^([\\w]+)<([\\w0-9_]+)>$/;\r\n                const match = type.match(regexp);\r\n                assert(match);\r\n\r\n                const reflection: IUavReflection = {\r\n                    name,\r\n                    type,\r\n                    uavType: match[1],\r\n                    elementType: match[2],\r\n                    register\r\n                };\r\n\r\n                this.knownUAVs.push(reflection);\r\n            }\r\n            this.end();\r\n        }\r\n\r\n        return this.knownUAVs[register];\r\n    }\r\n\r\n    emitResetShader(fx: IPartFxInstruction): ICSShaderReflection {\r\n        const name = 'CSParticlesResetRoutine';\r\n        const numthreads = [64, 1, 1];\r\n        const uavs = [];\r\n\r\n        const reflection: ICSShaderReflection = { name, numthreads, uavs };\r\n\r\n        const capacity = fx.capacity;\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint tid = DTid.x;`);\r\n                this.emitLine(`if (tid >= ${capacity}) return;`);\r\n\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));\r\n                this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[tid] = tid;`);\r\n\r\n                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));\r\n                this.emitLine(`${FxTranslator.UAV_STATES}[tid] = 0;`);\r\n\r\n                const { typeName: partType } = this.resolveType(fx.particle);\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));\r\n                this.emitLine(`${partType} Particle;`);\r\n\r\n                assert(fx.particle.isComplex());\r\n                fx.particle.fields.forEach(({ name, type }: IVariableDeclInstruction) => {\r\n                    assert(type.length >= 1);\r\n                    let zero = isFloatBasedType(type) ? '0.f' : isBoolBasedType(type) ? 'false' : '0';\r\n                    if (type.length === 1) {\r\n                        this.emitLine(`Particle.${name} = ${zero};`);\r\n                    } else {\r\n                        this.emitLine(`Particle.${name} = ${type.name}(${Array(type.length).fill(zero).join(', ')});`);\r\n                    }\r\n                });\r\n\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[tid] = Particle;`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        return reflection;\r\n    }\r\n\r\n\r\n    // TOOD: sync groupSize with value used inside the emitInitShader();\r\n    protected emitSpawnOperator(guid: number, ctor: IFunctionDeclInstruction, groupSize: number = 64): IUavReflection[] {\r\n        const uavs = <IUavReflection[]>[];\r\n\r\n        this.begin();\r\n        {\r\n            this.emitKeyword('void');\r\n            this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitKeyword(`uint nPart`);\r\n            if (ctor) {\r\n                this.emitChar(',');\r\n                this.emitParams(ctor.def.params.slice(2));\r\n            }\r\n            this.emitChar(')');\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`,\r\n                    FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));\r\n                uavs.push(this.emitUav(`RWBuffer<uint>`,\r\n                    FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION));\r\n\r\n                this.emitLine(`int nGroups = (int)ceil((float)nPart / ${groupSize}.f);`);\r\n                this.emitLine(`for (int i = 0; i < nGroups; ++i)`);\r\n                this.emitChar(`{`);\r\n                this.push();\r\n                {\r\n                    this.emitLine(`uint RequestId;`);\r\n                    this.emitLine(`// layout: [ uint GroupCountX, uint GroupCountY, uint GroupCountZ ]`);\r\n                    this.emitLine(`InterlockedAdd(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0], 1u, RequestId);`);\r\n                    // params\r\n                    const request = `${FxTranslator.UAV_CREATION_REQUESTS}[RequestId]`;\r\n                    this.emitLine(`${request}.count = min(nPart, ${groupSize}u);`);\r\n                    this.emitLine(`${request}.type = ${guid}u;`);\r\n\r\n                    if (ctor) {\r\n                        const params = ctor.def.params;\r\n                        let nfloat = 0;\r\n                        // skip first two arguments\r\n                        params.slice(2).forEach(param => {\r\n                            let type = param.type;\r\n                            if (type.isComplex()) {\r\n                                assert(false, 'unsupported', type.toCode());\r\n                            }\r\n\r\n                            let n = type.size / T_FLOAT.size;\r\n                            for (let i = 0; i < n; ++i) {\r\n                                this.emitLine(`${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}] = asfloat(${param.name}${type.isArray()? `[${i % 4}]`: ``});`);\r\n                                nfloat++;\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    this.emitLine(`nPart = nPart - ${groupSize}u;`);\r\n                }\r\n                this.pop();\r\n                this.emitChar(`}`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n\r\n        }\r\n        this.end();\r\n\r\n        return uavs;\r\n    }\r\n\r\n\r\n    emitSpawnShader(fx: IPartFxInstruction): ICSShaderReflection {\r\n        const spawnFn = fx.spawnRoutine.function;\r\n        const elapsedTime = fx.scope.findVariable('elapsedTime');\r\n\r\n        const name = 'CSParticlesSpawnRoutine';\r\n        const numthreads = [1, 1, 1];\r\n        const uavs = [];\r\n\r\n\r\n\r\n        const reflection = <ICSShaderReflection>{ name, numthreads, uavs };\r\n\r\n        uavs.push(...this.emitSpawnOperator(0, null));\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`if (DTid.x != 0u) return;`);\r\n                this.emitNewline();\r\n\r\n                this.emitLine(`// usage of 4th element of ${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS} as temp value of number of particles`);\r\n                this.emitFunction(spawnFn);\r\n                this.emitGlobal(elapsedTime);\r\n\r\n                this.emitLine(`float nPartAddFloat = asfloat(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3]) + (float)${spawnFn.name}() * elapsedTime;`);\r\n                this.emitLine(`float nPartAdd = floor(nPartAddFloat);`);\r\n                // TODO: replace with InterlockedExchange()\r\n\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0] = 0u;`);\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[1] = 1u;`);\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[2] = 1u;`);\r\n                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3] = asuint(nPartAddFloat - nPartAdd);`);\r\n                // TODO: check the capacity\r\n                // this.emitLine(`nPartAdd = min(nPartAdd, )`)\r\n                this.emitLine(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}0__((uint)nPartAdd);`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        return reflection;\r\n    }\r\n\r\n\r\n    emitInitShader(fx: IPartFxInstruction): ICSShaderReflection {\r\n        const initFn = fx.initRoutine.function;\r\n\r\n        const name = 'CSParticlesInitRoutine';\r\n        const numthreads = [64, 1, 1];\r\n        const uavs = [];\r\n\r\n        const reflection = <ICSShaderReflection>{ name, numthreads, uavs };\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint GroupId = Gid.x;`);\r\n                this.emitLine(`uint ThreadId = GTid.x;`);\r\n                // TODO: emit operator instead!\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));\r\n                this.emitLine(`uint nPart = ${FxTranslator.UAV_CREATION_REQUESTS}[GroupId].count;`);\r\n                this.emitNewline();\r\n                this.emitLine(`if (ThreadId >= nPart) return;`);\r\n                this.emitNewline();\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));\r\n                this.emitLine(`int n = (int)${FxTranslator.UAV_DEAD_INDICES}.DecrementCounter();`);\r\n                this.emitComment(`a bit confusing way to check for particles running out`);\r\n                this.emitLine(`if (n <= 0)`);\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    this.emitComment(`not very beautiful, but a cheap way not to`);\r\n                    this.emitComment(`think about the correctness of this counter`);\r\n                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);\r\n                    this.emitLine('return;');\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitNewline();\r\n                this.emitNewline();\r\n                this.emitLine(`uint PartId = ${FxTranslator.UAV_DEAD_INDICES}[n];`);\r\n\r\n                const { typeName: partType } = this.resolveType(fx.particle);\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));\r\n                this.emitLine(`${partType} Particle;`);\r\n                this.emitFunction(initFn);\r\n\r\n                const request = `${FxTranslator.UAV_CREATION_REQUESTS}[GroupId]`;\r\n\r\n                this.emitLine(`uint type = ${request}.type;`);\r\n                this.emitLine(`if (type == 0u)`);\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    this.emitLine(`${initFn.name}(Particle${initFn.def.params.length > 1 ? ', PartId' : ''});`);\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitNewline();\r\n\r\n                this.knownSpawnCtors.forEach((ctor, i) => {\r\n                    this.emitFunction(ctor);\r\n                    this.emitLine(`else if (type == ${i + 1}u)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                    {\r\n                        // TODO: move param unpacking to separate function\r\n                        // unpack arguments\r\n                        let nfloat = 0;\r\n                        let params = ctor.def.params.slice(2);\r\n                        params.forEach(param => {\r\n                            this.emitVariableDecl(param);\r\n                            this.emitChar(';');\r\n                            this.emitNewline();\r\n\r\n                            const type = param.type;\r\n                            if (type.isComplex()) {\r\n                                assert(false, 'unsupported', type.toCode());\r\n                            }\r\n\r\n                            let interpreter = 'asfloat';\r\n                            if (isFloatBasedType(type)) { interpreter = 'asfloat'; }\r\n                            if (isIntBasedType(type)) { interpreter = 'asint'; }\r\n                            if (isUIntBasedType(type)) { interpreter = 'asuint'; }\r\n                            \r\n                            let n = type.size / T_FLOAT.size;\r\n                            for (let i = 0; i < n; ++i) {\r\n                                this.emitLine(`${param.name}${type.isArray() ? `[${i % 4}]`: ``} = ${interpreter}(${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}]);`);\r\n                                nfloat++;\r\n                            }\r\n                            \r\n\r\n                            this.emitNewline();\r\n                        });\r\n                        this.emitLine(`${ctor.name}(Particle, PartId, ${params.map(param => param.name).join(', ')});`);\r\n                    }\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                    this.emitNewline();\r\n                });\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);\r\n                this.emitComment('set particles\\'s state as \\'Alive\\'');\r\n                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));\r\n                this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 1;`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        return reflection;\r\n    }\r\n\r\n    emitUpdateShader(fx: IPartFxInstruction): ICSShaderReflection {\r\n        const updateFn = fx.updateRoutine.function;\r\n\r\n        const name = 'CSParticlesUpdateRoutine';\r\n        const numthreads = [64, 1, 1];\r\n        const uavs = [];\r\n\r\n        const reflection = <ICSShaderReflection>{ name, numthreads, uavs };\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint PartId = DTid.x;`);\r\n                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));\r\n                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);\r\n                this.emitNewline();\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if(!Alive) return;`);\r\n                this.emitNewline();\r\n\r\n                const { typeName: partType } = this.resolveType(fx.particle);\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));\r\n                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);\r\n                this.emitNewline();\r\n\r\n                this.emitFunction(updateFn);\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if (!${updateFn.name}(Particle${updateFn.def.params.length > 1 ? ', PartId' : ''}))`);\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    uavs.push(this.emitUav(`RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION));\r\n                    this.emitComment('returning the particle index to the list of the dead');\r\n                    this.emitLine(`uint n = ${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);\r\n                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[n] = PartId;`);\r\n                    this.emitNewline();\r\n\r\n                    this.emitComment('set particles\\'s state as \\'dead\\'');\r\n                    this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 0;`);\r\n                    this.emitLine('return;');\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n                this.emitNewline();\r\n                this.emitNewline();\r\n\r\n                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        // hack\r\n        uavs.push(this.emitUav(`RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`,\r\n            FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION));\r\n        uavs.push(this.emitUav(`RWBuffer<uint>`,\r\n            FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION));\r\n\r\n\r\n        return reflection;\r\n    }\r\n\r\n    emitPrerenderShader(fx: IPartFxInstruction, pass: IPartFxPassInstruction, i: number): ICSShaderReflection {\r\n        const prerenderFn = pass.prerenderRoutine.function;\r\n\r\n        const name = `CSParticlesPrerenderShader${i}`;\r\n        const numthreads = [64, 1, 1];\r\n        const uavs = [];\r\n\r\n        const reflection = <ICSShaderReflection>{ name, numthreads, uavs };\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);\r\n            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint PartId = DTid.x;`);\r\n                uavs.push(this.emitUav(`RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION));\r\n                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);\r\n                this.emitNewline();\r\n                this.emitLine(`[branch]`);\r\n                this.emitLine(`if(!Alive) return;`);\r\n                this.emitNewline();\r\n\r\n                this.emitFunction(prerenderFn);\r\n                const { typeName: partType } = this.resolveType(fx.particle);\r\n                uavs.push(this.emitUav(`RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION));\r\n                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);\r\n\r\n                const { typeName: prerenderedType } = this.resolveType(prerenderFn.def.params[1].type);\r\n\r\n                uavs.push(this.emitUav(`AppendStructuredBuffer<${prerenderedType}>`, `${FxTranslator.UAV_PRERENDERED}${i}`));\r\n\r\n                if (pass.instanceCount > 1) {\r\n                    this.emitLine(`for(int InstanceId = 0; InstanceId < ${pass.instanceCount}; InstanceId++)`);\r\n                    this.emitChar('{');\r\n                    this.push();\r\n                }\r\n\r\n                {\r\n                    this.emitLine(`${prerenderedType} Prerendered;`);\r\n                    if (prerenderFn.def.params.length == 3) {\r\n                        if (pass.instanceCount === 1) {\r\n                            this.emitLine(`int InstanceId = 0;`);\r\n                        }\r\n                        this.emitLine(`${prerenderFn.name}(Particle, Prerendered, InstanceId);`);\r\n                    } else {\r\n                        this.emitLine(`${prerenderFn.name}(Particle, Prerendered);`);\r\n                    }\r\n                    this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}.Append(Prerendered);`);\r\n                }\r\n\r\n                if (pass.instanceCount > 1) {\r\n                    this.pop();\r\n                    this.emitChar('}');\r\n                    this.emitNewline();\r\n                }\r\n\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n\r\n        return reflection;\r\n    }\r\n\r\n    emitSpawnOpContainer() {\r\n\r\n\r\n        const payloadSize = this.knownSpawnCtors.map(\r\n            // slice 1 or 2 depending on necessity of partID\r\n            ctor => ctor.def.params.slice(2).map(param => param.type.size).reduce((size, summ) => summ + size, 0))\r\n            .reduce((size, summ) => summ + size, 0);\r\n\r\n        const alignment = T_FLOAT4.size;\r\n        const numF4 = Math.ceil(payloadSize / alignment);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitLine(`struct ${FxTranslator.SPAWN_OPERATOR_TYPE}`);\r\n            this.emitChar(`{`);\r\n            this.push();\r\n            {\r\n                this.emitLine(`uint count;`);\r\n                this.emitLine(`uint type;`);\r\n\r\n                // this.emitLine(`uint _pad[2];`);\r\n                // emit padding?\r\n\r\n                if (numF4 > 0) {\r\n                    this.emitNewline();\r\n                    this.emitLine(`float4 payload[${numF4}];`);\r\n                }\r\n            }\r\n            this.pop();\r\n            this.emitChar(`}`);\r\n            this.emitChar(';');\r\n        }\r\n        // NOTE: emit as prologue!\r\n        this.end(true);\r\n    }\r\n\r\n    emitPartFxDecl(fx: IPartFxInstruction): IFxReflection {\r\n        const { name, capacity } = fx;\r\n\r\n        const CSParticlesSpawnRoutine = this.emitSpawnShader(fx);\r\n        const CSParticlesResetRoutine = this.emitResetShader(fx);\r\n        const CSParticlesUpdateRoutine = fx.updateRoutine && this.emitUpdateShader(fx);\r\n        const CSParticlesInitRoutine = fx.initRoutine && this.emitInitShader(fx);\r\n\r\n        const passes = fx.passList.map((pass, i) => {\r\n            const { prerenderRoutine, vertexShader, pixelShader } = pass;\r\n            let { sorting, geometry, instanceCount } = pass;\r\n            let VSParticleShader: string = null;\r\n            let PSParticleShader: string = null;\r\n            let CSParticlesPrerenderRoutine: ICSShaderReflection = null;\r\n\r\n            if (prerenderRoutine) {\r\n                CSParticlesPrerenderRoutine = this.emitPrerenderShader(fx, pass, i);\r\n            }\r\n\r\n            if (vertexShader) {\r\n                this.emitFunction(vertexShader);\r\n                VSParticleShader = vertexShader.name;\r\n            }\r\n\r\n            if (pixelShader) {\r\n                this.emitFunction(pixelShader);\r\n                PSParticleShader = pixelShader.name;\r\n            }\r\n\r\n            const { typeName: instance } = this.resolveType(pass.particleInstance);\r\n\r\n            return {\r\n                instance,\r\n                sorting,\r\n                geometry,\r\n                instanceCount,\r\n                VSParticleShader,\r\n                PSParticleShader,\r\n                CSParticlesPrerenderRoutine\r\n            };\r\n        });\r\n\r\n        this.emitSpawnOpContainer();\r\n\r\n        const { typeName: particle } = this.resolveType(fx.particle);\r\n\r\n        return {\r\n            name,\r\n            capacity,\r\n            particle,\r\n            passes,\r\n            CSParticlesSpawnRoutine,\r\n            CSParticlesResetRoutine,\r\n            CSParticlesInitRoutine,\r\n            CSParticlesUpdateRoutine\r\n        };\r\n    }\r\n}\r\n\r\nexport function translateFlat(fx: IPartFxInstruction): string {\r\n    const emitter = new FxTranslator();\r\n    const reflection = emitter.emitPartFxDecl(fx);\r\n    // console.log(JSON.stringify(reflection, null, '\\t'));\r\n    return emitter.toString();\r\n}\r\n","import { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, ISamplerStateBlockInstruction, IStmtBlockInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IWhileStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// TODO: move it to helpers\r\nexport function visitor(owner: IInstruction, cb: (instr: IInstruction, owner?: IInstruction) => void) {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n\r\n    const visit = (instr: IInstruction) => { \r\n        if (instr) {\r\n            cb(instr, owner); \r\n            visitor(instr, cb) \r\n        }\r\n    };\r\n\r\n    switch (owner.instructionType) {\r\n\r\n        //\r\n        // Stmt\r\n        //\r\n\r\n        case EInstructionTypes.k_ReturnStmt:\r\n            visit((owner as IReturnStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_DeclStmt:\r\n            (owner as IDeclStmtInstruction).declList.forEach(decl => visit(decl));\r\n            break;\r\n        case EInstructionTypes.k_ExprStmt:\r\n            visit((owner as IExprStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_IfStmt:\r\n            visit((owner as IIfStmtInstruction).cond);\r\n            visit((owner as IIfStmtInstruction).conseq);\r\n            visit((owner as IIfStmtInstruction).contrary);\r\n            break;\r\n        case EInstructionTypes.k_StmtBlock:\r\n            (owner as IStmtBlockInstruction).stmtList.forEach(stmt => visit(stmt));\r\n            break;\r\n        case EInstructionTypes.k_ForStmt:\r\n            visit((owner as IForStmtInstruction).init);\r\n            visit((owner as IForStmtInstruction).cond);\r\n            visit((owner as IForStmtInstruction).body);\r\n            visit((owner as IForStmtInstruction).step);\r\n            break;\r\n        case EInstructionTypes.k_WhileStmt:\r\n            visit((owner as IWhileStmtInstruction).cond);\r\n            visit((owner as IWhileStmtInstruction).body);\r\n            break;\r\n\r\n        //\r\n        // Expr\r\n        //\r\n\r\n        case EInstructionTypes.k_ArithmeticExpr:\r\n            visit((owner as IArithmeticExprInstruction).left);\r\n            visit((owner as IArithmeticExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_AssignmentExpr:\r\n            visit((owner as IAssignmentExprInstruction).left);\r\n            visit((owner as IAssignmentExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_CastExpr:\r\n            visit((owner as ICastExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_CompileExpr:\r\n            (owner as ICompileExprInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as ICompileExprInstruction).function);\r\n            break;\r\n        case EInstructionTypes.k_ComplexExpr:\r\n            visit((owner as IComplexExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_ConditionalExpr:\r\n            visit((owner as IConditionalExprInstruction).left);\r\n            visit((owner as IConditionalExprInstruction).right);\r\n            visit((owner as IConditionalExprInstruction).condition);\r\n            break;\r\n        case EInstructionTypes.k_ConstructorCallExpr:\r\n            (owner as IConstructorCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IConstructorCallInstruction).ctor);\r\n            break;\r\n        case EInstructionTypes.k_FunctionCallExpr:\r\n            (owner as IFunctionCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IFunctionCallInstruction).decl);\r\n            break;\r\n        case EInstructionTypes.k_IdExpr:\r\n            visit((owner as IIdExprInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_InitExpr:\r\n            (owner as IInitExprInstruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_IntExpr:\r\n        case EInstructionTypes.k_FloatExpr:\r\n        case EInstructionTypes.k_BoolExpr:\r\n        case EInstructionTypes.k_StringExpr:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_LogicalExpr:\r\n            visit((owner as ILogicalExprInstruction).left);\r\n            visit((owner as ILogicalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            visit((owner as IPostfixArithmeticInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_PostfixIndexExpr:\r\n            visit((owner as IPostfixIndexInstruction).element);\r\n            visit((owner as IPostfixIndexInstruction).index);\r\n            break;\r\n        case EInstructionTypes.k_PostfixPointExpr:\r\n            visit((owner as IPostfixPointInstruction).element);\r\n            visit((owner as IPostfixPointInstruction).postfix);\r\n            break;\r\n        case EInstructionTypes.k_RelationalExpr:\r\n            visit((owner as IRelationalExprInstruction).left);\r\n            visit((owner as IRelationalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_SamplerStateBlockExpr:\r\n            (owner as ISamplerStateBlockInstruction).params.forEach(param => visit(param));\r\n            visit((owner as ISamplerStateBlockInstruction).texture);\r\n            break;\r\n        case EInstructionTypes.k_UnaryExpr:\r\n            visit((owner as IUnaryExprInstruction).expr);\r\n            break;\r\n\r\n        //\r\n        // Others\r\n        //\r\n        case EInstructionTypes.k_ComplexType:\r\n            (owner as ITypeInstruction).fields.forEach(field => visit(field));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDef:\r\n            visit((owner as IFunctionDefInstruction).returnType);\r\n            visit((owner as IFunctionDefInstruction).id);\r\n            (owner as IFunctionDefInstruction).params.forEach(param => visit(param));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDecl:\r\n            visit((owner as IFunctionDeclInstruction).def);\r\n            visit((owner as IFunctionDeclInstruction).impl);\r\n            break;\r\n        case EInstructionTypes.k_VariableDecl:\r\n            visit((owner as IVariableDeclInstruction).type);\r\n            visit((owner as IVariableDeclInstruction).initExpr);\r\n            visit((owner as IVariableDeclInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_VariableType:\r\n            visit((owner as IVariableTypeInstruction).subType);\r\n            break;\r\n        case EInstructionTypes.k_Id:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_SystemFunctionDecl:\r\n        case EInstructionTypes.k_SystemType:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_BreakStmt:\r\n            break;\r\n\r\n        default:\r\n            console.error('unsupported instruction type found');\r\n    }\r\n}\r\n\r\nexport const Visitor = {\r\n    each: visitor\r\n};\r\n\r\n","import { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport enum EInstructionTypes {\r\n    k_Instruction = 0,\r\n    \r\n    k_Id,\r\n    k_Provide,\r\n    k_Collector,\r\n    k_Keyword,      // FIXME: useless type\r\n    k_Simple,       // FIXME: useless type\r\n    k_SamplerState,\r\n    k_Attribute,\r\n    k_Annotation,   // FIXME: instruction is not fully implemented\r\n    k_UsageType,    // FIXME: instruction is not implemented\r\n    \r\n    k_Typed,        // NOTE: Abstract type\r\n    k_VariableType,\r\n    k_SystemType,\r\n    k_ComplexType,\r\n    k_ProxyType,\r\n    \r\n    k_Expr,         // NOTE: Abstract type\r\n    k_IdExpr,\r\n    k_IntExpr,\r\n    k_FloatExpr,\r\n    k_BoolExpr,\r\n    k_StringExpr,\r\n    k_ArithmeticExpr,\r\n    k_AssignmentExpr,\r\n    k_RelationalExpr,\r\n    k_LogicalExpr,\r\n    k_ConditionalExpr,\r\n    k_CastExpr,\r\n    k_UnaryExpr,\r\n    k_PostfixIndexExpr,\r\n    k_PostfixPointExpr,\r\n    k_PostfixArithmeticExpr,\r\n    k_ComplexExpr,\r\n    k_FunctionCallExpr,\r\n    k_ConstructorCallExpr,\r\n    k_CompileExpr,\r\n    k_InitExpr,\r\n    k_SamplerStateBlockExpr,\r\n\r\n    k_Decl,\r\n    k_TypeDecl,\r\n    k_VariableDecl,\r\n    k_StructDecl,\r\n    k_FunctionDecl,\r\n    k_SystemFunctionDecl,\r\n    k_FunctionDef,\r\n    k_PassDecl,\r\n    k_TechniqueDecl,\r\n    \r\n    k_Stmt,\r\n    k_ExprStmt,\r\n    k_BreakStmt,\r\n    k_WhileStmt,\r\n    k_ForStmt,\r\n    k_IfStmt,\r\n    k_DeclStmt,\r\n    k_ReturnStmt,\r\n    k_SemicolonStmt,\r\n    k_StmtBlock,\r\n    \r\n    // part fx\r\n    k_PartFxDecl,\r\n    k_PartFxPass,\r\n    k_SpawnStmt\r\n}\r\n\r\n\r\nexport enum ECheckStage {\r\n    CODE_TARGET_SUPPORT, /* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */\r\n    SELF_CONTAINED /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */\r\n    // VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ \r\n}\r\n\r\nexport enum EVarUsedMode {\r\n    k_Read,\r\n    k_Write,\r\n    k_ReadWrite,\r\n    k_Undefined,\r\n    k_Default = k_ReadWrite\r\n}\r\n\r\n\r\nexport interface IInstructionError {\r\n    code: number;\r\n    info: any;\r\n}\r\n\r\nexport interface ITypeUseInfoContainer {\r\n    type: IVariableTypeInstruction;\r\n    isRead: boolean;\r\n    isWrite: boolean;\r\n    numRead: number;\r\n    numWrite: number;\r\n    numUsed: number;\r\n}\r\n\r\nexport enum EExtractExprType {\r\n    k_Header,\r\n\r\n    k_Float,\r\n    k_Int,\r\n    k_Bool,\r\n\r\n    k_Float2,\r\n    k_Int2,\r\n    k_Bool2,\r\n\r\n    k_Float3,\r\n    k_Int3,\r\n    k_Bool3,\r\n\r\n    k_Float4,\r\n    k_Int4,\r\n    k_Bool4,\r\n\r\n    k_Float4x4\r\n}\r\n\r\n\r\nexport enum EScopeType {\r\n    k_System,\r\n    k_Global,\r\n    k_Default,\r\n    k_Struct,\r\n    k_Annotation\r\n}\r\n\r\n\r\nexport interface ITypeTemplate {\r\n    readonly scope: IScope;\r\n    readonly name: string;\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction;\r\n    typeName(args?: ITypeInstruction[]): string;\r\n}\r\n\r\n\r\nexport interface IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    \r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n\r\n    /** Recursive check for all parents for strict mode */\r\n    isStrict(): boolean;\r\n\r\n    findVariable(variableName: string): IVariableDeclInstruction;\r\n    findType(typeName: string): ITypeInstruction;\r\n    findTypeTemplate(typeName: string): ITypeTemplate;\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction | null | undefined;\r\n    findTechnique(techName: string): ITechniqueInstruction | null;\r\n\r\n    /** @deprecated */\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction;\r\n\r\n    addVariable(variable: IVariableDeclInstruction): boolean;\r\n    addType(type: ITypeInstruction): boolean;\r\n    addTypeTemplate(template: ITypeTemplate): boolean;\r\n    addFunction(func: IFunctionDeclInstruction): boolean;\r\n    addTechnique(technique: ITechniqueInstruction): boolean;\r\n}\r\n\r\n\r\n/**\r\n * All opertion are represented by: \r\n * operator : arg1 ... argn\r\n * Operator and instructions may be empty.\r\n */\r\nexport interface IInstruction {\r\n    readonly parent: IInstruction;\r\n    readonly scope: IScope;\r\n\r\n    readonly sourceNode: IParseNode | null;\r\n    readonly instructionType: EInstructionTypes;\r\n    readonly instructionID: number;\r\n    readonly instructionName: string;\r\n\r\n    toString(): string;\r\n    toCode(): string;\r\n\r\n    /** Internal API */\r\n    $withParent<T extends IInstruction>(parent: IInstruction): T;\r\n    $withNoParent<T extends IInstruction>(): T;\r\n\r\n    /** @deprecated */\r\n    _check(eStage: ECheckStage): boolean;\r\n    /** @deprecated */\r\n    _getLastError(): IInstructionError;\r\n    /** @deprecated */\r\n    _setError(eCode: number, pInfo?: any): void;\r\n    /** @deprecated */\r\n    _clearError(): void;\r\n    /** @deprecated */\r\n    _isErrorOccured(): boolean;\r\n}\r\n\r\n\r\nexport interface IInstructionCollector extends IInstruction {\r\n    readonly instructions: IInstruction[];\r\n}\r\n\r\n\r\nexport interface ISimpleInstruction extends IInstruction {\r\n    readonly value: string;\r\n}\r\n\r\n\r\nexport interface IProvideInstruction extends IInstruction {\r\n    readonly moduleName: string;\r\n}\r\n\r\n\r\n\r\nexport interface ITypeInstruction extends IInstruction {\r\n    readonly size: number;\r\n    readonly name: string;\r\n    readonly baseType: ITypeInstruction;\r\n    readonly length: number;\r\n    readonly arrayElementType: ITypeInstruction;\r\n\r\n    readonly writable: boolean;\r\n    readonly readable: boolean;\r\n\r\n    readonly fieldNames: string[];\r\n    readonly fields: IVariableDeclInstruction[];\r\n    readonly methods: IFunctionDeclInstruction[];\r\n\r\n    /** \r\n     * @deprecated\r\n     * Use type.equals() instead.\r\n     */\r\n    isEqual(type: ITypeInstruction): boolean;\r\n\r\n    isBase(): boolean;\r\n    isArray(): boolean;\r\n    // Returns true is type is user defined array.\r\n    // an user defined array like: float f[4]\r\n    // not: float4 \r\n    isNotBaseArray(): boolean;\r\n    isComplex(): boolean;\r\n    isConst(): boolean;\r\n\r\n    /** @deprecated */\r\n    isContainArray(): boolean;\r\n    /** @deprecated */\r\n    isContainSampler(): boolean;\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean;\r\n\r\n    hasField(fieldName: string): boolean;\r\n    hasFieldWithSematics(semantic: string);\r\n    hasAllUniqueSemantics(): boolean;\r\n    hasFieldWithoutSemantics(): boolean;\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction;\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction;\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    getMethod(methodName: string, args?: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction;\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string;\r\n\r\n\r\n    isUAV(): boolean;\r\n    isSampler(): boolean;\r\n    isTexture(): boolean;\r\n}\r\n\r\n\r\nexport type IVariableUsage = 'uniform' | 'const' | 'in' | 'out' | 'inout';\r\n\r\nexport interface IVariableTypeInstruction extends ITypeInstruction {\r\n    readonly usages: IVariableUsage[];\r\n    readonly subType: ITypeInstruction;\r\n    readonly padding: number;\r\n\r\n    isUniform(): boolean;\r\n\r\n    hasUsage(usageName: IVariableUsage): boolean;\r\n\r\n    // for structures internal usage\r\n    $overwritePadding(val: number): void;\r\n}\r\n\r\n\r\nexport interface ITypedInstruction extends IInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface IConditionalExprInstruction extends IExprInstruction {\r\n    readonly condition: IExprInstruction;\r\n    readonly left: ITypedInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IDeclInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly semantic: string;\r\n    readonly annotation: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionDefInstruction extends IDeclInstruction {\r\n    readonly returnType: IVariableTypeInstruction;\r\n    readonly name: string;\r\n    readonly params: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface ITypeDeclInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface ISamplerStateInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly value: IInstruction;\r\n}\r\n\r\n\r\nexport interface IVariableDeclInstruction extends IDeclInstruction, ITypedInstruction {\r\n    readonly id: IIdInstruction;\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly initExpr: IInitExprInstruction;\r\n\r\n    readonly defaultValue: any;\r\n\r\n    isParameter(): boolean;\r\n    isLocal(): boolean;\r\n    isGlobal(): boolean;\r\n    isField(): boolean;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclInstruction extends IDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStructDeclInstruction extends IInstruction {\r\n\r\n}\r\n\r\n\r\nexport interface IIdInstruction extends IInstruction {\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface IKeywordInstruction extends IInstruction {\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface IExprInstruction extends ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean;\r\n    /** @deprecated */\r\n    getEvalValue(): any;\r\n\r\n    isConst(): boolean;\r\n    isConstExpr(): boolean;\r\n}\r\n\r\nexport type ILogicalOperator = \"&&\" | \"||\";\r\n\r\nexport interface ILogicalExprInstruction extends IExprInstruction {\r\n    operator: ILogicalOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IUnaryOperator = \"+\" | \"-\" | \"!\" | \"++\" | \"--\";\r\n\r\nexport interface IUnaryExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: IUnaryOperator;\r\n}\r\n\r\nexport interface IPostfixPointInstruction extends IExprInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixIndexInstruction extends IExprInstruction {\r\n    readonly index: IExprInstruction;\r\n    readonly element: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IConstructorCallInstruction extends IExprInstruction {\r\n    readonly args: IInstruction[];\r\n    readonly ctor: IVariableTypeInstruction;\r\n}\r\n\r\nexport interface IArithmeticExprInstruction extends IExprInstruction {\r\n    readonly right: IExprInstruction;\r\n    readonly left: IExprInstruction;\r\n    readonly operator: '+' | '-' | '/' | '*' | '%';\r\n}\r\n\r\nexport interface ICastExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    isUseless(): boolean;\r\n}\r\n\r\n\r\nexport interface IComplexExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixArithmeticInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\n\r\nexport interface ISamplerStateBlockInstruction extends IExprInstruction {\r\n    readonly texture: IVariableDeclInstruction;\r\n    readonly params: ISamplerStateInstruction[];\r\n    readonly operator: string;\r\n}\r\n\r\n\r\nexport interface ICompileExprInstruction extends IExprInstruction {\r\n    readonly function: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\n\r\nexport interface IRelationalExprInstruction extends IExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\nexport interface IAssignmentExprInstruction extends IExprInstruction {\r\n    readonly operator: string;\r\n    readonly left: IExprInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IInitExprInstruction extends IExprInstruction {\r\n    readonly args: IExprInstruction[];\r\n\r\n    isArray(): boolean;\r\n    isConst(): boolean;\r\n\r\n    // todo: refactor this!!\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean;\r\n}\r\n\r\n\r\nexport interface IIdExprInstruction extends IExprInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    /** @helpers */\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionCallInstruction extends IExprInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // move it to method?\r\n    readonly decl: IFunctionDeclInstruction;   \r\n}\r\n\r\n\r\nexport interface ILiteralInstruction<T = number | boolean | string> extends IExprInstruction {\r\n    readonly value: T;\r\n}\r\n\r\n\r\nexport type IExprDerived =\r\n    | IArithmeticExprInstruction\r\n    | IAssignmentExprInstruction\r\n    | ICastExprInstruction\r\n    | ICompileExprInstruction\r\n    | IComplexExprInstruction\r\n    | IConditionalExprInstruction\r\n    | IConstructorCallInstruction\r\n    | IFunctionCallInstruction\r\n    | IIdExprInstruction\r\n    | IInitExprInstruction\r\n    | ILiteralInstruction<number>\r\n    | ILiteralInstruction<boolean>\r\n    | ILiteralInstruction<string>\r\n    | ILogicalExprInstruction\r\n    | IPostfixArithmeticInstruction\r\n    | IPostfixIndexInstruction\r\n    | IPostfixPointInstruction\r\n    | IRelationalExprInstruction\r\n    | ISamplerStateBlockInstruction\r\n    | IUnaryExprInstruction;\r\n\r\nexport interface IAnnotationInstruction extends IInstruction {\r\n}\r\n\r\n\r\nexport interface IStmtInstruction extends IInstruction {\r\n}\r\n\r\nexport interface IAttributeInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n}\r\n\r\nexport interface IForStmtInstruction extends IStmtInstruction {\r\n    readonly init: ITypedInstruction;\r\n    readonly cond: IExprInstruction;\r\n    readonly step: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n}\r\n\r\nexport type IDoWhileOperator = \"do\" | \"while\";\r\n\r\nexport interface IWhileStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n    readonly operator: IDoWhileOperator;\r\n}\r\n\r\nexport interface IDeclStmtInstruction extends IStmtInstruction {\r\n    readonly declList: IDeclInstruction[];\r\n}\r\n\r\nexport type IReturnOperator = \"return\";\r\n\r\nexport interface IReturnStmtInstruction extends IStmtInstruction {\r\n    readonly operator: IReturnOperator;\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\nexport interface IIfStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtBlockInstruction extends IStmtInstruction {\r\n    readonly stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n\r\nexport interface IExprStmtInstruction extends IStmtInstruction {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n\r\nexport interface IPassInstruction extends IDeclInstruction {\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly vertexShader: IFunctionDeclInstruction;\r\n    readonly pixelShader: IFunctionDeclInstruction;\r\n\r\n    readonly renderStates: IMap<ERenderStateValues>;\r\n    getState(type: ERenderStates): ERenderStateValues;\r\n}\r\n\r\n\r\nexport type IStmtDerived =\r\n    | IDeclStmtInstruction\r\n    | IReturnStmtInstruction\r\n    | IIfStmtInstruction\r\n    | IStmtBlockInstruction\r\n    | IExprStmtInstruction\r\n    | IWhileStmtInstruction\r\n    | IForStmtInstruction;\r\n\r\n\r\nexport enum ETechniqueType {\r\n    k_BasicFx,  // << basic Microsoft DirectX like effect\r\n    k_PartFx,\r\n    k_Unknown\r\n}\r\n\r\nexport interface ITechniqueInstruction extends IDeclInstruction {\r\n    readonly passList: IPassInstruction[];\r\n    readonly type: ETechniqueType;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclListMap {\r\n    [functionName: string]: IFunctionDeclInstruction[];\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IConstructorCallInstruction, IExprInstruction, IInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConstructorCallInstructionSettings extends IInstructionSettings {\r\n    ctor: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Resresnt ctor(arg1,..., argn)\r\n * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class ConstructorCallInstruction extends ExprInstruction implements IConstructorCallInstruction {\r\n    protected _args: IInstruction[];\r\n    protected _ctor: IVariableTypeInstruction;\r\n    \r\n\r\n    constructor({ ctor, args = null, ...settings }: IConstructorCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });\r\n\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this._ctor = Instruction.$withParent(ctor, this);\r\n    }\r\n\r\n    \r\n    get args() : IInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n    \r\n    get ctor(): IVariableTypeInstruction {\r\n        return this._ctor;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n\r\n        code += this.ctor.toCode();\r\n        code += \"(\";\r\n\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            if (!(<IExprInstruction>this.args[i]).isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        if (!this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        var res: any = null;\r\n        var jsTypeCtor: any = SystemScope.getExternalType(this.type);\r\n        var args: any[] = new Array(this.args.length);\r\n\r\n        if (isNull(jsTypeCtor)) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            if (SystemScope.isScalarType(this.type)) {\r\n                var pTestedInstruction: IExprInstruction = <IExprInstruction>this.args[0];\r\n                if (this.args.length > 1 || !pTestedInstruction.evaluate()) {\r\n                    return false;\r\n                }\r\n\r\n                res = jsTypeCtor(pTestedInstruction.getEvalValue());\r\n            }\r\n            else {\r\n                for (var i: number = 0; i < this.args.length; i++) {\r\n                    var pTestedInstruction: IExprInstruction = <IExprInstruction>this.args[i];\r\n\r\n                    if (pTestedInstruction.evaluate()) {\r\n                        args[i - 1] = pTestedInstruction.getEvalValue();\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                res = new jsTypeCtor;\r\n                res.set.apply(res, args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, ExpectedSymbols, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { State } from \"./State\";\r\nimport { END_POSITION, T_EMPTY } from \"./symbols\";\r\n\r\nexport class Item {\r\n    rule: IRule;\r\n    /**\r\n     * Position in item. \r\n     * left: right0,   right1, ...., rightN;\r\n     *               ^\r\n     *               position\r\n     */\r\n    pos: number;\r\n    /**\r\n     * Index in parser.\r\n     * (Uniq ID)\r\n     */\r\n    index: number;\r\n\r\n    expectedSymbols: ExpectedSymbols;\r\n\r\n    constructor(rule: IRule, pos: number, expectedSymbols?: string[]) {\r\n        this.rule = rule;\r\n        this.pos = pos;\r\n        this.index = 0;\r\n        this.expectedSymbols = new Set<string>();\r\n\r\n        if (expectedSymbols) {\r\n            expectedSymbols.forEach(symbol => this.addExpected(symbol));\r\n        }\r\n    }\r\n\r\n    isEqual(item: Item, type: EParserType = EParserType.k_LR0): boolean {\r\n        if (type === EParserType.k_LR0) {\r\n            return (this.rule === item.rule && this.pos === item.pos);\r\n        } \r\n        \r\n        if (type === EParserType.k_LR1) {\r\n            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {\r\n                return false;\r\n            }\r\n\r\n            for (const symbol of this.expectedSymbols) {\r\n                if (!item.isExpected(symbol)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } \r\n\r\n        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.\r\n        return false;\r\n    }\r\n\r\n    isParentItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos + 1);\r\n    }\r\n\r\n    isChildItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos - 1);\r\n    }\r\n\r\n    symbolName(): string {\r\n        const right = this.rule.right;\r\n        if (this.pos === right.length) {\r\n            return END_POSITION;\r\n        }\r\n        return right[this.pos];\r\n    }\r\n\r\n    // lastSymbolName(): string {\r\n    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;\r\n    // }\r\n\r\n    // // get next symbol name\r\n    // nextSymbolName(): string {\r\n    //     return this.rule.right[this.pos + 1] || END_POSITION;\r\n    // }\r\n\r\n    isExpected(symbol: string): boolean {\r\n        return this.expectedSymbols.has(symbol);\r\n    }\r\n\r\n    addExpected(symbol: string): boolean {\r\n        if (this.isExpected(symbol)) {\r\n            return false;\r\n        }\r\n        this.expectedSymbols.add(symbol);\r\n        return true;\r\n    }\r\n\r\n    toString(grammarSymbols: Map<string, string> = null): string {\r\n        const { left, right } = this.rule;\r\n\r\n        let msg = `${left} -> `;\r\n\r\n        msg += right\r\n            .map(s => Item.decodeSymbol(s, grammarSymbols))\r\n            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))\r\n            .join(' ');\r\n\r\n        if (this.pos === right.length) {\r\n            msg += \" . \";\r\n        }\r\n\r\n        if (this.expectedSymbols) {\r\n            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));\r\n\r\n            if (expectedTokens.length) {\r\n                msg += \", \" + expectedTokens.join(' ');\r\n            }\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    static decodeSymbol(s: string, grammarSymbols: Map<string, string>) {\r\n        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { CBUFFER0_REGISTER } from \"./Bytecode\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\n\r\nexport class ConstantPoolMemory {\r\n    byteArray: Uint8Array;\r\n    byteLength: number;\r\n\r\n    constructor() {\r\n        this.byteArray = new Uint8Array(4);\r\n        this.byteLength = 0;\r\n    }\r\n\r\n    get byteCapacity(): number {\r\n        return this.byteArray.byteLength;\r\n    }\r\n\r\n    /** Check capacity and make realloc if needed. */\r\n    private check(byteSize: number) {\r\n        let expected = this.byteLength + byteSize;\r\n        if (expected <= this.byteCapacity) {\r\n            return;\r\n        }\r\n        var oldBuffer = this.byteArray;\r\n        var newBuffer = new Uint8Array(Math.max(expected, this.byteCapacity * 2));\r\n        newBuffer.set(oldBuffer);\r\n\r\n        this.byteArray = newBuffer;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param size Size in bytes.\r\n     */\r\n    addUniform(size: number, name: string) {\r\n        this.check(size);\r\n        this.byteLength += size;\r\n    }\r\n}\r\n\r\nexport interface IConstantReflection {\r\n    name: string;\r\n    size: number;\r\n    offset: number;\r\n    semantic: string;\r\n    type: string;\r\n}\r\n\r\nexport class ConstanPool {\r\n    protected _data: ConstantPoolMemory = new ConstantPoolMemory;\r\n    protected _knownConstants: IConstantReflection[] = [];\r\n\r\n    deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        assert(decl.isGlobal() && decl.type.isUniform());\r\n        const { name, semantic, initExpr, type: { size } } = decl;\r\n\r\n        let reflection = this._knownConstants.find(c => c.name === name);\r\n        if (!reflection) {\r\n            let addr = null;\r\n            if (isNull(initExpr)) {\r\n                // TODO: add type to description\r\n                addr = this.addUniform(size, `${name}${semantic? `:${semantic}`: '' }`);\r\n            } else {\r\n                assert(false, 'unsupported');\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            const { addr: offset } = addr;\r\n            const type = decl.type.name; // TODO: use signature?\r\n\r\n            reflection = {\r\n                name,\r\n                semantic,\r\n                offset,\r\n                size,\r\n                type\r\n            };\r\n\r\n            this._knownConstants.push(reflection);\r\n        }\r\n\r\n        // NOTE: we return copy because adress will be loaded\r\n        return new PromisedAddress({\r\n            type: EAddrType.k_Input,\r\n            inputIndex: CBUFFER0_REGISTER,\r\n            addr: reflection.offset,\r\n            size\r\n        });\r\n    }\r\n\r\n\r\n    private addUniform(size: number, desc: string): PromisedAddress {\r\n        const addr = this._data.byteLength;\r\n        this._data.addUniform(size, desc);\r\n\r\n        return new PromisedAddress({\r\n            type: EAddrType.k_Input,\r\n            inputIndex: CBUFFER0_REGISTER,\r\n            addr,\r\n            size\r\n        });\r\n    }\r\n\r\n    get data(): ConstantPoolMemory {\r\n        return this._data;\r\n    }\r\n\r\n    get size(): number {\r\n        return this._data.byteLength;\r\n    }\r\n\r\n    dump(): IConstantReflection[] {\r\n        return this._knownConstants;\r\n    }\r\n}\r\n\r\n\r\nexport default ConstanPool;\r\n","import { T_BOOL, SCOPE } from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IUnaryExprInstruction, IUnaryOperator } from '@lib/idl/IInstruction';\r\n\r\nimport { ExprInstruction } from './ExprInstruction';\r\nimport { IInstructionSettings, Instruction } from './Instruction';\r\nimport { VariableTypeInstruction } from './VariableTypeInstruction';\r\n\r\nexport interface IUnaryExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: IUnaryOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent + - ! ++ -- expr\r\n * (+|-|!|++|--|) Instruction\r\n */\r\nexport class UnaryExprInstruction extends ExprInstruction implements IUnaryExprInstruction {\r\n    protected _operator: IUnaryOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, operator, ...settings }: IUnaryExprInstructionSettings) {\r\n        super({\r\n            instrType: EInstructionTypes.k_UnaryExpr,\r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: operator === '!'\r\n                ? VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE)\r\n                : expr.type,\r\n            ...settings\r\n        });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): IUnaryOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = '';\r\n        sCode += this.operator;\r\n        sCode += this.expr.toCode();\r\n\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n\r\n\r\n    evaluate(): boolean {\r\n        var op = this.operator;\r\n        var expr = <IExprInstruction>this.expr;\r\n\r\n        if (!expr.evaluate()) {\r\n            return false;\r\n        }\r\n\r\n        var res: any = null;\r\n\r\n        try {\r\n            res = expr.getEvalValue();\r\n            switch (op) {\r\n                case '+':\r\n                    res = +res;\r\n                    break;\r\n                case '-':\r\n                    res = -res;\r\n                    break;\r\n                case '!':\r\n                    res = !res;\r\n                    break;\r\n                case '++':\r\n                    res = ++res;\r\n                    break;\r\n                case '--':\r\n                    res = --res;\r\n                    break;\r\n            }\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EScopeType, IFunctionDeclInstruction, IScope, ITechniqueInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { fn, type } from \"./helpers\";\r\n\r\nexport interface IScopeSettings {\r\n    type?: EScopeType;\r\n    parent?: IScope;\r\n    strictMode?: boolean;\r\n}\r\n\r\n\r\n\r\nexport class Scope implements IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n\r\n    constructor({ type = EScopeType.k_Default, parent = null, strictMode = false }: IScopeSettings) {\r\n        this.type = type;\r\n        this.parent = parent;\r\n        this.strictMode = strictMode;\r\n\r\n        this.variables = {};\r\n        this.types = {};\r\n        this.functions = {};\r\n        this.techniques = {};\r\n        this.typeTemplates = {};\r\n    }\r\n\r\n\r\n    isStrict(): boolean {\r\n        return this.filter(scope => scope.strictMode);\r\n    }\r\n\r\n\r\n    findVariable(varName: string): IVariableDeclInstruction {\r\n        return this.filter(scope => scope.variables[varName] || null);\r\n    }\r\n\r\n\r\n    findTypeTemplate(typeName: string): ITypeTemplate {\r\n        return this.filter(scope => scope.typeTemplates[typeName] || null);\r\n    }\r\n\r\n\r\n    findType(typeName: string): ITypeInstruction {\r\n        return this.filter(scope => scope.types[typeName] || null);\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp> = null): IFunctionDeclInstruction | null | undefined {\r\n        return this.filter(scope => fn.matchList(scope.functions[funcName], args))\r\n    }\r\n\r\n\r\n    findTechnique(techName: string): ITechniqueInstruction {\r\n        return this.filter(scope => scope.techniques[techName] || null);\r\n    }\r\n\r\n\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction {\r\n        let res = fn.matchList(this.functions[func.name], func.def.params.map(param => param? param.type : null));\r\n        assert(res !== undefined);\r\n        return res;\r\n    }\r\n\r\n    \r\n    addVariable(variable: IVariableDeclInstruction): boolean {\r\n        let variableMap = this.variables;\r\n        let varName = variable.name;\r\n\r\n        if (!this.variables[varName]) {\r\n            variableMap[varName] = variable;\r\n            assert(variable.scope === this);\r\n        }\r\n        else {\r\n            // console.error(`letiable '${varName}' already exists in scope:`, this);\r\n            return false;\r\n        }\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeTemplate(template: ITypeTemplate): boolean {\r\n        if (isDefAndNotNull(this.typeTemplates[template.name])) {\r\n            return false;\r\n        }\r\n\r\n        this.typeTemplates[template.name] = template;\r\n        return true;\r\n    }\r\n\r\n    // todo: remove scopeId from argumts, use type.scope instead.\r\n    addType(type: ITypeInstruction): boolean {\r\n        if (this.types[type.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.types[type.name] = type;\r\n        console.assert(type.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addFunction(func: IFunctionDeclInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n        assert(func.scope === this);\r\n\r\n        let funcMap = this.functions;\r\n        let funcName = func.name;\r\n\r\n        funcMap[funcName] = funcMap[funcName] || [];\r\n        const funcOverloads = funcMap[funcName];\r\n\r\n        let targetFunc = this.findFunctionInScope(func);\r\n\r\n        if (!targetFunc) {\r\n            funcOverloads.push(func);\r\n        } else {\r\n            assert(!isNull(func.impl));\r\n            assert(isNull(targetFunc.impl));\r\n            let i = funcOverloads.indexOf(targetFunc);\r\n            funcOverloads[i] = func;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique(technique: ITechniqueInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques[technique.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques[technique.name] = technique;\r\n        assert(technique.scope === this);\r\n        return false;\r\n    }\r\n\r\n    private filter<T>(cb: (scope: IScope) => T | null): T \r\n    {\r\n        let scope: IScope = this;\r\n        while (!isNull(scope)) {\r\n            let res = cb(scope);\r\n            if (!isNull(res)) {\r\n                return res;\r\n            }\r\n            scope = scope.parent;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class ProgramScope {\r\n    globalScope: IScope;\r\n    currentScope: IScope;\r\n\r\n\r\n    constructor(parent: IScope) {\r\n        assert(parent !== null);\r\n        let type = EScopeType.k_Global;\r\n        this.globalScope = new Scope({ parent, type });\r\n        this.currentScope = this.globalScope;\r\n    }\r\n\r\n\r\n    validate(): void {\r\n        assert(this.currentScope === this.globalScope);\r\n    }\r\n\r\n\r\n    push(type: EScopeType = EScopeType.k_Default): void {\r\n        assert(this.currentScope !== null);\r\n        assert(type >= EScopeType.k_Default);\r\n\r\n        let parent = this.currentScope;\r\n        let scope = new Scope({ parent, type });\r\n\r\n        this.currentScope = scope;\r\n    }\r\n\r\n\r\n    pop(): void {\r\n        assert(this.currentScope !== null);\r\n        this.currentScope = this.currentScope.parent;\r\n        assert(this.currentScope !== null);\r\n    }\r\n}\r\n","export { default as ASTView } from './ASTView';\r\nexport { default as ProgramView } from './ProgramView';\r\nexport { default as FileListView } from './FileListView';\r\nexport { default as MemoryView } from './MemoryView';\r\n\r\n\r\n// temp definition for react-jss compatibility\r\nexport interface IWithStyles<T> {\r\n    classes?: {\r\n        [P in keyof T]: string;\r\n    }\r\n};\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport * as Bytecode from '@lib/fx/bytecode/Bytecode';\r\nimport sizeof from \"@lib/fx/bytecode/sizeof\";\r\n\r\nexport function createUAV(name: string, elementSize: number, length: number, register: number) {\r\n    const counterSize = sizeof.i32();\r\n    const size = counterSize + length * elementSize; // in bytes\r\n    assert(size % sizeof.i32() === 0);\r\n\r\n    const buffer = new Int32Array(size >> 2);\r\n    const data = buffer.subarray(counterSize >> 2);\r\n    const counter = new Int32Array(buffer.buffer, buffer.byteOffset, 1);\r\n    const index = Bytecode.UAV0_REGISTER + register;\r\n\r\n    function overwriteCounter(value: number) {\r\n        counter[0] = value;\r\n    }\r\n\r\n    function readCounter(): number {\r\n        return counter[0];\r\n    }\r\n\r\n    function readElement(iElement: number): Uint8Array {\r\n        return new Uint8Array(data.buffer, data.byteOffset + iElement * elementSize, elementSize);\r\n    }\r\n\r\n    overwriteCounter(0);\r\n\r\n    return {\r\n        name,\r\n        readElement,\r\n        readCounter,\r\n        overwriteCounter,\r\n        // byte length of a single element\r\n        elementSize,\r\n        // number of elements\r\n        length, \r\n        // register specified in the shader\r\n        register,\r\n\r\n        // [ elements ]\r\n        data,\r\n\r\n        // raw data [ counter, ...elements ]\r\n        buffer,\r\n        // input index for VM\r\n        index\r\n    };\r\n}\r\n","import { LOCATION_PATTERN, PATH_PARAMS_TYPE } from '@sandbox/logic';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { matchPath } from 'react-router';\r\nimport { combineReducers } from 'redux';\r\n\r\nimport parserParams from './parserParams';\r\nimport router from './router';\r\nimport sourceFile from './sourceFile';\r\n\r\n/**\r\n * selectors\r\n */\r\n\r\n// most common selector;\r\n// markers are very expensive for react update :/\r\nexport const getCommon = (state: IStoreState): IStoreState => state;\r\n// ({ ...state, sourceFile: { ...state.sourceFile, markers: null } });\r\n\r\nexport const getLocation = (state: IStoreState): string => state.router.location.pathname;\r\nexport const matchLocation = (state: IStoreState) =>\r\n    matchPath<PATH_PARAMS_TYPE>(getLocation(state), { path: LOCATION_PATTERN, exact: false });\r\n\r\n// helper function in order to get proper props from state using custom selector;\r\nexport function mapProps<T extends { (state: IStoreState): any; }>(selector: T): (state: IStoreState) => ReturnType<T> {\r\n    return (state) => selector(state);\r\n}\r\n\r\nexport default combineReducers<IStoreState>({ sourceFile, parserParams, router });","import { assert, isBoolean, isNull, isNumber, PropertiesDiff } from \"@lib/common\";\r\nimport { expression, instruction, type, variable } from \"@lib/fx/analisys/helpers\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EInstructionTypes, IAnnotationInstruction, ICompileExprInstruction, IDeclInstruction, IExprInstruction, IFunctionDeclInstruction, IIdInstruction, IInstruction, IInstructionCollector, IPassInstruction, IStmtInstruction, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { EPartFxPassGeometry, IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { Analyzer, Context, ICompileValidator } from \"./Analyzer\";\r\nimport { IdInstruction } from \"./instructions/IdInstruction\";\r\nimport { PartFxInstruction } from \"./instructions/part/PartFxInstruction\";\r\nimport { PartFxPassInstruction } from \"./instructions/part/PartFxPassInstruction\";\r\nimport { SpawnInstruction } from \"./instructions/part/SpawnInstruction\";\r\nimport { ProgramScope } from \"./ProgramScope\";\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_UINT, T_VOID } from \"./SystemScope\";\r\n\r\ntype IPartFxPassProperties = PropertiesDiff<IPartFxPassInstruction, IPassInstruction>;\r\n// type is internal property which is always ETechniqueType.k_PartFx for particle fx's,\r\n// so we can omit it.\r\ntype IPartFxProperties = Omit<PropertiesDiff<IPartFxInstruction, IDeclInstruction>, \"type\">;\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\nclass FxContext extends Context {\r\n    /** Main particle structure type describing particle's simulation. */\r\n    particleCore: ITypeInstruction;\r\n    /** Particle instance structure type which describe per pass render instance of the particle. */\r\n    particleInstance: ITypeInstruction;\r\n\r\n    spawnStmts: SpawnInstruction[] = [];\r\n\r\n    // beginFunc(): void {\r\n    //     super.beginFunc();\r\n    // }\r\n\r\n    // endFunc(): void {\r\n    //     super.endFunc();\r\n    // }\r\n\r\n    beginPartFxPass(): void {\r\n        this.beginPass();\r\n        this.particleInstance = null;\r\n    }\r\n\r\n    endPartFxPass(): void {\r\n        this.particleInstance = null;\r\n        this.endPass();\r\n    }\r\n\r\n    beginPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n\r\n    endPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n}\r\n\r\n\r\nfunction sliceNode(source: IParseNode, from: number, to?: number): IParseNode {\r\n    const { children, parent, name, value, loc } = source;\r\n    return {\r\n        children: children.slice(from, to),\r\n        parent,\r\n        name,\r\n        value,\r\n        loc\r\n    };\r\n}\r\n\r\n\r\nexport class FxAnalyzer extends Analyzer {\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'Init'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_SPAWN = 'spawn'\r\n     */\r\n    protected analyzeSpawnStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const count = Number(children.slice(-3, -2)[0].value);\r\n        const name = children.slice(-5, -4)[0].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 7; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        const spawnStmt = new SpawnInstruction({ sourceNode, scope, name, args, count });\r\n        context.spawnStmts.push(spawnStmt);\r\n\r\n        return spawnStmt;\r\n    }\r\n\r\n    protected analyzeSimpleStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_SPAWN':\r\n                return this.analyzeSpawnStmt(context, program, sourceNode);\r\n\r\n            default:\r\n                return super.analyzeSimpleStmt(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'SpawnRoutine'\r\n     */\r\n    protected analyzePartFXProperty(context: FxContext, program: ProgramScope, sourceNode: IParseNode): any {\r\n        const children = sourceNode.children;\r\n        console.log(sourceNode);\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePartFXPassDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxPassInstruction {\r\n\r\n        context.beginPartFxPass();\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        // temp solution in order to not highlight useless pass states in the next analysis call.\r\n        context.renderStates = renderStates;\r\n\r\n        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);\r\n\r\n        const sorting = isBoolean(fxStates.sorting) ? fxStates.sorting : true;\r\n        const prerenderRoutine = fxStates.prerenderRoutine || null;\r\n        const geometry = fxStates.geometry || EPartFxPassGeometry.k_Billboard;\r\n        const instanceCount = fxStates.instanceCount || 1;\r\n\r\n        //\r\n        // Validation of the shader input\r\n        //\r\n\r\n        let pixelShader = entry.pixel;\r\n\r\n        /**\r\n         * Vertex shader validation pattern:\r\n         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);\r\n         */\r\n\r\n        let vertexShader = entry.vertex;\r\n        if (vertexShader) {\r\n            const requiredSemantics = ['POSITION', 'POSITION0'];\r\n            let hasInstance = false;\r\n            let hasRequiredSemantics = false;\r\n            for (const param of vertexShader.def.params) {\r\n                hasInstance = hasInstance ||\r\n                    param.type.subType === context.particleInstance;\r\n                hasRequiredSemantics = hasRequiredSemantics ||\r\n                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));\r\n            }\r\n\r\n            if (!hasInstance) {\r\n                context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n                    { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });\r\n                vertexShader = pixelShader = null;\r\n            }\r\n\r\n            // if (!hasRequiredSemantics) {\r\n            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n            //         { tooltip: 'doesn\\'t have requiredsemantics.' });\r\n            //     vertexShader = pixelShader = null;\r\n            // }\r\n        }\r\n\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PartFxPassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n\r\n            sorting,\r\n            geometry,\r\n            instanceCount,\r\n            prerenderRoutine,\r\n\r\n            renderStates,\r\n            pixelShader,\r\n            vertexShader\r\n        });\r\n\r\n        //TODO: add annotation and id\r\n\r\n        context.endPartFxPass();\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    // TODO: use explicit return type\r\n    protected analyzePartFxStateBlock(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n        const children = sourceNode.children;\r\n        let states: Partial<IPartFxPassProperties> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n    * AST example:\r\n    *    PassState\r\n    *         T_PUNCTUATOR_59 = ';'\r\n    *       + PassStateExpr \r\n    *         T_PUNCTUATOR_61 = '='\r\n    *         T_NON_TYPE_ID = 'STATE_ONE'\r\n    */\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'STATE_TWO'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassStateExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // TODO: add explicit type for fx statess\r\n    protected analyzePartFXPassProperies(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateName: string = children[children.length - 1].value.toUpperCase();\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        let fxStates: Partial<IPartFxPassProperties> = {};\r\n\r\n        if (isNull(exprNode.value) || isNull(stateName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            // TODO: return correct state list\r\n            return fxStates;\r\n        }\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: string[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                // TODO: validate values with names\r\n                values[j] = stateExprNode.children[i].value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                // case ERenderStates.BLENDFUNC:\r\n                //     if (values.length !== 2) {\r\n                //         console.warn('Pass state are incorrect.');\r\n                //         return {};\r\n                //     }\r\n                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                //     break;\r\n                default:\r\n                    console.warn('Pass fx state is incorrect.');\r\n                    return fxStates;\r\n            }\r\n        }\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_NON_TYPE_ID = 'FALSE'\r\n         */\r\n        else {\r\n            let value: string = null;\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ('InstanceCount'.toUpperCase()):\r\n                    fxStates.instanceCount = Number(value) || 1;\r\n                    break;\r\n                case ('Geometry'.toUpperCase()):\r\n                    const types = [\r\n                        'Billboard',\r\n                        'Cylinder',\r\n                        'Box',\r\n                        'Sphere',\r\n                        'Line'\r\n                    ].map(type => type.toUpperCase());\r\n\r\n                    fxStates.geometry = Math.max(0, types.indexOf(value)) as EPartFxPassGeometry;\r\n                    break;\r\n                case ('Sorting'.toUpperCase()):\r\n                    // TODO: use correct validation with diag error output\r\n                    assert(value == 'TRUE' || value == 'FALSE');\r\n                    fxStates.sorting = (value === 'TRUE');\r\n                    break;\r\n                case ('PrerenderRoutine'.toUpperCase()):\r\n                    {\r\n                        /**\r\n                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.\r\n                        */\r\n                        let validators: ICompileValidator[] = [\r\n                            /* prerender(Part part, PartInstance instance) */\r\n                            { ret: T_VOID, args: [context.particleCore, null] },\r\n                            /* prerender(Part part, PartInstance instance, int instanceId) */\r\n                            { ret: T_VOID, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                        ];\r\n\r\n                        //\r\n                        // TODO: add string-based validators like this:\r\n                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);\r\n                        //\r\n\r\n                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);\r\n\r\n                        if (!prerenderRoutine) {\r\n                            break;\r\n                        }\r\n\r\n                        //\r\n                        // check arguments\r\n                        //\r\n\r\n                        let fn = prerenderRoutine.function;\r\n\r\n                        /** first argument's type */\r\n                        let argv = fn.def.params.map(param => param.type);\r\n\r\n                        if (argv.length < 2) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        if (!argv[0].readable || /*!argv[0].isEqual(context.particle)*/ argv[0].subType !== context.particleCore ||\r\n                            argv[0].isNotBaseArray() ||\r\n                            !argv[1].hasUsage('out') || !argv[1].writable || argv[1].isNotBaseArray()) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        //         argv[1]: \"out PartInstance\"\r\n                        // argv[1].subType: \"PartInstance\"\r\n                        context.particleInstance = argv[1].subType;\r\n                        fxStates.prerenderRoutine = prerenderRoutine;\r\n                    }\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n\r\n        return fxStates;\r\n    }\r\n\r\n\r\n    protected analyzePartFXBody(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxProperties {\r\n        let passList: IPartFxPassInstruction[] = [];\r\n        let spawnRoutine: ICompileExprInstruction = null;\r\n        let initRoutine: ICompileExprInstruction = null;\r\n        let updateRoutine: ICompileExprInstruction = null;\r\n        let particle: ITypeInstruction = null;\r\n        let capacity: number = null;\r\n\r\n        const children = sourceNode.children;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassState':\r\n                    {\r\n                        let sourceNode = children[i];\r\n                        let stateName = sourceNode.children[3].value; // \"T_NON_TYPE_ID\"\r\n                        switch (stateName.toUpperCase()) {\r\n                            case ('Capacity'.toUpperCase()):\r\n                                {\r\n                                    // TODO: make correct validation of the capacity value and emit errors\r\n                                    //       through diagnostics system. \r\n                                    const snum = sourceNode.children[1].children[0].value;\r\n                                    assert(isNumber(Number(snum)));\r\n                                    capacity = Number(snum) || -1;\r\n                                    break;\r\n                                }\r\n                            case ('SpawnRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Spawn routine expected as 'int spawn(void)'.\r\n                                     */\r\n                                    let validator = { ret: T_INT, args: [] };\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, [validator]);\r\n                                }\r\n                                break;\r\n                            case ('InitRoutine'.toUpperCase()):\r\n                                {\r\n                                    /** Init routine expected as 'void init(in Part part)'. */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_VOID, args: [null, T_INT] },   /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null, T_UINT] },  /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null] },          /* init(PART part) */\r\n                                    ];\r\n\r\n                                    // TODO: show error in case of both functions are found\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!initRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    let fn = initRoutine.function;\r\n                                    /** first argument's type */\r\n                                    let type = fn.def.params[0].type;\r\n\r\n                                    if ((!type.hasUsage('out') && !type.hasUsage('inout')) || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        initRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                            case ('UpdateRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Update routine expected as 'void update(inout Part part)'.\r\n                                     */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_BOOL, args: [null, T_INT] }, /* update(PART part, int partId) */\r\n                                        { ret: T_BOOL, args: [null] },        /* update(PART part) */\r\n                                    ];\r\n\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    const fn = updateRoutine.function;\r\n                                    const fdef = fn.def;\r\n                                    const paramList = fdef.params;\r\n\r\n                                    if (paramList.length < 1 || paramList.length > 2) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    /** first argument's type */\r\n                                    let type = paramList[0].type;\r\n\r\n                                    if (!type.hasUsage('out') && !type.hasUsage('inout') || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    //\r\n                                    // Check return type\r\n                                    //\r\n\r\n                                    if (!fdef.returnType.isEqual(T_BOOL)) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Note: all fx properties should be parsed prior to pass declaraion analysis\r\n        // because some of them are critical for pass validation\r\n        context.particleCore = particle;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassDecl':\r\n                    {\r\n                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);\r\n\r\n                        if (!pass.isValid()) {\r\n                            context.warn((pass.id && pass.id.sourceNode) || children[i], EWarnings.IncompletePass, {\r\n                                techniqueName: pass.name,\r\n                                tooltip: `The pass is not completed. Not all required parameters are specified.`\r\n                            });\r\n                        }\r\n\r\n                        assert(!isNull(pass));\r\n                        passList.push(pass);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        return { passList, spawnRoutine, initRoutine, updateRoutine, particle, capacity };\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PartFxDecl\r\n     *       + PartFxBody \r\n     *       + Annotation \r\n     *       + Semantic \r\n     *       + ComplexNameOpt \r\n     *         T_KW_FXPART = 'partFx'\r\n     */\r\n    protected analyzePartFXDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let props: IPartFxProperties = null;\r\n\r\n        context.beginPartFx();\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n\r\n            switch (children[i].name) {\r\n                case 'Annotation':\r\n                    annotation = this.analyzeAnnotation(children[i]);\r\n                    break;\r\n                case 'Semantic':\r\n                    semantic = this.analyzeSemantic(children[i]);\r\n                    break;\r\n                case 'PartFxBody':\r\n                    props = this.analyzePartFXBody(context, program, children[i]);\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        context.endPartFx();\r\n\r\n        const partFx = new PartFxInstruction({\r\n            sourceNode, name, semantic, annotation, scope, ...props\r\n        });\r\n\r\n        if (!partFx.isValid()) {\r\n            // highlight name only\r\n            context.warn(children[children.length - 2], EWarnings.IncompleteTechnique, {\r\n                techniqueName: partFx.name,\r\n                tooltip: `The technique is not completed. Not all required parameters are specified.`\r\n            });\r\n        }\r\n\r\n        FxAnalyzer.addTechnique(context, program, partFx);\r\n        return partFx;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'PartFxDecl':\r\n                return [this.analyzePartFXDecl(context, program, sourceNode)];\r\n            default:\r\n                return super.analyzeUnknDecl(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    protected createContext(uri: string): FxContext {\r\n        return new FxContext(uri);\r\n    }\r\n\r\n\r\n    protected validate(context: FxContext, program: ProgramScope, root: IInstructionCollector) {\r\n        super.validate(context, program, root);\r\n\r\n        const scope = program.globalScope;\r\n\r\n        // NOTE: all effects are assumed to be valid\r\n        const fxList = <IPartFxInstruction[]>root.instructions.filter(instr => instr.instructionType === EInstructionTypes.k_PartFxDecl);\r\n\r\n        //\r\n        // spawn operator validation\r\n        //\r\n\r\n        for (const spawnStmt of context.spawnStmts) {\r\n            const bImportedEffect = false;\r\n            //parse as the spawn from the same effect\r\n\r\n            assert(!bImportedEffect, 'unsupported');\r\n\r\n            if (!bImportedEffect) {\r\n\r\n                let initializer = <IFunctionDeclInstruction>null;\r\n                for (const fx of fxList) {\r\n                    // looking for Init(out Part part, int partId: PART_ID, ...parameters)\r\n                    let args = [fx.particle, T_INT, ...spawnStmt.args.map(asType)];\r\n                    initializer = scope.findFunction(spawnStmt.name, args);\r\n\r\n                    // in case of signature not found:\r\n                    // looking for signature like: Init(out Part part, ...parameters)\r\n                    if (!initializer) {\r\n                        // looaking for signature like: Init(out Part part, ...parameters)\r\n                        // TODO: check that second parameter doesn't have PART_ID semantic in \r\n                        //       order to not find false positive signature\r\n                        args = [fx.particle, ...spawnStmt.args.map(asType)];\r\n                        initializer = scope.findFunction(spawnStmt.name, args);\r\n                    }\r\n\r\n                    if (initializer) {\r\n                        spawnStmt.$resolve(fx, initializer);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!initializer) {\r\n                    context.error(spawnStmt.sourceNode, EErrors.PartFx_InvalidSpawnStmtInitializerNotFound,\r\n                        { tooltip: 'Invalid spawn statement. Effect initializer not found.' });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","import { isString } from \"@lib/common\";\r\n\r\n// helper class to always pass strings by pointer and not by value;\r\nexport class StringRef {\r\n    constructor(readonly content: string) {\r\n\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toSource(): string {\r\n        return this.content;\r\n    }\r\n\r\n    static make(val: string | StringRef): StringRef {\r\n        if (!isString(val)) {\r\n            return <StringRef>val;\r\n        }\r\n        return new StringRef(`${val}`);\r\n    }\r\n}\r\n\r\n","import { IDiagnosticReport, IDiagnostics } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport enum ENodeCreateMode {\r\n    k_Default,\r\n    k_Necessary,\r\n    k_Expose,\r\n    k_Skip\r\n}\r\n\r\nexport enum EParserCode {\r\n    // k_Pause,\r\n    k_Ok,\r\n    k_Error\r\n}\r\n\r\nexport enum EParserType {\r\n    k_LR0,\r\n    k_LR1,\r\n    k_LALR\r\n}\r\n\r\nexport enum IASTDocumentFlags {\r\n    k_Optimize = 0x0008,\r\n    k_DeveloperMode = 0x0010\r\n}\r\n\r\n\r\nexport enum EParserFlags {\r\n    k_ForceAppendAll = 0x0001,\r\n    k_AllowExposeMode = 0x0002,\r\n    k_AllowAddMode = 0x0004,\r\n    k_AllowSkipMode = 0x008,\r\n    k_Default = k_AllowAddMode | k_AllowExposeMode | k_AllowSkipMode,\r\n    k_Debug = 0x0010\r\n}\r\n\r\n\r\nexport enum ETokenType {\r\n    k_NumericLiteral = 1,\r\n    k_SinglelineCommentLiteral,\r\n    k_MultilineCommentLiteral,\r\n    k_StringLiteral,\r\n    k_PunctuatorLiteral,\r\n    k_WhitespaceLiteral,\r\n    k_NewlineLiteral,\r\n    k_IdentifierLiteral,\r\n    k_KeywordLiteral,\r\n    k_Unknown,\r\n    k_End\r\n}\r\n\r\n\r\nexport type IFile = StringRef;\r\n\r\nexport interface IPosition {\r\n    file: IFile;\r\n    line: number; \r\n    column: number;\r\n    offset?: number;\r\n}\r\n\r\n// todo: add support for range over multiple files;\r\nexport interface IRange {\r\n    start: IPosition;\r\n    end: IPosition;\r\n}\r\n\r\nexport interface IToken {\r\n    index: number;\r\n    value: string;\r\n    name?: string;\r\n    type?: ETokenType;\r\n\r\n    loc?: IRange;\r\n    // range?: number[];\r\n}\r\n\r\n\r\n/**\r\n * Grammar rule corresponding to the entry from grammar file.\r\n */\r\nexport interface IRule {\r\n    left: string;\r\n    right: string[];\r\n\r\n    /**\r\n     * rule index based on parser's '_nRules'; \r\n     */\r\n    index: number;\r\n}\r\n\r\nexport enum EOperationType {\r\n    k_Error = 100,\r\n    k_Shift,\r\n    k_Reduce,\r\n    k_Success,\r\n    k_Ok\r\n}\r\n\r\nexport type IRuleFunction = () => EOperationType | Promise<EOperationType>;\r\n\r\nexport interface IParseNode {\r\n    children: IParseNode[];\r\n    parent: IParseNode;\r\n    name: string;\r\n    value: string;\r\n    loc?: IRange;\r\n}\r\n\r\nexport interface IParseTree {\r\n    readonly nodes: IParseNode[];\r\n    readonly lastNode: IParseNode;\r\n    readonly optimized: boolean;\r\n    readonly root: IParseNode;\r\n\r\n    addToken(pToken: IToken): void;\r\n    reduceByRule(pRule: IRule, eCreate: ENodeCreateMode): void;\r\n    finishTree(): void;\r\n    \r\n    $pop(loc?: IRange): void;\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree;\r\n    /** @deprecated */\r\n    toString(): string;\r\n    /** @deprecated */\r\n    toHTMLString(node?: IParseNode, padding?: string): string;\r\n}\r\n\r\n\r\nexport interface ILexerEngine {\r\n    readonly keywords: IMap<string>;\r\n    readonly punctuators: IMap<string>;\r\n    readonly punctuatorsFirstSymbols: IMap<boolean>;\r\n\r\n\r\n    addPunctuator(value: string, name?: string): string;\r\n    addKeyword(value: string, name: string): string;\r\n\r\n    getTerminalValueByName(name: string): string;\r\n\r\n    isLineTerminator(symbol: string): boolean;\r\n    isKeyword(value: string): boolean;\r\n    isPunctuator(value: string): boolean;\r\n    isNumberStart(ch: string, ch1: string): boolean;\r\n    isCommentStart(ch: string, ch1: string): boolean;\r\n    isStringStart(ch: string): boolean;\r\n    isPunctuatorStart(ch: string): boolean;\r\n    isWhiteSpaceStart(ch: string): boolean;\r\n    isNewlineStart(ch: string): boolean;\r\n    isIdentifierStart(ch: string): boolean;\r\n}\r\n\r\n\r\nexport interface IASTConfig {\r\n    parser?: IParser;\r\n    knownTypes?: Set<string>;\r\n    ruleFunctions?: Map<string, IRuleFunction>;\r\n}\r\n\r\n\r\nexport interface IASTDocument {\r\n    readonly uri: string;\r\n    readonly diagnosticReport: IDiagnosticReport;\r\n    readonly root: IParseNode;\r\n}\r\n\r\n\r\n\r\n\r\nexport interface IOperation {\r\n    type: EOperationType;\r\n    rule?: IRule;\r\n    stateIndex?: number;\r\n}\r\n\r\nexport interface IOperationMap {\r\n    [grammarSymbol: string]: IOperation;\r\n    [stateIndex: number]: IOperation;\r\n}\r\n\r\nexport interface ISyntaxTable {\r\n    [stateIndex: number]: {\r\n        [terminal: string]: IOperation;\r\n    }\r\n}\r\n\r\n\r\nexport interface IRuleMap {\r\n    [ruleIndex: number]: IRule;\r\n}\r\n\r\nexport interface IProductions {\r\n    [nonTerminal: string]: IRuleMap;\r\n}\r\n\r\n// TODO: remove type\r\nexport interface IRuleFunctionMap {\r\n    [grammarSymbolOrFuncName: string]: string;\r\n}\r\n\r\nexport interface IRuleFunctionDMap {\r\n    [stateIndex: number]: IRuleFunctionMap;\r\n}\r\n\r\nexport interface IAdditionalFuncInfo {\r\n    name: string;\r\n    position: number;\r\n    rule: IRule;\r\n}\r\n\r\nexport interface IParser {\r\n    readonly lexerEngine: ILexerEngine;\r\n    readonly syntaxTable: ISyntaxTable;\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreateMode;\r\n    getGrammarSymbols(): Map<string, string>;    \r\n}\r\n\r\n\r\nexport interface IParserParams {\r\n    grammar: string;\r\n    flags?: number; // EParserFlags\r\n    type?: EParserType;\r\n}\r\n\r\n\r\nexport type ExpectedSymbols = Set<string>;\r\n","import { EInstructionTypes, IExprInstruction, IReturnOperator, IReturnStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IReturnStmtInstructionSettings extends IInstructionSettings {\r\n    expr?: IExprInstruction;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Represent return expr;\r\n * return ExprInstruction\r\n */\r\nexport class ReturnStmtInstruction extends StmtInstruction implements IReturnStmtInstruction {\r\n    protected _operator: IReturnOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr = null, ...settings }: IReturnStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ReturnStmt, ...settings });\r\n        \r\n        this._operator = \"return\";\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get operator(): IReturnOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        if (this.expr) {\r\n            return \"return \" + this.expr.toCode() + \";\";\r\n        }\r\n        else {\r\n            return \"return;\";\r\n        }\r\n    }\r\n}\r\n\r\n","import { assert, isNull } from '@lib/common';\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IInitExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from './DeclInstruction';\r\nimport { type } from '../helpers';\r\nimport { Instruction } from './Instruction';\r\n\r\n// import * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface IVariableDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: IVariableTypeInstruction;\r\n    init?: IInitExprInstruction;\r\n\r\n    // EVariableUsageFlags\r\n    usageFlags?: number;\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport enum EVariableUsageFlags {\r\n    k_Local     = 0x01,\r\n    k_Global    = 0x02,\r\n    k_Argument  = 0x04,\r\n}\r\n\r\n/**\r\n * Represent type var_name [= init_expr]\r\n * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction\r\n */\r\nexport class VariableDeclInstruction extends DeclInstruction implements IVariableDeclInstruction {\r\n\r\n    protected _id: IIdInstruction;\r\n    protected _type: IVariableTypeInstruction;\r\n    protected _initExpr: IInitExprInstruction;\r\n    protected _usageFlags: number;\r\n\r\n \r\n    constructor({ id, type, init = null, usageFlags = 0, ...settings }: IVariableDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withNoParent(type);\r\n        this._initExpr = Instruction.$withParent(init, this);\r\n        this._usageFlags = usageFlags;\r\n\r\n        assert(!this.isParameter() || (isNull(this.parent) || this.parent.instructionType == EInstructionTypes.k_FunctionDef));\r\n        assert(this.isLocal() || !this.isLocal());\r\n        assert(!this.isParameter() || this.isLocal());\r\n    }\r\n\r\n\r\n    get initExpr(): IInitExprInstruction {\r\n        return this._initExpr;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    get defaultValue(): any {\r\n        this._initExpr.evaluate();\r\n        return this._initExpr.getEvalValue();\r\n    }\r\n\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>this._type;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    isGlobal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Global);\r\n    }\r\n\r\n\r\n    isLocal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Local);\r\n    }\r\n\r\n    isParameter(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);\r\n    }\r\n\r\n\r\n\r\n    isField(): boolean {\r\n        if (isNull(this.parent)) {\r\n            return false;\r\n        }\r\n\r\n        var eParentType: EInstructionTypes = this.parent.instructionType;\r\n        if (eParentType === EInstructionTypes.k_VariableType ||\r\n            eParentType === EInstructionTypes.k_ComplexType ||\r\n            eParentType === EInstructionTypes.k_SystemType) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        var code = '';        \r\n        code = this.type.toCode();\r\n        code += ' ' + this.id.toCode();\r\n\r\n        if (this.type.isNotBaseArray()) {\r\n            var iLength: number = this.type.length;\r\n            code += '[' + iLength + ']';\r\n        }\r\n\r\n        if (!isNull(this.initExpr) &&\r\n            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?\r\n            !this.type.isUniform()) {\r\n            code += '=' + this.initExpr.toCode();\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IStmtInstruction, IWhileStmtInstruction, IDoWhileOperator } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n\r\n\r\nexport interface IWhileStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    body: IStmtInstruction;\r\n    operator: IDoWhileOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent while(expr) stmt\r\n * ( while || do_while) ExprInstruction StmtInstruction\r\n */\r\nexport class WhileStmtInstruction extends StmtInstruction implements IWhileStmtInstruction {\r\n    protected _operator: IDoWhileOperator;\r\n    protected _cond: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    \r\n    constructor({ cond, body, operator, ...settings }: IWhileStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_WhileStmt, ...settings });\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this.cond;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n\r\n    get operator(): IDoWhileOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        if (this.operator === \"while\") {\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \")\";\r\n            code += this.body.toCode();\r\n        }\r\n        else {\r\n            code += \"do\";\r\n            code += this.body.toCode();\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \");\";\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IComplexExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IComplexExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (expr)\r\n * EMPTY_OPERATOR ExprInstruction\r\n */\r\nexport class ComplexExprInstruction extends ExprInstruction implements IComplexExprInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, ...settings }: IComplexExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return \"(\" + this.expr.toCode() + \")\";\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        if ((<IExprInstruction>this.expr).evaluate()) {\r\n            this._evalResult = (<IExprInstruction>this.expr).getEvalValue();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","class DistinctColor {\r\n    static list = [\r\n        0xe6194b, 0x3cb44b, 0xffe119, 0x4363d8, 0xf58231, 0x911eb4, \r\n        0x46f0f0, 0xf032e6, 0xbcf60c, 0xfabebe, 0x008080, 0xe6beff, \r\n        0x9a6324, 0xfffac8, 0x800000, 0xaaffc3, 0x808000, 0xffd8b1, \r\n        0x000075, 0x808080  //, 0xffffff, 0x000000\r\n    ];\r\n\r\n    private _curIdx: number;\r\n\r\n    constructor(idx = 0) {\r\n        this._curIdx = idx;\r\n    }\r\n\r\n\r\n    value(): number {\r\n        return this._curIdx;\r\n    }\r\n\r\n\r\n    pickNext(): number {\r\n        this._curIdx = (this._curIdx + 1) % DistinctColor.list.length;\r\n        return this.value();\r\n    }\r\n\r\n\r\n    toRGBAString() {\r\n        return DistinctColor.toRGBAString(DistinctColor.resolveColor(this.value()));\r\n    }\r\n\r\n\r\n    static resolveColor(idx: number) {\r\n        return DistinctColor.list[idx % DistinctColor.list.length];\r\n    }\r\n\r\n\r\n    static toRGBAString(val: number) {\r\n        let r = ((val >> 16) & 0xff);\r\n        let g = ((val >> 8) & 0xff);\r\n        let b = ((val >> 0) & 0xff);\r\n        return `rgb(${r}, ${g}, ${b})`;\r\n    }\r\n    \r\n\r\n    static make(idx: number) {\r\n        return new DistinctColor(idx);\r\n    }\r\n\r\n    static buildVariousClasses(prefix = 'dc') {\r\n        return DistinctColor.list.reduce((styles, color) => (\r\n            styles[`${prefix}_${color}`] = { \r\n                opacity: 0.3, \r\n                backgroundColor: `${DistinctColor.toRGBAString(color)}` \r\n            }, styles), {});\r\n\r\n        // [`dc_${0xe6194b}`]: { opacity: 0.3, backgroundColor: '#e6194b' },\r\n        // [`dc_${0x3cb44b}`]: { opacity: 0.3, backgroundColor: '#3cb44b' },\r\n        // ...\r\n        // ...\r\n        // [`dc_${0x000075}`]: { opacity: 0.3, backgroundColor: '#000075' },\r\n        // [`dc_${0x808080}`]: { opacity: 0.3, backgroundColor: '#808080' }\r\n    }\r\n}\r\n\r\nexport default DistinctColor;\r\n\r\n","import { EInstructionTypes, IInstruction, ISamplerStateInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISamplerStateInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    value: IInstruction;\r\n}\r\n\r\nexport class SamplerStateInstruction extends Instruction implements ISamplerStateInstruction {\r\n    protected _name: string;\r\n    protected _value: IInstruction;\r\n\r\n    constructor({ name, value, ...settings }: ISamplerStateInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SamplerState, ...settings });\r\n        \r\n        this._name = name;\r\n        this._value = Instruction.$withParent(value, this);\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get value(): IInstruction {\r\n        return this.value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@not_implemented\");\r\n        return null;\r\n    }\r\n\r\n    toCode(): string {\r\n        console.error(\"@not_implmented\");\r\n        return null;\r\n    }\r\n}\r\n\r\n","export { EOperation } from \"./EOperations\"\r\n\r\nexport enum EAddrType {\r\n    k_Registers,\r\n    k_Input,\r\n\r\n    k_PointerRegisters,\r\n    k_PointerInput\r\n};\r\n\r\nexport enum EChunkType {\r\n    k_Constants,\r\n    k_Layout,\r\n    k_Code,\r\n};\r\n\r\n// export interface IMemoryRecord {\r\n//     range: number;\r\n//     value: number | string;\r\n//     type: 'f32' | 'i32' | 'uniform' | 'unknown';\r\n// }\r\n\r\n","import { assert, isEmpty, isNull } from \"@lib/common\";\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { createFXSLDocument } from \"@lib/fx/FXSLDocument\";\r\nimport { IScope } from \"@lib/idl/IInstruction\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { ETokenType, IRange, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Lexer } from \"@lib/parser/Lexer\";\r\nimport { END_SYMBOL } from \"@lib/parser/symbols\";\r\nimport { cloneRange } from \"@lib/parser/util\";\r\n\r\nimport { u8ArrayAsI32 } from \"../bytecode/common\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\n\r\nfunction nativeFromString(str) {\r\n    switch(str.toLowerCase()) {\r\n        case 'true': return true;\r\n        case 'false': return false;\r\n        default:\r\n            return Number(str) || 0;\r\n    }\r\n}\r\n\r\nfunction exractComments(document: ITextDocument): IToken[] {\r\n    const lexer = new Lexer({ skipComments: false });\r\n    lexer.setup(document);\r\n\r\n    let comments = [];\r\n    let token: IToken;\r\n    while((token = lexer.getNextToken()).value !== END_SYMBOL) {\r\n        if (token.type === ETokenType.k_MultilineCommentLiteral) {\r\n            comments.push(token);\r\n        }\r\n    }\r\n    return comments;\r\n}\r\n\r\nexport interface ITestCase {\r\n    expr: string;\r\n    expected: number | boolean;\r\n    loc: IRange;\r\n    passed?: boolean;\r\n    note?: string;\r\n}\r\n\r\nexport interface ITest {\r\n    name: string;\r\n    cases: ITestCase[];\r\n    loc: IRange;\r\n    passed?: boolean;\r\n}\r\n\r\nexport interface IAutotests {\r\n    description: string;\r\n    document: ISLDocument;\r\n    tests: ITest[];\r\n    passed?: boolean;\r\n}\r\n\r\n/**\r\n * \r\n * @param source SL text document with test markup inside.\r\n */\r\nexport async function parse(textDocument: ITextDocument): Promise<IAutotests> {\r\n    let description = null;\r\n    let tests = [];\r\n\r\n    // NOTE: temp solution (until the parser gets comment support)\r\n    exractComments(textDocument).forEach((commentToken: IToken) => {\r\n        let comment = commentToken.value.slice(2, -2);\r\n        let list = comment\r\n            .split('\\n')\r\n            .map(str => str.replace(/^\\s*\\*{1,2}\\s*|\\s*$/g, ''));\r\n\r\n        let accum: string[] = [];\r\n        let lastRule: { line: number, content: string } = null;\r\n        let content: string;\r\n        let rules: { line: number, content: string }[] = [];\r\n        let line = -1;\r\n        while (list.length) {\r\n            line++;\r\n\r\n            [content, list] = [list[0], list.slice(1)];\r\n\r\n            if (content.match(/^\\s*$/g)) {\r\n                continue;\r\n            }\r\n\r\n            if (!content.match(/^@[\\w]+/g)) {\r\n                accum.push(content);\r\n                continue;\r\n            }\r\n\r\n            if (lastRule) {\r\n                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n            }\r\n\r\n            lastRule = { content, line };\r\n        };\r\n\r\n        if (lastRule && lastRule.content) {\r\n            rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line});\r\n        }\r\n\r\n        let test: ITest = null;\r\n\r\n        error:\r\n        for (let rule of rules) {\r\n            const { line, content } = rule;\r\n            const parts = content.split(' ');\r\n            const ruleName = parts[0].trim().toLowerCase();\r\n            const loc = cloneRange(commentToken.loc);\r\n\r\n            // FIXME: dirty hack in order to make the range correct\r\n            loc.start.line += line;\r\n            // loc.start.offset = -1;\r\n            loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '\r\n            loc.end.line = loc.start.line;\r\n            // loc.end.offset = loc.start.offset;\r\n            loc.end.column = loc.start.column + parts.join(' ').length;\r\n\r\n            switch (ruleName) {\r\n                case '@autotests':\r\n                    assert(isNull(description));\r\n                    description = parts.slice(1).join(' ');\r\n                    break;\r\n                case '@test':\r\n                    assert(isNull(test));\r\n                    if (test) {\r\n                        break error;\r\n                    }\r\n                    test = { \r\n                        name: parts.slice(1).join(' '),\r\n                        cases: [],\r\n                        loc\r\n                    };\r\n                    break;\r\n                case '@expected':\r\n                    assert(!isNull(test));\r\n                    if (!test) {\r\n                        break error;\r\n                    }\r\n                    let [expr, expectedString] = parts.slice(1).join(' ').trim().slice(1, -1).split('==').map(str => str.trim());\r\n                    assert(expr && expectedString);\r\n                    \r\n                    let expected = nativeFromString(expectedString);\r\n\r\n                    test.cases.push({ expr, expected, loc });\r\n                    break;\r\n            }\r\n        };\r\n\r\n        if (test) {\r\n            tests.push(test);\r\n        }\r\n    });\r\n\r\n    const document = await createFXSLDocument(textDocument);\r\n    return { description, document, tests };\r\n}\r\n\r\n\r\nasync function runTest(test: ITest, document: ISLDocument) {\r\n    const { cases } = test;\r\n    for (let exam of cases) {\r\n        const { expr, expected } = exam;\r\n        const result = await VM.evaluate(expr, document);\r\n        exam.passed = result === expected;\r\n        if (!exam.passed) {\r\n            exam.note = `Test failed. Expected is '${expected}', but given is '${result}'`;\r\n        }\r\n    }\r\n\r\n    test.passed = cases.reduce((acc, exam) => (acc && exam.passed), true);\r\n}\r\n\r\n\r\nexport async function run(autotests: IAutotests) {\r\n    autotests.passed = true;\r\n    for (const test of autotests.tests) {\r\n        await runTest(test, autotests.document);\r\n        autotests.passed = autotests.passed && test.passed;\r\n    }\r\n}\r\n","import { assert } from '@lib/common';\r\nimport { ETechniqueType, IScope } from '@lib/idl/IInstruction';\r\nimport { IPartFxInstruction } from '@lib/idl/part/IPartFx';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IDebuggerActions, IDebuggerOptionsChanged, IDebuggerStartDebug, IPlaygroundActions, IPlaygroundEmitterUpdate, ISourceCodeAddBreakpoint, ISourceCodeAddMarker, ISourceCodeAddMarkerBatch, ISourceCodeAnalysisComplete, ISourceCodeModified, ISourceCodeParsingComplete, ISourceCodeRemoveBreakpoint, ISourceCodeRemoveMarker, ISourceCodeRemoveMarkerBatch, ISourceFileActions, ISourceFileDropState, ISourceFileLoaded, ISourceFileLoadingFailed, ISourceFileRequest } from '@sandbox/actions/ActionTypes';\r\nimport { handleActions } from '@sandbox/reducers/handleActions';\r\nimport { IDebuggerState, IFileState, IStoreState } from '@sandbox/store/IStoreState';\r\n\r\nconst initialState: IFileState = {\r\n    uri: null,\r\n    content: null,\r\n    contentModified: null,\r\n    error: null,\r\n    markers: {},\r\n    breakpoints: [],\r\n    slastDocument: null,\r\n    slDocument: null,\r\n    debugger: {\r\n        expression: null,\r\n        runtime: null,\r\n        options: {\r\n            colorize: true,\r\n            disableOptimizations: true,\r\n            autocompile: false\r\n        }\r\n    },\r\n    emitter: null,\r\n    // HACK: additional counter in order to call component's update in case of shadow pipeline reloading\r\n    $pipeline: 0\r\n};\r\n\r\n\r\nexport default handleActions<IFileState, ISourceFileActions | IDebuggerActions | IPlaygroundActions>({\r\n    [evt.SOURCE_FILE_REQUEST]: (state, action: ISourceFileRequest) =>\r\n        ({ ...state, uri: action.payload.filename }),\r\n\r\n    [evt.SOURCE_FILE_LOADED]: (state, action: ISourceFileLoaded) =>\r\n        ({ ...state, content: action.payload.content }),\r\n\r\n    [evt.SOURCE_FILE_LOADING_FAILED]: (state, action: ISourceFileLoadingFailed) =>\r\n        ({\r\n            ...state,\r\n            error: action.payload.error,\r\n            // NOTE: temp solution (clean up all info about prev file)\r\n            content: null,\r\n            debugger: { ...state.debugger, runtime: null },\r\n            breakpoints: [],\r\n            slASTDocument: null,\r\n            slDocument: null,\r\n            emitter: null,\r\n            $pipeline: 0\r\n        }),\r\n\r\n    [evt.SOURCE_FILE_DROP_STATE]: (state, action: ISourceFileDropState) =>\r\n        ({\r\n            ...state,\r\n            error: null,\r\n            content: null,\r\n            debugger: { ...state.debugger, runtime: null },\r\n            breakpoints: [],\r\n            slASTDocument: null,\r\n            slDocument: null,\r\n            emitter: null,\r\n            $pipeline: 0\r\n        }),\r\n\r\n    [evt.SOURCE_CODE_MODIFED]: (state, action: ISourceCodeModified) =>\r\n        ({\r\n            ...state, markers: {}, content: action.payload.content, uri: action.payload.filename || state.uri\r\n            // , debugger: { entryPoint: null, runtime: null, ...state.debugger } =\r\n        }),\r\n\r\n    [evt.SOURCE_CODE_PARSING_COMPLETE]: (state, action: ISourceCodeParsingComplete) =>\r\n        ({ ...state, slastDocument: action.payload.slastDocument }),\r\n\r\n    [evt.SOURCE_CODE_ANALYSIS_COMPLETE]: (state, action: ISourceCodeAnalysisComplete) =>\r\n        ({ ...state, slDocument: action.payload.result }),\r\n\r\n    //\r\n    // markers\r\n    //\r\n\r\n    [evt.SOURCE_CODE_ADD_MARKER]: (state, action: ISourceCodeAddMarker) =>\r\n        ({ ...state, markers: { ...state.markers, [action.payload.name]: action.payload } }),\r\n\r\n    [evt.SOURCE_CODE_REMOVE_MARKER]: (state, action: ISourceCodeRemoveMarker) => {\r\n        const markers = { ...state.markers };\r\n        delete markers[action.payload.name];\r\n        return { ...state, markers };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_ADD_MARKER_BATCH]: (state, action: ISourceCodeAddMarkerBatch) => {\r\n        const markers = { ...state.markers };\r\n        action.payload.batch.forEach(desc => markers[desc.name] = desc);\r\n        return { ...state, markers };\r\n    },\r\n\r\n    [evt.SOURCE_CODE_REMOVE_MARKER_BATCH]: (state, action: ISourceCodeRemoveMarkerBatch) => {\r\n        const markers = { ...state.markers };\r\n        action.payload.batch.forEach(name => {\r\n            delete markers[name];\r\n        });\r\n        return { ...state, markers };\r\n    },\r\n\r\n    //\r\n    // breakpoints\r\n    //\r\n\r\n    [evt.SOURCE_CODE_ADD_BREAKPOINT]: (state, action: ISourceCodeAddBreakpoint) => {\r\n        assert(state.breakpoints.indexOf(action.payload.line) === -1);\r\n        return ({ ...state, breakpoints: [...state.breakpoints, action.payload.line] })\r\n    },\r\n\r\n    [evt.SOURCE_CODE_REMOVE_BREAKPOINT]: (state, action: ISourceCodeRemoveBreakpoint) => {\r\n        return { ...state, breakpoints: state.breakpoints.filter(ln => ln !== action.payload.line) };\r\n    },\r\n\r\n    //\r\n    // debugger\r\n    //\r\n\r\n    [evt.DEBUGGER_START_DEBUG]: (state, action: IDebuggerStartDebug) => {\r\n        const options = state.debugger.options;\r\n        const { expression, runtime } = action.payload;\r\n        return { ...state, debugger: { expression, runtime, options } };\r\n    },\r\n\r\n    [evt.DEBUGGER_RESET]: (state) => {\r\n        const { debugger: { options } } = state;\r\n        return { ...state, debugger: { expression: null, runtime: null, options, layout: 'i32' } };\r\n    },\r\n\r\n    [evt.DEBUGGER_OPTIONS_CHANGED]: (state: IFileState, action: IDebuggerOptionsChanged) => {\r\n        const options = { ...state.debugger.options, ...action.payload.options };\r\n        const $debugger = { ...state.debugger, options };\r\n        // console.log(JSON.stringify(options, null, '\\t'));\r\n        return { ...state, debugger: $debugger };\r\n    },\r\n\r\n    //\r\n    // playground\r\n    //\r\n\r\n    [evt.PLAYGROUND_EMITER_UPDATE]: (state, action: IPlaygroundEmitterUpdate) =>\r\n        ({ ...state, emitter: action.payload.emitter, $pipeline: state.$pipeline + 1 })\r\n\r\n}, initialState);\r\n\r\n\r\n//- Selectors\r\n\r\n// export const getFileStateNoMarkers = (state: IStoreState): IFileState => ({ ...state.sourceFile, markers: null });\r\nexport const getFileState = (state: IStoreState): IFileState => state.sourceFile;\r\nexport const getDebugger = (state: IStoreState): IDebuggerState => getFileState(state).debugger;\r\nexport const getScope = (file: IFileState): IScope => file.slDocument ? file.slDocument.root.scope : null;\r\nexport const getEmitterName = (file: IFileState) => file.emitter ? file.emitter.name : null;\r\nexport function filterPartFx(scope: IScope): IPartFxInstruction[] {\r\n    if (!scope) {\r\n        return [];\r\n    }\r\n\r\n    const map = scope.techniques;\r\n    return Object.keys(map)\r\n        .filter(name => map[name].type === ETechniqueType.k_PartFx)\r\n        .map(name => <IPartFxInstruction>map[name]);\r\n}\r\n\r\n\r\n","import { assert, isDef, isDefAndNotNull, isNull, mwalk } from '@lib/common';\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport { ECheckStage, EInstructionTypes, EScopeType, ETechniqueType, IAnnotationInstruction, IAttributeInstruction, IConstructorCallInstruction, IDeclInstruction, IDoWhileOperator, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIdInstruction, IInitExprInstruction, IInstruction, IInstructionCollector, IInstructionError, ILiteralInstruction, ILogicalOperator, IPassInstruction, IProvideInstruction, ISamplerStateInstruction, IScope, IStmtBlockInstruction, IStmtInstruction, ITechniqueInstruction, ITypeDeclInstruction, ITypedInstruction, ITypeInstruction, IUnaryOperator, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IParseNode, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\nimport { AnalyzerDiagnostics } from '../AnalyzerDiagnostics';\r\nimport { visitor } from '../Visitors';\r\nimport { expression, instruction, type } from './helpers';\r\nimport { ArithmeticExprInstruction, ArithmeticOperator } from './instructions/ArithmeticExprInstruction';\r\nimport { AssigmentOperator, AssignmentExprInstruction } from \"./instructions/AssignmentExprInstruction\";\r\nimport { AttributeInstruction } from './instructions/AttributeInstruction';\r\nimport { BoolInstruction } from './instructions/BoolInstruction';\r\nimport { BreakOperator, BreakStmtInstruction } from './instructions/BreakStmtInstruction';\r\nimport { CastExprInstruction } from './instructions/CastExprInstruction';\r\nimport { CompileExprInstruction } from './instructions/CompileExprInstruction';\r\nimport { ComplexExprInstruction } from './instructions/ComplexExprInstruction';\r\nimport { ComplexTypeInstruction } from './instructions/ComplexTypeInstruction';\r\nimport { ConditionalExprInstruction } from './instructions/ConditionalExprInstruction';\r\nimport { ConstructorCallInstruction } from './instructions/ConstructorCallInstruction';\r\nimport { DeclStmtInstruction } from './instructions/DeclStmtInstruction';\r\nimport { ExprStmtInstruction } from './instructions/ExprStmtInstruction';\r\nimport { FloatInstruction } from './instructions/FloatInstruction';\r\nimport { ForStmtInstruction } from './instructions/ForStmtInstruction';\r\nimport { FunctionCallInstruction } from './instructions/FunctionCallInstruction';\r\nimport { FunctionDeclInstruction } from './instructions/FunctionDeclInstruction';\r\nimport { FunctionDefInstruction } from './instructions/FunctionDefInstruction';\r\nimport { IdExprInstruction } from './instructions/IdExprInstruction';\r\nimport { IdInstruction } from './instructions/IdInstruction';\r\nimport { IfStmtInstruction } from './instructions/IfStmtInstruction';\r\nimport { InitExprInstruction } from './instructions/InitExprInstruction';\r\nimport { Instruction } from './instructions/Instruction';\r\nimport { InstructionCollector } from './instructions/InstructionCollector';\r\nimport { IntInstruction } from './instructions/IntInstruction';\r\nimport { LogicalExprInstruction } from './instructions/LogicalExprInstruction';\r\nimport { PassInstruction } from './instructions/PassInstruction';\r\nimport { PostfixArithmeticInstruction, PostfixOperator } from './instructions/PostfixArithmeticInstruction';\r\nimport { PostfixIndexInstruction } from './instructions/PostfixIndexInstruction';\r\nimport { PostfixPointInstruction } from './instructions/PostfixPointInstruction';\r\nimport { ProvideInstruction } from \"./instructions/ProvideInstruction\";\r\nimport { ProxyTypeInstruction } from './instructions/ProxyTypeInstruction';\r\nimport { RelationalExprInstruction, RelationOperator } from './instructions/RelationalExprInstruction';\r\nimport { ReturnStmtInstruction } from './instructions/ReturnStmtInstruction';\r\nimport { SamplerOperator, SamplerStateBlockInstruction } from './instructions/SamplerStateBlockInstruction';\r\nimport { SamplerStateInstruction } from \"./instructions/SamplerStateInstruction\";\r\nimport { SemicolonStmtInstruction } from './instructions/SemicolonStmtInstruction';\r\nimport { StmtBlockInstruction } from './instructions/StmtBlockInstruction';\r\nimport { StringInstruction } from './instructions/StringInstruction';\r\nimport { SystemTypeInstruction } from './instructions/SystemTypeInstruction';\r\nimport { TechniqueInstruction } from './instructions/TechniqueInstruction';\r\nimport { TypeDeclInstruction } from './instructions/TypeDeclInstruction';\r\nimport { UnaryExprInstruction } from './instructions/UnaryExprInstruction';\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from './instructions/VariableDeclInstruction';\r\nimport { VariableTypeInstruction } from './instructions/VariableTypeInstruction';\r\nimport { WhileStmtInstruction } from './instructions/WhileStmtInstruction';\r\nimport { ProgramScope } from './ProgramScope';\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_UINT, T_VOID } from './SystemScope';\r\n\r\ntype IErrorInfo = IMap<any>;\r\ntype IWarningInfo = IMap<any>;\r\n\r\n\r\nfunction validate(instr: IInstruction, expectedType: EInstructionTypes) {\r\n    assert(instr.instructionType === expectedType);\r\n}\r\n\r\n// TODO: refactor it\r\nfunction findConstructor(type: ITypeInstruction, args: IExprInstruction[]): IVariableTypeInstruction {\r\n    return new VariableTypeInstruction({ type, scope: null });\r\n}\r\n\r\n\r\nfunction _errorFromInstruction(context: Context, sourceNode: IParseNode, pError: IInstructionError): void {\r\n    context.error(sourceNode, pError.code, isNull(pError.info) ? {} : pError.info);\r\n}\r\n\r\n\r\nfunction checkInstruction<INSTR_T extends IInstruction>(context: Context, inst: INSTR_T, stage: ECheckStage): INSTR_T {\r\n    // TODO: rework this api\r\n    if (!inst._check(stage)) {\r\n        _errorFromInstruction(context, inst.sourceNode, inst._getLastError());\r\n        return null;\r\n    }\r\n    return inst;\r\n}\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\n\r\n// FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\nconst asRelaxedType = (instr: ITypedInstruction): ITypeInstruction | RegExp => {\r\n    if (!instr) {\r\n        return null;\r\n    }\r\n\r\n    // if (instruction.isLiteral(instr)) {\r\n        if (instr.type.isEqual(T_INT) || instr.type.isEqual(T_UINT)) {\r\n            // temp workaround in order to match int to uint and etc. \r\n            return /^int$|^uint$/g;\r\n        }\r\n    // }\r\n\r\n    return instr.type;\r\n};\r\n\r\n// TODO: rework 'auto' api\r\nfunction tryResolveProxyType(type: IVariableTypeInstruction, host: ITypeInstruction) {\r\n    if (type.subType.instructionType === EInstructionTypes.k_ProxyType) {\r\n        const proxy = <ProxyTypeInstruction>type.subType;\r\n        if (!proxy.isResolved()) {\r\n            proxy.resolve(host);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction getRenderStateValue(state: ERenderStates, value: string): ERenderStateValues {\r\n    let eValue: ERenderStateValues = ERenderStateValues.UNDEF;\r\n\r\n    switch (state) {\r\n        case ERenderStates.ALPHABLENDENABLE:\r\n        case ERenderStates.ALPHATESTENABLE:\r\n            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');\r\n            return ERenderStateValues.UNDEF;\r\n\r\n        case ERenderStates.BLENDENABLE:\r\n        case ERenderStates.CULLFACEENABLE:\r\n        case ERenderStates.ZENABLE:\r\n        case ERenderStates.ZWRITEENABLE:\r\n        case ERenderStates.DITHERENABLE:\r\n        case ERenderStates.SCISSORTESTENABLE:\r\n        case ERenderStates.STENCILTESTENABLE:\r\n        case ERenderStates.POLYGONOFFSETFILLENABLE:\r\n            switch (value) {\r\n                case 'TRUE':\r\n                    eValue = ERenderStateValues.TRUE;\r\n                    break;\r\n                case 'FALSE':\r\n                    eValue = ERenderStateValues.FALSE;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '\r\n                        + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.CULLFACE:\r\n            switch (value) {\r\n                case 'FRONT':\r\n                    eValue = ERenderStateValues.FRONT;\r\n                    break;\r\n                case 'BACK':\r\n                    eValue = ERenderStateValues.BACK;\r\n                    break\r\n                case 'FRONT_AND_BACK':\r\n                    eValue = ERenderStateValues.FRONT_AND_BACK;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.FRONTFACE:\r\n            switch (value) {\r\n                case 'CW':\r\n                    eValue = ERenderStateValues.CW;\r\n                    break;\r\n                case 'CCW':\r\n                    eValue = ERenderStateValues.CCW;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.SRCBLEND:\r\n        case ERenderStates.DESTBLEND:\r\n        case ERenderStates.SRCBLENDALPHA:\r\n        case ERenderStates.DESTBLENDALPHA:\r\n        case ERenderStates.SRCBLENDCOLOR:\r\n        case ERenderStates.DESTBLENDCOLOR:\r\n        case ERenderStates.BLENDFUNC:\r\n        case ERenderStates.BLENDFUNCSEPARATE:\r\n            switch (value) {\r\n                case 'ZERO':\r\n                    eValue = ERenderStateValues.ZERO;\r\n                    break;\r\n                case 'ONE':\r\n                    eValue = ERenderStateValues.ONE;\r\n                    break;\r\n                case 'SRCCOLOR':\r\n                    eValue = ERenderStateValues.SRCCOLOR;\r\n                    break;\r\n                case 'INVSRCCOLOR':\r\n                    eValue = ERenderStateValues.INVSRCCOLOR;\r\n                    break;\r\n                case 'SRCALPHA':\r\n                    eValue = ERenderStateValues.SRCALPHA;\r\n                    break;\r\n                case 'INVSRCALPHA':\r\n                    eValue = ERenderStateValues.INVSRCALPHA;\r\n                    break;\r\n                case 'DESTALPHA':\r\n                    eValue = ERenderStateValues.DESTALPHA;\r\n                    break;\r\n                case 'INVDESTALPHA':\r\n                    eValue = ERenderStateValues.INVDESTALPHA;\r\n                    break;\r\n                case 'DESTCOLOR':\r\n                    eValue = ERenderStateValues.DESTCOLOR;\r\n                    break;\r\n                case 'INVDESTCOLOR':\r\n                    eValue = ERenderStateValues.INVDESTCOLOR;\r\n                    break;\r\n                case 'SRCALPHASAT':\r\n                    eValue = ERenderStateValues.SRCALPHASAT;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.BLENDEQUATION:\r\n        case ERenderStates.BLENDEQUATIONSEPARATE:\r\n        case ERenderStates.BLENDEQUATIONCOLOR:\r\n        case ERenderStates.BLENDEQUATIONALPHA:\r\n            switch (value) {\r\n                case 'FUNCADD':\r\n                case 'ADD':\r\n                    eValue = ERenderStateValues.FUNCADD;\r\n                    break;\r\n                case 'FUNCSUBTRACT':\r\n                case 'SUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCSUBTRACT;\r\n                    break;\r\n                case 'FUNCREVERSESUBTRACT':\r\n                case 'REVERSESUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCREVERSESUBTRACT;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.ZFUNC:\r\n            switch (value) {\r\n                case 'NEVER':\r\n                    eValue = ERenderStateValues.NEVER;\r\n                    break;\r\n                case 'LESS':\r\n                    eValue = ERenderStateValues.LESS;\r\n                    break;\r\n                case 'EQUAL':\r\n                    eValue = ERenderStateValues.EQUAL;\r\n                    break;\r\n                case 'LESSEQUAL':\r\n                    eValue = ERenderStateValues.LESSEQUAL;\r\n                    break;\r\n                case 'GREATER':\r\n                    eValue = ERenderStateValues.GREATER;\r\n                    break;\r\n                case 'NOTEQUAL':\r\n                    eValue = ERenderStateValues.NOTEQUAL;\r\n                    break;\r\n                case 'GREATEREQUAL':\r\n                    eValue = ERenderStateValues.GREATEREQUAL;\r\n                    break;\r\n                case 'ALWAYS':\r\n                    eValue = ERenderStateValues.ALWAYS;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n        case ERenderStates.PRIMITIVETOPOLOGY:\r\n            switch (value) {\r\n                case 'TRIANGLELIST':\r\n                    eValue = ERenderStateValues.TRIANGLELIST;\r\n                    break;\r\n                case 'LINELIST':\r\n                    eValue = ERenderStateValues.LINELIST;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n    }\r\n\r\n    return eValue;\r\n}\r\n\r\n\r\n\r\n\r\nfunction addTypeDecl(context: Context, scope: IScope, typeDecl: ITypeDeclInstruction): void {\r\n    if (SystemScope.findType(typeDecl.name)) {\r\n        context.error(typeDecl.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n\r\n    let isAdded = scope.addType(typeDecl.type);\r\n    if (!isAdded) {\r\n        context.error(typeDecl.sourceNode, EErrors.TypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction checkFunctionForRecursion(context: Context, func: IFunctionDeclInstruction, stack: number[]): boolean {\r\n    if (stack.indexOf(func.instructionID) !== -1) {\r\n        context.error(func.sourceNode,\r\n            EErrors.InvalidFunctionRecursionNotAllowed,\r\n            { funcName: func.name });\r\n        return false;\r\n    }\r\n\r\n    let recursionFound = false;\r\n\r\n    stack = [...stack, func.instructionID];\r\n    const recursionChecker = (instr: IInstruction) => {\r\n        if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n            let fcall = (instr as IFunctionCallInstruction);\r\n            let fdecl = fcall.decl;\r\n            if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                return;\r\n            }\r\n\r\n            // NOTE: it is possible that the declaration was not complete \r\n            //       at the time of the call, so you need to look for a \r\n            //       version with implementation\r\n            fdecl = fdecl.scope.findFunctionInScope(fdecl);\r\n            if (isNull(fdecl.impl)) {\r\n                context.error(instr.sourceNode,\r\n                    EErrors.InvalidFunctionImplementationNotFound,\r\n                    { funcName: fdecl.name });\r\n                return;\r\n            }\r\n\r\n            // visitor(fdecl.impl, recursionChecker);\r\n            recursionFound = recursionFound ||\r\n                checkFunctionForRecursion(context, fdecl, stack);\r\n        }\r\n    };\r\n\r\n    visitor(func.impl, recursionChecker);\r\n\r\n    return !recursionFound;\r\n}\r\n\r\nfunction checkFunctionsForRecursion(context: Context, program: ProgramScope) {\r\n    const gs = program.globalScope;\r\n\r\n    let recusrionFound = false;\r\n    mwalk(gs.functions, funcOverloads => {\r\n        funcOverloads.forEach(func => {\r\n            recusrionFound = recusrionFound ||\r\n                !checkFunctionForRecursion(context, func, []);\r\n        })\r\n    });\r\n\r\n    return !recusrionFound;\r\n}\r\n\r\n\r\n\r\nfunction checkForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nfunction checkReturnTypeForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    const returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (returnType.isEqual(SystemScope.T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    if (returnType.isComplex()) {\r\n        if (returnType.hasFieldWithoutSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        if (!returnType.hasAllUniqueSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        // isGood = returnType._hasFieldWithSematic(\"POSITION\");\r\n        // if(!isGood){\r\n        // \treturn false;\r\n        // }\r\n\r\n        // samplers cant be interpolators\r\n        if (returnType.isContainSampler()) {\r\n            return false;\r\n        }\r\n\r\n        // Forbid fileds with user-defined types\r\n        // or any other complex types.\r\n        if (returnType.isContainComplexType()) {\r\n            return false;\r\n        }\r\n    } else {\r\n        if (!returnType.isEqual(SystemScope.T_FLOAT4)) {\r\n            return false;\r\n        }\r\n\r\n        if (funcDef.semantic !== \"POSITION\") {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// todo: add support for dual source blending\r\n// todo: add support for MRT\r\nfunction checkReturnTypeForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (returnType.isEqual(SystemScope.T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    // TODO: add MRT support\r\n    if (!returnType.isBase()) {\r\n        return false;\r\n    }\r\n\r\n    if (!returnType.isEqual(SystemScope.T_FLOAT4)) {\r\n        return false;\r\n    }\r\n\r\n    if (funcDef.semantic !== \"COLOR\") {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isAttributeByStruct = false;\r\n    let isAttributeByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (isNull(param.semantic)) {\r\n                if (param.type.isBase() ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByStruct = true;\r\n            } else if (!isNull(param.semantic)) {\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        } else if (isAttributeByStruct) {\r\n            return false;\r\n        } else if (isAttributeByParams) {\r\n            if (isNull(param.semantic)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isVaryingsByStruct = false;\r\n    let isVaryingsByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param: IVariableDeclInstruction = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (param.semantic === \"\") {\r\n                if (param.type.isBase() ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics() ||\r\n                    param.type.isContainSampler()) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByStruct = true;\r\n            } else if (param.semantic !== \"\") {\r\n                if (param.type.isContainSampler() ||\r\n                    SystemScope.isSamplerType(param.type)) {\r\n                    return false;\r\n                }\r\n\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        }\r\n        else if (isVaryingsByStruct) {\r\n            return false;\r\n        }\r\n        else if (isVaryingsByParams) {\r\n            if (param.semantic === \"\") {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isContainSampler() ||\r\n                SystemScope.isSamplerType(param.type)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nexport interface ICompileValidator {\r\n    // validate with custom arguments ignoring statements inside compile expression.\r\n    args?: ITypeInstruction[];\r\n    ret?: ITypeInstruction;\r\n}\r\n\r\n\r\n\r\nexport class Context {\r\n    readonly uri: string | null;\r\n    readonly diagnostics: AnalyzerDiagnostics;\r\n\r\n    /** driven from provide declaration */\r\n    moduleName: string | null;\r\n\r\n    // funct states\r\n    func: boolean;                              // Are we inside a function analysis?\r\n    funcDef: IFunctionDefInstruction | null;    // Current function definition.\r\n    haveCurrentFunctionReturnOccur: boolean;    // TODO: replace with array of return statements.\r\n\r\n    renderStates: IMap<ERenderStateValues>;\r\n\r\n    constructor(uri: string) {\r\n        this.diagnostics = new AnalyzerDiagnostics;\r\n        this.uri = uri;\r\n        this.moduleName = null;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n    }\r\n\r\n\r\n    beginFunc(): void {\r\n        this.func = true;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.funcDef = null; // << will be set inside analyzeFunctionDecl();\r\n    }\r\n\r\n    endFunc(): void {\r\n        this.func = false\r\n    }\r\n\r\n\r\n    beginPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n    endPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n\r\n    error(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.error(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    critical(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.critical(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    warn(sourceNode: IParseNode, code: number, info: IWarningInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.warning(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    private resolveNodeSourceLocation(sourceNode: IParseNode): IRange {\r\n        if (!isDefAndNotNull(sourceNode)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(sourceNode.loc)) {\r\n            return sourceNode.loc;\r\n        }\r\n\r\n        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Analyzer {\r\n\r\n\r\n    protected analyzeUseDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): void {\r\n        program.currentScope.strictMode = true;\r\n    }\r\n\r\n\r\n    protected analyzeComplexName(sourceNode: IParseNode): string {\r\n        const children = sourceNode.children;\r\n        let name: string = '';\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            name += children[i].value;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ProvideDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_PROVIDE = 'provide'\r\n     */\r\n    protected analyzeProvideDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IProvideInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children.length === 3) {\r\n            let moduleName = this.analyzeComplexName(children[1]);;\r\n            if (!isNull(context.moduleName)) {\r\n                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);\r\n            }\r\n            context.moduleName = moduleName;\r\n            assert(children[2].name === 'T_KW_PROVIDE');\r\n            return new ProvideInstruction({ sourceNode, moduleName, scope });\r\n        }\r\n\r\n        context.error(sourceNode, EErrors.UnsupportedProvideAs);\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     */\r\n    protected analyzeInitExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IInitExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let args: IExprInstruction[] = [];\r\n\r\n        if (children.length === 1) {\r\n            args.push(this.analyzeExpr(context, program, children[0]));\r\n        }\r\n        else {\r\n            for (let i = 0; i < children.length; i++) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    args.push(this.analyzeInitExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: determ type!!\r\n        const initExpr: IInitExprInstruction = new InitExprInstruction({ scope, sourceNode, args, type: null });\r\n        return initExpr;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVariableDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);\r\n        const vars: IVariableDeclInstruction[] = [];\r\n\r\n        if (isNull(generalType)) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars.push(this.analyzeVariable(context, program, children[i], generalType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UsageType\r\n     *       + Type \r\n     *       + Usage \r\n     */\r\n    protected analyzeUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        let usagesRaw: IVariableUsage[] = [];\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null\r\n                }\r\n            }\r\n            else if (children[i].name === 'Usage') {\r\n                usagesRaw.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        const usageIn = usagesRaw.indexOf('in') !== -1;\r\n        const usageOut = usagesRaw.indexOf('out') !== -1;\r\n        const usageInout = usagesRaw.indexOf('inout') !== -1;\r\n        const usageConst = usagesRaw.indexOf('const') !== -1;\r\n        const usageUniform = usagesRaw.indexOf('uniform') !== -1;\r\n\r\n        // TODO: emit errors in case of inconsistent usages\r\n        // TODO: remplace with bitflags\r\n        let usages: IVariableUsage[] = [];\r\n        if (usageInout) {\r\n            usages.push('inout');\r\n            // emit error in case of uniform\r\n            // emit error in case of const\r\n        } else {\r\n            if (usageIn && usageOut) {\r\n                usages.push('inout');\r\n                // emit error in case of uniform\r\n                // emit error in case of const\r\n            } else {\r\n                if (usageIn) {\r\n                    usages.push('in');\r\n                }\r\n                if (usageOut) {\r\n                    usages.push('out');\r\n                    // emit error in case of const\r\n                    // emit error in case of uniform\r\n                } else {\r\n                    if (usageConst) usages.push('const');\r\n                    if (usageUniform) usages.push('uniform');\r\n                }\r\n            }\r\n        }\r\n\r\n        let varType = new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n        return checkInstruction(context, varType, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Type\r\n     *         T_TYPE_ID = 'float3'\r\n     */\r\n    protected analyzeType(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n\r\n        switch (sourceNode.name) {\r\n            case 'T_TYPE_ID':\r\n                if (sourceNode.value === 'auto') {\r\n                    type = new ProxyTypeInstruction({ scope });\r\n                    break;\r\n                }\r\n\r\n                type = scope.findType(sourceNode.value);\r\n\r\n                if (isNull(type)) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });\r\n                }\r\n                break;\r\n            case 'Struct':\r\n                type = this.analyzeStruct(context, program, sourceNode);\r\n                break;\r\n\r\n            case 'T_KW_VOID':\r\n                type = T_VOID;\r\n                break;\r\n\r\n            case 'ScalarType':\r\n            case 'ObjectType':\r\n                {\r\n                    let typeName = children[children.length - 1].value;\r\n\r\n                    if (children.length !== 1) {\r\n                        assert(children[children.length - 2].value === '<' && children[0].value === '>');\r\n                        const tplName = typeName;\r\n                        const args = children\r\n                            .slice(1, -2)\r\n                            .reverse()\r\n                            .filter((v, i) => i % 2 == 0)\r\n                            .map(sourceNode => this.analyzeType(context, program, sourceNode));\r\n\r\n                        const template = scope.findTypeTemplate(typeName);\r\n\r\n                        if (isNull(template)) {\r\n                            context.error(sourceNode, EErrors.InvalidTypeNameTemplateNotFound,\r\n                                { tplName, args: args.map(arg => arg.toCode()) });\r\n                            return null;\r\n                        }\r\n\r\n                        // TODO: validate register\r\n                        // TODO: use ESystemTypes enumeration\r\n                        const SYSTEM_TYPES = ['RWBuffer', 'RWStructuredBuffer', 'AppendStructuredBuffer'];\r\n                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {\r\n                            if (scope.type != EScopeType.k_Global) {\r\n                                context.error(sourceNode, EErrors.InvalidTypeScope,\r\n                                    { typeName: template.name, tooltip: 'only global scope allowed' });\r\n                                return null;\r\n                            }\r\n                        }\r\n\r\n                        typeName = template.typeName(args);\r\n                        type = scope.findType(typeName);\r\n\r\n                        if (isNull(type)) {\r\n                            type = template.produceType(scope, args);\r\n                            if (isNull(type)) {\r\n                                context.error(sourceNode, EErrors.CannotProduceType, { typeName });\r\n                                return null;\r\n                            }\r\n                            scope.addType(type);\r\n                        }\r\n                    } else {\r\n                        type = scope.findType(typeName);\r\n                    }\r\n\r\n                    if (isNull(type)) {\r\n                        context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName });\r\n                        return null;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case 'VectorType':\r\n            case 'MatrixType':\r\n                context.error(sourceNode, EErrors.InvalidTypeVectorMatrix);\r\n                break;\r\n\r\n            case 'BaseType':\r\n            case 'Type':\r\n                return this.analyzeType(context, program, children[0]);\r\n        }\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    protected analyzeUsage(sourceNode: IParseNode): IVariableUsage {\r\n        sourceNode = sourceNode.children[0];\r\n        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout'];\r\n        assert(supportedUsages.indexOf(sourceNode.value) !== -1);\r\n        return <IVariableUsage>sourceNode.value;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Variable\r\n     *       + Initializer \r\n     *       + Semantic \r\n     *       + VariableDim\r\n     *              T_PUNCTUATOR_93 = ']'\r\n     *              T_NON_TYPE_ID = 'N'\r\n     *              T_PUNCTUATOR_91 = '['\r\n     *            + VariableDim\r\n     *                   T_NON_TYPE_ID = 'x'\r\n     *                   ^^^^^^^^^^^^^^^^^^\r\n     */\r\n    protected analyzeVariable(context: Context, program: ProgramScope, sourceNode: IParseNode, generalType: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let init: IInitExprInstruction = null;\r\n        let semantic = '';\r\n        let usageFlags = 0;\r\n\r\n        if (!context.func) {\r\n            usageFlags |= EVariableUsageFlags.k_Global;\r\n        } else {\r\n            // All variables found inside function definition are arguments.\r\n            if (!context.funcDef) {\r\n                usageFlags |= EVariableUsageFlags.k_Argument;\r\n            }\r\n            usageFlags |= EVariableUsageFlags.k_Local;\r\n        }\r\n\r\n\r\n        let id: IIdInstruction = null;\r\n        let arrayIndex: IExprInstruction = null;\r\n        let type: IVariableTypeInstruction = null;\r\n\r\n        let vdimNode = children[children.length - 1];\r\n        do {\r\n            let vdimChildren = vdimNode.children;\r\n\r\n            if (vdimChildren.length === 1) {\r\n                const name = vdimChildren[0].value;\r\n                id = new IdInstruction({ scope, sourceNode, name });\r\n                break;\r\n            }\r\n\r\n            assert(vdimChildren.length == 4);\r\n\r\n            if (!isNull(arrayIndex)) {\r\n                // usage of generalType.source node instead of sourceNode was done for more clear debugging\r\n                generalType = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n            }\r\n\r\n            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);\r\n            vdimNode = vdimChildren[vdimChildren.length - 1];\r\n        } while (true);\r\n\r\n        // using generalType.source node instead of sourceNode was done for more clear degging\r\n        type = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n\r\n        for (let i = children.length - 2; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else if (children[i].name === 'Initializer') {\r\n                let args = this.analyzeInitializerArguments(context, program, children[i]);\r\n                init = new InitExprInstruction({ scope, sourceNode: children[i], args, type });\r\n\r\n                let isValidInit = false;\r\n                try {\r\n                    isValidInit = init.optimizeForVariableType(type);\r\n                } catch (e) { };\r\n\r\n                if (!isValidInit) {\r\n                    // TODO: make it warning\r\n                    context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n                    init = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        const varDecl = new VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });\r\n        assert(scope.type != EScopeType.k_System);\r\n\r\n        if (SystemScope.hasVariable(varDecl.name)) {\r\n            context.error(sourceNode, EErrors.SystemVariableRedefinition, { varName: varDecl.name });\r\n        }\r\n\r\n        const isAdded = scope.addVariable(varDecl);\r\n        if (!isAdded) {\r\n            switch (scope.type) {\r\n                case EScopeType.k_Global:\r\n                case EScopeType.k_Default:\r\n                    context.error(sourceNode, EErrors.VariableRedefinition, { varName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Struct:\r\n                    context.error(sourceNode, EErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Annotation:\r\n                    context.error(sourceNode, EErrors.InvalidNewAnnotationVar, { varName: varDecl.name });\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return checkInstruction(context, varDecl, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Annotation\r\n     *         T_PUNCTUATOR_62 = '>'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     */\r\n    protected analyzeAnnotation(sourceNode: IParseNode): IAnnotationInstruction {\r\n        // todo\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_NON_TYPE_ID = 'SEMANTIC'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'u2'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_REGISTER = 'register'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    protected analyzeSemantic(sourceNode: IParseNode): string {\r\n        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Initializer\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *       + CastExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     */\r\n    protected analyzeInitializerArguments(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let args: IExprInstruction[] = [];\r\n\r\n        if (children.length === 2) {\r\n            args.push(this.analyzeExpr(context, program, children[0]));\r\n        }\r\n        else {\r\n            for (let i = children.length - 3; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    args.push(this.analyzeInitExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        return args;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n\r\n        switch (name) {\r\n            case 'ObjectExpr':\r\n                return this.analyzeObjectExpr(context, program, sourceNode);\r\n            case 'ComplexExpr':\r\n                return this.analyzeComplexExpr(context, program, sourceNode);\r\n            case 'PostfixExpr':\r\n                return this.analyzePostfixExpr(context, program, sourceNode);\r\n            case 'UnaryExpr':\r\n                return this.analyzeUnaryExpr(context, program, sourceNode);\r\n            case 'CastExpr':\r\n                return this.analyzeCastExpr(context, program, sourceNode);\r\n            case 'ConditionalExpr':\r\n                return this.analyzeConditionalExpr(context, program, sourceNode);\r\n            case 'MulExpr':\r\n            case 'AddExpr':\r\n                return this.analyzeArithmeticExpr(context, program, sourceNode);\r\n            case 'RelationalExpr':\r\n            case 'EqualityExpr':\r\n                return this.analyzeRelationExpr(context, program, sourceNode);\r\n            case 'AndExpr':\r\n            case 'OrExpr':\r\n                return this.analyzeLogicalExpr(context, program, sourceNode);\r\n            case 'AssignmentExpr':\r\n                return this.analyzeAssignmentExpr(context, program, sourceNode);\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeIdExpr(context, program, sourceNode);\r\n            case 'T_STRING':\r\n            case 'T_UINT':\r\n            case 'T_FLOAT':\r\n            case 'T_KW_TRUE':\r\n            case 'T_KW_FALSE':\r\n                return this.analyzeSimpleExpr(context, program, sourceNode);\r\n            default:\r\n                context.error(sourceNode, EErrors.UnsupportedExpr, { exprName: name });\r\n                break;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'fs_skybox'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeObjectExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        let name = sourceNode.children[sourceNode.children.length - 1].name;\r\n\r\n        switch (name) {\r\n            case 'T_KW_COMPILE':\r\n                return this.analyzeCompileExpr(context, program, sourceNode);\r\n            case 'T_KW_SAMPLER_STATE':\r\n                return this.analyzeSamplerStateBlock(context, program, sourceNode);\r\n            default:\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'main'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeCompileExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, validators?: ICompileValidator[]): CompileExprInstruction {\r\n        const children = sourceNode.children;\r\n        const shaderFuncName = children[children.length - 2].value;\r\n        const scope = program.currentScope;\r\n\r\n        let compileArgs: IExprInstruction[] = null;\r\n        let retType: ITypeInstruction = null;\r\n        let args: ITypeInstruction[] = null;\r\n\r\n        if (children.length > 4) {\r\n            compileArgs = [];\r\n            for (let i = children.length - 4; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    compileArgs.push(this.analyzeExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        args = compileArgs ? compileArgs.map(asType) : null;\r\n\r\n        let func: IFunctionDeclInstruction = null;\r\n\r\n        if (validators) {\r\n            for (let validator of validators) {\r\n                args = compileArgs ? compileArgs.map(asType) : null;\r\n                retType = null;\r\n\r\n                args = validator.args || args;\r\n                retType = validator.ret || retType;\r\n\r\n                func = program.globalScope.findFunction(shaderFuncName, args);\r\n                if (func) {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            func = program.globalScope.findFunction(shaderFuncName, args);\r\n        }\r\n\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });\r\n            return null;\r\n        }\r\n\r\n        if (retType) {\r\n            if (!func.def.returnType.isEqual(retType)) {\r\n                context.error(sourceNode, EErrors.InvalidCompileFunctionNotValid, {\r\n                    funcName: shaderFuncName,\r\n                    funcType: retType.toCode(),\r\n                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `\r\n                });\r\n                return null;\r\n            }\r\n        }\r\n\r\n        let type = VariableTypeInstruction.wrap(<IVariableTypeInstruction>func.def.returnType, scope);\r\n\r\n        let expr = new CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     */\r\n    protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        sourceNode = sourceNode.children[0];\r\n\r\n        let scope = program.currentScope;\r\n        let children = sourceNode.children;\r\n        let operator: SamplerOperator = \"sampler_state\";\r\n        let texture = null;\r\n        let params = <ISamplerStateInstruction[]>[];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let param = this.analyzeSamplerState(context, program, children[i]);\r\n            if (!isNull(param)) {\r\n                params.push(param);\r\n            }\r\n        }\r\n\r\n        let expr = new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });\r\n        checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return expr;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    State\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         StateExpr\r\n     *              T_PUNCTUATOR_62 = '>'\r\n     *              T_NON_TYPE_ID = 'tex0'\r\n     *              T_PUNCTUATOR_60 = '<'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'Texture'\r\n     */\r\n    protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children[children.length - 2].name === 'StateIndex') {\r\n            context.error(sourceNode, EErrors.UnsupportedStateIndex);\r\n            return null;\r\n        }\r\n\r\n        let stateExprNode = children[children.length - 3];\r\n        let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n        let stateType = children[children.length - 1].value.toUpperCase();\r\n        let stateValue = '';\r\n\r\n        if (isNull(subStateExprNode.value)) {\r\n            context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n            return null;\r\n        }\r\n\r\n        switch (stateType) {\r\n            case 'TEXTURE':\r\n                if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {\r\n                    context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n                    return null;\r\n                }\r\n\r\n                let texNameNode = stateExprNode.children[1];\r\n                let texName = texNameNode.value;\r\n                if (isNull(texName) || !scope.findVariable(texName)) {\r\n                    context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);\r\n                    return null;\r\n                }\r\n\r\n                let texDecl = scope.findVariable(texName);\r\n                let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });\r\n                let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });\r\n\r\n                return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });\r\n            case 'ADDRESSU': /* WRAP_S */\r\n            case 'ADDRESSV': /* WRAP_T */\r\n                stateValue = subStateExprNode.value.toUpperCase();\r\n                switch (stateValue) {\r\n                    case 'WRAP':\r\n                    case 'CLAMP':\r\n                    case 'MIRROR':\r\n                        break;\r\n                    default:\r\n                        // TODO: move to errors\r\n                        // console.warn('Webgl don`t support this wrapmode: ' + stateValue);\r\n                        return null;\r\n                }\r\n                break;\r\n\r\n            case 'MAGFILTER':\r\n            case 'MINFILTER':\r\n                stateValue = subStateExprNode.value.toUpperCase();\r\n                switch (stateValue) {\r\n                    case 'POINT':\r\n                        stateValue = 'NEAREST';\r\n                        break;\r\n                    case 'POINT_MIPMAP_POINT':\r\n                        stateValue = 'NEAREST_MIPMAP_NEAREST';\r\n                        break;\r\n                    case 'LINEAR_MIPMAP_POINT':\r\n                        stateValue = 'LINEAR_MIPMAP_NEAREST';\r\n                        break;\r\n                    case 'POINT_MIPMAP_LINEAR':\r\n                        stateValue = 'NEAREST_MIPMAP_LINEAR';\r\n                        break;\r\n\r\n                    case 'NEAREST':\r\n                    case 'LINEAR':\r\n                    case 'NEAREST_MIPMAP_NEAREST':\r\n                    case 'LINEAR_MIPMAP_NEAREST':\r\n                    case 'NEAREST_MIPMAP_LINEAR':\r\n                    case 'LINEAR_MIPMAP_LINEAR':\r\n                        break;\r\n                    default:\r\n                        // TODO: move to erros api\r\n                        // console.warn('Webgl don`t support this texture filter: ' + stateValue);\r\n                        return null;\r\n                }\r\n                break;\r\n\r\n            default:\r\n                // TODO: move to erros api\r\n                console.warn('Don`t support this texture param: ' + stateType);\r\n                return null;\r\n        }\r\n\r\n        return new SamplerStateInstruction({\r\n            sourceNode,\r\n            scope,\r\n            name: stateType,\r\n            value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_FLOAT = '2.'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_FLOAT = '1.'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_TYPE_ID = 'float4'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + PostfixPointExpr \r\n     */\r\n    protected analyzeComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'PostfixPointExpr':\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeFunctionCallExpr(context, program, sourceNode);\r\n            case 'BaseType':\r\n            case 'T_TYPE_ID':\r\n                return this.analyzeConstructorCallExpr(context, program, sourceNode);\r\n            default:\r\n                return this.analyzeSimpleComplexExpr(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    protected analyzeCallee(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        return this.analyzeExpr(context, program, children[children.length - 1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'a'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'foo'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PostfixPointExpr\r\n     *         T_NON_TYPE_ID = 'IncrementCounter'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *       + PostfixExpr \r\n     */\r\n    protected analyzeFunctionCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        \r\n        const firstNodeName = children[children.length - 1].name;\r\n \r\n        const args: IExprInstruction[] = [];\r\n        if (children.length > 3) {\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    const arg = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(arg);\r\n                }\r\n            }\r\n        }\r\n\r\n        let funcName: string = null;\r\n        let func: IFunctionDeclInstruction = null;\r\n        let callee: IExprInstruction = null;\r\n\r\n        switch (firstNodeName) {\r\n            // call as function\r\n            case 'T_NON_TYPE_ID':\r\n                {\r\n                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address\r\n                    funcName = children[children.length - 1].value;\r\n                    func = globalScope.findFunction(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n            // call as method\r\n            case 'PostfixPointExpr':\r\n                {\r\n                    callee = this.analyzeCallee(context, program, children[children.length - 1]);\r\n                    funcName = children[children.length - 1].children[0].value; // method name\r\n                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n        }\r\n        \r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (func.instructionType !== EInstructionTypes.k_FunctionDecl &&\r\n            func.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            console.error(\"@undefined_behavior\");\r\n            return null;\r\n        }\r\n\r\n\r\n\r\n        const params = func.def.params;\r\n\r\n        for (let i = 0; i < args.length; i++) {\r\n            if (isNull(args[i])) {\r\n                continue;\r\n            }\r\n            if (params[i].type.hasUsage('out')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                    return null;\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                    return null;\r\n                }\r\n            } else if (params[i].type.hasUsage('inout')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                    return null;\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                    return null;\r\n                }\r\n\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            } else {\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        const type = VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?\r\n        const expr = new FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });\r\n\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + BaseType \r\n     */\r\n    protected analyzeConstructorCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IConstructorCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const ctorType = this.analyzeType(context, program, children[children.length - 1]);\r\n\r\n        if (isNull(ctorType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotType);\r\n            return null;\r\n        }\r\n\r\n        let args: IExprInstruction[] = null;\r\n        if (children.length > 3) {\r\n            let argumentExpr: IExprInstruction = null;\r\n\r\n            args = [];\r\n\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: add correct implementation! \r\n        const exprType = findConstructor(ctorType, args);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(args)) {\r\n            for (let i = 0; i < args.length; i++) {\r\n                if (!args[i].type.readable) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n        const expr = new ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    // TODO: add comment!\r\n    protected analyzeSimpleComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[1]);\r\n        if (isNull(expr)) {\r\n            return null\r\n        }\r\n        // let type = <IVariableTypeInstruction>expr.type;\r\n\r\n        let complexExpr = new ComplexExprInstruction({ scope, sourceNode, expr });\r\n        return checkInstruction(context, complexExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const symbol = children[children.length - 2].value;\r\n\r\n        switch (symbol) {\r\n            case '[':\r\n                return this.analyzePostfixIndex(context, program, sourceNode);\r\n            case '.':\r\n                return this.analyzePostfixPoint(context, program, sourceNode);\r\n            case '++':\r\n            case '--':\r\n                return this.analyzePostfixArithmetic(context, program, sourceNode);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixIndex(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(postfixExpr)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        if (!postfixExprType.isArray()) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });\r\n            return null;\r\n        }\r\n\r\n        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const indexExprType = indexExpr.type;\r\n\r\n        if (!(indexExprType.isEqual(T_INT) || indexExprType.isEqual(T_UINT))) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     * @param fieldName \r\n     */\r\n    protected createFieldDecl(elementType: IVariableTypeInstruction, fieldName: string): IVariableDeclInstruction {\r\n        if (!elementType.hasField(fieldName)) {\r\n            return null;\r\n        }\r\n\r\n        // in case of typical postfix exp. like \"element.postfix\":\r\n        //      elementType => type defrived from the parameter or variable declaration or derived from another expr\r\n        //      elementType.subType => original complex (structure) type\r\n        // in case of something else, like ccall with postfix \"float2(1.0, 2.0).yx\":\r\n        //      elementType => original system type\r\n\r\n        const scope = elementType.scope;\r\n        const { id, type, type: { padding, length }, semantic } =\r\n            // FIXME: remove 'logical OR' operation, always use subType\r\n            (elementType.subType || elementType).getField(fieldName); // arrayIndex\r\n\r\n\r\n\r\n        // note: sourceNode for field is being used from the original complex structure.\r\n\r\n        // let arrayIndex: IExprInstruction = null;\r\n        // if (type.isNotBaseArray()) {\r\n        //     // using of length instead of arrayIndex because of lack of api functionality :/\r\n        //     assert(length != Instruction.UNDEFINE_LENGTH, \"undefined behaviour found\");\r\n        //     arrayIndex = new IntInstruction({ scope, value: String(length) });\r\n        // }\r\n\r\n        const fieldType = new VariableTypeInstruction({ type, scope, padding, sourceNode: type.sourceNode/*, arrayIndex*/ });\r\n        const fieldId = new IdInstruction({ scope, name: id.name, sourceNode: id.sourceNode });\r\n        const field = new VariableDeclInstruction({ scope, id: fieldId, type: fieldType, semantic, sourceNode: fieldId.sourceNode });\r\n\r\n        return Instruction.$withParent(field, elementType);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     */\r\n    protected analyzePostfixPointField(context: Context, program: ProgramScope, sourceNode: IParseNode, elementType: IVariableTypeInstruction): IIdExprInstruction {\r\n        if (isNull(elementType)) {\r\n            return null;\r\n        }\r\n\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;                             // fiedl name\r\n        // const decl = this.createFieldDecl(elementType, name);   // field decl\r\n        const decl = elementType.getField(name);\r\n\r\n        if (isNull(decl)) {\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        const expr = new IdExprInstruction({ scope, sourceNode, id, decl });\r\n\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    /** \r\n     * Expressions like: \r\n     *      **(element.postfix)** \r\n     */\r\n    protected analyzePostfixPoint(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const element = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(element)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);\r\n\r\n        if (isNull(postfix)) {\r\n            const fieldName = children[children.length - 3].value;\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixPointInstruction({ sourceNode, scope, element, postfix });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     */\r\n    protected analyzePostfixArithmetic(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <PostfixOperator>children[0].value;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[1]);\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixArithmetic, {\r\n                operator: operator,\r\n                typeName: String(postfixExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UnaryExpr\r\n     *         T_NON_TYPE_ID = 'x'\r\n     *         T_PUNCTUATOR_33 = '!'\r\n     */\r\n    protected analyzeUnaryExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const operator = <IUnaryOperator>children[1].value;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[0]);\r\n        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidUnaryOperation, {\r\n                operator: operator,\r\n                tyename: String(expr.type)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        let unaryExpr: IExprInstruction = null;\r\n\r\n        // shortcut for replacment of unary expressions with literals\r\n        if (operator === '-' || operator === '+') {\r\n            if (instruction.isLiteral(expr)) {\r\n                switch (expr.instructionType) {\r\n                    case EInstructionTypes.k_IntExpr:\r\n                        {\r\n                            let lit = <IntInstruction>expr;\r\n                            let signed = operator === '-' || lit.signed;\r\n                            unaryExpr = new IntInstruction({ scope, sourceNode, value: Number(`${operator}${lit.value}`), signed });\r\n                        }\r\n                        break;\r\n                    case EInstructionTypes.k_FloatExpr:\r\n                        unaryExpr = new FloatInstruction({ scope, sourceNode, value: Number(`${operator}${(<ILiteralInstruction<number>>expr).value}`) });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!unaryExpr) {\r\n            unaryExpr = new UnaryExprInstruction({ scope, sourceNode, expr, operator });\r\n        }\r\n\r\n        return checkInstruction(context, unaryExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CastExpr\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ConstType \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeCastExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n        const sourceExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(sourceExpr)) {\r\n            return null;\r\n        }\r\n\r\n        if (!(<IVariableTypeInstruction>sourceExpr.type).readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        const expr = new CastExprInstruction({ scope, sourceNode, sourceExpr, type });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConditionalExpr\r\n     *         T_KW_FALSE = 'false'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_63 = '?'\r\n     *         T_NON_TYPE_ID = 'isOk'\r\n     */\r\n    protected analyzeConditionalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n\r\n        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const rightExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(conditionExpr) || isNull(leftExpr) || isNull(rightExpr)) {\r\n            context.error(conditionExpr ? conditionExpr.sourceNode : sourceNode, EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        const conditionType = <IVariableTypeInstruction>conditionExpr.type;\r\n        const leftExprType = <IVariableTypeInstruction>leftExpr.type;\r\n        const rightExprType = <IVariableTypeInstruction>rightExpr.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!conditionType.isEqual(boolType)) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidConditionType, { typeName: String(conditionType) });\r\n            return null;\r\n        }\r\n\r\n        if (!leftExprType.isEqual(rightExprType)) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidConditonValueTypes, {\r\n                leftTypeName: String(leftExprType),\r\n                rightTypeName: String(rightExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!conditionType.readable) {\r\n            context.error(conditionType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!leftExprType.readable) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!rightExprType.readable) {\r\n            context.error(rightExprType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        const condExpr = new ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });\r\n        return checkInstruction(context, condExpr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AddExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_43 = '+'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeArithmeticExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope\r\n        const operator = <ArithmeticOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: '[unknown]',\r\n                rightTypeName: '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const arithmeticExpr = new ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });\r\n        return checkInstruction(context, arithmeticExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    RelationalExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeRelationExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <RelationOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = left ? left.type : null;\r\n        const rightType = right ? right.type : null;\r\n\r\n        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left ? left.sourceNode : null,\r\n            right ? right.sourceNode : null);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidRelationalOperation, {\r\n                operator: operator,\r\n                leftTypeName: leftType ? type.signature(leftType) : '[unknown]',\r\n                rightTypeName: rightType ? type.signature(rightType) : '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        const relationExpr = new RelationalExprInstruction({ sourceNode, scope, left, right, operator });\r\n        return checkInstruction(context, relationExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    OrExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_OP_OR = '||'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeLogicalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <ILogicalOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!leftType.isEqual(boolType)) {\r\n            context.error(leftType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(leftType)\r\n            });\r\n            return null;\r\n        }\r\n        if (!rightType.isEqual(boolType)) {\r\n            context.error(rightType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!leftType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!rightType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        let logicalExpr = new LogicalExprInstruction({ scope, sourceNode, left, right, operator });\r\n        return checkInstruction(context, logicalExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AssignmentExpr\r\n     *         T_UINT = '10'\r\n     *         T_OP_AE = '+='\r\n     *         T_NON_TYPE_ID = 'x'\r\n     */\r\n    protected analyzeAssignmentExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <AssigmentOperator>children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n\r\n        if (!expression.unwind(left)) {\r\n            // Invalid left-hand side in assignment\r\n            context.error(sourceNode, EErrors.InvalidLeftHandSideInAssignment, {\r\n                operator: operator\r\n            });\r\n        }\r\n\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(left) || isNull(right)) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        let exprType: IVariableTypeInstruction = null;\r\n\r\n        if (operator !== '=') {\r\n            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);\r\n            if (isNull(exprType)) {\r\n                context.error(sourceNode, EErrors.InvalidArithmeticAssigmentOperation, {\r\n                    operator: operator,\r\n                    leftTypeName: type.signature(leftType),\r\n                    rightTypeName: type.signature(rightType)\r\n                });\r\n            }\r\n        } else {\r\n            exprType = rightType;\r\n        }\r\n\r\n        // FIXME: show corrent source nodes for left and right expression.\r\n        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidAssigmentOperation, {\r\n                leftTypeName: type.signature(leftType),\r\n                rightTypeName: type.signature(rightType)\r\n            });\r\n        }\r\n\r\n        let assigmentExpr = new AssignmentExprInstruction({ scope, sourceNode, left, right, operator });\r\n        return checkInstruction(context, assigmentExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    T_NON_TYPE_ID = 'name'\r\n     */\r\n    protected analyzeIdExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        const expr = new IdExprInstruction({ scope, sourceNode, id, decl });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    protected analyzeSimpleExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n        const value = sourceNode.value;\r\n        const scope = program.currentScope;\r\n\r\n        switch (name) {\r\n            case 'T_UINT':\r\n                {\r\n                    const match = value.match(/^([0-9]+)(u?)$/);\r\n                    const signed = match[2] !== 'u';\r\n                    return new IntInstruction({ scope, sourceNode, value: Number(match[1]), signed });\r\n                }\r\n            case 'T_FLOAT':\r\n                return new FloatInstruction({ scope, sourceNode, value: Number(value) });\r\n            case 'T_STRING':\r\n                return new StringInstruction({ scope, sourceNode, value });\r\n            case 'T_KW_TRUE':\r\n                return new BoolInstruction({ scope, sourceNode, value: true });\r\n            case 'T_KW_FALSE':\r\n                return new BoolInstruction({ scope, sourceNode, value: false });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConstType\r\n     *       + Type \r\n     */\r\n    protected analyzeConstTypeDim(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length > 1) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeUsage);\r\n            return null;\r\n        }\r\n\r\n        const type = <IVariableTypeInstruction>(this.analyzeType(context, program, children[0]));\r\n\r\n        if (!type.isBase()) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeNotBase, { typeName: String(type) });\r\n        }\r\n\r\n        return checkInstruction(context, type, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVarStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n\r\n        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);\r\n        let vars: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    protected analyzeUsageStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'StructDecl') {\r\n                type = this.analyzeStructDecl(context, program, children[i]);\r\n                const typeDecl = new TypeDeclInstruction({ scope, sourceNode: children[i], type });\r\n                addTypeDecl(context, scope, typeDecl);\r\n            } else if (children[i].name === 'Usage') {\r\n                const usage = this.analyzeUsage(children[i]);\r\n                usages.push(usage);\r\n            }\r\n        }\r\n\r\n        assert(!isNull(type));\r\n        let varType = new VariableTypeInstruction({ scope, sourceNode, usages, type });\r\n        return checkInstruction(context, varType, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     *    Struct\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStruct(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let name: string = null;\r\n        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {\r\n            name = children[children.length - 2].value;\r\n        }\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const struct = new ComplexTypeInstruction({ scope, sourceNode, fields, name });\r\n        return checkInstruction(context, struct, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + Annotation \r\n     *       + FunctionDef \r\n     */\r\n    protected analyzeFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        const lastNodeValue = children[0].value;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let implementation: IStmtBlockInstruction = null;\r\n\r\n        program.push(EScopeType.k_Default);\r\n\r\n        const attributes = [];\r\n        while (children[children.length - 1 - attributes.length].name === 'Attribute') {\r\n            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));\r\n        }\r\n\r\n        const definition = this.analyzeFunctionDef(context, program, children[children.length - 1 - attributes.length]);\r\n\r\n        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)\r\n        let func = globalScope.findFunction(definition.name, definition.params.map(asType));\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName: definition.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func) && func.impl) {\r\n            context.error(sourceNode, EErrors.FunctionRedefinition, { funcName: definition.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func)) {\r\n            if (!func.def.returnType.isEqual(definition.returnType)) {\r\n                context.error(sourceNode, EErrors.InvalidFuncDefenitionReturnType, { funcName: definition.name });\r\n                program.pop();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        assert(context.funcDef === null);\r\n\r\n        // TODO: rewrite context ?\r\n        context.funcDef = definition;\r\n\r\n        if (children.length === 3) {\r\n            annotation = this.analyzeAnnotation(children[1]);\r\n        }\r\n\r\n        if (lastNodeValue !== ';') {\r\n            // TODO: do to increase scope depth inside stmt block!!\r\n            implementation = this.analyzeStmtBlock(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let hasVoidType = definition.returnType.isEqual(T_VOID);\r\n\r\n        // validate unreachable code.\r\n        if (!isNull(implementation)) {\r\n            let stmtList = implementation.stmtList;\r\n\r\n            // stmtList = stmtList.slice().reverse();\r\n            for (let i = stmtList.length - 1; i >= 0; --i) {\r\n                if (stmtList[i].instructionType == EInstructionTypes.k_ReturnStmt) {\r\n                    if (i != stmtList.length - 1) {\r\n                        context.error(stmtList[i + 1].sourceNode, EErrors.UnreachableCode);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        assert(scope == globalScope);\r\n        func = new FunctionDeclInstruction({ sourceNode, scope, definition, implementation, annotation, attributes });\r\n\r\n        // NOTE: possible implicit replacement of function \r\n        //       without implementaion inside addFunction() call.\r\n        if (!globalScope.addFunction(func)) {\r\n            context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: definition.name });\r\n        }\r\n\r\n        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !isNull(implementation)) {\r\n            context.error(sourceNode, EErrors.InvalidFunctionReturnStmtNotFound, { funcName: definition.name });\r\n        }\r\n\r\n        return func;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDef\r\n     *       + ParamList \r\n     *         T_NON_TYPE_ID = 'bar'\r\n     *       + UsageType \r\n     */\r\n    protected analyzeFunctionDef(context: Context, program: ProgramScope, sourceNode: IParseNode): FunctionDefInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const nameNode = children[children.length - 2];\r\n        const name = nameNode.value;\r\n\r\n        const retTypeNode = children[children.length - 1];\r\n        let returnType = this.analyzeUsageType(context, program, retTypeNode);\r\n\r\n        // TODO: is it really needed?\r\n        if (returnType.isContainSampler()) {\r\n            context.error(retTypeNode, EErrors.InvalidFunctionReturnType, { funcName: name });\r\n            return null;\r\n        }\r\n\r\n        let id = new IdInstruction({ scope, name, sourceNode: nameNode });\r\n\r\n        let semantic: string = null;\r\n        if (children.length === 4) {\r\n            semantic = this.analyzeSemantic(children[0]);\r\n        }\r\n\r\n        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);\r\n        let funcDef = new FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic })\r\n\r\n        checkInstruction(context, funcDef, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return funcDef;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamList\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeParamList(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n\r\n        const children = sourceNode.children;\r\n        let paramList: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'ParameterDecl') {\r\n                let param = this.analyzeParameterDecl(context, program, children[i]);\r\n                paramList.push(param);\r\n            }\r\n        }\r\n\r\n        return paramList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParameterDecl\r\n     *       + Variable \r\n     *       + ParamUsageType \r\n     */\r\n    protected analyzeParameterDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        const type = this.analyzeParamUsageType(context, program, children[1]);\r\n\r\n        if (isNull(type)) {\r\n            return null;\r\n        }\r\n\r\n        const param = this.analyzeVariable(context, program, children[0], type);\r\n\r\n        return param;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamUsageType\r\n     *       + Type \r\n     *       + ParamUsage \r\n     */\r\n    protected analyzeParamUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (children[i].name === 'ParamUsage') {\r\n                usages.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        let paramType = new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n        checkInstruction(context, paramType, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return paramType;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    StmtBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Stmt \r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStmtBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtBlockInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!children) {\r\n            return null;\r\n        }\r\n\r\n        let stmtList: IStmtInstruction[] = [];\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            let stmt = this.analyzeStmt(context, program, children[i]);\r\n            if (!isNull(stmt)) {\r\n                stmtList.push(stmt);\r\n            }\r\n        }\r\n\r\n        const stmtBlock = new StmtBlockInstruction({ sourceNode, scope, stmtList });\r\n        checkInstruction(context, stmtBlock, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return stmtBlock;\r\n    }\r\n\r\n\r\n    protected analyzeStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        let nonAttrNode = children.length;\r\n        let nonAttrNodeName: string;\r\n\r\n        do {\r\n            nonAttrNodeName = children[--nonAttrNode].name;\r\n        } while (nonAttrNodeName === 'Attribute');\r\n\r\n        switch (nonAttrNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, children[0]);\r\n                return null;\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n            case 'T_KW_IF':\r\n                return this.analyzeIfStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeSimpleStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_RETURN':\r\n                return this.analyzeReturnStmt(context, program, sourceNode);\r\n\r\n            case 'T_KW_DO':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n\r\n            case 'StmtBlock':\r\n                {\r\n                    program.push(EScopeType.k_Default);\r\n                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);\r\n                    program.pop();\r\n                    return stmtBlock;\r\n                }\r\n            case 'T_KW_DISCARD':\r\n            case 'T_KW_BREAK':\r\n            case 'T_KW_CONTINUE':\r\n                return this.analyzeBreakStmt(context, program, sourceNode);\r\n\r\n            case 'TypeDecl':\r\n            case 'VariableDecl':\r\n            case 'VarStructDecl':\r\n                return this.analyzeDeclStmt(context, program, children[0]);\r\n\r\n            default:\r\n                if (children.length === 2) {\r\n                    return this.analyzeExprStmt(context, program, sourceNode);\r\n                }\r\n\r\n                return new SemicolonStmtInstruction({ sourceNode, scope });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_KW_RETURN = 'return'\r\n     */\r\n    protected analyzeReturnStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        assert(context.func);\r\n\r\n        const funcReturnType = context.funcDef.returnType;\r\n        context.haveCurrentFunctionReturnOccur = true;\r\n        \r\n        if (children.length === 2) {\r\n            tryResolveProxyType(funcReturnType, T_VOID);\r\n        }\r\n\r\n        if (funcReturnType.isEqual(T_VOID) && children.length === 3) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtVoid);\r\n            return null;\r\n        }\r\n        else if (!funcReturnType.isEqual(T_VOID) && children.length === 2) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtEmpty);\r\n            return null;\r\n        }   \r\n\r\n        let expr: IExprInstruction = null;\r\n        if (children.length === 3) {\r\n            expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n            if (isNull(expr)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n\r\n            tryResolveProxyType(funcReturnType, expr.type);\r\n\r\n            if (!funcReturnType.isEqual(expr.type)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const returnStmtInstruction = new ReturnStmtInstruction({ sourceNode, scope, expr });\r\n        checkInstruction(context, returnStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return returnStmtInstruction;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_KW_BREAK = 'break'\r\n     */\r\n    protected analyzeBreakStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const operator: BreakOperator = <BreakOperator>children[1].value;\r\n\r\n        if (operator === 'discard' && !isNull(context.funcDef)) {\r\n            // context.currentFunction.vertex = (false);\r\n        }\r\n\r\n        const breakStmtInstruction = new BreakStmtInstruction({ sourceNode, scope, operator });\r\n        checkInstruction(context, breakStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return breakStmtInstruction;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeDeclStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const nodeName = sourceNode.name;\r\n\r\n        let declList: IDeclInstruction[] = [];\r\n\r\n        switch (nodeName) {\r\n            case 'TypeDecl':\r\n                declList.push(this.analyzeTypeDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VariableDecl':\r\n                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VarStructDecl':\r\n                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));\r\n                break;\r\n        }\r\n\r\n        const declStmtInstruction = new DeclStmtInstruction({ sourceNode, scope, declList });\r\n        checkInstruction(context, declStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return declStmtInstruction;\r\n    }\r\n\r\n\r\n    protected analyzeExprStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n        const exprStmt = new ExprStmtInstruction({ sourceNode, scope, expr });\r\n        checkInstruction(context, exprStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return exprStmt;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *       + Stmt \r\n     *         T_KW_DO = 'do'\r\n     */\r\n    protected analyzeWhileStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isDoWhile = (children[children.length - 1].value === 'do');\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;\r\n        const boolType = T_BOOL;\r\n\r\n\r\n        let cond: IExprInstruction = null;\r\n        let conditionType: IVariableTypeInstruction = null;\r\n        let body: IStmtInstruction = null;\r\n        let operator: IDoWhileOperator = \"do\";\r\n\r\n        if (isDoWhile) {\r\n            operator = \"do\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!conditionType.isEqual(boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            operator = \"while\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!conditionType.isEqual(boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            if (isNonIfStmt) {\r\n                body = this.analyzeNonIfStmt(context, program, children[0]);\r\n            }\r\n            else {\r\n                body = this.analyzeStmt(context, program, children[0]);\r\n            }\r\n        }\r\n\r\n        const whileStmt = new WhileStmtInstruction({ sourceNode, scope, cond, body, operator });\r\n        checkInstruction(context, whileStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return whileStmt;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Attribute\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '3'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '2'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'loop'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     */\r\n    protected analyzeAttribute(context: Context, program: ProgramScope, sourceNode: IParseNode): IAttributeInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const name = children[children.length - 2].value;\r\n\r\n        let args: ILiteralInstruction<number | boolean>[] = null;\r\n\r\n        if (children.length > 3) {\r\n            let argumentExpr: ILiteralInstruction<boolean | number> = null;\r\n\r\n            args = [];\r\n            for (let i = children.length - 4; i > 1; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = <ILiteralInstruction<number | boolean>>this.analyzeSimpleExpr(context, program, children[i]);\r\n\r\n                    // TODO: emit diagnostics error\r\n                    assert(\r\n                        argumentExpr.instructionType === EInstructionTypes.k_BoolExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_FloatExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_IntExpr);\r\n\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new AttributeInstruction({ scope, sourceNode, name, args });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_KW_ELSE = 'else'\r\n     *       + NonIfStmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_IF = 'if'\r\n     *       + Attribute \r\n     *       + Attribute \r\n     */\r\n    protected analyzeIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n\r\n        let attributes = [];\r\n        while (children[children.length - 1 - attributes.length].name === 'Attribute') {\r\n            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));\r\n        }\r\n\r\n        const isIfElse = (children.length - attributes.length === 7);\r\n\r\n        const cond = this.analyzeExpr(context, program, children[children.length - 3 - attributes.length]);\r\n\r\n        if (!cond || !cond.type.isEqual(T_BOOL)) {\r\n            context.error(sourceNode, EErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });\r\n        }\r\n\r\n        let conseq: IStmtInstruction = null;\r\n        let contrary: IStmtInstruction = null;\r\n\r\n        if (isIfElse) {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[2]);\r\n            contrary = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n\r\n        if (!cond) {\r\n            return null;\r\n        }\r\n\r\n        const ifStmt = new IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attributes });\r\n        checkInstruction(context, ifStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return ifStmt;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    NonIfStmt\r\n     *       + SimpleStmt \r\n     */\r\n    protected analyzeNonIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeForStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');\r\n\r\n        let body: IStmtInstruction = null;\r\n        let init: ITypedInstruction = null;\r\n        let cond: IExprInstruction = null;\r\n        let step: IExprInstruction = null;\r\n\r\n\r\n        if (children[1].name === 'ERROR') {\r\n            return null;\r\n        }\r\n\r\n        program.push();\r\n\r\n        init = this.analyzeForInit(context, program, children[children.length - 3]);\r\n        cond = this.analyzeForCond(context, program, children[children.length - 4]);\r\n        step = null;\r\n\r\n        if (children.length === 7) {\r\n            step = this.analyzeForStep(context, program, children[2]);\r\n        }\r\n\r\n        if (isNonIfStmt) {\r\n            body = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const pForStmtInstruction = new ForStmtInstruction({ sourceNode, scope, init, cond, step, body });\r\n        checkInstruction(context, pForStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return pForStmtInstruction;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + AssignmentExpr \r\n     *    ForInit\r\n     *       + VariableDecl \r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Expr \r\n     */\r\n    protected analyzeForInit(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypedInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'VariableDecl':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeVariableDecl(context, program, children[0])[0] || null;\r\n            case 'Expr':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeExpr(context, program, children[0]);\r\n        }\r\n\r\n        // ForInit : ';'\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForCond\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + RelationalExpr \r\n     */\r\n    protected analyzeForCond(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length === 1) {\r\n            return null;\r\n        }\r\n\r\n        return this.analyzeExpr(context, program, children[1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForStep\r\n     *       + UnaryExpr \r\n     */\r\n    protected analyzeForStep(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        if (children.length == 0) {\r\n            return null;\r\n        }\r\n        const step = this.analyzeExpr(context, program, children[0]);\r\n        return step;\r\n    }\r\n\r\n\r\n    protected analyzeTechniqueDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechniqueInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passList: IPassInstruction[] = null;\r\n        let techniqueType: ETechniqueType = ETechniqueType.k_BasicFx;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                passList = this.analyzeTechnique(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passList, scope });\r\n        Analyzer.addTechnique(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    TechniqueBody\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassDecl \r\n     *       + PassDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeTechnique(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction[] {\r\n        const children = sourceNode.children;\r\n        let passList: IPassInstruction[] = [];\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let pass = this.analyzePassDecl(context, program, children[i]);\r\n            assert(!isNull(pass));\r\n            passList.push(pass);\r\n        }\r\n        return passList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *       + Annotation \r\n     *         T_NON_TYPE_ID = 'name'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePassDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            renderStates,\r\n            id,\r\n            pixelShader: entry.pixel,\r\n            vertexShader: entry.vertex\r\n        });\r\n        //TODO: add annotation and id\r\n\r\n        return pass;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'VertexShader'\r\n     */\r\n    protected analyzePassStateBlockForShaders(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode): { vertex: IFunctionDeclInstruction; pixel: IFunctionDeclInstruction; } {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        let pixel: IFunctionDeclInstruction = null;\r\n        let vertex: IFunctionDeclInstruction = null;\r\n\r\n        const supportedTypeNames = ['vertexshader', 'pixelshader'];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let func: IFunctionDeclInstruction = null;\r\n\r\n            const childrenIth = children[i].children;\r\n            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();\r\n\r\n            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);\r\n\r\n            if (!isNull(func)) {\r\n                switch (shaderTypeName) {\r\n                    case 'vertexshader':\r\n                        assert(vertex == null);\r\n                        vertex = func;\r\n                        break;\r\n                    case 'pixelshader':\r\n                        assert(pixel == null);\r\n                        pixel = func;\r\n                        break;\r\n                    default:\r\n                        // TODO: make error!\r\n                        console.error('function is not suitable as shader entry point');\r\n                }\r\n            }\r\n        }\r\n\r\n        return { vertex, pixel };\r\n    }\r\n\r\n\r\n    protected analyzePassStateForShader(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode, shaderType: string): IFunctionDeclInstruction {\r\n\r\n        assert(shaderType === 'vertexshader' || shaderType === 'pixelshader');\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        const compileExpr = <CompileExprInstruction>this.analyzeExpr(context, program, exprNode);\r\n        const shaderFunc = compileExpr.function;\r\n\r\n        if (shaderType === 'vertexshader') {\r\n            if (!checkForVertexUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n        else {\r\n            if (!checkForPixelUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n\r\n        return shaderFunc;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassStateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassState \r\n     *       + PassState \r\n     *       + PassState \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzePassStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n        const children = sourceNode.children;\r\n        let states: IMap<ERenderStateValues> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePassState(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzePassState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateType = children[children.length - 1].value.toUpperCase();\r\n        const stateName = ERenderStates[stateType] || null;\r\n\r\n        if (isNull(stateName)) {\r\n            return {};\r\n        }\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let renderStates: IMap<ERenderStateValues> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: ERenderStateValues[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ERenderStates.BLENDFUNC:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDFUNCSEPARATE:\r\n                    if (values.length !== 4) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[2];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[3];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDEQUATIONSEPARATE:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.BLENDEQUATIONCOLOR] = values[0];\r\n                    renderStates[ERenderStates.BLENDEQUATIONALPHA] = values[1];\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Pass state is incorrect.');\r\n                    return {};\r\n            }\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            const stateValue = getRenderStateValue(stateName, value);\r\n\r\n            if (stateValue !== ERenderStateValues.UNDEF) {\r\n                switch (stateName) {\r\n                    case ERenderStates.SRCBLEND:\r\n                        renderStates[ERenderStates.SRCBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.SRCBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.DESTBLEND:\r\n                        renderStates[ERenderStates.DESTBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.DESTBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.BLENDEQUATION:\r\n                        renderStates[ERenderStates.BLENDEQUATIONCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.BLENDEQUATIONALPHA] = stateValue;\r\n                        break;\r\n                    default:\r\n                        renderStates[stateName] = stateValue;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return renderStates;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ImportDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_IMPORT = 'import'\r\n     */\r\n    // TODO: restore functionality! \r\n    protected analyzeImportDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): null {\r\n        const children = sourceNode.children;\r\n        const componentName = this.analyzeComplexName(children[children.length - 2]);\r\n\r\n        // if (!isNull(technique)) {\r\n        //     //We can import techniques from the same file, but on this stage they don`t have component yet.\r\n        //     //So we need special mehanism to add them on more belated stage\r\n        //     // let sShortedComponentName: string = componentName;\r\n        //     if (!isNull(context.moduleName)) {\r\n        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + \".\", \"\");\r\n        //     }\r\n\r\n        //     throw null;\r\n        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];\r\n        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {\r\n        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);\r\n        //     //     return;\r\n        //     // }\r\n        // }\r\n\r\n        const sourceTechnique: ITechniqueInstruction = null;//fx.techniques[componentName];\r\n        if (!sourceTechnique) {\r\n            context.error(sourceNode, EErrors.ImportedComponentNotExists, { componentName: componentName });\r\n            return null;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const name = children[children.length - 2].value;\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const struct = new ComplexTypeInstruction({ scope, sourceNode, name, fields });\r\n        return checkInstruction(context, struct, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StructDecl \r\n     */\r\n    protected analyzeTypeDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        if (children.length === 2) {\r\n            type = this.analyzeStructDecl(context, program, children[1]);\r\n        }\r\n        else {\r\n            context.error(sourceNode, EErrors.UnsupportedTypeDecl);\r\n        }\r\n\r\n\r\n        let typeDecl = new TypeDeclInstruction({ scope, sourceNode, type });\r\n        addTypeDecl(context, scope, typeDecl);\r\n        return checkInstruction(context, typeDecl, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'TechniqueDecl':\r\n                return [this.analyzeTechniqueDecl(context, program, sourceNode)];\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!\r\n                return null;\r\n            case 'ImportDecl':\r\n                return [this.analyzeImportDecl(context, program, sourceNode)];\r\n            case 'ProvideDecl':\r\n                return [this.analyzeProvideDecl(context, program, sourceNode)];\r\n            case 'TypeDecl':\r\n                return [this.analyzeTypeDecl(context, program, sourceNode)];\r\n            case 'VariableDecl':\r\n                return this.analyzeVariableDecl(context, program, sourceNode);\r\n            case 'VarStructDecl':\r\n                return this.analyzeVarStructDecl(context, program, sourceNode);\r\n            case 'FunctionDecl':\r\n                assert(program.currentScope == program.globalScope);\r\n                let fdecl = null;\r\n                context.beginFunc();\r\n                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);\r\n                context.endFunc();\r\n                return [fdecl];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeGlobals(context: Context, program: ProgramScope, slastDocument: ISLASTDocument): IInstruction[] {\r\n        if (isNull(slastDocument) || isNull(slastDocument.root)) {\r\n            return null;\r\n        }\r\n\r\n        const children = slastDocument.root.children;\r\n        let globals: IInstruction[] = [];\r\n\r\n        if (isNull(children)) {\r\n            return [];\r\n        }\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));\r\n        }\r\n\r\n        return globals.filter(decl => !!decl);\r\n    }\r\n\r\n\r\n    protected createContext(uri: string): Context {\r\n        return new Context(uri);\r\n    }\r\n\r\n    protected createProgram(document: ISLDocument = null): ProgramScope {\r\n        let parent = <IScope>SystemScope.SCOPE;\r\n        if (!isNull(document)) {\r\n            parent = document.root.scope;\r\n        }\r\n        return new ProgramScope(parent);\r\n    }\r\n\r\n    /**\r\n     * Post-analysis validation.\r\n     */\r\n    protected validate(context: Context, program: ProgramScope, root: IInstructionCollector) {\r\n        checkFunctionsForRecursion(context, program);\r\n        program.validate();\r\n    }\r\n\r\n\r\n    async parse(slastDocument: ISLASTDocument, document?: ISLDocument): Promise<ISLDocument> {\r\n        const uri = slastDocument.uri;\r\n        // console.time(`analyze(${uri})`);\r\n\r\n        const program = this.createProgram(document);\r\n        const context = this.createContext(uri);\r\n\r\n        let instructions: IInstruction[] = null;\r\n        try {\r\n            instructions = this.analyzeGlobals(context, program, slastDocument);\r\n        } catch (e) {\r\n            // critical errors were occured\r\n            // throw e;\r\n            console.error(e);\r\n        }\r\n\r\n        // console.timeEnd(`analyze(${uri})`);\r\n\r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n\r\n\r\n        const diagnosticReport = Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n\r\n    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {\r\n    //     if (isSystemFunction(func)) {\r\n    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });\r\n    //     }\r\n\r\n    //     let isFunctionAdded: boolean = program.addFunction(func);\r\n\r\n    //     if (!isFunctionAdded) {\r\n    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });\r\n    //     }\r\n    // }\r\n\r\n\r\n    protected static addTechnique(context: Context, program: ProgramScope, technique: ITechniqueInstruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique(technique);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * Check the possibility of using the operator between the two types.\r\n    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =\r\n     * @leftType {IVariableTypeInstruction} Type of the left side of the expression.\r\n     * @rightType {IVariableTypeInstruction} Type of the right side of the expression.\r\n     */\r\n    protected static checkTwoOperandExprTypes(\r\n        context: Context,\r\n        operator: string,\r\n        leftType: IVariableTypeInstruction,\r\n        rightType: IVariableTypeInstruction,\r\n        leftSourceNode: IParseNode = leftType.sourceNode,\r\n        rightSourceNode: IParseNode = rightType.sourceNode): IVariableTypeInstruction {\r\n\r\n        if (!leftType || !rightType) {\r\n            return null;\r\n        }\r\n\r\n        const isComplex = leftType.isComplex() || rightType.isComplex();\r\n        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();\r\n        const isSampler = SystemScope.isSamplerType(leftType) || SystemScope.isSamplerType(rightType);\r\n\r\n        const boolType = <IVariableTypeInstruction>T_BOOL;\r\n        // const constBoolType = VariableTypeInstruction.wrapAsConst(T_BOOL, SystemScope.SCOPE);\r\n\r\n        if (isArray || isSampler) {\r\n            return null;\r\n        }\r\n\r\n        if (operator === '%' || operator === '%=') {\r\n            return null;\r\n        }\r\n\r\n        if (Analyzer.isAssignmentOperator(operator)) {\r\n            if (!leftType.writable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForWriting);\r\n                return null;\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n\r\n            if (operator !== '=' && !leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n        }\r\n        else {\r\n            if (!leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (isComplex) {\r\n            if (operator === '=' && leftType.isEqual(rightType)) {\r\n                return <IVariableTypeInstruction>leftType;\r\n            }\r\n            // samplers and arrays can't be compared directly\r\n            else if (Analyzer.isEqualOperator(operator) && !leftType.isContainArray() && !leftType.isContainSampler()) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        // FIXME: use operands' scope instead of system scope?\r\n        const leftBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>leftType.baseType, SystemScope.SCOPE);\r\n        const rightBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>rightType.baseType, SystemScope.SCOPE);\r\n\r\n\r\n        if (leftType.isConst() && Analyzer.isAssignmentOperator(operator)) {\r\n            // TODO: emit proper error\r\n            return null;\r\n        }\r\n\r\n        if (leftType.isEqual(rightType)) {\r\n            if (Analyzer.isArithmeticalOperator(operator)) {\r\n                if (!SystemScope.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {\r\n                    return leftBaseType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (Analyzer.isRelationalOperator(operator)) {\r\n                if (SystemScope.isScalarType(leftType)) {\r\n                    return boolType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (Analyzer.isEqualOperator(operator)) {\r\n                return boolType;\r\n            }\r\n            else if (operator === '=') {\r\n                return leftBaseType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n\r\n        }\r\n\r\n        // temp workaround for INT/UINT comparison\r\n        if (Analyzer.isRelationalOperator(operator)) {\r\n            if ((leftType.isEqual(T_UINT) && rightType.isEqual(T_INT)) ||\r\n                (leftType.isEqual(T_INT) && rightType.isEqual(T_UINT))) {\r\n                return boolType;\r\n            }\r\n        }\r\n\r\n        if (Analyzer.isArithmeticalOperator(operator)) {\r\n            if (SystemScope.isBoolBasedType(leftType) || SystemScope.isBoolBasedType(rightType) ||\r\n                SystemScope.isFloatBasedType(leftType) !== SystemScope.isFloatBasedType(rightType) ||\r\n                SystemScope.isIntBasedType(leftType) !== SystemScope.isIntBasedType(rightType) || \r\n                SystemScope.isUIntBasedType(leftType) !== SystemScope.isUIntBasedType(rightType)) {\r\n                return null;\r\n            }\r\n\r\n            if (SystemScope.isScalarType(leftType)) {\r\n                return rightBaseType;\r\n            }\r\n\r\n            if (SystemScope.isScalarType(rightType)) {\r\n                return leftBaseType;\r\n            }\r\n\r\n            if (operator === '*' || operator === '*=') {\r\n                if (SystemScope.isMatrixType(leftType) && SystemScope.isVectorType(rightType) &&\r\n                    leftType.length === rightType.length) {\r\n                    return rightBaseType;\r\n                }\r\n                else if (SystemScope.isMatrixType(rightType) && SystemScope.isVectorType(leftType) &&\r\n                    leftType.length === rightType.length) {\r\n                    return leftBaseType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (operator === '=') {\r\n            // TODO: move conversion logic inside TypeInstruction.\r\n            if ((leftType.isEqual(T_INT) && rightType.isEqual(T_UINT)) ||\r\n                (leftType.isEqual(T_UINT) && rightType.isEqual(T_INT))) {\r\n                return leftType;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Проверят возможность использования оператора к типу данных.\r\n     * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.\r\n     *\r\n     * @operator {string} Один из операторов: + - ! ++ --\r\n     * @leftType {IVariableTypeInstruction} Тип операнда\r\n     */\r\n    protected static checkOneOperandExprType(context: Context, sourceNode: IParseNode, operator: string,\r\n        type: IVariableTypeInstruction): IVariableTypeInstruction {\r\n\r\n        const isComplex = type.isComplex();\r\n        const isArray = type.isNotBaseArray();\r\n        const isSampler = SystemScope.isSamplerType(type);\r\n\r\n        if (isComplex || isArray || isSampler) {\r\n            return null;\r\n        }\r\n\r\n        if (!type.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n\r\n        if (operator === '++' || operator === '--') {\r\n            if (!type.writable) {\r\n                context.error(sourceNode, EErrors.InvalidTypeForWriting);\r\n                return null;\r\n            }\r\n\r\n            return type;\r\n        }\r\n\r\n        if (operator === '!') {\r\n            const boolType = <IVariableTypeInstruction>T_BOOL;\r\n            // validate(boolType, EInstructionTypes.k_VariableDecl);\r\n\r\n            if (type.isEqual(boolType)) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (SystemScope.isBoolBasedType(type)) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (<SystemTypeInstruction>type.baseType) as any; // << TODO: fixme!!!! remove \"any\"!\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected static isAssignmentOperator(operator: string): boolean {\r\n        return operator === '+=' || operator === '-=' ||\r\n            operator === '*=' || operator === '/=' ||\r\n            operator === '%=' || operator === '=';\r\n    }\r\n\r\n\r\n    protected static isArithmeticalOperator(operator: string): boolean {\r\n        return operator === '+' || operator === '+=' ||\r\n            operator === '-' || operator === '-=' ||\r\n            operator === '*' || operator === '*=' ||\r\n            operator === '/' || operator === '/=';\r\n    }\r\n\r\n\r\n    protected static isRelationalOperator(operator: string): boolean {\r\n        return operator === '>' || operator === '>=' ||\r\n            operator === '<' || operator === '<=';\r\n    }\r\n\r\n\r\n    protected static isEqualOperator(operator: string): boolean {\r\n        return operator === '==' || operator === '!=';\r\n    }\r\n}\r\n\r\n\r\n","import { deepEqual } from \"@lib/common\";\r\nimport { EParserFlags, EParserType, IParserParams } from \"@lib/idl/parser/IParser\";\r\nimport { IParser } from \"@lib/idl/parser/IParser\"\r\nimport { AbstractParser } from \"@lib/parser/AbstractParser\";\r\nimport slGrammar from 'raw-loader!./HLSL.gr';\r\n\r\nexport class SLParser extends AbstractParser {\r\n    protected init({ grammar = slGrammar, type = EParserType.k_LALR, flags = EParserFlags.k_Default }: IParserParams) {\r\n        super.init({ grammar, type, flags });\r\n    }\r\n}\r\n\r\nlet paramsDefault: IParserParams = null;\r\nlet parserDefault: IParser = null;\r\n\r\nexport function defaultSLGrammar(): string {\r\n    return slGrammar;\r\n}\r\n\r\nexport function defaultSLParser(): IParser {\r\n    if (!parserDefault) {\r\n        createDefaultSLParser();\r\n    }\r\n    return parserDefault;\r\n}\r\n\r\n/**\r\n * Internal debugging functionality, no need to use without necessary.\r\n */\r\nexport function createDefaultSLParser(params: IParserParams = { grammar: slGrammar }) {\r\n    if (deepEqual(paramsDefault, params)) {\r\n        return;\r\n    }\r\n    paramsDefault = params;\r\n    parserDefault = new SLParser(params);\r\n}\r\n","import * as bf from '@lib/bf/bf';\r\nimport { EParserFlags, EParserType, IASTDocumentFlags } from '@lib/idl/parser/IParser';\r\nimport { mapActions, parser as parserActions } from '@sandbox/actions';\r\nimport { mapProps } from '@sandbox/reducers';\r\nimport { getParser } from '@sandbox/reducers/parserParams';\r\nimport { IParserState } from '@sandbox/store/IStoreState';\r\nimport autobind from 'autobind-decorator';\r\nimport * as React from 'react';\r\nimport MonacoEditor from 'react-monaco-editor';\r\nimport { connect } from 'react-redux';\r\nimport { Form, Grid, Segment } from 'semantic-ui-react';\r\n\r\nconst setFlags = (dest: number, src: number, value: boolean) => {\r\n    return value ? bf.setFlags(dest, src) : bf.clearFlags(dest, src);\r\n};\r\n\r\nexport interface IParserProps extends IParserState {\r\n    // warning, actions actually have void return type!\r\n    actions: typeof parserActions;\r\n}\r\n\r\n\r\nclass ParserParameters extends React.Component<IParserProps, IParserState> {\r\n    state: IParserState;\r\n\r\n    UNSAFE_componentWillMount(): void {\r\n        this.setState(this.props);\r\n    }\r\n\r\n    UNSAFE_componentWillReceiveProps(nextProps: IParserProps): void {\r\n        this.setState(nextProps);\r\n    }\r\n\r\n    // tslint:disable-next-line:max-func-body-length\r\n    render(): JSX.Element {\r\n        const { type, flags, grammar, parsingFlags } = this.state;\r\n        return (\r\n            <Grid>\r\n                <Grid.Row columns={ 2 }>\r\n                    <Grid.Column computer=\"10\" tablet=\"8\" mobile=\"6\">\r\n                        <MonacoEditor\r\n                            language=\"powershell\"\r\n                            theme=\"vs\"\r\n                            value={ grammar || '' }\r\n                            width=\"100%\"\r\n                            height=\"calc(100vh - 41px)\" // todo: fixme\r\n                            options={ {\r\n                                selectOnLineNumbers: true,\r\n                                fontSize: 12,\r\n                                lineNumbers: \"on\",\r\n                                lineHeight: 14,\r\n                                automaticLayout: true\r\n                            } }\r\n                            onChange={ grammar => this.setState({ grammar }) }\r\n                        />\r\n                    </Grid.Column>\r\n                    <Grid.Column computer=\"6\" tablet=\"8\" mobile=\"10\">\r\n                        {/* css fix for stupied setup in the App.tsx */ }\r\n                        <Segment style={ { marginTop: '1em', marginRight: '2em' } }>\r\n                            <Form>\r\n                                <Grid columns='equal' divided padded>\r\n                                    <Grid.Column>\r\n                                        <Form.Group grouped>\r\n                                            <label>Parser type:</label>\r\n                                            <Form.Radio\r\n                                                label='LR0'\r\n                                                name='radioParserType'\r\n                                                value={ EParserType[EParserType.k_LR0] }\r\n                                                checked={ this.state.type === EParserType.k_LR0 }\r\n                                                onChange={ (e, { value }) => this.setState({ type: EParserType[value] }) }\r\n                                                disabled\r\n                                            />\r\n                                            <Form.Radio\r\n                                                label='LR1'\r\n                                                name='radioParserType'\r\n                                                value={ EParserType[EParserType.k_LR1] }\r\n                                                checked={ this.state.type === EParserType.k_LR1 }\r\n                                                onChange={ (e, { value }) => this.setState({ type: EParserType[value] }) }\r\n                                            />\r\n                                            <Form.Radio\r\n                                                label='LALR'\r\n                                                name='radioParserType'\r\n                                                value={ EParserType[EParserType.k_LALR] }\r\n                                                checked={ this.state.type === EParserType.k_LALR }\r\n                                                onChange={ (e, { value }) => this.setState({ type: EParserType[value] }) }\r\n                                            />\r\n                                        </Form.Group>\r\n                                    </Grid.Column>\r\n                                    <Grid.Column>\r\n                                        <Form.Group grouped>\r\n                                            <label>Parser flags:</label>\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(flags & EParserFlags.k_AllowAddMode) }\r\n                                                onChange={ this.handleParserFlags.bind(this, EParserFlags.k_AllowAddMode) }\r\n                                                label='Allow `--add` mode'\r\n                                            />\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(flags & EParserFlags.k_AllowExposeMode) }\r\n                                                onChange={ this.handleParserFlags.bind(this, EParserFlags.k_AllowExposeMode) }\r\n                                                label='Allow `--expose` mode'\r\n                                            />\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(flags & EParserFlags.k_AllowSkipMode) }\r\n                                                onChange={ this.handleParserFlags.bind(this, EParserFlags.k_AllowSkipMode) }\r\n                                                label='Allow `--skip` mode'\r\n                                            />\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(flags & EParserFlags.k_ForceAppendAll) }\r\n                                                onChange={ this.handleParserFlags.bind(this, EParserFlags.k_ForceAppendAll) }\r\n                                                label='Force create all nodes'\r\n                                            />\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(flags & EParserFlags.k_Debug) }\r\n                                                onChange={ this.handleParserFlags.bind(this, EParserFlags.k_Debug) }\r\n                                                label='Debug mode'\r\n                                            />\r\n                                            <label>Parsing flags:</label>\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(parsingFlags & IASTDocumentFlags.k_Optimize) }\r\n                                                onChange={ this.handleParsingFlags.bind(this, IASTDocumentFlags.k_Optimize) }\r\n                                                label='Created nodes if it has more than one child'\r\n                                            />\r\n                                            <Form.Checkbox\r\n                                                checked={ !!(parsingFlags & IASTDocumentFlags.k_DeveloperMode) }\r\n                                                onChange={ this.handleParsingFlags.bind(this, IASTDocumentFlags.k_DeveloperMode) }\r\n                                                label='Developer mode'\r\n                                            />\r\n                                        </Form.Group>\r\n                                    </Grid.Column>\r\n                                </Grid>\r\n                                <Form.Button onClick={ this.reinit }>\r\n                                    Reinit parser\r\n                                </Form.Button>\r\n                            </Form>\r\n                        </Segment>\r\n                    </Grid.Column>\r\n                </Grid.Row>\r\n            </Grid>\r\n\r\n        );\r\n    }\r\n\r\n    @autobind\r\n    private reinit() {\r\n        const { type, flags, grammar, parsingFlags } = this.state;\r\n        this.props.actions.setParams(type, flags);\r\n        this.props.actions.setGrammar(grammar);\r\n        this.props.actions.setParsingParams(parsingFlags);\r\n    }\r\n\r\n    @autobind\r\n    private handleParserFlags(flag: EParserFlags, event, { checked: value }): void {\r\n        let { flags } = this.state;\r\n        switch (flag) {\r\n            case EParserFlags.k_AllowAddMode:\r\n            case EParserFlags.k_AllowExposeMode:\r\n            case EParserFlags.k_AllowSkipMode:\r\n                if (value) {\r\n                    flags = bf.clearFlags(flags, EParserFlags.k_ForceAppendAll);\r\n                }\r\n                break;\r\n            case EParserFlags.k_ForceAppendAll:\r\n                if (value) {\r\n                    flags = bf.clearFlags(flags, EParserFlags.k_AllowExposeMode |\r\n                        EParserFlags.k_AllowAddMode | EParserFlags.k_AllowSkipMode);\r\n                }\r\n                break;\r\n            default:\r\n        }\r\n\r\n        flags = setFlags(flags, flag, value);\r\n        this.setState({ flags });\r\n    }\r\n\r\n    @autobind\r\n    private handleParsingFlags(flag: IASTDocumentFlags, event, { checked: value }): void {\r\n        let { parsingFlags } = this.state;\r\n\r\n        parsingFlags = setFlags(parsingFlags, flag, value);\r\n        this.setState({ parsingFlags });\r\n    }\r\n}\r\n\r\nexport default connect<{}, {}, IParserProps>(mapProps(getParser), mapActions(parserActions))(ParserParameters) as any;\r\n","import { EInstructionTypes, IInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace instruction {\r\n    export const UNDEFINE_LENGTH: number = 0xffffff;\r\n    export const UNDEFINE_SIZE: number = 0xffffff;\r\n    export const UNDEFINE_PADDING: number = 0xffffff;\r\n    export const UNDEFINE_NAME: string = \"undef\";\r\n\r\n    export function isExpression(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n            case EInstructionTypes.k_InitExpr:\r\n            case EInstructionTypes.k_IdExpr:\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n            case EInstructionTypes.k_ComplexExpr:\r\n            case EInstructionTypes.k_CastExpr:\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isStatement(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_Stmt:\r\n            case EInstructionTypes.k_DeclStmt:\r\n            case EInstructionTypes.k_ReturnStmt:\r\n            case EInstructionTypes.k_IfStmt:\r\n            case EInstructionTypes.k_StmtBlock:\r\n            case EInstructionTypes.k_ExprStmt:\r\n            case EInstructionTypes.k_WhileStmt:\r\n            case EInstructionTypes.k_ForStmt:\r\n            case EInstructionTypes.k_BreakStmt:\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isLiteral(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}","import { isDef, isNull } from \"@lib/common\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, ISamplerStateBlockInstruction, ISamplerStateInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISamplerState } from \"@lib/idl/ISamplerState\";\r\nimport { ETextureFilters, ETextureWrapModes } from \"@lib/idl/ITexture\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type SamplerOperator = \"sampler_state\";\r\n\r\nexport interface ISamplerStateBlockInstructionSettings extends IInstructionSettings {\r\n    operator: SamplerOperator;\r\n    params?: ISamplerStateInstruction[];\r\n}\r\n\r\n\r\n/**\r\n  * Represetn sampler_state { states }\r\n  */\r\nexport class SamplerStateBlockInstruction extends ExprInstruction implements ISamplerStateBlockInstruction {\r\n    protected _samplerParams: ISamplerStateInstruction[];\r\n    protected _operator: SamplerOperator;\r\n\r\n\r\n    constructor({ operator, params = [], ...settings }: ISamplerStateBlockInstructionSettings) {\r\n        // todo: resolve type from texture type!\r\n        super({ instrType: EInstructionTypes.k_SamplerStateBlockExpr, type: SystemScope.T_SAMPLER, ...settings } );\r\n        \r\n        this._samplerParams = params.map(param => Instruction.$withParent(param, this));\r\n        this._operator = operator;\r\n    }\r\n\r\n    \r\n    get texture(): IVariableDeclInstruction {\r\n        let params = this._samplerParams;\r\n        for (let i = 0; i < params.length; ++ i) {\r\n            if (params[i].name === \"TEXTURE\") {\r\n                return <IVariableDeclInstruction>params[i].value;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    \r\n    get params(): ISamplerStateInstruction[] {\r\n        return this._samplerParams;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    // todo: rewrite it!\r\n    evaluate(): boolean {\r\n        var samplerState: ISamplerState = {\r\n            textureName: \"\",\r\n\r\n            wrap_s: 0,\r\n            wrap_t: 0,\r\n\r\n            mag_filter: 0,\r\n            min_filter: 0\r\n        };\r\n\r\n        if (!isNull(this.texture)) {\r\n            samplerState.textureName = this.texture.name;\r\n        }\r\n\r\n        if (!isNull(this._samplerParams)) {\r\n            if (isDef(this._samplerParams[\"ADDRESSU\"])) {\r\n                samplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams[\"ADDRESSU\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"ADDRESSV\"])) {\r\n                samplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams[\"ADDRESSV\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"MAGFILTER\"])) {\r\n                samplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams[\"MAGFILTER\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"MINFILTER\"])) {\r\n                samplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams[\"MINFILTER\"]);\r\n            }\r\n        }\r\n\r\n\r\n        this._evalResult = samplerState;\r\n        return true;\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    static convertWrapMode(sState: string): ETextureWrapModes {\r\n        switch (sState) {\r\n            case \"WRAP\":\r\n                return ETextureWrapModes.REPEAT;\r\n            case \"CLAMP\":\r\n                return ETextureWrapModes.CLAMP_TO_EDGE;\r\n            case \"MIRROR\":\r\n                return ETextureWrapModes.MIRRORED_REPEAT;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n    \r\n\r\n    // TODO: move it to helpers\r\n    static convertFilters(sState: string): ETextureFilters {\r\n        switch (sState) {\r\n            case \"NEAREST\":\r\n                return ETextureFilters.NEAREST;\r\n            case \"LINEAR\":\r\n                return ETextureFilters.LINEAR;\r\n            case \"NEAREST_MIPMAP_NEAREST\":\r\n                return ETextureFilters.NEAREST_MIPMAP_NEAREST;\r\n            case \"LINEAR_MIPMAP_NEAREST\":\r\n                return ETextureFilters.LINEAR_MIPMAP_NEAREST;\r\n            case \"NEAREST_MIPMAP_LINEAR\":\r\n                return ETextureFilters.NEAREST_MIPMAP_LINEAR;\r\n            case \"LINEAR_MIPMAP_LINEAR\":\r\n                return ETextureFilters.LINEAR_MIPMAP_LINEAR;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { T_INT, T_UINT, SCOPE } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\n\r\nexport interface IIntInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n    signed: boolean;\r\n}\r\n\r\nexport class IntInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    readonly signed: boolean;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, signed, scope, ...settings }: IIntInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IntExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes \r\n            type: VariableTypeInstruction.wrapAsConst(signed ? T_INT : T_UINT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n        this.signed = signed;\r\n\r\n        if (!signed) {\r\n            this.value >>>= 0;\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    toString(): string {\r\n        // return `${this.value}${this.signed? '' : 'u'}`;\r\n        return `${this.value}`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { isDefAndNotNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\ninterface IAnalyzerDiagDesc {\r\n    file: string;\r\n    loc: IRange;\r\n    info: any; // TODO: fixme\r\n}\r\n\r\n\r\nexport class AnalyzerDiagnostics extends Diagnostics<IAnalyzerDiagDesc> {\r\n    constructor() {\r\n        super(\"Analyzer Diagnostics\", 'A');\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: IAnalyzerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: IAnalyzerDiagDesc): IRange {\r\n        return desc.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        // TODO: fill all errors.\r\n        // TODO: add support for warnings\r\n        return {\r\n            [EErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \\'*type*\\' type expected.', // TODO: specify type\r\n            [EErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \\'void\\' type expected.',\r\n            [EErrors.FunctionRedefinition]: 'Function redefinition. Function with name \\'{info.funcName}\\' already declared.', // TODO: add location where function declared before\r\n            [EErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \\'{info.funcName}\\' but another type already declared.', // TODO: specify prev type and location\r\n            [EErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.', // TODO: specify func name and return type details.\r\n            [EErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IAnalyzerDiagDesc): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { FunctionDeclInstruction, IFunctionDeclInstructionSettings } from \"./FunctionDeclInstruction\";\r\n\r\nexport interface ISystemFunctionInstructionSettings extends IFunctionDeclInstructionSettings {\r\n    vertex?: boolean;\r\n    pixel?: boolean;\r\n}\r\n\r\n\r\nexport class SystemFunctionInstruction extends FunctionDeclInstruction implements IFunctionDeclInstruction {\r\n    protected _bForVertex: boolean;\r\n    protected _bForPixel: boolean;\r\n    \r\n     constructor({ vertex = true, pixel = true, implementation = null, ...settings }: ISystemFunctionInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemFunctionDecl, implementation: null, ...settings });\r\n        \r\n        assert(isNull(implementation));\r\n\r\n        this._bForVertex = vertex;\r\n        this._bForPixel = pixel;\r\n    }\r\n\r\n\r\n    checkVertexUsage(): boolean {\r\n        return this._bForVertex;\r\n    }\r\n\r\n\r\n    checkPixelUsage(): boolean {\r\n        return this._bForPixel;\r\n    }\r\n\r\n\r\n    $makeVertexCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForVertex = val;\r\n    }\r\n\r\n\r\n    $makePixelCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForPixel = val;\r\n    }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\n\r\n// todo: use more compact format than 4 x int32\r\n\r\nclass InstructionList {\r\n    private _data: Uint32Array;\r\n    private _length: number;\r\n\r\n    constructor() {\r\n        this._data = new Uint32Array(8);\r\n        this._length = 0;\r\n    }\r\n\r\n\r\n    get capacity(): number {\r\n        return this._data.length;\r\n    }\r\n\r\n\r\n    get data(): Uint32Array {\r\n        return this._data.subarray(0, this._length);\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get pc(): number {\r\n        return this.length / InstructionList.STRIDE;\r\n    }\r\n\r\n\r\n    // convert bytes adresses to register numbers\r\n    // validate number of arguments\r\n    // premultiply jump counters with instructions stride\r\n    static prepareInstruction(op: EOperation, args: number[]) {\r\n\r\n        // NOTE: keep order as it is done in the VM.ts\r\n        switch (op) {\r\n            case EOperation.k_I32SetConst:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                // args[1] => constant itself\r\n                // args[2] => hint about what type lies in the constant\r\n                break;\r\n            case EOperation.k_I32LoadRegister:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n            case EOperation.k_I32LoadRegistersPointer:\r\n            case EOperation.k_I32StoreRegisterPointer:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2; // byte offset => register offset\r\n                break;\r\n            case EOperation.k_I32LoadInput:\r\n            case EOperation.k_I32StoreInput:\r\n                assert(args.length == 3);\r\n                // args[0] => input index    \r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n            case EOperation.k_I32LoadInputPointer:\r\n            case EOperation.k_I32StoreInputPointer:\r\n                assert(args.length == 4);\r\n                // args[0] => input index\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                args[3] >>= 2; // byte offset => register offset\r\n                break;\r\n                \r\n            case EOperation.k_I32Not:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Add:\r\n            case EOperation.k_I32Sub:\r\n            case EOperation.k_I32Mul:\r\n            case EOperation.k_I32Div:\r\n            case EOperation.k_F32Add:\r\n            case EOperation.k_F32Sub:\r\n            case EOperation.k_F32Mul:\r\n            case EOperation.k_F32Div:\r\n\r\n            case EOperation.k_U32LessThan:\r\n            case EOperation.k_U32GreaterThanEqual:\r\n            case EOperation.k_I32LessThan:\r\n            case EOperation.k_I32GreaterThanEqual:\r\n            case EOperation.k_I32Equal:\r\n            case EOperation.k_I32NotEqual:\r\n            case EOperation.k_F32LessThan:\r\n            case EOperation.k_F32GreaterThanEqual:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Mad:\r\n                assert(args.length == 4);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                args[3] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32LogicalOr:\r\n            case EOperation.k_I32LogicalAnd:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_F32Frac:\r\n            case EOperation.k_F32Floor:\r\n            case EOperation.k_F32Ceil:\r\n            case EOperation.k_F32Sin:\r\n            case EOperation.k_F32Cos:\r\n            case EOperation.k_F32Abs:\r\n            case EOperation.k_F32Sqrt:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Min:\r\n            case EOperation.k_I32Max:\r\n            case EOperation.k_F32Min:\r\n            case EOperation.k_F32Max:\r\n                assert(args.length == 3);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                args[2] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_F32ToI32:\r\n            case EOperation.k_I32ToF32:\r\n            case EOperation.k_F32ToU32:\r\n            case EOperation.k_U32ToF32:\r\n                assert(args.length == 2);\r\n                args[0] >>= 2;\r\n                args[1] >>= 2;\r\n                break;\r\n\r\n            case EOperation.k_Jump:\r\n                assert(args.length === 1);\r\n                // multiply jump in order to facilitate the operation of the VM\r\n                args[0] *= InstructionList.STRIDE;\r\n                break;\r\n            case EOperation.k_JumpIf:\r\n                assert(args.length === 1);\r\n                args[0] >>= 2;\r\n                break;\r\n            case EOperation.k_Ret:\r\n                // nothing todo\r\n                break;\r\n            default:\r\n                assert(false, `unknown operation found: ${op} (${EOperation[op]})`);\r\n        }\r\n    }\r\n\r\n\r\n    add(op: EOperation, args: number[]) {\r\n        assert(args.length <= 4);\r\n        this.check(InstructionList.STRIDE);\r\n\r\n        InstructionList.prepareInstruction(op, args);\r\n\r\n        this.push(op);\r\n        args.forEach((v) => this.push(v));\r\n        this._length += 4 - args.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * Replace specified instruction with new one;\r\n     * @param pc number of instruction to be replaced\r\n     * @param op new operation\r\n     * @param args new arguments\r\n     */\r\n    replace(pc: number, op: EOperation, args: number[]) {\r\n        assert(pc < this.pc);\r\n        assert(args.length <= 4);\r\n\r\n        const pc5 = pc * InstructionList.STRIDE; // stride is 5\r\n\r\n        // FIXME: remove this assert\r\n        assert(this.data[pc5] === EOperation.k_Ret || this.data[pc5] === EOperation.k_Jump,\r\n            `expected ${EOperation.k_Ret}/${EOperation.k_Jump}, but given is ${this.data[pc5]} for pc = ${pc}`);\r\n\r\n        InstructionList.prepareInstruction(op, args);\r\n\r\n        // replace op\r\n        this.data[pc5] = op;\r\n        // replace arguments\r\n        args.forEach((v, i) => { this.data[pc5 + 1 + i] = v; });\r\n    }\r\n\r\n    private push(val: number) {\r\n        assert(this.capacity - this._length >= 1);\r\n        this._data[this._length++] = val;\r\n    }\r\n\r\n\r\n    private check(count: number) {\r\n        let expected = this._length + count;\r\n        if (expected <= this.capacity) {\r\n            return;\r\n        }\r\n\r\n        var oldData = this._data;\r\n        var newData = new Uint32Array(Math.max(expected, this.capacity * 2));\r\n        newData.set(oldData);\r\n\r\n        this._data = newData;\r\n    }\r\n\r\n    static STRIDE: number = 5;\r\n}\r\n\r\nexport default InstructionList;","import { assert, isDef } from \"@lib/common\";\r\nimport { IdExprInstruction } from \"@lib/fx/analisys/instructions/IdExprInstruction\";\r\nimport { EInstructionTypes, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IInstruction, ILiteralInstruction, IPostfixPointInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { CodeEmitter, ICodeEmitterOptions } from \"./CodeEmitter\";\r\n\r\nconst GlslTypeNames = {\r\n    'int': 'int',\r\n    'float': 'float',\r\n    'float2': 'vec2',\r\n    'float3': 'vec3',\r\n    'float4': 'vec4',\r\n    'float4x4': 'mat4'\r\n}\r\n \r\n\r\nconst sname = {\r\n    attr: (decl: IVariableDeclInstruction) => decl.semantic ?\r\n        `a_${decl.semantic.toLowerCase()}` :\r\n        `a_${decl.name}_${decl.instructionID}`,\r\n    varying: (decl: IVariableDeclInstruction) => decl.semantic ?\r\n        `v_${decl.semantic.toLowerCase()}` :\r\n        `v_${decl.name}_${decl.instructionID}`,\r\n    // uniform: (decl: IVariableDeclInstruction) => `u_${decl.name}`\r\n};\r\n\r\n\r\n\r\nexport class GlslEmitter extends CodeEmitter {\r\n    \r\n    protected resolveTypeName(type: ITypeInstruction): string {\r\n        const typeName = GlslTypeNames[type.name];\r\n        if (!isDef(typeName)) {\r\n            assert(false, 'unknown built in type found');\r\n            return null;\r\n        }\r\n\r\n        return typeName;\r\n    }\r\n\r\n\r\n    protected isVaryingOrAttributeAlias(pfxp: IPostfixPointInstruction) {\r\n        if (this.isMain() && this.mode !== 'raw') {\r\n            if (pfxp.element.instructionType === EInstructionTypes.k_IdExpr) {\r\n                const id = pfxp.element as IdExprInstruction;\r\n                if (id.decl.isParameter() && !id.decl.type.isUniform()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    emitSemantic(semantic: string) {\r\n        // disabling of semantics emission.\r\n    }\r\n\r\n    protected emitPrologue(def: IFunctionDefInstruction): void {\r\n        this.begin();\r\n        {\r\n            this.emitLine(`precision highp float;`);\r\n            this.emitLine(`precision highp int;`);\r\n        }\r\n        this.end();\r\n        this.begin();\r\n        {\r\n            for (const param of def.params) {\r\n                if (param.type.isUniform()) {\r\n                    continue;\r\n                }\r\n\r\n                const type = param.type;\r\n\r\n                this.emitComment(param.toCode());\r\n                this.emitNewline();\r\n\r\n                if (!type.isComplex()) {\r\n                    assert(type.isNotBaseArray());\r\n                    this.emitVaryingOrAttribute(param);\r\n                    continue;\r\n                }\r\n\r\n                type.fields.forEach(field => {\r\n                    assert(!field.type.isNotBaseArray() && !field.type.isComplex());\r\n                    this.emitVaryingOrAttribute(field);\r\n                });\r\n            }\r\n        }\r\n        this.end();\r\n\r\n        this.begin();\r\n        {\r\n            for (const param of def.params) {\r\n                if (!param.type.isUniform()) {\r\n                    continue;\r\n                }\r\n\r\n                this.emitVariableDecl(param);\r\n            }\r\n        }\r\n        this.end();\r\n\r\n\r\n        if (this.mode === 'vertex') {\r\n            this.begin();\r\n            {\r\n                const retType = def.returnType;\r\n                assert(retType.isComplex(), 'basic types unsupported yet');\r\n\r\n                retType.fields.forEach(field => {\r\n                    assert(!field.type.isNotBaseArray() && !field.type.isComplex());\r\n                    this.emitVarying(field);\r\n                });\r\n            }\r\n            this.end();\r\n        }\r\n    }\r\n\r\n    protected emitAttribute(decl: IVariableDeclInstruction) {\r\n        return (this.emitKeyword('attribute'), this.emitVariableDecl(decl, sname.attr), this.emitChar(';'), this.emitNewline());\r\n    }\r\n\r\n    protected emitVarying(decl: IVariableDeclInstruction) {\r\n        return (this.emitKeyword('varying'), this.emitVariableDecl(decl, sname.varying), this.emitChar(';'), this.emitNewline());\r\n    }\r\n\r\n    protected emitVaryingOrAttribute(decl: IVariableDeclInstruction) {\r\n        switch(this.mode) {\r\n            case 'vertex':\r\n                return this.emitAttribute(decl);\r\n            case 'pixel':\r\n                return this.emitVarying(decl);\r\n        }\r\n    }\r\n\r\n    emitFloat(lit: ILiteralInstruction<number>) {\r\n        const sval = String(lit.value);\r\n        this.emitKeyword(sval);\r\n        (sval.indexOf('.') === -1) && this.emitChar('.0');\r\n    }\r\n\r\n    emitPostfixPoint(pfxp: IPostfixPointInstruction) {\r\n        if (this.isVaryingOrAttributeAlias(pfxp)) {\r\n            this.emitKeyword(this.mode === 'vertex' ? sname.attr(pfxp.postfix.decl) : sname.varying(pfxp.postfix.decl));\r\n            return;\r\n        }\r\n        \r\n        super.emitPostfixPoint(pfxp);\r\n    }\r\n\r\n    emitIdentifier(id: IIdExprInstruction) {\r\n        super.emitIdentifier(id);\r\n    }\r\n\r\n\r\n    emitFCall(call: IFunctionCallInstruction) {\r\n        const decl = call.decl;\r\n        const args = call.args;\r\n\r\n        switch (decl.name) {\r\n            case 'mul':\r\n                assert(args.length == 2);\r\n                this.emitMulIntrinsic(args[0], args[1]);\r\n                return;\r\n        }\r\n        \r\n        super.emitFCall(call);\r\n    }\r\n\r\n\r\n    emitFunction(fn: IFunctionDeclInstruction) {\r\n        const def = fn.def;\r\n        const retType = def.returnType;\r\n\r\n        if (this.depth() === 0 && this.mode !== 'raw') {\r\n            this.emitPrologue(fn.def);\r\n            const { typeName } = this.resolveType(def.returnType);\r\n\r\n            // emit original function witout parameters\r\n            this.begin();\r\n            {\r\n                this.emitKeyword(typeName);\r\n                this.emitKeyword(fn.name);\r\n                this.emitChar('(');\r\n                this.emitChar(')');\r\n                this.emitNewline();\r\n                this.emitBlock(fn.impl);\r\n            }\r\n            this.end();\r\n\r\n            // emit main()\r\n            this.begin();\r\n            {\r\n                this.emitChar('void main(void)');\r\n                this.emitNewline();\r\n                this.emitChar('{');\r\n                this.push();\r\n                {\r\n                    const tempName = 'temp';\r\n\r\n                    this.emitKeyword(typeName);\r\n                    this.emitKeyword(tempName);\r\n                    this.emitKeyword('=');\r\n                    this.emitKeyword(fn.name);\r\n                    this.emitChar('()');\r\n                    this.emitChar(';');\r\n                    this.emitNewline();\r\n\r\n                    if (this.mode === 'vertex') {\r\n                        retType.fields.forEach(field => {\r\n                            const varyingName = sname.varying(field);\r\n                            this.emitKeyword(varyingName);\r\n                            this.emitKeyword('=');\r\n                            this.emitKeyword(tempName);\r\n                            this.emitChar('.');\r\n                            this.emitChar(field.name);\r\n                            this.emitChar(';');\r\n                            this.emitNewline();\r\n                        });\r\n\r\n                        const fieldPos = retType.fields.filter(field => (field.semantic === 'POSITION'))[0];\r\n                        this.emitKeyword('gl_Position');\r\n                        this.emitKeyword('=');\r\n                        this.emitKeyword(tempName);\r\n                        this.emitChar('.');\r\n                        this.emitChar(fieldPos.name);\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    } else { // pixel\r\n                        this.emitKeyword('gl_FragColor');\r\n                        this.emitKeyword('=');\r\n                        this.emitKeyword(tempName);\r\n                        this.emitChar(';');\r\n                        this.emitNewline();\r\n                    }\r\n                }\r\n                this.pop();\r\n                this.emitChar('}');\r\n            }\r\n            this.end();\r\n            return;\r\n        }\r\n\r\n        super.emitFunction(fn);\r\n    }\r\n\r\n    \r\n    //\r\n    // intrinsics\r\n    //\r\n\r\n    emitMulIntrinsic(left: IExprInstruction, right: IExprInstruction) {\r\n        this.emitChar('(');\r\n        this.emitExpression(left);\r\n        this.emitKeyword('*');\r\n        this.emitExpression(right);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    static $declToAttributeName(decl: IVariableDeclInstruction) {\r\n        return sname.attr(decl);\r\n    }\r\n}\r\n\r\n\r\nexport function translate(instr: IInstruction, options?: ICodeEmitterOptions): string {\r\n    return (new GlslEmitter(options)).emit(instr).toString();\r\n}\r\n","import { connectRouter } from 'connected-react-router';\r\nimport { createHashHistory } from 'history';\r\n\r\nexport const history = createHashHistory();\r\n\r\nexport default connectRouter(history);","/* tslint:disable:typedef */\r\n\r\nimport { isArray } from '@lib/common';\r\nimport * as fs1 from 'fs';\r\nimport * as isElectron from 'is-electron-renderer';\r\nimport * as path from 'path';\r\nimport * as React from 'react';\r\nimport { List } from 'semantic-ui-react';\r\nimport { promisify } from 'util';\r\n\r\ninterface IFileListViewProps {\r\n    path: string;\r\n    onFileClick: (file: string) => void;\r\n    filters?: string[];\r\n}\r\n\r\nconst FileDirectoryIcon: any = 'file directory';\r\nconst FileCodeIcon: any = 'file code';\r\n\r\ninterface IFolder {\r\n    path: string;\r\n    folders?: IFolder[];\r\n    files?: string[];\r\n    shown?: boolean;\r\n    totalFiles: number;\r\n}\r\n\r\n\r\nconst fs = {\r\n    stat: isElectron ?\r\n        promisify(fs1.lstat) :\r\n        (dir) => ({\r\n            isDirectory() { return false },\r\n            isFile() { return false }\r\n        }),\r\n    readdir: isElectron ?\r\n        promisify(fs1.readdir) : null\r\n}\r\n\r\n\r\n// todo: remove \"sync\" calls\r\n\r\nasync function scan($dir: string, node: IFolder, filters?: string[]) {\r\n    if (!isElectron) {\r\n        node.files = [\r\n            'sphere.fx',\r\n            'part.fx',\r\n            'holographicTable.fx',\r\n            'messy.fx',\r\n            'speed.fx',\r\n            'errorHandling.fx',\r\n            'autotests.fx',\r\n            'tail.fx',\r\n            'tree.fx'\r\n        ].map(file => `./assets/fx/tests/${file}`).sort();\r\n        node.path = 'tests';\r\n        node.totalFiles = 5;\r\n        return;\r\n    }\r\n\r\n    try {\r\n        node.path = $dir;\r\n\r\n        const dir = path.join(path.dirname(window.location.pathname.substr(1)), $dir);\r\n\r\n        let stats = await fs.stat(dir);\r\n        if (!stats.isDirectory()) {\r\n            return;\r\n        }\r\n\r\n        (await fs.readdir(dir)).forEach(async filename => {\r\n            let $filepath = path.join($dir, filename);\r\n            let filepath = path.join(dir, filename);\r\n            let filestats = await fs.stat(filepath);\r\n\r\n            if (filestats.isFile()) {\r\n                if (!filters || filters.indexOf(path.extname(filename)) != -1) {\r\n                    node.files = node.files || [];\r\n                    node.files.push($filepath);\r\n                    node.totalFiles++;\r\n                }\r\n            }\r\n\r\n            if (filestats.isDirectory()) {\r\n                node.folders = node.folders || [];\r\n\r\n                let subfolder = { path: $filepath, totalFiles: 0 };\r\n                scan($filepath, subfolder, filters);\r\n\r\n                node.folders.push(subfolder);\r\n                node.totalFiles += subfolder.totalFiles;\r\n            }\r\n        });\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}\r\n\r\nclass FileListView extends React.Component<IFileListViewProps, {}> {\r\n    state: { root: IFolder };\r\n\r\n    constructor(props: IFileListViewProps) {\r\n        super(props);\r\n        this.state = { root: { path: null, shown: true, totalFiles: 0 } };\r\n    }\r\n\r\n    UNSAFE_componentWillUpdate(nextProps: IFileListViewProps, nextState) {\r\n        const { state } = this;\r\n\r\n        if (state.root.path === nextProps.path) {\r\n            return;\r\n        }\r\n\r\n        scan(nextProps.path, state.root, nextProps.filters);\r\n    }\r\n\r\n\r\n    renderFolder(folder: IFolder) {\r\n        if (!folder || !folder.path || !folder.totalFiles) {\r\n            return null;\r\n        }\r\n\r\n        return (\r\n            <List.Item key={ folder.path }>\r\n                <List.Icon name={ FileDirectoryIcon } />\r\n                <List.Content>\r\n                    <List.Header onClick={ () => { folder.shown = !folder.shown; this.forceUpdate(); } }>\r\n                        { path.basename(folder.path) }\r\n                    </List.Header>\r\n                    { folder.shown && (isArray(folder.folders) || isArray(folder.files)) &&\r\n                        <List.List>\r\n                            { (folder.folders || []).map(folder => this.renderFolder(folder)) }\r\n                            { (folder.files || []).map(file => this.renderFile(file)) }\r\n                        </List.List>\r\n                    }\r\n                </List.Content>\r\n            </List.Item>\r\n        );\r\n    }\r\n\r\n    renderFile(file: string) {\r\n        if (!file) {\r\n            return null;\r\n        }\r\n\r\n        return (\r\n            <List.Item onClick={ () => this.props.onFileClick(file) } key={ file }>\r\n                <List.Icon name={ FileCodeIcon } />\r\n                <List.Content>\r\n                    <List.Header>{ path.basename(file) }</List.Header>\r\n                </List.Content>\r\n            </List.Item>\r\n        );\r\n    }\r\n\r\n    render() {\r\n        // temp check in order to be compatible with browsers;\r\n        // if (!isElectron) {\r\n        //     return null;\r\n        // }\r\n\r\n        const { root } = this.state;\r\n        return (\r\n            <List selection>\r\n                { this.renderFolder(root) }\r\n            </List>\r\n        );\r\n    }\r\n}\r\n\r\nexport default FileListView;\r\n","import { isString } from '@lib/common';\r\nimport { IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { ETokenType, IFile, ILexerEngine, IPosition, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { StringRef } from '@lib/util/StringRef';\r\n\r\nimport { END_SYMBOL, EOF, ERROR, T_FLOAT, T_LINE_TERMINATOR, T_NON_TYPE_ID, T_STRING, T_TYPE_ID, T_UINT, UNKNOWN_TOKEN } from './symbols';\r\n\r\ninterface ILexerDiagDesc {\r\n    file: string;\r\n    token: IToken;\r\n}\r\n\r\n\r\nenum ELexerErrors {\r\n    UnknownToken = 2101,\r\n    InvalidToken = 2102\r\n};\r\n\r\n\r\nclass LexerDiagnostics extends Diagnostics<ILexerDiagDesc> {\r\n    constructor() {\r\n        super(\"Lexer Diagnostics\", 'L');\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: ILexerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: ILexerDiagDesc): IRange {\r\n        return desc.token.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [ELexerErrors.UnknownToken]: \"Unknown token: {token.value}.\",\r\n            [ELexerErrors.InvalidToken]: \"Invalid token: {token.value}.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport class LexerEngine implements ILexerEngine {\r\n    readonly keywords: IMap<string> = {};\r\n    readonly punctuators: IMap<string> = {};\r\n    readonly punctuatorsFirstSymbols: IMap<boolean> = {};\r\n\r\n\r\n    addPunctuator(value: string, name: string = LexerEngine.getPunctuatorName(value)): string {\r\n        this.punctuators[value] = name;\r\n        this.punctuatorsFirstSymbols[value[0]] = true;\r\n        return name;\r\n    }\r\n\r\n\r\n    addKeyword(value: string, name: string): string {\r\n        this.keywords[value] = name;\r\n        return name;\r\n    }\r\n\r\n\r\n    getTerminalValueByName(name: string): string {\r\n        let value = \"\";\r\n\r\n        for (value in this.punctuators) {\r\n            if (this.punctuators[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        for (value in this.keywords) {\r\n            if (this.keywords[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    isLineTerminator(symbol: string): boolean {\r\n        return (symbol === \"\\n\" || symbol === \"\\r\" || symbol === \"\\u2028\" || symbol === \"\\u2029\");\r\n    }\r\n\r\n\r\n    isKeyword(value: string): boolean {\r\n        return !!(this.keywords[value]);\r\n    }\r\n\r\n\r\n    isPunctuator(value: string): boolean {\r\n        return !!(this.punctuators[value]);\r\n    }\r\n\r\n\r\n    isNumberStart(ch: string, ch1: string): boolean {\r\n        if ((ch >= \"0\") && (ch <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        if (ch === \".\" && (ch1 >= \"0\") && (ch1 <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isCommentStart(ch: string, ch1: string): boolean {\r\n        if (ch === \"/\" && (ch1 === \"/\" || ch1 === \"*\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isStringStart(ch: string): boolean {\r\n        if (ch === \"\\\"\" || ch === \"'\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isPunctuatorStart(ch: string): boolean {\r\n        if (this.punctuatorsFirstSymbols[ch]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isWhiteSpaceStart(ch: string): boolean {\r\n        if (ch === \" \" || ch === \"\\t\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isNewlineStart(ch: string): boolean {\r\n        if (ch === \"\\n\" || ch === \"\\r\" ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isIdentifierStart(ch: string): boolean {\r\n        if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    static getPunctuatorName(value: string): string {\r\n        return \"T_PUNCTUATOR_\" + value.charCodeAt(0);\r\n    }\r\n}\r\n\r\ninterface ILexerConfig {\r\n    engine?: LexerEngine;\r\n    knownTypes?: Set<string>;\r\n    skipComments?: boolean;\r\n}\r\n\r\nexport class Lexer {\r\n    index: number;\r\n    lineNumber: number;\r\n    columnNumber: number;\r\n    uri: IFile;\r\n    source: string;\r\n\r\n    engine: LexerEngine;\r\n    diagnostics: LexerDiagnostics;\r\n    knownTypes: Set<string>;\r\n    skipComments: boolean;\r\n\r\n    constructor({ engine = new LexerEngine, knownTypes = new Set(), skipComments = true }: ILexerConfig) {\r\n        this.lineNumber = 0;\r\n        this.columnNumber = 0;\r\n        this.index = 0;\r\n\r\n        this.diagnostics = new LexerDiagnostics;\r\n        this.knownTypes = knownTypes;\r\n        this.engine = engine;\r\n        this.skipComments = skipComments;\r\n    }\r\n\r\n    setup(textDocument: ITextDocument) {\r\n        this.uri = StringRef.make(textDocument.uri);\r\n        this.source = textDocument.source;\r\n    }\r\n\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return this.diagnostics.resolve();\r\n    }\r\n\r\n\r\n    getNextToken(allowLineTerminators?: boolean): IToken {\r\n        let ch = this.currentChar();\r\n        if (!ch) {\r\n            let pos = this.pos();\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: END_SYMBOL,\r\n                value: END_SYMBOL,\r\n                loc: {\r\n                    start: pos,\r\n                    end: { ...pos }\r\n                }\r\n            };\r\n        }\r\n        let tokenType = this.identityTokenType();\r\n        let token: IToken = null;\r\n        switch (tokenType) {\r\n            case ETokenType.k_NumericLiteral:\r\n                token = this.scanNumber();\r\n                break;\r\n            case ETokenType.k_SinglelineCommentLiteral:\r\n            case ETokenType.k_MultilineCommentLiteral:\r\n                token = this.scanComment();\r\n                if (this.skipComments) {\r\n                    token = this.getNextToken();\r\n                }\r\n                break;\r\n            case ETokenType.k_StringLiteral:\r\n                token = this.scanString();\r\n                break;\r\n            case ETokenType.k_PunctuatorLiteral:\r\n                token = this.scanPunctuator();\r\n                break;\r\n            case ETokenType.k_IdentifierLiteral:\r\n                token = this.scanIdentifier();\r\n                break;\r\n            case ETokenType.k_NewlineLiteral:\r\n                token = this.scanLineTerminators();\r\n                if (!allowLineTerminators) {\r\n                    token = this.getNextToken();\r\n                }\r\n                break;\r\n            case ETokenType.k_WhitespaceLiteral:\r\n                this.scanWhiteSpace();\r\n                token = this.getNextToken();\r\n                break;\r\n            default:\r\n                {\r\n                    // TODO: move this code to scanInvalid()\r\n                    const start = this.pos();\r\n                    let value = '';\r\n                    while (this.identityTokenType() === ETokenType.k_Unknown && this.index < this.source.length) {\r\n                        value += this.currentChar();\r\n                        this.readNextChar();\r\n                    }\r\n                    token = {\r\n                        index: this.index,\r\n                        name: UNKNOWN_TOKEN,\r\n                        value,\r\n                        loc: { start, end: this.pos() }\r\n                    };\r\n                    // console.warn(value);\r\n                    this.emitError(ELexerErrors.UnknownToken, token);\r\n                    return token;\r\n                }\r\n        }\r\n        return token;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    getLocation() {\r\n        return { line: this.lineNumber, file: this.uri };\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    setSource(sSource: string): void {\r\n        this.source = sSource;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    setIndex(iIndex: number): void {\r\n        this.index = iIndex;\r\n    }\r\n\r\n\r\n    private pos(n: number = 0): IPosition {\r\n        return {\r\n            file: this.uri,\r\n            line: this.lineNumber,\r\n            column: this.columnNumber + n,\r\n            offset: this.index + n\r\n        };\r\n    }\r\n\r\n\r\n    private emitError(code: number, token: IToken): void {\r\n        this.diagnostics.error(code, { file: `${this.uri}`, token });\r\n    }\r\n\r\n\r\n    private identityTokenType(): ETokenType {\r\n        if (this.isIdentifierStart()) {\r\n            return ETokenType.k_IdentifierLiteral;\r\n        }\r\n        if (this.isWhiteSpaceStart()) {\r\n            return ETokenType.k_WhitespaceLiteral;\r\n        }\r\n        if (this.isNewlineStart()) {\r\n            return ETokenType.k_NewlineLiteral;\r\n        }\r\n        if (this.isStringStart()) {\r\n            return ETokenType.k_StringLiteral;\r\n        }\r\n        if (this.isCommentStart()) {\r\n            // TODO: return exact type (separate multiline/singleline comment parsings)\r\n            return ETokenType.k_SinglelineCommentLiteral;\r\n        }\r\n        if (this.isNumberStart()) {\r\n            return ETokenType.k_NumericLiteral;\r\n        }\r\n        if (this.isPunctuatorStart()) {\r\n            return ETokenType.k_PunctuatorLiteral;\r\n        }\r\n        return ETokenType.k_Unknown;\r\n    }\r\n\r\n\r\n    private isNumberStart(): boolean {\r\n        return this.engine.isNumberStart(this.currentChar(), this.nextChar());\r\n    }\r\n\r\n\r\n    private isCommentStart(): boolean {\r\n        return this.engine.isCommentStart(this.currentChar(), this.nextChar())\r\n    }\r\n\r\n\r\n    private isStringStart(): boolean {\r\n        return this.engine.isStringStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isPunctuatorStart(): boolean {\r\n        return this.engine.isPunctuatorStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isWhiteSpaceStart(): boolean {\r\n        return this.engine.isWhiteSpaceStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isNewlineStart(): boolean {\r\n        return this.engine.isNewlineStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isIdentifierStart(): boolean {\r\n        return this.engine.isIdentifierStart(this.currentChar());\r\n    }\r\n\r\n\r\n\r\n\r\n    private nextChar(): string {\r\n        return this.source[this.index + 1];\r\n    }\r\n\r\n\r\n    private currentChar(): string {\r\n        return this.source[<number>this.index];\r\n    }\r\n\r\n\r\n    private readNextChar(): string {\r\n        this.index++;\r\n        this.columnNumber++;\r\n        return this.source[<number>this.index];\r\n    }\r\n\r\n\r\n    private scanString(): IToken {\r\n        let chFirst = this.currentChar();\r\n        let value = chFirst;\r\n        let ch = \"\";\r\n        let chPrevious = chFirst;\r\n        let isGoodFinish = false;\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            value += ch;\r\n            if (ch === chFirst && chPrevious !== \"\\\\\") {\r\n                isGoodFinish = true;\r\n                this.readNextChar();\r\n                break;\r\n            }\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: T_STRING,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_StringLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanPunctuator(): IToken {\r\n        let value = this.currentChar();\r\n        let start = this.pos();\r\n        let ch: string;\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch) {\r\n                value += ch;\r\n                if (!this.engine.isPunctuator(value)) {\r\n                    value = value.slice(0, value.length - 1);\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return <IToken>{\r\n            index: this.index,\r\n            name: this.engine.punctuators[value],\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    private scanNumber(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = \"\";\r\n        let isFloat = false;\r\n        let chPrevious = ch;\r\n        let isGoodFinish = false;\r\n        let isE = false; // exponential\r\n        let isU = false; // unsigned\r\n        let start = this.pos();\r\n\r\n        if (ch === \".\") {\r\n            value += 0;\r\n            isFloat = true;\r\n        }\r\n\r\n        value += ch;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch === \".\") {\r\n                if (isFloat || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isFloat = true;\r\n                }\r\n            }\r\n            else if (ch === \"e\") {\r\n                if (isE || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isE = true;\r\n                }\r\n            }\r\n            else if (ch === \"u\") {\r\n                if (isE || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isU = true;\r\n                }\r\n            }\r\n            else if (((ch === \"+\" || ch === \"-\") && chPrevious === \"e\")) {\r\n                value += ch;\r\n                chPrevious = ch;\r\n                continue;\r\n            }\r\n            else if (ch === \"f\" && isFloat) {\r\n                ch = this.readNextChar();\r\n                if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                    break;\r\n                }\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            else if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                break;\r\n            }\r\n            else if (!((ch >= \"0\") && (ch <= \"9\")) || !ch || isU) {\r\n                if ((isE && chPrevious !== \"+\" && chPrevious !== \"-\" && chPrevious !== \"e\") || !isE) {\r\n                    isGoodFinish = true;\r\n                }\r\n                break;\r\n            }\r\n            value += ch;\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            let name = isFloat ? T_FLOAT : T_UINT;\r\n            return <IToken>{\r\n                index: this.index,\r\n                name,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_NumericLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanIdentifier(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = ch;\r\n        let start = this.pos();\r\n        let isGoodFinish = false;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            if (!((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\") || (ch >= \"0\" && ch <= \"9\"))) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            value += ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            if (this.engine.isKeyword(value)) {\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name: this.engine.keywords[value],\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                let name = this.knownTypes.has(value) ? T_TYPE_ID : T_NON_TYPE_ID;\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_IdentifierLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanLineTerminators(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = '';\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            if (this.engine.isLineTerminator(ch)) {\r\n                value += ch;\r\n                if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                    this.lineNumber--;\r\n                }\r\n                this.lineNumber++;\r\n                ch = this.readNextChar();\r\n                this.columnNumber = 0;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n\r\n        let name = T_LINE_TERMINATOR;\r\n        return <IToken>{\r\n            index: this.index,\r\n            name,\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n    private scanWhiteSpace(): boolean {\r\n        let ch = this.currentChar();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"\\t\") {\r\n                // possible way to convert tab to multiple spaces\r\n                this.columnNumber += 0;\r\n            }\r\n            else if (ch !== \" \") {\r\n                break;\r\n            }\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private scanComment(): IToken {\r\n        let value = this.currentChar();\r\n        let ch = this.readNextChar();\r\n        let start = this.pos();\r\n        value += ch;\r\n\r\n        if (ch === \"/\") {\r\n            //Line Comment\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.readNextChar();\r\n                    this.columnNumber = 0;\r\n                    break;\r\n                }\r\n                value += ch;\r\n            }\r\n\r\n            return {\r\n                index: this.index,\r\n                type: ETokenType.k_SinglelineCommentLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            //Multiline Comment\r\n            let chPrevious = ch;\r\n            let isGoodFinish = false;\r\n            let start = this.pos();\r\n\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                value += ch;\r\n                if (ch === \"/\" && chPrevious === \"*\") {\r\n                    isGoodFinish = true;\r\n                    this.readNextChar();\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.columnNumber = -1;\r\n                }\r\n                chPrevious = ch;\r\n            }\r\n\r\n            if (isGoodFinish) {\r\n                return {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                if (!ch) {\r\n                    ch = EOF;\r\n                }\r\n                value += ch;\r\n\r\n                const token = {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n\r\n                this.emitError(ELexerErrors.InvalidToken, token);\r\n                return Lexer.makeUnknownToken(token);\r\n            }\r\n        }\r\n    }\r\n\r\n    static makeUnknownToken(token: IToken): IToken {\r\n        return {\r\n            ...token,\r\n            type: undefined,\r\n            name: UNKNOWN_TOKEN,\r\n            loc: {\r\n                start: { ...token.loc.start },\r\n                end: { ...token.loc.end }\r\n            }\r\n        };\r\n    }\r\n}\r\n","/* tslint:disable:no-for-in */\r\n/* tslint:disable:forin */\r\n/* tslint:disable:typedef */\r\n\r\n\r\nimport { deepEqual, isNull } from '@lib/common';\r\nimport { cdlview } from '@lib/fx/bytecode/DebugLayout';\r\nimport DistinctColor from '@lib/util/DistinctColor';\r\nimport { mapActions, sourceCode as sourceActions } from '@sandbox/actions';\r\nimport { IWithStyles } from '@sandbox/components';\r\nimport { getCommon, mapProps } from '@sandbox/reducers';\r\nimport { getParser } from '@sandbox/reducers/parserParams';\r\nimport { getFileState } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState, { IFileState, IParserState } from '@sandbox/store/IStoreState';\r\nimport autobind from 'autobind-decorator';\r\nimport * as Comlink from 'comlink';\r\nimport * as monaco from 'monaco-editor';\r\nimport { MonacoToProtocolConverter, ProtocolToMonacoConverter } from 'monaco-languageclient/lib/monaco-converter';\r\nimport * as React from 'react';\r\nimport injectSheet from 'react-jss';\r\nimport MonacoEditor from 'react-monaco-editor';\r\nimport { connect } from 'react-redux';\r\nimport { Diagnostic, DiagnosticSeverity, TextDocument, TextDocumentIdentifier } from 'vscode-languageserver-types';\r\n// tslint:disable-next-line:no-submodule-imports\r\nimport LanguageServiceWorker from 'worker-loader!./LanguageServiceProvider';\r\nimport { ILanguageServiceProvider } from './LanguageServiceProvider';\r\nimport styles from './styles.jss';\r\n\r\n\r\nconst m2p = new MonacoToProtocolConverter();\r\nconst p2m = new ProtocolToMonacoConverter();\r\n\r\nconst provider = Comlink.wrap<ILanguageServiceProvider>(new LanguageServiceWorker());\r\n\r\nfunction defer() {\r\n    const deferred = {\r\n        promise: null,\r\n        resolve: null,\r\n        reject: null\r\n    };\r\n\r\n    // tslint:disable-next-line:promise-must-complete\r\n    deferred.promise = new Promise((resolve, reject) => {\r\n        deferred.resolve = resolve;\r\n        deferred.reject = reject;\r\n    });\r\n\r\n    return deferred;\r\n}\r\n\r\ntype IDefer = ReturnType<typeof defer>;\r\n\r\nconst LANGUAGE_ID = 'hlsl';\r\n\r\ninterface ILang extends monaco.languages.ILanguageExtensionPoint {\r\n    loader: () => Promise<ILangImpl>;\r\n}\r\n\r\ninterface ILangImpl {\r\n    conf: monaco.languages.LanguageConfiguration;\r\n    language: monaco.languages.IMonarchLanguage;\r\n}\r\n\r\nasync function loadLanguage(def: ILang): Promise<void> {\r\n    const mod = await def.loader();\r\n    monaco.languages.setMonarchTokensProvider(def.id, mod.language);\r\n    monaco.languages.setLanguageConfiguration(def.id, mod.conf);\r\n}\r\n\r\nfunction registerLanguage(def: ILang): void {\r\n    monaco.languages.register(def);\r\n    monaco.languages.onLanguage(def.id, () => { loadLanguage(def); });\r\n}\r\n\r\n// register the HLSL language with Monaco\r\nregisterLanguage({\r\n    id: LANGUAGE_ID,\r\n    extensions: ['.fx', '.vsh', '.psh', '.hsh', '.dsh', '.csh'],\r\n    aliases: ['HLSL', 'hlsl', 'openhlsl'],\r\n    mimetypes: ['application/hlsl'],\r\n    loader: () => import('./hlsl')\r\n});\r\n\r\n\r\nconst options: monaco.editor.IEditorConstructionOptions = {\r\n    selectOnLineNumbers: true,\r\n    fontSize: 12,\r\n    renderWhitespace: 'none',\r\n    lineHeight: 14,\r\n    minimap: {\r\n        enabled: false\r\n    },\r\n    automaticLayout: true,\r\n    glyphMargin: true,\r\n    theme: 'vs-dark',\r\n    language: LANGUAGE_ID,\r\n    lineDecorationsWidth: 0,\r\n    cursorSmoothCaretAnimation: true,\r\n    fontLigatures: true\r\n};\r\n\r\n\r\n\r\nexport interface ISourceEditorProps extends IStoreState, IWithStyles<typeof styles> {\r\n    name?: string;\r\n    actions: typeof sourceActions;\r\n}\r\n\r\n\r\n\r\n@injectSheet(styles)\r\nclass SourceEditor extends React.Component<ISourceEditorProps> {\r\n\r\n    codeLensProvider: monaco.IDisposable = null;\r\n    hoverProvider: monaco.IDisposable = null;\r\n    completionProvider: monaco.IDisposable = null;\r\n    documentSymbolProvider: monaco.IDisposable = null;\r\n    signatureHelpProvider: monaco.IDisposable = null;\r\n\r\n    mouseDownEvent: monaco.IDisposable = null;\r\n\r\n    // cache for previously set decorations/breakpoints\r\n    decorations: string[] = [];\r\n\r\n    pendingValidationRequests = new Map<string, number>();\r\n    deferredRequests: IDefer[] = [];\r\n\r\n    // cache for params\r\n    parserParamsCache: Object = {};\r\n\r\n    model: monaco.editor.ITextModel;\r\n\r\n    setupDecorations(): monaco.editor.IModelDeltaDecoration[] {\r\n        const { props } = this;\r\n        const { classes } = props;\r\n\r\n        const decorations: monaco.editor.IModelDeltaDecoration[] = [];\r\n\r\n        const cls = {\r\n            error: classes.errorMarker,\r\n            warning: classes.warningMarker\r\n        };\r\n\r\n\r\n        const file = this.getFile();\r\n        for (const key in file.markers) {\r\n            const { range, type, tooltip, range: { start, end }, payload } = file.markers[key];\r\n            if (!tooltip && type === 'marker') {\r\n                decorations.push({\r\n                    range: new monaco.Range(start.line + 1, start.column + 1, end.line + 1, end.column + 1),\r\n                    options: { inlineClassName: classes.yellowMarker }\r\n                });\r\n            } else {\r\n                switch (type) {\r\n                    case 'error':\r\n                        decorations.push({\r\n                            range: new monaco.Range(start.line + 1, start.column + 1, end.line + 1, end.column + 1),\r\n                            options: { className: cls[type], hoverMessage: { value: tooltip } },\r\n                        });\r\n                        break;\r\n                    case 'line':\r\n                        decorations.push({\r\n                            range: new monaco.Range(start.line + 1, 0, start.line + 1, 0),\r\n                            options: {\r\n                                isWholeLine: true,\r\n                                className: classes[`dc_${DistinctColor.resolveColor(payload['color'])}`]\r\n                            }\r\n                        });\r\n                        break;\r\n                    default:\r\n                }\r\n            }\r\n        }\r\n\r\n        // fixme: clumsy code :/\r\n        for (const key in file.breakpoints) {\r\n            const lineNumber = file.breakpoints[key] + 1;\r\n            decorations.push({\r\n                range: new monaco.Range(lineNumber, 1, lineNumber, 1),\r\n                options: { glyphMarginClassName: classes.breakpoint },\r\n            });\r\n        }\r\n\r\n        return decorations;\r\n    }\r\n\r\n    // handle content's update from outside of the editor\r\n    UNSAFE_componentWillUpdate(nextProps) {\r\n        const file = getFileState(nextProps);\r\n        if (isNull(file.content)) {\r\n            return;\r\n        }\r\n\r\n        if (file.content !== this.getContent()) {\r\n            this.validate(file.content, file.uri);\r\n            this.getEditor().setValue(file.content);\r\n            console.log('%c force reload content from outside', 'background: #ffd1c9; color: #ff3714');\r\n        }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.updateDecorations();\r\n\r\n        // TEMP: temp solution for parser param sync\r\n        const parserStateNext = getParser(this.props);\r\n        this.validateParser(parserStateNext);\r\n    }\r\n\r\n    componentDidMount() {\r\n         // TEMP: temp solution for parser param sync\r\n         const parserStateNext = getParser(this.props);\r\n         this.validateParser(parserStateNext);\r\n    }\r\n\r\n    validateParser(parserStateNext: IParserState) {\r\n        const parserProps = [ 'flags', 'type', 'grammar', 'parsingFlags' ];\r\n        const paramsChanges = !parserProps.every(propName => this.parserParamsCache[propName] === parserStateNext[propName]);\r\n\r\n        if (paramsChanges) {\r\n            parserProps.forEach(propName => this.parserParamsCache[propName] = parserStateNext[propName]);\r\n\r\n            const { grammar, flags, type, parsingFlags } = parserStateNext;\r\n\r\n            if (grammar) {\r\n                provider.init({ grammar, flags, type }, parsingFlags);\r\n            }\r\n        }\r\n    }\r\n\r\n    @autobind\r\n    editorWillMount(editor) { }\r\n\r\n\r\n    pendingValidations() {\r\n        const def = defer();\r\n        if (this.pendingValidationRequests.size > 0) {\r\n            this.deferredRequests.push(def);\r\n            return def.promise;\r\n        }\r\n\r\n        def.resolve();\r\n        return def.promise;\r\n    }\r\n\r\n    // tslint:disable-next-line:max-func-body-length\r\n    @autobind\r\n    editorDidMount(editor: monaco.editor.IStandaloneCodeEditor) {\r\n        editor.getModel()\r\n            .updateOptions({ tabSize: 4 });\r\n\r\n        //\r\n        // naive breakpoints implementation\r\n        //\r\n\r\n        this.mouseDownEvent = editor.onMouseDown((e: monaco.editor.IEditorMouseEvent) => {\r\n            if (e.target.type !== monaco.editor.MouseTargetType.GUTTER_GLYPH_MARGIN) {\r\n                return;\r\n            }\r\n\r\n            const file = this.getFile();\r\n            const { props } = this;\r\n            const { breakpoints } = file;\r\n\r\n            let { lineNumber } = e.target.position;\r\n\r\n            lineNumber = cdlview(file.debugger.runtime.cdl)\r\n                .resolveBreakpointLocation(lineNumber - 1);\r\n\r\n            if (lineNumber === -1) {\r\n                return;\r\n            }\r\n\r\n            if (breakpoints.indexOf(lineNumber) === -1) {\r\n                props.actions.addBreakpoint(lineNumber);\r\n            } else {\r\n                props.actions.removeBreakpoint(lineNumber);\r\n            }\r\n        });\r\n\r\n        const self = this;\r\n        this.codeLensProvider = monaco.languages.registerCodeLensProvider(\r\n            LANGUAGE_ID,\r\n            {\r\n                async provideCodeLenses(model: monaco.editor.ITextModel, token: monaco.CancellationToken)\r\n                    : Promise<monaco.languages.CodeLensList> {\r\n\r\n                    // validation should always be done before any other requests\r\n                    await self.pendingValidations();\r\n\r\n                    const lenses = p2m.asCodeLenses(await provider.provideFxCodeLenses(self.asTextDocumentIdentifier()));\r\n                    return { lenses, dispose() { } };\r\n                }\r\n            });\r\n\r\n\r\n        this.completionProvider = monaco.languages.registerCompletionItemProvider(\r\n            LANGUAGE_ID,\r\n            {\r\n                triggerCharacters: ['(', ',', '=', '+'],\r\n                provideCompletionItems(model, position, context, token)\r\n                    : monaco.Thenable<monaco.languages.CompletionList> {\r\n                    // const document = self.createDocument(model);\r\n                    const wordUntil = model.getWordUntilPosition(position);\r\n                    const defaultRange = new monaco.Range(\r\n                        position.lineNumber, wordUntil.startColumn,\r\n                        position.lineNumber, wordUntil.endColumn\r\n                    );\r\n\r\n                    // return jsonService.doComplete(document,\r\n                    // m2p.asPosition(position.lineNumber, position.column), jsonDocument).then((list) => {\r\n                    //     return p2m.asCompletionResult(list, defaultRange);\r\n                    // });\r\n\r\n                    console.log('provideCompletionItems', defaultRange, wordUntil);\r\n\r\n                    return null;\r\n                },\r\n\r\n                resolveCompletionItem(model, position, item, token)\r\n                    : monaco.languages.CompletionItem | monaco.Thenable<monaco.languages.CompletionItem> {\r\n                    // return jsonService.doResolve(m2p.asCompletionItem(item)).then(result => p2m.asCompletionItem(result, item.range));\r\n                    console.log('resolveCompletionItem', m2p.asCompletionItem(item));\r\n                    return null;\r\n                }\r\n            });\r\n\r\n        // TODO: do not pass whole document\r\n        this.signatureHelpProvider = monaco.languages.registerSignatureHelpProvider(\r\n            LANGUAGE_ID,\r\n            {\r\n                signatureHelpTriggerCharacters: ['('],\r\n                signatureHelpRetriggerCharacters: [','],\r\n                async provideSignatureHelp(\r\n                    model: monaco.editor.ITextModel,\r\n                    position: monaco.Position,\r\n                    token,\r\n                    context: monaco.languages.SignatureHelpContext)\r\n                    : Promise<monaco.languages.SignatureHelpResult> {\r\n\r\n                    // validation should always be done before any other requests\r\n                    await self.pendingValidations();\r\n\r\n                    const signatureHelp = await provider.provideSignatureHelp(\r\n                        self.asTextDocumentIdentifier(), m2p.asPosition(position.lineNumber, position.column));\r\n                    return signatureHelp && { value: p2m.asSignatureHelp(signatureHelp), dispose() { } };\r\n                }\r\n            }\r\n        );\r\n\r\n        // this.documentSymbolProvider = monaco.languages.registerDocumentSymbolProvider(\r\n        //     LANGUAGE_ID, \r\n        //     {\r\n        //     provideDocumentSymbols(model, token): monaco.languages.DocumentSymbol[] | monaco.Thenable<monaco.languages.DocumentSymbol[]> {\r\n        //         const document = self.createDocument(model);\r\n        //         // const jsonDocument = jsonService.parseJSONDocument(document);\r\n        //         // return p2m.asSymbolInformations(jsonService.findDocumentSymbols(document, jsonDocument));\r\n\r\n        //         // return p2m.asSymbolInformations();\r\n        //     }\r\n        // });\r\n\r\n        // // const self = this;\r\n        // this.hoverProvider = monaco.languages.registerHoverProvider(\r\n        //     LANGUAGE_ID,\r\n        //     {\r\n        //         provideHover(model, position, token): monaco.languages.Hover | monaco.Thenable<monaco.languages.Hover> {\r\n        //             // const document = self.createDocument(model);\r\n        //             // const jsonDocument = jsonService.parseJSONDocument(document);\r\n        //             // console.log(model, position, token);\r\n        //             return null;\r\n        //         }\r\n        //     });\r\n    }\r\n\r\n    asTextDocumentIdentifier(): TextDocumentIdentifier {\r\n        return {\r\n            uri: this.getFile().uri\r\n        };\r\n    }\r\n\r\n\r\n    cleanPendingValidation(document: TextDocument): void {\r\n        const request = this.pendingValidationRequests.get(document.uri);\r\n        if (request !== undefined) {\r\n            clearTimeout(request);\r\n            this.pendingValidationRequests.delete(document.uri);\r\n        }\r\n    }\r\n\r\n\r\n    validate(newContent?: string, newUri?: string): void {\r\n        const document = this.createDocument(this.getModel(), newContent, newUri);\r\n\r\n        if (isNull(document.uri)) {\r\n            return;\r\n        }\r\n\r\n        this.cleanPendingValidation(document);\r\n        this.pendingValidationRequests.set(document.uri, setTimeout(async () => {\r\n            await this.doValidate(document);\r\n            this.pendingValidationRequests.delete(document.uri);\r\n        }));\r\n    }\r\n\r\n    // tslint:disable-next-line:member-ordering\r\n    static asMarker(diag: Diagnostic): monaco.editor.IMarkerData {\r\n        const { code, message, range: { start, end }, severity } = diag;\r\n\r\n        const severities = {\r\n            [DiagnosticSeverity.Error]: monaco.MarkerSeverity.Error,\r\n            [DiagnosticSeverity.Warning]: monaco.MarkerSeverity.Warning\r\n        };\r\n\r\n        return {\r\n            severity: severities[severity],\r\n            code: code as string,\r\n            message,\r\n            startLineNumber: start.line + 1,\r\n            startColumn: start.character + 1,\r\n            endLineNumber: end.line + 1,\r\n            endColumn: end.character + 1\r\n        };\r\n    }\r\n\r\n    async doValidate(document: TextDocument) {\r\n        if (document.getText().length === 0) {\r\n            this.cleanDiagnostics();\r\n            return;\r\n        }\r\n\r\n        // const messages = await LanguageService.validate(document);\r\n        const diagnostics = await provider.validate(document);\r\n        monaco.editor.setModelMarkers(this.getModel(), 'default', diagnostics.map(diag => SourceEditor.asMarker(diag)));\r\n        this.deferredRequests.forEach(def => def.resolve());\r\n        this.deferredRequests = [];\r\n    }\r\n\r\n\r\n    cleanDiagnostics(): void {\r\n        monaco.editor.setModelMarkers(this.getModel(), 'default', []);\r\n    }\r\n\r\n\r\n    @autobind\r\n    async onChange(content, e) {\r\n        this.validate(content);\r\n        this.props.actions.setContent(content);\r\n    }\r\n\r\n    getEditor(): monaco.editor.ICodeEditor {\r\n        // don't know better way :/\r\n        return (this.refs.monaco as any).editor;\r\n    }\r\n\r\n\r\n    getModel(): monaco.editor.ITextModel {\r\n        // tslint:disable-next-line:newline-per-chained-call\r\n        return this.getEditor().getModel();\r\n    }\r\n\r\n    getContent() {\r\n        // tslint:disable-next-line:newline-per-chained-call\r\n        return this.getModel().getValue();\r\n    }\r\n\r\n\r\n    createDocument(model: monaco.editor.IReadOnlyModel, newContent?: string, newUri?: string) {\r\n        return TextDocument.create(newUri || this.getFile().uri, model.getModeId(), model.getVersionId(), newContent || model.getValue());\r\n    }\r\n\r\n\r\n    updateDecorations() {\r\n        this.decorations = this.getEditor().deltaDecorations(this.decorations, this.setupDecorations());\r\n        return this.decorations;\r\n    }\r\n\r\n\r\n    shouldComponentUpdate(nextProps: ISourceEditorProps) {\r\n        const src = getFileState(this.props);\r\n        const dst = getFileState(nextProps);\r\n        return this.getContent() !== dst.content ||\r\n            !deepEqual(src.markers, dst.markers) ||\r\n            !deepEqual(src.breakpoints, dst.breakpoints);\r\n    }\r\n\r\n\r\n    componentWillUnmount() {\r\n        if (this.codeLensProvider) {\r\n            this.codeLensProvider.dispose();\r\n        }\r\n\r\n        if (this.hoverProvider) {\r\n            this.hoverProvider.dispose();\r\n        }\r\n    }\r\n\r\n    // componentWillMount() {\r\n    //     const file = this.getFile();\r\n    //     const uri = monaco.Uri.parse(`inmemory://${file.filename}`);\r\n    //     this.model = monaco.editor.createModel(file.content, LANGUAGE_ID, uri);\r\n    // }\r\n\r\n    render() {\r\n        const file = this.getFile();\r\n        // const uri = monaco.Uri.parse(`inmemory://${file.filename}`);\r\n        const content = file.content;\r\n\r\n        return (\r\n            <MonacoEditor\r\n                ref='monaco'\r\n                value={ content }\r\n                width='100%'\r\n                height='calc(100vh - 67px)' // todo: fixme\r\n\r\n                options={ options }\r\n                onChange={ this.onChange }\r\n                editorDidMount={ this.editorDidMount }\r\n                editorWillMount={ this.editorWillMount }\r\n            />\r\n        );\r\n    }\r\n\r\n\r\n    getFile(): IFileState {\r\n        return getFileState(this.props);\r\n    }\r\n}\r\n\r\nexport default connect<{}, {}, ISourceEditorProps>(mapProps(getCommon), mapActions(sourceActions))(SourceEditor) as any;\r\n\r\n\r\n","import * as bf from './bf';\r\nexport default bf;\r\n","import { assert, isDef } from \"@lib/common\";\r\nimport { IFunctionDeclInstruction, IInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport DistinctColor from \"@lib/util/DistinctColor\";\r\nimport { isNull } from \"util\";\r\n\r\nenum EDebugLineFlags {\r\n    k_NewStatement = 0x01\r\n};\r\n\r\nexport class DebugLineRecord {\r\n    pc: number;      // instruction addr;\r\n    file?: number;\r\n    line?: number;\r\n    column?: number; \r\n    flags: number;  // bitflags like: NS PE etc.\r\n    color?: number; // debug color, for easier code <=> asm matching\r\n}\r\n\r\n// process counter;\r\ntype PC = () => number;\r\n\r\nfunction debugLine(pc: PC) {\r\n    const files: string[] = [];\r\n    const layout: DebugLineRecord[] = [];\r\n\r\n    const lastRecord = () => layout[layout.length -1] || null;\r\n\r\n    // mark last record as 'new statement';\r\n    function ns() {\r\n        let rec = lastRecord();\r\n        // TOOD: allow breakpoints in case of no instructions have already beed added\r\n        if (rec) {\r\n            rec.flags |= EDebugLineFlags.k_NewStatement;\r\n        }\r\n    }\r\n\r\n    // add last instruction to record table;\r\n    function step() {\r\n        layout.push({ pc: pc(), flags: 0 })\r\n    }\r\n\r\n    // add filename to source files table and return index;\r\n    function fileToIndex(file: string) {\r\n        let idx = files.indexOf(file);\r\n        if (idx == -1) {\r\n            idx = files.length;\r\n            files.push(file);\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    function map(inst: IInstruction) {\r\n        const loc = (inst && inst.sourceNode && inst.sourceNode.loc) || null;\r\n        if (isNull(loc)) {\r\n            return;\r\n        }\r\n        \r\n        const pos = loc.start;\r\n        const rec = lastRecord();\r\n        rec.line = pos.line || 0;\r\n        rec.column = pos.column || 0;\r\n        rec.file = fileToIndex(`${pos.file}`);\r\n    }\r\n\r\n\r\n    function dump() {\r\n        let line = undefined;\r\n        let color = new DistinctColor;\r\n        let cache = {};\r\n        for (let i = layout.length - 1; i >= 0; i--) {\r\n            let entry = layout[i];\r\n\r\n            if (line != entry.line) color.pickNext();\r\n            line = isDef(entry.line) ? entry.line : line;\r\n            entry.line = line;\r\n            cache[line] = isDef(cache[line])? cache[line] : color.value();\r\n            entry.color = cache[line];\r\n        }\r\n        return { files, layout };\r\n    }\r\n\r\n    return {\r\n        ns,         // mark last record as 'new statement';\r\n        step,       // add last instruction(pc) to record table;\r\n        map,        // specify last record source location\r\n\r\n        dump\r\n    }\r\n}\r\n\r\nenum ETagType {\r\n    k_CompilationUnit,\r\n    k_SubProgram\r\n}\r\n\r\ninterface ITag {\r\n    tagType: ETagType;\r\n    children?: ITag[];\r\n}\r\n\r\ninterface ICompilationUnit extends ITag {\r\n    name: string; // path to file originally compiled;\r\n    lowPc: number;\r\n    highPc: number;\r\n}\r\n\r\ninterface ISubProgram extends ITag {\r\n    name: string;       // function name;\r\n    type: number;       // tag addr;\r\n    lowPc: number;\r\n    highPc: number;\r\n    declFile: string;   // file\r\n    declLine: number;\r\n}\r\n\r\nfunction debugInfo(pc: PC) {\r\n\r\n    let unitLayout: ITypeInstruction;\r\n\r\n    function locate(decl: IVariableDeclInstruction, reg: number) {\r\n\r\n    }\r\n\r\n    function beginCompilationUnit(name: string = null, layout: ITypeInstruction): void {\r\n        unitLayout = layout;\r\n    }\r\n    function endCompilationUnit(): void {};\r\n\r\n    function beginSubProgram(func: IFunctionDeclInstruction): void {}\r\n    function endSubProgram(): void {}\r\n\r\n    function dump() {\r\n        return {\r\n            layout: unitLayout\r\n        };\r\n    }\r\n\r\n    return {\r\n        beginCompilationUnit,\r\n        endCompilationUnit,\r\n        beginSubProgram,\r\n        endSubProgram,\r\n\r\n        locate,\r\n\r\n        dump\r\n    }\r\n}\r\n\r\n\r\n\r\nexport interface CDL {\r\n    line: ReturnType<ReturnType<typeof debugLine>['dump']>; // << descriptoption for each line\r\n    info: ReturnType<ReturnType<typeof debugInfo>['dump']>; // << empty for now\r\n}\r\n\r\nexport function debug (pc: PC) {\r\n    const line = debugLine(pc);\r\n    const info = debugInfo(pc);\r\n   \r\n    function dump(): CDL {\r\n        return {\r\n            line: line.dump(),\r\n            info: info.dump()\r\n        }\r\n    }\r\n\r\n    // const { ns } = line;\r\n    // const { beginCompilationUnit, endCompilationUnit, beginSubProgram, endSubProgram } = info;\r\n    return { ...line, ...info, dump }; // todo: export only required;\r\n}\r\n\r\ntype Color = number;\r\n\r\n/**\r\n * Code Debug Layout View.\r\n */\r\nexport function cdlview(cdlRaw: CDL) {\r\n    if (isNull(cdlRaw)) {\r\n        return null;\r\n    }\r\n\r\n    const { line, info } = cdlRaw;\r\n\r\n    /**\r\n     * @param pc Number of instruction.\r\n     */\r\n    function resolveFileLocation(pc: number) {\r\n        let rec = line.layout[pc];\r\n        assert(rec.pc == pc);\r\n        return {\r\n            file: isDef(rec.file) ? line.files[rec.file]: null,\r\n            line: rec.line,\r\n            column: rec.column\r\n        };\r\n    }\r\n\r\n    /** \r\n     * @returns Valid breakpoint position from arbitrary line.\r\n     */\r\n    function resolveBreakpointLocation(ln: number): number {\r\n        // todo: optimize it;\r\n        let rec = line.layout.find(r => r.line >= ln && (r.flags & EDebugLineFlags.k_NewStatement) != 0);\r\n        return (rec && rec.line) || -1;\r\n    }\r\n\r\n\r\n    function resolvePcColor(pc: number): Color {\r\n        return line.layout[pc] ? line.layout[pc].color : 0xffffff;\r\n    }\r\n\r\n    function resolveLineColor(ln: number, file: string): number {        \r\n        let rec = line.layout.find(r => r.line === ln && r.file === line.files.indexOf(file));\r\n        return rec ? rec.color : -1;\r\n    }\r\n    \r\n\r\n    return {\r\n        resolveFileLocation,\r\n        resolveBreakpointLocation,\r\n        resolvePcColor,\r\n        resolveLineColor\r\n    }\r\n}\r\n\r\nexport default debug;\r\n\r\n","import { CBUFFER0_REGISTER, ISubProgram } from '@lib/fx/bytecode/Bytecode';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { IWithStyles } from '@sandbox/components';\r\nimport * as React from 'react';\r\nimport injectSheet from 'react-jss';\r\nimport { Popup, Table } from 'semantic-ui-react';\r\n\r\nexport const styles = {\r\n    memoryVal: {\r\n        display: `inline-block`,\r\n        textAlign: `center`,\r\n        zoom: 1\r\n    }\r\n};\r\n\r\nexport interface IMemoryViewProps extends IWithStyles<typeof styles> {\r\n    program: ISubProgram;\r\n}\r\n\r\n@injectSheet(styles)\r\nclass MemoryView extends React.Component<IMemoryViewProps, {}> {\r\n\r\n    render(): JSX.Element {\r\n        if (!this.props.program) {\r\n            return null;\r\n        }\r\n        return (\r\n            <Table unstackable fixed style={ { fontFamily: 'consolas', border: '0' } }>\r\n                <Table.Body>\r\n                    { this.renderContent() }\r\n                </Table.Body>\r\n            </Table>\r\n        );\r\n    }\r\n\r\n\r\n    renderContent(): JSX.Element[] {\r\n        const { props } = this;\r\n        const bundle = VM.load(props.program.code);\r\n        const binaryData = bundle.input[CBUFFER0_REGISTER];\r\n        const layout = bundle.layout;\r\n\r\n        const WIDTH_MAX = 12;\r\n        const u8view = new Uint8Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);\r\n        // const f32view = new Float32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);\r\n        // const i32view = new Int32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);\r\n\r\n        let n = 0;\r\n\r\n        let rows: JSX.Element[] = [];\r\n        let columns: JSX.Element[] = [];\r\n\r\n        let colLen = 0;\r\n\r\n        let bLeftClosed: boolean;\r\n        let bRightClosed: boolean;\r\n\r\n        layout.map((constant, i) => {\r\n            let written = 0;\r\n            bLeftClosed = columns.length === 0;\r\n            do {\r\n                const segWidth = Math.min(constant.size - written, WIDTH_MAX - colLen);\r\n\r\n                const n4 = n >> 2;\r\n                const content = [];\r\n                for (let i = 0; i < segWidth; ++i) {\r\n                    content.push(\r\n                        <div key={ `mvk-d-${n}` }\r\n                            className={ `${props.classes.memoryVal}` }\r\n                            style={ { width: `${100 / segWidth}%` } }>\r\n                            { `${u8view[n] < 16 ? '0' : ''}${u8view[n++].toString(16).toUpperCase()}` }\r\n                        </div>);\r\n                    written++;\r\n                }\r\n\r\n                bRightClosed = written >= constant.size;\r\n\r\n                const style = {\r\n                    padding: 0,\r\n                    borderLeft: `1px solid ${bLeftClosed ? '#ccc' : 'transparent'}`,\r\n                    borderRight: `1px solid ${bRightClosed ? '#ccc' : 'transparent'}`,\r\n                    borderTop: `${rows.length === 0 ? 1 : 0}px solid #ccc`,\r\n                    borderBottom: `1px solid #ccc`,\r\n                };\r\n\r\n                columns.push(\r\n                    <Table.Cell\r\n                        key={ `mvk-tc-${colLen}` }\r\n                        textAlign=\"center\"\r\n                        colSpan={ segWidth }\r\n                        style={ style }>\r\n                        {/* {['f32', 'i32'].indexOf(constant.type) !== -1 &&\r\n                            <Popup inverted\r\n                                content={ <div style={ { fontFamily: 'consolas' } }>f32: {f32view[n4]}<br/>i32: {i32view[n4]}</div> }\r\n                                trigger={ <span>{content}</span> } />\r\n                        } */}\r\n                        {/* {['uniform'].indexOf(constant.type) !== -1 &&\r\n                            <Popup inverted\r\n                                content={ <div style={ { fontFamily: 'consolas' } }>{constant.value}</div> }\r\n                                trigger={ <span style={ { opacity: 0.5 } }>{content}</span> } />\r\n                        } */}\r\n                        {/* {['unknown'].indexOf(constant.type) !== -1 &&\r\n                            content\r\n                        } */}\r\n                        <Popup inverted\r\n                                content={ <div style={ { fontFamily: 'consolas' } }>{constant.name}</div> }\r\n                                trigger={ <span style={ { opacity: 0.5 } }>{content}</span> } />\r\n                    </Table.Cell>\r\n                );\r\n                colLen += segWidth;\r\n                bLeftClosed = false;\r\n\r\n                if (n % WIDTH_MAX === 0) {\r\n                    rows.push(<Table.Row key={ `mvk-tc-${rows.length}` }>{ columns }</Table.Row>);\r\n                    columns = [];\r\n                    colLen = 0;\r\n                }\r\n            } while (written < constant.size);\r\n        });\r\n        if (columns.length > 0) {\r\n            const csRest = WIDTH_MAX - n % WIDTH_MAX;\r\n            if (csRest !== WIDTH_MAX) {\r\n                columns.push(\r\n                    <Table.Cell\r\n                        key={ `mvk-tc-${colLen}` }\r\n                        textAlign=\"center\"\r\n                        colSpan={ csRest }\r\n                        style={ { padding: 0 } }>\r\n                    </Table.Cell>\r\n                );\r\n            }\r\n            rows.push(<Table.Row key={ `mvk-tc-${rows.length}` }>{ columns }</Table.Row>);\r\n        }\r\n        return rows;\r\n    }\r\n}\r\n\r\nexport default MemoryView;\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { type } from \"./type\";\r\n\r\nexport namespace variable {\r\n    /**\r\n * @param decl Variable declaraion (decl.isParameter() must be true).\r\n * @returns Serial number of the declaration among the function parameters or -1 otherwise.\r\n */\r\n    export function parameterIndex(decl: IVariableDeclInstruction): number {\r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return -1;\r\n        }\r\n        // all parameters must be a children on function definition!\r\n        assert(decl.parent.instructionType === EInstructionTypes.k_FunctionDef);\r\n        return (<IFunctionDefInstruction>decl.parent).params.indexOf(decl);\r\n    }\r\n\r\n    /**\r\n     * @returns Offset in bytes from the beginning of the parameters' list.\r\n     */\r\n    export function parameterOffset(decl: IVariableDeclInstruction): number {\r\n        // todo: add support for 'inout', 'out' usages \r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return 0;\r\n        }\r\n\r\n        let idx = parameterIndex(decl);\r\n        let offset = 0;\r\n        for (let i = 0; i < idx; ++i) {\r\n            offset += (<IFunctionDefInstruction>decl.parent).params[i].type.size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n        /**\r\n     * Helper:\r\n     *  Returns 'structName.fieldName' for structs;\r\n     *  Returns 'varName' for variables;\r\n     */\r\n    export function fullName(decl: IVariableDeclInstruction) {\r\n        if (decl.isField() &&\r\n            type.findParentVariableDecl(<IVariableTypeInstruction>decl.parent)) {\r\n\r\n            let name = '';\r\n            let parentType = decl.parent.instructionType;\r\n\r\n            if (parentType === EInstructionTypes.k_VariableType) {\r\n                name = type.resolveVariableDeclFullName(<IVariableTypeInstruction>decl.parent);\r\n            }\r\n\r\n            name += '.' + decl.name;\r\n            return name;\r\n        }\r\n        return decl.name;\r\n    }\r\n\r\n\r\n    export interface IRegister {\r\n        type: 'u' | 'b' | 't' | 's' | null;\r\n        index: number;\r\n        // space ?\r\n    };\r\n\r\n    export function resolveRegister(decl: IVariableDeclInstruction): IRegister {\r\n        let type = null;\r\n        let index = -1;\r\n\r\n        const semantic = decl.semantic;\r\n        if (semantic) {\r\n            const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n            if (match) {\r\n                type = match[1];\r\n                index = Number(match[2]);\r\n            }\r\n        }\r\n\r\n        if (decl.type.isUAV()) {\r\n            assert(type === null || type === 'u');\r\n            type = 'u';\r\n        }\r\n\r\n        if (decl.type.isTexture()) {\r\n            assert(type === null || type === 't');\r\n            type = 't';\r\n        }\r\n\r\n        if (decl.type.isSampler()) {\r\n            assert(type === null || type === 's');\r\n            type = 's';\r\n        }\r\n\r\n        // TODO: buffers\r\n\r\n        return { type, index };\r\n    }\r\n}","/* tslint:disable:typedef */\r\n\r\nimport { isNumber } from '@lib/common';\r\nimport * as Hlsl from '@lib/fx/translators/CodeEmitter';\r\nimport * as FxHlsl from '@lib/fx/translators/FxEmitter';\r\nimport * as FxTranslator from '@lib/fx/translators/FxTranslator';\r\nimport * as Glsl from '@lib/fx/translators/GlslEmitter';\r\n// import { getCommon, mapProps, matchLocation } from '@lib/idl/parser/IParser';\r\nimport { getCommon, mapProps, matchLocation } from '@sandbox/reducers';\r\nimport { filterPartFx, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport autobind from 'autobind-decorator';\r\nimport * as monaco from 'monaco-editor';\r\nimport * as React from 'react';\r\nimport { MonacoDiffEditor } from 'react-monaco-editor';\r\nimport { connect } from 'react-redux';\r\nimport { RouteComponentProps, withRouter } from 'react-router';\r\n\r\ninterface IShaderTranslatorViewProps extends IStoreState, RouteComponentProps {\r\n\r\n}\r\n\r\n\r\n// function cutSourceRange(content: string, range: IRange): string {\r\n//     const { start, end } = range;\r\n//     // console.log(range);\r\n//     const lines = content.split('\\n').slice(start.line, end.line + 1);\r\n//     lines[0] = lines[0].substr(start.column);\r\n//     lines[lines.length - 1] = lines[lines.length - 1].substr(0, end.column);\r\n//     return lines.join('\\n');\r\n// }\r\n\r\nconst diffOptions: monaco.editor.IDiffEditorConstructionOptions = {\r\n    selectOnLineNumbers: true,\r\n    fontSize: 12,\r\n    renderWhitespace: 'none',\r\n    lineHeight: 14,\r\n    minimap: {\r\n        enabled: false\r\n    },\r\n    automaticLayout: true,\r\n    glyphMargin: false,\r\n    theme: 'vs-dark',\r\n    lineDecorationsWidth: 0,\r\n    cursorSmoothCaretAnimation: false,\r\n    fontLigatures: true,\r\n\r\n    // diff specific options\r\n    occurrencesHighlight: false,\r\n    renderLineHighlight: 'none',\r\n    renderIndentGuides: false,\r\n    readOnly: true,\r\n    renderControlCharacters: false,\r\n    ignoreTrimWhitespace: true\r\n};\r\n\r\n@(withRouter as any)\r\nclass ShaderTranslatorView extends React.Component<IShaderTranslatorViewProps> {\r\n\r\n    @autobind\r\n    editorDidMount(editor: monaco.editor.IDiffEditor) {\r\n        const { modified, original } = editor.getModel();\r\n        modified.updateOptions({ tabSize: 4 });\r\n        original.updateOptions({ tabSize: 4 });\r\n    }\r\n\r\n    // shouldComponentUpdate(nextProps: IShaderTranslatorViewProps) {\r\n    //     return getFileState(this.props).content !== getFileState(nextProps).content;\r\n    // }\r\n\r\n    // tslint:disable-next-line:typedef\r\n    render() {\r\n        // console.log('ShaderTranslatorView::render()');\r\n        const { props } = this;\r\n\r\n        const match = matchLocation(props);\r\n        const file = getFileState(props);\r\n        const scope = getScope(file);\r\n\r\n        if (!scope) {\r\n            return null;\r\n        }\r\n\r\n        const fxList = filterPartFx(scope);\r\n        const fx = fxList.find(tech => tech.name === match.params.name);\r\n\r\n        if (!fx) {\r\n            return null;\r\n        }\r\n\r\n        let original: string;\r\n        let value: string;\r\n\r\n        if (match.params.pass) {\r\n\r\n            const pass = fx.passList.find((instr, i) => isNumber(match.params.pass)\r\n                ? i === Number(match.params.pass)\r\n                : instr.name === match.params.pass);\r\n\r\n            const mode = match.params.property === 'VertexShader' ? 'vertex' : 'pixel';\r\n            const shader = mode === 'vertex' ? pass.vertexShader : pass.pixelShader;\r\n\r\n            original = Hlsl.translate(shader, { mode });\r\n            value = Glsl.translate(shader, { mode });\r\n        } else {\r\n            original = FxHlsl.translate(fx);\r\n            value = FxTranslator.translateFlat(fx);\r\n        }\r\n\r\n        return (\r\n            <MonacoDiffEditor\r\n                ref='monaco'\r\n\r\n                original = { original }\r\n                value={ value }\r\n\r\n                width='100%'\r\n                height='calc(100vh - 74px)' // todo: fixme\r\n\r\n                options={ diffOptions }\r\n                editorDidMount={ this.editorDidMount }\r\n            // onChange={ this.onChange }\r\n            // editorWillMount={ this.editorWillMount }\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\n\r\nexport default connect<{}, {}, IShaderTranslatorViewProps>(mapProps(getCommon), null)\r\n    (ShaderTranslatorView) as any;\r\n\r\n","var pug = require(\"!../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;;var locals_for_with = (locals || {});(function (htmlWebpackPlugin) {var pug_indent = [];\npug_html = pug_html + \"\\u003C!DOCTYPE html\\u003E\\n\\u003Chtml\\u003E\\n  \\u003Ctitle\\u003E\" + (pug.escape(null == (pug_interp = htmlWebpackPlugin.options.title) ? \"\" : pug_interp)) + \"\\u003C\\u002Ftitle\\u003E\\n  \\u003Chead\\u003E\\n    \\u003Cmeta http-equiv=\\\"Content-Type\\\" content=\\\"text\\u002Fhtml; charset=UTF-8\\\"\\u003E\\n  \\u003C\\u002Fhead\\u003E\\n  \\u003Cbody\\u003E\\n    \\u003Cdiv id=\\\"app\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\n  \\u003C\\u002Fbody\\u003E\\n\\u003C\\u002Fhtml\\u003E\";}.call(this,\"htmlWebpackPlugin\" in locals_for_with?locals_for_with.htmlWebpackPlugin:typeof htmlWebpackPlugin!==\"undefined\"?htmlWebpackPlugin:undefined));;return pug_html;};\nmodule.exports = template;","import { IBaseAction } from \"@sandbox/actions/ActionTypes\";\r\n\r\nexport function handleActions<StateType extends {}, ActionType extends IBaseAction<string>>(map: { [actionType: string]: (state: StateType, action: ActionType) => StateType; }, initialState: StateType) {\r\n    return (state: StateType, action: ActionType) => {\r\n        state = state ? state : initialState;\r\n        \r\n        if (map.hasOwnProperty(action.type)) {\r\n            return map[action.type](state, action);\r\n        }\r\n\r\n        return state;\r\n    }\r\n}","import { assert, isNull, isObject } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { ISystemTypeInstructionSettings, SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { Scope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EInstructionTypes, EScopeType, IFunctionDeclInstruction, IScope, ITypedInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\n// TODO: use it\r\nexport enum ESystemTypes {\r\n    k_Sampler,\r\n    k_Sampler2D,\r\n    k_Sampler3D,\r\n    k_SamplerCube,\r\n    k_RWBuffer,\r\n    k_RWStructuredBuffer,\r\n    k_AppendStructuredBuffer\r\n};\r\n\r\nconst scope = new Scope({ type: EScopeType.k_System });\r\n\r\nconst systemFunctionHashMap: IMap<boolean> = {};\r\nconst TEMPLATE_TYPE = \"template\";\r\n\r\n\r\nfunction _emitException(message: string) {\r\n    throw new Error(message);\r\n}\r\n\r\n// todo: rewrite it!\r\nfunction _error(code: number, info = {}): void {\r\n    _emitException(EAnalyzerErrors[code]);\r\n}\r\n\r\ntype ITypeInfo = Pick<ISystemTypeInstructionSettings, Exclude<keyof ISystemTypeInstructionSettings, 'scope'>>;\r\n\r\nfunction generateSystemType(name: string, size?: number, elementType?: ITypeInstruction, \r\n    length?: number, fields?: IVariableDeclInstruction[], methods?: IFunctionDeclInstruction[]): SystemTypeInstruction;\r\n// function generateSystemType({ name, length, elementType, fields, size, methods }: ITypeInfo): SystemTypeInstruction;\r\nfunction generateSystemType(...args: any[]): SystemTypeInstruction {\r\n    let name: string;\r\n    let size: number;\r\n    let elementType: ITypeInstruction;\r\n    let length: number;\r\n    let fields: IVariableDeclInstruction[];\r\n    let methods: IFunctionDeclInstruction[];\r\n\r\n    // if (isObject(args[0])) {\r\n    //     ({ name, size, elementType, length, fields, methods } = args[0]);\r\n    // } else{\r\n        [ name, size, elementType, length, fields, methods ] = args;\r\n    // }\r\n\r\n    if (getSystemType(name)) {\r\n        console.error(`type already exists: ${name}`);\r\n        return null;\r\n    }\r\n\r\n    const type = new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    scope.addType(type);\r\n\r\n    return type;\r\n}\r\n\r\n\r\nclass TypeTemplate implements ITypeTemplate {\r\n    readonly name: string;\r\n    readonly scope: IScope;\r\n    \r\n    constructor(name: string, scope: IScope) {\r\n        this.name = name;\r\n        this.scope = scope;\r\n    }\r\n\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    typeName(args?: ITypeInstruction[]): string {\r\n        if (args) {\r\n            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;\r\n        }\r\n        return this.name;\r\n    }\r\n}\r\n\r\n\r\nclass RWBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!args[0].isBase()) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\nclass RWStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWStructuredBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n        \r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        \r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'IncrementCounter' });\r\n            let definition = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'DecrementCounter' });\r\n            let definition = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\nclass AppendStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('AppendStructuredBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                const type = new VariableTypeInstruction({ type: args[0], scope });\r\n                const id = new IdInstruction({ scope, name: 'Append' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            const id = new IdInstruction({ scope, name: 'Append' });\r\n            const definition = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            const func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n        \r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction addFieldsToVectorFromSuffixObject(fields: IVariableDeclInstruction[], suffixMap: IMap<boolean>, baseType: string) {\r\n    for (let suffix in suffixMap) {\r\n        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : \"\");\r\n        const fieldBaseType = getSystemType(fieldTypeName);\r\n\r\n        assert(fieldBaseType);\r\n\r\n        const fieldId = new IdInstruction({ scope, name: suffix });\r\n        const fieldType = new VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] })\r\n\r\n        fields.push(new VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));\r\n    }\r\n}\r\n\r\n\r\nfunction addSystemTypeScalar(): void {\r\n    generateSystemType(\"void\", 0);\r\n    generateSystemType(\"int\", 4);\r\n    generateSystemType(\"uint\", 4);\r\n    generateSystemType(\"bool\", 4);\r\n    generateSystemType(\"float\", 4);\r\n    generateSystemType(\"string\");\r\n    generateSystemType(\"texture\");\r\n    generateSystemType(\"sampler\");\r\n    generateSystemType(\"sampler2D\");\r\n    generateSystemType(\"samplerCUBE\");\r\n}\r\n\r\n\r\nfunction addSystemTypeVector(): void {\r\n    let XYSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let XYZSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let XYZWSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    let RGSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let RGBSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let RGBASuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    let STSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let STPSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let STPQSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    generateSuffixLiterals([\"x\", \"y\"], XYSuffix);\r\n    generateSuffixLiterals([\"x\", \"y\", \"z\"], XYZSuffix);\r\n    generateSuffixLiterals([\"x\", \"y\", \"z\", \"w\"], XYZWSuffix);\r\n\r\n    generateSuffixLiterals([\"r\", \"g\"], RGSuffix);\r\n    generateSuffixLiterals([\"r\", \"g\", \"b\"], RGBSuffix);\r\n    generateSuffixLiterals([\"r\", \"g\", \"b\", \"a\"], RGBASuffix);\r\n\r\n    generateSuffixLiterals([\"s\", \"t\"], STSuffix);\r\n    generateSuffixLiterals([\"s\", \"t\", \"p\"], STPSuffix);\r\n    generateSuffixLiterals([\"s\", \"t\", \"p\", \"q\"], STPQSuffix);\r\n\r\n\r\n    let float = getSystemType(\"float\");\r\n    let int = getSystemType(\"int\");\r\n    let uint = getSystemType(\"uint\");\r\n    let bool = getSystemType(\"bool\");\r\n\r\n    let float2 = generateSystemType(\"float2\", -1, float, 2);\r\n    let float3 = generateSystemType(\"float3\", -1, float, 3);\r\n    let float4 = generateSystemType(\"float4\", -1, float, 4);\r\n\r\n    let int2 = generateSystemType(\"int2\", -1, int, 2);\r\n    let int3 = generateSystemType(\"int3\", -1, int, 3);\r\n    let int4 = generateSystemType(\"int4\", -1, int, 4);\r\n\r\n    let uint2 = generateSystemType(\"uint2\", -1, uint, 2);\r\n    let uint3 = generateSystemType(\"uint3\", -1, uint, 3);\r\n    let uint4 = generateSystemType(\"uint4\", -1, uint, 4);\r\n\r\n    let bool2 = generateSystemType(\"bool2\", -1, bool, 2);\r\n    let bool3 = generateSystemType(\"bool3\", -1, bool, 3);\r\n    let bool4 = generateSystemType(\"bool4\", -1, bool, 4);\r\n\r\n    {\r\n        let suf2f: IVariableDeclInstruction[] = [];\r\n        // program.push(EScopeType.k_Struct);\r\n        addFieldsToVectorFromSuffixObject(suf2f, XYSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf2f, RGSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf2f, STSuffix, \"float\");\r\n        // program.pop();\r\n        suf2f.forEach(field => float2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3f, XYZSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf3f, RGBSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf3f, STPSuffix, \"float\");\r\n        suf3f.forEach(field => float3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4f, XYZWSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf4f, RGBASuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf4f, STPQSuffix, \"float\");\r\n        suf4f.forEach(field => float4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2i, XYSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf2i, RGSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf2i, STSuffix, \"int\");\r\n        suf2i.forEach(field => int2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3i, XYZSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf3i, RGBSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf3i, STPSuffix, \"int\");\r\n        suf3i.forEach(field => int3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4i, XYZWSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf4i, RGBASuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf4i, STPQSuffix, \"int\");\r\n        suf4i.forEach(field => int4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2ui, XYSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf2ui, RGSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf2ui, STSuffix, \"uint\");\r\n        suf2ui.forEach(field => uint2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3ui, XYZSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf3ui, RGBSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf3ui, STPSuffix, \"uint\");\r\n        suf3ui.forEach(field => uint3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4ui, XYZWSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf4ui, RGBASuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf4ui, STPQSuffix, \"uint\");\r\n        suf4ui.forEach(field => uint4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2b, XYSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf2b, RGSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf2b, STSuffix, \"bool\");\r\n        suf2b.forEach(field => bool2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3b, XYZSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf3b, RGBSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf3b, STPSuffix, \"bool\");\r\n        suf3b.forEach(field => bool3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4b, XYZWSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf4b, RGBASuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf4b, STPQSuffix, \"bool\");\r\n        suf4b.forEach(field => bool4.addField(field));\r\n    }\r\n}\r\n\r\n\r\nfunction addSystemTypeMatrix(): void {\r\n    let float2 = getSystemType(\"float2\");\r\n    let float3 = getSystemType(\"float3\");\r\n    let float4 = getSystemType(\"float4\");\r\n\r\n    let int2 = getSystemType(\"int2\");\r\n    let int3 = getSystemType(\"int3\");\r\n    let int4 = getSystemType(\"int4\");\r\n\r\n    let uint2 = getSystemType(\"uint2\");\r\n    let uint3 = getSystemType(\"uint3\");\r\n    let uint4 = getSystemType(\"uint4\");\r\n\r\n    let bool2 = getSystemType(\"bool2\");\r\n    let bool3 = getSystemType(\"bool3\");\r\n    let bool4 = getSystemType(\"bool4\");\r\n\r\n    generateSystemType(\"float2x2\", -1, float2, 2);\r\n    generateSystemType(\"float2x3\", -1, float2, 3);\r\n    generateSystemType(\"float2x4\", -1, float2, 4);\r\n\r\n    generateSystemType(\"float3x2\", -1, float3, 2);\r\n    generateSystemType(\"float3x3\", -1, float3, 3);\r\n    generateSystemType(\"float3x4\", -1, float3, 4);\r\n\r\n    generateSystemType(\"float4x2\", -1, float4, 2);\r\n    generateSystemType(\"float4x3\", -1, float4, 3);\r\n    generateSystemType(\"float4x4\", -1, float4, 4);\r\n\r\n    generateSystemType(\"int2x2\", -1, int2, 2);\r\n    generateSystemType(\"int2x3\", -1, int2, 3);\r\n    generateSystemType(\"int2x4\", -1, int2, 4);\r\n\r\n    generateSystemType(\"int3x2\", -1, int3, 2);\r\n    generateSystemType(\"int3x3\", -1, int3, 3);\r\n    generateSystemType(\"int3x4\", -1, int3, 4);\r\n\r\n    generateSystemType(\"int4x2\", -1, int4, 2);\r\n    generateSystemType(\"int4x3\", -1, int4, 3);\r\n    generateSystemType(\"int4x4\", -1, int4, 4);\r\n\r\n    generateSystemType(\"bool2x2\", -1, bool2, 2);\r\n    generateSystemType(\"bool2x3\", -1, bool2, 3);\r\n    generateSystemType(\"bool2x4\", -1, bool2, 4);\r\n\r\n    generateSystemType(\"bool3x2\", -1, bool3, 2);\r\n    generateSystemType(\"bool3x3\", -1, bool3, 3);\r\n    generateSystemType(\"bool3x4\", -1, bool3, 4);\r\n\r\n    generateSystemType(\"bool4x2\", -1, bool4, 2);\r\n    generateSystemType(\"bool4x3\", -1, bool4, 3);\r\n    generateSystemType(\"bool4x4\", -1, bool4, 4);\r\n}\r\n\r\n\r\nfunction generateSuffixLiterals(literals: string[], output: IMap<boolean>, depth: number = 0): void {\r\n    if (depth >= literals.length) {\r\n        return;\r\n    }\r\n\r\n    if (depth === 0) {\r\n        for (let i = 0; i < literals.length; i++) {\r\n            output[literals[i]] = true;\r\n        }\r\n\r\n        depth = 1;\r\n    }\r\n\r\n    const outputKeys = Object.keys(output);\r\n\r\n    for (let i = 0; i < literals.length; i++) {\r\n        for (let j = 0; j < outputKeys.length; j++) {\r\n            if (outputKeys[j].indexOf(literals[i]) !== -1) {\r\n                output[outputKeys[j] + literals[i]] = false;\r\n            }\r\n            else {\r\n                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;\r\n            }\r\n        }\r\n    }\r\n\r\n    depth++;\r\n\r\n    generateSuffixLiterals(literals, output, depth);\r\n}\r\n\r\n\r\nfunction generateSystemFunctionInstance(type: ITypeInstruction, name: string, paramTypes: ITypeInstruction[], vertex: boolean, pixel: boolean) {\r\n    let paramList = paramTypes.map((type, n) => {\r\n        return new VariableDeclInstruction({ \r\n            type: new VariableTypeInstruction({ type, scope }), \r\n            id: new IdInstruction({ name: `p${n}`, scope }), \r\n            scope });\r\n    });\r\n\r\n    let returnType = new VariableTypeInstruction({ type, scope });\r\n    let id = new IdInstruction({ scope, name });\r\n    let definition = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n    let func = new SystemFunctionInstruction({ scope, definition, pixel, vertex });\r\n\r\n    scope.addFunction(func);\r\n}\r\n\r\n\r\n/**\r\n * Exampler:\r\n *  generateSystemFunction(\"dot\", \"dot($1,$2)\",   \"float\",    [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n *                         name   translationExpr returnType  argsTypes                       templateTypes\r\n */\r\nfunction generateSystemFunction(\r\n    name: string,\r\n    returnTypeName: string,\r\n    paramTypeNames: string[],\r\n    templateTypes: string[],\r\n    isForVertex: boolean = true,\r\n    isForPixel: boolean = true): void {\r\n\r\n    if (!isNull(templateTypes)) {\r\n        for (let i = 0; i < templateTypes.length; i++) {\r\n            let funcHash = name + \"(\";\r\n            let returnType = (returnTypeName === TEMPLATE_TYPE) ?\r\n                getSystemType(templateTypes[i]) :\r\n                getSystemType(returnTypeName);\r\n            let paramTypes: ITypeInstruction[] = [];\r\n\r\n            for (let j = 0; j < paramTypeNames.length; j++) {\r\n                if (paramTypeNames[j] === TEMPLATE_TYPE) {\r\n                    paramTypes.push(getSystemType(templateTypes[i]));\r\n                    funcHash += templateTypes[i] + \",\";\r\n                }\r\n                else {\r\n                    paramTypes.push(getSystemType(paramTypeNames[j]));\r\n                    funcHash += paramTypeNames[j] + \",\"\r\n                }\r\n            }\r\n\r\n            funcHash += \")\";\r\n\r\n            if (systemFunctionHashMap[funcHash]) {\r\n                _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n            }\r\n\r\n            generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);\r\n            systemFunctionHashMap[funcHash] = true;\r\n        }\r\n    }\r\n    else {\r\n        if (returnTypeName === TEMPLATE_TYPE) {\r\n            _emitException(\"Bad return type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n        }\r\n\r\n        let funcHash = name + \"(\";\r\n        let returnType = getSystemType(returnTypeName);\r\n        let paramTypes: ITypeInstruction[] = [];\r\n\r\n        for (let i = 0; i < paramTypeNames.length; i++) {\r\n            if (paramTypeNames[i] === TEMPLATE_TYPE) {\r\n                _emitException(\"Bad argument type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n            }\r\n            else {\r\n                paramTypes.push(getSystemType(paramTypeNames[i]));\r\n                funcHash += paramTypeNames[i] + \",\";\r\n            }\r\n        }\r\n\r\n        funcHash += \")\";\r\n\r\n        if (systemFunctionHashMap[funcHash]) {\r\n            _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n        }\r\n\r\n        generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);\r\n        systemFunctionHashMap[funcHash] = true;\r\n    }\r\n}\r\n\r\n\r\n// function generateNotBuiltInSystemFunction(name: string, definition: string, implementation: string,\r\n//     returnTypeName: string,\r\n//     usedTypes: string[],\r\n//     usedFunctions: string[]): void {\r\n\r\n//     if (scope.hasFunction(name)) {\r\n//         console.warn(`Builtin function ${name} already exists.`);\r\n//         return;\r\n//     }\r\n\r\n//     let builtIn = false;\r\n//     let returnType = getSystemType(returnTypeName);\r\n//     let id = new IdInstruction({ scope, name })\r\n//     let func = new SystemFunctionInstruction({ scope, id, returnType, definition, implementation, builtIn });\r\n\r\n//     let usedExtSystemTypes: ITypeDeclInstruction[] = [];\r\n//     let usedExtSystemFunctions: IFunctionDeclInstruction[] = [];\r\n\r\n//     if (!isNull(usedTypes)) {\r\n//         for (let i = 0; i < usedTypes.length; i++) {\r\n//             let typeDecl: ITypeDeclInstruction = <ITypeDeclInstruction>getSystemType(usedTypes[i]).parent;\r\n//             if (!isNull(typeDecl)) {\r\n//                 usedExtSystemTypes.push(typeDecl);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     if (!isNull(usedFunctions)) {\r\n//         for (let i = 0; i < usedFunctions.length; i++) {\r\n//             let pFindFunction: IFunctionDeclInstruction = scope.findFunction(usedFunctions[i]);\r\n//             usedExtSystemFunctions.push(pFindFunction);\r\n//         }\r\n//     }\r\n\r\n//     func.$setUsedSystemData(usedExtSystemTypes, usedExtSystemFunctions);\r\n//     func.$closeSystemDataInfo();\r\n\r\n//     scope.addFunction(func);\r\n// }\r\n\r\n\r\n// TODO: rework system function templates for better readability\r\nfunction addSystemFunctions(): void {\r\n    generateSystemFunction(\"dot\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul\r\n    // TODO: add support for int|uint|bool based vectors \r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [\"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(\"mul\", \"float4\", [\"float4\", TEMPLATE_TYPE], [\"float4x4\", \"float4x3\", \"float4x2\"]);\r\n    generateSystemFunction(\"mul\", \"float3\", [\"float3\", TEMPLATE_TYPE], [\"float3x4\", \"float3x3\", \"float3x2\"]);\r\n    generateSystemFunction(\"mul\", \"float2\", [\"float2\", TEMPLATE_TYPE], [\"float2x4\", \"float2x3\", \"float2x2\"]);\r\n    generateSystemFunction(\"mul\", \"float4\", [TEMPLATE_TYPE, \"float4\"], [\"float4x4\", \"float3x4\", \"float2x4\"]);\r\n    generateSystemFunction(\"mul\", \"float3\", [TEMPLATE_TYPE, \"float3\"], [\"float4x3\", \"float3x3\", \"float2x3\"]);\r\n    generateSystemFunction(\"mul\", \"float2\", [TEMPLATE_TYPE, \"float2\"], [\"float4x2\", \"float3x2\", \"float2x2\"]);\r\n\r\n    /**\r\n     * scalar = int|uint|float\r\n     * vector = vector<int|uint|float, n>, n = 2,3,4\r\n     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4\r\n     * \r\n     * scalar mul(scalar, scalar)\r\n     * vector mul(scalar, vector)\r\n     * vector mul(vector, scalar)\r\n     * vector mul(vector, vector)\r\n     * matrix mul(scalar, matrix)\r\n     * matrix mul(matrix, scalar)\r\n     * vector mul(vector, matrix)\r\n     * vector mul(matrix, vector)\r\n     * matrix mul(matrix, matrix)\r\n     */\r\n\r\n    generateSystemFunction(\"mod\", \"float\", [\"float\", \"float\"], null);\r\n    generateSystemFunction(\"floor\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"ceil\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"fract\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"normalize\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"length\", \"float\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"cross\", \"float3\", [\"float3\", \"float3\"], null);\r\n    generateSystemFunction(\"reflect\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"int\"], [\"int2\", \"int3\", \"int4\"]);\r\n\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"uint\"], [\"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"int\"], [\"int2\", \"int3\", \"int4\"]);\r\n\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"uint\"], [\"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\", \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"pow\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"exp\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"exp2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"log\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"log2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"inversesqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"all\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    generateSystemFunction(\"any\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    generateSystemFunction(\"not\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"distance\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"lessThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"lessThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"lessThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"lessThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"lessThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"lessThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"equal\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"equal\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"equal\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(\"equal\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"notEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"notEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"notEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(\"notEqual\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"greaterThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"greaterThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"greaterThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n\r\n    generateSystemFunction(\"radians\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"degrees\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"cos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"tan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"asin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"acos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler\", \"float2\"], null);\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler2D\", \"float2\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float4\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\"], null);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\"], null);\r\n\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, false, true);\r\n\r\n    generateSystemFunction(\"tex2DLod\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DLod\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"texCUBELod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"texCUBELod\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, true, false);\r\n\r\n    //OES_standard_derivatives\r\n\r\n    generateSystemFunction(\"dFdx\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"dFdy\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"width\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"fwidth\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"smoothstep\", \"float3\", [\"float3\", \"float3\", \"float3\"], null);\r\n\r\n    generateSystemFunction(\"smoothstep\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"smoothstep\", TEMPLATE_TYPE, [\"float\", \"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"frac\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"saturate\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"float\"/*, \"uint\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"int\"/*, \"uint\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float2\", [TEMPLATE_TYPE], [\"int2\"/*, \"uint2\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float3\", [TEMPLATE_TYPE], [\"int3\"/*, \"uint3\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float4\", [TEMPLATE_TYPE], [\"int4\"/*, \"uint4\"*/]);\r\n    \r\n    generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"uint\"]);\r\n    generateSystemFunction(\"asint\", \"int2\", [TEMPLATE_TYPE], [\"float2\", \"uint2\"]);\r\n    generateSystemFunction(\"asint\", \"int3\", [TEMPLATE_TYPE], [\"float3\", \"uint3\"]);\r\n    generateSystemFunction(\"asint\", \"int4\", [TEMPLATE_TYPE], [\"float4\", \"uint4\"]);\r\n    \r\n    generateSystemFunction(\"asuint\", \"uint\", [TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(\"asuint\", \"uint2\", [TEMPLATE_TYPE], [\"float2\", \"int2\"]);\r\n    generateSystemFunction(\"asuint\", \"uint3\", [TEMPLATE_TYPE], [\"float3\", \"int3\"]);\r\n    generateSystemFunction(\"asuint\", \"uint4\", [TEMPLATE_TYPE], [\"float4\", \"int4\"]);\r\n\r\n    generateSystemFunction(\"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\"]);\r\n    // generateSystemFunction(\"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\"]);\r\n\r\n    // generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n}\r\n\r\n\r\n\r\n// function generateSystemVariable(name: string, typeName: string,\r\n//     isForVertex: boolean, isForPixel: boolean, readonly: boolean): void {\r\n\r\n//     if (scope.hasVariable(name)) {\r\n//         return;\r\n//     }\r\n\r\n//     let id = new IdInstruction({ scope, name });\r\n//     let type = new VariableTypeInstruction({ scope, type: getSystemType(typeName), writable: readonly });\r\n//     let variableDecl = new VariableDeclInstruction({ scope, id, type, builtIn: true });\r\n\r\n//     variableDecl.$makeVertexCompatible(isForVertex);\r\n//     variableDecl.$makePixelCompatible(isForPixel);\r\n\r\n//     scope.addVariable(variableDecl);\r\n// }\r\n\r\n\r\nfunction getSystemType(typeName: string): SystemTypeInstruction {\r\n    //boolean, string, float and others\r\n    let type = <SystemTypeInstruction>scope.findType(typeName);\r\n    assert(!type || (type.instructionType === EInstructionTypes.k_SystemType));\r\n    return type;\r\n}\r\n\r\n\r\n// function addSystemVariables(): void {\r\n    // generateSystemVariable(\"fragColor\", \"gl_FragColor\", \"float4\", false, true, true);\r\n    // generateSystemVariable(\"fragCoord\", \"gl_FragCoord\", \"float4\", false, true, true);\r\n    // generateSystemVariable(\"frontFacing\", \"gl_FrontFacing\", \"bool\", false, true, true);\r\n    // generateSystemVariable(\"pointCoord\", \"gl_PointCoord\", \"float2\", false, true, true);\r\n// }\r\n\r\n\r\nfunction initSystemTypes(): void {\r\n    addSystemTypeScalar();\r\n    addSystemTypeVector();\r\n    addSystemTypeMatrix();\r\n    \r\n    scope.addTypeTemplate(new RWBufferTemplate);\r\n    scope.addTypeTemplate(new RWStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new AppendStructuredBufferTemplate);\r\n}\r\n\r\n\r\nfunction initSystemFunctions(): void {\r\n    addSystemFunctions();\r\n}\r\n\r\n\r\n// function initSystemVariables(): void {\r\n//     addSystemVariables();\r\n// }\r\n\r\n\r\ninitSystemTypes();\r\ninitSystemFunctions();\r\n// initSystemVariables();\r\n\r\n/**\r\n * Export API\r\n */\r\n\r\nexport const SCOPE = scope;\r\n\r\nexport const T_VOID = scope.findType(\"void\");\r\nexport const T_STRING = scope.findType(\"string\");\r\n\r\nexport const T_FLOAT = scope.findType(\"float\");\r\nexport const T_FLOAT2 = scope.findType(\"float2\");\r\nexport const T_FLOAT3 = scope.findType(\"float3\");\r\nexport const T_FLOAT4 = scope.findType(\"float4\");\r\n\r\nexport const T_FLOAT2X2 = scope.findType(\"float2x2\");\r\nexport const T_FLOAT3X3 = scope.findType(\"float3x3\");\r\nexport const T_FLOAT4X4 = scope.findType(\"float4x4\");\r\n\r\nexport const T_BOOL = scope.findType(\"bool\");\r\nexport const T_BOOL2 = scope.findType(\"bool2\");\r\nexport const T_BOOL3 = scope.findType(\"bool3\");\r\nexport const T_BOOL4 = scope.findType(\"bool4\");\r\n\r\nexport const T_BOOL2X2 = scope.findType(\"bool2x2\");\r\nexport const T_BOOL3X3 = scope.findType(\"bool3x3\");\r\nexport const T_BOOL4X4 = scope.findType(\"bool4x4\");\r\n\r\nexport const T_INT = scope.findType(\"int\");\r\nexport const T_INT2 = scope.findType(\"int2\");\r\nexport const T_INT3 = scope.findType(\"int3\");\r\nexport const T_INT4 = scope.findType(\"int4\");\r\n\r\nexport const T_UINT = scope.findType(\"uint\");\r\nexport const T_UINT2 = scope.findType(\"uint2\");\r\nexport const T_UINT3 = scope.findType(\"uint3\");\r\nexport const T_UINT4 = scope.findType(\"uint4\");\r\n\r\nexport const T_INT2X2 = scope.findType(\"int2x2\");\r\nexport const T_INT3X3 = scope.findType(\"int3x3\");\r\nexport const T_INT4X4 = scope.findType(\"int4x4\");\r\n\r\nexport const T_SAMPLER = scope.findType(\"sampler\");\r\nexport const T_SAMPLER_2D = scope.findType(\"sampler2D\");\r\nexport const T_SAMPLER_CUBE = scope.findType(\"samplerCUBE\");\r\n\r\nexport const findType = (typeName: string) => scope.findType(typeName);\r\nexport const findVariable = (varName: string) => scope.findVariable(varName);\r\nexport const findTechnique = (techName: string) => scope.findTechnique(techName);\r\nexport const findFunction = (funcName: string, args?: ITypeInstruction[]) => scope.findFunction(funcName, args);\r\n\r\nexport const hasType = (typeName: string) => !isNull(scope.findType(typeName));\r\nexport const hasVariable = (varName: string) => !isNull(scope.findVariable(varName));\r\nexport const hasTechnique = (techName: string) => !isNull(scope.findTechnique(techName));\r\n\r\nexport function isMatrixType(type: ITypeInstruction): boolean { \r\n    return type.isEqual(getSystemType(\"float2x2\")) ||\r\n        type.isEqual(getSystemType(\"float3x3\")) ||\r\n        type.isEqual(getSystemType(\"float4x4\")) ||\r\n        type.isEqual(getSystemType(\"int2x2\")) ||\r\n        type.isEqual(getSystemType(\"int3x3\")) ||\r\n        type.isEqual(getSystemType(\"int4x4\")) ||\r\n        type.isEqual(getSystemType(\"bool2x2\")) ||\r\n        type.isEqual(getSystemType(\"bool3x3\")) ||\r\n        type.isEqual(getSystemType(\"bool4x4\"));\r\n}\r\n\r\n\r\nexport function isVectorType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(getSystemType(\"float2\")) ||\r\n        type.isEqual(getSystemType(\"float3\")) ||\r\n        type.isEqual(getSystemType(\"float4\")) ||\r\n        type.isEqual(getSystemType(\"bool2\")) ||\r\n        type.isEqual(getSystemType(\"bool3\")) ||\r\n        type.isEqual(getSystemType(\"bool4\")) ||\r\n        type.isEqual(getSystemType(\"int2\")) ||\r\n        type.isEqual(getSystemType(\"int3\")) ||\r\n        type.isEqual(getSystemType(\"int4\")) || \r\n        type.isEqual(getSystemType(\"uint2\")) ||\r\n        type.isEqual(getSystemType(\"uint3\")) ||\r\n        type.isEqual(getSystemType(\"uint4\"));\r\n}\r\n\r\n\r\nexport function isScalarType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_BOOL) ||\r\n        type.isEqual(T_INT) ||\r\n        type.isEqual(T_UINT) ||\r\n        type.isEqual(T_FLOAT);\r\n}\r\n\r\n\r\nexport function isFloatBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_FLOAT) ||\r\n        type.isEqual(T_FLOAT2) ||\r\n        type.isEqual(T_FLOAT3) ||\r\n        type.isEqual(T_FLOAT4) ||\r\n        type.isEqual(T_FLOAT2X2) ||\r\n        type.isEqual(T_FLOAT3X3) ||\r\n        type.isEqual(T_FLOAT4X4);\r\n}\r\n\r\n\r\nexport function isIntBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_INT) ||\r\n        type.isEqual(T_INT2) ||\r\n        type.isEqual(T_INT3) ||\r\n        type.isEqual(T_INT4) ||\r\n        type.isEqual(T_INT2X2) ||\r\n        type.isEqual(T_INT3X3) ||\r\n        type.isEqual(T_INT4X4);\r\n}\r\n\r\n\r\nexport function isUIntBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_UINT) ||\r\n        type.isEqual(T_UINT2) ||\r\n        type.isEqual(T_UINT3) ||\r\n        type.isEqual(T_UINT4);\r\n}\r\n\r\n\r\nexport function isBoolBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_BOOL) ||\r\n        type.isEqual(T_BOOL2) ||\r\n        type.isEqual(T_BOOL3) ||\r\n        type.isEqual(T_BOOL4) ||\r\n        type.isEqual(T_BOOL2X2) ||\r\n        type.isEqual(T_BOOL3X3) ||\r\n        type.isEqual(T_BOOL4X4);\r\n}\r\n\r\n\r\nexport function isSamplerType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_SAMPLER) ||\r\n        type.isEqual(getSystemType(\"sampler2D\")) ||\r\n        type.isEqual(getSystemType(\"samplerCUBE\"));\r\n}\r\n\r\n\r\n\r\n/** @deprecated */\r\nexport function getExternalType(type: ITypeInstruction): any {\r\n    if (type.isEqual(T_INT) ||\r\n        type.isEqual(T_UINT) ||\r\n        type.isEqual(T_FLOAT)) {\r\n        return Number;\r\n    }\r\n    else if (type.isEqual(T_BOOL)) {\r\n        return \"Boolean\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT2) ||\r\n        type.isEqual(T_BOOL2) ||\r\n        type.isEqual(T_INT2) ||\r\n        type.isEqual(T_UINT2)) {\r\n        return \"Vec2\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT3) ||\r\n        type.isEqual(T_BOOL3) ||\r\n        type.isEqual(T_INT3) ||\r\n        type.isEqual(T_UINT3)) {\r\n        return \"Vec3\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT4) ||\r\n        type.isEqual(T_BOOL4) ||\r\n        type.isEqual(T_INT4) ||\r\n        type.isEqual(T_UINT4)) {\r\n        return \"Vec4\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT2X2) ||\r\n        type.isEqual(T_BOOL2X2) ||\r\n        type.isEqual(T_INT2X2)) {\r\n        return \"Vec2\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT3X3) ||\r\n        type.isEqual(T_BOOL3X3) ||\r\n        type.isEqual(T_INT3X3)) {\r\n        return \"Mat3\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT4X4) ||\r\n        type.isEqual(T_BOOL4X4) ||\r\n        type.isEqual(T_INT4X4)) {\r\n        return \"Mat4\";\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ECheckStage, EInstructionTypes, IExprInstruction, IForStmtInstruction, IStmtInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IForStmtInstructionSettings extends IInstructionSettings {\r\n    init?: ITypedInstruction;\r\n    cond?: IExprInstruction;\r\n    step?: IExprInstruction;\r\n    body?: IStmtInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent for(forInit forCond ForStep) stmt\r\n * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction\r\n */\r\nexport class ForStmtInstruction extends StmtInstruction implements IForStmtInstruction {\r\n    protected _init: ITypedInstruction;\r\n    protected _cond: IExprInstruction;\r\n    protected _step: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    constructor({ init = null, cond = null, step = null, body = null, ...settings }: IForStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ForStmt, ...settings });\r\n\r\n        this._init = Instruction.$withParent(init, this);\r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._step = Instruction.$withParent(step, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n    }\r\n\r\n\r\n    get init(): ITypedInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n\r\n    get step(): IExprInstruction {\r\n        return this._step;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"for(\";\r\n\r\n        code += this._init.toCode() + \";\";\r\n        code += this._cond.toCode() + \";\";\r\n        code += this._step.toCode() + \")\";\r\n        code += this._body.toCode();\r\n\r\n        return code;\r\n    }\r\n\r\n    // TODO: move it to Analysis.ts\r\n    check(stage: ECheckStage, info: any = null): boolean {\r\n        if (isNull(this._step)) {\r\n            this._setError(EAnalyzerErrors.InvalidForStepEmpty);\r\n            return false;\r\n        }\r\n\r\n        if (isNull(this._init)) {\r\n            this._setError(EAnalyzerErrors.InvalidForInitEmptyIterator);\r\n            return false;\r\n        }\r\n\r\n        if (this._init.instructionType !== EInstructionTypes.k_VariableDecl) {\r\n            this._setError(EAnalyzerErrors.InvalidForInitExpr);\r\n            return false;\r\n        }\r\n\r\n        if (isNull(this._cond)) {\r\n            this._setError(EAnalyzerErrors.InvalidForConditionEmpty);\r\n            return false;\r\n        }\r\n\r\n        if (this._cond.instructionType !== EInstructionTypes.k_RelationalExpr) {\r\n            this._setError(EAnalyzerErrors.InvalidForConditionRelation);\r\n            return false;\r\n        }\r\n\r\n        if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||\r\n            this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||\r\n            this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {\r\n            \r\n            // todo: rewrite this check!!\r\n            // var sOperator: string = this._step.operator;\r\n            // if (sOperator !== \"++\" && sOperator !== \"--\" &&\r\n            //     sOperator !== \"+=\" && sOperator !== \"-=\") {\r\n            //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });\r\n            //     return false;\r\n            // }\r\n        }\r\n        else {\r\n            this._setError(EAnalyzerErrors.InvalidForStepExpr);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { isString } from \"@lib/common\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\n\r\nimport { Analyzer } from \"./analisys/Analyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\nexport async function createSLDocument(textDocument: ITextDocument, flags?: number): Promise<ISLDocument>;\r\nexport async function createSLDocument(slastDocument: ISLASTDocument): Promise<ISLDocument>;\r\nexport async function createSLDocument(document: ISLASTDocument | ITextDocument, flags?: number): Promise<ISLDocument> {\r\n    let textDocument = <ITextDocument>document;\r\n    let slastDocument = <ISLASTDocument>document;\r\n\r\n    if (isString(textDocument.source)) {    \r\n        slastDocument = await createSLASTDocument(textDocument, flags);\r\n    }\r\n    \r\n    const analyzer = new Analyzer;\r\n    return await analyzer.parse(slastDocument);\r\n}\r\n\r\n","import { EInstructionTypes, IAssignmentExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type AssigmentOperator = \"=\" | \"+=\" | \"-=\" | \"/=\" | \"*=\" | \"%=\";\r\n\r\nexport interface IAssignmentExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: ITypedInstruction;\r\n    operator: AssigmentOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr = += -= /= *= %= someExpr\r\n * (=|+=|-=|*=|/=|%=) Instruction Instruction\r\n */\r\nexport class AssignmentExprInstruction extends ExprInstruction implements IAssignmentExprInstruction {\r\n    protected _leftValue: IExprInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n    protected _operator: AssigmentOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IAssignmentExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });\r\n\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport class TypedInstruction extends Instruction implements ITypedInstruction {\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Typed, ...settings });\r\n        \r\n        this._type = Instruction.$withNoParent(type);\r\n\r\n        // todo: remove this check\r\n        if (isNull(this._type)) {\r\n            console.warn(\"Something goes wrong! Type is not specified!\", this);\r\n        }\r\n    }\r\n\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","export const END_POSITION               = 'END';                 // item, parser\r\nexport const T_EMPTY                    = 'EMPTY';               // item, parser\r\nexport const UNKNOWN_TOKEN              = 'UNKNOWN';             // lexer\r\nexport const START_SYMBOL               = 'S';                   // parser\r\nexport const UNUSED_SYMBOL              = '##';                  // parser\r\nexport const INLINE_COMMENT_SYMBOL      = '#';                   // parser\r\n// TODO: do not use ambigious name 'ERROR'\r\nexport const ERROR                      = 'ERROR';               // parser\r\nexport const END_SYMBOL                 = '$';                   // lexer, parser\r\nexport const LEXER_RULES                = '--LEXER--';           // parser\r\nexport const FLAG_RULE_CREATE_NODE      = '--add';                // parser\r\nexport const FLAG_RULE_SKIP_NODE        = '--skip';              // parser\r\nexport const FLAG_RULE_EXPOSE_NODE      = '--expose';            // parser\r\nexport const FLAG_RULE_FUNCTION         = '--F';                 // parser\r\nexport const EOF                        = 'EOF';                 // lexer\r\nexport const T_STRING                   = 'T_STRING';            // lexer\r\nexport const T_FLOAT                    = 'T_FLOAT';             // lexer\r\nexport const T_UINT                     = 'T_UINT';              // lexer\r\nexport const T_TYPE_ID                  = 'T_TYPE_ID';           // lexer\r\nexport const T_NON_TYPE_ID              = 'T_NON_TYPE_ID';       // lexer\r\nexport const T_LINE_TERMINATOR          = 'T_LINE_TERMINATOR';   // lexer\r\n","// tslint:disable:typedef\r\n// tslint:disable:max-func-body-length\r\n// tslint:disable:cyclomatic-complexity\r\n\r\n\r\nimport { isNull } from '@lib/common';\r\nimport { cdlview } from '@lib/fx/bytecode';\r\nimport { i32Asf32, u32Asf32, u32Asi32, u8ArrayAsF32, u8ArrayAsI32 } from '@lib/fx/bytecode/common';\r\nimport InstructionList from '@lib/fx/bytecode/InstructionList';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\nimport { EChunkType } from '@lib/idl/bytecode';\r\nimport { EOperation } from '@lib/idl/bytecode/EOperations';\r\nimport DistinctColor from '@lib/util/DistinctColor';\r\nimport { mapActions, sourceCode as sourceActions } from '@sandbox/actions';\r\nimport { mapProps } from '@sandbox/reducers';\r\nimport { getDebugger } from '@sandbox/reducers/sourceFile';\r\nimport { IDebuggerState } from '@sandbox/store/IStoreState';\r\nimport * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Button, Icon, Table } from 'semantic-ui-react';\r\n\r\nexport interface IBytecodeViewProps extends IDebuggerState {\r\n    actions: typeof sourceActions;\r\n}\r\n\r\n\r\nexport interface IBytecodeViewState {\r\n    count: number;\r\n    cdlView: ReturnType<typeof cdlview>;\r\n}\r\n\r\n\r\nfunction minWidth(str: string, len: number = 0, char: string = ' ') {\r\n    for (let i = 0, slen = str.length; i < Math.max(0, len - slen); ++i) {\r\n        str = char + str;\r\n    }\r\n    return str;\r\n}\r\n\r\nconst REG_NAMES = {\r\n    [0x100]: 'rax' // todo: get register adresses from bytecode generator\r\n};\r\n\r\nconst constant = (v: string) => `\"${v}\"`;\r\nconst float = (v: number) => String(v).indexOf('.') === -1 ? `${v}.f` : `${v}f`;\r\nconst fixPrecision = (v: number, precision = 2) => Math.floor(v * Math.pow(10, 2)) / Math.pow(10, 2);\r\nconst hex2 = (v: number) => `0x${minWidth(v.toString(16), 2, '0')}`;\r\nconst hex4 = (v: number) => `0x${minWidth(v.toString(16), 4, '0')}`;\r\nconst reg = (v: number) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`;    // register address;\r\nconst addr = (v: number) => `%${hex4(v >>> 0)}%`;                   // global memory address;\r\nconst any4 = (v: number | string) => `${minWidth(String(v), 4, ' ')}`;\r\nconst scode = (c: EOperation) => {\r\n    let s = String(EOperation[c]);\r\n    s = s.substr(2);\r\n\r\n    let v = '';\r\n    for (const char of s) {\r\n        if (char === char.toUpperCase() && (char < '0' || char > '9') && v.length > 0) {\r\n            v += '_';\r\n        }\r\n\r\n        v += char.toLowerCase();\r\n    }\r\n\r\n    switch (c) {\r\n        case EOperation.k_I32SetConst: return 'i32_set';\r\n        case EOperation.k_I32LoadRegister: return 'i32_load';\r\n        case EOperation.k_I32LoadRegistersPointer: return 'i32_load*';\r\n        case EOperation.k_I32StoreRegisterPointer: return 'i32_store*';\r\n        case EOperation.k_I32LoadInputPointer: return 'i32_load_input*';\r\n        case EOperation.k_I32StoreInputPointer: return 'i32_store_input*';\r\n        case EOperation.k_I32GreaterThanEqual: return 'i32_ge';\r\n        case EOperation.k_I32LessThan: return 'i32_lt';\r\n        case EOperation.k_U32GreaterThanEqual: return 'u32_ge';\r\n        case EOperation.k_U32LessThan: return 'u32_lt';\r\n        case EOperation.k_F32GreaterThanEqual: return 'f32_ge';\r\n        case EOperation.k_F32LessThan: return 'f32_lt';\r\n        case EOperation.k_I32Not: return 'i32_not';\r\n        case EOperation.k_I32NotEqual: return 'i32_ne';\r\n        default:\r\n            return v;\r\n    }\r\n};\r\n\r\n\r\nclass BytecodeView extends React.Component<IBytecodeViewProps, IBytecodeViewState>  {\r\n\r\n    state: IBytecodeViewState = {\r\n        count: 0,\r\n        cdlView: null\r\n    };\r\n\r\n    static getDerivedStateFromProps(props: IBytecodeViewProps, state: IBytecodeViewState) {\r\n        const count = 0;\r\n        const cdlView = cdlview(props.runtime.cdl);\r\n\r\n        return { count, cdlView };\r\n    }\r\n\r\n    render() {\r\n        const { props } = this;\r\n        const { runtime: { code, cdl } } = props;\r\n\r\n        if (isNull(code)) {\r\n            return null;\r\n        }\r\n\r\n        const chunks = VM.decodeChunks(code);\r\n        const ilist = VM.decodeCodeChunk(chunks[EChunkType.k_Code]);\r\n\r\n        return (\r\n            // fixed\r\n            <div>\r\n                <Table size='small' unstackable basic compact style={ { fontFamily: 'consolas', whiteSpace: 'pre' } }>\r\n                    <Table.Body style={ {\r\n                        maxHeight: 'calc(100vh - 432px)',\r\n                        overflowY: 'auto',\r\n                        display: 'block'\r\n                    } }>\r\n                        { this.renderOpList(ilist) }\r\n                    </Table.Body>\r\n                    { props.options.disableOptimizations &&\r\n                        <Table.Footer>\r\n                            <Table.Row >\r\n                                <Table.Cell colSpan={ 5 } inverted warning textAlign='center'\r\n                                    style={ { padding: '2px', fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif' } }\r\n                                >\r\n                                    optimizations are disabled\r\n                            </Table.Cell>\r\n                            </Table.Row>\r\n                        </Table.Footer>\r\n                    }\r\n                </Table>\r\n                <Button animated onClick={ async () => {\r\n                    const result = VM.asNative(await VM.evaluate(code), cdl);\r\n                    alert(JSON.stringify(result, null, '   '));\r\n                } }>\r\n                    <Button.Content visible>Run</Button.Content>\r\n                    <Button.Content hidden>\r\n                        <Icon name='rocket' />\r\n                    </Button.Content>\r\n                </Button>\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    renderOpList(ilist: Uint32Array) {\r\n        const list = [];\r\n        for (let i = 0; i < ilist.length; i += 5) {\r\n            list.push(this.renderOp(ilist.subarray(i, i + 5)));\r\n        }\r\n        return list;\r\n    }\r\n\r\n\r\n    renderOp(op: Uint32Array) {\r\n        const code: EOperation = op[0];\r\n        const args = [op[1], op[2], op[3], op[4]];\r\n        switch (op[3]) {\r\n            default:\r\n                return this.renderOpInternal(code, args);\r\n        }\r\n    }\r\n\r\n    showSourceLine(pc: number) {\r\n        // console.log(this.state.cdlView.resolveFileLocation(pc));\r\n    }\r\n\r\n    hideSourceLine(oc: number) {\r\n\r\n    }\r\n\r\n\r\n    // tslint:disable-next-line:max-func-body-length:\r\n    // tslint:disable-next-line:cyclomatic-complexity\r\n    renderOpInternal(code: EOperation, args: number[]) {\r\n        const i = this.state.count++;\r\n        const { cdlView } = this.state;\r\n\r\n        switch (code) {\r\n            case EOperation.k_I32SetConst:\r\n                args.length = 3;\r\n                // op, const, hint\r\n                break;\r\n\r\n            case EOperation.k_I32LoadRegister:\r\n                args.length = 2;\r\n                break;\r\n\r\n            case EOperation.k_I32LoadRegistersPointer:\r\n            case EOperation.k_I32StoreRegisterPointer:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_I32LoadInput:\r\n            case EOperation.k_I32StoreInput:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_I32LoadInputPointer:\r\n            case EOperation.k_I32StoreInputPointer:\r\n                args.length = 4;\r\n                break;\r\n\r\n            case EOperation.k_I32Not:\r\n                args.length = 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Equal:\r\n            case EOperation.k_I32NotEqual:\r\n            case EOperation.k_I32GreaterThanEqual:\r\n            case EOperation.k_I32LessThan:\r\n            case EOperation.k_U32GreaterThanEqual:\r\n            case EOperation.k_U32LessThan:\r\n            case EOperation.k_F32GreaterThanEqual:\r\n            case EOperation.k_F32LessThan:\r\n            case EOperation.k_I32LogicalOr:\r\n            case EOperation.k_I32LogicalAnd:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_F32ToI32:\r\n            case EOperation.k_I32ToF32:\r\n            case EOperation.k_F32ToU32:\r\n            case EOperation.k_U32ToF32:\r\n                args.length = 2;\r\n                break;\r\n\r\n            case EOperation.k_I32Add:\r\n            case EOperation.k_I32Sub:\r\n            case EOperation.k_I32Div:\r\n            case EOperation.k_I32Mul:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_I32Min:\r\n            case EOperation.k_I32Max:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_F32Add:\r\n            case EOperation.k_F32Sub:\r\n            case EOperation.k_F32Div:\r\n            case EOperation.k_F32Mul:\r\n                args.length = 3;\r\n                break;\r\n\r\n            case EOperation.k_F32Sin:\r\n            case EOperation.k_F32Cos:\r\n            case EOperation.k_F32Frac:\r\n            case EOperation.k_F32Sqrt:\r\n            case EOperation.k_F32Floor:\r\n            case EOperation.k_F32Ceil:\r\n                args.length = 2;\r\n                break;\r\n\r\n            case EOperation.k_F32Min:\r\n            case EOperation.k_F32Max:\r\n                args.length = 3;\r\n                break;\r\n\r\n\r\n            case EOperation.k_JumpIf:\r\n            case EOperation.k_Jump:\r\n                args.length = 1;\r\n                break;\r\n\r\n            case EOperation.k_Ret:\r\n                args.length = 0;\r\n                break;\r\n\r\n            default:\r\n        }\r\n\r\n        // tslint:disable-next-line:switch-default\r\n        switch (code) {\r\n            case EOperation.k_I32SetConst:\r\n                args[1] = args[2] === 1 ? fixPrecision(u32Asf32(args[1])) : u32Asi32(args[1]);\r\n        }\r\n\r\n        //\r\n        // Convert all arguments to strings\r\n        //\r\n\r\n        let sArgs = args.map(String);\r\n\r\n        const pointer = (x: number) => `%${x}`;\r\n        const register = (x: number) => `r${x}`;\r\n\r\n        // tslint:disable-next-line:switch-default\r\n        switch (code) {\r\n            case EOperation.k_I32SetConst:\r\n                sArgs[0] = register(args[0]);\r\n                if (args[2] === 1) { // is float\r\n                    sArgs[1] = float(args[1]);\r\n                }\r\n                sArgs[1] = constant(sArgs[1]);\r\n                sArgs.length = 2;\r\n                break;\r\n            case EOperation.k_I32LoadRegister:\r\n                sArgs[0] = register(args[0]);\r\n                sArgs[1] = register(args[1]);\r\n                break;\r\n            case EOperation.k_I32LoadRegistersPointer:\r\n                sArgs[0] = register(args[0]);\r\n                sArgs[1] = pointer(args[1]);\r\n                break;\r\n            case EOperation.k_I32StoreRegisterPointer:\r\n                sArgs[0] = pointer(args[0]);\r\n                sArgs[1] = register(args[1]);\r\n                break;\r\n            case EOperation.k_I32LoadInput:\r\n                sArgs[1] = register(args[1]);\r\n                break;\r\n            case EOperation.k_I32StoreInput:\r\n                sArgs[2] = register(args[2]);\r\n                break;\r\n            case EOperation.k_I32LoadInputPointer:\r\n                sArgs[1] = register(args[1]);\r\n                sArgs[2] = pointer(args[2]);\r\n                break;\r\n            case EOperation.k_I32StoreInputPointer:\r\n                sArgs[1] = pointer(args[1]);\r\n                sArgs[2] = register(args[2]);\r\n                break;\r\n            case EOperation.k_Jump:\r\n                sArgs[0] = hex2(args[0] / InstructionList.STRIDE);\r\n                break;\r\n            default:\r\n                sArgs = args.map(register);\r\n        }\r\n\r\n        sArgs = sArgs.map(any4);\r\n\r\n        // let htmlArgs: JSX.Element[] = [];\r\n        // const asSpan = (v: string) => (<span>&nbsp;{ v }&nbsp;</span>);\r\n\r\n        // switch (code) {\r\n        //     case EOperation.k_I32SetConst:\r\n        //         htmlArgs[0] = asSpan(sArgs[0]);\r\n        //         htmlArgs[1] = (<span style={ { color: 'gray' } }>&nbsp;{ sArgs[1] }&nbsp;</span>);\r\n        //         break;\r\n        //     default:\r\n        //         htmlArgs = sArgs.map(asSpan);\r\n        // }\r\n\r\n        let specColor = null;\r\n        if (this.props.options.colorize) {\r\n            specColor = {\r\n                padding: '0.2em 0',\r\n                opacity: 0.5,\r\n                background: DistinctColor.make(cdlView.resolvePcColor(i)).toRGBAString(),\r\n                width: '4px'\r\n            };\r\n        }\r\n\r\n        return (\r\n            <Table.Row key={ `op-${code}-${i}` }\r\n                style={ { width: '100%', display: 'table', tableLayout: 'fixed', borderBottom: 'none' } }\r\n                onMouseOver={ () => this.showSourceLine(i) } onMouseOut={ () => this.hideSourceLine(i) }>\r\n                <Table.Cell style={ specColor }></Table.Cell>\r\n                <Table.Cell style={ { padding: '0.2em 0.7em', width: '50px' } }>{ hex4(i) }</Table.Cell>\r\n                <Table.Cell style={ { padding: '0.2em 0.7em' } }>{ scode(code) }</Table.Cell>\r\n                <Table.Cell colSpan={ 2 } style={ { padding: '0.2em 0.7em' } }>\r\n                    {/* { htmlArgs } */}\r\n                    { sArgs.join(' ') }\r\n                </Table.Cell>\r\n            </Table.Row>\r\n        );\r\n    }\r\n}\r\n\r\nexport default connect<{}, {}, IBytecodeViewProps>(mapProps(getDebugger), mapActions(sourceActions))(BytecodeView) as any;\r\n","import { EInstructionTypes, IDeclInstruction, IDeclStmtInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IDeclStmtInstructionSettings extends IInstructionSettings {\r\n    declList?: IDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent TypeDecl or VariableDecl or VarStructDecl\r\n * EMPTY DeclInstruction\r\n */\r\nexport class DeclStmtInstruction extends StmtInstruction implements IDeclStmtInstruction {\r\n    private _declList: IDeclInstruction[];\r\n\r\n    \r\n    constructor({ declList = null, ...settings }: IDeclStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DeclStmt, ...settings });\r\n        \r\n        this._declList = (declList || []).map(decl => Instruction.$withParent(decl, this));\r\n    }\r\n\r\n\r\n    get declList(): IDeclInstruction[] {\r\n        return this._declList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code = '';\r\n        var declList = <IVariableDeclInstruction[]>this.declList;\r\n\r\n        for (var i: number = 0; i < this.declList.length; i++) {\r\n            code += declList[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n\r\n\r\n","export enum EAnalyzerWarnings {\r\n    UnsupportedRenderStateTypeUsed = 3000,\r\n    IncompleteTechnique,\r\n    IncompletePass,\r\n    UselessPassState,\r\n    // part fx\r\n}","import { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { EOperationType, EParserCode, IASTConfig, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { ASTDocument, EParsingErrors } from \"@lib/parser/ASTDocument\";\r\nimport { Lexer } from '@lib/parser/Lexer';\r\nimport { END_SYMBOL } from '@lib/parser/symbols';\r\nimport * as URI from \"@lib/uri/uri\"\r\n\r\nimport { defaultSLParser } from './SLParser';\r\n\r\n// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));\r\n\r\nconst PREDEFINED_TYPES = [\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float3x3', 'float4x4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'bool2', 'bool3', 'bool4',\r\n    'auto'\r\n];\r\n\r\nexport class SLASTDocument extends ASTDocument implements ISLASTDocument {\r\n    protected includeList: Map<string, IRange>;\r\n    protected lexers: Lexer[];\r\n    protected tokens: IToken[];\r\n\r\n    constructor({ parser = defaultSLParser() }: IASTConfig = {}) {\r\n        super({ parser, knownTypes: new Set(PREDEFINED_TYPES) });\r\n    }\r\n\r\n    get includes(): Map<string, IRange> {\r\n        return this.includeList;\r\n    }\r\n    \r\n    async parse(textDocument: ITextDocument, flags?: number): Promise<EParserCode> {\r\n        this.includeList.set(textDocument.uri, null);\r\n        return await super.parse(textDocument, flags);\r\n    }\r\n\r\n\r\n    protected init(config: IASTConfig) {\r\n        super.init(config);\r\n\r\n        this.includeList = new Map();\r\n        this.lexers = [];\r\n        this.tokens = [];\r\n        this.ruleFunctions.set('addType', this._addType.bind(this));\r\n        this.ruleFunctions.set('includeCode', this._includeCode.bind(this));\r\n    }\r\n\r\n    private _addType(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.children[node.children.length - 2].value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private emitFileNotFound(file: string, range: IRange) {\r\n        this.diag.error(EParsingErrors.GeneralCouldNotReadFile, { ...this.lexer.getLocation(), loc: range, target: file });\r\n    }\r\n\r\n\r\n    protected readToken(): IToken {\r\n        const token = super.readToken();\r\n        if (token.value === END_SYMBOL) {\r\n            if (this.lexers.length > 0) {\r\n                this.lexer = this.lexers.pop();\r\n                return this.tokens.pop();\r\n            }\r\n        }\r\n        return token;\r\n    }\r\n\r\n\r\n    private async _includeCode(): Promise<EOperationType> {\r\n        let tree = this.tree;\r\n        let node = tree.lastNode;\r\n        let file = node.value;\r\n\r\n        //cuttin qoutes\r\n        const includeURL = file.substr(1, file.length - 2);\r\n        const uri = URI.resolve(includeURL, `${this.uri}`);\r\n\r\n        if (this.includeList.has(uri)) {\r\n            console.warn(`'${uri}' file has already been included previously.`);\r\n            return EOperationType.k_Ok;\r\n        } \r\n\r\n        this.includeList.set(uri, node.loc);\r\n\r\n        try {\r\n            const response = await fetch(uri);\r\n            \r\n            if (!response.ok) {\r\n                this.emitFileNotFound(uri, node.loc);\r\n                return EOperationType.k_Error;\r\n            }\r\n\r\n        const source = await response.text();\r\n            \r\n            //\r\n            // Replace lexer with new one \r\n            //\r\n\r\n            this.lexers.push(this.lexer);\r\n            this.tokens.push(this.token);\r\n            this.lexer = new Lexer({\r\n                engine: this.parser.lexerEngine,\r\n                knownTypes: this.knownTypes\r\n            });\r\n            this.lexer.setup({ source, uri });\r\n            this.token = this.readToken();\r\n\r\n            return EOperationType.k_Ok;\r\n        } catch (e) {\r\n            console.error(e);\r\n            this.emitFileNotFound(file, node.loc);\r\n        }\r\n\r\n        return EOperationType.k_Error;\r\n    }\r\n}\r\n\r\n\r\nexport async function createSLASTDocument(textDocument: ITextDocument, flags?: number): Promise<ISLASTDocument> {\r\n    const document = new SLASTDocument();\r\n    await document.parse(textDocument, flags);\r\n    return document;\r\n}\r\n","export { default as ParserParameters } from './ParserParameters';\r\nexport { default as SourceEditor2 } from './editor/Editor';\r\nexport { default as BytecodeView } from './BytecodeView';\r\nexport { default as App } from './App';\r\nexport { default as Playground } from './playground';\r\nexport { default as ShaderTranslatorView } from './ShaderTranslatorView';\r\n","export { translate, translateExpression } from \"./Bytecode\"\r\nexport { DEFAULT_ENTRY_POINT_NAME, REG_INVALID } from \"./common\"\r\nexport { cdlview } from \"./DebugLayout\"\r\n","import { isNull } from \"@lib/common\";\r\nimport { IPassInstructionSettings, PassInstruction } from \"@lib/fx/analisys/instructions/PassInstruction\";\r\nimport { EInstructionTypes, ICompileExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPartFxPassGeometry, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nexport interface IPartFxPassInstructionSettings extends IPassInstructionSettings {\r\n    sorting?: boolean;\r\n    prerenderRoutine: ICompileExprInstruction;\r\n    geometry: EPartFxPassGeometry;\r\n    instanceCount?: number;\r\n}\r\n\r\n\r\nexport class PartFxPassInstruction extends PassInstruction implements IPartFxPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly geometry: EPartFxPassGeometry;\r\n    readonly instanceCount: number;\r\n\r\n    constructor({ sorting = false, instanceCount = 1, prerenderRoutine, geometry, ...settings }: IPartFxPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxPass, ...settings });\r\n        \r\n        this.sorting = sorting;\r\n        this.prerenderRoutine = prerenderRoutine;\r\n        this.geometry = geometry;\r\n        this.instanceCount = instanceCount;\r\n    }\r\n\r\n    get particleInstance(): ITypeInstruction {\r\n        if (isNull(this.prerenderRoutine)) {\r\n            return null;\r\n        }\r\n\r\n        return this.prerenderRoutine.function.def.params[1].type.subType;\r\n    }\r\n\r\n    isValid(): boolean {\r\n        return !!this.particleInstance && !!this.prerenderRoutine;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { fn, type, instruction } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISystemTypeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    size: number;\r\n    elementType?: ITypeInstruction;\r\n    length?: number;\r\n    fields?: IVariableDeclInstruction[];\r\n    methods?: IFunctionDeclInstruction[];\r\n    writable?: boolean;\r\n    readable?: boolean;\r\n    complex?: boolean;\r\n    sampler?: boolean;\r\n    texture?: boolean;\r\n    uav?: boolean;\r\n}\r\n\r\nexport class SystemTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _size: number;\r\n    protected _elementType: ITypeInstruction;\r\n    protected _length: number;\r\n    protected _fields: IVariableDeclInstruction[];\r\n    protected _methods: IFunctionDeclInstruction[];\r\n    protected _bIsWritable: boolean;\r\n    protected _bIsReadable: boolean;\r\n    protected _bIsComplex: boolean;\r\n    protected _bIsUAV: boolean;\r\n    protected _bIsTexture: boolean;\r\n    protected _bIsSampler: boolean;\r\n    \r\n\r\n    constructor({\r\n        name, \r\n        size = 0,\r\n        elementType = null, \r\n        length = 1, \r\n        fields = [],\r\n        methods = [],\r\n        writable = true, \r\n        readable = true, \r\n        complex = false,\r\n        sampler = false,\r\n        texture = false,\r\n        uav = false,\r\n        ...settings\r\n    }: ISystemTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemType, ...settings });\r\n\r\n        this._name = name;\r\n        this._size = size;\r\n        this._elementType = Instruction.$withNoParent(elementType);\r\n        this._length = length;\r\n        this._fields = [];\r\n        this._methods = [];\r\n        this._bIsWritable = writable;\r\n        this._bIsReadable = readable;\r\n        this._bIsComplex = complex;\r\n        this._bIsSampler = sampler;\r\n        this._bIsTexture = texture;\r\n        this._bIsUAV = uav;\r\n\r\n        fields.forEach(field => this.addField(field));\r\n        methods.forEach(method => this.addMethod(method));\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        return this._bIsWritable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        return this._bIsReadable;\r\n    }\r\n\r\n\r\n    set name(sName: string) {\r\n        this._name = sName;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get hash(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get strongHash(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get size(): number {\r\n        if (this.isArray()) {\r\n            if (this.length === instruction.UNDEFINE_LENGTH) {\r\n                return instruction.UNDEFINE_LENGTH;\r\n            }\r\n            return this.arrayElementType.size * this.length;\r\n        }\r\n        return this._size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n\r\n    get arrayElementType(): ITypeInstruction {\r\n        return this._elementType;\r\n    }\r\n\r\n\r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this._fields;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this._methods;\r\n    }\r\n\r\n\r\n    get fieldNames(): string[] {\r\n        return this._fields.map(field => field.name);\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return this._bIsSampler;\r\n    }\r\n\r\n\r\n    isTexture(): boolean {\r\n        return this._bIsTexture;\r\n    }\r\n\r\n\r\n    isUAV(): boolean {\r\n        return this._bIsUAV;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n\r\n    toDeclString(): string {\r\n        console.warn('@pure_virtual');\r\n        return '';\r\n    }\r\n\r\n\r\n    isBase(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this.arrayElementType);\r\n    }\r\n\r\n\r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this._bIsComplex;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainSampler(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainPointer(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainComplexType(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || type.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return !!this.getField(fieldName);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields.find(field => field.name === fieldName) || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction | undefined | null {\r\n        const list = this._methods.filter(method => method.name === methodName);\r\n        return fn.matchList(list, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        console.error(\"@undefined_behavior\");\r\n        return null;\r\n    }\r\n\r\n\r\n    /** internal api */\r\n    addField(field: IVariableDeclInstruction): void {\r\n        console.assert(this.getField(field.name) === null);\r\n        this._fields.push(Instruction.$withParent(field, this));\r\n    }\r\n\r\n    /** internal api */\r\n    addMethod(method: IFunctionDeclInstruction): void {\r\n        console.assert(isNull(this.getMethod(method.name, method.def.params.map(param => param.type))));\r\n        this._methods.push(Instruction.$withParent(method, this));\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IConditionalExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\nimport { type } from '@lib/fx/analisys/helpers';\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConditionalExprInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    left: ITypedInstruction;\r\n    right: ITypedInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represen boolExpr ? someExpr : someExpr\r\n * EMPTY_OPERATOR Instruction Instruction Instruction \r\n */\r\nexport class ConditionalExprInstruction extends ExprInstruction implements IConditionalExprInstruction {\r\n    protected _cond: IExprInstruction;\r\n    protected _leftValue: ITypedInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n\r\n    constructor({ cond, left, right, ...settings }: IConditionalExprInstructionSettings) {\r\n        // todo: do not use {left.type} here\r\n        super({ instrType: EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings});\r\n\r\n        console.assert(type.equals(left.type, right.type, true));\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n    }\r\n\r\n\r\n    get condition(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n    \r\n    get left(): ITypedInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '(';\r\n        code += this.condition.toCode();\r\n        code += '?';\r\n        code += this.left.toCode();\r\n        code += ':';\r\n        code += this.right.toCode();\r\n        code += ')';\r\n        return code;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.condition).isConst() &&\r\n            (<IExprInstruction>this.left).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface ISpawnInstructionSettings extends IInstructionSettings {\r\n    count: number;\r\n    args: IExprInstruction[];\r\n    name: string;\r\n}\r\n\r\n\r\nexport class SpawnInstruction extends StmtInstruction implements ISpawnStmtInstruction {\r\n    readonly count: number;\r\n    readonly args: IExprInstruction[];\r\n    readonly name: string;\r\n    \r\n    private _fx: IPartFxInstruction = null;\r\n    private _init: IFunctionDeclInstruction = null;\r\n\r\n    constructor({ count, name, args, ...settings }: ISpawnInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SpawnStmt, ...settings });\r\n\r\n        this.count = count;\r\n        this.args = args;\r\n        this.name = name;\r\n    }    \r\n\r\n    \r\n    get fx(): IPartFxInstruction {\r\n        return this._fx;\r\n    }\r\n\r\n\r\n    get init(): IFunctionDeclInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;\r\n    }\r\n\r\n    // delayed resolve of the spawn instructions\r\n    $resolve(fx: IPartFxInstruction, init: IFunctionDeclInstruction): void {\r\n        this._fx = fx;\r\n        this._init = init;\r\n    }\r\n}\r\n","import { assert } from \"@lib/common\";\r\nimport { u8ArrayAsF32, u8ArrayAsI32 } from \"@lib/fx/bytecode/common\";\r\nimport { CDL } from \"@lib/fx/bytecode/DebugLayout\";\r\nimport { ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nfunction asNativeVector(elementDecoder: (u8: Uint8Array) => any, value: Uint8Array, length: number, stride = 4): any[] {\r\n    const vector = [];\r\n    for (let i = 0; i < length; ++i) {\r\n        vector.push(elementDecoder(value.subarray(stride * i, stride * i + stride)));\r\n    }\r\n    return vector;\r\n}\r\n\r\nconst asInt = u8ArrayAsI32;\r\nconst asUint = u8a => (asInt(u8a) >>> 0);\r\nconst asFloat = u8ArrayAsF32;\r\nconst asBool = u8a => asInt(u8a) !== 0;\r\n\r\ntype TypeLayout = ITypeInstruction;\r\n\r\nexport function asNativeInner(result: Uint8Array, layout: TypeLayout): any {\r\n    // TODO: remove it?\r\n    while (layout !== layout.baseType) {\r\n        layout = layout.baseType;\r\n    }\r\n    switch (layout.name) {\r\n        case 'bool':\r\n            return asBool(result);\r\n        case 'int':\r\n            return asInt(result);\r\n        case 'float':\r\n            return asFloat(result);\r\n        case 'uint':\r\n            return asUint(result);\r\n        case 'uint2':\r\n        case 'uint3':\r\n        case 'uint4':\r\n            return asNativeVector(asUint, result, layout.length, 4);\r\n        case 'int2':\r\n        case 'int3':\r\n        case 'int4':\r\n            return asNativeVector(asInt, result, layout.length, 4);\r\n        case 'float2':\r\n        case 'float3':\r\n        case 'float4':\r\n            return asNativeVector(asFloat, result, layout.length, 4);\r\n    }\r\n\r\n    if (layout.isComplex()) {\r\n        let complex = {};\r\n        layout.fields.forEach(field => {\r\n            const { type, type: { padding, size } } = field;\r\n            complex[field.name] = asNativeInner(result.subarray(padding, padding + size), type);\r\n        });\r\n        return complex;\r\n    }\r\n\r\n    if (layout.isNotBaseArray()) {\r\n        return asNativeVector(u8a => asNativeInner(u8a, layout.arrayElementType), result, layout.length, layout.arrayElementType.size);\r\n    }\r\n\r\n    assert(false, `not implemented: ${layout.toCode()}`);\r\n    return null;\r\n}\r\n\r\nexport function asNative(result: Uint8Array, cdl: CDL): any {\r\n    let layout = cdl.info.layout;\r\n    return asNativeInner(result, layout);\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { EInstructionTypes, ICompileExprInstruction, IFunctionDeclInstruction, IInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EPartFxPassGeometry, IPartFxInstruction, IPartFxPassInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { CodeEmitter } from \"./CodeEmitter\";\r\n\r\nexport class FxEmitter extends CodeEmitter {\r\n\r\n    protected emitRoutineProperty(name: string, routine: ICompileExprInstruction) {\r\n        this.emitKeyword(name);\r\n        this.emitKeyword('=');\r\n        this.emitSpace();\r\n        this.emitCompile(routine);\r\n        this.emitChar(';');\r\n        this.emitNewline();\r\n    }\r\n\r\n    protected emitStringProperty(name: string, id: string) {\r\n        this.emitKeyword(name),\r\n        this.emitKeyword('='),\r\n        this.emitKeyword(id),\r\n        this.emitChar(';'),\r\n        this.emitNewline()\r\n    }\r\n\r\n    protected emitSpawnStmt(stmt: ISpawnStmtInstruction) {\r\n        this.emitKeyword(`spawn(${stmt.count})`);\r\n        this.emitKeyword(stmt.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        stmt.args.forEach((arg, i, list) => {\r\n            this.emitExpression(arg);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n        this.emitChar(')');\r\n        this.emitChar(';');\r\n    }\r\n\r\n    emitPartFxDecl(fx: IPartFxInstruction) {\r\n        this.begin();\r\n        {\r\n            this.emitKeyword('partFx');\r\n            fx.name && this.emitKeyword(fx.name);\r\n            fx.semantic && this.emitSemantic(fx.semantic);\r\n            fx.annotation && this.emitAnnotation(fx.annotation);\r\n            this.emitNewline();\r\n            this.emitChar('{');\r\n            this.push();\r\n            {\r\n                fx.capacity && this.emitStringProperty('Capacity', String(fx.capacity));\r\n\r\n                fx.spawnRoutine && this.emitRoutineProperty('SpawnRoutine', fx.spawnRoutine);\r\n                fx.initRoutine && this.emitRoutineProperty('InitRoutine', fx.initRoutine);\r\n                fx.updateRoutine && this.emitRoutineProperty('UpdateRoutine', fx.updateRoutine);\r\n\r\n                this.emitNewline();\r\n                fx.passList.forEach((pass, i) => (this.emitPartFxPass(pass),\r\n                    i !== fx.passList.length - 1 && this.emitNewline()));\r\n            }\r\n            this.pop();\r\n            this.emitChar('}');\r\n        }\r\n        this.end();\r\n    }\r\n\r\n\r\n    emitPartFxPass(pass: IPartFxPassInstruction) {\r\n        this.emitKeyword('pass');\r\n        pass.name && this.emitKeyword(pass.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        {\r\n            pass.prerenderRoutine && this.emitRoutineProperty('PrerenderRoutine', pass.prerenderRoutine);\r\n            pass.sorting && this.emitStringProperty('Sorting', String(pass.sorting));\r\n            this.emitStringProperty('Geometry', EPartFxPassGeometry[pass.geometry].substr(2));\r\n            pass.instanceCount !== 1 && this.emitStringProperty('InstanceCount', String(pass.instanceCount));\r\n\r\n            super.emitPassBody(pass);\r\n        }\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n    emitStmt(stmt: IInstruction) {\r\n        switch (stmt.instructionType) {\r\n            case EInstructionTypes.k_SpawnStmt:\r\n                this.emitSpawnStmt(stmt as ISpawnStmtInstruction);\r\n                break;\r\n            default:\r\n                super.emitStmt(stmt);\r\n        }\r\n    }\r\n\r\n\r\n    emit(instr: IInstruction): CodeEmitter {\r\n        if (!instr) {\r\n            return this;\r\n        }\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_PartFxDecl:\r\n                this.emitPartFxDecl(instr as IPartFxInstruction);\r\n                break;\r\n            case EInstructionTypes.k_PartFxPass:\r\n                this.emitPartFxPass(instr as IPartFxPassInstruction);\r\n                break;\r\n            default:\r\n                super.emit(instr)\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // emnitPartFx(partFx: IPartFxInstruction) {\r\n    //     this.begin();\r\n    //     this.emitComment('ATTENTION: This file is autogenerated.\\nDo not change it directly.');\r\n    //     this.end();\r\n    //     //partFx.particle\r\n    // }\r\n}\r\n\r\nexport function translate(instr: IInstruction): string {\r\n    const emitter = new FxEmitter();\r\n    emitter.emit(instr);\r\n    return emitter.toString();\r\n}\r\n\r\n","import { isEqual } from \"./bf/bf\";\r\nimport { IMap } from \"./idl/IMap\";\r\n\r\nexport let typeOf: (x: any) => string = (x: any): string => {\r\n    const s: string = typeof x;\r\n\r\n    if (s === 'object') {\r\n        if (x) {\r\n            if (x instanceof Array) {\r\n                return 'array';\r\n            } else if (x instanceof Object) {\r\n                return s;\r\n            }\r\n\r\n            const sClassName: string = Object.prototype.toString.call(x);\r\n\r\n            if (sClassName === '[object Window]') {\r\n                return 'object';\r\n            }\r\n\r\n            if ((sClassName === '[object Array]' ||\r\n                (typeof x.length) === 'number' &&\r\n                (typeof x.splice) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('splice')\r\n\r\n            )) {\r\n                return 'array';\r\n            }\r\n\r\n            if ((sClassName === '[object Function]' ||\r\n                (typeof x.call) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('call'))) {\r\n                return 'function';\r\n            }\r\n        } else {\r\n            return 'null';\r\n        }\r\n    } else if (s === 'function' && (typeof x.call) === 'undefined') {\r\n        return 'object';\r\n    }\r\n\r\n    return s;\r\n};\r\n\r\nexport let isDef = (x: any): boolean => x !== undefined;\r\nexport let isDefAndNotNull = (x: any): boolean => x != null;\r\nexport let isEmpty = (x: any): boolean => x.length === 0;\r\nexport let isNull = (x: any): boolean => x === null;\r\nexport let isBoolean = (x: any): boolean => typeof x === 'boolean';\r\nexport let isString = (x: any): boolean => typeof x === 'string';\r\nexport let isNumber = (x: any): boolean => typeof x === 'number';\r\nexport let isFloat = isNumber;\r\nexport let isInt = (x: any): boolean => isNumber(x) && (~~x === x);\r\nexport let isUint = (x: any): boolean => isInt(x) && x > 0;\r\nexport let isFunction = (x: any): boolean => typeOf(x) === 'function';\r\nexport let isObject = (x: any): boolean => {\r\n    const T: string = typeOf(x);\r\n    return T === 'object' || T === 'array' || T === 'function';\r\n};\r\nexport let isArrayBuffer = (x: any): boolean => x instanceof ArrayBuffer;\r\nexport let isTypedArray = (x: any): boolean => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';\r\nexport let isBlob = (x: any): boolean => x instanceof Blob;\r\nexport let isArray = (x: any): boolean => typeOf(x) === 'array';\r\n// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);\r\nexport let deepEqual = (a: Object, b: Object) => JSON.stringify(a) === JSON.stringify(b);\r\n\r\n\r\nexport type Nullable<T> = {[P in keyof T]: T[P] | null } | null;\r\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\nexport type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\r\nexport type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\r\nexport type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\r\nexport type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\r\n/** For ex: retrieve the properties of the child that the parent does not have. */\r\nexport type Diff<T1, T2> = Pick<T1, Exclude<keyof T1, keyof T2>>;\r\nexport type NonFunctionDiff<T1, T2> = NonFunctionProperties<Diff<T1, T2>>;\r\nexport type PropertiesDiff<T1, T2> = Writeable<NonFunctionDiff<T1, T2>>;\r\nexport type MakeOptional<T> = { [P in keyof T]?: T[P]; };\r\n\r\nexport const assert = console.assert.bind(console);\r\nexport const verbose = console.log.bind(console);\r\n\r\n/** 'ForEach' for maps. */\r\nexport function mwalk<T>(map: IMap<T>, cb: (element: T, key?: string, i?: number) => boolean | void) {\r\n    let i = 0;\r\n    for (const key in map) {\r\n        if (cb(map[key], key, i++) === false) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileExprInstruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICompileExprInstructionSettings extends IExprInstructionSettings {\r\n    operand: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n  * Represetn compile vs_func(...args)\r\n  * compile IdExprInstruction ExprInstruction ... ExprInstruction\r\n  */\r\nexport class CompileExprInstruction extends ExprInstruction implements ICompileExprInstruction {\r\n    protected _operand: IFunctionDeclInstruction;\r\n    protected _args: IExprInstruction[];\r\n\r\n\r\n    constructor({ operand, args = null, ...settings }: ICompileExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileExpr, ...settings });\r\n\r\n        this._operand = Instruction.$withParent(operand, this);\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    \r\n    get function(): IFunctionDeclInstruction {\r\n        return <IFunctionDeclInstruction>this._operand;\r\n    }\r\n\r\n    \r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IPostfixIndexInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixIndexInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    index: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent element[index]\r\n * EMPTY_OPERATOR Instruction ExprInstruction\r\n */\r\nexport class PostfixIndexInstruction extends ExprInstruction implements IPostfixIndexInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly index: IExprInstruction;\r\n\r\n    constructor({ element, index, ...settings }: IPostfixIndexInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_PostfixIndexExpr, \r\n            type: (element.type as IVariableTypeInstruction).arrayElementType, ...settings });\r\n            \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.index = Instruction.$withParent(index, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.element.toCode()}[${this.index.toCode()}]`;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.element.isConst() && this.index.isConst();\r\n    }\r\n}\r\n\r\n\r\n","export enum ETextureFilters {\r\n    UNDEF = 0x0000,\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n    NEAREST_MIPMAP_NEAREST = 0x2700,\r\n    LINEAR_MIPMAP_NEAREST = 0x2701,\r\n    NEAREST_MIPMAP_LINEAR = 0x2702,\r\n    LINEAR_MIPMAP_LINEAR = 0x2703\r\n}\r\n\r\nexport enum ETextureWrapModes {\r\n    UNDEF = 0x0000,\r\n    REPEAT = 0x2901,\r\n    CLAMP_TO_EDGE = 0x812F,\r\n    MIRRORED_REPEAT = 0x8370\r\n}\r\n\r\nexport enum ETextureParameters {\r\n    MAG_FILTER = 0x2800,\r\n    MIN_FILTER,\r\n    WRAP_S,\r\n    WRAP_T\r\n}\r\n\r\nexport enum ETextureTypes {\r\n    TEXTURE_2D = 0x0DE1,\r\n    TEXTURE_CUBE_MAP = 0x8513,\r\n}\r\n\r\nexport enum ECubeFace {\r\n    POSITIVE_X = 0,\r\n    NEGATIVE_X = 1,\r\n    POSITIVE_Y = 2,\r\n    NEGATIVE_Y = 3,\r\n    POSITIVE_Z = 4,\r\n    NEGATIVE_Z = 5,\r\n}\r\n\r\nexport enum ETextureCubeFlags {\r\n    POSITIVE_X = 0x00000001,\r\n    NEGATIVE_X = 0x00000002,\r\n    POSITIVE_Y = 0x00000004,\r\n    NEGATIVE_Y = 0x00000008,\r\n    POSITIVE_Z = 0x0000000c,\r\n    NEGATIVE_Z = 0x000000010,\r\n}\r\n\r\nexport enum ETextureUnits {\r\n    TEXTURE0 = 0x84C0\r\n}\r\n\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, EScopeType, IExprInstruction, IInitExprInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents:\r\n *   int a[3] = { 1, 2, 3 };\r\n *              -----------\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    type: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\nexport class InitExprInstruction extends ExprInstruction implements IInitExprInstruction {\r\n    private _args: IExprInstruction[];\r\n\r\n    // Returns true if it is user-defined array.\r\n    private _isArray: boolean; // todo: remove\r\n\r\n    constructor({ type, args = [], ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_InitExpr, type, ...settings });\r\n\r\n        this._isArray = false;\r\n        this._args = args.map(arg => Instruction.$withParent(arg, this));\r\n\r\n        // if (!this.optimizeForVariableType(type)) {\r\n        //     context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n        //     return null;\r\n        // }\r\n    }\r\n\r\n\r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this._isArray;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = '';\r\n\r\n        if (!isNull(this.type)) {\r\n            code += this.type.toCode();\r\n        }\r\n        code += \"(\";\r\n\r\n        for (let i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        let bConst: boolean;\r\n        let args: IExprInstruction[] = <IExprInstruction[]>this.args;\r\n\r\n        for (let i: number = 0; i < args.length; i++) {\r\n            if (!args[i].isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param type The type of the variable for which the initializer was created.\r\n     */\r\n    // TODO: move it to Analysis.ts\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean {\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        if ((type.isNotBaseArray() && type.scope.type <= EScopeType.k_Global) ||\r\n            (type.isArray() && this.args.length > 1)) {\r\n\r\n            if (type.length === instruction.UNDEFINE_LENGTH ||\r\n                (type.isNotBaseArray() && this.args.length !== type.length) ||\r\n                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {\r\n                return false;\r\n            }\r\n\r\n            if (type.isNotBaseArray()) {\r\n                this._isArray = true;\r\n            }\r\n\r\n            let arrayElementType = <IVariableTypeInstruction>type.arrayElementType;\r\n            let isOk = false;\r\n            let testedInstruction: IExprInstruction = null;\r\n\r\n            for (let i = 0; i < this.args.length; i++) {\r\n                testedInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (testedInstruction.instructionType === EInstructionTypes.k_InitExpr) {\r\n                    isOk = (<IInitExprInstruction>testedInstruction).optimizeForVariableType(arrayElementType);\r\n                    if (!isOk) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    if (SystemScope.isSamplerType(arrayElementType)) {\r\n                        if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        isOk = testedInstruction.type.isEqual(arrayElementType);\r\n                        if (!isOk) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n        else {\r\n            let firstInstruction = <IExprInstruction>this.args[0];\r\n\r\n            if (this.args.length === 1 &&\r\n                firstInstruction.instructionType !== EInstructionTypes.k_InitExpr) {\r\n\r\n                if (SystemScope.isSamplerType(type)) {\r\n                    if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (firstInstruction.type.isEqual(type)) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (this.args.length === 1) {\r\n                return false;\r\n            }\r\n\r\n            let args = <IInitExprInstruction[]>this.args;\r\n            let fieldNameList = type.fieldNames;\r\n\r\n            for (let i = 0; i < args.length; i++) {\r\n                let pFieldType: IVariableTypeInstruction = type.getField(fieldNameList[i]).type;\r\n                if (!args[i].optimizeForVariableType(pFieldType)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        if (!this.isConst()) {\r\n            this._evalResult = null;\r\n            return false;\r\n        }\r\n\r\n        let res: any = null;\r\n\r\n        if (this._isArray) {\r\n            res = new Array(this.args.length);\r\n\r\n            for (let i: number = 0; i < this.args.length; i++) {\r\n                let evalInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (evalInstruction.evaluate()) {\r\n                    res[i] = evalInstruction.getEvalValue();\r\n                }\r\n            }\r\n        }\r\n        else if (this.args.length === 1) {\r\n            let pEvalInstruction = (<IExprInstruction>this.args[0]);\r\n            pEvalInstruction.evaluate();\r\n            res = pEvalInstruction.getEvalValue();\r\n        }\r\n        else {\r\n            let jsTypeCtor: any = SystemScope.getExternalType(this.type);\r\n            let args: any[] = new Array(this.args.length);\r\n\r\n            if (isNull(jsTypeCtor)) {\r\n                return false;\r\n            }\r\n\r\n            try {\r\n                if (SystemScope.isScalarType(this.type)) {\r\n                    let testedInstruction: IExprInstruction = <IExprInstruction>this.args[1];\r\n                    if (this.args.length > 2 || !testedInstruction.evaluate()) {\r\n                        return false;\r\n                    }\r\n\r\n                    res = jsTypeCtor(testedInstruction.getEvalValue());\r\n                }\r\n                else {\r\n                    for (let i: number = 0; i < this.args.length; i++) {\r\n                        let testedInstruction: IExprInstruction = <IExprInstruction>this.args[i];\r\n\r\n                        if (testedInstruction.evaluate()) {\r\n                            args[i] = testedInstruction.getEvalValue();\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    res = new jsTypeCtor;\r\n                    res.set.apply(res, args);\r\n                }\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { isDef, isNull } from \"@lib/common\";\r\nimport { assert } from \"@lib/common\";\r\nimport { IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IASTDocumentFlags as EASTParsingFlags, EOperationType, EParserCode, IASTConfig, IASTDocument, IFile, IParseNode, IParser, IParseTree, IPosition, IRange, IRuleFunction, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { DiagnosticException, Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { Lexer } from \"./Lexer\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { END_SYMBOL, ERROR, UNKNOWN_TOKEN } from \"./symbols\";\r\nimport { extendRange } from \"./util\";\r\n\r\nexport enum EParsingErrors {\r\n    SyntaxUnknownError = 2051,\r\n    SyntaxUnexpectedEOF,\r\n    SyntaxRecoverableStateNotFound,\r\n\r\n    GeneralCouldNotReadFile = 2200,\r\n    GeneralParsingLimitIsReached\r\n};\r\n\r\n\r\n\r\nexport class ParsingDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Parsing diagnostics\", 'P');\r\n    }\r\n\r\n\r\n    protected resolveFilename(code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(code: number, desc: IMap<any>): IRange {\r\n        switch (code) {\r\n            case EParsingErrors.SyntaxUnknownError:\r\n            case EParsingErrors.SyntaxUnexpectedEOF:\r\n                return desc.token.loc;\r\n            case EParsingErrors.GeneralCouldNotReadFile:\r\n                return desc.loc;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(code: number, desc: IMap<any>): IPosition {\r\n        console.assert(code != EParsingErrors.SyntaxUnknownError);\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParsingErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"Line: {token.loc.start.line}. Column: {token.loc.start.column}.\",\r\n            [EParsingErrors.SyntaxUnexpectedEOF]: \"Syntax error. Unexpected EOF.\",\r\n            [EParsingErrors.GeneralCouldNotReadFile]: \"Could not read file '{target}'.\",\r\n            [EParsingErrors.GeneralParsingLimitIsReached]: \"Parsing limit is reached.\",\r\n            [EParsingErrors.SyntaxRecoverableStateNotFound]: \"Recoverable state not found.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nfunction cloneToken(token: IToken): IToken {\r\n    return {\r\n        ...token,\r\n        loc: {\r\n            start: { ...token.loc.start },\r\n            end: { ...token.loc.end }\r\n        }\r\n    };\r\n}\r\n\r\n\r\n// class Context {\r\n//     allowErrorRecoverty: boolean = true;\r\n//     developerMode: boolean = false;\r\n\r\n//     lexer: Lexer;\r\n//     diagnostics: ParsingDiagnostics;\r\n//     knownTypes: Set<string>;\r\n//     ruleFunctions: Map<string, IRuleFunction>;\r\n    \r\n//     stack: number[] = [0];\r\n\r\n\r\n//     constructor() {\r\n//         this.diagnostics = new ParsingDiagnostics;\r\n//     }\r\n\r\n//     readToken() {\r\n//         return this.lexer.getNextToken();\r\n//     }\r\n\r\n\r\n//     private error(code: number, token: IToken) {\r\n//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n\r\n//     private critical(code: number, token: IToken = null) {\r\n//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n// }\r\n\r\n\r\nexport class ASTDocument implements IASTDocument {\r\n    protected parser: IParser;\r\n    protected knownTypes: Set<string>;\r\n    protected ruleFunctions: Map<string, IRuleFunction>;\r\n\r\n    protected diag: ParsingDiagnostics;\r\n    protected tree: IParseTree;\r\n    protected stack: number[];\r\n    protected lexer: Lexer;\r\n    protected token: IToken;\r\n\r\n    constructor(config: IASTConfig) {\r\n        assert(config.parser, 'parser engine is not defined');\r\n        this.init(config);\r\n    }\r\n\r\n    protected init({ parser, knownTypes = new Set(), ruleFunctions = new Map }: IASTConfig) {\r\n        const lexerEngine = parser.lexerEngine;\r\n\r\n        this.parser = parser;\r\n        this.knownTypes = knownTypes;\r\n        this.ruleFunctions = ruleFunctions;\r\n        this.lexer = new Lexer({\r\n            engine: lexerEngine,\r\n            knownTypes\r\n        });\r\n    }\r\n\r\n\r\n    get uri(): string {\r\n        return this.lexer.uri.toString();\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let lexerReport = this.lexer.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([lexerReport, parserReport]);\r\n    }\r\n\r\n    get root(): IParseNode {\r\n        return this.tree.root;\r\n    }\r\n\r\n\r\n    async parse(textDocument: ITextDocument, flags: number = EASTParsingFlags.k_Optimize): Promise<EParserCode> {\r\n        const developerMode = bf.testAll(flags, EASTParsingFlags.k_DeveloperMode);\r\n        const allowErrorRecoverty = true;\r\n        const optimizeTree = bf.testAll(flags, EASTParsingFlags.k_Optimize);\r\n\r\n        this.diag = new ParsingDiagnostics;\r\n        this.tree = new ParseTree(optimizeTree);\r\n        this.stack = [0];\r\n        this.lexer.setup(textDocument);\r\n        this.token = this.readToken();\r\n\r\n        if (this.token.value === END_SYMBOL) {\r\n            return EParserCode.k_Ok;\r\n        }\r\n\r\n        await this.run({ developerMode, allowErrorRecoverty });\r\n\r\n        // clear context\r\n\r\n        // this.stack = null;\r\n        // this.lexer = null;\r\n        // this.token = null;\r\n        // diag\r\n        // tree\r\n\r\n        // end of clear\r\n\r\n        if (this.diag.hasErrors()) {\r\n            console.error('parsing was ended with errors.');\r\n            return EParserCode.k_Error;\r\n        }\r\n\r\n        return EParserCode.k_Ok;\r\n    }\r\n\r\n\r\n    protected readToken(): IToken {\r\n        return this.lexer.getNextToken();\r\n    }\r\n\r\n    \r\n    protected emitError(code: number, token: IToken) {\r\n        this.diag.error(code, { ...this.lexer.getLocation(), token });\r\n    }\r\n\r\n    \r\n    protected emitCritical(code: number, token: IToken = null) {\r\n        this.diag.critical(code, { ...this.lexer.getLocation(), token });\r\n    }\r\n\r\n\r\n    private restoreState(syntaxTable: ISyntaxTable, parseTree: ParseTree, stack: number[], causingErrorToken: IToken, errorToken: IToken) {\r\n        while (true) {\r\n            let recoverableState = -1;\r\n            for (let i = stack.length - 1; i >= 0; --i) {\r\n                const errorOp = syntaxTable[stack[i]][ERROR];\r\n                const isRecoverableState = (isDef(errorOp) &&\r\n                    errorOp.type === EOperationType.k_Shift &&\r\n                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);\r\n                if (isRecoverableState) {\r\n                    recoverableState = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (recoverableState !== -1) {\r\n                const recoveredStateIndex = stack[recoverableState];\r\n                // current op will be: syntaxTable[recoveredStateIndex][ERROR];\r\n\r\n                let stackDiff = stack.length - 1 - recoverableState;\r\n                while (stackDiff != 0) {\r\n                    // extend error token location with the already processed tokens\r\n                    parseTree.$pop(errorToken.loc);\r\n                    stack.pop();\r\n                    stackDiff--;\r\n                }\r\n\r\n                // recoverable state found so continue normal processing as it would be before the error\r\n                return recoveredStateIndex;\r\n            }\r\n\r\n            extendRange(errorToken.loc, causingErrorToken.loc);\r\n\r\n            if (causingErrorToken.value === END_SYMBOL) {\r\n                // state cant be recovered\r\n                break;\r\n            }\r\n\r\n            // try to restore from the next token\r\n            // FIXME: \r\n            const nextToken = this.readToken();\r\n            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    \r\n    private async operationAdditionalAction(stateIndex: number, grammarSymbol: string): Promise<EOperationType> {\r\n        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);\r\n        if (!isNull(funcName)) {\r\n            assert(!!this.ruleFunctions.has(funcName));\r\n            return await this.ruleFunctions.get(funcName)();\r\n        }\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private async run({ developerMode = false, allowErrorRecoverty = true }): Promise<void> {\r\n\r\n        const { syntaxTable } = this.parser;\r\n        const { stack, tree } = this;\r\n\r\n        const undefinedToken: IToken = { index: -1, name: null, value: null };\r\n        let causingErrorToken: IToken = undefinedToken;\r\n\r\n        // debug mode\r\n        const opLimit = 10000;\r\n        let opCounter = 0;\r\n\r\n        try {\r\n            breakProcessing:\r\n            while (true) {\r\n                // global recursion prevention in debug mode\r\n                if (developerMode) {\r\n                    if (opCounter > opLimit) {\r\n                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);\r\n                    }\r\n                    opCounter++;\r\n                }\r\n\r\n                let currStateIndex = stack[stack.length - 1];\r\n                let op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                if (allowErrorRecoverty) {\r\n                    if (!op) {\r\n                        // recursion prevention\r\n                        if (causingErrorToken.index !== this.token.index) {\r\n                            if (this.token.value === END_SYMBOL) {\r\n                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);\r\n                            } else {\r\n                                this.emitError(EParsingErrors.SyntaxUnknownError, this.token);\r\n                            }\r\n                        } else {\r\n                            // one more attempt to recover but from the next token\r\n                            this.token = this.readToken();\r\n                            // NOTE: in order to prevent recusrion on END_SYMBOL\r\n                            causingErrorToken = undefinedToken;\r\n                            continue;\r\n                        }\r\n\r\n                        causingErrorToken = cloneToken(this.token);\r\n                        // token = { ...token, name: ERROR };\r\n                        this.token = { ...cloneToken(this.token), name: ERROR };\r\n                    }\r\n\r\n                    op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                    const errorProcessing = this.token.name === ERROR;\r\n                    const errorReductionEnded = !op || (errorProcessing && (op.type === EOperationType.k_Shift));\r\n\r\n                    // state must be recovered if operation is undefined or error reduction was ended. \r\n                    if (errorReductionEnded) {\r\n                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. \r\n                        let recoveryToken = cloneToken(causingErrorToken);\r\n                        while (recoveryToken.name === UNKNOWN_TOKEN) {\r\n                            recoveryToken = this.readToken();\r\n                        }\r\n                        currStateIndex = this.restoreState(syntaxTable, <ParseTree>tree, stack, recoveryToken, this.token /* error token */);\r\n                        if (currStateIndex === -1) {\r\n                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);\r\n                        }\r\n\r\n                        // perform error shift op.\r\n                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'\r\n                        stack.push(op.stateIndex);\r\n                        tree.addToken(this.token/* error token */);\r\n                        this.token = recoveryToken;\r\n\r\n                        // const nextOp = syntaxTable[op.stateIndex][token.name];\r\n                        // if (nextOp.type === EOperationType.k_Reduce) {\r\n                        //     tokenBuffer.push(rec);\r\n                        // }\r\n\r\n                        // return to normal precesing loop\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isDef(op)) {\r\n                    switch (op.type) {\r\n                        case EOperationType.k_Success:\r\n                            break breakProcessing;\r\n\r\n                        case EOperationType.k_Shift:\r\n                            {\r\n                                const stateIndex = op.stateIndex;\r\n                                stack.push(stateIndex);\r\n                                tree.addToken(this.token);\r\n\r\n                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, this.token.name);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                } else if (additionalOperationCode === EOperationType.k_Ok) {\r\n                                    this.token = this.readToken();\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case EOperationType.k_Reduce:\r\n                            {\r\n                                const ruleLength = op.rule.right.length;\r\n                                stack.length -= ruleLength;\r\n\r\n                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;\r\n\r\n                                stack.push(stateIndex);\r\n                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));\r\n\r\n                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, op.rule.left);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    assert(!allowErrorRecoverty, `unexpected end, something went wrong :/`);\r\n                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                }\r\n            }\r\n\r\n            tree.finishTree();\r\n        } catch (e) {\r\n            if (!(e instanceof DiagnosticException)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import * as Autotests from '@lib/fx/autotests';\r\n/* tslint:disable:max-func-body-length */\r\n/* tslint:disable:typedef */\r\n/* tslint:disable:no-single-line-block-comment */\r\n\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport { IInstruction } from '@lib/idl/IInstruction';\r\nimport { IParseNode, IRange } from '@lib/idl/parser/IParser';\r\nimport { mapActions, sourceCode as sourceActions } from '@sandbox/actions';\r\nimport { ASTView, FileListView, IWithStyles, MemoryView, ProgramView } from '@sandbox/components';\r\nimport { BytecodeView, ParserParameters, Playground, ShaderTranslatorView, SourceEditor2 } from '@sandbox/containers';\r\nimport { getCommon, mapProps } from '@sandbox/reducers';\r\nimport { history } from '@sandbox/reducers/router';\r\nimport { filterPartFx, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport autobind from 'autobind-decorator';\r\nimport { routerActions } from 'connected-react-router';\r\nimport * as path from 'path';\r\nimport * as React from 'react';\r\nimport injectSheet from 'react-jss';\r\nimport { connect } from 'react-redux';\r\nimport { matchPath, NavLink, Route, RouteComponentProps, Switch, withRouter } from 'react-router-dom';\r\nimport { Button, Checkbox, Container, Dropdown, Grid, Icon, Input, Loader, Menu, Message, Popup, Segment, Sidebar, Tab, Table } from 'semantic-ui-react';\r\n\r\ndeclare const VERSION: string;\r\ndeclare const COMMITHASH: string;\r\ndeclare const BRANCH: string;\r\ndeclare const MODE: string;\r\ndeclare const TIMESTAMP: string;\r\n\r\n// const DEFAULT_FX_NAME = `./assets/fx/tests/new`;\r\n\r\ntype UnknownIcon = any;\r\n\r\nexport const styles = {\r\n    sidebarLeftHotfix: {\r\n        width: `79px !important`,\r\n        backgroundColor: '#1e1e1e !important'\r\n    },\r\n    mainContentHotfix: {\r\n        marginLeft: `calc(79px)`\r\n    },\r\n    mainViewHeightHotfix: {\r\n        marginBottom: '0 !important'\r\n    },\r\n    fileBrowserSidebarFix: {\r\n        padding: '10px !important',\r\n        background: 'rgba(255,255,255,0.95) !important'\r\n    },\r\n    containerMarginFix: {\r\n        border: '0px !important',\r\n        padding: '0 !important'\r\n    },\r\n    topMenuFix: {\r\n        '& > div:first-child': {\r\n            marginBottom: '0',\r\n            position: 'relative',\r\n            zIndex: '2',\r\n            // boxShadow: '0 2px 5px rgba(10,10,10, 0.1) !important',\r\n            backgroundColor: 'white !important'\r\n        },\r\n\r\n        '& > .menu:first-child': {\r\n            '& .item': {\r\n                '&.active': {\r\n                    border: '0 !important'\r\n                }\r\n            }\r\n        }\r\n    },\r\n    rightColumnFix: {\r\n        // boxShadow: '-5px 0 5px black',\r\n        zIndex: 1,\r\n        paddingLeft: '0 !important',\r\n        backgroundColor: 'white',\r\n        '& > .container': {\r\n            paddingTop: '15px'\r\n        }\r\n    },\r\n    leftColumnFix: {\r\n        paddingRight: '0px !important'\r\n    },\r\n    versionFix: {\r\n        padding: '5px !important',\r\n        margin: '-5px !important'\r\n    },\r\n\r\n    tabHeaderFix: {\r\n        marginTop: 0,\r\n        boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.075)'\r\n    },\r\n\r\n    //\r\n    // SourceCodeMenu\r\n    //\r\n\r\n    mebFix: {\r\n        background: '#1e1e1e !important',\r\n        position: 'relative',\r\n        zIndex: 1,\r\n        height: 'auto !important',\r\n        minHeight: 'auto !important',\r\n\r\n        '& .item': {\r\n            opacity: '0.6 !important',\r\n            alignSelf: 'baseline !important',\r\n            paddingRight: '0 !important',\r\n            paddingTop: '5px !important',\r\n            paddingBottom: '5px !important',\r\n\r\n            '&:not(:first-child)': {\r\n                paddingLeft: '0 !important',\r\n            },\r\n\r\n            '&.active': {\r\n                border: '0 !important',\r\n                opacity: '0.75 !important',\r\n                fontWeight: 'normal !important'\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\n// todo: remove the inheritance of the type of data\r\nexport interface IAppProps extends IStoreState, IWithStyles<typeof styles>, RouteComponentProps<any> {\r\n    actions: typeof sourceActions & typeof routerActions;\r\n}\r\n\r\n\r\nconst Version = (props) => {\r\n    return (\r\n        <Popup\r\n            trigger={\r\n                <div>\r\n                    <Message warning={MODE !== 'production'} size='tiny' compact className={props.classes.versionFix}>\r\n                        {MODE !== 'production' && <Icon name={'issue opened' as UnknownIcon} />}{MODE} | {BRANCH}-{VERSION}\r\n                    </Message>\r\n                </div>\r\n            }\r\n            // position='left center'\r\n            size='small'\r\n            content={TIMESTAMP}\r\n            inverted\r\n        />\r\n    );\r\n};\r\n\r\ninterface ISourceCodeMenuProps extends IWithStyles<typeof styles> {\r\n    path: {\r\n        name?: string;\r\n        pass?: string;\r\n        property?: string;\r\n    };\r\n}\r\n\r\n@injectSheet(styles)\r\nclass SourceCodeMenu extends React.Component<ISourceCodeMenuProps> {\r\n    state = { activeItem: 'vertexshader' };\r\n\r\n    handleItemClick = (e, { name }) => this.setState({ activeItem: name })\r\n\r\n    render() {\r\n        const { state: { activeItem }, props: { path } } = this;\r\n\r\n        return (\r\n            <Menu size='mini' pointing secondary inverted attached className={this.props.classes.mebFix}>\r\n                <Menu.Item\r\n                    name='sourcecode'\r\n                    // position='right'\r\n                    active={activeItem === 'sourcecode'}\r\n                    onClick={this.handleItemClick}\r\n                >\r\n                    source code <Icon name={'chevron right' as any} />\r\n                </Menu.Item>\r\n\r\n                <Menu.Item\r\n                    name='vertexshader'\r\n                    // position='right'\r\n                    active={activeItem === 'vertexshader'}\r\n                    onClick={this.handleItemClick}\r\n                >\r\n                    {path.name &&\r\n                        <div>\r\n                            {path.name} < Icon name={'chevron right' as any} />\r\n                        </div>\r\n                    }\r\n                    {path.pass &&\r\n                        <div>\r\n                            {`pass[${path.pass}]`} < Icon name={'chevron right' as any} />\r\n                        </div>\r\n                    }\r\n                    {path.property &&\r\n                        <div>\r\n                            {path.property}\r\n                        </div>\r\n                    }\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n@injectSheet(styles)\r\n@(withRouter as any) // << NOTE: known issue with TS decorators :/\r\nclass App extends React.Component<IAppProps> {\r\n\r\n    state: {\r\n        showFileBrowser: boolean;\r\n        testProcessing: boolean;\r\n    };\r\n\r\n    private expressionRef = React.createRef<Input>();\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            showFileBrowser: false,\r\n            testProcessing: false\r\n        };\r\n    }\r\n\r\n\r\n    static getDerivedStateFromProps(props: IAppProps, state) {\r\n        const nextAnalysis = props.sourceFile.slDocument;\r\n        const contentChanged = !(state.prevAnalysis === nextAnalysis);\r\n        let stateDiff = null;\r\n\r\n        if (contentChanged) {\r\n            stateDiff = { prevAnalysis: nextAnalysis };\r\n        }\r\n\r\n        return stateDiff;\r\n    }\r\n\r\n\r\n    handleShowFileBrowser = () => this.setState({ showFileBrowser: !this.state.showFileBrowser });\r\n    hideFileBrowser = () => this.setState({ showFileBrowser: false });\r\n\r\n\r\n\r\n    @autobind\r\n    async runAutotests() {\r\n        this.setState({ testProcessing: true });\r\n\r\n        // timeout for playing animation in UI\r\n        setTimeout(async () => {\r\n            const { content: source, uri } = getFileState(this.props);\r\n            const autotests = await Autotests.parse({ source, uri });\r\n\r\n            await Autotests.run(autotests);\r\n\r\n            if (!autotests.passed) {\r\n                console.warn(autotests);\r\n            }\r\n\r\n            autotests.tests.forEach((test, iTest) => {\r\n                const testName = `${test.name}-${iTest}`;\r\n                this.highlightTest(test.name, test.loc, false);\r\n                this.highlightTest(test.name, test.loc, true, test.passed);\r\n\r\n                test.cases.forEach((exam, iExam) => {\r\n                    const examName = `${testName}-${iExam}`;\r\n                    this.highlightTest(examName, exam.loc, false);\r\n                    this.highlightTest(examName, exam.loc, true, exam.passed, exam.note);\r\n                });\r\n            });\r\n\r\n            this.setState({ testProcessing: false });\r\n        }, 10);\r\n    }\r\n\r\n    @autobind\r\n    compile() {\r\n        const { state, props, expressionRef } = this;\r\n\r\n        // fixme: kinda hack!\r\n        const input: HTMLInputElement = (expressionRef.current as any).inputRef.current;\r\n        props.actions.compile(input.value || null);\r\n    }\r\n\r\n\r\n    setAutocompile(autocompile: boolean) {\r\n        this.props.actions.specifyOptions({ autocompile });\r\n    }\r\n\r\n    setBytecodeColorization(colorize: boolean) {\r\n        this.props.actions.specifyOptions({ colorize });\r\n    }\r\n\r\n    resolveLocation(src: IRange): IRange {\r\n        const file = getFileState(this.props);\r\n        const uri = file.uri;\r\n        const slastDocument = file.slastDocument;\r\n\r\n        if (!slastDocument) {\r\n            return null;\r\n        }\r\n\r\n        const includes = slastDocument.includes;\r\n\r\n        let dst = src;\r\n        while (dst && String(uri) !== String(dst.start.file)) {\r\n            dst = includes.get(String(dst.start.file));\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /** @deprecated */\r\n    highlightTest(testName: string, loc: IRange, show: boolean = true, passed?: boolean, tooltip?: string) {\r\n        const name = `autotest-${testName}`;\r\n        if (show) {\r\n            const range = this.resolveLocation(loc);\r\n            const color = passed ? 10 : 14;\r\n            this.props.actions.addMarker({ name, range, type: `line`, payload: { color } });\r\n            if (!passed && tooltip) {\r\n                this.props.actions.addMarker({ name: `${name}-error`, range, type: `error`, payload: { color }, tooltip });\r\n            }\r\n        } else {\r\n            this.props.actions.removeMarker(`${name}`);\r\n            this.props.actions.removeMarker(`${name}-error`);\r\n        }\r\n    }\r\n\r\n    /** @deprecated */\r\n    highlightInstruction(inst: IInstruction, show: boolean = true) {\r\n        const markerName = `ast-range-${inst.instructionID}`;\r\n        if (show) {\r\n            const range = this.resolveLocation(inst.sourceNode.loc);\r\n            this.props.actions.addMarker({\r\n                name: markerName,\r\n                range,\r\n                type: `marker`\r\n            });\r\n        } else {\r\n            this.props.actions.removeMarker(markerName);\r\n        }\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    highlightPNode(id: string, pnode: IParseNode = null, show: boolean = true) {\r\n        if (show) {\r\n            const range = this.resolveLocation(pnode.loc);\r\n            this.props.actions.addMarker({\r\n                name: `ast-range-${id}`,\r\n                range,\r\n                type: 'marker'\r\n            })\r\n        } else {\r\n            this.props.actions.removeMarker(`ast-range-${id}`);\r\n        }\r\n    }\r\n\r\n\r\n    canCompile(): boolean {\r\n        const { sourceFile } = this.props;\r\n        return sourceFile.slDocument && sourceFile.slDocument.diagnosticReport.errors === 0;\r\n    }\r\n\r\n\r\n    buildShaderMenu(): { name: string; link: string }[] {\r\n        const props = this.props;\r\n        const file = getFileState(props);\r\n        const list = filterPartFx(getScope(file));\r\n\r\n        if (!file.uri) {\r\n            return [];\r\n        }\r\n\r\n        const links: string[] = [];\r\n        const basepath = `/playground/${path.basename(file.uri)}`;\r\n        for (const fx of list) {\r\n            links.push(`${fx.name}`);\r\n            links.push(...fx.passList\r\n                .filter(pass => !!pass.vertexShader)\r\n                .map((pass, i) => `${fx.name}/${pass.name || i}/VertexShader`));\r\n            links.push(...fx.passList\r\n                .filter(pass => !!pass.pixelShader)\r\n                .map((pass, i) => `${fx.name}/${pass.name || i}/PixelShader`));\r\n        }\r\n        return links.map(name => ({ name, basepath, link: `${basepath}/${name}` }));\r\n    }\r\n\r\n\r\n    render() {\r\n        const { props, state, props: { sourceFile } } = this;\r\n        const $debugger = sourceFile.debugger;\r\n\r\n        // console.log(props.match.params);\r\n        // console.log(`/${props.match.params.view}/${props.match.params.fx}`);\r\n\r\n        // console.log(JSON.stringify(props.match, null, '\\t'));\r\n\r\n        const showAutotestMenu = (sourceFile.content || '').substr(0, 40).indexOf('@autotests') !== -1;\r\n\r\n        const analysisResults = [\r\n            {\r\n                menuItem: {\r\n                    as: NavLink,\r\n                    content: (<Menu.Header>Playground</Menu.Header>),\r\n                    to: `/playground/${props.match.params.fx}`,\r\n                    // exact: true,\r\n                    key: 'playground'\r\n                },\r\n                pane: (\r\n                    <Route path='/playground'>\r\n                        {/* <Header as='h5' textAlign='right' mini block attached={ 'top' } style={ { marginTop: 0 } }>\r\n                            Playground\r\n                        </Header> */}\r\n                        <Menu secondary borderless attached={'top'} className={props.classes.tabHeaderFix}>\r\n                            <Dropdown item icon='gear' simple>\r\n                                <Dropdown.Menu>\r\n                                    {\r\n                                        this.buildShaderMenu().map(item => (\r\n                                            <Dropdown.Item\r\n                                                as={NavLink}\r\n                                                to={item.link} >\r\n                                                {item.name}\r\n                                            </Dropdown.Item>\r\n                                        ))\r\n                                    }\r\n                                </Dropdown.Menu>\r\n                            </Dropdown>\r\n                            <Menu.Menu position='right'>\r\n                                <div className='ui right aligned category search item'>\r\n                                    Playground\r\n                                </div>\r\n                            </Menu.Menu>\r\n                        </Menu>\r\n                        <Tab.Pane attached={'bottom'} key='playground-view'>\r\n                            <Playground />\r\n                        </Tab.Pane>\r\n                    </Route>\r\n                )\r\n            },\r\n            {\r\n                menuItem: {\r\n                    as: NavLink,\r\n                    content: (<Menu.Header>Bytecode<br />Debugger</Menu.Header>),\r\n                    to: `/bytecode/${props.match.params.fx}`,\r\n                    // exact: true,\r\n                    key: 'bytecode'\r\n                },\r\n                pane: (\r\n                    <Route path='/bytecode'>\r\n                        {/* <Header as='h5' textAlign='right' mini block attached={ 'top' } style={ { marginTop: 0 } }>\r\n                            Bytecode Debugger\r\n                        </Header> */}\r\n                        <Menu secondary borderless attached={'top'} className={props.classes.tabHeaderFix}>\r\n                            <Menu.Menu position='right'>\r\n                                <div className='ui right aligned category search item'>\r\n                                    Bytecode Debugger\r\n                                </div>\r\n                            </Menu.Menu>\r\n                        </Menu>\r\n                        <Tab.Pane attached={'bottom'} key='bytecode-view'>\r\n                            {showAutotestMenu &&\r\n                                <Segment color='orange'>\r\n                                    {!this.state.testProcessing &&\r\n                                        <Button\r\n                                            onClick={this.runAutotests} width={'100%'} >\r\n                                            <span>Run autotests!</span>\r\n                                        </Button>\r\n                                    }\r\n                                    {this.state.testProcessing &&\r\n                                        <Loader active inline />\r\n                                    }\r\n                                </Segment>\r\n                            }\r\n                            <Table size='small' basic='very' compact='very'>\r\n                                <Table.Body>\r\n                                    <Table.Row style={{ paddingTop: 0 }}>\r\n                                        <Table.Cell>\r\n                                            <Input\r\n                                                fluid\r\n                                                size='small'\r\n                                                label='expression'\r\n                                                placeholder={`${Bytecode.DEFAULT_ENTRY_POINT_NAME}()`}\r\n                                                ref={this.expressionRef}\r\n                                            />\r\n                                        </Table.Cell>\r\n                                        <Table.Cell >\r\n                                            <Button\r\n                                                disabled={($debugger.options.autocompile || !this.canCompile())}\r\n                                                onClick={this.compile} width={10} >\r\n                                                Compile\r\n                                            </Button>\r\n                                            &nbsp;\r\n                                            <Dropdown text='Options' pointing='left' >\r\n                                                <Dropdown.Menu>\r\n                                                    <Dropdown.Item>\r\n                                                        <Checkbox label='auto compilation' size='small'\r\n                                                            checked={$debugger.options.autocompile}\r\n                                                            onMouseDown={\r\n                                                                e => this.setAutocompile(!$debugger.options.autocompile)\r\n                                                            } />\r\n                                                    </Dropdown.Item>\r\n                                                    <Dropdown.Item>\r\n                                                        <Checkbox disabled label='no optimisations' size='small' checked />\r\n                                                    </Dropdown.Item>\r\n                                                    <Dropdown.Item>\r\n                                                        <Checkbox label='colorize' size='small'\r\n                                                            checked={$debugger.options.colorize}\r\n                                                            onMouseDown={\r\n                                                                e => this.setBytecodeColorization(!$debugger.options.colorize)\r\n                                                            } />\r\n                                                    </Dropdown.Item>\r\n                                                </Dropdown.Menu>\r\n                                            </Dropdown>\r\n                                            {/* <NoOptimizations /> */}\r\n                                        </Table.Cell>\r\n                                    </Table.Row>\r\n                                </Table.Body>\r\n                            </Table>\r\n                            {$debugger.runtime ? (\r\n                                <div>\r\n                                    {/* todo: move memory view inside bytecode view; */}\r\n                                    <MemoryView program={$debugger.runtime} />\r\n                                    <BytecodeView />\r\n                                </div>\r\n                            ) : null}\r\n                        </Tab.Pane>\r\n                    </Route>\r\n                )\r\n            },\r\n            {\r\n                menuItem: {\r\n                    as: NavLink,\r\n                    content: <Menu.Header>Semantic<br />Analyzer</Menu.Header>,\r\n                    to: `/program/${props.match.params.fx}`,\r\n                    // exact: true,\r\n                    key: 'program'\r\n                },\r\n                pane: (\r\n                    <Route path='/program'>\r\n                        <Menu secondary borderless attached={'top'} className={props.classes.tabHeaderFix}>\r\n                            <Menu.Menu position='right'>\r\n                                <div className='ui right aligned category search item'>\r\n                                    Semantic Analisys\r\n                                </div>\r\n                            </Menu.Menu>\r\n                        </Menu>\r\n                        <Tab.Pane attached={'bottom'} key='program-view'>\r\n                            <ProgramView\r\n                                onNodeOver={inst => this.highlightInstruction(inst, true)}\r\n                                onNodeOut={inst => this.highlightInstruction(inst, false)}\r\n                                onNodeClick={inst => { }}\r\n                            />\r\n                        </Tab.Pane>\r\n                    </Route>\r\n                )\r\n            },\r\n            {\r\n                menuItem: {\r\n                    as: NavLink,\r\n                    content: <Menu.Header>Syntax<br />Analyzer</Menu.Header>,\r\n                    to: `/ast/${props.match.params.fx}`,\r\n                    // exact: true,\r\n                    key: 'ast'\r\n                },\r\n                pane: (\r\n                    <Route path='/ast'>\r\n                        {/* <Header as='h5' textAlign='right' mini block attached={ 'top' } style={ { marginTop: 0 } }>\r\n                            Syntax Analysis\r\n                        </Header> */}\r\n                        <Menu secondary borderless attached={'top'} className={props.classes.tabHeaderFix}>\r\n                            <Menu.Menu position='right'>\r\n                                <div className='ui right aligned category search item'>\r\n                                    Syntax Analysis\r\n                                </div>\r\n                            </Menu.Menu>\r\n                        </Menu>\r\n                        <Tab.Pane attached={'bottom'} key='ast-view'>\r\n                            <ASTView\r\n                                onNodeOver={(idx, node) => this.highlightPNode(idx, node, true)}\r\n                                onNodeOut={idx => this.highlightPNode(idx, null, false)}\r\n                            />\r\n                        </Tab.Pane>\r\n                    </Route>\r\n                )\r\n            }\r\n        ];\r\n\r\n        const defaultActiveIndex = analysisResults.findIndex(pane => {\r\n            return !!matchPath(window.location.pathname, {\r\n                path: pane.menuItem.to,\r\n                exact: false\r\n            });\r\n        });\r\n\r\n        const panes = [\r\n            {\r\n                menuItem: (\r\n                    <Menu.Item>\r\n                        Source File\r\n                        <span style={{ fontWeight: 'normal', color: 'rgba(0, 0, 0, 0.6)' }}>\r\n                            &nbsp;|&nbsp;{path.basename(props.sourceFile.uri || '')}\r\n                        </span>\r\n                    </Menu.Item>\r\n                ),\r\n                render: () => (\r\n                    <Tab.Pane key='source' className={`${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}`}>\r\n                        <Grid divided={false}>\r\n                            <Grid.Row columns={2}>\r\n                                <Grid.Column computer='10' tablet='8' mobile='6' className={props.classes.leftColumnFix}>\r\n                                    <SourceCodeMenu path={props.match.params} />\r\n                                    <Switch>\r\n                                        {/* TODO: sync all pathes with business logic */}\r\n                                        <Route path='/playground/:fx/:name/:pass/(vertexshader|pixelshader)'>\r\n                                            <ShaderTranslatorView name='shader-translator-view' />\r\n                                        </Route>\r\n                                        <Route path='/playground/:fx/:name'>\r\n                                            <ShaderTranslatorView name='shader-translator-view' />\r\n                                        </Route>\r\n                                        <Route exact path='/playground/:fx'>\r\n                                            <SourceEditor2 name='source-code' />\r\n                                        </Route>\r\n                                        <Route exact path='/bytecode/:fx'>\r\n                                            <SourceEditor2 name='source-code' />\r\n                                        </Route>\r\n                                        <Route exact path='/program/:fx'>\r\n                                            <SourceEditor2 name='source-code' />\r\n                                        </Route>\r\n                                        <Route exact path='/ast/:fx'>\r\n                                            <SourceEditor2 name='source-code' />\r\n                                        </Route>\r\n                                    </Switch>\r\n                                </Grid.Column>\r\n                                <Grid.Column computer='6' tablet='8' mobile='10' className={props.classes.rightColumnFix}>\r\n                                    <Container>\r\n                                        <Tab\r\n                                            defaultActiveIndex={defaultActiveIndex}\r\n                                            menu={{ attached: false, secondary: true, pointing: false, size: 'mini' }}\r\n                                            panes={analysisResults}\r\n                                            renderActiveOnly={false} />\r\n                                    </Container>\r\n                                </Grid.Column>\r\n                            </Grid.Row>\r\n                        </Grid>\r\n                    </Tab.Pane>\r\n                )\r\n            },\r\n            {\r\n                menuItem: 'Grammar',\r\n                render: () => (\r\n                    <Tab.Pane key='grammar' className={`${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}`}>\r\n                        <ParserParameters />\r\n                    </Tab.Pane>\r\n                )\r\n            },\r\n            {\r\n                menuItem: (\r\n                    <Menu.Item key='ver' position='right' inverted disabled color='red'>\r\n                        <Version classes={props.classes} />\r\n                    </Menu.Item>),\r\n                render: () => null\r\n            }\r\n        ];\r\n\r\n        return (\r\n            <div className={props.classes.mainContentHotfix}>\r\n                <Sidebar.Pushable>\r\n                    <Sidebar\r\n                        as={Segment}\r\n                        animation='overlay'\r\n                        vertical\r\n                        visible={this.state.showFileBrowser}\r\n                        className={this.props.classes.fileBrowserSidebarFix}\r\n                    >\r\n                        <FileListView\r\n                            path='./assets/fx/tests/'\r\n                            filters={['.fx']}\r\n                            onFileClick={(file) => { history.push(`/${props.match.params.view}/${path.basename(file)}`); }} />\r\n                    </Sidebar>\r\n                    <Sidebar.Pusher dimmed={this.state.showFileBrowser}>\r\n                        {\r\n                            /*\r\n                                NOTE: \"renderActiveOnly\" should always be true\r\n                                       because only one instance of Monaco editor\r\n                                       can be used simultaneously\r\n                            */\r\n                        }\r\n                        <Tab\r\n                            menu={{ secondary: true, pointing: true }}\r\n                            panes={panes}\r\n                            renderActiveOnly={true}\r\n                            size='tiny'\r\n                            className={props.classes.topMenuFix} />\r\n                    </Sidebar.Pusher>\r\n                </Sidebar.Pushable>\r\n\r\n                <Menu vertical icon='labeled' color='black' inverted fixed='left' className={props.classes.sidebarLeftHotfix}>\r\n                    <Menu.Item name='home' onClick={this.handleShowFileBrowser} >\r\n                        <Icon name={'three bars' as UnknownIcon} />\r\n                        File Browser\r\n                        </Menu.Item>\r\n                </Menu>\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport default connect<{}, {}, IAppProps>(mapProps(getCommon), mapActions({ ...sourceActions, ...routerActions }))(App) as any;\r\n","import { assert, isDefAndNotNull, isNull, isNumber } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IVariableTypeInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n    usages?: IVariableUsage[];\r\n    arrayIndex?: IExprInstruction;\r\n    padding?: number;\r\n\r\n    readable?: boolean;\r\n    writable?: boolean;\r\n}\r\n\r\n\r\nexport class VariableTypeInstruction extends Instruction implements IVariableTypeInstruction {\r\n    protected _subType: ITypeInstruction;\r\n    protected _usageList: IVariableUsage[];\r\n\r\n    /** overrites for defautl read/write tests (for internal usage) */\r\n    protected _isWritable: boolean;\r\n    protected _isReadable: boolean;\r\n\r\n    protected _arrayIndexExpr: IExprInstruction;\r\n    protected _arrayElementType: IVariableTypeInstruction;\r\n    protected _padding: number;\r\n\r\n    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = instruction.UNDEFINE_PADDING, ...settings }: IVariableTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableType, ...settings });\r\n\r\n        type = type.$withNoParent();\r\n        this._usageList = [];\r\n\r\n        let instrType = type.instructionType;\r\n        if (instrType === EInstructionTypes.k_ProxyType ||\r\n            instrType === EInstructionTypes.k_SystemType ||\r\n            instrType === EInstructionTypes.k_ComplexType) {\r\n            this._subType = type;\r\n        }\r\n        else {\r\n            let varType = <IVariableTypeInstruction>type;\r\n            // TODO: review this code\r\n            if (!varType.isNotBaseArray()) {\r\n                this._subType = varType.subType;\r\n                varType.usages.forEach(usage => this.addUsage(usage))\r\n            }\r\n            else {\r\n                this._subType = type;\r\n            }\r\n        }\r\n\r\n        assert(isDefAndNotNull(this._subType));\r\n        assert(isDefAndNotNull(this._usageList));\r\n\r\n        this._isWritable = writable;\r\n        this._isReadable = readable;\r\n\r\n        this._arrayIndexExpr = null;\r\n        this._arrayElementType = null;\r\n        this._padding = padding;\r\n\r\n        if (arrayIndex) {\r\n            //TODO: add support for v[][10]\r\n            this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType, usages: this._usageList }), this);\r\n            this._arrayIndexExpr = Instruction.$withParent(arrayIndex, this);\r\n        }\r\n\r\n        usages.forEach(usage => this.addUsage(usage));\r\n\r\n        // todo: construct arrayElementType here! with proper usages!\r\n        // if (this.isArray()) {\r\n        //     if (isNull(this._arrayElementType)) {\r\n        //         this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType.arrayElementType, usages: this.usageList }), this);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.baseType.name;\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        if (!this._isWritable) {\r\n            return false;\r\n        }\r\n\r\n        if ((this.isArray() && !this.isBase()) || this.isUniform()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        // check for hasUsage('in') ?\r\n\r\n        return this.subType.writable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        if (!this._isReadable) {\r\n            return false;\r\n        }\r\n\r\n        if (this.hasUsage(\"out\")) {\r\n            return false;\r\n        }\r\n\r\n        return this.subType.readable;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this.subType.methods;\r\n    }\r\n\r\n\r\n    // TODO: move to helpers\r\n    get size(): number {\r\n        if (!isNull(this._arrayElementType)) {\r\n            const size = this._arrayElementType.size;\r\n            const length = this.length;\r\n            if (length === instruction.UNDEFINE_LENGTH || size === instruction.UNDEFINE_SIZE) {\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n            return size * length;\r\n        }\r\n        return this.subType.size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.subType.baseType;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        if (!this.isNotBaseArray()) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        if (this.isNotBaseArray() && isNull(this._arrayElementType)) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        // TODO: rework evaluation api!\r\n\r\n        let isEval = this._arrayIndexExpr.evaluate();\r\n\r\n        if (isEval) {\r\n            let iValue: number = <number>this._arrayIndexExpr.getEvalValue();\r\n            if (isNumber(iValue)) {\r\n                return iValue;\r\n            }\r\n        }\r\n\r\n        return instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n\r\n    get padding(): number {\r\n        return this._padding;\r\n    }\r\n\r\n\r\n    get arrayElementType(): IVariableTypeInstruction {\r\n        if (!this.isArray()) {\r\n            return null;\r\n        }\r\n\r\n        // todo: fix this.subType.arrayElementType!\r\n        return this._arrayElementType || <IVariableTypeInstruction>this.subType.arrayElementType;\r\n    }\r\n\r\n\r\n\r\n    get fieldNames(): string[] {\r\n        return this.subType.fieldNames;\r\n    }\r\n\r\n\r\n    get usages(): IVariableUsage[] {\r\n        return this._usageList;\r\n    }\r\n\r\n\r\n    get subType(): ITypeInstruction {\r\n        return this._subType;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.subType.fields;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        // TODO: fix this condition\r\n        return this.name || this.subType.toString() || type.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = \"\";\r\n        if (!isNull(this._usageList)) {\r\n            for (let i: number = 0; i < this._usageList.length; i++) {\r\n                code += this._usageList[i] + \" \";\r\n            }\r\n        }\r\n\r\n        code += this.subType.toCode();\r\n\r\n        return code;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.subType.toDeclString();\r\n    }\r\n\r\n    // todo: add explanation!\r\n    isBase(): boolean {\r\n        return this.subType.isBase() && isNull(this._arrayElementType);\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isArray();\r\n    }\r\n\r\n\r\n    // Returns true if the type is user defined array.\r\n    // like an ordinary array: int a[5]\r\n    // not a base array like: float4/int3 etc.\r\n    isNotBaseArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isNotBaseArray();\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this.subType.isComplex();\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this.subType.isContainArray();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this.subType.isContainSampler();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this.subType.isContainComplexType();\r\n    }\r\n\r\n\r\n    isUniform(): boolean {\r\n        return this.hasUsage(\"uniform\");\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.hasUsage(\"const\");\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isSampler();\r\n    }\r\n\r\n\r\n    isTexture(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isTexture();\r\n    }\r\n\r\n\r\n    isUAV(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isUAV();\r\n    }\r\n\r\n\r\n    $overwritePadding(val: number) {\r\n        this._padding = val;\r\n    }\r\n\r\n\r\n    private addUsage(usage: IVariableUsage): void {\r\n        if (!this.hasUsage(usage)) {\r\n            this._usageList.push(usage);\r\n        }\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return this.subType.hasField(fieldName);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.subType.hasFieldWithSematics(semantic);\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.subType.hasAllUniqueSemantics();\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.subType.hasFieldWithoutSemantics();\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getField(fieldName);\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.subType.getMethod(methodName, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    hasUsage(usage: IVariableUsage): boolean {\r\n        if (this._usageList.find(knownUsage => knownUsage === usage)) {\r\n            return true;\r\n        }\r\n\r\n        if (!isNull(this.subType) && this.subType.instructionType === EInstructionTypes.k_VariableType) {\r\n            return (<IVariableTypeInstruction>this.subType).hasUsage(usage);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Helpers\r\n     */\r\n\r\n\r\n    static wrap(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope });\r\n    }\r\n\r\n    static wrapAsConst(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });\r\n    }\r\n}\r\n","import { DeclInstruction, IDeclInstructionSettings } from \"@lib/fx/analisys/instructions/DeclInstruction\";\r\nimport { Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { fn, type } from \"@lib/fx/analisys/helpers\";\r\n\r\nexport interface IFunctionDefInstructionSettings extends IDeclInstructionSettings {\r\n    returnType: IVariableTypeInstruction;\r\n    id: IIdInstruction;\r\n    paramList?: IVariableDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic]\r\n * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction\r\n */\r\nexport class FunctionDefInstruction extends DeclInstruction implements IFunctionDefInstruction {\r\n    readonly params: IVariableDeclInstruction[];\r\n    readonly returnType: IVariableTypeInstruction;\r\n    \r\n    protected _id: IIdInstruction;\r\n\r\n    constructor({ returnType, id, paramList = [], ...settings }: IFunctionDefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDef, ...settings });\r\n\r\n        this.params = paramList.map(param => Instruction.$withParent(param, this));\r\n        this.returnType = Instruction.$withParent(returnType, this);\r\n        this._id = Instruction.$withParent(id, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n    \r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        let def = type.signature(this.returnType) + \" \" + this.name + \"(\";\r\n\r\n        for (let i: number = 0; i < this.params.length; i++) {\r\n            def += type.signature(this.params[i].type) + \",\";\r\n        }\r\n\r\n        def += \")\";\r\n        // TODO: add semantic\r\n        return def;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        const { _id: id, returnType, params } = this;\r\n        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;\r\n    }\r\n}\r\n","import { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\nimport { EInstructionTypes, IExprInstruction, IExprStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprStmtInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Represent expr;\r\n * EMPTY_OPERTOR ExprInstruction \r\n */\r\nexport class ExprStmtInstruction extends StmtInstruction implements IExprStmtInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr, ...settings }: IExprStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ExprStmt, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._expr.toCode() + ';';\r\n    }\r\n}\r\n","import { isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { instruction, type } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IComplexTypeInstructionSettings extends IInstructionSettings {\r\n    name?: string;\r\n    fields: IVariableDeclInstruction[]; // << todo: replace this Array<Instruction>;\r\n}\r\n\r\nexport class ComplexTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _fields: IMap<IVariableDeclInstruction>;\r\n\r\n    // helpers\r\n    protected _isContainArray: boolean;\r\n    protected _isContainSampler: boolean;\r\n    protected _isContainComplexType: boolean;\r\n\r\n    constructor({ name = null, fields, ...settings }: IComplexTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexType, ...settings });\r\n\r\n        this._name = name;\r\n        this._fields = {};\r\n\r\n        this._isContainArray = false;\r\n        this._isContainSampler = false;\r\n        this._isContainComplexType = false;\r\n\r\n        this.addFields(fields.filter(field => !isNull(field)).map(field => Instruction.$withParent(field, this)));\r\n    }\r\n\r\n    \r\n    get writable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.calcSize();\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return 0;\r\n    }\r\n\r\n    \r\n    get fieldNames(): string[] {\r\n        return Object.keys(this._fields);\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.fieldNames.map( name => this._fields[name] );\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return false;\r\n    }\r\n\r\n    isTexture(): boolean {\r\n        return false;\r\n    }\r\n\r\n    isUAV(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return this.name || type.hash(this);\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        var code: string = \"struct \" + this._name + \"{\";\r\n\r\n        for (var i: number = 0; i < this.fields.length; i++) {\r\n            code += \"\\t\" + this.fields[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    isBase(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this._isContainArray;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this._isContainSampler;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this._isContainComplexType;\r\n    }\r\n\r\n\r\n    private addField(variable: IVariableDeclInstruction): void {\r\n        var varName: string = variable.name;\r\n        this._fields[varName] = variable;\r\n\r\n        var type: IVariableTypeInstruction = variable.type;\r\n\r\n        if (type.isNotBaseArray() || type.isContainArray()) {\r\n            this._isContainArray = true;\r\n        }\r\n\r\n        if (SystemScope.isSamplerType(type) || type.isContainSampler()) {\r\n            this._isContainSampler = true;\r\n        }\r\n\r\n        if (type.isComplex()) {\r\n            this._isContainComplexType = true;\r\n        }\r\n    }\r\n\r\n    private addFields(fields: IVariableDeclInstruction[]): void {\r\n        for (var i = 0; i < fields.length; i++) {\r\n            this.addField(fields[i]);\r\n        }\r\n\r\n        this.calculatePaddings();\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return isDef(this._fields[fieldName]);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return !!this.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields[fieldName] || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            if (semantic == field.semantic) {\r\n                return field;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    \r\n    public calcSize(): number {\r\n        let size: number = 0;\r\n\r\n        for (let i: number = 0; i < this.fields.length; i++) {\r\n            let iFieldSize: number = this.fields[i].type.size;\r\n\r\n            if (iFieldSize === instruction.UNDEFINE_SIZE) {\r\n                size = instruction.UNDEFINE_SIZE;\r\n                break;\r\n            }\r\n            else {\r\n                size += iFieldSize;\r\n            }\r\n        }\r\n\r\n        return size;\r\n    }\r\n\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            if (semantic == null || semantic == '') {\r\n                return true;\r\n            }\r\n            if (field.type.hasFieldWithoutSemantics()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        let fieldBySemantics: IMap<IVariableDeclInstruction> = {};\r\n\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            \r\n            if (isDefAndNotNull(fieldBySemantics[semantic])) {\r\n                return false;\r\n            }\r\n\r\n            fieldBySemantics[semantic] = field;\r\n\r\n            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private calculatePaddings(): void {\r\n        let padding: number = 0;\r\n\r\n        for (let i: number = 0; i < this.fields.length; i++) {\r\n            let varType: IVariableTypeInstruction = this.fields[i].type;\r\n            let varSize: number = varType.size;\r\n\r\n            if (varSize === instruction.UNDEFINE_SIZE) {\r\n                this._setError(EAnalyzerErrors.CannotCalcPadding, { typeName: this.name });\r\n                return;\r\n            }\r\n\r\n            varType.$overwritePadding(padding);\r\n            padding += varSize;\r\n        }\r\n    }\r\n}\r\n","export { default } from './Playground';\r\n","import { EInstructionTypes, IInstruction, IInstructionCollector } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IInstructionCollectorSettings extends IInstructionSettings {\r\n    instructions?: IInstruction[];\r\n}\r\n\r\nexport class InstructionCollector extends Instruction implements IInstructionCollector {\r\n    protected _instructions: IInstruction[];\r\n\r\n    constructor({ instructions = [], ...settings }: IInstructionCollectorSettings) {\r\n        super({ instrType: EInstructionTypes.k_Collector, ...settings });\r\n\r\n        this._instructions = instructions;\r\n    }\r\n\r\n\r\n    get instructions(): IInstruction[] {\r\n        return this._instructions;\r\n    }\r\n\r\n    push(instr: IInstruction): void {\r\n        this._instructions.push(instr);\r\n    }\r\n\r\n    toCode(): string {\r\n        let code = \"\";\r\n        for (const instr of  this.instructions) {\r\n            switch (instr.instructionType) {\r\n                case EInstructionTypes.k_VariableDecl:\r\n                    code += instr.toCode() + ';\\n';\r\n                break;\r\n                default:\r\n                    code += instr.toCode() + '\\n';\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}","const sizeof = {\r\n    u32: () => 4,\r\n    i32: () => 4,\r\n    f32: () => 4,\r\n    bool: () => sizeof.i32(),\r\n    addr: () => sizeof.i32()\r\n};\r\n\r\n\r\nexport default sizeof;","/* tslint:disable:typedef */\r\n/* tslint:disable:forin */\r\n/* tslint:disable:no-for-in */\r\n/* tslint:disable:newline-per-chained-call */\r\n/* tslint:disable:number-literal-format */\r\n/* tslint:disable:no-string-literal */\r\n/* tslint:disable:insecure-random */\r\n\r\nimport { assert, isDefAndNotNull, verbose } from '@lib/common';\r\nimport { EPartFxPassGeometry } from '@lib/idl/part/IPartFx';\r\nimport autobind from 'autobind-decorator';\r\nimport * as React from 'react';\r\nimport { Progress } from 'semantic-ui-react';\r\nimport * as THREE from 'three';\r\nimport * as OrbitControls from 'three-orbitcontrols';\r\nimport { IEmitter, IPass } from './IEmitter';\r\n\r\nconst $vertexShader = `\r\nprecision highp float;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nattribute vec3 position;\r\nattribute vec4 color;\r\nattribute float size;\r\nattribute vec3 offset;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n    vColor = color;\r\n    vec4 viewPos = modelViewMatrix * vec4(offset, 1.0) + vec4(position * size, 0.0);\r\n    gl_Position = projectionMatrix * viewPos;\r\n}\r\n`;\r\n\r\nconst $fragmentShader = `\r\nprecision highp float;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n    gl_FragColor = vColor;\r\n}\r\n`;\r\n\r\ninterface ITreeSceneProps {\r\n    style: React.CSSProperties;\r\n    emitter?: IEmitter;\r\n}\r\n\r\ninterface IThreeSceneState {\r\n    emitter: IEmitter;\r\n    nParticles: number;\r\n}\r\n\r\nclass Particle {\r\n    position: THREE.Vector3;\r\n    color: THREE.Color;\r\n    alpha: number;\r\n    size: number;\r\n}\r\n\r\n\r\nconst statsStyleFix: React.CSSProperties = {\r\n    position: 'absolute',\r\n    color: 'white',\r\n    padding: '2px 5px',\r\n    fontFamily: 'consolas',\r\n    fontSize: '10px',\r\n    right: '0',\r\n    lineHeight: '11px',\r\n    textShadow: '0 0 1px grey'\r\n};\r\n\r\nconst progressStyleFix: React.CSSProperties = {\r\n    background: '#eee',\r\n    borderRadius: '0'\r\n};\r\n\r\nclass ThreeScene extends React.Component<ITreeSceneProps, IThreeSceneState> {\r\n\r\n    state: IThreeSceneState = {\r\n        emitter: null,\r\n        nParticles: 0\r\n    };\r\n\r\n    renderer: THREE.WebGLRenderer;\r\n    camera: THREE.PerspectiveCamera;\r\n    scene: THREE.Scene;\r\n    pointCloud: THREE.Points;\r\n    controls: OrbitControls;\r\n\r\n    frameId: number;\r\n    mount: HTMLDivElement;\r\n\r\n    passes: {\r\n        mesh: THREE.Mesh | THREE.LineSegments;\r\n        instancedBuffer: THREE.InstancedInterleavedBuffer | THREE.InterleavedBuffer;\r\n    }[];\r\n\r\n    particles: Particle[];\r\n\r\n\r\n    componentDidMount() {\r\n        const width = this.mount.clientWidth;\r\n        const height = this.mount.clientHeight;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.scene.background = new THREE.Color(0xCCCCCC);\r\n\r\n        this.createCamera(width, height);\r\n        this.createRenderer(width, height);\r\n\r\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\r\n        this.controls.enabled = false;\r\n        // temp solution in order to not moving text cursor during movement\r\n        this.controls.enableKeys = false;\r\n\r\n        this.createGridHelper();\r\n        // this.createCube();\r\n\r\n        this.addEmitter(this.props.emitter);\r\n        this.start();\r\n\r\n        window.addEventListener('resize', this.onWindowResize, false);\r\n\r\n        // small hack for disabling arrow keys actings during the typing\r\n        this.canvas.addEventListener('mouseover', e => { this.controls.enabled = true; });\r\n        this.canvas.addEventListener('mouseout', e => { this.controls.enabled = false; });\r\n        // this.canvas.addEventListener('keydown', e => { if (this.controls.enabled) e.stopPropagation() });\r\n        // this.canvas.addEventListener('keyup', e => { if (this.controls.enabled) e.stopPropagation() });\r\n\r\n        // console.log('ThreeScene::componentDidMount()');\r\n    }\r\n\r\n    get canvas(): HTMLCanvasElement {\r\n        return this.renderer.domElement;\r\n    }\r\n\r\n    addPassLine(pass: IPass) {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const instancedBuffer = new THREE.InterleavedBuffer(new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);\r\n\r\n        //\r\n        // Instance data\r\n        //\r\n\r\n        pass.instanceLayout.forEach(desc => {\r\n            const interleavedAttr = new THREE.InterleavedBufferAttribute(instancedBuffer, desc.size, desc.offset);\r\n            geometry.addAttribute(desc.attrName, interleavedAttr);\r\n        });\r\n\r\n\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms: {},\r\n            vertexShader: pass.vertexShader,\r\n            fragmentShader: pass.pixelShader,\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false\r\n            // linewidth: 5\r\n        });\r\n\r\n        // geometry.setIndex(Array(pass.capacity).fill(0).map((x, i) => i));\r\n        geometry.setDrawRange(0, pass.length());\r\n        // geometry.index = new THREE.Uint16BufferAttribute(Array(pass.length).fill(0).map((x, i) => i), 1);\r\n\r\n        const mesh = new THREE.LineSegments(geometry, material);\r\n\r\n        mesh.name = 'emitter';\r\n        this.scene.add(mesh);\r\n        this.passes.push({ mesh, instancedBuffer });\r\n        verbose('emitter added.');\r\n    }\r\n\r\n\r\n    addPass(pass: IPass) {\r\n\r\n        if (pass.geometry === EPartFxPassGeometry.k_Line) {\r\n            this.addPassLine(pass);\r\n            return;\r\n        }\r\n\r\n        const geometry = new THREE.InstancedBufferGeometry();\r\n        const instanceGeometry: THREE.BufferGeometry = this.createInstinceGeometry(pass);\r\n\r\n        // tslint:disable-next-line:max-line-length\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);\r\n\r\n        //\r\n        // Instance data\r\n        //\r\n\r\n        pass.instanceLayout.forEach(desc => {\r\n            const interleavedAttr = new THREE.InterleavedBufferAttribute(instancedBuffer, desc.size, desc.offset);\r\n            geometry.addAttribute(desc.attrName, interleavedAttr);\r\n        });\r\n\r\n        //\r\n        // Geometry\r\n        //\r\n\r\n        // FIXME: do not use hardcoded layout\r\n        const geometryFixedLayout = {\r\n            a_position0: instanceGeometry.attributes.position,\r\n            a_normal0: instanceGeometry.attributes.normal,\r\n            a_texcoord0: instanceGeometry.attributes.uv\r\n        };\r\n\r\n        geometry.index = instanceGeometry.index;\r\n        for (const attrName in geometryFixedLayout) {\r\n            geometry.attributes[attrName] = geometryFixedLayout[attrName];\r\n        }\r\n\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms: {},\r\n            vertexShader: pass.vertexShader,\r\n            fragmentShader: pass.pixelShader,\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false,\r\n            // TODO: do not use for billboards\r\n            side: THREE.DoubleSide\r\n        });\r\n\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n\r\n        mesh.name = 'emitter';\r\n        this.scene.add(mesh);\r\n        this.passes.push({ mesh, instancedBuffer });\r\n        verbose('emitter added.');\r\n    }\r\n\r\n\r\n    addPassDefaultMat(pass: IPass) {\r\n        const geometry = new THREE.InstancedBufferGeometry();\r\n        const instanceGeometry: THREE.BufferGeometry = this.createInstinceGeometry(pass);\r\n        // tslint:disable-next-line:max-line-length\r\n        const instancedBuffer = new THREE.InstancedInterleavedBuffer(new Float32Array(pass.data.buffer, pass.data.byteOffset), pass.stride);\r\n\r\n        //\r\n        // Geometry\r\n        //\r\n\r\n        geometry.index = instanceGeometry.index;\r\n        geometry.attributes.position = instanceGeometry.attributes.position;\r\n        geometry.attributes.normal = instanceGeometry.attributes.normal;\r\n        geometry.attributes.uv = instanceGeometry.attributes.uv;\r\n\r\n        //\r\n        // Instanced data\r\n        //\r\n\r\n        instancedBuffer.setDynamic(true);\r\n\r\n        // todo: remove hardcoded layout or check it's validity.\r\n        geometry.addAttribute('offset', new THREE.InterleavedBufferAttribute(instancedBuffer, 3, 0));\r\n        geometry.addAttribute('color', new THREE.InterleavedBufferAttribute(instancedBuffer, 4, 3));\r\n        geometry.addAttribute('size', new THREE.InterleavedBufferAttribute(instancedBuffer, 1, 7));\r\n        geometry.maxInstancedCount = pass.length();\r\n\r\n\r\n        const material = new THREE.RawShaderMaterial({\r\n            uniforms: {},\r\n            vertexShader: $vertexShader,\r\n            fragmentShader: $fragmentShader,\r\n            transparent: true,\r\n            blending: THREE.NormalBlending,\r\n            depthTest: false\r\n        });\r\n\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n\r\n        mesh.name = 'emitter';\r\n        this.scene.add(mesh);\r\n        this.passes.push({ mesh, instancedBuffer });\r\n        verbose('emitter added.');\r\n    }\r\n\r\n    createInstinceGeometry(pass: IPass): THREE.BufferGeometry {\r\n        let instanceGeometry: THREE.BufferGeometry = null;\r\n        switch (pass.geometry) {\r\n            case EPartFxPassGeometry.k_Box:\r\n                instanceGeometry = new THREE.BoxBufferGeometry();\r\n                break;\r\n            case EPartFxPassGeometry.k_Sphere:\r\n                instanceGeometry = new THREE.SphereBufferGeometry(0.5);\r\n                break;\r\n            case EPartFxPassGeometry.k_Cylinder:\r\n                instanceGeometry = new THREE.CylinderBufferGeometry(0.5, 0.5, 1.0);\r\n                break;\r\n            case EPartFxPassGeometry.k_Line:\r\n                break;\r\n            case EPartFxPassGeometry.k_Billboard:\r\n            default:\r\n                instanceGeometry = new THREE.PlaneBufferGeometry();\r\n        }\r\n        return instanceGeometry;\r\n    }\r\n\r\n    // tslint:disable-next-line:max-func-body-length\r\n    addEmitter(emitter: IEmitter) {\r\n        this.passes = [];\r\n\r\n        if (!isDefAndNotNull(emitter)) {\r\n            console.warn('no emitters found.');\r\n            return;\r\n        }\r\n\r\n        // tslint:disable-next-line:max-func-body-length\r\n        emitter.passes.forEach((pass, i) => {\r\n            if (pass.vertexShader && pass.pixelShader) {\r\n               this.addPass(pass);\r\n            } else {\r\n                this.addPassDefaultMat(pass);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    createCamera(width, height) {\r\n        this.camera = new THREE.PerspectiveCamera(\r\n            75,\r\n            width / height,\r\n            0.1,\r\n            10000\r\n        );\r\n        this.camera.position.z = 3;\r\n        this.camera.position.y = 2;\r\n        this.camera.position.x = 2;\r\n        this.camera.lookAt(new THREE.Vector3(0, 0, 0));\r\n    }\r\n\r\n\r\n    createRenderer(width, height) {\r\n        this.renderer = new THREE.WebGLRenderer({ antialias: true });\r\n        // this.renderer.setClearColor('#000000');\r\n        this.renderer.setSize(width, height - 3);\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        this.mount.appendChild(this.renderer.domElement);\r\n\r\n        // FIXME: remove this ui hack\r\n        this.renderer.domElement.style.borderBottomLeftRadius = '3px';\r\n        this.renderer.domElement.style.borderBottomRightRadius = '3px';\r\n    }\r\n\r\n\r\n    createGridHelper() {\r\n        const size = 10;\r\n        const divisions = 10;\r\n\r\n        const gridHelper = new THREE.GridHelper(size, divisions);\r\n        this.scene.add(gridHelper);\r\n    }\r\n\r\n    @autobind\r\n    onWindowResize() {\r\n        this.camera.aspect = this.mount.clientWidth / this.mount.clientHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight);\r\n    }\r\n\r\n\r\n    componentWillUnmount() {\r\n        this.stop();\r\n        window.removeEventListener('resize', this.onWindowResize, false);\r\n        this.mount.removeChild(this.renderer.domElement);\r\n    }\r\n\r\n\r\n    start = () => {\r\n        if (!this.frameId) {\r\n            this.frameId = requestAnimationFrame(this.animate);\r\n        }\r\n    }\r\n\r\n\r\n    stop = () => {\r\n        cancelAnimationFrame(this.frameId);\r\n    }\r\n\r\n\r\n    animate = (time: number) => {\r\n        const emitter = this.state.emitter;\r\n\r\n        if (!emitter) {\r\n            return;\r\n        }\r\n\r\n        emitter.tick();\r\n\r\n        for (let iPass = 0; iPass < this.passes.length; ++iPass) {\r\n            const rendPass = this.passes[iPass];\r\n            const emitPass = emitter.passes[iPass];\r\n\r\n            if (emitPass.sorting) {\r\n                emitPass.sort(this.camera.position);\r\n            }\r\n\r\n            const geometry = rendPass.mesh.geometry as THREE.BufferGeometry;\r\n\r\n            rendPass.instancedBuffer.needsUpdate = true;\r\n            if (emitPass.geometry === EPartFxPassGeometry.k_Line) {\r\n                geometry.setDrawRange(0, emitPass.length());\r\n            } else {\r\n                (geometry as THREE.InstancedBufferGeometry).maxInstancedCount = emitPass.length();\r\n            }\r\n        }\r\n\r\n        this.controls.update();\r\n        this.renderer.render(this.scene, this.camera);\r\n        this.frameId = requestAnimationFrame(this.animate);\r\n\r\n        this.setState({ nParticles: emitter.length() });\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: ITreeSceneProps, nexState) {\r\n        return this.state.emitter !== nextProps.emitter || this.state.nParticles !== nexState.nParticles;\r\n    }\r\n\r\n    // tslint:disable-next-line:member-ordering\r\n    static getDerivedStateFromProps(props: ITreeSceneProps, state: IThreeSceneState) {\r\n        if (state.emitter === props.emitter) {\r\n            return null;\r\n        }\r\n\r\n        return { emitter: props.emitter };\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n        if (prevState.emitter === this.state.emitter) {\r\n            const emitter = this.props.emitter;\r\n\r\n            emitter.passes.forEach((pass, i) => {\r\n                let { mesh } = this.passes[i];\r\n                let material = mesh.material as THREE.RawShaderMaterial;\r\n                // let geometry = mesh.geometry as THREE.InstancedBufferGeometry;\r\n\r\n                if (!pass.vertexShader || !pass.pixelShader) {\r\n                    return;\r\n                }\r\n\r\n                const { vertexShader, pixelShader: fragmentShader } = pass;\r\n\r\n                if (material.vertexShader !== vertexShader ||\r\n                    material.fragmentShader !== fragmentShader) {\r\n                    verbose('material shadow reload.');\r\n\r\n                    material.dispose();\r\n                    material = new THREE.RawShaderMaterial({\r\n                        uniforms: {},\r\n                        vertexShader,\r\n                        fragmentShader,\r\n                        transparent: true,\r\n                        blending: THREE.NormalBlending,\r\n                        depthTest: false\r\n                    });\r\n\r\n                    // this.scene.remove(mesh);\r\n                    mesh.material = material;\r\n\r\n                    // mesh = new THREE.Mesh(geometry, material);\r\n                }\r\n            });\r\n            return;\r\n        }\r\n\r\n        this.passes.forEach(pass => {\r\n            this.scene.remove(pass.mesh);\r\n            verbose('emitter removed.');\r\n        });\r\n\r\n        if (this.props.emitter) {\r\n            this.addEmitter(this.props.emitter);\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        // console.log('ThreeScene::render()');\r\n        return (\r\n            <div\r\n                style={ this.props.style }\r\n                ref={ (mount) => { this.mount = mount; } }\r\n            >\r\n                <Progress\r\n                    value={ this.state.nParticles }\r\n                    total={ this.state.emitter.capacity }\r\n                    attached='top'\r\n                    size='medium'\r\n                    indicating\r\n                    style={ progressStyleFix }\r\n                />\r\n                <div style={ statsStyleFix }>\r\n                    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: { this.state.nParticles }</span>\r\n                    <br />\r\n                    <span>simulation: CPU</span>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ThreeScene;\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n/**\r\n * Represent empty statement only semicolon ;\r\n * ;\r\n */\r\nexport class SemicolonStmtInstruction extends StmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SemicolonStmt, ...settings });\r\n    }\r\n\r\n    toCode(): string {\r\n        return \";\";\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { isNumber } from \"@lib/common\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, IAnnotationInstruction, IFunctionDeclInstruction, IIdInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISamplerState } from \"@lib/idl/ISamplerState\";\r\nimport { ETextureFilters, ETextureWrapModes } from \"@lib/idl/ITexture\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPassInstructionSettings extends IDeclInstructionSettings {\r\n    vertexShader?: IFunctionDeclInstruction;\r\n    pixelShader?: IFunctionDeclInstruction;\r\n    renderStates?: IMap<ERenderStateValues>;\r\n    id?: IIdInstruction;\r\n}\r\n\r\n\r\nexport class PassInstruction extends DeclInstruction implements IPassInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _vertexShader: IFunctionDeclInstruction;\r\n    protected _pixelShader: IFunctionDeclInstruction;\r\n    protected _passStateMap: IMap<ERenderStateValues>;\r\n\r\n    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }: IPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PassDecl, ...settings });\r\n\r\n        this._passStateMap = {};\r\n        PassInstruction.clearRenderStateMap(this._passStateMap);\r\n        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);\r\n \r\n        this._vertexShader = Instruction.$withNoParent(vertexShader);\r\n        this._pixelShader = Instruction.$withNoParent(pixelShader);\r\n\r\n        this._id = id;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get vertexShader(): IFunctionDeclInstruction {\r\n        return this._vertexShader;\r\n    }\r\n\r\n    get pixelShader(): IFunctionDeclInstruction {\r\n        return this._pixelShader;\r\n    }\r\n\r\n\r\n    getState(state: ERenderStates): ERenderStateValues {\r\n        return this._passStateMap[state];\r\n    }\r\n\r\n    get renderStates(): IMap<ERenderStateValues> {\r\n        return this._passStateMap;\r\n    }\r\n\r\n    // TODO: move it to helpers\r\n    private static createRenderStateMap(): IMap<ERenderStateValues> {\r\n        let map: IMap<ERenderStateValues> = <IMap<ERenderStateValues>>{};\r\n        PassInstruction.clearRenderStateMap(map);\r\n\r\n        return map;\r\n    }\r\n\r\n    // TODO: move it to helpers\r\n    private static copyRenderStateMap(from: IMap<ERenderStateValues>, to: IMap<ERenderStateValues>): void {\r\n        if (isNull(from)) {\r\n            return;\r\n        }\r\n\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { to[rs] = from[rs] || to[rs] });\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static clearRenderStateMap(map: IMap<ERenderStateValues>): void {\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { map[rs] = ERenderStateValues.UNDEF });\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // TODO: move it to helpers\r\n    private static createSamplerState(): ISamplerState {\r\n        return <ISamplerState>{\r\n            textureName: \"\",\r\n            texture: null,\r\n            wrap_s: ETextureWrapModes.UNDEF,\r\n            wrap_t: ETextureWrapModes.UNDEF,\r\n            mag_filter: ETextureFilters.UNDEF,\r\n            min_filter: ETextureFilters.UNDEF\r\n            /*wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,\r\n            wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,\r\n            mag_filter: ETextureFilters.LINEAR,\r\n            min_filter: ETextureFilters.LINEAR*/\r\n        };\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IStmtBlockInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IStmtBlockInstructionSettings extends IInstructionSettings {\r\n    stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent {stmts}\r\n * EMPTY_OPERATOR StmtInstruction ... StmtInstruction\r\n */\r\nexport class StmtBlockInstruction extends StmtInstruction implements IStmtBlockInstruction {\r\n    protected _stmtList: IStmtInstruction[];\r\n\r\n    \r\n    constructor({ stmtList, ...settings }: IStmtBlockInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StmtBlock, ...settings });\r\n        this._stmtList = stmtList.map(stmt => Instruction.$withParent(stmt, this));\r\n    }\r\n\r\n\r\n    get stmtList(): IStmtInstruction[] {\r\n        return this._stmtList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"{\" + \"\\n\";\r\n\r\n        for (var i: number = 0; i < this.stmtList.length; i++) {\r\n            code += \"\\t\" + this.stmtList[i].toCode() + \"\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport type ArithmeticOperator = \"+\" | \"-\" | \"/\" | \"*\" | \"%\";\r\n\r\nexport interface IArithmeticExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ArithmeticOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr + / - * % someExpr\r\n * (+|-|*|/|%) Instruction Instruction\r\n */\r\nexport class ArithmeticExprInstruction extends ExprInstruction implements IArithmeticExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: ArithmeticOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IArithmeticExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ArithmeticExpr, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n    get operator(): ArithmeticOperator {\r\n        return this._operator;\r\n    }\r\n    \r\n\r\n    evaluate(): boolean {\r\n        var pValL: any = this._leftOperand.evaluate() ? this._leftOperand.getEvalValue() : null;\r\n        var pValR: any = this._rightOperand.evaluate() ? this._rightOperand.getEvalValue() : null;\r\n\r\n        if (isNull(pValL) || isNull(pValR)) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            switch (this.operator) {\r\n                case \"+\":\r\n                    this._evalResult = pValL + pValR;\r\n                    break;\r\n                case \"-\":\r\n                    this._evalResult = pValL - pValR;\r\n                    break;\r\n                case \"*\":\r\n                    this._evalResult = pValL * pValR;\r\n                    break;\r\n                case \"/\":\r\n                    this._evalResult = pValL / pValR;\r\n                    break;\r\n                case \"%\":\r\n                    this._evalResult = pValL % pValR;\r\n                    break;\r\n            }\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this._leftOperand.toCode();\r\n        sCode += this.operator;\r\n        sCode += this._rightOperand.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\n\r\nimport { REG_INVALID } from \"./common\";\r\nimport sizeof from \"./sizeof\";\r\n\r\nexport interface IAddrDesc {\r\n    type: EAddrType;\r\n    addr: number | PromisedAddress;\r\n    size?: number;\r\n    swizzle?: number[];\r\n    inputIndex?: number;\r\n}\r\n\r\n\r\nexport interface IAddrOverride {\r\n    size?: number;\r\n    swizzle?: number[];\r\n}\r\n\r\n\r\nclass PromisedAddress {\r\n    type: EAddrType;\r\n    addr: number;\r\n    size: number;\r\n    inputIndex: number;\r\n    swizzle: number[];\r\n\r\n\r\n    constructor({ type, addr, size = 0, inputIndex = -1, swizzle = null }: IAddrDesc) {\r\n        this.type = type;\r\n        this.addr = Number(addr);\r\n        this.inputIndex = inputIndex;\r\n\r\n        assert(!swizzle || !size || swizzle.length * sizeof.i32() === size, 'size and swizzling are not compatible');\r\n        if (swizzle) {\r\n            assert(swizzle.length > 1, 'unary swizzles must be removed in favor of offsetted adress');\r\n            assert(swizzle.length <= 4, 'only xyzw/rgba swizzles are supported');\r\n\r\n            size = swizzle.length * sizeof.i32();\r\n        }\r\n\r\n        this.size = size;\r\n        this.swizzle = swizzle;\r\n\r\n        assert(addr === REG_INVALID || size > 0, 'invalid address size found');\r\n        assert(size % sizeof.i32() === 0, 'invalid address alignment found');\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this.size / sizeof.i32();\r\n    }\r\n\r\n\r\n    valueOf(): number {\r\n         // guard of implicit loading\r\n        if (this.type != EAddrType.k_Registers) {\r\n            assert(false, `address has implicitly moved to ${EAddrType[EAddrType.k_Registers]} from ${EAddrType[this.type]}`);\r\n            return REG_INVALID;\r\n        }\r\n\r\n        return this.addr;\r\n    }\r\n\r\n\r\n    isPointer(): boolean {\r\n        return this.type >= EAddrType.k_PointerRegisters;\r\n    }\r\n\r\n    isInput(): boolean {\r\n        return this.type == EAddrType.k_Input || this.type == EAddrType.k_PointerInput;\r\n    }\r\n\r\n\r\n    toNumber() {\r\n        return this.addr;\r\n    }\r\n\r\n\r\n    toString() {\r\n        const { type, inputIndex, addr, swizzle, size } = this;\r\n        const isPointer = this.isPointer();\r\n        const isInput = this.isInput();\r\n        \r\n        return `${EAddrType[type]} [${isPointer ? '%' : isInput ? '' : 'r'}${addr / 4} ${isInput ? `input(${inputIndex})` : ``}, ${size} bytes, [${(swizzle || []).join(', ')}]]`;\r\n    }\r\n\r\n    // non-pointer address type => pointer\r\n    static castToPointer(type: EAddrType): EAddrType {\r\n        assert(type < EAddrType.k_PointerRegisters);\r\n        return (type + EAddrType.k_PointerRegisters);\r\n    }\r\n\r\n\r\n    static INVALID = new PromisedAddress({ type: EAddrType.k_Registers, addr: REG_INVALID, size: 0 });\r\n}\r\n\r\nexport default PromisedAddress;\r\n","import { EInstructionTypes, IAnnotationInstruction, IDeclInstruction, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IDeclInstructionSettings extends IInstructionSettings {\r\n    readonly semantic?: string;\r\n    readonly annotation?: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport class DeclInstruction extends Instruction implements IDeclInstruction {\r\n    protected _semantic: string\r\n    protected _annotation: IAnnotationInstruction;\r\n    \r\n    constructor({ semantic = null, annotation = null, ...settings }: IDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Decl, ...settings });\r\n\r\n        this._semantic = semantic;\r\n        this._annotation = Instruction.$withParent(annotation, this);\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this._semantic;\r\n    }\r\n\r\n\r\n    get annotation(): IAnnotationInstruction {\r\n        return this._annotation;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return null;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return null;\r\n    }\r\n}\r\n","import DistinctColor from \"@lib/util/DistinctColor\";\r\n\r\nexport default {\r\n    yellowMarker: {\r\n        backgroundColor: 'rgba(255,255,0,0.3)'\r\n    },\r\n\r\n    errorMarker: {\r\n        top: '1px',\r\n        background: `url(\"data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\") repeat-x bottom left`\r\n    },\r\n\r\n    warningMarker: {\r\n        top: '1px',\r\n        filter: 'hue-rotate(45deg)',\r\n        background: `url(\"data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\") repeat-x bottom left`\r\n    },\r\n\r\n    breakpoint: {\r\n        background: 'red'\r\n    },\r\n\r\n    ...DistinctColor.buildVariousClasses('dc')\r\n};\r\n","import { assert, isDef, isDefAndNotNull, isNull, isNumber, isString, MakeOptional } from \"@lib/common\";\r\nimport { EAddrType } from \"@lib/idl/bytecode\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IFunctionDeclInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { variable } from \"../analisys/helpers\";\r\nimport { f32Asi32, sname } from \"./common\";\r\nimport ConstanPool from \"./ConstantPool\";\r\nimport debugLayout from './DebugLayout';\r\nimport InstructionList from \"./InstructionList\";\r\nimport PromisedAddress, { IAddrDesc } from \"./PromisedAddress\";\r\nimport sizeof from \"./sizeof\";\r\nimport SymbolTable from \"./SymbolTable\";\r\nimport { UAVPool } from \"./UAVPool\";\r\n\r\nexport enum EErrors {\r\n    k_UnsupportedConstantType,\r\n    k_UnsupportedExprType,\r\n    k_UnsupoortedTypeConversion,\r\n    k_UnsupportedArithmeticExpr,\r\n    k_UnsupportedRelationalExpr\r\n}\r\n\r\n\r\n// FIXME: don't use 'any' type\r\ntype ITranslatorDiagDesc = any;\r\n\r\nexport class TranslatorDiagnostics extends Diagnostics<ITranslatorDiagDesc> {\r\n    constructor() {\r\n        super(\"Translator Diagnostics\", 'T');\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: ITranslatorDiagDesc): string {\r\n        return '[unknown]';  // FIXME: return correct filename\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: ITranslatorDiagDesc): IRange {\r\n        return { start: { line: 0, column: 0, file: null }, end: { line: 0, column: 0, file: null } }; // todo: fixme\r\n    }\r\n\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: any): string {\r\n        let { ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `warning: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function ContextBuilder() {\r\n    // occupied registers count \r\n    // same as stack pointer; \r\n    // counter grows forward;\r\n    let rc: number = 0;\r\n\r\n    // stack of functions and logical blocks for ex: braces.\r\n    const stack: {\r\n        scopes: {\r\n            // symbol table containing local variables of the function including parameters\r\n            symbols: SymbolTable<PromisedAddress>;\r\n            // registers count at the moment of block's entry\r\n            rc: number;\r\n        }[];\r\n\r\n        // program counter's value before the function's start \r\n        pc: number; // << NOTE: currently is unsed\r\n\r\n        fn: IFunctionDeclInstruction;\r\n        // address of register where return call should save its value\r\n        ret: PromisedAddress;\r\n        // addresses of function return instructions to be resolved\r\n        retRequests: number[];\r\n    }[] = [];\r\n\r\n\r\n    const instructions = new InstructionList;\r\n    const constants = new ConstanPool;\r\n    const uavs = new UAVPool;\r\n\r\n    const diag = new TranslatorDiagnostics; // todo: remove it?\r\n\r\n\r\n    /** @returns Description of the top of the callstack */\r\n    const top = () => stack[stack.length - 1];\r\n    const depth = () => stack.length;\r\n    const ret = () => top().ret;\r\n    const pc = () => instructions.pc;\r\n\r\n\r\n    const debug = debugLayout(pc);\r\n\r\n    /* (assuming that all registers for all types are placed in the same memory) */\r\n    function alloca(size: number): PromisedAddress {\r\n        if (size === 0) {\r\n            return PromisedAddress.INVALID;\r\n        }\r\n\r\n        const dest = Addr.loc({ type: EAddrType.k_Registers, addr: rc, size });\r\n        rc += size;\r\n        return dest;\r\n    }\r\n\r\n\r\n    /** insert code */\r\n    function icode(code: EOperation, ...args: Array<number | PromisedAddress>): void {\r\n        if (code === EOperation.k_Ret) {\r\n            // add the instruction address to the description of the\r\n            // function on the top of the colstack; when the code\r\n            // generation for this function is completed, all return\r\n            // instructions must receive the correct addresses for\r\n            // jumping to the end of the function\r\n            addReturn();\r\n        }\r\n\r\n        // add this instruction to debug layout;\r\n        debug.step();\r\n        instructions.add(code, args.map(Number));\r\n    }\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * op(a[i])\r\n     */\r\n    function iop1(op: EOperation, dest: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * a[i] = op(b[i])\r\n     */\r\n    function iop2(op: EOperation, dest: PromisedAddress, a: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n\r\n        assert(dest.length === a.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * dest[i] = op(a[i], b[i])\r\n     */\r\n    function iop3(op: EOperation, dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n        assert(b.type === EAddrType.k_Registers);\r\n\r\n        assert(dest.length === a.length);\r\n        assert(dest.length === b.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32(),\r\n                b.addr + (b.swizzle ? b.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Apply per component operation between two register-based adresses\r\n     * dest[i] = op(a[i], b[i], c[i])\r\n     */\r\n    function iop4(op: EOperation, dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress, c: PromisedAddress): void {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        assert(a.type === EAddrType.k_Registers);\r\n        assert(b.type === EAddrType.k_Registers);\r\n        assert(c.type === EAddrType.k_Registers);\r\n\r\n\r\n        assert(dest.length === a.length);\r\n        assert(dest.length === b.length);\r\n        assert(dest.length === c.length);\r\n\r\n        for (let i = 0; i < dest.length; ++i) {\r\n            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                a.addr + (a.swizzle ? a.swizzle[i] : i) * sizeof.i32(),\r\n                b.addr + (b.swizzle ? b.swizzle[i] : i) * sizeof.i32(),\r\n                c.addr + (c.swizzle ? c.swizzle[i] : i) * sizeof.i32());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write something to this location/address\r\n     * @param src Source address.\r\n     * @param size Size of the source location.\r\n     */\r\n    function imove(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n        assert(src.length === dest.length,\r\n            `source size is ${src.size} and less then the requested size ${dest.size}.`);\r\n\r\n        switch (dest.type) {\r\n            case EAddrType.k_Registers:\r\n                {\r\n                    switch (src.type) {\r\n                        case EAddrType.k_Registers:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadRegister,\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_Input:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadInput, src.inputIndex,\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_PointerRegisters:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadRegistersPointer,\r\n                                    // destination register\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    // source pointer\r\n                                    src.addr,\r\n                                    // pointer offset\r\n                                    (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        case EAddrType.k_PointerInput:\r\n                            assert(dest.type === EAddrType.k_Registers);\r\n                            for (let i = 0; i < dest.length; ++i) {\r\n                                icode(EOperation.k_I32LoadInputPointer,\r\n                                    src.inputIndex,\r\n                                    // destination register\r\n                                    dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                                    // source pointer\r\n                                    src.addr,\r\n                                    // pointer offset\r\n                                    (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                            }\r\n                            break;\r\n                        default:\r\n                            assert(false, 'unsupported memory type found.');\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case EAddrType.k_Input:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreInput, dest.inputIndex,\r\n                        dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32(),\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            case EAddrType.k_PointerInput:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreInputPointer, dest.inputIndex,\r\n                        // destination pointer\r\n                        dest.addr,\r\n                        // source register\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32(),\r\n                        // destination offset\r\n                        (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            case EAddrType.k_PointerRegisters:\r\n                assert(src.type === EAddrType.k_Registers);\r\n                for (let i = 0; i < dest.length; ++i) {\r\n                    icode(EOperation.k_I32StoreRegisterPointer,\r\n                        // destination pointer\r\n                        dest.addr,\r\n                        // source register\r\n                        src.addr + (src.swizzle ? src.swizzle[i] : i) * sizeof.i32(),\r\n                        // destination offset\r\n                        (dest.swizzle ? dest.swizzle[i] : i) * sizeof.i32());\r\n                }\r\n                break;\r\n            default:\r\n                assert(false, 'unsupported memory type found.');\r\n        }\r\n\r\n        return dest;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Resolve/move this address/region to registers\r\n     */\r\n    function iload(src: PromisedAddress): PromisedAddress {\r\n        assert(src.type !== EAddrType.k_Registers);\r\n        return imove(alloca(src.size), src);\r\n    }\r\n\r\n\r\n    const I32_HINT = 0;\r\n    const F32_HINT = 1;\r\n    // hint: 0 -> i32, 1 -> f32 (hints for bytecode viewer only)\r\n    function iset(dest: PromisedAddress, i32: number, i32Hint: 0 | 1): PromisedAddress {\r\n        assert(dest.type === EAddrType.k_Registers);\r\n        icode(EOperation.k_I32SetConst, dest.addr + (dest.swizzle ? dest.swizzle[0] : 0) * sizeof.i32(), i32, i32Hint);\r\n        return dest;\r\n    }\r\n\r\n\r\n    function iconst_i32(i32: number): PromisedAddress {\r\n        return iset(alloca(sizeof.i32()), i32, I32_HINT);\r\n    }\r\n\r\n    function iconst_f32(f32: number): PromisedAddress {\r\n        return iset(alloca(sizeof.f32()), f32Asi32(f32), F32_HINT);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add referene of the local variable.\r\n     * @param decl Variable declaration.\r\n     * @param src Register number.\r\n     */\r\n    function ref(decl: IVariableDeclInstruction, src: PromisedAddress): void {\r\n        const name = sname.var(decl);\r\n        assert(src.type === EAddrType.k_Registers);\r\n\r\n        const scopes = top().scopes;\r\n        const symbols = scopes[scopes.length - 1].symbols;\r\n        assert(!isDef(symbols[name]));\r\n        symbols[name] = src;\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns Register address of variable/constant or REG_INVALID.\r\n     * @param decl\r\n     */\r\n    function deref(decl: IVariableDeclInstruction): PromisedAddress {\r\n        const name = sname.var(decl);\r\n        // is zero register available?\r\n        for (let iFn = stack.length - 1; iFn >= 0; --iFn) {\r\n            const scopes = stack[iFn].scopes;\r\n            for (let iScope = scopes.length - 1; iScope >= 0; --iScope) {\r\n                const symbols = scopes[iScope].symbols;\r\n                if (isDef(symbols[name])) {\r\n                    return symbols[name];\r\n                }\r\n            }\r\n        }\r\n        assert(false, `cannot dereference varaible ${name} (${decl.toCode()})`);\r\n        return PromisedAddress.INVALID;\r\n    }\r\n\r\n\r\n    /** @returns Address of the return value. */\r\n    function push(fn: IFunctionDeclInstruction, ret: PromisedAddress): void {\r\n        const pc = instructions.pc;\r\n        const retRequests = [];\r\n        const scopes = [];\r\n        stack.push({ fn, scopes, ret, pc, retRequests });\r\n        open();\r\n    }\r\n\r\n\r\n    function pop(): void {\r\n        // check that there are no non-closed blocks left inside the function\r\n        assert(top().scopes.length === 1);\r\n        close();\r\n\r\n        const entry = stack.pop();\r\n\r\n        const entryPoint = stack.length === 0;\r\n        // updating all return adresses to correct values\r\n        if (!entryPoint) {\r\n            entry.retRequests.forEach(pc => instructions.replace(pc, EOperation.k_Jump, [instructions.pc]));\r\n            //                                                                          ^^^^^^^^^^^^^^^^^\r\n            //                                                     instruction immediately after function\r\n        }\r\n    }\r\n\r\n    /** Open new block */\r\n    function open() {\r\n        const symbols = new SymbolTable<PromisedAddress>();\r\n        top().scopes.push({ symbols, rc });\r\n    }\r\n\r\n\r\n    /** CLose last block */\r\n    function close() {\r\n        const scope = top().scopes.pop();\r\n        rc = scope.rc;\r\n    }\r\n\r\n\r\n    // next operation will be 'k_Ret'\r\n    function addReturn() {\r\n        top().retRequests.push(pc());\r\n    }\r\n\r\n    const Addr = {\r\n        loc({ type = EAddrType.k_Registers, addr, inputIndex, size, swizzle }: MakeOptional<IAddrDesc>) {\r\n            return new PromisedAddress({ type, addr, inputIndex, size, swizzle });\r\n        },\r\n\r\n        // override layout\r\n        override(src: PromisedAddress, swizzle: number[]): PromisedAddress {\r\n\r\n            let offset = 0;\r\n            let size = 0;\r\n\r\n            swizzle = swizzle.map(i => src.swizzle ? src.swizzle[i] : i);\r\n\r\n\r\n            // NOTE: \r\n            // All this optimizations are need only for debug purposes.\r\n            \r\n            if (!src.isPointer()) {\r\n                // removment of the unary swizzles\r\n                if (swizzle.length === 1) {\r\n                    offset = swizzle[0] * sizeof.i32();\r\n                    size = sizeof.i32();\r\n                    swizzle = null;\r\n                    return new PromisedAddress({ ...src, addr: src.addr + offset, size, swizzle });\r\n                }\r\n\r\n\r\n                const ordered = [ ...swizzle ].sort((a, b) => a - b);\r\n                \r\n                // removment of the gap\r\n                // example: v.zw => (&v + 2).xy\r\n                if (ordered[0] !== 0) {\r\n                    offset = ordered[0] * sizeof.i32();\r\n                    swizzle = swizzle.map(si => si - ordered[0]);\r\n                }\r\n                \r\n                // removment of the useless swizzles\r\n                // example: v.xy => v\r\n                const useless = swizzle.every((si, i) => si === i);\r\n                if (useless) {\r\n                    size = swizzle.length * sizeof.i32();\r\n                    swizzle = null;\r\n                }\r\n            }\r\n\r\n            return new PromisedAddress({ ...src, addr: src.addr + offset, size, swizzle });\r\n        },\r\n\r\n\r\n        subPointer(src: PromisedAddress, indexAddr: PromisedAddress, arrayElementSize: number) {\r\n            const { type, addr, size, inputIndex, swizzle } = src;\r\n\r\n            if (indexAddr.type !== EAddrType.k_Registers) {\r\n                indexAddr = iload(indexAddr);\r\n            }\r\n\r\n            //\r\n            // no swizzling (pointers & non-pointers)\r\n            //\r\n\r\n            if (!swizzle) {\r\n\r\n                // convert byte offset to register index (cause VM uses registers not byte offsets)\r\n                const sizeAddr = iconst_i32(arrayElementSize >> 2);\r\n\r\n                // convert byte offset to register index\r\n                const baseAddr =  !src.isPointer() ? iconst_i32(addr >> 2) : addr;\r\n                const pointerType = !src.isPointer() ? PromisedAddress.castToPointer(type) : type;\r\n\r\n                const pointerAddr = alloca(sizeof.addr());        // addr <=> i32\r\n                icode(EOperation.k_I32Mad, pointerAddr, baseAddr, indexAddr, sizeAddr);\r\n\r\n\r\n                return new PromisedAddress({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });\r\n            }\r\n\r\n            //\r\n            // swizzling (pointers & non-pointers)\r\n            //\r\n\r\n            assert(arrayElementSize === sizeof.i32());\r\n\r\n            assert(swizzle.length <= 4);\r\n\r\n            const swBaseRegister = rc;\r\n            swizzle.forEach(si => iconst_i32(si));\r\n            // ----- sw base rigister\r\n            // [z]\r\n            // [x]\r\n            // [y]\r\n            // -----\r\n\r\n            const swAddr = iconst_i32(swBaseRegister >> 2);\r\n\r\n            // swAddr ==> [ sw base rigister ]\r\n\r\n            icode(EOperation.k_I32Add, swAddr, swAddr, indexAddr);\r\n\r\n            // swAddr ==> [ sw base rigister + offset ]\r\n\r\n            // pointer to value of the swizzle for given offset\r\n            const offsetPointer = new PromisedAddress({ type: EAddrType.k_PointerRegisters, addr: swAddr, size: sizeof.i32() });\r\n\r\n            const pointerAddr = iload(offsetPointer);\r\n            // destAddr ==> [ swizzles[offset] ]\r\n\r\n            const baseAddr = !src.isPointer()? iconst_i32(addr >> 2) : addr;\r\n            const pointerType = !src.isPointer() ? PromisedAddress.castToPointer(type) : type;\r\n\r\n            // add given swizzle to base pointer (all pointers already aligned in registers, so 'mad' isn't not needed here)\r\n            icode(EOperation.k_I32Add, pointerAddr, baseAddr, pointerAddr);\r\n\r\n            return new PromisedAddress({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });\r\n        },\r\n\r\n\r\n        sub(src: PromisedAddress, offset: number, range?: number): PromisedAddress {\r\n            const { type, addr, size, inputIndex, swizzle } = src;\r\n\r\n            range = range || (size - offset);\r\n\r\n            assert(range % sizeof.i32() === 0);\r\n            assert(offset % sizeof.i32() === 0);\r\n            assert(size >= offset + range);\r\n\r\n            if (src.isPointer()) {\r\n                if (!swizzle) {\r\n                    if (offset !== 0) {\r\n                        // calc the summ of the original addr and given offset\r\n                        const newAddr = alloca(sizeof.addr());\r\n                        const offsetAddr = iconst_i32(offset >> 2);\r\n                        icode(EOperation.k_I32Add, newAddr, addr, offsetAddr);\r\n                        return new PromisedAddress({ type, addr: newAddr, size: range, inputIndex });\r\n                    }\r\n                    // nothing todo, just shrink the size\r\n                    return new PromisedAddress({ type, addr, size: range, inputIndex });\r\n                }\r\n\r\n                // offsets from the swizzled pointers are unsupported\r\n                // ex: uav[i].xyz.field\r\n                //                ^^^^^\r\n                //                there are not such case can be! \r\n                \r\n                assert(false, 'unsupported branch');\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            // just shift the address\r\n            if (!swizzle) {\r\n                return new PromisedAddress({ type, addr: addr + offset, size: range, inputIndex });\r\n            }\r\n\r\n            // implicitly move padding inside swizzles\r\n            const ordered = [...Array(range / sizeof.i32()).keys()].map(i => i + offset / sizeof.i32());\r\n            return Addr.override(src, ordered);\r\n        },\r\n\r\n        shrink(src: PromisedAddress, size: number): PromisedAddress {\r\n            return Addr.sub(src, 0, size);\r\n        }\r\n    }\r\n\r\n    const addr = Addr;\r\n\r\n    return {\r\n        pc,\r\n        addr,\r\n        instructions,\r\n        debug,\r\n        deref,\r\n        ref,\r\n        alloca,\r\n        icode,\r\n        imove,\r\n        iload,\r\n        iconst_i32,\r\n        iconst_f32,\r\n        iop4,\r\n        iop3,\r\n        iop2,\r\n        iop1,\r\n        push,\r\n        pop,\r\n        open,\r\n        close,\r\n        ret,\r\n        constants,\r\n        uavs,\r\n        depth,\r\n        diag\r\n    };\r\n}\r\n\r\nexport type IContext = ReturnType<typeof ContextBuilder>;\r\n","import { createOutput, IOutput } from \"./Output\";\r\n\r\nexport class BaseEmitter {\r\n    private blocks: IOutput[] = [];\r\n    private stack: IOutput[] = [];\r\n\r\n    private top() { return this.stack[this.depth() - 1]; }\r\n    \r\n    protected depth() { \r\n        return this.stack.length;\r\n    }\r\n\r\n    protected begin() {\r\n        this.stack.push(createOutput());\r\n    }\r\n\r\n    /**\r\n     * @param prologue Move block to the beginning.\r\n     */\r\n    protected end(prologue = false) {\r\n        if (!prologue) {\r\n            this.blocks.push(this.stack.pop());\r\n        } else {\r\n            this.blocks = [ this.stack.pop(), ...this.blocks ];\r\n        }\r\n    }\r\n\r\n    protected push(pad?) {\r\n        this.top().push(pad);\r\n    }\r\n\r\n    protected pop() {\r\n        this.top().pop();\r\n    }\r\n\r\n    emitNewline() { this.top().newline(); }\r\n    emitKeyword(kw: string) { this.top().keyword(kw); }\r\n    emitNoSpace() { this.top().ignoreNextSpace(); }\r\n    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }\r\n    emitChar(char: string) { this.top().add(char); }\r\n    emitLine(line: string) { \r\n        this.emitChar(line);\r\n        this.emitNewline(); \r\n    }\r\n\r\n    toString(): string {\r\n        return this.blocks\r\n            .map(block => block.toString())\r\n            .filter(code => !!code)\r\n            .join('\\n\\n');\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.toString();\r\n    }\r\n}","import { IFunctionDefInstruction, IVariableDeclInstruction, ITypeInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { type } from \"@lib/fx/analisys/helpers\";\r\nimport { isNull } from \"@lib/common\";\r\n\r\nexport namespace fn {\r\n\r\n    function signatureParam(param: IVariableDeclInstruction, strong: boolean): string {\r\n        return `${type.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;\r\n    }\r\n\r\n    export function signature(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, params } = def;\r\n        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n    export function signatureEx(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, returnType, params } = def;\r\n        return `${type.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n\r\n    export function numArgsRequired(def: IFunctionDefInstruction): number {\r\n        return def.params.filter((param) => !param || !param.initExpr).length;\r\n    }\r\n\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function match(def: IFunctionDefInstruction, args: Array<ITypeInstruction | RegExp>, strong: boolean = false): boolean {\r\n        if (!strong && isNull(args)) {\r\n            return true;\r\n        }\r\n\r\n        if (args.length > def.params.length || numArgsRequired(def) > args.length) {\r\n            return false;\r\n        }\r\n\r\n        return args.every((arg, i) => \r\n            (!strong && isNull(arg)) ||\r\n            (!strong && isNull(def.params[i].type)) ||\r\n            type.equals(arg, def.params[i].type, strong)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function matchList(funcList: IFunctionDeclInstruction[],\r\n        args: Array<ITypeInstruction | RegExp>,\r\n        strong: boolean = false): IFunctionDeclInstruction | null | undefined {\r\n\r\n        if (!funcList) {\r\n            return null;\r\n        }\r\n\r\n        const res = funcList.filter(func => fn.match(func.def, args, strong));\r\n        if (res.length > 1) {\r\n            return undefined;\r\n        }\r\n\r\n        if (res.length === 1) {\r\n            return res[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","import { assert, isDef, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypeDeclInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypeDeclInstruction extends DeclInstruction implements ITypeDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypeDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypeDecl, ...settings });\r\n        this.type =  Instruction.$withParent(type, this);\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return this.type.toDeclString() + \";\";\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { expression, instruction, type, variable } from \"@lib/fx/analisys/helpers\";\r\nimport { DeclStmtInstruction } from \"@lib/fx/analisys/instructions/DeclStmtInstruction\";\r\nimport { ReturnStmtInstruction } from \"@lib/fx/analisys/instructions/ReturnStmtInstruction\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { T_BOOL, T_FLOAT, T_INT, T_UINT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { createFXSLDocument } from \"@lib/fx/FXSLDocument\";\r\nimport { EAddrType, EChunkType } from \"@lib/idl/bytecode\";\r\nimport { EOperation } from \"@lib/idl/bytecode/EOperations\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, IComplexExprInstruction, IConstructorCallInstruction, IExprInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, ILiteralInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IStmtBlockInstruction, IUnaryExprInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { i32ToU8Array } from \"./common\";\r\nimport { ContextBuilder, EErrors, IContext, TranslatorDiagnostics } from \"./Context\";\r\nimport { CDL } from \"./DebugLayout\";\r\nimport PromisedAddress from \"./PromisedAddress\";\r\nimport sizeof from \"./sizeof\";\r\n\r\nexport const CBUFFER0_REGISTER = 0;\r\nexport const INPUT0_REGISTER = 1;\r\nexport const UAV0_REGISTER = 17;\r\n\r\nexport const UAV_TOTAL = 33 - UAV0_REGISTER;\r\nexport const INPUT_TOTAL = UAV_TOTAL - INPUT0_REGISTER;\r\nexport const CBUFFER_TOTAL = INPUT0_REGISTER - CBUFFER0_REGISTER;\r\n\r\n\r\nconst UNRESOLVED_JUMP_LOCATION = -1;\r\n\r\n// TODO: rename as IProgramDocument\r\nexport interface ISubProgram {\r\n    code: Uint8Array;\r\n    cdl: CDL;\r\n\r\n    // diagnosticReport: IDiagnosticReport;\r\n    // uri: string\r\n}\r\n\r\nfunction writeString(u8data: Uint8Array, offset: number, value: string): number {\r\n    u8data.set(i32ToU8Array(value.length), offset);\r\n    offset += 4;\r\n\r\n    u8data.set(value.split('').map(c => c.charCodeAt(0)), offset);\r\n    offset += value.length;\r\n    return offset;\r\n}\r\n\r\nfunction writeInt(u8data: Uint8Array, offset: number, value: number): number {\r\n    u8data.set(i32ToU8Array(value), offset);\r\n    offset += 4;\r\n    return offset;\r\n}\r\n\r\n// TODO: rewrite with cleaner code\r\nfunction constLayoutChunk(ctx: IContext): ArrayBuffer {\r\n    const { constants } = ctx;\r\n    const reflection = constants.dump();\r\n    const byteLength =\r\n        4/* names.length */ +\r\n        reflection.map(entry =>\r\n            entry.name.length +\r\n            entry.type.length +\r\n            entry.semantic.length +\r\n            4 + /* sizeof(name.length) */\r\n            4 + /* sizeof(type.length) */\r\n            4 + /* sizeof(semantic.length) */\r\n            4 + /* sizeof(addr) */\r\n            4 + /* sizeof(size) */\r\n            4   /* sizeof(type.length) */\r\n        ).reduce((prev, curr) => prev + curr, 0);\r\n\r\n    const size = (byteLength + 4) >> 2;\r\n    const chunkHeader = [EChunkType.k_Layout, size];\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n\r\n    const u8data = new Uint8Array(data.buffer, 8/* int header type + int size */);\r\n    let written = writeInt(u8data, 0, reflection.length);\r\n    for (let i = 0; i < reflection.length; ++i) {\r\n        const { name, offset, type, size, semantic } = reflection[i];\r\n        written = writeString(u8data, written, name);\r\n        written = writeString(u8data, written, type);\r\n        written = writeString(u8data, written, semantic || '');\r\n        written = writeInt(u8data, written, offset);\r\n        written = writeInt(u8data, written, size);\r\n    }\r\n    // console.log('after write', u8data.length, 'bytes', written);\r\n    return data.buffer;\r\n}\r\n\r\nfunction constChunk(ctx: IContext): ArrayBuffer {\r\n    const { constants } = ctx;\r\n    const mem = constants.data;\r\n    const size = mem.byteLength >> 2;\r\n    const chunkHeader = [EChunkType.k_Constants, size];\r\n    assert((size << 2) == mem.byteLength);\r\n    const data = new Uint32Array(chunkHeader.length + size);\r\n    data.set(chunkHeader);\r\n    data.set(new Uint32Array(mem.byteArray.buffer, 0, mem.byteLength >> 2), chunkHeader.length);\r\n    return data.buffer;\r\n}\r\n\r\n\r\nfunction codeChunk(ctx: IContext): ArrayBuffer {\r\n    const { instructions } = ctx;\r\n    const chunkHeader = [EChunkType.k_Code, instructions.length];\r\n    const data = new Uint32Array(chunkHeader.length + instructions.length);\r\n    data.set(chunkHeader);\r\n    data.set(instructions.data, chunkHeader.length);\r\n    return data.buffer;\r\n}\r\n\r\nfunction binary(ctx: IContext): Uint8Array {\r\n    const chunks = [constLayoutChunk(ctx), constChunk(ctx), codeChunk(ctx)].map(ch => new Uint8Array(ch));\r\n    const byteLength = chunks.map(x => x.byteLength).reduce((a, b) => a + b);\r\n    let data = new Uint8Array(byteLength);\r\n    let offset = 0;\r\n    chunks.forEach(ch => {\r\n        data.set(ch, offset);\r\n        offset += ch.byteLength;\r\n    });\r\n    return data;\r\n}\r\n\r\n\r\n\r\nfunction translateProgram(ctx: IContext, fn: IFunctionDeclInstruction): ISubProgram {\r\n    const { constants, debug, alloca, push, pop, addr, imove, ref } = ctx;\r\n\r\n    // NOTE: it does nothing at the momemt :/\r\n    debug.beginCompilationUnit('[todo]', fn.def.returnType);\r\n    // simulate function call()\r\n    const fdef = fn.def;\r\n    let ret = alloca(fdef.returnType.size);\r\n    push(fn, ret);\r\n\r\n    // TODO: use the same code as FunctionCall;\r\n    // loading of all non-inpt parameters to registers\r\n    for (let i = 0; i < fdef.params.length; ++i) {\r\n        const param = fdef.params[i];\r\n        if (param.type.hasUsage('out') || param.type.hasUsage('inout')) {\r\n            continue;\r\n        }\r\n\r\n        const inputIndex = variable.parameterIndex(param) + INPUT0_REGISTER;\r\n        const size = param.type.size;\r\n        const src = addr.loc({ type: EAddrType.k_Input, inputIndex, addr: 0, size });\r\n        const dest = alloca(size);\r\n        imove(dest, src);\r\n        debug.map(fdef); // FIXME: is it ok?\r\n        ref(param, dest);\r\n    }\r\n\r\n    translateUnknown(ctx, fn);\r\n    pop();\r\n    debug.endCompilationUnit();\r\n\r\n    let code = binary(ctx);         // TODO: stay only binary view\r\n    let cdl = debug.dump();         // code debug layout;\r\n\r\n    return {\r\n        code,           // final binary pack\r\n        cdl             // same as PDB\r\n    };\r\n}\r\n\r\nfunction translateUnknown(ctx: IContext, instr: IInstruction): void {\r\n    const {\r\n        pc,\r\n        diag,\r\n        constants,\r\n        uavs,\r\n        alloca,\r\n        addr,\r\n        debug,\r\n        push,\r\n        pop,\r\n        open,\r\n        close,\r\n        deref,\r\n        ref,\r\n        icode,\r\n        imove,\r\n        iop4,\r\n        iop3,\r\n        iop2,\r\n        iop1,\r\n        iload,\r\n        iconst_i32,\r\n        iconst_f32,\r\n        ret,\r\n        depth,\r\n        instructions\r\n    } = ctx;\r\n\r\n\r\n    // NOTE: pc - number of written instructions\r\n    // NOTE: rc - number of occupied registers\r\n\r\n    const isEntryPoint = () => depth() === 1;\r\n\r\n    type ArithmeticOp = IArithmeticExprInstruction['operator'];\r\n\r\n    const intrinsics = {\r\n\r\n        /**\r\n         * Float based arithmetics\r\n         * vector [op] vector | vector [op] scalar | scalar [op] vector\r\n         */\r\n        arithf(opName: ArithmeticOp, dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            const size = Math.max(left.size, right.size);\r\n            const n = size / sizeof.f32();\r\n\r\n            // handle case: scalar * vector => scalar.xxxx * vector\r\n            if (left.size != right.size) {\r\n                if (left.size === sizeof.f32()) {\r\n                    left = addr.override(left, Array(n).fill(0));\r\n                } else if (right.size === sizeof.f32()) {\r\n                    right = addr.override(right, Array(n).fill(0));\r\n                } else {\r\n                    assert(false, 'vectors with differen length cannot be multipled');\r\n                }\r\n            }\r\n\r\n            const opFloatMap = {\r\n                '+': EOperation.k_F32Add,\r\n                '-': EOperation.k_F32Sub,\r\n                '*': EOperation.k_F32Mul,\r\n                '/': EOperation.k_F32Div\r\n            };\r\n\r\n            const op: EOperation = opFloatMap[opName];\r\n            if (!isDef(op)) {\r\n                diag.error(EErrors.k_UnsupportedArithmeticExpr, {});\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            iop3(op, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        // TODO: merhe with function above\r\n        arithi(opName: ArithmeticOp, dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            const size = Math.max(left.size, right.size);\r\n            const n = size / sizeof.f32();\r\n\r\n            // handle case: scalar * vector => scalar.xxxx * vector\r\n            if (left.size !== right.size) {\r\n                if (left.size === sizeof.f32()) {\r\n                    left = addr.override(left, Array(n).fill(0));\r\n                } else if (right.size === sizeof.f32()) {\r\n                    right = addr.override(right, Array(n).fill(0));\r\n                } else {\r\n                    assert(false, 'vectors with differen length cannot be multipled');\r\n                }\r\n            }\r\n\r\n            const opIntMap = {\r\n                '+': EOperation.k_I32Add,\r\n                '-': EOperation.k_I32Sub,\r\n                '*': EOperation.k_I32Mul,\r\n                '/': EOperation.k_I32Div\r\n            }\r\n\r\n            const op: EOperation = opIntMap[opName];\r\n            if (!isDef(op)) {\r\n                diag.error(EErrors.k_UnsupportedArithmeticExpr, {});\r\n                return PromisedAddress.INVALID;\r\n            }\r\n\r\n            iop3(op, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        mulf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('*', dest, left, right),\r\n        divf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('/', dest, left, right),\r\n        addf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('+', dest, left, right),\r\n        subf: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithf('-', dest, left, right),\r\n\r\n        muli: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('*', dest, left, right),\r\n        divi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('/', dest, left, right),\r\n        addi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('+', dest, left, right),\r\n        subi: (dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress) => intrinsics.arithi('-', dest, left, right),\r\n\r\n        dotf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            let temp = alloca(Math.max(left.size, right.size));\r\n            let mlr = intrinsics.mulf(temp, left, right);\r\n            let n = mlr.size / sizeof.f32();\r\n\r\n            // copy first element of 'mlr' to dest\r\n            imove(dest, addr.shrink(mlr, sizeof.f32()));\r\n            for (let i = 1; i < n; ++i) {\r\n                let padding = i * sizeof.f32();\r\n                let size = sizeof.f32();\r\n                intrinsics.addf(dest, dest, addr.sub(mlr, padding, size));\r\n            }\r\n\r\n            return dest;\r\n        },\r\n\r\n        /** dest = a + b * c */\r\n        madi(dest: PromisedAddress, a: PromisedAddress, b: PromisedAddress, c: PromisedAddress): PromisedAddress {\r\n            iop4(EOperation.k_I32Mad, dest, a, b, c);\r\n            return dest;\r\n        },\r\n\r\n        noti(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_I32Not, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        mini(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_I32Min, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        maxi(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_I32Max, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        fracf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Frac, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        floorf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Floor, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        ceilf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Ceil, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        sinf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Sin, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        cosf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Cos, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        absf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Abs, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        sqrtf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            iop2(EOperation.k_F32Sqrt, dest, src);\r\n            return dest;\r\n        },\r\n\r\n        minf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Min, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        maxf(dest: PromisedAddress, left: PromisedAddress, right: PromisedAddress): PromisedAddress {\r\n            iop3(EOperation.k_F32Max, dest, left, right);\r\n            return dest;\r\n        },\r\n\r\n        lengthf(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            intrinsics.dotf(dest, src, src);\r\n            intrinsics.sqrtf(dest, dest);\r\n            return dest;\r\n        },\r\n\r\n        normalizef(dest: PromisedAddress, src: PromisedAddress): PromisedAddress {\r\n            const len = alloca(sizeof.f32());\r\n            intrinsics.lengthf(len, src);\r\n            intrinsics.divf(dest, src, len);\r\n            return dest;\r\n        },\r\n\r\n        lerpf(dest: PromisedAddress, from: PromisedAddress, to: PromisedAddress, k: PromisedAddress): PromisedAddress {\r\n            assert(from.size === to.size);\r\n\r\n            const size = from.size;\r\n            const n = size / sizeof.f32();\r\n            const swizzle = Array(n).fill(0);\r\n\r\n            let one = iconst_f32(1.0);\r\n            // todo: fix bu with vectored koef.\r\n            let kInv: PromisedAddress;\r\n            if (k.size === sizeof.f32()) {\r\n                kInv = intrinsics.subf(one, one, k);\r\n            } else {\r\n                assert(k.size === from.size);\r\n                one = addr.override(one, swizzle);\r\n                kInv = intrinsics.subf(alloca(dest.size), one, k);\r\n            }\r\n\r\n            let temp = alloca(size);\r\n\r\n            intrinsics.mulf(temp, to, k);\r\n            intrinsics.mulf(dest, from, kInv);\r\n            intrinsics.addf(dest, dest, temp);\r\n\r\n            return dest;\r\n        }\r\n    }\r\n\r\n\r\n    function resolveAddressType(decl: IVariableDeclInstruction): EAddrType {\r\n        if (decl.isParameter()) {\r\n            if (decl.type.hasUsage('out') || decl.type.hasUsage('inout')) {\r\n                // entry point function can refer to input memory, for ex. vertex shader\r\n                return isEntryPoint() ? EAddrType.k_Input : EAddrType.k_Registers;\r\n            }\r\n        }\r\n\r\n        if (decl.isGlobal()) {\r\n            if (decl.type.isUniform()) {\r\n                return EAddrType.k_Input;\r\n            }\r\n            if (decl.type.isUAV()) {\r\n                return EAddrType.k_Input;\r\n            }\r\n            assert(false, `could not resolve address type for '${decl.toCode()}'`);\r\n        }\r\n\r\n        assert(decl.isLocal());\r\n        return EAddrType.k_Registers;\r\n    }\r\n\r\n    const POSTFIX_COMPONENT_MAP = {\r\n        'r': 0, 'x': 0, 's': 0,\r\n        'g': 1, 'y': 1, 't': 1,\r\n        'b': 2, 'z': 2, 'p': 2,\r\n        'a': 3, 'w': 3, 'q': 3\r\n    };\r\n\r\n    const checkPostfixNameForSwizzling = (postfixName: string) =>\r\n        postfixName\r\n            .split('')\r\n            .map(c => POSTFIX_COMPONENT_MAP[c])\r\n            .map(i => i >= 0 && i < 4)\r\n            .reduce((accum, val) => accum && val);\r\n\r\n    // xxwy => [0, 0, 3, 1]\r\n    const swizzlePatternFromName = (postfixName: string) =>\r\n        postfixName.split('').map(c => POSTFIX_COMPONENT_MAP[c]);\r\n\r\n    // const swizzlePatternFromPadding = (padding: number, size: number) => {\r\n    //     assert(padding % sizeof.i32() === 0);\r\n    //     assert(size % sizeof.i32() === 0);\r\n\r\n    //     return [...Array(size / sizeof.i32()).keys()].map(i => i + padding / sizeof.i32());\r\n    // };\r\n\r\n\r\n    function iintrinsic(call: IFunctionCallInstruction): PromisedAddress {\r\n        const fdecl = call.decl as IFunctionDeclInstruction;\r\n        const fdef = fdecl.def;\r\n        const retType = fdef.returnType;\r\n\r\n        const dest = alloca(retType.size);\r\n\r\n        let forceLoadArgumentsToRegisters: boolean;\r\n\r\n        switch (fdecl.name) {\r\n            case 'InterlockedAdd':\r\n                // expected InterlockedAdd(UAV pointer [uint/int], any [uint/int], any [uint/int])\r\n                forceLoadArgumentsToRegisters = false;\r\n                break;\r\n            default:\r\n                forceLoadArgumentsToRegisters = true;\r\n        }\r\n\r\n\r\n        const args = preloadArguments(fdef, forceLoadArgumentsToRegisters);\r\n        // TODO: add support for INT type\r\n\r\n        function preloadArguments(fdef: IFunctionDefInstruction, forceLoad: boolean): PromisedAddress[] {\r\n            const args: PromisedAddress[] = [];\r\n            for (let i = 0; i < fdef.params.length; ++i) {\r\n                const arg = call.args[i];\r\n                let argAddr = raddr(arg);\r\n                if (argAddr.type !== EAddrType.k_Registers && forceLoad) {\r\n                    argAddr = iload(argAddr);\r\n                }\r\n                args.push(argAddr);\r\n            }\r\n            return args;\r\n        }\r\n\r\n        switch (fdecl.name) {\r\n            case 'asuint':\r\n            case 'asfloat':\r\n            case 'asint':\r\n                // NOTE: nothing todo\r\n                assert(fdef.params.length === 1);\r\n                return args[0];\r\n            case 'mul':\r\n                assert(fdef.params.length === 2);\r\n                return intrinsics.mulf(dest, args[0], args[1]);\r\n            case 'dot':\r\n                assert(fdef.params.length === 2 && dest.size === sizeof.f32());\r\n                return intrinsics.dotf(dest, args[0], args[1]);\r\n            case 'frac':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.fracf(dest, args[0]);\r\n            case 'sin':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.sinf(dest, args[0]);\r\n            case 'cos':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.cosf(dest, args[0]);\r\n            case 'abs':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.absf(dest, args[0]);\r\n            case 'sqrt':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.sqrtf(dest, args[0]);\r\n            case 'normalize':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.normalizef(dest, args[0]);\r\n            case 'length':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.lengthf(dest, args[0]);\r\n            case 'floor':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.floorf(dest, args[0]);\r\n            case 'ceil':\r\n                assert(fdef.params.length === 1);\r\n                return intrinsics.ceilf(dest, args[0]);\r\n            case 'min':\r\n                // TODO: separate INT/FLOAT intrisics\r\n                if (SystemScope.isFloatBasedType(fdef.params[0].type)) {\r\n                    assert(fdef.params.length === 2);\r\n                    return intrinsics.minf(dest, args[0], args[1]);\r\n                }\r\n                assert(SystemScope.isIntBasedType(fdef.params[0].type) || SystemScope.isUIntBasedType(fdef.params[0].type));\r\n                // handle INT/UINT params as int intrinsic\r\n                return intrinsics.mini(dest, args[0], args[1]);\r\n            case 'max':\r\n                // TODO: separate INT/FLOAT intrisics\r\n                if (SystemScope.isFloatBasedType(fdef.params[0].type)) {\r\n                    assert(fdef.params.length === 2);\r\n                    return intrinsics.maxf(dest, args[0], args[1]);\r\n                }\r\n                assert(SystemScope.isIntBasedType(fdef.params[0].type) || SystemScope.isUIntBasedType(fdef.params[0].type));\r\n                // handle INT/UINT params as int intrinsic\r\n                return intrinsics.maxi(dest, args[0], args[1]);\r\n            case 'lerp':\r\n                assert(fdef.params.length === 3);\r\n                return intrinsics.lerpf(dest, args[0], args[1], args[2]);\r\n\r\n            case 'InterlockedAdd':\r\n                {\r\n                    assert(fdef.params.length === 3);\r\n\r\n                    assert(args[0].type === EAddrType.k_PointerInput, 'destination must be UAV address');\r\n                    assert(args[0].size === sizeof.i32(), 'only int/uint values are supported');\r\n\r\n                    if (args[1].type !== EAddrType.k_Registers) {\r\n                        args[1] = iload(args[1]);\r\n                    }\r\n\r\n                    let originalAddr = args[2];\r\n                    if (args[2].type !== EAddrType.k_Registers) {\r\n                        originalAddr = alloca(sizeof.i32());\r\n                    }\r\n\r\n                    imove(originalAddr, args[0]);\r\n\r\n                    const changedAddr = intrinsics.addi(alloca(sizeof.i32()), originalAddr, args[1]);\r\n                    imove(args[0], changedAddr);\r\n\r\n                    if (args[2] !== originalAddr) {\r\n                        imove(args[2], originalAddr);\r\n                    }\r\n\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n\r\n            //\r\n            // UAVs\r\n            //\r\n\r\n            /** @returns: The post-decremented counter value. */\r\n            case 'DecrementCounter':\r\n                {\r\n                    const uav = call.callee;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n                    const valueAddr = iload(uavCounterAddr);\r\n                    const nextValueAddr = intrinsics.addi(alloca(sizeof.i32()), valueAddr, iconst_i32(-1));\r\n                    imove(uavCounterAddr, nextValueAddr);\r\n                    return nextValueAddr;\r\n                }\r\n            /** @returns: The pre-incremented counter value. */\r\n            case 'IncrementCounter':\r\n                {\r\n                    const uav = call.callee;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n                    const valueAddr = iload(uavCounterAddr);\r\n                    const nextValueAddr = intrinsics.addi(alloca(sizeof.i32()), valueAddr, iconst_i32(+1));\r\n                    imove(uavCounterAddr, nextValueAddr);\r\n                    return valueAddr;\r\n                }\r\n                return PromisedAddress.INVALID;\r\n            case 'Append':\r\n                {\r\n                    const { callee: uav, args } = call;\r\n                    const uavAddr = raddr(uav);\r\n                    const uavCounterAddr = addr.shrink(uavAddr, sizeof.i32());\r\n\r\n                    assert(args.length === 1);\r\n                    const srcAddr = raddr(args[0]);\r\n                    const valueAddr = iload(uavCounterAddr);\r\n\r\n                    const arrayElementSize = args[0].type.size;\r\n\r\n                    const uavDataAddr = addr.sub(uavAddr, sizeof.i32());\r\n                    const elementPointer = addr.subPointer(uavDataAddr, valueAddr, arrayElementSize);\r\n\r\n                    imove(elementPointer, srcAddr);\r\n\r\n                    // TODO: replace with intrinsics.inc();\r\n                    intrinsics.addi(valueAddr, valueAddr, iconst_i32(1));\r\n                    imove(uavCounterAddr, valueAddr);\r\n\r\n                    return elementPointer;\r\n                }\r\n                return PromisedAddress.INVALID;\r\n        }\r\n\r\n        assert(false, `unsupported intrinsic found '${fdecl.name}'`);\r\n        return PromisedAddress.INVALID;\r\n    }\r\n\r\n\r\n    /** resolve address => returns address of temprary result of expression */\r\n    function raddr(expr: IExprInstruction): PromisedAddress {\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_InitExpr:\r\n                {\r\n                    const init = expr as IInitExprInstruction;\r\n\r\n                    if (init.isArray()) {\r\n                        diag.error(EErrors.k_UnsupportedExprType, {});\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    let arg = init.args[0];\r\n                    return raddr(arg);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_BoolExpr:\r\n                {\r\n                    const i32 = (expr as ILiteralInstruction<boolean>).value ? 1 : 0;\r\n                    return iconst_i32(i32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_IntExpr:\r\n                {\r\n                    const i32 = (expr as ILiteralInstruction<number>).value;\r\n                    return iconst_i32(i32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_FloatExpr:\r\n                {\r\n                    const f32 = (expr as ILiteralInstruction<number>).value;\r\n                    return iconst_f32(f32);\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_IdExpr:\r\n                {\r\n                    let id = (expr as IIdExprInstruction);\r\n                    assert(id.decl === expression.unwind(id));\r\n\r\n                    const size = id.decl.type.size;\r\n                    const decl = expression.unwind(id);\r\n                    const addrType = resolveAddressType(decl);\r\n\r\n                    switch (addrType) {\r\n                        case EAddrType.k_Registers:\r\n                            {\r\n                                return deref(id.decl);\r\n                            }\r\n                        case EAddrType.k_Input:\r\n                            {\r\n                                // CBUFFER0_REGISTER input is always being used for hidden constant buffer (uniform constants)\r\n                                if (decl.type.isUniform()) {\r\n                                    return constants.deref(decl);\r\n                                }\r\n\r\n\r\n                                if (decl.type.isUAV()) {\r\n                                    return uavs.deref(decl);\r\n                                }\r\n\r\n                                // implies that each parameter is loaded from its stream, so \r\n                                // the offset is always zero. \r\n                                // Otherwise use 'variable.getParameterOffset(decl);'\r\n                                // in order to determ correct offset between parameters\r\n                                const offset = 0;\r\n                                const src = offset;\r\n                                const inputIndex = variable.parameterIndex(decl) + INPUT0_REGISTER;\r\n                                assert(variable.parameterIndex(decl) < INPUT_TOTAL);\r\n                                return addr.loc({ inputIndex, addr: src, size, type: addrType });\r\n                            }\r\n                    }\r\n\r\n                    assert(false, 'unsupported branch found');\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return raddr((expr as IComplexExprInstruction).expr);\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                {\r\n                    const arithExpr = expr as IArithmeticExprInstruction;\r\n                    const dest = alloca(arithExpr.type.size);\r\n\r\n                    const opName = arithExpr.operator;\r\n                    const left = arithExpr.left;\r\n                    const right = arithExpr.right;\r\n\r\n                    assert(SystemScope.isScalarType(left.type) || SystemScope.isVectorType(left.type));\r\n                    assert(SystemScope.isScalarType(right.type) || SystemScope.isVectorType(right.type));\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    if (SystemScope.isFloatBasedType(left.type)) {\r\n                        assert(SystemScope.isFloatBasedType(right.type));\r\n                        intrinsics.arithf(opName, dest, leftAddr, rightAddr);\r\n                    } else if (SystemScope.isIntBasedType(left.type) || SystemScope.isUIntBasedType(left.type)) {\r\n                        assert(SystemScope.isIntBasedType(right.type) || SystemScope.isUIntBasedType(right.type));\r\n                        intrinsics.arithi(opName, dest, leftAddr, rightAddr);\r\n                    } else {\r\n                        assert(false);\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    debug.map(arithExpr);\r\n                    return dest;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                {\r\n                    const assigment = expr as IAssignmentExprInstruction;\r\n                    const size = assigment.type.size;\r\n                    assert(size % sizeof.i32() === 0);\r\n                    assert(assigment.operator === '=');\r\n\r\n                    // left address can be both from the registers and in the external memory\r\n                    const leftAddr = raddr(assigment.left);\r\n\r\n                    assert(instruction.isExpression(assigment.right), EInstructionTypes[assigment.right.instructionType]);\r\n                    // right address always from the registers\r\n                    let rightAddr = raddr(<IExprInstruction>assigment.right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(assigment.right);\r\n                    }\r\n\r\n                    imove(leftAddr, rightAddr);\r\n                    debug.map(assigment);\r\n                    // breakpoint right after assingment\r\n                    debug.ns();\r\n                    return leftAddr;\r\n                }\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                {\r\n                    const postfix = expr as IPostfixArithmeticInstruction;\r\n                    const operand = postfix.expr;\r\n                    const op = postfix.operator;\r\n                    const size = postfix.type.size;\r\n\r\n                    let src = raddr(operand);\r\n                    if (src.type !== EAddrType.k_Registers) {\r\n                        src = iload(src);\r\n                    }\r\n\r\n                    if (SystemScope.isIntBasedType(operand.type)) {\r\n                        switch (op) {\r\n                            case '++':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithi('+', src, src, iconst_i32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithi('-', src, src, iconst_i32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    } else {\r\n                        switch (op) {\r\n                            case '++':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithf('+', src, src, iconst_f32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = imove(alloca(size), src);\r\n                                    intrinsics.arithf('-', src, src, iconst_f32(1));\r\n                                    debug.map(postfix);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    }\r\n\r\n                    console.error(`unsupported type of unary expression found: '${op}'(${postfix.toCode()})`);\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                {\r\n                    const unary = expr as IUnaryExprInstruction;\r\n                    const operand = unary.expr;\r\n                    const op = unary.operator;\r\n                    const size = unary.type.size;\r\n\r\n                    let src = raddr(operand);\r\n                    if (src.type !== EAddrType.k_Registers) {\r\n                        src = iload(src);\r\n                    }\r\n\r\n                    if (SystemScope.isBoolBasedType(operand.type)) {\r\n                        if (op === '!') {\r\n                            const dest = intrinsics.noti(alloca(size), src);\r\n                            debug.map(unary);\r\n                            return dest;\r\n                        }\r\n                    }\r\n\r\n                    if (SystemScope.isIntBasedType(operand.type)) {\r\n                        switch (op) {\r\n                            case '-':\r\n                                {\r\n                                    const dest = intrinsics.arithi('*', alloca(size), src, iconst_i32(-1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '+':\r\n                                // nothing todo\r\n                                return src;\r\n                            case '++':\r\n                                {\r\n                                    const dest = intrinsics.arithi('+', src, src, iconst_i32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = intrinsics.arithi('-', src, src, iconst_i32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    } else {\r\n                        switch (op) {\r\n                            case '-':\r\n                                {\r\n                                    const dest = intrinsics.arithf('*', alloca(size), src, iconst_f32(-1.0));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '++':\r\n                                {\r\n                                    const dest = intrinsics.arithf('+', src, src, iconst_f32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            case '--':\r\n                                {\r\n                                    const dest = intrinsics.arithf('-', src, src, iconst_f32(1));\r\n                                    debug.map(unary);\r\n                                    return dest;\r\n                                }\r\n                            // fall to unsupported warning\r\n                        }\r\n                    }\r\n                    console.error(`unsupported type of unary expression found: '${op}'(${unary.toCode()})`);\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n            case EInstructionTypes.k_LogicalExpr:\r\n                {\r\n                    const logicExpr = expr as ILogicalExprInstruction;\r\n\r\n                    const opMap = {\r\n                        '||': EOperation.k_I32LogicalOr,\r\n                        '&&': EOperation.k_I32LogicalAnd\r\n                    };\r\n\r\n                    let op: EOperation = opMap[logicExpr.operator];;\r\n\r\n                    const { left, right } = logicExpr;\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    const size = logicExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    iop3(op, dest, leftAddr, rightAddr);\r\n                    debug.map(logicExpr);\r\n\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                {\r\n                    const relExpr = expr as IRelationalExprInstruction;\r\n\r\n                    const opUintMap = {\r\n                        '<': EOperation.k_U32LessThan,          //lt\r\n                        '>=': EOperation.k_U32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // << compare with I32 operator\r\n                        '!=': EOperation.k_I32NotEqual          // << compare with I32 operator\r\n                    }\r\n\r\n                    const opIntMap = {\r\n                        '<': EOperation.k_I32LessThan,          //lt\r\n                        '>=': EOperation.k_I32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // eq\r\n                        '!=': EOperation.k_I32NotEqual          // ne\r\n                    };\r\n\r\n                    const opFloatMap = {\r\n                        '<': EOperation.k_F32LessThan,          // lt\r\n                        '>=': EOperation.k_F32GreaterThanEqual, // ge\r\n                        '==': EOperation.k_I32Equal,            // << compare with I32 operator\r\n                        '!=': EOperation.k_I32NotEqual          // << compare with I32 operator\r\n                    };\r\n\r\n                    let op: EOperation;\r\n                    let { left, right } = relExpr;\r\n                    let operator = relExpr.operator;\r\n\r\n                    // (left > right) => (right < left)\r\n                    if (operator === '>') {\r\n                        operator = '<';\r\n                        [right, left] = [left, right];\r\n                    }\r\n\r\n                    // (left <= right) => (right >= left)\r\n                    if (operator === '<=') {\r\n                        operator = '>=';\r\n                        [right, left] = [left, right];\r\n                    }\r\n\r\n\r\n                    if (left.type.isEqual(T_INT)) {\r\n                        op = opIntMap[operator];\r\n\r\n                        // print warning if right type is UINT;\r\n                        if (!right.type.isEqual(T_INT) && !right.type.isEqual(T_UINT)) {\r\n                            diag.error(EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (left.type.isEqual(T_UINT)) {\r\n                        op = opUintMap[operator];\r\n\r\n                        // print warning if right type is INT;\r\n                        if (!right.type.isEqual(T_UINT) && !right.type.isEqual(T_INT)) {\r\n                            diag.error(EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (left.type.isEqual(T_FLOAT)) {\r\n                        op = opFloatMap[operator];\r\n\r\n                        if (!right.type.isEqual(T_FLOAT)) {\r\n                            diag.error(EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (left.type.isEqual(T_BOOL)) {\r\n                        op = opIntMap[operator];\r\n                        if (!right.type.isEqual(T_BOOL)) {\r\n                            diag.error(EErrors.k_UnsupportedRelationalExpr, {});\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    }\r\n\r\n                    if (!op) {\r\n                        diag.error(EErrors.k_UnsupportedRelationalExpr, {});\r\n                        return PromisedAddress.INVALID;\r\n                    }\r\n\r\n                    let leftAddr = raddr(left);\r\n                    if (leftAddr.type !== EAddrType.k_Registers) {\r\n                        leftAddr = iload(leftAddr);\r\n                        debug.map(left);\r\n                    }\r\n\r\n                    let rightAddr = raddr(right);\r\n                    if (rightAddr.type !== EAddrType.k_Registers) {\r\n                        rightAddr = iload(rightAddr);\r\n                        debug.map(right);\r\n                    }\r\n\r\n                    const size = relExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    iop3(op, dest, leftAddr, rightAddr);\r\n                    debug.map(relExpr);\r\n\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_CastExpr:\r\n                {\r\n                    const castExpr = expr as ICastExprInstruction;\r\n\r\n                    if (castExpr.isUseless()) {\r\n                        console.warn(`Useless cast found: ${castExpr.toCode()}`);\r\n                        return raddr(castExpr.expr);\r\n                    }\r\n\r\n                    const srcType = castExpr.expr.type;\r\n                    const dstType = castExpr.type;\r\n\r\n                    let op: EOperation;\r\n\r\n                    // TODO: add support for vectors\r\n\r\n                    if (dstType.isEqual(T_BOOL)) {\r\n                        const size = castExpr.type.size;\r\n                        const dest = alloca(size);\r\n                        let exprAddr = raddr(castExpr.expr);\r\n                        if (exprAddr.type !== EAddrType.k_Registers) {\r\n                            exprAddr = iload(exprAddr);\r\n                        }\r\n\r\n                        iop3(EOperation.k_I32NotEqual, dest, exprAddr, iconst_i32(0));\r\n                        debug.map(castExpr);\r\n                        return addr.loc({ addr: dest, size });\r\n                    }\r\n\r\n\r\n                    if (srcType.isEqual(T_FLOAT)) {\r\n                        if (dstType.isEqual(T_INT)) {\r\n                            op = EOperation.k_F32ToI32;\r\n                        } else if (dstType.isEqual(T_UINT)) {\r\n                            op = EOperation.k_F32ToU32;\r\n                        } else {\r\n                            diag.error(EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (srcType.isEqual(T_INT)) {\r\n                        if (dstType.isEqual(T_FLOAT)) {\r\n                            op = EOperation.k_I32ToF32;\r\n                        } else if (dstType.isEqual(T_UINT)) {\r\n                            // useless conversion\r\n                            return raddr(castExpr.expr);\r\n                        } else {\r\n                            diag.error(EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    } else if (srcType.isEqual(T_UINT)) {\r\n                        if (dstType.isEqual(T_FLOAT)) {\r\n                            op = EOperation.k_U32ToF32;\r\n                        } else if (dstType.isEqual(T_INT)) {\r\n                            // useless conversion\r\n                            return raddr(castExpr.expr);\r\n                        } else {\r\n                            diag.error(EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });\r\n                            return PromisedAddress.INVALID;\r\n                        }\r\n                    }\r\n\r\n                    const size = castExpr.type.size;\r\n                    const dest = alloca(size);\r\n                    let exprAddr = raddr(castExpr.expr);\r\n                    if (exprAddr.type !== EAddrType.k_Registers) {\r\n                        exprAddr = iload(exprAddr);\r\n                    }\r\n                    iop2(op, dest, exprAddr);\r\n                    debug.map(castExpr);\r\n                    return addr.loc({ addr: dest, size });\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                {\r\n                    const postfixIndex = expr as IPostfixIndexInstruction;\r\n                    // element[index]\r\n                    const { element, index } = postfixIndex;\r\n\r\n                    assert(type.equals(index.type, T_INT) || type.equals(index.type, T_UINT));\r\n                    // assert(element.type.isNotBaseArray());\r\n                    assert(!isNull(element.type.arrayElementType));\r\n\r\n                    if (/*index.isConstExpr()*/false) {\r\n                        // TODO: implement constexpr branch\r\n                    } else {\r\n                        let elementAddr = raddr(element);\r\n                        // NOTE: element can be not loaded yet\r\n                        //       we don't want to load all the array (all 'element' object)\r\n\r\n                        if (element.type.isUAV()) {\r\n                            // some UAVs can have hidden counter at the beginning of the data\r\n                            // in such cases we need to step forward before fetching the data\r\n                            elementAddr = addr.sub(elementAddr, sizeof.i32());\r\n                        }\r\n\r\n                        // sizeof(element[i])\r\n                        let arrayElementSize = element.type.arrayElementType.size;\r\n                        assert(arrayElementSize % sizeof.i32() === 0, `all sizes must be multiple of ${sizeof.i32()}`);\r\n\r\n                        // index => index of element in the array (element)\r\n                        let indexAddr = raddr(index);\r\n                        // NOTE: index can be unresolved yet\r\n\r\n                        const dest = addr.subPointer(elementAddr, indexAddr, arrayElementSize);\r\n                        debug.map(postfixIndex);\r\n                        return dest;\r\n                    }\r\n\r\n                    return PromisedAddress.INVALID; // << FIXME\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                {\r\n                    const point = expr as IPostfixPointInstruction;\r\n                    const { element, postfix } = point;\r\n                    const elementAddr = raddr(element);\r\n\r\n                    let { size, padding } = postfix.type;\r\n                    let swizzle: number[] = null;\r\n\r\n                    // Does expression have dynamic indexing?\r\n                    // TODO: rename isConstExpr() method to something more suitable\r\n                    if (point.isConstExpr()) {\r\n\r\n                        // handle such types like float2, float3, int2, int3 etc.\r\n                        // all system types except matrix and samplers support swizzling\r\n                        const isSwizzlingSupported = SystemScope.isVectorType(element.type) ||\r\n                            SystemScope.isScalarType(element.type);\r\n\r\n                        if (isSwizzlingSupported) {\r\n                            assert(checkPostfixNameForSwizzling(postfix.name));\r\n                            swizzle = swizzlePatternFromName(postfix.name);\r\n\r\n                            assert(padding === instruction.UNDEFINE_PADDING, 'padding of swizzled components must be undefined');\r\n                            \r\n                            // If loading not allowed then we are inside the recursive call to calculate the final address\r\n                            // so in this case we just have to return address with padding added to it.\r\n                            return addr.override(elementAddr, swizzle);\r\n                        } else {\r\n                            return addr.sub(elementAddr, padding, size);\r\n                        }   \r\n                    }\r\n\r\n                    assert(false, 'not implemented!');\r\n\r\n                    // todo: add support for move_reg_ptr, move_ptr_ptr, move_ptr_reg\r\n                    return elementAddr;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                {\r\n                    const call = expr as IFunctionCallInstruction;\r\n                    const fdecl = call.decl;\r\n                    const fdef = fdecl.def;\r\n                    const retType = fdef.returnType;\r\n\r\n                    if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                        // breakpoint before intrinsic call\r\n                        // TODO: is it's breakpoint really usefull?\r\n                        debug.ns();\r\n                        const dest = iintrinsic(call);\r\n                        debug.map(call);\r\n                        return dest;\r\n                    }\r\n\r\n                    const ret = alloca(retType.size);\r\n\r\n                    const params = fdef.params;\r\n                    const args = params\r\n                        .map((param, i) => i < call.args.length ? call.args[i] : param.initExpr);\r\n                    const paramSources = args\r\n                        .map(arg => raddr(arg))\r\n                        .map(arg => arg.type === EAddrType.k_Registers ? arg : iload(arg));\r\n\r\n                    push(fdecl, ret);\r\n\r\n                    for (let i = 0; i < fdef.params.length; ++i) {\r\n                        const src = paramSources[i];\r\n\r\n                        // by default all parameters are interpreted as 'in'\r\n                        if (params[i].type.hasUsage('out') || params[i].type.hasUsage('inout')) {\r\n                            ref(params[i], src);\r\n                        } else {\r\n                            // todo: handle expressions like \"float4 v = 5.0;\"\r\n                            const size = params[i].type.size;\r\n                            const dest = alloca(size);\r\n\r\n                            imove(dest, src);\r\n                            debug.map(args[i]);\r\n\r\n                            ref(params[i], dest);\r\n                        }\r\n                    }\r\n\r\n                    translateUnknown(ctx, fdecl);\r\n                    pop();\r\n\r\n                    return ret;\r\n                }\r\n                break;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                {\r\n                    const ctorCall = expr as IConstructorCallInstruction;\r\n                    // todo: add correct constructor call support for builtin type at the level of analyzer\r\n                    const type = ctorCall.type;\r\n                    const args = (ctorCall.args as IExprInstruction[]);\r\n\r\n                    const size = type.size;\r\n                    const dest = alloca(size);\r\n\r\n                    switch (type.name) {\r\n                        case 'float':\r\n                        case 'float1':\r\n                        case 'float2':\r\n                        case 'float3':\r\n                        case 'float4':\r\n                        case 'int':\r\n                        case 'int1':\r\n                        case 'int2':\r\n                        case 'int3':\r\n                        case 'int4':\r\n                        case 'uint':\r\n                        case 'uint1':\r\n                        case 'uint2':\r\n                        case 'uint3':\r\n                        case 'uint4':\r\n\r\n                            switch (args.length) {\r\n                                case 1:\r\n                                    // TODO: convert float to int if necessary\r\n                                    // handling for the case single same type argument and multiple floats\r\n                                    assert(instruction.isExpression(args[0]), EInstructionTypes[args[0].instructionType]);\r\n                                    let src = raddr(args[0]);\r\n\r\n                                    if (src.type !== EAddrType.k_Registers) {\r\n                                        src = iload(src);\r\n                                        debug.map(args[0]);\r\n                                    }\r\n\r\n                                    const elementSize = SystemScope.isFloatBasedType(type) ? sizeof.f32() : sizeof.i32();\r\n\r\n                                    // FIXME: use 'length' property\r\n                                    let length = type.size / elementSize;\r\n                                    let swizzle = null;\r\n                                    if (src.size === elementSize) {\r\n                                        swizzle = [...Array(length).fill(0)];\r\n                                        src = addr.override(src, swizzle);\r\n                                    } else {\r\n                                        swizzle = [...Array(length).keys()];\r\n                                        src = addr.override(src, swizzle);\r\n                                    }\r\n\r\n\r\n                                    imove(dest, src);\r\n                                    debug.map(ctorCall);\r\n                                    break;\r\n                                default:\r\n                                    let padding = 0;\r\n                                    for (let i = 0; i < args.length; ++i) {\r\n                                        assert(instruction.isExpression(args[i]), EInstructionTypes[args[i].instructionType]);\r\n                                        let src = raddr(args[i]);\r\n\r\n                                        if (src.type !== EAddrType.k_Registers) {\r\n                                            src = iload(src);\r\n                                            debug.map(args[i]);\r\n                                        }\r\n\r\n                                        imove(addr.sub(dest, padding, src.size), src);\r\n                                        debug.map(ctorCall);\r\n                                        padding += args[i].type.size;\r\n                                    }\r\n                                    break;\r\n\r\n                            }\r\n                            return addr.loc({ addr: dest, size });\r\n                        default:\r\n                    }\r\n                    console.warn(`Unknown constructor found: ${ctorCall.toCode()}`);\r\n                    return PromisedAddress.INVALID;\r\n                }\r\n                break;\r\n            default:\r\n                console.warn(`Unknown expression found: ${expr.instructionName} (${expr.toCode()})`);\r\n                return PromisedAddress.INVALID;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // \r\n    // Handle all instruction types\r\n    //\r\n\r\n    function translate(instr: IInstruction) {\r\n        if (isNull(instr)) {\r\n            return;\r\n        }\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_VariableDecl:\r\n                {\r\n                    let decl = instr as IVariableDeclInstruction;\r\n\r\n                    if (isNull(decl.initExpr)) {\r\n                        // There is no initial value, but allocation should be done anyway\r\n                        // in order to assign register for this variable.\r\n                        ref(decl, alloca(decl.type.size));\r\n                        return;\r\n                    }\r\n\r\n                    /*\r\n                    0: int a = 1;           | 0x00: load %a   #1        | NS 0\r\n                    1: int b = 2;           | 0x01: load %b   #2        | NS 1\r\n                    2: int c = a + b * 10;  | 0x02: load %t0  #10       |\r\n                                            | 0x03: mul  $t1  %b %t0    |\r\n                                            | 0x02: add  %c   %a %t1    | NS 2\r\n                    3: return c;            | 0x03: move %rax %c        | NS 3\r\n                                            | 0x04: ret                 |\r\n                                            |\r\n                    */\r\n\r\n                    let dest = raddr(decl.initExpr);\r\n                    if (dest.type !== EAddrType.k_Registers) {\r\n                        //breakpoint before variable initialization\r\n                        debug.ns();\r\n                        dest = iload(dest);\r\n                        debug.map(decl.initExpr);\r\n                        // breakpoint right after variable initialization\r\n                        debug.ns();\r\n                    }\r\n\r\n                    ref(decl, dest);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_DeclStmt:\r\n                {\r\n                    let stmt = instr as DeclStmtInstruction;\r\n                    stmt.declList.forEach(translate);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_IfStmt:\r\n                {\r\n                    // [out of if code]\r\n                    //  jif:\r\n                    // jump: 'jump to end of if'    ---+\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // [out of if code]             <--+\r\n\r\n                    // [out of if code]\r\n                    //  jif:\r\n                    // jump: 'jump to contrary'     ---+\r\n                    // ....                            |\r\n                    // ....                            |\r\n                    // jump:  'jump to skip contraty'  |  ---+\r\n                    // ....                         <--+     |\r\n                    // ....                                  |\r\n                    // [out of if code]                   <--+ \r\n\r\n\r\n\r\n\r\n                    let ifStmt = instr as IIfStmtInstruction;\r\n                    let { cond, conseq, contrary } = ifStmt;\r\n\r\n                    let condAddr = raddr(cond);\r\n                    assert(condAddr.size === sizeof.bool());\r\n\r\n                    if (condAddr.type !== EAddrType.k_Registers) {\r\n                        condAddr = iload(condAddr);\r\n                    }\r\n\r\n                    iop1(EOperation.k_JumpIf, condAddr);\r\n\r\n                    let unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n                    translate(conseq);\r\n                    // jump co contrary or out of if\r\n                    let jumpTo = pc() + (contrary ? 1 : 0);\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n\r\n                    if (contrary) {\r\n                        unresolvedJump = pc();\r\n                        icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n                        translate(contrary);\r\n                        // jump to skip contrary\r\n                        jumpTo = pc();\r\n                        instructions.replace(unresolvedJump, EOperation.k_Jump, [jumpTo]);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                {\r\n                    let retStmt = instr as ReturnStmtInstruction;\r\n                    const expr = retStmt.expr;\r\n                    if (!isNull(expr)) {\r\n                        let src = raddr(expr);\r\n\r\n                        if (src.type !== EAddrType.k_Registers) {\r\n                            src = iload(src);\r\n                            debug.map(expr);\r\n                        }\r\n\r\n                        const dest = ret();\r\n\r\n                        assert(src.size === ret().size);\r\n                        imove(dest, src);\r\n                        debug.map(expr);\r\n                    }\r\n                    // breakpoint before leaving function\r\n                    debug.ns();\r\n                    icode(EOperation.k_Ret);\r\n                    debug.map(retStmt);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_StmtBlock:\r\n                {\r\n                    open(); // open block\r\n                    let block = instr as IStmtBlockInstruction;\r\n                    for (let stmt of block.stmtList) {\r\n                        translate(stmt);\r\n                    }\r\n                    close(); // close block\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                {\r\n                    let func = instr as IFunctionDeclInstruction;\r\n\r\n                    // resolve function's implementation\r\n                    func = func.scope.findFunctionInScope(func);\r\n\r\n                    let def = func.def; // todo: handle all arguments!!\r\n                    let impl = func.impl;\r\n\r\n                    translate(impl);\r\n\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ExprStmt:\r\n                {\r\n                    let stmt = instr as IExprStmtInstruction;\r\n                    raddr(stmt.expr);\r\n                    return;\r\n                }\r\n            case EInstructionTypes.k_ForStmt:\r\n                {\r\n                    const loop = instr as IForStmtInstruction;\r\n                    const { init, cond, step, body } = loop;\r\n\r\n                    open(); // open block\r\n\r\n                    // TODO: make the code more readable\r\n                    if (instruction.isExpression(init)) {\r\n                        // translate as expression\r\n                        raddr(init as IExprInstruction);\r\n                    } else {\r\n                        // translate as varaible declaration\r\n                        translate(init as IVariableDeclInstruction);\r\n                    }\r\n\r\n                    assert(cond.type.isEqual(T_BOOL));\r\n                    // before cond:\r\n                    let beforeCondPc = pc();\r\n                    let condAddr = raddr(cond);\r\n                    assert(condAddr.size === sizeof.bool());\r\n\r\n                    if (condAddr.type !== EAddrType.k_Registers) {\r\n                        condAddr = iload(condAddr);\r\n                    }\r\n\r\n                    // TOOD: add support for break statement.\r\n\r\n                    iop1(EOperation.k_JumpIf, condAddr);\r\n                    let unresolvedJump = pc();\r\n                    icode(EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);\r\n\r\n                    translate(body);\r\n\r\n                    // step:\r\n                    raddr(step);\r\n                    // goto to before condition\r\n                    icode(EOperation.k_Jump, beforeCondPc);\r\n\r\n                    // out of loop:\r\n                    let outofLoopPc = pc();\r\n                    // resolve jump in case of invalid condition => go to out of loop\r\n                    instructions.replace(unresolvedJump, EOperation.k_Jump, [outofLoopPc]);\r\n\r\n                    close(); // close block\r\n\r\n                    return;\r\n                }\r\n            default:\r\n                console.warn(`Unknown statement found: ${instr.instructionName} (${instr.toCode()})`);\r\n        }\r\n    }\r\n\r\n    translate(instr);\r\n}\r\n\r\n\r\nconst hex2 = (v: number) => `0x${v.toString(16).padStart(2, '0')}`;\r\nconst hex4 = (v: number) => `0x${v.toString(16).padStart(4, '0')}`;\r\n// const reg = (v: number) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`;    // register address;\r\n// const addr = (v: number) => `%${hex4(v >>> 0)}%`;                   // global memory address;\r\n\r\n\r\nexport function translate(entryFunc: IFunctionDeclInstruction): ISubProgram {\r\n    let ctx = ContextBuilder();\r\n    let res: ISubProgram = null;\r\n\r\n    try {\r\n        if (!isDefAndNotNull(entryFunc)) {\r\n            console.error(`Entry point '${entryFunc.name}' not found.`);\r\n            return null;\r\n        }\r\n        res = translateProgram(ctx, entryFunc);\r\n    } catch (e) {\r\n        throw e;\r\n        console.error(TranslatorDiagnostics.stringify(ctx.diag.resolve()));\r\n    }\r\n\r\n    let report = ctx.diag.resolve();\r\n    if (report.errors) {\r\n        console.error(Diagnostics.stringify(report));\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n\r\nexport async function translateExpression(expr: string, document?: ISLDocument): Promise<ISubProgram> {\r\n    const uri = `://expression`;\r\n    const anonymousFuncName = `anonymous`;\r\n    const source = `auto ${anonymousFuncName}() { return (${expr}); }`;\r\n    const documentEx = await createFXSLDocument({ source, uri }, undefined, document);\r\n    if (!documentEx.diagnosticReport.errors) {\r\n        return translate(documentEx.root.scope.findFunction(anonymousFuncName, null));\r\n    }\r\n    console.error(Diagnostics.stringify(documentEx.diagnosticReport));\r\n    return null;\r\n}\r\n\r\n","import { EInstructionTypes, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represent all kind of statements\r\n */\r\nexport class StmtInstruction extends Instruction implements IStmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Stmt, ...settings });\r\n    }    \r\n}\r\n","import { IFunctionDeclInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport const REG_INVALID = (-1 >>> 0);\r\nexport const DEFAULT_ENTRY_POINT_NAME = 'main';\r\n\r\n// symbol name id generation;\r\nexport const sname = {\r\n    i32: (i32: number) => `%i32:${i32}`,\r\n    f32: (f32: number) => `%f32:${f32}`,\r\n    var: (vdecl: IVariableDeclInstruction) => `${vdecl.name}:${vdecl.instructionID}`,\r\n    fun: (fdecl: IFunctionDeclInstruction) => `${fdecl.name}:${fdecl.instructionID}`,\r\n\r\n    // addr: (addr: number) => sname.i32(addr)\r\n};\r\n\r\n// aux functions for packing routines\r\nexport const i32ToU8Array = (i32: number) => Array(4).fill(0).map((u8, i, self) => (i32 >> (i) * 8) & (0xff));\r\nexport const u8ArrayToI32 = (arr: Uint8Array | Array<number>) => (arr as number[]).reduce((acc, cv, i, self) => acc | (cv << (i) * 8), 0);\r\n\r\n// Uint8Array => Int32Array conversion\r\nexport const u8ArrayAsI32 = (arr: Uint8Array) => ((arr[0]) | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24));\r\nexport const u8ArrayAsF32 = (arr: Uint8Array) => new Float32Array(arr.buffer, arr.byteOffset)[0];\r\n\r\n\r\nconst ab = new ArrayBuffer(4);\r\nconst f32a = new Float32Array(ab);\r\nconst i32a = new Int32Array(ab);\r\nconst u32a = new Uint32Array(ab);\r\nexport function f32Asi32(f32: number): number {\r\n    f32a[0] = f32;\r\n    return i32a[0];\r\n}\r\n\r\nexport function i32Asf32(i32: number): number {\r\n    i32a[0] = i32;\r\n    return f32a[0];\r\n}\r\n\r\nexport function u32Asf32(u32: number): number {\r\n    u32a[0] = u32;\r\n    return f32a[0];\r\n}\r\n\r\n\r\nexport function i32Asu32(i32: number): number {\r\n    i32a[0] = i32;\r\n    return u32a[0];\r\n}\r\n\r\n\r\nexport function u32Asi32(u32: number): number {\r\n    u32a[0] = u32;\r\n    return i32a[0];\r\n}\r\n","import { EInstructionTypes, IAttributeInstruction, IInstruction, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAttributeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args: ILiteralInstruction<boolean | number>[];\r\n}\r\n\r\n/**\r\n * Represent attributes:\r\n *  [numthreads(1, 2, 3)]\r\n *  [loop]\r\n *  [branch]\r\n */\r\nexport class AttributeInstruction extends Instruction implements IAttributeInstruction {\r\n    \r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n\r\n    constructor({ name, args, ...settings }: IAttributeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Attribute, ...settings });\r\n\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `[${this.name}${ this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})`: `` }]`;\r\n    }\r\n}\r\n","export const SOURCE_FILE_REQUEST                    = 'source-file-request';\r\nexport const SOURCE_FILE_LOADED                     = 'source-file-loaded';\r\nexport const SOURCE_FILE_LOADING_FAILED             = 'source-file-loading-failed';\r\nexport const SOURCE_FILE_DROP_STATE                 = 'source-file-drop-state';\r\n\r\nexport const GRAMMAR_CONTENT_SPECIFIED              = 'grammar-content-specified';\r\nexport const PARSER_PARAMS_CHANGED                  = 'parser-params-changed';\r\nexport const PARSING_PARAMS_CHANGED                 = 'parsing-params-changed';\r\n\r\nexport const SOURCE_CODE_MODIFED                    = 'source-code-modified';\r\nexport const SOURCE_CODE_PARSING_COMPLETE           = 'source-code-parsing-complete';\r\nexport const SOURCE_CODE_ANALYSIS_COMPLETE          = 'source-code-analysis-complete';\r\nexport const SOURCE_CODE_ADD_MARKER                 = 'source-code-add-marker';\r\nexport const SOURCE_CODE_ADD_MARKER_BATCH           = 'source-code-add-marker-batch';\r\nexport const SOURCE_CODE_REMOVE_MARKER              = 'source-code-remove-marker';\r\nexport const SOURCE_CODE_REMOVE_MARKER_BATCH        = 'source-code-remove-marker-batch';\r\nexport const SOURCE_CODE_ADD_BREAKPOINT             = 'source-code-add-breakpoint';\r\nexport const SOURCE_CODE_REMOVE_BREAKPOINT          = 'source-code-remove-breakpoint';\r\n\r\nexport const DEBUGGER_COMPILE                       = 'debugger-compile';\r\nexport const DEBUGGER_START_DEBUG                   = 'debugger-start-debug';\r\n// cancel compilation or jut clean up all previous results from store\r\nexport const DEBUGGER_RESET                         = 'debugger-reset';\r\nexport const DEBUGGER_COLORIZE                      = 'debugger-colorize';\r\nexport const DEBUGGER_OPTIONS_CHANGED               = 'debugger-options-changed';\r\n\r\nexport const PLAYGROUND_EMITER_UPDATE               = 'playground-emitter-update';\r\nexport const PLAYGROUND_SELECT_EFFECT               = 'playground-select-effect';\r\n\r\n","import { defaultSLGrammar } from '@lib/fx/SLParser';\r\nimport { parser } from '@sandbox/actions';\r\nimport ActionTypes from '@sandbox/actions/ActionTypes';\r\nimport { App } from '@sandbox/containers';\r\nimport logic, { LOCATION_NOT_FOUND, LOCATION_PATTERN } from '@sandbox/logic';\r\nimport reducer from '@sandbox/reducers';\r\nimport { history } from '@sandbox/reducers/router';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport { ConnectedRouter } from 'connected-react-router';\r\nimport * as isElectron from 'is-electron-renderer';\r\nimport * as React from 'react';\r\nimport { render } from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { Route, Switch } from 'react-router-dom';\r\nimport { applyMiddleware, createStore, Middleware } from 'redux';\r\nimport reduxImmutableStateInvariant from 'redux-immutable-state-invariant';\r\nimport { createLogger } from 'redux-logger';\r\nimport { Header, Modal } from 'semantic-ui-react';\r\n\r\nrequire('semantic-ui-less/semantic.less');\r\n\r\n// global defines from webpack's config;\r\ndeclare const VERSION: string;\r\ndeclare const COMMITHASH: string;\r\ndeclare const BRANCH: string;\r\ndeclare const MODE: string;\r\ndeclare const PRODUCTION: boolean;\r\n\r\nif (isElectron) {\r\n    require('electron-react-devtools').install();\r\n}\r\n\r\nconst logger = createLogger({\r\n    collapsed: true,\r\n    diff: false\r\n});\r\n\r\n\r\nconst reduxImmutableState = reduxImmutableStateInvariant({\r\n    ignore: [\r\n        'sourceFile.slastDocument',\r\n        'sourceFile.slDocument',\r\n        'sourceFile.debugger.runtime',\r\n        'sourceFile.emitter'\r\n    ]\r\n} as any);\r\n\r\n// todo: add support for retail configuration\r\nconst middleware: Middleware[] = !PRODUCTION ?\r\n    [/*thunk, */logic, logger, reduxImmutableState] :\r\n    [logic];\r\n\r\nconst store = createStore<IStoreState, ActionTypes, any, any>(\r\n    reducer,\r\n    applyMiddleware(...middleware)\r\n);\r\n\r\n// const initialState: IStoreState = store.getState();\r\n// const defaultName = initialState.sourceFile.filename;\r\n\r\nrender(\r\n    <Provider store={store}>\r\n        <ConnectedRouter history={history}>\r\n            <Switch>\r\n                <Route path={LOCATION_PATTERN} component={App} />\r\n                <Route exact path={LOCATION_NOT_FOUND}>\r\n                    <Modal open basic size='small'>\r\n                        <Header icon='archive' content='Location not found :/' />\r\n                        <Modal.Content>\r\n                        </Modal.Content>\r\n                    </Modal>\r\n                </Route>\r\n            </Switch>\r\n        </ConnectedRouter>\r\n    </Provider>,\r\n    document.getElementById('app')\r\n);\r\n\r\n// make grammar available for editing\r\nstore.dispatch(parser.setGrammar(defaultSLGrammar()));\r\n\r\nconsole.log(`%c Is this running in electron.js?: ${isElectron}`, 'background: #222; color: #bada55');\r\nconsole.log(`%c This is ${isElectron ? 'electron' : 'a web browser'}!!!`, 'background: #222; color: #bada55');\r\nconsole.log(`%c ver: ${VERSION} (${COMMITHASH}, ${BRANCH}), mode=${MODE}, production=${PRODUCTION}`, 'background: #222; color: #bada55');","import { isString, isNull, isDef } from \"../common\";\r\nimport * as path from \"../path/path\"\r\nimport { IDataURI } from \"../idl/IDataURI\";\r\n\r\nclass URI {\r\n    private _scheme: string = null;\r\n    private _userinfo: string = null;\r\n    private _host: string = null;\r\n    private _port: number = 0;\r\n    private _path: string = null;\r\n    private _query: string = null;\r\n    private _fragment: string = null;\r\n\r\n    get urn(): string {\r\n        return (this._path ? this._path : \"\") +\r\n            (this._query ? '?' + this._query : \"\") +\r\n            (this._fragment ? '#' + this._fragment : \"\");\r\n    }\r\n\r\n    get url(): string {\r\n        return (this._scheme ? this._scheme : \"\") + this.authority;\r\n    }\r\n\r\n    get authority(): string {\r\n        return (this._host ? '//' + (this._userinfo ? this._userinfo + '@' : \"\") +\r\n            this._host + (this._port ? ':' + this._port : \"\") : \"\");\r\n    }\r\n\r\n    get scheme(): string {\r\n        return this._scheme;\r\n    }\r\n\r\n    get protocol(): string {\r\n        if (!this._scheme) {\r\n            return this._scheme;\r\n        }\r\n\r\n        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));\r\n    }\r\n\r\n    get userInfo(): string {\r\n        return this._userinfo;\r\n    }\r\n\r\n    get host(): string {\r\n        return this._host;\r\n    }\r\n\r\n    set host(sHost: string) {\r\n        //TODO: check host format\r\n        this._host = sHost;\r\n    }\r\n\r\n    get port(): number {\r\n        return this._port;\r\n    }\r\n\r\n    set port(iPort: number) {\r\n        this._port = iPort;\r\n    }\r\n\r\n    get path(): string {\r\n        return this._path;\r\n    }\r\n\r\n    set path(sPath: string) {\r\n        // debug_assert(!isNull(sPath.match(new RegExp(\"^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$\"))), \r\n        //     \"invalid path used: \" + sPath);\r\n        //TODO: check path format\r\n        this._path = sPath;\r\n    }\r\n\r\n    get query(): string {\r\n        //TODO: check query format\r\n        return this._query;\r\n    }\r\n\r\n    set query(sQuery: string) {\r\n        this._query = sQuery;\r\n    }\r\n\r\n    get fragment(): string {\r\n        return this._fragment;\r\n    }\r\n\r\n\r\n    constructor(uri: URI);\r\n    constructor(uri: string);\r\n    constructor(uri?) {\r\n        if (uri) {\r\n            this.set(uri);\r\n        }\r\n    }\r\n\r\n    set(uri: URI);\r\n    set(uri: string);\r\n    set(data?): URI {\r\n        if (isString(data)) {\r\n            var uri: RegExpExecArray = URI.uriExp.exec(<string>data);\r\n\r\n            console.assert(uri !== null, 'Invalid URI format used.\\nused uri: ' + data);\r\n\r\n            if (!uri) {\r\n                return null;\r\n            }\r\n\r\n            this._scheme = uri[1] || null;\r\n            this._userinfo = uri[2] || null;\r\n            this._host = uri[3] || null;\r\n            this._port = parseInt(uri[4]) || null;\r\n            this._path = uri[5] || uri[6] || null;\r\n            this._query = uri[7] || null;\r\n            this._fragment = uri[8] || null;\r\n\r\n            return this;\r\n\r\n        }\r\n        else if (data instanceof URI) {\r\n            return this.set(data.toString());\r\n        }\r\n\r\n        console.error('Unexpected data type was used.');\r\n\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.url + this.urn;\r\n    }\r\n\r\n    //------------------------------------------------------------------//\r\n    //----- Validate a URI -----//\r\n    //------------------------------------------------------------------//\r\n    //- The different parts are kept in their own groups and can be recombined\r\n    //  depending on the scheme:\r\n    //  - http as $1://$3:$4$5?$7#$8\r\n    //  - ftp as $1://$2@$3:$4$5\r\n    //  - mailto as $1:$6?$7\r\n    //- groups are as follows:\r\n    //  1   == scheme\r\n    //  2   == userinfo\r\n    //  3   == host\r\n    //  4   == port\r\n    //  5,6 == path (5 if it has an authority, 6 if it doesn't)\r\n    //  7   == query\r\n    //  8   == fragment\r\n\r\n\r\n    private static uriExp: RegExp = new RegExp(\"^([a-z0-9+.-]+:)?(?:\\\\/\\\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\\\d*))?(\\\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$\", \"i\");\r\n\r\n    /*\r\n     composed as follows:\r\n     ^\r\n     ([a-z0-9+.-]+):                            #scheme\r\n     (?:\r\n     //                            #it has an authority:\r\n     (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?    #userinfo\r\n     ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)        #host\r\n     (?::(\\d*))?                        #port\r\n     (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     |\r\n     #it doesn't have an authority:\r\n     (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     )\r\n     (?:\r\n     \\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #query string\r\n     )?\r\n     (?:\r\n     #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #fragment\r\n     )?\r\n     $\r\n     */\r\n}\r\n\r\n\r\nfunction normalizeURIPath(file: URI): URI {\r\n    if (!isNull(file.path)) {\r\n        if (file.scheme === \"filesystem:\") {\r\n            var uri = parse(file.path);\r\n\r\n            uri.path = path.normalize(uri.path);\r\n            file.path = uri.toString();\r\n        }\r\n        else {\r\n            file.path = path.normalize(file.path);\r\n        }\r\n    }\r\n\r\n    return file;\r\n}\r\n\r\n\r\n\r\nexport function resolve(from: string, to: string = document.location.href): string {\r\n    var currentPath = parse(to);\r\n    var file = parse(from);\r\n    var dirname: string;\r\n\r\n    normalizeURIPath(file);\r\n    normalizeURIPath(currentPath);\r\n\r\n    if (!isNull(file.scheme) || !isNull(file.host) || path.parse(file.path).isAbsolute()) {\r\n        //another server or absolute path\r\n        return from;\r\n    }\r\n\r\n    dirname = path.parse(currentPath.path).dirname;\r\n    currentPath.path = dirname ? (dirname + \"/\" + from) : from;\r\n\r\n    return normalizeURIPath(currentPath).toString();\r\n}\r\n\r\n\r\nexport function parseDataURI(uri: string): IDataURI {\r\n    var re: RegExp = /^data:([\\w\\d\\-\\/]+)?(;charset=[\\w\\d\\-]*)?(;base64)?,(.*)$/;\r\n    var m: string[] = uri.match(re);\r\n\r\n    return {\r\n        //like [text/plain]\r\n        mediatype: m[1] || null,\r\n        //like [;charset=windows-1251]\r\n        charset: isString(m[2]) ? m[2].substr(9) : null,\r\n        //like [;base64]\r\n        base64: isDef(m[3]),\r\n        data: m[4] || null\r\n    };\r\n}\r\n\r\n\r\nexport function parse(uri: string): URI {\r\n    return new URI(uri);\r\n}\r\n\r\n\r\nexport function currentScript(): HTMLScriptElement {\r\n    if (isDef(document['currentScript'])) {\r\n        return <HTMLScriptElement>document['currentScript'];\r\n    }\r\n\r\n    var scripts: HTMLCollectionOf<HTMLScriptElement> = document.getElementsByTagName(\"script\");\r\n    return scripts[scripts.length - 1];\r\n}\r\n\r\n\r\nexport function currentPath(): string {\r\n    var uri = parse(currentScript().src);\r\n    let dirname = path.parse(uri.path).dirname;\r\n    return uri.url + dirname + \"/\";\r\n}\r\n\r\n\r\nexport function here(): URI {\r\n    return new URI(document.location.href);\r\n}\r\n","/* tslint:disable:typedef */\r\n/* tslint:disable:use-simple-attributes */\r\n/* tslint:disable:react-a11y-event-has-role */\r\n/* tslint:disable:no-for-in */\r\n/* tslint:disable:cyclomatic-complexity */\r\n\r\nimport { isArray, isDefAndNotNull, isNull } from '@lib/common';\r\nimport { fn, instruction, type } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, IAttributeInstruction, ICastExprInstruction, IComplexExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIdInstruction, IInitExprInstruction, IInstruction, IInstructionCollector, ILiteralInstruction, IPassInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IProvideInstruction, IReturnStmtInstruction, IStmtBlockInstruction, IStmtInstruction, ITechniqueInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from '@lib/idl/IInstruction';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { mapProps } from '@sandbox/reducers';\r\nimport { getFileState } from '@sandbox/reducers/sourceFile';\r\nimport { IFileState } from '@sandbox/store/IStoreState';\r\nimport * as React from 'react';\r\nimport injectSheet from 'react-jss';\r\nimport { connect } from 'react-redux';\r\nimport { Icon, List, Message } from 'semantic-ui-react';\r\n\r\nimport { IWithStyles } from '.';\r\n\r\nconst styles = {\r\n    parentIcon: {\r\n        '&:hover': {\r\n            textShadow: '1px 1px 1px #ccc'\r\n        }\r\n    }\r\n};\r\n\r\nconst PropertyStyles = {\r\n    selected: {\r\n        // backgroundColor: `rgba(128, 128, 128, 0.125)`,\r\n        // boxShadow: `0 0 3px rgba(55, 55, 55, 0.33)`,\r\n        // borderRadius: `2px`\r\n    },\r\n    system: {\r\n        // opacity: '0.75'\r\n    }\r\n};\r\n\r\n\r\nfunction PropertyStyle(names: Object) {\r\n    let styles = {};\r\n    for (let k in names) {\r\n        if (names[k] && PropertyStyles[k]) {\r\n            styles = { ...styles, ...PropertyStyles[k] };\r\n        }\r\n    }\r\n    return styles;\r\n}\r\n\r\n\r\nfunction prettifyEName(econstName: string): string {\r\n    let m;\r\n    return (m = /k_([a-zA-Z]+)/g.exec(econstName), (m && m[1]) || econstName);\r\n}\r\n\r\n\r\ninterface IPropertyProps extends IWithStyles<typeof styles> {\r\n    name?: any;\r\n    value?: any;\r\n    onMouseOver?: any;\r\n    onMouseOut?: any;\r\n    onClick?: any;\r\n    selected?: boolean;\r\n    opened?: boolean;\r\n    system?: boolean;\r\n    parent?: any;\r\n    onParentMouseDown?: any;\r\n    onParentMouseUp?: any;\r\n}\r\n\r\n\r\ntype PropertyComponent = React.StatelessComponent<IPropertyProps>;\r\n\r\n\r\n\r\nconst Property: PropertyComponent =\r\n    ({ name, value, children, onMouseOver, onMouseOut, onClick, selected, opened, system,\r\n        parent, onParentMouseDown, onParentMouseUp, classes }) => {\r\n        let iconName = system ? `code` as any : (isDefAndNotNull(children) ? `chevron down` : `code`);\r\n        if (!children) {\r\n            opened = true;\r\n        }\r\n        if (opened === false) {\r\n            iconName = 'chevron right';\r\n            children = null;\r\n        }\r\n        const isHelper = !onClick;\r\n        const simpleProperty = (value && !children) && !parent;\r\n        const helperProperty = (!value && children) && isHelper;\r\n        const showIcon = !simpleProperty && !helperProperty;\r\n        return (\r\n            <List.Item\r\n                className='astnode'\r\n                onMouseOver={ onMouseOver }\r\n                onMouseOut={ onMouseOut }\r\n                onClick={ onClick }\r\n                style={ { ...PropertyStyle({ selected, system }), ...(simpleProperty ? { fontSize: '85%' } : {}) } }\r\n            >\r\n                { showIcon &&\r\n                    <List.Icon name={ iconName } />\r\n                }\r\n                <List.Content>\r\n                    { isDefAndNotNull(name) &&\r\n                        <List.Header style={ helperProperty ? { fontSize: '85%', color: '#ccc' } : {} }>\r\n                            { parent &&\r\n                                <span>\r\n                                    <a\r\n                                        style={ { color: 'rgba(0,0,0,0.3)' } }\r\n                                        onMouseOver={ onParentMouseDown }\r\n                                        onMouseOut={ onParentMouseUp }\r\n                                    >\r\n                                        <Icon className={ classes.parentIcon } name={ `git pull request` as any } size='small' />\r\n                                    </a>\r\n                                </span>\r\n                            }\r\n                            { helperProperty ? `[${name}]` : name }\r\n                        </List.Header>\r\n\r\n                    }\r\n                    { isDefAndNotNull(value) &&\r\n                        <List.Description>{ value }</List.Description>\r\n                    }\r\n                    { isDefAndNotNull(children) &&\r\n                        <List.List className='astlist'>\r\n                            { children }\r\n                        </List.List>\r\n                    }\r\n                </List.Content>\r\n            </List.Item>\r\n        );\r\n    }\r\n\r\n\r\nconst isNotEmptyArray = (arr) => (!isArray(arr) || (arr).length > 0);\r\n\r\nconst PropertyOpt: PropertyComponent = (props) => {\r\n    const { value, children } = props;\r\n    if (isDefAndNotNull(value) || (isDefAndNotNull(children) && isNotEmptyArray(children))) {\r\n        return (\r\n            <Property { ...props } />\r\n        );\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\nconst SystemProperty: PropertyComponent = (props) => {\r\n    return (\r\n        <PropertyOpt { ...props } system={ true }>\r\n            { props.children }\r\n        </PropertyOpt>\r\n    );\r\n}\r\n\r\nexport interface IProgramViewProps extends IFileState, IWithStyles<typeof styles> {\r\n    onNodeOut?: (instr: IInstruction) => void;\r\n    onNodeOver?: (instr: IInstruction) => void;\r\n    onNodeClick?: (instr: IInstruction) => void;\r\n}\r\n\r\n@injectSheet(styles)\r\nclass ProgramView extends React.Component<IProgramViewProps, {}> {\r\n    state: {\r\n        instrList: IMap<{ opened: boolean; selected: boolean; errors?: string[]; }>;\r\n    };\r\n\r\n    documentCache: ISLDocument = null;\r\n    rootRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            instrList: {}\r\n        };\r\n\r\n        this.rootRef = React.createRef();\r\n    }\r\n\r\n\r\n    shouldComponentUpdate(nextProps: IFileState, nextState): boolean {\r\n        return this.documentCache !== nextProps.slDocument;\r\n        // return true;\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.documentCache = this.props.slDocument;\r\n\r\n        // const rect = this.rootRef.current.getBoundingClientRect();\r\n        // just a rude hack\r\n        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;\r\n    }\r\n\r\n\r\n    render() {\r\n        const { slDocument: analysis } = this.props;\r\n\r\n        if (isNull(analysis)) {\r\n            return null;\r\n        }\r\n\r\n        const root = analysis.root;\r\n\r\n        const style = {\r\n            height: 'calc(100vh - 205px)',\r\n            overflowY: 'auto'\r\n        };\r\n\r\n        return (\r\n            <div ref={ this.rootRef }>\r\n                <List style={ style } selection size='small' className='astlist'>\r\n                    { this.InstructionCollector(root) }\r\n                </List>\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    Unknown(instr) {\r\n        if (!instr) {\r\n            return null;\r\n        }\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_Collector:\r\n                return this.InstructionCollector(instr);\r\n\r\n            case EInstructionTypes.k_TypeDecl:\r\n                return this.TypeDecl(instr);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return this.ComplexType(instr);\r\n            case EInstructionTypes.k_Provide:\r\n                return this.ProvideDecl(instr);\r\n            case EInstructionTypes.k_TechniqueDecl:\r\n                return this.Technique(instr);\r\n            case EInstructionTypes.k_VariableDecl:\r\n                return this.VariableDecl(instr);\r\n            case EInstructionTypes.k_VariableType:\r\n                return this.VariableType(instr);\r\n            case EInstructionTypes.k_SystemType:\r\n                return this.SystemType(instr);\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                return this.FunctionDecl(instr);\r\n\r\n            //\r\n            // Expressions\r\n            //\r\n\r\n            case EInstructionTypes.k_InitExpr:\r\n                return this.InitExpr(instr);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return this.IdExpr(instr);\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return this.PostfixPointExpr(instr);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return this.PostfixIndexExpr(instr);\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                return this.Assigment(instr);\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                return this.PostfixArithmetic(instr);\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                return this.ConstructorCall(instr);\r\n            case EInstructionTypes.k_IntExpr:\r\n                return this.Int(instr);\r\n            case EInstructionTypes.k_FloatExpr:\r\n                return this.Float(instr);\r\n            case EInstructionTypes.k_StringExpr:\r\n                return this.String(instr);\r\n            case EInstructionTypes.k_BoolExpr:\r\n                return this.Bool(instr);\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                return this.ArithmeticExpr(instr);\r\n            case EInstructionTypes.k_CastExpr:\r\n                return this.Cast(instr);\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return this.ComplexExpr(instr);\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                return this.FunctionCall(instr);\r\n            default:\r\n                return this.NotImplemented(instr);\r\n        }\r\n    }\r\n\r\n\r\n    InstructionCollector(instr: IInstructionCollector) {\r\n        return (\r\n            <PropertyOpt { ...this.bindProps(instr, true) } name='Program' >\r\n                { (instr.instructions || []).map((instr) => this.Unknown(instr)) }\r\n            </PropertyOpt>\r\n        );\r\n    }\r\n\r\n\r\n    ProvideDecl(instr: IProvideInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='moduleName' value={ instr.moduleName } />\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    TypeDecl(instr: ITypeDeclInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property { ...this.bindProps(instr) } name={ 'type' } >\r\n                    { this.Unknown(instr.type) }\r\n                </Property>\r\n                <SystemProperty name='name' value={ instr.name } />\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    ComplexType(instr: ITypeInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='name' value={ instr.name } />\r\n                <PropertyOpt { ...this.bindProps(instr) } name='fields'>\r\n                    { instr.fields.map((field) => this.Unknown(field)) }\r\n                </PropertyOpt>\r\n                { this.typeInfo(instr) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    // todo: implement it properly\r\n    SystemType(instr: ITypeInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                { this.typeInfo(instr) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    typeInfo(instr: ITypeInstruction) {\r\n        return (\r\n            <SystemProperty { ...this.bindProps(instr, false) } name={ type.signature(instr, true) }>\r\n                <SystemProperty name='writable' value={ `${instr.writable}` } />\r\n                <SystemProperty name='readable' value={ `${instr.readable}` } />\r\n                <SystemProperty name='size' value={ `${instr.size === instruction.UNDEFINE_SIZE ? 'undef' : instr.size} bytes` } />\r\n                <SystemProperty name='length' value={ `${instr.length === instruction.UNDEFINE_LENGTH ? 'undef' : instr.length}` } />\r\n                <SystemProperty name='base' value={ `${instr.isBase()}` } />\r\n                <SystemProperty name='array' value={ `${instr.isArray()}` } />\r\n                <SystemProperty name='complex' value={ `${instr.isComplex()}` } />\r\n                <SystemProperty name='const' value={ `${instr.isConst()}` } />\r\n                <PropertyOpt name='element type'>\r\n                    { this.Unknown(instr.arrayElementType) }\r\n                </PropertyOpt>\r\n                <PropertyOpt name='methods' >\r\n                    { instr.methods.map(method => fn.signatureEx(method.def, true))\r\n                        .map(signature =>\r\n                            <SystemProperty name={ <span>&nbsp;&nbsp;</span> } value={ signature } />\r\n                        ) }\r\n                </PropertyOpt>\r\n            </SystemProperty>\r\n        );\r\n    }\r\n\r\n\r\n    Pass(instr: IPassInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <PropertyOpt name='name' value={ instr.name } />\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    Technique(instr: ITechniqueInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='name' value={ instr.name } />\r\n                <PropertyOpt name='semantic' value={ instr.semantic } />\r\n                <PropertyOpt name='passes'>\r\n                    { instr.passList.map((pass) => this.Pass(pass)) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    VariableDecl(instr: IVariableDeclInstruction) {\r\n        if (isNull(instr)) {\r\n            return null;\r\n        }\r\n\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='id' value={ instr.id.toString() } />\r\n                <Property name='semantic' value={ instr.semantic } />\r\n                <Property name='type' opened={ true }>\r\n                    { this.VariableType(instr.type) }\r\n                </Property>\r\n                <PropertyOpt name='init' opened={ true }>\r\n                    { this.InitExpr(instr.initExpr) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    FunctionDecl(instr: IFunctionDeclInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) } >\r\n                <PropertyOpt name='attributes'>\r\n                    { instr.attributes.map((attr) => this.Attribute(attr)) }\r\n                </PropertyOpt>\r\n                <Property name='definition' >\r\n                    { this.FunctionDefinition(instr.def) }\r\n                </Property>\r\n                <PropertyOpt name='implementation' >\r\n                    { this.StmtBlock(instr.impl) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n\r\n    IdExpr(instr: IIdExprInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                { this.Id(instr.id) }\r\n                <Property name='declaration' >\r\n                    { this.Unknown(instr.decl) }\r\n                </Property>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n    Id(instr: IIdInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } name='name' value={ instr.name } />\r\n        )\r\n    }\r\n\r\n    PostfixPointExpr(instr: IPostfixPointInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='element'>\r\n                    { this.Unknown(instr.element) }\r\n                </Property>\r\n                <Property name='postfix'>\r\n                    { this.Unknown(instr.postfix) }\r\n                </Property>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n\r\n    PostfixIndexExpr(instr: IPostfixIndexInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='element'>\r\n                    { this.Unknown(instr.element) }\r\n                </Property>\r\n                <Property name='index'>\r\n                    { this.Unknown(instr.index) }\r\n                </Property>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n\r\n    Assigment(instr: IAssignmentExprInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='lval'>\r\n                    { this.Unknown(instr.left) }\r\n                </Property>\r\n                <Property name='rval'>\r\n                    { this.Unknown(instr.right) }\r\n                </Property>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n\r\n    PostfixArithmetic(instr: IPostfixArithmeticInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='operator' value={ instr.operator } />\r\n                <Property name='expr'>\r\n                    { this.Unknown(instr.expr) }\r\n                </Property>\r\n            </Property>\r\n        )\r\n    }\r\n\r\n\r\n    ConstructorCall(instr: IConstructorCallInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='type'>\r\n                    { this.VariableType(instr.ctor) }\r\n                </Property>\r\n                <PropertyOpt name='arguments'>\r\n                    { instr.args.map((arg) => this.Unknown(arg)) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    ArithmeticExpr(instr: IArithmeticExprInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } >\r\n                <Property name='operator' value={ instr.operator } />\r\n                <Property name='operands'>\r\n                    { this.Unknown(instr.left) }\r\n                    { this.Unknown(instr.right) }\r\n                </Property>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    Cast(instr: ICastExprInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } >\r\n                <Property name='type'>\r\n                    { this.Type(instr.type) }\r\n                </Property>\r\n                <Property name='expr' >\r\n                    { this.Unknown(instr.expr) }\r\n                </Property>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    ComplexExpr(instr: IComplexExprInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } >\r\n                <Property name='expr' >\r\n                    { this.Unknown(instr.expr) }\r\n                </Property>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    FunctionCall(instr: IFunctionCallInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } >\r\n                {/* <Property name='type' value={ (instr.callee ? 'method' : 'function') } /> */ }\r\n                <Property name='declaration' >\r\n                    { this.FunctionDecl(instr.decl as IFunctionDeclInstruction) }\r\n                </Property>\r\n                <PropertyOpt name='callee'>\r\n                    { this.Unknown(instr.callee) }\r\n                </PropertyOpt>\r\n                <PropertyOpt name='arguments'>\r\n                    { instr.args.map((arg) => this.Unknown(arg)) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    Int(instr: ILiteralInstruction<number>) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } value={ String(instr.value) } />\r\n            // <Property { ...this.bindProps(instr) } >\r\n            //     <Property { ...this.bindProps(instr) } value={ String(instr.value) } />\r\n            //     <Property name='type'>\r\n            //         { this.Unknown(instr.type) }\r\n            //     </Property>\r\n            // </Property>\r\n        );\r\n    }\r\n\r\n    Float(instr: ILiteralInstruction<number>) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } value={ String(instr.value) } />\r\n        );\r\n    }\r\n\r\n\r\n    Bool(instr: ILiteralInstruction<boolean>) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } value={ String(instr.value) } />\r\n        );\r\n    }\r\n\r\n\r\n    String(instr: ILiteralInstruction<string>) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } value={ String(instr.value) } />\r\n        );\r\n    }\r\n\r\n\r\n    Attribute(instr: IAttributeInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) } name={ instr.name } >\r\n                { instr.args.map((arg) => this.Unknown(arg)) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    FunctionDefinition(instr: IFunctionDefInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                <Property name='name' value={ instr.name } />\r\n                <Property name='signature' value={ fn.signatureEx(instr, true) } />\r\n                <Property name='type' value={ instr.returnType.name } />\r\n                <Property name='numArgsRequired' value={ String(fn.numArgsRequired(instr)) } />\r\n                <PropertyOpt name='semantic' value={ instr.semantic } />\r\n                <PropertyOpt name='arguments'>\r\n                    { instr.params.map((param) => this.VariableDecl(param)) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    StmtBlock(instr: IStmtBlockInstruction) {\r\n        if (isNull(instr)) {\r\n            return null;\r\n        }\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                { instr.stmtList.map(stmt => this.Stmt(stmt)) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n    Stmt(instr: IStmtInstruction) {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_DeclStmt:\r\n                return this.DeclStmt(instr as IDeclStmtInstruction);\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                return this.ReturnStmt(instr as IReturnStmtInstruction);\r\n            case EInstructionTypes.k_StmtBlock:\r\n                return this.StmtBlock(instr as IStmtBlockInstruction);\r\n            case EInstructionTypes.k_ExprStmt:\r\n                return this.ExprStmt(instr as IExprStmtInstruction);\r\n            case EInstructionTypes.k_ForStmt:\r\n                return this.ForStmt(instr as IForStmtInstruction);\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                return this.SemicolonStmt(instr as IStmtInstruction);\r\n            default:\r\n                return this.NotImplemented(instr); // TODO: remove it\r\n        }\r\n    }\r\n\r\n    Type(instr: ITypeInstruction) {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return this.VariableType(instr as IVariableTypeInstruction);\r\n            case EInstructionTypes.k_SystemType:\r\n                return this.SystemType(instr as ITypeInstruction);\r\n            default:\r\n                return this.NotImplemented(instr); // TODO: remove it\r\n        }\r\n\r\n    }\r\n\r\n\r\n    DeclStmt(instr: IDeclStmtInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                <Property name='declarations'>\r\n                    { instr.declList.map(decl => this.Unknown(decl)) }\r\n                </Property>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    ReturnStmt(instr: IReturnStmtInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                <PropertyOpt name='value'>\r\n                    { this.Unknown(instr.expr) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    ExprStmt(instr: IExprStmtInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                { this.Unknown(instr.expr) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    SemicolonStmt(instr: IStmtInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) } />\r\n        );\r\n    }\r\n\r\n\r\n    ForStmt(instr: IForStmtInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr, true) }>\r\n                <PropertyOpt name='init'>\r\n                    { this.Unknown(instr.init) }\r\n                </PropertyOpt>\r\n                <PropertyOpt name='cond'>\r\n                    { this.Unknown(instr.cond) }\r\n                </PropertyOpt>\r\n                <PropertyOpt name='step'>\r\n                    { this.Unknown(instr.step) }\r\n                </PropertyOpt>\r\n                <PropertyOpt name='body'>\r\n                    { this.Stmt(instr.body) }\r\n                </PropertyOpt>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    VariableType(instr: IVariableTypeInstruction) {\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <PropertyOpt name='usages' value={ (instr.usages.join(' ') || null) } />\r\n                <Property name='padding' value={ instr.padding === instruction.UNDEFINE_PADDING ? 'undef' : instr.padding } />\r\n                <PropertyOpt name='subType' opened={ true }>\r\n                    { this.Unknown(instr.subType) }\r\n                </PropertyOpt>\r\n                { this.typeInfo(instr) }\r\n            </Property>\r\n        );\r\n    }\r\n\r\n    InitExpr(instr: IInitExprInstruction) {\r\n        if (isNull(instr)) {\r\n            return null;\r\n        }\r\n\r\n        return (\r\n            <Property { ...this.bindProps(instr) }>\r\n                <Property name='const' value={ String(instr.isConst()) } />\r\n                <Property name='array' value={ String(instr.isArray()) } />\r\n                <Property name='arguments'>\r\n                    { instr.args.map(arg => this.Unknown(arg)) }\r\n                </Property>\r\n            </Property>\r\n        );\r\n    }\r\n\r\n\r\n    NotImplemented(instr: IInstruction) {\r\n        if (!instr) {\r\n            return null;\r\n        }\r\n        return (\r\n            <Property { ...this.bindProps(instr) }\r\n                onClick={ () => console.log(instr) }\r\n                name={\r\n                    <Message size='mini' color='red'>\r\n                        <Message.Content>\r\n                            <Message.Header>Not implemented</Message.Header>\r\n                            <p>{ EInstructionTypes[instr.instructionType] }</p>\r\n                        </Message.Content>\r\n                    </Message>\r\n                }\r\n                key={ instr.instructionID }\r\n            />\r\n        );\r\n    }\r\n\r\n\r\n    bindProps(instr: IInstruction, opened: boolean = false) {\r\n        const { instrList } = this.state;\r\n        const instrState = instrList[instr.instructionID];\r\n\r\n        if (!instrState) {\r\n            instrList[instr.instructionID] = { opened, selected: false };\r\n            return this.bindProps(instr, opened);\r\n        }\r\n\r\n        return {\r\n            name: `${prettifyEName(instr.instructionName)}`,\r\n            key: `${instr.instructionID}`,\r\n            onMouseOver: this.handleMouseOver.bind(this, instr),\r\n            onMouseOut: this.handleMouseOut.bind(this, instr),\r\n            onClick: this.handleMouseClick.bind(this, instr),\r\n            selected: !!instrState.selected,\r\n            opened: !!instrState.opened,\r\n            parent: instr.parent && `I${instr.parent.instructionID}`,\r\n            onParentMouseDown: this.handleParentMouseDown.bind(this, instr),\r\n            onParentMouseUp: this.handleParentMouseUp.bind(this, instr),\r\n            classes: this.props.classes\r\n        }\r\n    }\r\n\r\n\r\n    handleParentMouseDown(instr: IInstruction, e: MouseEvent) {\r\n        e.stopPropagation();\r\n\r\n        let parent = instr.parent;\r\n\r\n        if (parent && parent.sourceNode)\r\n            this.props.onNodeOver(parent);\r\n    }\r\n\r\n    handleParentMouseUp(instr: IInstruction, e: MouseEvent) {\r\n        e.stopPropagation();\r\n\r\n        let parent = instr.parent;\r\n\r\n        if (parent && parent.sourceNode)\r\n            this.props.onNodeOut(parent);\r\n    }\r\n\r\n\r\n    handleMouseOver(instr: IInstruction, e: MouseEvent) {\r\n        e.stopPropagation();\r\n\r\n        this.invertInstructionProperty(instr, 'selected');\r\n\r\n        if (instr.sourceNode) {\r\n            this.props.onNodeOver(instr);\r\n        }\r\n    }\r\n\r\n\r\n    handleMouseOut(instr: IInstruction, e: MouseEvent) {\r\n        e.stopPropagation();\r\n\r\n        this.invertInstructionProperty(instr, 'selected');\r\n\r\n        if (instr.sourceNode) {\r\n            this.props.onNodeOut(instr);\r\n        }\r\n    }\r\n\r\n\r\n    handleMouseClick(instr: IInstruction, e: MouseEvent) {\r\n        e.stopPropagation();\r\n\r\n        this.documentCache = null;\r\n        this.invertInstructionProperty(instr, 'opened');\r\n\r\n        if (instr.sourceNode) {\r\n            this.props.onNodeClick(instr);\r\n        }\r\n    }\r\n\r\n\r\n    invertInstructionProperty(instr: IInstruction, prop: string) {\r\n        let { instrList } = this.state;\r\n        let instrState = { opened: false, selected: false, ...instrList[instr.instructionID] };\r\n        instrState[prop] = !instrState[prop];\r\n        instrList = { ...instrList, [instr.instructionID]: instrState };\r\n        this.setState({ instrList });\r\n    }\r\n\r\n}\r\n\r\nexport default connect<{}, {}, IProgramViewProps>(mapProps(getFileState), {})(ProgramView) as any;\r\n","import { EInstructionTypes, IExprInstruction, IIdExprInstruction, IPostfixPointInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixPointInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr.id\r\n * EMPTY_OPERATOR Instruction IdInstruction\r\n */\r\nexport class PostfixPointInstruction extends ExprInstruction implements IPostfixPointInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n\r\n\r\n    constructor({ element, postfix, ...settings }: IPostfixPointInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });\r\n        \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.postfix = Instruction.$withParent(postfix, this);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.element.toCode()}.${this.postfix.toCode()}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.element.isConst();\r\n    }\r\n}\r\n\r\n","/**\r\n * A simplified symbol table containing the correspondence of unique \r\n * hashes of symbols and their addresses in registers.\r\n * The table is global and does not depend on the stack of functions, \r\n * because hashes are built on the basis of identifiers of instructions \r\n * unique to each function and context.\r\n */\r\nclass SymbolTable<SYMBOL_T>  {\r\n    [key: string]: SYMBOL_T;\r\n\r\n    *[Symbol.iterator]() {\r\n        for (let i in this) {\r\n            yield this[i];\r\n        }\r\n    }\r\n}\r\n\r\nexport default SymbolTable;\r\n","export { expression } from './expression';\r\nexport { fn } from './fn';\r\nexport { instruction } from './instruction';\r\nexport { type } from './type';\r\nexport { variable } from './variable';\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { Item } from \"./Item\";\r\n\r\nexport class State {\r\n    index: number;\r\n    nextStates: IMap<State>;\r\n\r\n    private items: Item[];\r\n    private numBaseItems: number;\r\n    // for debug only\r\n    private numOtherItems: number;\r\n\r\n    constructor() {\r\n        this.nextStates = {};\r\n        this.index = 0;\r\n\r\n        this.items = [];\r\n        this.numBaseItems = 0;\r\n        this.numOtherItems = 0;\r\n    }\r\n\r\n\r\n    eachItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.items.length; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n\r\n    eachBaseItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n    \r\n    isExpected(symbol: string): boolean {\r\n        return !!this.items.find(item => item.isExpected(symbol));\r\n    }\r\n\r\n\r\n    hasItem(value: Item, type: EParserType): Item {\r\n        return this.items.find(item => item.isEqual(value, type)) || null;\r\n    }\r\n\r\n    \r\n    hasParentItem(value: Item): Item {\r\n        return this.items.find(item => item.isParentItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasChildItem(value: Item): Item {\r\n        return this.items.find(item => item.isChildItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasRule(rule: IRule, pos: number): boolean {\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const item = this.items[i];\r\n            if (item.rule === rule && item.pos === pos) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    isEmpty(): boolean {\r\n        return !(this.items.length);\r\n    }\r\n\r\n    \r\n    isEqual(state: State, type: EParserType): boolean {\r\n        if (this.numBaseItems !== state.numBaseItems) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const baseItemA = this.items[i];\r\n\r\n            let isEqual = false;\r\n            for (let i = 0; i < state.numBaseItems; ++i) {\r\n                const baseItemB = state.items[i];\r\n                if (baseItemA.isEqual(baseItemB, type)) {\r\n                    isEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isEqual) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    push(item: Item): void {\r\n        if (this.items.length === 0 || item.pos > 0) {\r\n            assert(this.numOtherItems === 0);\r\n            this.numBaseItems++;\r\n        } else {\r\n            this.numOtherItems++;\r\n        }\r\n        this.items.push(item);\r\n    }\r\n\r\n\r\n    tryPush_LR0(rule: IRule, pos: number): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return false;\r\n        }\r\n\r\n        const item = new Item(rule, pos);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n\r\n    tryPush_LR(rule: IRule, pos: number, expectedSymbol: string): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return sameItem.addExpected(expectedSymbol);\r\n        }\r\n\r\n        const item = new Item(rule, pos, [expectedSymbol]);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n    \r\n    addNextState(symbol: string, state: State): boolean {\r\n        if (this.nextStates[symbol]) {\r\n            return false;\r\n        }\r\n\r\n        this.nextStates[symbol] = state;\r\n        return true;\r\n    }\r\n\r\n    \r\n    deleteNotBase(): void {\r\n        this.items.length = this.numBaseItems;\r\n    }\r\n\r\n    \r\n    toString(isBase: boolean = true, grammarSymbols: Map<string, string> = null): string {\r\n        const items = isBase? this.items.slice(0, this.numBaseItems) : this.items;\r\n        return `State ${this.index}:\\n` +\r\n            items.map(item => `\\t\\t${item.toString(grammarSymbols)}\\n`).join();\r\n    }\r\n}\r\n","import { EParserFlags, EParserType, IASTDocumentFlags } from '@lib/idl/parser/IParser';\r\nimport { GRAMMAR_CONTENT_SPECIFIED, PARSER_PARAMS_CHANGED, PARSING_PARAMS_CHANGED } from '@sandbox/actions/ActionTypeKeys';\r\nimport { IGrammarContentSpecified, IParserParamsActions, IParserParamsChanged, IParsingParamsChanged } from '@sandbox/actions/ActionTypes';\r\nimport { IParserState, IStoreState } from '@sandbox/store/IStoreState';\r\n\r\nimport { handleActions } from './handleActions';\r\n\r\ndeclare const MODE: string;\r\n\r\nconst initialState: IParserState = {\r\n    filename: null,\r\n    grammar: null,\r\n    type: EParserType.k_LALR,\r\n    flags: EParserFlags.k_Default,\r\n    // TODO: rename option (or move it out of this scope)\r\n    parsingFlags: IASTDocumentFlags.k_Optimize\r\n};\r\n\r\nif (MODE === 'development') {\r\n    initialState.flags |= EParserFlags.k_Debug;\r\n    initialState.parsingFlags |= IASTDocumentFlags.k_DeveloperMode;\r\n}\r\n\r\n\r\nexport default handleActions<IParserState, IParserParamsActions>({\r\n    [ GRAMMAR_CONTENT_SPECIFIED ]: (state, action: IGrammarContentSpecified) => \r\n        ({ ...state, grammar: action.payload.content }),\r\n\r\n    [ PARSER_PARAMS_CHANGED ]: (state, action: IParserParamsChanged) => {\r\n        const { flags, type } = action.payload;\r\n        return { ...state, flags, type };\r\n    },\r\n\r\n    [ PARSING_PARAMS_CHANGED ]: (state, action: IParsingParamsChanged) => {\r\n        const { flags } = action.payload;\r\n        return { ...state, parsingFlags: flags };\r\n    }\r\n}, initialState);\r\n\r\n\r\n//- Selectors\r\n\r\nexport const getParser = (state: IStoreState): IParserState => state.parserParams;\r\n","import * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IExprInstruction, ILogicalExprInstruction, ILogicalOperator } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ILogicalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ILogicalOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent boolExpr && || boolExpr\r\n * (&& | ||) Instruction Instruction\r\n */\r\nexport class LogicalExprInstruction extends ExprInstruction implements ILogicalExprInstruction {\r\n    protected _operator: ILogicalOperator;\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n\r\n    constructor({ left, right, operator, ...settings }: ILogicalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_LogicalExpr, type: SystemScope.T_BOOL, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): ILogicalOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this.left.toCode();\r\n        sCode += this.operator;\r\n        sCode += this.right.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IPosition, IRange } from \"@lib/idl/parser/IParser\";\r\n\r\nexport function positionMin(a: IPosition, b: IPosition): IPosition {\r\n    assert(String(a.file) === String(b.file));\r\n    return {\r\n        offset: Math.min(a.offset, b.offset),\r\n        line: Math.min(a.line, b.line),\r\n        column: Math.min(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\nexport function positionMax(a: IPosition, b: IPosition): IPosition {\r\n    assert(String(a.file) === String(b.file));\r\n    return {\r\n        offset: Math.max(a.offset, b.offset),\r\n        line: Math.max(a.line, b.line),\r\n        column: Math.max(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\n\r\nexport function cloneRange(range: IRange): IRange {\r\n    return { start: { ...range.start }, end: { ...range.end } };\r\n}\r\n\r\n\r\nexport function extendRange(parent: IRange, child: IRange): IRange {\r\n    if (child.start.file !== parent.start.file) {\r\n        return parent;\r\n    }\r\n    \r\n    if (child.start.line < parent.start.line) {\r\n        parent.start = { ...child.start };\r\n    } else if (child.start.line === parent.start.line) {\r\n        parent.start = positionMin(child.start, parent.start);\r\n    }\r\n\r\n    if (child.end.line > parent.end.line) {\r\n        parent.end = { ...child.end };\r\n    } else if (child.end.line === parent.end.line) {\r\n        parent.end = positionMax(child.end, parent.end);\r\n    }\r\n\r\n    return parent;\r\n}\r\n\r\nexport function commonRange(...rangeList: IRange[]): IRange {\r\n    const MAX_I32 = Number.MAX_SAFE_INTEGER;\r\n    const MIN_I32 = Number.MIN_SAFE_INTEGER;\r\n\r\n    const file = rangeList[0].start.file;\r\n    \r\n    let start: IPosition = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };\r\n    let end: IPosition = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };\r\n\r\n    rangeList.forEach(range => start = positionMin(start, range.start));\r\n    rangeList.forEach(range => end = positionMax(end, range.end));\r\n\r\n    return { start, end };\r\n}\r\n\r\nexport const checkRange = (range: IRange, offset: number) => range.start.offset <= offset && range.end.offset > offset;","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IRelationalExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport type RelationOperator = \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\";\r\n\r\nexport interface IRelationalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: RelationOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr == != < > <= >= someExpr\r\n * (==|!=|<|>|<=|>=) Instruction Instruction\r\n */\r\nexport class RelationalExprInstruction extends ExprInstruction implements IRelationalExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: RelationOperator;\r\n\r\n\r\n    constructor({ left, right, operator, ...settings }: IRelationalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_RelationalExpr, type: SystemScope.T_BOOL, ...settings });\r\n        this._leftOperand = left;\r\n        this._rightOperand = right;\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    get operator(): RelationOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import * as Bytecode from '@lib/fx/bytecode/Bytecode';\r\nimport * as VM from '@lib/fx/bytecode/VM';\r\n\r\n// uint3 Gid: SV_GroupID    \r\nconst Gid = new Int32Array([0, 0, 0]);\r\n// uint GI: SV_GroupIndex\r\nconst Gi = new Int32Array([0]);\r\n// uint3 GTid: SV_GroupThreadID\r\nconst GTid = new Int32Array([0, 0, 0]);\r\n// uint3 DTid: SV_DispatchThreadID\r\nconst DTid = new Int32Array([0, 0, 0]);\r\n\r\n\r\nfunction dispatch(bundle: VM.Bundle, numgroups: number[], numthreads: number[] = [1, 1, 1]) {\r\n    const [nGroupX, nGroupY, nGroupZ] = numgroups;\r\n    const [nThreadX, nThreadY, nThreadZ] = numthreads;\r\n\r\n    // TODO: get order from bundle\r\n    const SV_GroupID = Bytecode.INPUT0_REGISTER + 0;\r\n    const SV_GroupIndex = Bytecode.INPUT0_REGISTER + 1;\r\n    const SV_GroupThreadID = Bytecode.INPUT0_REGISTER + 2;\r\n    const SV_DispatchThreadID = Bytecode.INPUT0_REGISTER + 3;\r\n\r\n    bundle.input[SV_GroupID] = Gid;\r\n    bundle.input[SV_GroupIndex] = Gi;\r\n    bundle.input[SV_GroupThreadID] = GTid;\r\n    bundle.input[SV_DispatchThreadID] = DTid;\r\n\r\n    for (let iGroupZ = 0; iGroupZ < nGroupZ; ++iGroupZ) {\r\n        for (let iGroupY = 0; iGroupY < nGroupY; ++iGroupY) {\r\n            for (let iGroupX = 0; iGroupX < nGroupX; ++iGroupX) {\r\n                Gid[0] = iGroupX;\r\n                Gid[1] = iGroupY;\r\n                Gid[2] = iGroupZ;\r\n\r\n                for (let iThreadZ = 0; iThreadZ < nThreadZ; ++iThreadZ) {\r\n                    for (let iThreadY = 0; iThreadY < nThreadY; ++iThreadY) {\r\n                        for (let iThreadX = 0; iThreadX < nThreadX; ++iThreadX) {\r\n                            GTid[0] = iThreadX;\r\n                            GTid[1] = iThreadY;\r\n                            GTid[2] = iThreadZ;\r\n\r\n                            DTid[0] = iGroupX * nThreadX + iThreadX;\r\n                            DTid[1] = iGroupY * nThreadY + iThreadY;\r\n                            DTid[2] = iGroupZ * nThreadZ + iThreadZ;\r\n\r\n                            Gi[0] = iThreadZ * nThreadX * nThreadY + iThreadY * nThreadX + iThreadX;\r\n\r\n                            VM.play(bundle);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default dispatch;","/* tslint:disable:typedef */\r\n\r\nimport { isNull } from '@lib/common';\r\nimport { T_BOOL, T_FLOAT, T_INT, T_UINT, T_VOID } from '@lib/fx/analisys/SystemScope';\r\nimport * as Bytecode from '@lib/fx/bytecode';\r\nimport { cdlview } from '@lib/fx/bytecode/DebugLayout';\r\nimport { createFXSLDocument } from '@lib/fx/FXSLDocument';\r\nimport { createSLASTDocument } from '@lib/fx/SLASTDocument';\r\nimport { createDefaultSLParser } from '@lib/fx/SLParser';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { IDispatch } from '@sandbox/actions';\r\nimport * as evt from '@sandbox/actions/ActionTypeKeys';\r\nimport { IDebuggerCompile, IDebuggerOptionsChanged, IMarkerDesc } from '@sandbox/actions/ActionTypes';\r\nimport { getDebugger, getFileState, getScope } from '@sandbox/reducers/sourceFile';\r\nimport IStoreState, { IDebuggerState, IFileState, IMarker } from '@sandbox/store/IStoreState';\r\nimport { createLogic } from 'redux-logic';\r\n\r\nconst DEBUGGER_COLORIZATION_PREFIX = 'debug-ln-clr';\r\n\r\ndeclare const PRODUCTION: boolean;\r\n\r\nfunction cleanupMarkersBatch(state: IStoreState, prefix: string): string[] {\r\n    return Object\r\n        .keys(state.sourceFile.markers)\r\n        .filter(name => name.startsWith(`${prefix}-`));\r\n}\r\n\r\nfunction cleanupMarkers(dispatch: IDispatch, batch: string[]) {\r\n    if (batch.length > 0) {\r\n        dispatch({ type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH, payload: { batch } });\r\n    }\r\n}\r\n\r\ntype IMarkerType = IMarker['type'];\r\n\r\nfunction emitMarkersBatch(list, type: IMarkerType, prefix: string): IMarkerDesc[] {\r\n    return list.map((desc, i) => {\r\n        const { loc, message, payload } = desc;\r\n        return {\r\n            name: `${prefix}-${message}-${i}`,\r\n            range: loc,\r\n            type,\r\n            tooltip: message,\r\n            payload\r\n        };\r\n    });\r\n}\r\n\r\nfunction emitMarkers(dispatch: IDispatch, batch: IMarkerDesc[]) {\r\n    dispatch({ type: evt.SOURCE_CODE_ADD_MARKER_BATCH, payload: { batch } });\r\n}\r\n\r\n\r\nconst emitDebuggerColorization = (list) => emitMarkersBatch(list, 'line', DEBUGGER_COLORIZATION_PREFIX);\r\nconst cleanupDebuggerColorization = (state) => cleanupMarkersBatch(state, DEBUGGER_COLORIZATION_PREFIX);\r\n\r\n\r\nasync function processParsing(state: IStoreState, dispatch): Promise<void> {\r\n    const { content: source, uri } = state.sourceFile;\r\n    const { parsingFlags: flags } = state.parserParams;\r\n\r\n    if (!source) {\r\n        return;\r\n    }\r\n\r\n    const slastDocument = await createSLASTDocument({ source, uri }, flags);\r\n\r\n    if (!PRODUCTION) {\r\n        // verbose(Diagnostics.stringify(diag));\r\n    }\r\n\r\n    // if (!diag.errors)\r\n    {\r\n        dispatch({ type: evt.SOURCE_CODE_PARSING_COMPLETE, payload: { slastDocument } });\r\n    }\r\n}\r\n\r\n\r\nasync function processAnalyze(state: IStoreState, dispatch: IDispatch): Promise<void> {\r\n    const { slastDocument } = state.sourceFile;\r\n\r\n    if (!slastDocument) {\r\n        return;\r\n    }\r\n\r\n    const slDocument = await createFXSLDocument(slastDocument);\r\n\r\n    if (!PRODUCTION) {\r\n        // verbose(Diagnostics.stringify(diag));\r\n    }\r\n\r\n    // if (!diag.errors)\r\n    {\r\n        dispatch({ type: evt.SOURCE_CODE_ANALYSIS_COMPLETE, payload: { result: slDocument } });\r\n    }\r\n}\r\n\r\n\r\nconst updateParserLogic = createLogic<IStoreState>({\r\n    type: [evt.GRAMMAR_CONTENT_SPECIFIED, evt.PARSER_PARAMS_CHANGED],\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const parserParams = getState().parserParams;\r\n        const { grammar, type, flags } = parserParams;\r\n        /**\r\n         * !!! note: all inline functionality inside analyze.ts depends on this setup\r\n         */\r\n        console.log('%c Creating parser...', 'background: #222; color: #bada55');\r\n        try {\r\n            createDefaultSLParser({ grammar, type, flags });\r\n            console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n        } catch (e) {\r\n            console.error('could not initialize parser.');\r\n            return null;\r\n        }\r\n\r\n        // todo: add support for failed setup\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst updateSourceContentLogic = createLogic<IStoreState>({\r\n    type: [evt.SOURCE_CODE_MODIFED, evt.SOURCE_FILE_LOADED],\r\n    latest: true,\r\n    debounce: 500,\r\n\r\n    async process({ getState, action, action$ }, dispatch, done) {\r\n        const $debugger = getDebugger(getState());\r\n        if (!$debugger.options.autocompile) {\r\n            dispatch({ type: evt.DEBUGGER_RESET });\r\n        }\r\n        await processParsing(getState(), dispatch);\r\n        done();\r\n    }\r\n});\r\n\r\n\r\n\r\nconst parsingCompleteLogic = createLogic<IStoreState>({\r\n    type: [evt.SOURCE_CODE_PARSING_COMPLETE],\r\n    async process({ getState, action, action$ }, dispatch, done) {\r\n        await processAnalyze(getState(), <any>dispatch);\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nfunction buildDebuggerSourceColorization(debuggerState: IDebuggerState, fileState: IFileState) {\r\n    // const fn = fileState.slDocument.root.scope.findFunction(debuggerState.expression, null);\r\n    const locList = [];\r\n\r\n    if (debuggerState.runtime) {\r\n        // const from = fn.sourceNode.loc.start.line;\r\n        // const to = fn.sourceNode.loc.end.line;\r\n\r\n        const from = 0;\r\n        const to = fileState.content.split('\\n').length;\r\n\r\n        const cdl = cdlview(debuggerState.runtime.cdl);\r\n\r\n        for (let ln = from; ln <= to; ++ln) {\r\n            const color = cdl.resolveLineColor(ln, fileState.uri);\r\n            if (color !== -1) {\r\n                const loc = { start: { file: null, line: ln, column: 0 }, end: null };\r\n                locList.push({ loc, payload: { color } });\r\n            }\r\n        }\r\n    }\r\n    return locList;\r\n}\r\n\r\n\r\nconst debuggerCompileLogic = createLogic<IStoreState, IDebuggerCompile['payload']>({\r\n    type: evt.DEBUGGER_COMPILE,\r\n    cancelType: evt.DEBUGGER_RESET,\r\n    latest: true,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const file = getFileState(getState());\r\n        const debuggerState = getDebugger(getState());\r\n        const expression = (action.payload && action.payload.expression) || debuggerState.expression || `${Bytecode.DEFAULT_ENTRY_POINT_NAME}()`;\r\n\r\n\r\n        if (!isNull(file.slDocument)) {\r\n            const func = file.slDocument.root.scope.findFunction(expression, null);\r\n            // workaround for debug purposes (interpretations of the expressions string as function name)\r\n            if (func) {\r\n                const program = Bytecode.translate(func);\r\n                dispatch({ type: evt.DEBUGGER_START_DEBUG, payload: { expression, runtime: program } });\r\n            } else {\r\n                const program = await Bytecode.translateExpression(expression, file.slDocument);\r\n                if (!isNull(program)) {\r\n                    dispatch({ type: evt.DEBUGGER_START_DEBUG, payload: { expression, runtime: program } });\r\n                } else {\r\n                    alert('could not evaluate expression, see console log for details');\r\n                }\r\n            }\r\n        } else {\r\n            console.error('invalid compile request!');\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n// const markersAddLogic = createLogic<IStoreState>({\r\n//     type: evt.SOURCE_CODE_ADD_MARKER_BATCH,\r\n//     debounce: 10000,\r\n//     process: ({ getState, action }, dispatch, done) => done()\r\n// });\r\n\r\n// const markersDelLogic = createLogic<IStoreState>({\r\n//     type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH,\r\n//     debounce: 500,\r\n//     process: ({ getState, action }, dispatch, done) => done()\r\n// });\r\n\r\nconst debuggerResetLogic = createLogic<IStoreState>({\r\n    type: evt.DEBUGGER_RESET,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const $debugger = getDebugger(getState());\r\n        if ($debugger.options.colorize) {\r\n            cleanupMarkers(<IDispatch>dispatch, cleanupDebuggerColorization(getState()));\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerOptionsChangedLogic = createLogic<IStoreState, IDebuggerOptionsChanged['payload']>({\r\n    type: evt.DEBUGGER_OPTIONS_CHANGED,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        if (action.payload.options.autocompile === true) {\r\n            dispatch({ type: evt.DEBUGGER_COMPILE });\r\n        }\r\n        if (action.payload.options.colorize === false) {\r\n            cleanupMarkers(<IDispatch>dispatch, cleanupDebuggerColorization(getState()));\r\n        } else {\r\n            const markers = buildDebuggerSourceColorization(getDebugger(getState()), getFileState(getState()));\r\n            emitMarkers(<IDispatch>dispatch, emitDebuggerColorization(markers));\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerStartLogic = createLogic<IStoreState>({\r\n    type: evt.DEBUGGER_START_DEBUG,\r\n\r\n    async process({ getState, action }, dispatch, done) {\r\n        const fileState = getFileState(getState());\r\n        const debuggerState = getDebugger(getState());\r\n\r\n        if (debuggerState.options.colorize) {\r\n            const markers = buildDebuggerSourceColorization(debuggerState, fileState);\r\n            emitMarkers(<IDispatch>dispatch, emitDebuggerColorization(markers));\r\n        }\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nconst debuggerAutocompileLogic = createLogic<IStoreState>({\r\n    type: evt.SOURCE_CODE_ANALYSIS_COMPLETE,\r\n\r\n    process({ getState }, dispatch, done) {\r\n        const debuggerState = getDebugger(getState());\r\n\r\n        if (debuggerState.options.autocompile) {\r\n            dispatch({ type: evt.DEBUGGER_COMPILE });\r\n        }\r\n\r\n        done();\r\n    }\r\n});\r\n\r\n\r\nexport default [\r\n    updateParserLogic,\r\n    updateSourceContentLogic,\r\n    parsingCompleteLogic,\r\n    debuggerCompileLogic,\r\n    debuggerResetLogic,\r\n    debuggerOptionsChangedLogic,\r\n    debuggerStartLogic,\r\n    debuggerAutocompileLogic,\r\n    // markersAddLogic,\r\n    // markersDelLogic\r\n];","import { MakeOptional } from '@lib/common';\r\nimport { EParserType } from '@lib/idl/parser/IParser';\r\nimport IStoreState, { IDebuggerState } from '@sandbox/store/IStoreState';\r\nimport { bindActionCreators, Dispatch } from 'redux';\r\n\r\nimport * as evt from './ActionTypeKeys';\r\nimport { IMarkerDesc } from './ActionTypes';\r\n\r\nexport type IDispatch = Dispatch<any>;\r\nexport type IActionCreator = (dispatch: IDispatch, getState?: () => IStoreState) => Promise<any>;\r\n\r\nexport const parser = {\r\n    setGrammar(content: string) {\r\n        return { type: evt.GRAMMAR_CONTENT_SPECIFIED, payload: { content } };\r\n    },\r\n\r\n    setParams(type: EParserType, flags: number) {\r\n        return { type: evt.PARSER_PARAMS_CHANGED, payload: { type, flags } };\r\n    },\r\n\r\n    setParsingParams(flags: number) {\r\n        return { type: evt.PARSING_PARAMS_CHANGED, payload: { flags } };\r\n    }\r\n};\r\n\r\n\r\nexport const sourceCode = {\r\n    openFile(filename: string) {\r\n        return { type: evt.SOURCE_FILE_REQUEST, payload: { filename } };\r\n    },\r\n\r\n    setContent(content: string, filename?: string) {\r\n        return { type: evt.SOURCE_CODE_MODIFED, payload: { content, filename } };\r\n    },\r\n\r\n\r\n    // setContent (content): IActionCreator {\r\n    //     return async (dispatch: IDispatch, getState) => {\r\n    //         await dispatch({ type: evt.SOURCE_CODE_MODIFED, payload: { content } });\r\n    //         return getState();\r\n    //     };\r\n    // },\r\n\r\n    // IP: Just an incredible example of a AC power!!\r\n    // someRoutine (...argv): IActionCreator {\r\n    //     return async (dispatch: IDispatch, getState) => {\r\n    //         await dispatch({ type: 'some routine', payload: argv });\r\n    //         return getState();\r\n    //     };\r\n    // },\r\n\r\n    //\r\n    // markers api\r\n    //\r\n\r\n    addMarker(marker: IMarkerDesc) {\r\n        return { type: evt.SOURCE_CODE_ADD_MARKER, payload: marker };\r\n    },\r\n\r\n    removeMarker(name: string) {\r\n        return { type: evt.SOURCE_CODE_REMOVE_MARKER, payload: { name } };\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    addBreakpoint(line: number) {\r\n        return { type: evt.SOURCE_CODE_ADD_BREAKPOINT, payload: { line } }\r\n    },\r\n\r\n    removeBreakpoint(line: number) {\r\n        return { type: evt.SOURCE_CODE_REMOVE_BREAKPOINT, payload: { line } }\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    compile(expression: string) {\r\n        return { type: evt.DEBUGGER_COMPILE, payload: { expression } };\r\n    },\r\n\r\n    specifyOptions(options: MakeOptional<IDebuggerState['options']>) {\r\n        return { type: evt.DEBUGGER_OPTIONS_CHANGED, payload: { options } };\r\n    },\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    selectEffect(name: string) {\r\n        return { type: evt.PLAYGROUND_SELECT_EFFECT, payload: { name } };\r\n    },\r\n\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    resetDebugger() {\r\n        return { type: evt.DEBUGGER_RESET };\r\n    }\r\n};\r\n\r\nexport type mapDispatchToProps<T> = (dispatch: IDispatch) => { actions: any; $dispatch: IDispatch; $rowActions: T };\r\nexport function mapActions(actions): mapDispatchToProps<typeof actions> {\r\n    return (dispatch: IDispatch) => {\r\n        return {\r\n            actions: bindActionCreators(actions, dispatch),\r\n\r\n            // debug functionality\r\n            $dispatch: dispatch,\r\n            $rowActions: actions\r\n        };\r\n    };\r\n}\r\n","import { assert, isDef, mwalk } from \"@lib/common\";\r\nimport { instruction } from \"@lib/fx/analisys/helpers\";\r\nimport { Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, IAnnotationInstruction, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprInstruction, IExprStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IInitExprInstruction, IInstruction, ILiteralInstruction, IPassInstruction, IPostfixArithmeticInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, IStmtBlockInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IIfStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { BaseEmitter } from \"./BaseEmitter\";\r\nimport { IntInstruction } from \"../analisys/instructions/IntInstruction\";\r\n\r\nexport interface ITypeInfo {\r\n    typeName: string;\r\n    length: number;\r\n    usage?: string;\r\n}\r\n\r\nexport interface ICodeEmitterOptions {\r\n    mode: 'vertex' | 'pixel' | 'raw';\r\n}\r\n\r\nexport class CodeEmitter extends BaseEmitter {\r\n    protected knownGlobals: string[] = [];\r\n    protected knownTypes: string[] = [];\r\n    protected knownFunctions: number[] = [];\r\n    protected options: ICodeEmitterOptions;\r\n\r\n    constructor(options: ICodeEmitterOptions = { mode: 'raw' }) {\r\n        super();\r\n        this.options = options;\r\n    }\r\n\r\n    get mode(): string {\r\n        return this.options.mode;\r\n    }\r\n\r\n    protected isMain() {\r\n        return this.depth() === 1;\r\n    }\r\n\r\n    protected resolveTypeName(type: ITypeInstruction): string {\r\n        return type.name;\r\n    }\r\n\r\n\r\n    protected resolveType(type: ITypeInstruction): ITypeInfo {\r\n        let complex = type.isComplex();\r\n\r\n        let length: number;\r\n        let typeName: string;\r\n        let usages: string[];\r\n        let usage: string;\r\n\r\n        if (!complex) {\r\n            typeName = this.resolveTypeName(type);\r\n        } else {\r\n            typeName = type.name;\r\n\r\n            if (this.knownTypes.indexOf(typeName) === -1) {\r\n                this.begin();\r\n                this.emitComplexType(type);\r\n                this.emitChar(';');\r\n                this.end();\r\n\r\n                this.knownTypes.push(typeName);\r\n            }\r\n        }\r\n\r\n        if (type.instructionType === EInstructionTypes.k_VariableType) {\r\n            const vtype = type as IVariableTypeInstruction;\r\n            usages = vtype.usages as string[];\r\n        }\r\n\r\n        if (type.isNotBaseArray()) {\r\n            length = type.length;\r\n        }\r\n\r\n        if (usages && usages.length) {\r\n            usage = usages.join(' ');\r\n        }\r\n\r\n        return { typeName, length, usage };\r\n    }\r\n\r\n\r\n    emitLine(line: string, comment?: string) {\r\n        this.emitChar(line);\r\n        comment && assert(comment.split('\\n').length === 1);\r\n        comment && (this.emitChar('\\t'), this.emitComment(comment));\r\n        this.emitNewline();\r\n    }\r\n\r\n    emitComment(comment: string) {\r\n        //\r\n        if (comment.indexOf('\\n') === -1) {\r\n            this.emitLine(`// ${comment}`);\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * \r\n         */\r\n        this.emitLine('/**');\r\n        this.push(' * ');\r\n        comment.split('\\n').forEach(line => this.emitLine(line));\r\n        this.pop();\r\n        this.emitLine(' */');\r\n    }\r\n\r\n\r\n    emitComplexType(ctype: ITypeInstruction) {\r\n        assert(ctype.isComplex());\r\n\r\n        this.emitKeyword('struct');\r\n        this.emitKeyword(ctype.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n\r\n        ctype.fields.map(field => (this.emitStmt(field), this.emitNewline()));\r\n\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n\r\n    emitVariableDecl(src: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string): void {\r\n        const { typeName, length, usage } = this.resolveType(src.type);\r\n        const name = rename ? rename(src) : src.name;\r\n\r\n        usage && this.emitKeyword(usage);\r\n        this.emitKeyword(typeName);\r\n        this.emitKeyword(name);\r\n        length && this.emitChar(`[${length}]`);\r\n        src.initExpr && (this.emitKeyword('='), this.emitSpace(), this.emitExpression(src.initExpr));\r\n        src.semantic && this.emitSemantic(src.semantic);\r\n        src.annotation && this.emitAnnotation(src.annotation);\r\n    }\r\n\r\n\r\n    emitIfStmt(stmt: IIfStmtInstruction): void {\r\n        this.emitKeyword('if');\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(stmt.cond);\r\n        this.emitChar(')');\r\n        this.emitNewline();\r\n        this.emitStmt(stmt.conseq);\r\n\r\n        if (stmt.contrary) {\r\n            this.emitNewline();\r\n            this.emitKeyword('else');\r\n            this.emitStmt(stmt.contrary);\r\n        }\r\n    }\r\n\r\n\r\n    emitSemantic(semantic: string) {\r\n        this.emitChar(':');\r\n        this.emitKeyword(semantic);\r\n    }\r\n\r\n    emitAnnotation(anno: IAnnotationInstruction) {\r\n        // TODO: add annotation emission.\r\n    }\r\n\r\n    emitCompile(compile: ICompileExprInstruction) {\r\n        this.emitFunction(compile.function);\r\n\r\n        this.emitKeyword('compile');\r\n        this.emitKeyword(compile.function.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(compile.args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n    emitFunction(fn: IFunctionDeclInstruction) {\r\n\r\n        if (fn.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n           return;\r\n        }\r\n\r\n        if (this.knownFunctions.indexOf(fn.instructionID) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.knownFunctions.push(fn.instructionID);\r\n\r\n        const def = fn.def;\r\n        const { typeName } = this.resolveType(def.returnType);\r\n\r\n        this.begin();\r\n        {\r\n            this.emitKeyword(typeName);\r\n            this.emitKeyword(fn.name);\r\n            this.emitChar('(');\r\n            this.emitNoSpace();\r\n            this.emitParams(def.params);\r\n            this.emitChar(')');\r\n            this.emitNewline();\r\n            this.emitBlock(fn.impl);\r\n        }\r\n        this.end();\r\n    }\r\n\r\n    emitExpression(expr: IExprInstruction) {\r\n        if (!expr) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        | ICastExprInstruction\r\n        | ILogicalExprInstruction\r\n        | IPostfixIndexInstruction\r\n        | ISamplerStateBlockInstruction\r\n        */\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                return this.emitArithmetic(expr as IArithmeticExprInstruction);\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                return this.emitAssigment(expr as IAssignmentExprInstruction);\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return this.emitPostfixPoint(expr as IPostfixPointInstruction);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return this.emitIdentifier(expr as IIdExprInstruction);\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                return this.emitFCall(expr as IFunctionCallInstruction);\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                return this.emitCCall(expr as IConstructorCallInstruction);\r\n            case EInstructionTypes.k_FloatExpr:\r\n                return this.emitFloat(expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_IntExpr:\r\n                return this.emitInteger(expr as ILiteralInstruction<number>);\r\n            case EInstructionTypes.k_BoolExpr:\r\n                return this.emitBool(expr as ILiteralInstruction<boolean>);\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return this.emitComplexExpr(expr as IComplexExprInstruction);\r\n            case EInstructionTypes.k_CompileExpr:\r\n                return this.emitCompile(expr as ICompileExprInstruction);\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n                return this.emitConditionalExpr(expr as IConditionalExprInstruction);\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                return this.emitRelationalExpr(expr as IRelationalExprInstruction);\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                return this.emitUnaryExpr(expr as IUnaryExprInstruction);\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n                return this.emitPostfixArithmetic(expr as IPostfixArithmeticInstruction);\r\n            case EInstructionTypes.k_InitExpr:\r\n                return this.emitInitExpr(expr as IInitExprInstruction);\r\n            case EInstructionTypes.k_CastExpr:\r\n                return this.emitCast(expr as ICastExprInstruction);\r\n            default:\r\n                assert(false, 'unsupported instruction found');\r\n        }\r\n    }\r\n\r\n    emitFloat(lit: ILiteralInstruction<number>) {\r\n        const sval = String(lit.value);\r\n        this.emitKeyword(sval);\r\n        (sval.indexOf('.') === -1) && this.emitChar('.');\r\n        this.emitChar('f');\r\n    }\r\n\r\n    emitBool(lit: ILiteralInstruction<boolean>) {\r\n        this.emitKeyword(lit.value ? 'true' : 'false');\r\n    }\r\n\r\n    emitComplexExpr(complex: IComplexExprInstruction) {\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpression(complex.expr);\r\n        this.emitChar(')');\r\n    }\r\n\r\n    emitConditionalExpr(cond: IConditionalExprInstruction) {\r\n        this.emitExpression(cond.condition);\r\n        this.emitKeyword('?');\r\n        this.emitExpression(cond.left as IExprInstruction);\r\n        this.emitKeyword(':');\r\n        this.emitExpression(cond.right as IExprInstruction);\r\n    }\r\n\r\n    emitInteger(lit: ILiteralInstruction<number>) {\r\n        // TODO: use IIntInstructions instead of ILiteralInstruction\r\n        this.emitKeyword(`${lit.value.toFixed(0)}${!(lit as IntInstruction).signed? 'u': ''}`);\r\n    }\r\n\r\n    emitRelationalExpr(rel: IRelationalExprInstruction) {\r\n        this.emitExpression(rel.left);\r\n        this.emitKeyword(rel.operator);\r\n        this.emitExpression(rel.right);\r\n    }\r\n\r\n    emitUnaryExpr(unary: IUnaryExprInstruction) {\r\n        this.emitChar(unary.operator);\r\n        this.emitExpression(unary.expr);\r\n    }\r\n\r\n    emitPostfixArithmetic(par: IPostfixArithmeticInstruction) {\r\n        this.emitExpression(par.expr);\r\n        this.emitChar(par.operator);\r\n    }\r\n\r\n    emitExpressionList(list: IExprInstruction[]) {\r\n        list.forEach((expr, i) => {\r\n            this.emitExpression(expr);\r\n            (i != list.length - 1) && this.emitChar(',');\r\n        })\r\n    }\r\n\r\n    emitParams(params: IVariableDeclInstruction[]) {\r\n        params.forEach((param, i, list) => {\r\n            this.emitVariableDecl(param);\r\n            (i + 1 != list.length) && this.emitChar(',');\r\n        });\r\n    }\r\n\r\n    emitInitExpr(init: IInitExprInstruction) {\r\n        if (init.args.length > 1) {\r\n            this.emitChar('{');\r\n            this.emitNoSpace();\r\n            this.emitExpressionList(init.args);\r\n            this.emitChar('}');\r\n            return;\r\n        }\r\n\r\n        this.emitExpression(init.args[0]);\r\n    }\r\n\r\n    emitCast(cast: ICastExprInstruction) {\r\n        if (cast.isUseless()) {\r\n            return;\r\n        }\r\n\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n\r\n        const { typeName } = this.resolveType(cast.type);\r\n        this.emitKeyword(typeName);\r\n\r\n        this.emitChar(')');\r\n        this.emitNoSpace();\r\n        this.emitExpression(cast.expr);\r\n    }\r\n\r\n    emitArithmetic(arthm: IArithmeticExprInstruction) {\r\n        this.emitExpression(arthm.left);\r\n        this.emitKeyword(arthm.operator);\r\n        this.emitExpression(arthm.right);\r\n    }\r\n\r\n    emitAssigment(asgm: IAssignmentExprInstruction) {\r\n        this.emitExpression(asgm.left);\r\n        this.emitKeyword('=');\r\n        this.emitSpace();\r\n        assert(instruction.isExpression(asgm.right));\r\n        this.emitExpression(asgm.right as IExprInstruction);\r\n    }\r\n\r\n\r\n\r\n    emitPostfixPoint(pfxp: IPostfixPointInstruction) {\r\n        this.emitExpression(pfxp.element);\r\n        this.emitChar('.');\r\n        this.emitChar(pfxp.postfix.name);\r\n    }\r\n\r\n    emitGlobal(decl: IVariableDeclInstruction) {\r\n        const name = decl.name;\r\n\r\n        // if (isMain() && decl.isParameter() && !decl.isUniform()) {\r\n        // TODO: add support of main arguments with basic types (attributes)\r\n        // }\r\n\r\n        const isUniformArg = this.isMain() && decl.isParameter() && decl.type.isUniform();\r\n\r\n        if (decl.isGlobal() || isUniformArg) {\r\n            assert(decl.type.isUniform());\r\n\r\n            if (this.knownGlobals.indexOf(name) === -1) {\r\n                this.begin();\r\n                this.emitStmt(decl);\r\n                this.end();\r\n                this.knownGlobals.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    emitIdentifier(id: IIdExprInstruction) {\r\n        const { decl, name } = id;\r\n\r\n        this.emitGlobal(decl);\r\n        this.emitKeyword(name);\r\n    }\r\n\r\n\r\n    emitCCall(call: IConstructorCallInstruction) {\r\n        const args = call.args as IExprInstruction[];\r\n        const { typeName } = this.resolveType(call.ctor);\r\n\r\n        this.emitKeyword(typeName);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitFCall(call: IFunctionCallInstruction) {\r\n        const decl = call.decl;\r\n        const args = call.args;\r\n\r\n        this.emitFunction(decl);\r\n\r\n        this.emitKeyword(decl.name);\r\n        this.emitChar('(');\r\n        this.emitNoSpace();\r\n        this.emitExpressionList(args);\r\n        this.emitChar(')');\r\n    }\r\n\r\n\r\n    emitReturnStmt(stmt: IReturnStmtInstruction) {\r\n        this.emitKeyword('return');\r\n        this.emitExpression(stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    emitExpressionStmt(stmt: IExprStmtInstruction) {\r\n        this.emitExpression(stmt.expr);\r\n        this.emitChar(';');\r\n    }\r\n\r\n\r\n    /*\r\n        | IStmtBlockInstruction\r\n        | IWhileStmtInstruction\r\n        | IForStmtInstruction;\r\n    */\r\n    emitStmt(stmt: IInstruction) {\r\n        switch (stmt.instructionType) {\r\n            case EInstructionTypes.k_DeclStmt:\r\n                (stmt as IDeclStmtInstruction).declList.forEach(dcl => (this.emitStmt(dcl)));\r\n                break;\r\n            case EInstructionTypes.k_ExprStmt:\r\n                this.emitExpressionStmt(stmt as IExprStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_ReturnStmt:\r\n                this.emitReturnStmt(stmt as IReturnStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_VariableDecl:\r\n                this.emitVariableDecl(stmt as IVariableDeclInstruction);\r\n                this.emitChar(';');\r\n                break;\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                this.emitChar(';');\r\n                break;\r\n            case EInstructionTypes.k_IfStmt:\r\n                this.emitIfStmt(stmt as IIfStmtInstruction);\r\n                break;\r\n            case EInstructionTypes.k_StmtBlock:\r\n                this.emitBlock(stmt as IStmtBlockInstruction);\r\n                break;\r\n            default:\r\n                console.warn(`unknown stmt found: '${stmt.instructionName}'`);\r\n        }\r\n    }\r\n\r\n    emitBlock(blk: IStmtBlockInstruction) {\r\n        this.emitChar('{');\r\n        this.push();\r\n        blk.stmtList.forEach(stmt => (this.emitStmt(stmt), this.emitNewline()));\r\n        this.pop();\r\n        this.emitChar('}');\r\n    }\r\n\r\n    emitPass(pass: IPassInstruction) {\r\n        this.emitKeyword('pass');\r\n        pass.name && this.emitKeyword(pass.name);\r\n        this.emitNewline();\r\n        this.emitChar('{');\r\n        this.push();\r\n        this.emitPassBody(pass);\r\n        this.pop();\r\n        this.emitChar('}');\r\n        this.emitNewline();\r\n    }\r\n\r\n\r\n\r\n    emitPassBody(pass: IPassInstruction) {\r\n        // TODO: replace with emitCompile();\r\n        pass.vertexShader && (\r\n            this.emitFunction(pass.vertexShader),\r\n\r\n            this.emitKeyword('VertexShader'),\r\n            this.emitKeyword('='),\r\n            this.emitKeyword('compile'),\r\n            this.emitKeyword(pass.vertexShader.name),\r\n            this.emitChar('()'),\r\n            this.emitChar(';'),\r\n            this.emitNewline()\r\n        );\r\n\r\n        pass.pixelShader && (\r\n            this.emitFunction(pass.pixelShader),\r\n\r\n            this.emitKeyword('PixelShader'),\r\n            this.emitKeyword('='),\r\n            this.emitKeyword('compile'),\r\n            this.emitKeyword(pass.pixelShader.name),\r\n            this.emitChar('()'),\r\n            this.emitChar(';'),\r\n            this.emitNewline()\r\n        );\r\n\r\n        this.emitNewline();\r\n\r\n        // mwalk(pass.renderStates, (val, key) => {\r\n        //     console.log(ERenderStates[key], ERenderStateValues[val]);\r\n        // });\r\n    }\r\n\r\n    emit(instr: IInstruction): CodeEmitter {\r\n        if (!instr) {\r\n            // TODO: emit error.\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isExpression(instr)) {\r\n            this.emitExpression(instr as IExprInstruction);\r\n            return this;\r\n        }\r\n\r\n        if (instruction.isStatement(instr)) {\r\n            this.emitStmt(instr);\r\n            return this;\r\n        }\r\n\r\n        //\r\n        // Other types\r\n        //\r\n\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_FunctionDecl:\r\n                this.emitFunction(instr as IFunctionDeclInstruction);\r\n                break;\r\n            default:\r\n                assert(false, 'unsupported instruction found');\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\nexport function translate(instr: IInstruction, options?: ICodeEmitterOptions): string {\r\n    return (new CodeEmitter(options)).emit(instr).toString();\r\n}","export default \"S : Program\\r\\nProgram : --add\\r\\nProgram : Decls\\r\\n\\r\\nDecls : Decl --expose\\r\\nDecls : Decls Decl\\r\\n\\r\\nDecl : ';'\\r\\nDecl : TypeDecl\\r\\nDecl : VariableDecl\\r\\nDecl : VarStructDecl\\r\\nDecl : FunctionDecl\\r\\nDecl : TechniqueDecl\\r\\n#if FX_PART\\r\\n    Decl : PartFxDecl\\r\\n#endif \\r\\nDecl : UseDecl\\r\\nDecl : ImportDecl\\r\\nDecl : ProvideDecl\\r\\nDecl : IncludeDecl\\r\\nDecl : ERROR\\r\\n\\r\\nIncludeDecl : '#' T_KW_INCLUDE String --skip --F includeCode\\r\\n\\r\\nImportDecl : T_KW_IMPORT String ';'\\r\\n\\r\\nProvideDecl : T_KW_PROVIDE ComplexNameOpt ';'\\r\\nProvideDecl : T_KW_PROVIDE ComplexNameOpt T_KW_AS ComplexNameOpt ';'\\r\\n\\r\\nUseDecl : T_KW_USE Mode\\r\\nMode : T_KW_STRICT\\r\\n\\r\\nUsages : Usage --expose\\r\\nUsages : Usages Usage\\r\\nUsage : T_KW_STATIC --add\\r\\nUsage : T_KW_UNIFORM\\r\\nUsage : T_KW_EXTERN\\r\\nUsage : T_KW_VOLATILE\\r\\nUsage : T_KW_INLINE\\r\\nUsage : ConstUsage\\r\\n\\r\\nConstUsages : ConstUsage --expose\\r\\nConstUsages : ConstUsages ConstUsage\\r\\nConstUsage : T_KW_CONST\\r\\nConstUsage : T_KW_ROW_MAJOR\\r\\nConstUsage : T_KW_COLUMN_MAJOR\\r\\n\\r\\nUsageType : Type --add\\r\\nUsageType : Usages Type\\r\\n\\r\\nUsageStructDecl : StructDecl --add\\r\\nUsageStructDecl : Usages StructDecl\\r\\n\\r\\nTypeDecl : T_KW_TYPEDEF ConstType TypeDefs ';' --add\\r\\nTypeDecl : T_KW_TYPEDEF ConstStructDecl TypeDefs ';'\\r\\nTypeDecl : StructDecl --F addType ';'\\r\\nTypeDefs : VariableDim\\r\\nTypeDefs : VariableDim ',' TypeDefs\\r\\n\\r\\n# GenericParams : '<' Arguments '>'\\r\\n# GenericParamsOpt: --expose\\r\\n# GenericParamsOpt: GenericParams\\r\\n\\r\\nType : BaseType --add\\r\\nType : Struct\\r\\nType : TypeId\\r\\nType : T_KW_STRUCT TypeId\\r\\n\\r\\nConstType : Type --add\\r\\nConstType : ConstUsages Type\\r\\nConstTypeDim : ConstType --expose\\r\\nConstTypeDim : ConstTypeDim '[' ConstantExpr ']'\\r\\n\\r\\nBaseType : T_KW_VOID --add\\r\\nBaseType : ScalarType\\r\\nBaseType : VectorType\\r\\nBaseType : MatrixType\\r\\nBaseType : ObjectType\\r\\n\\r\\nScalarType : T_KW_BOOL --add\\r\\nScalarType : T_KW_INT\\r\\nScalarType : T_KW_UINT\\r\\nScalarType : T_KW_HALF\\r\\nScalarType : T_KW_FLOAT\\r\\nScalarType : T_KW_DOUBLE\\r\\n\\r\\nVectorType : T_KW_VECTOR --add\\r\\nVectorType : T_KW_VECTOR '<' ScalarType ',' AddExpr '>'\\r\\n\\r\\nMatrixType : T_KW_MATRIX --add\\r\\nMatrixType : T_KW_MATRIX '<' ScalarType ',' ConstantExpr ',' AddExpr '>'\\r\\n\\r\\nObjectType : T_KW_STRING --add\\r\\nObjectType : T_KW_TEXTURE\\r\\nObjectType : T_KW_TEXTURE1D\\r\\nObjectType : T_KW_TEXTURE2D\\r\\nObjectType : T_KW_TEXTURE3D\\r\\nObjectType : T_KW_TEXTURECUBE\\r\\nObjectType : T_KW_SAMPLER\\r\\nObjectType : T_KW_SAMPLER1D\\r\\nObjectType : T_KW_SAMPLER2D\\r\\nObjectType : T_KW_SAMPLER3D\\r\\nObjectType : T_KW_SAMPLERCUBE\\r\\nObjectType : T_KW_PIXELSHADER\\r\\nObjectType : T_KW_VERTEXSHADER\\r\\nObjectType : T_KW_PIXELFRAGMENT\\r\\nObjectType : T_KW_VERTEXFRAGMENT\\r\\nObjectType : T_KW_STATEBLOCK\\r\\nObjectType : T_KW_RWBUFFER '<' Type '>'\\r\\nObjectType : T_KW_RWSTRUCTUREDBUFFER '<' Type '>'\\r\\nObjectType : T_KW_APPENDSTRUCTUREDBUFFER '<' Type '>'\\r\\n\\r\\n\\r\\n# struct Name\\r\\n# {\\r\\n#     [InterpolationModifier] Type[RxC] MemberName;\\r\\n#     ...\\r\\n# };\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509668(v=vs.85).aspx\\r\\n\\r\\nStruct : T_KW_STRUCT '{' '}' --add\\r\\nStruct : T_KW_STRUCT '{' StructDecls '}'\\r\\nStructDecl : T_KW_STRUCT Id '{' '}' --add\\r\\nStructDecl : T_KW_STRUCT Id '{' UseDecl StructDecls '}'\\r\\nStructDecl : T_KW_STRUCT Id '{' StructDecls '}'\\r\\n\\r\\nConstStructDecl : StructDecl\\r\\nConstStructDecl : ConstUsages StructDecl\\r\\n\\r\\nStructDecls : VariableDecl --expose\\r\\nStructDecls : VariableDecl StructDecls\\r\\n\\r\\nSemantic : ':' Id --add\\r\\nSemantic : ':' T_KW_REGISTER '(' Register ')'\\r\\nSemantics : Semantic\\r\\nSemantics : Semantics Semantic\\r\\nSemanticsOpt :\\r\\nSemanticsOpt : Semantics\\r\\n\\r\\nRegister : Id\\r\\nRegister : Target ',' Id\\r\\n\\r\\nAnnotation : AnnotationBegin AnnotationEnd  --add\\r\\nAnnotation : AnnotationBegin AnnotationDecls AnnotationEnd\\r\\nAnnotationOpt :\\r\\nAnnotationOpt : Annotation\\r\\nAnnotationBegin : '<'\\r\\nAnnotationDecls : VariableDecl\\r\\nAnnotationDecls : VariableDecl AnnotationDecls\\r\\nAnnotationEnd : '>'\\r\\n\\r\\nInitializer : '=' AssignmentExpr --add\\r\\nInitializer : '=' ERROR --add\\r\\nInitializer : '=' '{' InitExprs '}'\\r\\nInitializer : '=' '{' InitExprs ',' '}'\\r\\n\\r\\n# InitializerOpt :\\r\\n# InitializerOpt : Initializer\\r\\n\\r\\n\\r\\n# [Storage_Class] [Type_Modifier] Type Name[Index]\\r\\n#    [: Semantic]\\r\\n#    [: Packoffset]\\r\\n#    [: Register];\\r\\n#    [Annotations]\\r\\n#    [= Initial_Value]\\r\\n#\\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509706(v=vs.85).aspx\\r\\n\\r\\nVariableDecl : UsageType Variables ';' --add\\r\\nVariableDecl : UsageType Variables ERROR --add\\r\\nVarStructDecl : UsageStructDecl Variables ';' --add\\r\\nVariables : Variable --expose\\r\\nVariables : Variables ',' Variable\\r\\n# Variables : Variables ERROR Variable\\r\\nVariables : Variables ',' ERROR\\r\\nVariable : VariableDim SemanticsOpt AnnotationOpt Initializer --add\\r\\nVariable : VariableDim SemanticsOpt AnnotationOpt --add\\r\\nVariableDim : NonTypeId --add\\r\\nVariableDim : VariableDim '[' ConstantExpr ']'\\r\\n\\r\\n\\r\\n# [StorageClass] [clipplanes()] [precise] Return_Value Name ( [ArgumentList] ) [: Semantic]\\r\\n# {ок\\r\\n#   [StatementBlock]\\r\\n# };\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509607(v=vs.85).aspx\\r\\n\\r\\nFunctionDecl : Attributes FunctionDef ';' --add\\r\\nFunctionDecl : FunctionDef ';' --add\\r\\nFunctionDecl : Attributes FunctionDef AnnotationOpt StmtBlock\\r\\nFunctionDecl : FunctionDef AnnotationOpt StmtBlock\\r\\n\\r\\n# TODO: remove it;\\r\\nFunctionDecl : Attributes FunctionDef AnnotationOpt ERROR\\r\\nFunctionDecl : FunctionDef AnnotationOpt ERROR\\r\\n\\r\\nFunctionDef : UsageType NonTypeId ParamList SemanticsOpt\\r\\n\\r\\nAttribute : '[' Id '(' ArgumentsOpt ')' ']'\\r\\nAttribute : '[' Id ']'\\r\\nAttributes : Attribute --expose\\r\\nAttributes : Attributes Attribute\\r\\nAttributesOpt : --expose\\r\\nAttributesOpt : Attributes\\r\\n\\r\\nParamList : '(' ')'\\r\\nParamList : '(' T_KW_VOID ')'\\r\\nParamList : '(' ParameterDecls ')'\\r\\n\\r\\n\\r\\n# [InputModifier] Type Name [: Semantic] [InterpolationModifier] [= Initializers]\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509606(v=vs.85).aspx\\r\\n\\r\\nParameterDecls : ParameterDecl --expose\\r\\nParameterDecls : ParameterDecls ',' ParameterDecl\\r\\nParameterDecls : ParameterDecls ERROR ParameterDecl\\r\\nParameterDecls : ParameterDecls ',' ERROR\\r\\nParameterDecls : ERROR\\r\\nParameterDecl : ParamUsageType Variable\\r\\n\\r\\nParamUsageType : Type --add\\r\\nParamUsageType : ParamUsages Type\\r\\n\\r\\nParamUsages : ParamUsage --expose\\r\\nParamUsages : ParamUsages ParamUsage\\r\\nParamUsage : T_KW_IN --add\\r\\nParamUsage : T_KW_OUT\\r\\nParamUsage : T_KW_INOUT\\r\\nParamUsage : T_KW_UNIFORM\\r\\nParamUsage : ConstUsage\\r\\n\\r\\n\\r\\nTechniqueDecl : T_KW_TECHNIQUE ComplexNameOpt SemanticsOpt AnnotationOpt TechniqueBody --add\\r\\nTechniqueBody : '{' '}'  --add\\r\\nTechniqueBody : '{' PassDecls '}'\\r\\n\\r\\nComplexNameOpt : ComplexName --add\\r\\nComplexName : Id --expose\\r\\nComplexName : ComplexName '.' Id\\r\\n\\r\\nPassDecls : PassDecl --expose\\r\\nPassDecls : PassDecls PassDecl\\r\\nPassDecl : T_KW_PASS IdOpt AnnotationOpt PassStateBlock --add\\r\\nPassDecl : ';'\\r\\n\\r\\nPassStateBlock : '{' '}' --add\\r\\nPassStateBlock : '{' PassStates '}'\\r\\nPassStates : PassState --expose\\r\\nPassStates : PassStates PassState\\r\\n\\r\\nPassState : Id StateIndex '=' PassStateExpr ';' --add\\r\\n\\r\\n# todo: move all particles declarations to separate grammar!\\r\\n#if FX_PART\\r\\n\\r\\nPartFxDecl : T_KW_FXPART ComplexNameOpt SemanticsOpt AnnotationOpt PartFxBody --add\\r\\n\\r\\nPartFxBody : '{' '}' \\r\\nPartFxBody : '{' PartFxProperties '}'\\r\\n\\r\\nPartFxProperties : PartFxProperty --expose\\r\\nPartFxProperties : PartFxProperties PartFxProperty\\r\\n\\r\\nPartFxProperty : PassState\\r\\nPartFxProperty : PassDecl\\r\\n\\r\\n#endif // FX_PART\\r\\n\\r\\nStateBlock : '{' '}' --add\\r\\nStateBlock : '{' States '}'\\r\\n\\r\\n\\r\\nStates : State --expose\\r\\nStates : States State\\r\\nState : Id StateIndex '=' StateExpr ';' --add\\r\\n\\r\\nStateIndex :\\r\\nStateIndex : '[' Uint ']'\\r\\n\\r\\nStmtBlock : '{' '}' --add\\r\\nStmtBlock : '{' Stmts '}'  \\r\\n\\r\\nStmts : Stmt --expose\\r\\nStmts : Stmts Stmt\\r\\n\\r\\n# SimpleStmt : ERROR ';' \\r\\n# SimpleStmt : ';' --add\\r\\n\\r\\nSimpleStmt : Expr ';'\\r\\nSimpleStmt : Expr ERROR\\r\\nSimpleStmt : T_KW_RETURN ';'\\r\\nSimpleStmt : T_KW_RETURN Expr ';'\\r\\nSimpleStmt : T_KW_RETURN ERROR ';'\\r\\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' Expr ')' ';'\\r\\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' ERROR ')' ';'\\r\\nSimpleStmt : StmtBlock\\r\\nSimpleStmt : T_KW_DISCARD ';'\\r\\nSimpleStmt : TypeDecl\\r\\nSimpleStmt : VariableDecl --add\\r\\nSimpleStmt : VarStructDecl\\r\\nSimpleStmt : T_KW_BREAK ';'\\r\\nSimpleStmt : T_KW_BREAK ERROR\\r\\nSimpleStmt : T_KW_CONTINUE ';'\\r\\nSimpleStmt : T_KW_CONTINUE ERROR\\r\\n\\r\\n#if FX_PART\\r\\nSimpleStmt : T_KW_SPAWN '(' Uint ')' NonTypeId '(' ArgumentsOpt ')' ';'\\r\\n#endif\\r\\n\\r\\n\\r\\nNonIfStmt : SimpleStmt --add\\r\\nNonIfStmt : WhileStmt NonIfStmt\\r\\nNonIfStmt : ForStmt NonIfStmt\\r\\n\\r\\nStmt : SimpleStmt --add\\r\\nStmt : UseDecl\\r\\nStmt : WhileStmt Stmt\\r\\nStmt : ForStmt Stmt\\r\\nStmt : IfStmt Stmt\\r\\nStmt : IfStmt NonIfStmt T_KW_ELSE Stmt\\r\\nStmt : ERROR\\r\\nStmt : ';'\\r\\n\\r\\nIfStmt : AttributesOpt T_KW_IF '(' Expr ')' --expose\\r\\nIfStmt : AttributesOpt T_KW_IF '(' ERROR ')' --expose\\r\\n\\r\\nWhileStmt : T_KW_WHILE '(' Expr ')' --expose\\r\\nWhileStmt : T_KW_WHILE '(' ERROR ')' --expose\\r\\n\\r\\nForStmt : For '(' ForInit ForCond ForStep ')' --expose\\r\\nForStmt : For ERROR --expose\\r\\n\\r\\nFor : T_KW_FOR\\r\\n\\r\\nForInit : ';' --add\\r\\nForInit : Expr ';'\\r\\nForInit : VariableDecl\\r\\nForInit : ERROR ';'\\r\\n\\r\\nForCond : ';' --add\\r\\nForCond : Expr ';'\\r\\nForCond : ERROR ';'\\r\\n\\r\\nForStep : --add\\r\\nForStep : Expr\\r\\nForStep : ERROR\\r\\n\\r\\nDwordExpr : Dword\\r\\nDwordExpr : Dword '|' DwordExpr\\r\\n\\r\\nDwordExprSeq : DwordExpr --expose\\r\\nDwordExprSeq : DwordExpr ',' DwordExprSeq\\r\\n\\r\\nPassStateExpr : DwordExpr --add\\r\\nPassStateExpr : ComplexExpr\\r\\nPassStateExpr : '{' DwordExprSeq '}'\\r\\n\\r\\nStateExpr : DwordExpr --add\\r\\nStateExpr : ComplexExpr\\r\\nStateExpr : '{' InitExprs '}'\\r\\nStateExpr : '{' InitExprs ',' '}'\\r\\nStateExpr : '<' RelationalExpr '>'\\r\\n\\r\\nSimpleExpr : T_KW_TRUE\\r\\nSimpleExpr : T_KW_FALSE\\r\\nSimpleExpr : Uint\\r\\nSimpleExpr : Float\\r\\nSimpleExpr : String\\r\\nSimpleExpr : NonTypeId\\r\\n\\r\\nComplexExpr : '(' Expr ')'\\r\\nComplexExpr : TypeId '(' ArgumentsOpt ')'\\r\\nComplexExpr : BaseType '(' ArgumentsOpt ')'\\r\\nComplexExpr : NonTypeId '(' ArgumentsOpt ')'\\r\\nComplexExpr : PostfixPointExpr '(' ArgumentsOpt ')'\\r\\nComplexExpr : ObjectExpr\\r\\n\\r\\nObjectExpr : T_KW_COMPILE NonTypeId '(' ArgumentsOpt ')'\\r\\nObjectExpr : T_KW_SAMPLER_STATE StateBlock\\r\\nObjectExpr : T_KW_COMPILE_FRAGMENT Target NonTypeId '(' ArgumentsOpt ')'\\r\\nObjectExpr : T_KW_STATEBLOCK_STATE StateBlock\\r\\n\\r\\nPrimaryExpr : ComplexExpr\\r\\nPrimaryExpr : SimpleExpr\\r\\nPostfixExpr : PrimaryExpr\\r\\nPostfixExpr : PostfixExpr '[' Expr ']'\\r\\nPostfixExpr : PostfixExpr '[' ERROR ']'\\r\\nPostfixExpr : PostfixExpr '.' Id\\r\\nPostfixExpr : PostfixExpr T_OP_INC\\r\\nPostfixExpr : PostfixExpr T_OP_DEC\\r\\n\\r\\nPostfixPointExpr : PostfixExpr '.' Id\\r\\n\\r\\nUnaryExpr : PostfixExpr\\r\\nUnaryExpr : T_OP_INC UnaryExpr\\r\\nUnaryExpr : T_OP_DEC UnaryExpr\\r\\n# UnaryExpr : T_OP_INC ERROR\\r\\n# UnaryExpr : T_OP_DEC ERROR\\r\\nUnaryExpr : '!' CastExpr\\r\\n# UnaryExpr : '!' ERROR\\r\\nUnaryExpr : '-' CastExpr\\r\\nUnaryExpr : '+' CastExpr\\r\\n\\r\\nCastExpr : UnaryExpr\\r\\nCastExpr : '(' ConstTypeDim ')' CastExpr\\r\\nCastExpr : '(' ERROR ')' CastExpr\\r\\n\\r\\nMulExpr : CastExpr\\r\\nMulExpr : MulExpr '*' CastExpr\\r\\nMulExpr : MulExpr '/' CastExpr\\r\\nMulExpr : MulExpr '%' CastExpr\\r\\n\\r\\nMulExpr : ERROR '*' CastExpr\\r\\nMulExpr : ERROR '/' CastExpr\\r\\nMulExpr : ERROR '%' CastExpr\\r\\nMulExpr : MulExpr '*' ERROR\\r\\nMulExpr : MulExpr '/' ERROR\\r\\nMulExpr : MulExpr '%' ERROR\\r\\n# MulExpr : ERROR '*' ERROR\\r\\n# MulExpr : ERROR '/' ERROR\\r\\n# MulExpr : ERROR '%' ERROR\\r\\n\\r\\nAddExpr : MulExpr\\r\\nAddExpr : AddExpr '+' MulExpr\\r\\nAddExpr : AddExpr '-' MulExpr\\r\\n\\r\\nAddExpr : AddExpr '+' ERROR\\r\\nAddExpr : AddExpr '-' ERROR\\r\\n\\r\\nRelationalExpr : AddExpr\\r\\nRelationalExpr : RelationalExpr '<' AddExpr\\r\\nRelationalExpr : RelationalExpr '>' AddExpr\\r\\nRelationalExpr : RelationalExpr T_OP_LE AddExpr\\r\\nRelationalExpr : RelationalExpr T_OP_GE AddExpr\\r\\n\\r\\nRelationalExpr : ERROR '<' AddExpr\\r\\nRelationalExpr : RelationalExpr '<' ERROR\\r\\nRelationalExpr : ERROR '<' ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr '>' ERROR\\r\\nRelationalExpr : ERROR '>' AddExpr\\r\\nRelationalExpr : ERROR '>' ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr T_OP_LE ERROR\\r\\nRelationalExpr : ERROR T_OP_LE AddExpr\\r\\nRelationalExpr : ERROR T_OP_LE ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr T_OP_GE ERROR\\r\\nRelationalExpr : ERROR T_OP_GE AddExpr\\r\\nRelationalExpr : ERROR T_OP_GE ERROR\\r\\n\\r\\nEqualityExpr : RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_EQ RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_NE RelationalExpr\\r\\nEqualityExpr : ERROR T_OP_EQ RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_NE ERROR\\r\\nEqualityExpr : ERROR T_OP_NE ERROR\\r\\n\\r\\nAndExpr : EqualityExpr\\r\\nAndExpr : AndExpr T_OP_AND EqualityExpr\\r\\nAndExpr : ERROR T_OP_AND EqualityExpr\\r\\nAndExpr : AndExpr T_OP_AND ERROR\\r\\n\\r\\nOrExpr : AndExpr\\r\\nOrExpr : OrExpr T_OP_OR AndExpr\\r\\nOrExpr : OrExpr T_OP_OR ERROR\\r\\nOrExpr : ERROR T_OP_OR AndExpr\\r\\n\\r\\nConditionalExpr : OrExpr\\r\\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ConditionalExpr\\r\\nConditionalExpr : ERROR '?' AssignmentExpr ':' ConditionalExpr\\r\\nConditionalExpr : OrExpr '?' ERROR ':' ConditionalExpr\\r\\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ERROR\\r\\nConditionalExpr : OrExpr '?' ERROR ':' ERROR\\r\\nConditionalExpr : ERROR '?' ERROR ':' ERROR\\r\\nConditionalExpr : ERROR '?' ERROR ':' ConditionalExpr\\r\\n\\r\\nAssignmentExpr : ConditionalExpr\\r\\nAssignmentExpr : CastExpr '=' AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_ME AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_DE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_RE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_AE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_SE AssignmentExpr\\r\\n\\r\\nArguments : AssignmentExpr --expose\\r\\nArguments : Arguments ',' AssignmentExpr\\r\\nArguments : Arguments ERROR AssignmentExpr\\r\\nArguments : Arguments ',' ERROR\\r\\nArgumentsOpt : --expose\\r\\nArgumentsOpt : Arguments\\r\\n\\r\\nInitExpr : AssignmentExpr --add\\r\\nInitExpr : '{' InitExprs '}'\\r\\nInitExpr : '{' InitExprs ',' '}'\\r\\nInitExprs : InitExpr --expose\\r\\nInitExprs : InitExprs ',' InitExpr\\r\\n\\r\\nConstantExpr : AssignmentExpr\\r\\nExpr : AssignmentExpr\\r\\nExpr : Expr ',' AssignmentExpr\\r\\nExpr : Expr ',' ERROR\\r\\nExpr : ERROR ',' ERROR\\r\\nExpr : ERROR ',' AssignmentExpr\\r\\n\\r\\nDword : Uint\\r\\nDword : '-' Uint\\r\\nDword : Float\\r\\nDword : '-' Float\\r\\nDword : DwordId\\r\\nDword : Uint DwordId\\r\\nDwordId : Id\\r\\nDwordId : T_KW_TRUE\\r\\nDwordId : T_KW_FALSE\\r\\nDwordId : T_KW_TEXTURE\\r\\n\\r\\nId : TypeId\\r\\nId : NonTypeId\\r\\nIdOpt :\\r\\nIdOpt : Id\\r\\n\\r\\nTarget : NonTypeId\\r\\n\\r\\nUint : T_UINT\\r\\nFloat : T_FLOAT\\r\\n\\r\\nStrings : String\\r\\nStrings : Strings String\\r\\nString : T_STRING\\r\\n\\r\\nTypeId : T_TYPE_ID\\r\\nNonTypeId : T_NON_TYPE_ID\\r\\nLineTerminator : T_LINE_TERMINATOR\\r\\n\\r\\nAsmDecl : T_KW_DECL '{'\\r\\nAsm : T_KW_ASM '{'\\r\\nAsmFragment : T_KW_ASM_FRAGMENT '{'\\r\\n\\r\\n--LEXER--\\r\\n\\r\\nT_KW_STATIC : \\\"static\\\"\\r\\nT_KW_UNIFORM : \\\"uniform\\\"\\r\\nT_KW_EXTERN : \\\"extern\\\"\\r\\nT_KW_VOLATILE : \\\"volatile\\\"\\r\\nT_KW_INLINE : \\\"inline\\\"\\r\\nT_KW_CONST : \\\"const\\\"\\r\\nT_KW_ROW_MAJOR : \\\"row_major\\\"\\r\\nT_KW_COLUMN_MAJOR : \\\"column_major\\\"\\r\\nT_KW_TYPEDEF : \\\"typedef\\\"\\r\\nT_KW_STRUCT : \\\"struct\\\"\\r\\nT_KW_VOID : \\\"void\\\"\\r\\nT_KW_BOOL : \\\"bool\\\"\\r\\nT_KW_INT : \\\"int\\\"\\r\\nT_KW_UINT : \\\"uint\\\"\\r\\nT_KW_HALF : \\\"half\\\"\\r\\nT_KW_FLOAT : \\\"float\\\"\\r\\nT_KW_DOUBLE : \\\"double\\\"\\r\\nT_KW_VECTOR : \\\"vector\\\"\\r\\nT_KW_MATRIX : \\\"matrix\\\"\\r\\nT_KW_STRING : \\\"string\\\"\\r\\nT_KW_TEXTURE : \\\"texture\\\"\\r\\nT_KW_TEXTURE1D : \\\"texture1D\\\"\\r\\nT_KW_TEXTURE2D : \\\"texture2D\\\"\\r\\nT_KW_TEXTURE3D : \\\"texture3D\\\"\\r\\nT_KW_TEXTURECUBE : \\\"texturecube\\\"\\r\\nT_KW_SAMPLER : \\\"sampler\\\"\\r\\nT_KW_SAMPLER1D : \\\"sampler1D\\\"\\r\\nT_KW_SAMPLER2D : \\\"sampler2D\\\"\\r\\nT_KW_SAMPLER3D : \\\"sampler3D\\\"\\r\\nT_KW_SAMPLERCUBE : \\\"samplerCUBE\\\"\\r\\nT_KW_RWBUFFER : \\\"RWBuffer\\\"\\r\\nT_KW_RWSTRUCTUREDBUFFER : \\\"RWStructuredBuffer\\\"\\r\\nT_KW_APPENDSTRUCTUREDBUFFER : \\\"AppendStructuredBuffer\\\"\\r\\nT_KW_PIXELSHADER : \\\"pixelshader\\\"\\r\\nT_KW_VERTEXSHADER : \\\"vertexshader\\\"\\r\\nT_KW_PIXELFRAGMENT : \\\"pixelfragment\\\"\\r\\nT_KW_VERTEXFRAGMENT : \\\"vertexfragment\\\"\\r\\nT_KW_STATEBLOCK : \\\"stateblock\\\"\\r\\nT_KW_REGISTER : \\\"register\\\"\\r\\nT_KW_IN : \\\"in\\\"\\r\\nT_KW_OUT : \\\"out\\\"\\r\\nT_KW_INOUT : \\\"inout\\\"\\r\\nT_KW_TECHNIQUE : \\\"technique\\\"\\r\\n#if FX_PART\\r\\n    T_KW_FXPART : \\\"partFx\\\"\\r\\n#endif\\r\\nT_KW_PASS : \\\"pass\\\"\\r\\nT_KW_RETURN : \\\"return\\\"\\r\\nT_KW_DO : \\\"do\\\"\\r\\nT_KW_DISCARD : \\\"discard\\\"\\r\\nT_KW_WHILE : \\\"while\\\"\\r\\nT_KW_IF : \\\"if\\\"\\r\\nT_KW_ELSE : \\\"else\\\"\\r\\nT_KW_FOR : \\\"for\\\"\\r\\nT_KW_TRUE : \\\"true\\\"\\r\\nT_KW_FALSE : \\\"false\\\"\\r\\nT_KW_COMPILE : \\\"compile\\\"\\r\\nT_KW_SAMPLER_STATE : \\\"sampler_state\\\"\\r\\nT_KW_COMPILE_FRAGMENT : \\\"compile_fragment\\\"\\r\\nT_KW_STATEBLOCK_STATE : \\\"stateblock_state\\\"\\r\\nT_KW_DECL : \\\"decl\\\"\\r\\nT_KW_ASM : \\\"asm\\\"\\r\\nT_KW_ASM_FRAGMENT : \\\"asm_fragment\\\"\\r\\nT_KW_USE : \\\"use\\\"\\r\\nT_KW_STRICT : \\\"strict\\\"\\r\\nT_KW_IMPORT : \\\"import\\\"\\r\\nT_KW_PROVIDE : \\\"provide\\\"\\r\\nT_KW_SWITCH : \\\"switch\\\"\\r\\nT_KW_CASE : \\\"case\\\"\\r\\nT_KW_DEFAULT : \\\"default\\\"\\r\\nT_KW_BREAK : \\\"break\\\"\\r\\n#if FX_PART\\r\\nT_KW_SPAWN : \\\"spawn\\\"\\r\\n#endif\\r\\nT_KW_CONTINUE : \\\"continue\\\"\\r\\nT_KW_AS : \\\"as\\\"\\r\\nT_KW_INCLUDE : \\\"include\\\"\\r\\nT_OP_INC : \\\"++\\\"\\r\\nT_OP_DEC : \\\"--\\\"\\r\\nT_OP_LE : \\\">=\\\"\\r\\nT_OP_GE : \\\"<=\\\"\\r\\nT_OP_EQ : \\\"==\\\"\\r\\nT_OP_NE : \\\"!=\\\"\\r\\nT_OP_AND : \\\"&&\\\"\\r\\nT_OP_OR : \\\"||\\\"\\r\\nT_OP_ME : \\\"*=\\\"\\r\\nT_OP_DE : \\\"/=\\\"\\r\\nT_OP_RE : \\\"%=\\\"\\r\\nT_OP_AE : \\\"+=\\\"\\r\\nT_OP_SE : \\\"-=\\\"\";","import { IMap } from '@lib/idl/IMap';\r\nimport { IParseNode } from '@lib/idl/parser/IParser';\r\nimport { getCommon, mapProps } from '@sandbox/reducers';\r\nimport IStoreState from '@sandbox/store/IStoreState';\r\nimport * as copy from 'copy-to-clipboard';\r\nimport * as React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { List } from 'semantic-ui-react';\r\n\r\nexport interface IASTViewProps extends IStoreState {\r\n    onNodeOut: (id: string) => void;\r\n    onNodeOver: (id: string, node: IParseNode) => void;\r\n}\r\n\r\nclass ASTView extends React.Component<IASTViewProps, {}> {\r\n    state: {\r\n        nodeStats: IMap<{ opened: boolean; selected: boolean; }>;\r\n    };\r\n\r\n    rootRef: React.RefObject<HTMLDivElement>;\r\n\r\n    constructor(props: IASTViewProps) {\r\n        super(props);\r\n        this.state = {\r\n            nodeStats: {}\r\n        };\r\n\r\n        this.rootRef = React.createRef();\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // const rect = this.rootRef.current.getBoundingClientRect();\r\n        // just a rude hack\r\n        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        // TODO: implement it\r\n        return true;\r\n    }\r\n\r\n    // tslint:disable-next-line:typedef\r\n    render() {\r\n        const slastDocument = this.props.sourceFile.slastDocument;\r\n\r\n        const style = {\r\n            height: 'calc(100vh - 205px)',\r\n            overflowY: 'auto'\r\n        };\r\n\r\n        return (\r\n            <div ref={this.rootRef}>\r\n                <List style={ style } selection size='small' className='astlist' >\r\n                    { this.renderASTNode(slastDocument ? slastDocument.root : null) }\r\n                </List>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    private renderASTNode(node: IParseNode, idx: string = '0'): JSX.Element {\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        const { nodeStats } = this.state;\r\n        const forceShow = idx.split('.').length < 2;\r\n        const show = forceShow || (nodeStats[idx] || { opened: false, selected: false }).opened;\r\n        const selected = (nodeStats[idx] || { opened: false, selected: false }).selected;\r\n\r\n        if (node.value) {\r\n            return (\r\n                <List.Item key={ idx }\r\n                    onClick={ this.handleNodeClick.bind(this, idx, node) }\r\n                    onMouseOver={ this.handleNodeOver.bind(this, idx, node) }\r\n                    onMouseOut={ this.handleNodeOut.bind(this, idx, node) }\r\n                    className='astnode'\r\n                >\r\n                    {/* FIXME: remove inline style hotfix */ }\r\n                    <List.Icon style={ { minWidth: '12px' } } />\r\n                    <List.Content>\r\n                        <List.Header>{ node.name }</List.Header>\r\n                        <List.Description>{ node.value }</List.Description>\r\n                    </List.Content>\r\n                </List.Item>\r\n            );\r\n        } else {\r\n            let children = null;\r\n            if (show) {\r\n                children = (\r\n                    <List.List className='astlist'>\r\n                        { node.children.map((node, i) => this.renderASTNode(node, `${idx}.${i}`)).reverse() }\r\n                    </List.List>\r\n                );\r\n            }\r\n            return (\r\n                <List.Item key={ idx }\r\n                    onClick={ this.handleNodeClick.bind(this, idx, node) }\r\n                    onMouseOver={ this.handleNodeOver.bind(this, idx, node) }\r\n                    onMouseOut={ this.handleNodeOut.bind(this, idx, node) }\r\n                    className='astnode'\r\n                >\r\n                    <List.Icon name={ (show ? `chevron down` : `chevron right`) } />\r\n                    <List.Content>\r\n                        <List.Header>\r\n                            { node.name }&nbsp;\r\n                            <a href='/' style={ ({ display: (selected ? 'inline' : 'none') }) }\r\n                                onClick={ this.handleCopyClick.bind(this, idx, node) }>Copy</a>\r\n                        </List.Header>\r\n                        { children }\r\n                    </List.Content>\r\n                </List.Item>\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    private async handleCopyClick(idx: string, node: IParseNode, e: MouseEvent): Promise<void> {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        let out = [];\r\n        out.push(`/**`);\r\n        out.push(` * AST example:`)\r\n        out.push(` *    ${node.name}`)\r\n        out = out\r\n            .concat(node.children.slice()\r\n            .map(node => ` *       ${node.children ? '+' : ' '} ${node.name} ${node.value ? `= \\'${node.value}\\'` : ''}`));\r\n        out.push(` */`);\r\n\r\n        copy(out.join('\\n'), { debug: true });\r\n    }\r\n\r\n\r\n    private async handleNodeOver(idx: string, node: IParseNode, e: MouseEvent): Promise<void> {\r\n        e.stopPropagation();\r\n\r\n        let { nodeStats } = this.state;\r\n\r\n        let val = { opened: false, selected: false, ...nodeStats[idx] };\r\n        val.selected = !val.selected;\r\n        nodeStats = { ...nodeStats, [idx]: val };\r\n\r\n        this.setState({ nodeStats });\r\n        this.props.onNodeOver(idx, node);\r\n    }\r\n\r\n\r\n    private async handleNodeOut(idx: string, node: IParseNode, e: MouseEvent): Promise<void> {\r\n        e.stopPropagation();\r\n\r\n        let { nodeStats } = this.state;\r\n\r\n        const val = { opened: false, selected: false, ...nodeStats[idx] };\r\n        val.selected = !val.selected;\r\n        nodeStats = { ...nodeStats, [idx]: val };\r\n\r\n        this.setState({ nodeStats });\r\n        this.props.onNodeOut(idx);\r\n    }\r\n\r\n\r\n    private handleNodeClick(idx: string, node: IParseNode, e: MouseEvent): void {\r\n        e.stopPropagation();\r\n\r\n        let { nodeStats } = this.state;\r\n\r\n        const val = { opened: false, selected: false, ...nodeStats[idx] };\r\n        val.opened = !val.opened;\r\n        nodeStats = { ...nodeStats, [idx]: val };\r\n\r\n        this.setState({ nodeStats });\r\n    }\r\n}\r\n\r\n\r\nexport default connect<{}, {}, IASTViewProps>(mapProps(getCommon), {})(ASTView) as any;\r\n\r\n","import { IPosition } from \"./parser/IParser\";\r\n\r\nexport enum EDiagnosticCategory {\r\n    k_Warning,\r\n    k_Error\r\n}\r\n\r\n\r\nexport interface IDiagnosticEntry<DESC_T> {\r\n    category: EDiagnosticCategory;\r\n    code: number;\r\n    desc: DESC_T;\r\n}\r\n\r\n\r\ntype IDiagnosticDescription = string;\r\n\r\nexport interface IDiagnosticMessage {\r\n    code: string;\r\n    category: EDiagnosticCategory;\r\n    start?: IPosition;\r\n    end?: IPosition;\r\n    file?: string;\r\n    content: string;\r\n}\r\n\r\nexport interface IDiagnosticReport {\r\n    errors: number;\r\n    warnings: number;\r\n\r\n    messages: IDiagnosticMessage[];\r\n}\r\n\r\n\r\n\r\nexport interface IDiagnostics<DESC_T> {\r\n    reset(): void;\r\n    resolve(): IDiagnosticReport;\r\n    error(code: number, desc: DESC_T);\r\n    warning(code: number, desc: DESC_T);\r\n    critical(code: number, desc: DESC_T);\r\n    prettyPrint(): string;\r\n    hasErrors(): boolean;\r\n    getLastError(): IDiagnosticMessage;\r\n}\r\n","export enum EAnalyzerErrors {\r\n    SystemTypeRedefinition = 2202,\r\n    TypeRedefinition,\r\n    VariableRedefinition,\r\n    SystemVariableRedefinition,\r\n    FunctionRedifinition,\r\n    SystemFunctionRedefinition,\r\n\r\n    UnsupportedTypeDecl,\r\n    UnsupportedExpr,\r\n    UnknownVarName,\r\n    InvalidArithmeticOperation,\r\n    InvalidArithmeticAssigmentOperation,\r\n    InvalidAssigmentOperation,\r\n    InvalidLeftHandSideInAssignment,\r\n    InvalidRelationalOperation,\r\n    InvalidLogicOperation,\r\n    InvalidConditionType ,\r\n    InvalidConditonValueTypes,\r\n    InvalidCastTypeUsage,\r\n    InvalidCastTypeNotBase,\r\n    InvalidCastUnknownType,\r\n    InvalidUnaryOperation,\r\n    InvalidPostfixNotArray,\r\n    InvalidPostfixNotIntIndex,\r\n    InvalidPostfixNotField,\r\n    InvalidPostfixArithmetic,\r\n    InvalidComplexNotFunction,\r\n    InvalidComplexNotType,\r\n    InvalidComplexNotConstructor,\r\n    InvalidCompileNotFunction,\r\n    InvalidCompileFunctionNotValid,\r\n    FunctionRedefinition,\r\n    InvalidWhileCondition,\r\n    InvalidDoWhileCondition,\r\n    InvalidIfCondition,\r\n    InvalidForInitExpr,\r\n    InvalidForInitEmptyIterator,\r\n    InvalidForConditionEmpty,\r\n    InvalidForConditionRelation,\r\n    InvalidForStepEmpty,\r\n    InvalidForStepOperator,\r\n    InvalidForStepExpr,\r\n    InvalidNewFieldForStructName,\r\n    InvalidNewFieldForStructSematic,\r\n    InvalidNewAnnotationVar,\r\n    InvalidFunctionParameterDefenitionDefaultNeeded,\r\n    CannotChooseFunction,\r\n    InvalidFuncDefenitionReturnType,\r\n    InvalidSystemFunctionReturnType,\r\n    InvalidTypeNameNotType,\r\n    InvalidTypeNameTemplateNotFound,\r\n    InvalidTypeScope,\r\n    CannotProduceType,\r\n    InvalidTypeVectorMatrix,\r\n    TechniqueNameRedefinition,\r\n    InvalidFunctionRecursionNotAllowed,\r\n    InvalidFunctionImplementationNotFound,\r\n    // InvalidFunctionUsageVertex,\r\n    // InvalidFunctionUsagePixel,\r\n    FunctionIsNotCompatibleWithVertexShader,\r\n    FunctionIsNotCompatibleWithPixelShader,\r\n    InvalidReturnStmtVoid,\r\n    InvalidReturnStmtEmpty,\r\n    InvalidReturnStmtTypesNotEqual,\r\n    InvalidFunctionReturnType,\r\n    InvalidFunctionParameterUsage,\r\n    InvalidTypeForWriting,\r\n    InvalidTypeForReading,\r\n    InvalidExprIsNotLValue,\r\n    InvalidVariableInitializing,\r\n    UnsupportedStateIndex,\r\n    InvalidSamplerTexture,\r\n    CannotCalcPadding,\r\n    ImportedComponentNotExists,\r\n    InvalidFunctionReturnStmtNotFound,\r\n    UnsupportedProvideAs,\r\n    UnreachableCode,\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    PartFx_VertexShaderParametersMismatch,\r\n    PartFx_InvalidSpawnStmtInitializerNotFound\r\n};\r\n"],"sourceRoot":""}