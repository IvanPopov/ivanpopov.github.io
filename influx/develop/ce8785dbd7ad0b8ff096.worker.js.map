{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lib/language-service/LanguageService.ts","webpack:///./src/lib/fx/analisys/instructions/TechniqueInstruction.ts","webpack:///./src/lib/bf/bf.ts","webpack:///./src/lib/fx/analisys/helpers/expression.ts","webpack:///./src/lib/util/Diagnostics.ts","webpack:///./src/lib/fx/FXSLDocument.ts","webpack:///./src/lib/fx/analisys/instructions/IfStmtInstruction.ts","webpack:///./src/lib/parser/ParseTree.ts","webpack:///./src/lib/fx/analisys/instructions/Instruction.ts","webpack:///./src/lib/idl/ERenderStateValues.ts","webpack:///./src/lib/fx/analisys/instructions/CastExprInstruction.ts","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./src/lib/fx/analisys/instructions/FloatInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts","webpack:///./src/lib/path/path.ts","webpack:///./src/lib/fx/analisys/instructions/BoolInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/IdExprInstruction.ts","webpack:///./src/lib/idl/ERenderStates.ts","webpack:///./src/lib/fx/analisys/helpers/type.ts","webpack:///./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts","webpack:///./src/lib/language-service/services/fx/codeLenses.ts","webpack:///./src/lib/parser/AbstractParser.ts","webpack:///./src/lib/fx/analisys/instructions/ProvideInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/StringInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/IdInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts","webpack:///./src/lib/idl/part/IPartFx.ts","webpack:///./src/lib/fx/Visitors.ts","webpack:///./src/lib/idl/IInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts","webpack:///./src/lib/parser/Item.ts","webpack:///./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts","webpack:///./src/lib/language-service/services/signatureHelp.ts","webpack:///./src/lib/fx/analisys/ProgramScope.ts","webpack:///./src/lib/fx/analisys/FxAnalyzer.ts","webpack:///./src/lib/util/StringRef.ts","webpack:///./src/lib/idl/parser/IParser.ts","webpack:///./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/SamplerStateInstruction.ts","webpack:///./src/lib/fx/analisys/Analyzer.ts","webpack:///./src/lib/fx/SLParser.ts","webpack:///./src/lib/fx/analisys/helpers/instruction.ts","webpack:///./src/lib/fx/analisys/instructions/SamplerStateBlockInstruction.ts","webpack:///./node_modules/comlink/dist/esm/comlink.mjs","webpack:///./src/lib/fx/analisys/instructions/IntInstruction.ts","webpack:///./src/lib/fx/AnalyzerDiagnostics.ts","webpack:///./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts","webpack:///./src/lib/parser/Lexer.ts","webpack:///./src/lib/bf/index.ts","webpack:///./src/lib/fx/analisys/helpers/variable.ts","webpack:///./src/sandbox/containers/editor/LanguageServiceProvider.ts","webpack:///./src/lib/fx/analisys/SystemScope.ts","webpack:///./src/lib/fx/analisys/instructions/ForStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/TypedInstruction.ts","webpack:///./src/lib/parser/symbols.ts","webpack:///./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts","webpack:///./src/lib/idl/EAnalyzerWarnings.ts","webpack:///./src/lib/fx/SLASTDocument.ts","webpack:///./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts","webpack:///./src/lib/common.ts","webpack:///./src/lib/fx/analisys/instructions/CompileExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts","webpack:///./src/lib/idl/ITexture.ts","webpack:///./src/lib/fx/analisys/instructions/InitExprInstruction.ts","webpack:///./src/lib/parser/ASTDocument.ts","webpack:///./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/InstructionCollector.ts","webpack:///./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/PassInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts","webpack:///./node_modules/vscode-languageserver-types/lib/esm/main.js","webpack:///./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/DeclInstruction.ts","webpack:///./src/lib/fx/analisys/helpers/fn.ts","webpack:///./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/StmtInstruction.ts","webpack:///./src/lib/fx/analisys/instructions/AttributeInstruction.ts","webpack:///./src/lib/uri/uri.ts","webpack:///./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts","webpack:///./src/lib/fx/analisys/helpers/index.ts","webpack:///./src/lib/parser/State.ts","webpack:///./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts","webpack:///./src/lib/parser/util.ts","webpack:///./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts","webpack:///./src/lib/fx/HLSL.gr","webpack:///./src/lib/idl/IDiagnostics.ts","webpack:///./src/lib/idl/EAnalyzerErrors.ts"],"names":[],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yDAAyD,eAAe,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C,KAAK;AACL;A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CA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS,iCAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAA6C,IAAI;AACjF;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;;;;;;;;;;;;;AC18C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","file":"ce8785dbd7ad0b8ff096.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"Vs+U\");\n","import { createFXSLDocument } from '@lib/fx/FXSLDocument';\r\nimport { ILanguageService } from '@lib/idl/ILanguageService';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IASTDocumentFlags } from '@lib/idl/parser/IParser';\r\nimport { Color, ColorInformation, ColorPresentation, CompletionItem, CompletionList, FoldingRange, FormattingOptions, Hover, Position, Range, SymbolInformation, TextDocument, TextEdit } from 'vscode-languageserver-types';\r\n\r\nimport { FXCodeLenses } from './services/fx/codeLenses';\r\nimport { SLSignatureHelp } from './services/signatureHelp';\r\n\r\n// import { SLValidation } from './services/validation';\r\n\r\n// FIXME: use correct type\r\ntype SelectionRange = Range;\r\n\r\n\r\nexport function getLanguageService(flags: IASTDocumentFlags): ILanguageService {\r\n    const signatureHelp = new SLSignatureHelp();\r\n\r\n    //\r\n    // FX\r\n    //\r\n    \r\n    const fxCodeLenses = new FXCodeLenses();\r\n\r\n    return {\r\n        async parseDocument(textDocument: TextDocument): Promise<ISLDocument> { \r\n            const uri = textDocument.uri;\r\n            const source = textDocument.getText();\r\n            return await createFXSLDocument({ uri, source }, flags);\r\n        },\r\n\r\n        doResolve(item: CompletionItem): Thenable<CompletionItem> { return null; },\r\n        doComplete(textDocument: TextDocument, position: Position, slDocument: ISLDocument): Thenable<CompletionList | null> { return null; },\r\n        findDocumentSymbols(textDocument: TextDocument, slDocument: ISLDocument): SymbolInformation[] { return []; },\r\n        findDocumentColors(textDocument: TextDocument, slDocument: ISLDocument): Thenable<ColorInformation[]> { return null; },\r\n        getColorPresentations(textDocument: TextDocument, slDocument: ISLDocument, color: Color, range: Range): ColorPresentation[] { return []; },\r\n        doHover(textDocument: TextDocument, position: Position, slDocument: ISLDocument): Thenable<Hover | null> { return null; },\r\n        format(textDocument: TextDocument, range: Range, options: FormattingOptions): TextEdit[] { return []; },\r\n        getFoldingRanges(textDocument: TextDocument): FoldingRange[] { return []; },\r\n        getSelectionRanges(textDocument: TextDocument, positions: Position[], slDocument: ISLDocument): SelectionRange[] { return []; },\r\n        \r\n        doSignatureHelp: signatureHelp.doSignatureHelp.bind(signatureHelp),\r\n\r\n        //\r\n        // FX\r\n        //\r\n\r\n        doFxCodeLenses: fxCodeLenses.doProvide.bind(fxCodeLenses)\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IPassInstruction, ITechniqueInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from './Instruction';\r\n\r\nexport interface ITechniqueInstructionSettings<PassType extends IPassInstruction> extends IDeclInstructionSettings {\r\n    name: string;\r\n    techniqueType: ETechniqueType;\r\n    passList: PassType[];\r\n}\r\n\r\n\r\nexport class TechniqueInstruction<PassType extends IPassInstruction> extends DeclInstruction implements ITechniqueInstruction {\r\n    protected _name: string;\r\n    protected _techniqueType: ETechniqueType;\r\n    protected _passList: PassType[];\r\n\r\n    constructor({ name, techniqueType, passList, ...settings }: ITechniqueInstructionSettings<PassType>) {\r\n        super({ instrType: EInstructionTypes.k_TechniqueDecl, ...settings });\r\n        \r\n        this._name = name;\r\n        this._passList = passList.map(pass => Instruction.$withParent(pass, this));\r\n        this._techniqueType = techniqueType;\r\n    }\r\n\r\n    // todo: add id support?\r\n    // get id();\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    get passList(): PassType[] {\r\n        return this._passList;\r\n    }\r\n\r\n    get type(): ETechniqueType {\r\n        return this._techniqueType;\r\n    }\r\n}\r\n","/**\r\n * Сдвиг единицы на @a x позиций влево.\r\n */\r\nexport var flag = (x: number) => (1 << (x));\r\n/**\r\n * Проверка того что у @a value бит под номером @a bit равен единице.\r\n */\r\nexport var testBit = (value: number, bit: number) => ((value & flag(bit)) != 0);\r\n/**\r\n * Проверка того что у @a value равны единице все биты,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAll = (value: number, set: number) => (((value) & (set)) == (set));\r\n/**\r\n * Проверка того что у @a value равны единице хотя бы какие то из битов,\r\n * которые равны единице у @a set.\r\n */\r\nexport var testAny = (value: number, set: number) => (((value) & (set)) != 0);\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным единице\r\n */\r\nexport var setBit = (value: number, bit: number, setting: boolean = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));\r\n/**\r\n *\r\n */\r\nexport var clearBit = (value: number, bit: number) => ((value) &= ~flag((bit)));\r\n/**\r\n * Выставляет бит под номером @a bit у числа @a value равным нулю\r\n */\r\nexport var setAll = (value: number, set: number, setting: boolean = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var clearAll = (value: number, set: number) => ((value) &= ~(set));\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a set\r\n */\r\nexport var equal = (value: number, src: number) => { value = src; };\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var isEqual = (value: number, src: number) => value == src;\r\n/**\r\n * Если число @a value равно числу @a src возвращается true\r\n */\r\nexport var isNotEqaul = (value: number, src: number) => value != src;\r\n/**\r\n * Прирасваивает числу @a value число @a src\r\n */\r\nexport var set = (value: number, src: number) => { value = src; };\r\n/**\r\n * Обнуляет число @a value\r\n */\r\nexport var clear = (value: number) => { value = 0; };\r\n/**\r\n * Выставляет все биты у числа @a value равными единице,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var setFlags = (value: number, src: number) => (value |= src);\r\n/**\r\n * Выставляет все биты у числа @a value равными нулю,\r\n * которые равны единице у числа @a src\r\n */\r\nexport var clearFlags = (value: number, src: number) => value &= ~src;\r\n/**\r\n * Проверяет равно ли число @a value нулю. Если равно возвращает true.\r\n * Если не равно возвращает false.\r\n */\r\nexport var isEmpty = (value: number) => (value == 0);\r\n/**\r\n * Возвращает общее количество бит числа @a value.\r\n * На самом деле возвращает всегда 32.\r\n */\r\nexport var totalBits = (value: number) => 32;\r\n\r\n\r\n/**\r\n * Возвращает общее количество ненулевых бит числа @a value.\r\n */\r\nexport var totalSet = (value: number): number => {\r\n    var count: number = 0;\r\n    var total: number = totalBits(value);\r\n\r\n    for (var i: number = total; i; --i) {\r\n        count += (value & 1);\r\n        value >>= 1;\r\n    }\r\n\r\n    return (count);\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace expression {\r\n    /**\r\n     * unwind operation returns declaration in case of correct l-value expression;\r\n     */\r\n    export function unwind(expr: IExprInstruction): IVariableDeclInstruction {\r\n        if (isNull(expr)) {\r\n            return null;\r\n        }\r\n\r\n        switch (expr.instructionType) {\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n                return unwind((<IPostfixPointInstruction>expr).element);\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n                return unwind((<IPostfixIndexInstruction>expr).element);\r\n            case EInstructionTypes.k_IdExpr:\r\n                return (<IIdExprInstruction>expr).decl;\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n                // arithmetic expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_InitExpr:\r\n                assert(false, 'init expression doesn\\'t support unwind operation');\r\n                return null;\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n                // todo: reseach how it work in HLSL\r\n                //// assigment expression returns right-hand value;\r\n                return unwind((<IAssignmentExprInstruction>expr).left);\r\n            case EInstructionTypes.k_CastExpr:\r\n                // cast expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // unary expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_RelationalExpr:\r\n                // relation expression returns right-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n                // ctor call expression is not allowed as l-value;\r\n                // todo: allow it?\r\n                return null;\r\n            case EInstructionTypes.k_ComplexExpr:\r\n                return unwind((<IComplexExprInstruction>expr).expr);\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n                // literal cannot be a left-hand value;\r\n                return null;\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n                // function call expression returns right-hand value;\r\n                return null;\r\n            default:\r\n                assert(false, \"unsupported expr found\");\r\n                return null;\r\n        }\r\n    }\r\n}\r\n","import { EDiagnosticCategory, IDiagnosticEntry, IDiagnosticMessage, IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\n\r\nimport { IMap } from \"../idl/IMap\";\r\nimport { IPosition, IRange } from \"../idl/parser/IParser\";\r\n\r\nfunction locToString(loc: IPosition) {\r\n    return `${loc.line},${loc.column}`;\r\n}\r\n\r\n\r\nfunction rangeToString(range: IRange) {\r\n    return `${locToString(range.start)}:${locToString(range.end)}`;\r\n}\r\n\r\n\r\nfunction readKey(desc: Object, key: string) {\r\n    let keyParts: string[] = key.split('.');\r\n    if (keyParts.length > 1) {\r\n        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));\r\n    }\r\n    return desc[keyParts[0]];\r\n}\r\n\r\n\r\nfunction fillPattern(pattern: string, desc: Object): string {\r\n    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {\r\n        return readKey(desc, key);\r\n    });\r\n}\r\n\r\nexport class DiagnosticException<DESC_T> extends Error {\r\n    host: Diagnostics<DESC_T>;\r\n\r\n    constructor(host: Diagnostics<DESC_T>, mesg: IDiagnosticMessage) {\r\n        super(mesg.content);\r\n        Error.captureStackTrace(this, DiagnosticException);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Diagnostics <DESC_T>{\r\n    protected _name: string;\r\n    protected _codePrefix: string;\r\n    protected _entries: IDiagnosticEntry<DESC_T>[];\r\n\r\n    constructor(name: string, codePrefix: string) {\r\n        this._name = name;\r\n        this._codePrefix = (codePrefix || '').toUpperCase();\r\n        this.reset();\r\n    }\r\n\r\n    protected emitException(): void {\r\n        throw new DiagnosticException<DESC_T>(this, this.getLastError());\r\n    }\r\n\r\n    reset() {\r\n        this._entries = [];\r\n    }\r\n\r\n    resolve(): IDiagnosticReport {\r\n        let report: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        for (let entry of this._entries) {\r\n            let message = this.resolveEntry(entry);\r\n\r\n            switch(message.category) {\r\n                case EDiagnosticCategory.k_Warning:\r\n                    report.warnings ++;\r\n                    break;\r\n                case EDiagnosticCategory.k_Error:\r\n                    report.errors ++;\r\n                    break;\r\n            }\r\n            report.messages.push(message);\r\n        }\r\n\r\n        return report;\r\n    }\r\n\r\n    private resolveEntry(entry: IDiagnosticEntry<DESC_T>): IDiagnosticMessage {\r\n        // let { category, desc } = entry;\r\n\r\n        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();\r\n        let loc: string = null;\r\n        let range: IRange;\r\n        let start: IPosition;\r\n        let end: IPosition;\r\n        let file = this.resolveFilename(entry.code, entry.desc);\r\n\r\n        if (range = this.resolveRange(entry.code, entry.desc)) {\r\n            ({ start, end } = range);\r\n            loc = rangeToString(range);\r\n        } \r\n        else {\r\n            start = this.resolvePosition(entry.code, entry.desc);\r\n            loc = locToString(start);\r\n        }\r\n\r\n        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;\r\n        let code = `${this._codePrefix}${entry.code}`;\r\n        let category = entry.category;\r\n        return { code, category, content, file, start, end };\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: DESC_T): string {\r\n        return '[unknown]';\r\n    }\r\n\r\n    protected resolvePosition(code: number, desc: DESC_T): IPosition {\r\n        return { file: null, line: 0, column: 0 };\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: DESC_T): IRange {\r\n        return null;\r\n    }\r\n\r\n    protected resolveDescription(code:number, category: EDiagnosticCategory, desc: DESC_T): string {\r\n        let diagMesgs = this.diagnosticMessages();\r\n        if (!diagMesgs) {\r\n            console.error(`Diagnostic messages of '${this._name}' not found.`);\r\n            return '[no description found]';\r\n        }\r\n\r\n        if (!diagMesgs[code]) {\r\n            return `[no description found for code '${code}']`;\r\n        }\r\n\r\n        return fillPattern(diagMesgs[code], desc);\r\n    }\r\n\r\n    protected diagnosticMessages(): IMap<string> {\r\n        return null;\r\n    }\r\n\r\n    error(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Error, code, desc });\r\n    }\r\n\r\n    warning(code: number, desc: DESC_T) { \r\n        this._entries.push({ category: EDiagnosticCategory.k_Warning, code, desc });\r\n    }\r\n\r\n    // add error and emit an exception in order to interrupt processing\r\n    critical(code: number, desc: DESC_T) {\r\n        this.error(code, desc);\r\n        this.emitException();\r\n    }\r\n\r\n    prettyPrint(): string {\r\n        return null;//JSON.stringify(this._errors, null, '\\t');\r\n    }\r\n\r\n    hasErrors(): boolean {\r\n        return this._entries.filter(entry => entry.category === EDiagnosticCategory.k_Error).length > 0;\r\n    }\r\n\r\n    getLastError(): IDiagnosticMessage {\r\n        for (let i = this._entries.length - 1; i >= 0; --i) {\r\n            if (this._entries[i].category === EDiagnosticCategory.k_Error) {\r\n                return this.resolveEntry(this._entries[i]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static mergeReports(reportList: IDiagnosticReport[]): IDiagnosticReport {\r\n        let result: IDiagnosticReport = { errors: 0, warnings: 0, messages: [] };\r\n\r\n        reportList.forEach((report) => {\r\n            result.errors += report.errors;\r\n            result.warnings += report.warnings;\r\n            result.messages = result.messages.concat(report.messages);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    static stringify(report: IDiagnosticReport): string {\r\n        return report.messages.map(mesg => mesg.content).join('\\n');\r\n    }\r\n\r\n    static asRange(mesg: IDiagnosticMessage): IRange {\r\n        let range: IRange = { start: mesg.start, end: mesg.end };\r\n\r\n        if (!range.end) {\r\n            range.end = { ...range.start };\r\n        }\r\n\r\n        const { start, end } = range;\r\n\r\n        if (end.line == start.line && end.column == start.column) {\r\n            end.column +=1;\r\n        }\r\n\r\n        return range;\r\n    }\r\n}","import { isNumber, isObject, isString } from \"@lib/common\";\r\nimport { IScope } from \"@lib/idl/IInstruction\";\r\nimport { ISLASTDocument } from \"@lib/idl/ISLASTDocument\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\n\r\nimport { FxAnalyzer } from \"./analisys/FxAnalyzer\";\r\nimport { createSLASTDocument } from \"./SLASTDocument\";\r\n\r\nexport async function createFXSLDocument(textDocument: ITextDocument, flags?: number, document?: ISLDocument): Promise<ISLDocument>;\r\nexport async function createFXSLDocument(slastDocument: ISLASTDocument, document?: ISLDocument): Promise<ISLDocument>;\r\nexport async function createFXSLDocument(param1: ISLASTDocument | ITextDocument, param2?: number | ISLDocument, param3?: ISLDocument): Promise<ISLDocument> {\r\n    let textDocument: ITextDocument;\r\n    let slastDocument: ISLASTDocument;\r\n    let slDocument: ISLDocument;\r\n\r\n    if (isString(arguments[0].source)) {    \r\n        const flags = isNumber(arguments[1]) ? <number>arguments[1] : undefined;\r\n        textDocument = <ITextDocument>arguments[0];\r\n        slastDocument = await createSLASTDocument(textDocument, flags);\r\n        slDocument = arguments[2];\r\n    } else {\r\n        slastDocument = <ISLASTDocument>arguments[0];\r\n        slDocument = arguments[1];\r\n    }\r\n    \r\n    const analyzer = new FxAnalyzer;\r\n    return await analyzer.parse(slastDocument, slDocument);\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IAttributeInstruction, IExprInstruction, IIfStmtInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IIfStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    conseq: IStmtInstruction;\r\n    contrary?: IStmtInstruction;\r\n    attributes?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent if(expr) stmt or if(expr) stmt else stmt\r\n * ( if || if_else ) Expr Stmt [Stmt]\r\n */\r\nexport class IfStmtInstruction extends StmtInstruction implements IIfStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n    \r\n    constructor({ cond, conseq, attributes = null, contrary = null, ...settings }: IIfStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IfStmt, ...settings });\r\n\r\n        this.cond = Instruction.$withParent(cond, this);\r\n        this.conseq = Instruction.$withParent(conseq, this);\r\n        this.contrary = Instruction.$withParent(contrary, this);\r\n        this.attributes = (attributes || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        if (isNull(this.contrary)) {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \")\";\r\n            code += this.conseq.toCode();\r\n        }\r\n        else {\r\n            code += \"if(\";\r\n            code += this.cond.toCode() + \") \";\r\n            code += this.conseq.toCode();\r\n            code += \"else \";\r\n            code += this.contrary.toCode();\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { ENodeCreateMode, IParseNode, IParseTree, IPosition, IRange, IRule, IToken } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { extendRange } from \"./util\";\r\n\r\nexport class ParseTree implements IParseTree {\r\n    root: IParseNode;\r\n    nodes: IParseNode[];\r\n    \r\n    readonly optimized: boolean;\r\n    \r\n    private nodesCountStack: number[];\r\n\r\n\r\n    constructor(optimized: boolean, root: IParseNode = null) {\r\n        this.root = root;\r\n        this.nodes = [];\r\n        this.optimized = optimized;\r\n\r\n        this.nodesCountStack = [];\r\n    }\r\n\r\n\r\n    get lastNode(): IParseNode {\r\n        return this.nodes[this.nodes.length - 1];\r\n    }\r\n\r\n\r\n    finishTree(): void {\r\n        this.root = this.nodes.pop();\r\n    }\r\n\r\n\r\n    addToken({ name, value, loc }: IToken): void {\r\n        const children = null;\r\n        const parent = null;\r\n        this.addNode({ name, value, loc, children, parent });\r\n    }\r\n\r\n    reduceByRule(rule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {\r\n        let iReduceCount = 0;\r\n        let nodesCountStack = this.nodesCountStack;\r\n        let ruleLength = rule.right.length;\r\n        let nodes = this.nodes;\r\n        let optimize = this.optimized ? 1 : 0;\r\n\r\n        while (ruleLength) {\r\n            iReduceCount += nodesCountStack.pop();\r\n            ruleLength--;\r\n        }\r\n\r\n        if (eCreate === ENodeCreateMode.k_Skip && iReduceCount > optimize) {\r\n            nodes.length -= iReduceCount;\r\n            nodesCountStack.push(0);\r\n        }  else if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > optimize) || \r\n            (eCreate === ENodeCreateMode.k_Necessary)) {\r\n\r\n            assert(iReduceCount > 0);\r\n            \r\n            let temp = nodes.pop();\r\n            iReduceCount--;\r\n            \r\n            const name = rule.left;\r\n            // TODO: use correct location in case of include macro. \r\n            const loc = { ...temp.loc };\r\n\r\n            const node: IParseNode = { name, children: null, parent: null, value: '', loc };\r\n\r\n            this.addLink(node, temp);\r\n\r\n            while (iReduceCount) {\r\n                assert(nodes.length > 0);\r\n                this.addLink(node, nodes.pop());\r\n                iReduceCount--;\r\n            }\r\n            \r\n            nodes.push(node);\r\n            nodesCountStack.push(1);      \r\n        }\r\n        else {\r\n            nodesCountStack.push(iReduceCount);\r\n        }\r\n    }\r\n\r\n    private addNode(node: IParseNode): void {\r\n        this.nodes.push(node);\r\n        this.nodesCountStack.push(1);\r\n    }\r\n\r\n    $pop(loc: IRange = null): void {\r\n        let count = this.nodesCountStack.pop();\r\n        while (count) {\r\n            let node = this.nodes.pop();\r\n            if (loc) {\r\n                extendRange(loc, node.loc);\r\n            }\r\n            count--;\r\n        }\r\n    }\r\n \r\n    private addLink(parent: IParseNode, child: IParseNode): void {\r\n        parent.children = parent.children || [];\r\n        \r\n        extendRange(parent.loc, child.loc);\r\n        \r\n        parent.children.push(child);\r\n        child.parent = parent;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree {\r\n        return new ParseTree(this.optimized, this.cloneNode(this.root));\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // FIXME: location should be clonned too\r\n    private cloneNode({ name, value, children }: IParseNode): IParseNode {\r\n        const clone: IParseNode = { name, value, children: null, parent: null };\r\n        if (children) { \r\n            children.forEach(child => this.addLink(clone, this.cloneNode(child)))\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toString(): string {\r\n        if (this.root) {\r\n            return this.toStringNode(this.root);\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    /** @deprecated */\r\n    private toStringNode(node: IParseNode, padding: string = \"\"): string {\r\n        let res: string = padding + \"{\\n\";\r\n        let oldPadding: string = padding;\r\n        let defaultPadding: string = \"  \";\r\n\r\n        padding += defaultPadding;\r\n\r\n        if (node.value) {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"value : \\\"\" + node.value + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            res += padding + \"name : \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"children : [\";\r\n\r\n            let children: IParseNode[] = node.children;\r\n\r\n            if (children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n\r\n                for (let i = children.length - 1; i >= 0; i--) {\r\n                    res += this.toStringNode(children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toHTMLString(node: IParseNode, padding: string = \"\") {\r\n        node = node || this.root;\r\n        let res = padding + \"{\\n\";\r\n        let oldPadding = padding;\r\n        let defaultPadding = \"  \";\r\n        padding += defaultPadding;\r\n        if (node.value) {\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">name</b>: \\\"\" + node.name + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">value</b>: \\\"\" + node.value + \"\\\"\" + \",\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n        }\r\n        else {\r\n            let i;\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">name</i>: \\\"\" + node.name + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">line</b>: \\\"\" + node.loc.start.line + \"\\\" - \\\"\" + node.loc.end.line + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<b style=\\\"color: #458383;\\\">column</b>: \\\"\" + node.loc.start.column + \"\\\" - \\\"\" + node.loc.end.column + \"\\\"\" + \"\\n\";\r\n            // sRes += sPadding + \"<b style=\\\"color: #458383;\\\">position</b>: \\\"\" + pNode.position + \"\\\"\" + \"\\n\";\r\n            res += padding + \"<i style=\\\"color: #8A2BE2;\\\">children</i>: [\";\r\n            if (node.children) {\r\n                res += \"\\n\";\r\n                padding += defaultPadding;\r\n                for (i = node.children.length - 1; i >= 0; i--) {\r\n                    res += this.toHTMLString(node.children[i], padding);\r\n                    res += \",\\n\";\r\n                }\r\n                res = res.slice(0, res.length - 2);\r\n                res += \"\\n\";\r\n                res += oldPadding + defaultPadding + \"]\\n\";\r\n            }\r\n            else {\r\n                res += \" ]\\n\";\r\n            }\r\n        }\r\n        res += oldPadding + \"}\";\r\n        return res;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { ECheckStage, EInstructionTypes, IInstruction, IInstructionError, IScope } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport interface IInstructionSettings {\r\n    scope: IScope;\r\n\r\n    sourceNode?: IParseNode;\r\n    visible?: boolean;\r\n\r\n    instrType?: EInstructionTypes;\r\n}\r\n\r\nexport class Instruction implements IInstruction {\r\n    private _sourceNode: IParseNode;\r\n    private _instructionID: number;\r\n    private _instructionType: EInstructionTypes;\r\n    private _scope: IScope;\r\n    private _parent: IInstruction;\r\n    private _lastError: IInstructionError;\r\n\r\n    private static INSTRUCTION_COUNTER: number = 0;\r\n\r\n    constructor({\r\n        scope,\r\n        instrType/* = EInstructionTypes.k_Instruction*/,\r\n        sourceNode = null,\r\n        visible = true\r\n    }: IInstructionSettings) {\r\n\r\n        this._sourceNode = sourceNode;\r\n        this._instructionType = instrType;\r\n        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);\r\n        this._scope = scope;\r\n        this._parent = null;\r\n        this._lastError = null;\r\n    }\r\n\r\n\r\n    get parent(): IInstruction {\r\n        // console.assert(this._parent, \"Parent is not defined!\");\r\n        return this._parent;\r\n    }\r\n\r\n\r\n    get instructionType(): EInstructionTypes {\r\n        console.assert(this._instructionType != EInstructionTypes.k_Instruction, \"Instruction type 'k_Instruction' is forbidden.\");\r\n        return this._instructionType;\r\n    }\r\n\r\n    get instructionName(): string {\r\n        return EInstructionTypes[this.instructionType];\r\n    }\r\n\r\n\r\n    get instructionID(): number {\r\n        return this._instructionID;\r\n    }\r\n\r\n\r\n    get scope(): IScope {\r\n        if (!isNull(this._scope)) {\r\n            return this._scope;\r\n        }\r\n\r\n        if (!isNull(this.parent)) {\r\n            return this.parent.scope;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    get sourceNode(): IParseNode {\r\n        return this._sourceNode;\r\n    }\r\n\r\n    _getLastError(): IInstructionError {\r\n        return this._lastError;\r\n    }\r\n\r\n    _setError(eCode: number, pInfo: any = null): void {\r\n        this._lastError = { code: eCode, info: pInfo }\r\n    }\r\n\r\n    _clearError(): void {\r\n        this._lastError = null\r\n    }\r\n\r\n    _isErrorOccured(): boolean {\r\n        return !isNull(this._lastError);\r\n    }\r\n\r\n\r\n    /**\r\n     * Check that instuction is valid.\r\n     */\r\n    _check(eStage: ECheckStage, pInfo: any = null): boolean {\r\n        if (this._isErrorOccured()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        console.error(\"@pure_virtual\");\r\n        return null;\r\n    }\r\n\r\n\r\n    $withParent<T extends IInstruction>(parent: IInstruction | null): T {\r\n        console.assert(this._parent == null, \"parent redefenition detected!\");\r\n        if (this.instructionType === EInstructionTypes.k_SystemType && (this as any).name === 'float' && this._parent == null && parent != null) {\r\n            debugger;\r\n        }\r\n        this._parent = parent;\r\n        // todo: remove this hack!\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    // An auxiliary function created to maintain the clarity of the code.\r\n    $withNoParent<T extends IInstruction>(): T {\r\n        return <any>this;\r\n    }\r\n\r\n\r\n    static $withParent<T extends IInstruction>(child: T, parent: IInstruction): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withParent(parent);\r\n    }\r\n\r\n    static $withNoParent<T extends IInstruction>(child: T): T | null {\r\n        if (isNull(child)) {\r\n            return null;\r\n        }\r\n        return child.$withNoParent();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","\r\nexport enum ERenderStateValues {\r\n    UNDEF = 0,\r\n\r\n    TRUE,\r\n    FALSE,\r\n    ZERO,\r\n    ONE,\r\n    SRCCOLOR,\r\n    INVSRCCOLOR,\r\n    SRCALPHA,\r\n    INVSRCALPHA,\r\n    DESTALPHA,\r\n    INVDESTALPHA,\r\n    DESTCOLOR,\r\n    INVDESTCOLOR,\r\n    SRCALPHASAT,\r\n    NONE,\r\n    CW,\r\n    CCW,\r\n    FRONT,\r\n    BACK,\r\n    FRONT_AND_BACK,\r\n    NEVER,\r\n    LESS,\r\n    EQUAL,\r\n    LESSEQUAL,\r\n    GREATER,\r\n    NOTEQUAL,\r\n    GREATEREQUAL,\r\n    ALWAYS,\r\n\r\n    FUNCADD,\r\n    FUNCSUBTRACT,\r\n    FUNCREVERSESUBTRACT,\r\n\r\n    // HACK: temp hack\r\n    LINELIST,\r\n    LINESTRIP,\r\n    TRIANGLELIST,\r\n    TRAINGLESTRIP,\r\n    POINTLIST\r\n}\r\n","import { type } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, ICastExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICastExprInstructionSettings extends IExprInstructionSettings {\r\n    sourceExpr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (type) expr\r\n * EMPTY_OPERATOR VariableTypeInstruction Instruction\r\n */\r\nexport class CastExprInstruction extends ExprInstruction implements ICastExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    constructor({ sourceExpr, ...settings }: ICastExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CastExpr, ...settings });\r\n        this.expr = Instruction.$withParent(sourceExpr, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `(${this.type.toCode()})${this.expr.toCode()}`;\r\n    }\r\n\r\n    \r\n    isUseless() {\r\n        return this.type.isEqual(this.expr.type);\r\n    }\r\n    \r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_FLOAT } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IFloatInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n}\r\n\r\nexport class FloatInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, scope, ...settings }: IFloatInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FloatExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_FLOAT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.value}${this.value % 1 === 0? '.': ''}`;\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { ITypedInstructionSettings, TypedInstruction } from \"@lib/fx/analisys/instructions/TypedInstruction\";\r\nimport { EInstructionTypes, IAssignmentExprInstruction, IComplexExprInstruction, IExprInstruction, IIdExprInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprInstructionSettings extends ITypedInstructionSettings {\r\n    \r\n}\r\n\r\nexport class ExprInstruction extends TypedInstruction implements IExprInstruction {\r\n    protected _evalResult: any;\r\n\r\n    constructor({ ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Expr, ...settings });\r\n        this._evalResult = null;\r\n    }\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>super.type;\r\n    }\r\n\r\n    evaluate(): boolean {\r\n        console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    getEvalValue(): any {\r\n        return this._evalResult;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        // console.error(\"@pure_virtual\");\r\n        return false;\r\n    }\r\n\r\n    isConstExpr(): boolean {\r\n        // todo: implement it properly\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, ETechniqueType, IStructDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ICompileExprInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { ITechniqueInstructionSettings, TechniqueInstruction } from \"../TechniqueInstruction\";\r\n\r\n// prohibition of explicitly indicating the type of technique\r\nexport interface IPartFxInstructionSettings extends Omit<ITechniqueInstructionSettings<IPartFxPassInstruction>, \"techniqueType\"> {\r\n    spawnRoutine: ICompileExprInstruction;\r\n    initRoutine: ICompileExprInstruction;\r\n    updateRoutine: ICompileExprInstruction;\r\n    particle: ITypeInstruction;\r\n    capacity?: number;\r\n}\r\n\r\n// var s: IPartFxInstructionSettings;\r\n// s.te\r\n\r\nexport class PartFxInstruction extends TechniqueInstruction<IPartFxPassInstruction> implements IPartFxInstruction {\r\n    protected _spawnRoutine: ICompileExprInstruction;\r\n    protected _initRoutine: ICompileExprInstruction;\r\n    protected _updateRoutine: ICompileExprInstruction;\r\n    protected _particle: ITypeInstruction;\r\n    protected _material: ITypeInstruction;\r\n    protected _capacity: number;\r\n\r\n    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }: IPartFxInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxDecl, techniqueType: ETechniqueType.k_PartFx, ...settings });\r\n\r\n        this._spawnRoutine = spawnRoutine;\r\n        this._initRoutine = initRoutine;\r\n        this._updateRoutine = updateRoutine;\r\n        this._particle = particle;\r\n        this._capacity = capacity;\r\n    }\r\n\r\n    get spawnRoutine(): ICompileExprInstruction {\r\n        return this._spawnRoutine;\r\n    }\r\n\r\n    \r\n    get initRoutine(): ICompileExprInstruction {\r\n        return this._initRoutine;\r\n    }\r\n\r\n    \r\n    get updateRoutine(): ICompileExprInstruction {\r\n        return this._updateRoutine;\r\n    }\r\n\r\n    get particle(): ITypeInstruction {\r\n        return this._particle;\r\n    }\r\n\r\n    get capacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    isValid() {\r\n        const routineCheck = !!this.spawnRoutine && !!this.initRoutine && !!this.updateRoutine;\r\n        const particleCheck = !!this.particle;\r\n        const passCheck = this.passList && this.passList.filter((pass: IPartFxPassInstruction) => pass.isValid()).length > 0;\r\n\r\n        return routineCheck && particleCheck && passCheck;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionCallInstructionSettings extends IExprInstructionSettings {\r\n    decl: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n    callee?: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Respresnt func(arg1,..., argn)\r\n * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class FunctionCallInstruction extends ExprInstruction implements IFunctionCallInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // helpers\r\n    readonly decl: IFunctionDeclInstruction; // << move to resolveDecl() method.\r\n    \r\n    constructor({ decl, args, callee, ...settings }: IFunctionCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionCallExpr, ...settings });\r\n        \r\n        this.callee = callee;\r\n        this.args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n\r\n    toCode(): string {\r\n        const { callee, decl: { def }, args } = this;\r\n        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;\r\n    }\r\n}\r\n\r\n\r\n","import { isString, isDef, isNull } from \"../common\";\r\n\r\nclass Pathinfo {\r\n    private _dirname: string = null;\r\n    private _extension: string = null;\r\n    private _filename: string = null;\r\n\r\n    get path(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    set path(path: string) {\r\n        this.set(path);\r\n    }\r\n\r\n    get dirname(): string {\r\n        return this._dirname;\r\n    }\r\n\r\n    set dirname(dirname: string) {\r\n        this._dirname = dirname;\r\n    }\r\n\r\n    get filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    set filename(filename: string) {\r\n        this._filename = filename;\r\n    }\r\n\r\n    get ext(): string {\r\n        return this._extension;\r\n    }\r\n\r\n    set ext(extension: string) {\r\n        this._extension = extension;\r\n    }\r\n\r\n    get basename(): string {\r\n        return (this._filename ? this._filename + (this._extension ? \".\" + this._extension : \"\") : \"\");\r\n    }\r\n\r\n    set basename(basename: string) {\r\n        var nPos: number = basename.lastIndexOf(\".\");\r\n\r\n        if (nPos < 0) {\r\n            this._filename = basename.substr(0);\r\n            this._extension = null;\r\n        }\r\n        else {\r\n            this._filename = basename.substr(0, nPos);\r\n            this._extension = basename.substr(nPos + 1);\r\n        }\r\n    }\r\n\r\n\r\n    constructor(path: Pathinfo);\r\n    constructor(path: string);\r\n    constructor(path?: any) {\r\n        if (isDef(path)) {\r\n            this.set(<string>path);\r\n        }\r\n    }\r\n\r\n\r\n    set(path: string): void;\r\n    set(path: Pathinfo): void;\r\n    set(path?: any) {\r\n        if (isString(path)) {\r\n            var pParts: string[] = path.replace('\\\\', '/').split('/');\r\n\r\n            this.basename = (pParts.pop());\r\n\r\n            this._dirname = pParts.join('/');\r\n        }\r\n        else if (path instanceof Pathinfo) {\r\n            this._dirname = path.dirname;\r\n            this._filename = path.filename;\r\n            this._extension = path.ext;\r\n        }\r\n        else if (isNull(path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            //critical_error\r\n            throw new Error(`Unexpected data type was used: ${path}`);\r\n        }\r\n    }\r\n\r\n    isAbsolute(): boolean { return this._dirname[0] === \"/\"; }\r\n\r\n\r\n    toString(): string {\r\n        return (this._dirname ? this._dirname + \"/\" : \"\") + (this.basename);\r\n    }\r\n}\r\n\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n        var last = parts[i];\r\n        if (last === '.') {\r\n            parts.splice(i, 1);\r\n        } else if (last === \"..\") {\r\n            parts.splice(i, 1);\r\n            up++;\r\n        } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n        }\r\n    }\r\n\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n        for (; up--;) {\r\n            parts.unshift(\"..\");\r\n        }\r\n    }\r\n\r\n    return parts;\r\n}\r\n\r\n\r\nexport function normalize(path: string): string {\r\n    var info: Pathinfo = parse(path);\r\n    var isAbsolute: boolean = info.isAbsolute();\r\n    var tail: string = info.dirname;\r\n    var trailingSlash: boolean = /[\\\\\\/]$/.test(tail);\r\n\r\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/).filter(function (p) {\r\n        return !!p;\r\n    }), !isAbsolute).join(\"/\");\r\n\r\n    if (tail && trailingSlash) {\r\n        tail += \"/\";\r\n    }\r\n\r\n    info.dirname = ((isAbsolute ? \"/\" : \"\") + tail);\r\n\r\n    return info.toString();\r\n}\r\n\r\nexport function parse(path: Pathinfo): Pathinfo;\r\nexport function parse(path: string): Pathinfo;\r\nexport function parse(path?): Pathinfo {\r\n    return new Pathinfo(path);\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_BOOL } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IBoolInstructionSettings extends IInstructionSettings {\r\n    value: boolean;\r\n}\r\n\r\nexport class BoolInstruction extends ExprInstruction implements ILiteralInstruction<boolean> {\r\n    readonly value: boolean;\r\n\r\n    constructor({ value, scope, ...settings }: IBoolInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BoolExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n    }\r\n\r\n    toString(): string {\r\n        return String(this.value);\r\n    }\r\n\r\n    toCode(): string {\r\n        return this.value ? \"true\" : \"false\";\r\n    }\r\n\r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IIdExprInstruction, IIdInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdExprInstructionSettings extends IInstructionSettings {\r\n    id: IIdInstruction;\r\n    decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport class IdExprInstruction extends ExprInstruction implements IIdExprInstruction {\r\n    readonly id: IIdInstruction;\r\n    // helpers\r\n    readonly decl: IVariableDeclInstruction; // << move to resolveDecl() method.\r\n\r\n    constructor({ id, decl, ...settings }: IIdExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IdExpr, type: decl.type, ...settings });\r\n\r\n        this.id = Instruction.$withParent(id, this);\r\n        this.decl = decl;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.id.name;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.type.isConst();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this.decl.id.toCode();\r\n    }\r\n}\r\n\r\n","\r\nexport enum ERenderStates {\r\n\tBLENDENABLE,\r\n\tCULLFACEENABLE,\r\n\tZENABLE,\r\n\tZWRITEENABLE,\r\n\tDITHERENABLE,\r\n\tSCISSORTESTENABLE,\r\n\tSTENCILTESTENABLE,\r\n\tPOLYGONOFFSETFILLENABLE,\r\n\r\n\tCULLFACE,\r\n\tFRONTFACE,\r\n\r\n\tSRCBLENDCOLOR,\r\n\tDESTBLENDCOLOR,\r\n\r\n\tSRCBLENDALPHA,\r\n\tDESTBLENDALPHA,\r\n\r\n\tBLENDEQUATIONCOLOR,\r\n\tBLENDEQUATIONALPHA,\r\n\r\n\tZFUNC,\r\n\r\n\tALPHABLENDENABLE,\r\n\tALPHATESTENABLE,\r\n\r\n\tSRCBLEND, // Fake, set SRCBLENDCOLOR, SRCBLENDALPHA. Not use in setRenderState\r\n\tDESTBLEND, // Fake, set DESTBLENDCOLOR, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDFUNC, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\tBLENDFUNCSEPARATE, // Fake, set SRCBLENDCOLOR, DESTBLENDCOLOR, SRCBLENDALPHA, DESTBLENDALPHA. Not use in setRenderState\r\n\r\n\tBLENDEQUATION, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\tBLENDEQUATIONSEPARATE, // Fake, set BLENDEQUATIONCOLOR, BLENDEQUATIONALPHA. Not use in setRenderState\r\n\r\n\r\n\t// HACK:\r\n\tPRIMITIVETOPOLOGY,\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction } from \"./instruction\";\r\nimport { variable } from \"./variable\";\r\n\r\nexport namespace type {\r\n    // todo: rename it\r\n    /** @deprecated */\r\n    export function isInheritedFromVariableDecl(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n        const parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return true;\r\n        }\r\n        else if (parentType === EInstructionTypes.k_VariableType) {\r\n            return isInheritedFromVariableDecl(<IVariableTypeInstruction>type.parent);\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function isTypeOfField(type: ITypeInstruction): boolean {\r\n        if (isNull(type.parent)) {\r\n            return false;\r\n        }\r\n\r\n        if (type.parent.instructionType === EInstructionTypes.k_VariableDecl) {\r\n            let pParentDecl: IVariableDeclInstruction = <IVariableDeclInstruction>type.parent;\r\n            return pParentDecl.isField();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentContainer(type: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {\r\n            return null;\r\n        }\r\n\r\n        let containerType: IVariableTypeInstruction = <IVariableTypeInstruction>findParentVariableDecl(type).parent;\r\n        if (!isInheritedFromVariableDecl(containerType)) {\r\n            return null;\r\n        }\r\n\r\n        return findParentVariableDecl(containerType);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDecl(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType: EInstructionTypes = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_VariableDecl) {\r\n            return <IVariableDeclInstruction>type.parent;\r\n        }\r\n\r\n        return findParentVariableDecl(<IVariableTypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function findParentVariableDeclName(type: ITypeInstruction): string {\r\n        let varDecl = findParentVariableDecl(type)\r\n        return isNull(varDecl) ? null : varDecl.name;\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDecl(type: ITypeInstruction): ITypeDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        let parentType = type.parent.instructionType;\r\n        if (parentType === EInstructionTypes.k_TypeDecl) {\r\n            return <ITypeDeclInstruction>type.parent;\r\n        }\r\n        return finParentTypeDecl(<ITypeInstruction>type.parent);\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function finParentTypeDeclName(type: IVariableTypeInstruction): string {\r\n        let typeDecl = finParentTypeDecl(type);\r\n        return isNull(typeDecl) ? null : typeDecl.name;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    export function resolveVariableDeclFullName(type: ITypeInstruction): string {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            console.error(\"Not from variable decl\");\r\n            return null;\r\n        }\r\n\r\n        return variable.fullName(findParentVariableDecl(type));\r\n    }\r\n\r\n\r\n    // todo: add comment\r\n    // todo: review this code\r\n    /** @deprecated */\r\n    export function findMainVariable(type: ITypeInstruction): IVariableDeclInstruction {\r\n        if (!isInheritedFromVariableDecl(type)) {\r\n            return null;\r\n        }\r\n\r\n        if (isTypeOfField(type)) {\r\n            return findMainVariable(<IVariableTypeInstruction>type.parent.parent);\r\n        }\r\n        return findParentVariableDecl(type);\r\n    }\r\n\r\n    //\r\n    // Signatures\r\n    //\r\n\r\n    function signatureVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let prefix = '';\r\n        if (strong) {\r\n            if (vtype.usages.length > 0) {\r\n                prefix = `${vtype.usages.join('_')}_`;\r\n            }\r\n        }\r\n        let postfix = '';\r\n        if (vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${prefix}${signature(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n\r\n    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)\r\n\r\n\r\n    export function signature(type: ITypeInstruction, strong: boolean = false): string {\r\n        if (isNull(type)) {\r\n            assert(!strong);\r\n            return '*';\r\n        }\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return signatureVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return `${type.name}${type.instructionID}`;\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? signature(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    //\r\n    // hash\r\n    //\r\n\r\n    function hashVType(vtype: IVariableTypeInstruction, strong: boolean): string {\r\n        let postfix = '';\r\n        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {\r\n            postfix = '[]';\r\n            if (vtype.length !== instruction.UNDEFINE_LENGTH) {\r\n                postfix = `[${vtype.length}]`;\r\n            }\r\n        }\r\n\r\n        return `${hash(vtype.subType)}${postfix}`;\r\n    }\r\n\r\n    function hashComplex(ctype: ITypeInstruction, strong: boolean): string {\r\n        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;\r\n    }\r\n\r\n    export function hash(type: ITypeInstruction, strong: boolean = false): string {\r\n        switch (type.instructionType) {\r\n            case EInstructionTypes.k_VariableType:\r\n                return hashVType(<IVariableTypeInstruction>type, strong);\r\n            case EInstructionTypes.k_ComplexType:\r\n                return hashComplex(type, strong);\r\n            case EInstructionTypes.k_ProxyType:\r\n                return type.baseType ? hash(type.baseType) : type.name;\r\n            case EInstructionTypes.k_SystemType:\r\n                return type.name;\r\n            default:\r\n                assert(false, 'unsupported type');\r\n                return null;\r\n        }\r\n    }\r\n\r\n    export function compareRelaxed(a: ITypeInstruction, b: ITypeInstruction, strong: boolean = false): boolean {\r\n        return hash(a, strong) === hash(b, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function compare(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        if (isNull(a) || isNull(b)) {\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp && b instanceof RegExp) {\r\n            assert(false);\r\n            return false;\r\n        }\r\n\r\n        if (a instanceof RegExp) {\r\n            let ra = <RegExp>a;\r\n            let sb = signature(<ITypeInstruction>b, strong);\r\n            return !!sb.match(ra);\r\n        }\r\n\r\n        if (b instanceof RegExp) {\r\n            let sa = signature(<ITypeInstruction>a, strong);\r\n            let rb = <RegExp>b;\r\n            return !!sa.match(rb);\r\n        }\r\n\r\n        let ta = <ITypeInstruction>a;\r\n        let tb = <ITypeInstruction>b;\r\n        if (ta.isArray() && tb.isArray()) {\r\n            if (ta.length === instruction.UNDEFINE_LENGTH ||\r\n                tb.length === instruction.UNDEFINE_LENGTH) {\r\n                return false;\r\n            }\r\n        }\r\n        return signature(ta, strong) === signature(tb, strong);\r\n    }\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function equals(a: ITypeInstruction | RegExp, b: ITypeInstruction | RegExp, strong: boolean = false): boolean {\r\n        return compare(a, b, strong);\r\n    }\r\n}\r\n","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\n\r\nexport type BreakOperator = \"break\" | \"discard\";\r\n\r\nexport interface IBreakStmtInstructionSettings extends IInstructionSettings {\r\n    operator?: BreakOperator;\r\n}\r\n\r\n/**\r\n * Reprsernt continue; break; discard;\r\n * (continue || break || discard) \r\n */\r\nexport class BreakStmtInstruction extends StmtInstruction {\r\n    protected _operator: BreakOperator;\r\n\r\n    constructor({ operator = \"break\", ...settings }: IBreakStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_BreakStmt, ...settings });\r\n        this._operator = operator;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    // todo: validate operator's name\r\n    toCode(): string {\r\n        console.assert(this.operator == \"break\");\r\n        return this.operator + \";\";\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ETechniqueType } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { IPartFxInstruction } from \"@lib/idl/part/IPartFx\";\r\nimport { CodeLens, Command, Position, Range, TextDocument } from \"vscode-languageserver-types\";\r\n\r\nexport class FXCodeLenses {\r\n    doProvide(textDocument: TextDocument, slDocument: ISLDocument): CodeLens[] {\r\n        if (!slDocument) {\r\n            return [];\r\n        }\r\n\r\n        const lenses: CodeLens[] = [];\r\n        const scope = slDocument.root.scope;\r\n\r\n        /**\r\n         * Just a draft code :)\r\n         */\r\n\r\n        const createCodeLens = (name: string, loc: IRange): CodeLens => {\r\n            const pos = Position.create(loc.start.line, loc.start.column);\r\n            const range = Range.create(pos, pos);\r\n            const lens = CodeLens.create(range);\r\n            lens.command = Command.create(name, null);\r\n            return lens;\r\n        };\r\n\r\n        if (!isNull(scope)) {\r\n            for (const techniqueName in scope.techniques) {\r\n                const technique = scope.techniques[techniqueName];\r\n                if (technique.type === ETechniqueType.k_PartFx) {\r\n                    const partFx = <IPartFxInstruction>technique;\r\n\r\n                    if (partFx.spawnRoutine) {\r\n                        const sourceNode = partFx.spawnRoutine.function.def.sourceNode;\r\n                        lenses.push(createCodeLens(`[spawn routine]`, sourceNode.loc));\r\n                    }\r\n\r\n                    if (partFx.initRoutine) {\r\n                        const sourceNode = partFx.initRoutine.function.def.sourceNode;\r\n                        lenses.push(createCodeLens(`[init routine]`, sourceNode.loc));\r\n                    }\r\n\r\n                    if (partFx.updateRoutine) {\r\n                        const sourceNode = partFx.updateRoutine.function.def.sourceNode;\r\n                        lenses.push(createCodeLens(`[update routine]`, sourceNode.loc));\r\n                    }\r\n\r\n                    if (partFx.particle &&\r\n                        partFx.particle.instructionType !== EInstructionTypes.k_SystemType) {\r\n                        const sourceNode = partFx.particle.sourceNode;\r\n                        lenses.push(createCodeLens(`[particle]`, sourceNode.loc));\r\n                    }\r\n\r\n                    for (const pass of partFx.passList) {\r\n                        if (pass.prerenderRoutine) {\r\n                            {\r\n                                const sourceNode = pass.prerenderRoutine.function.def.sourceNode;\r\n                                lenses.push(createCodeLens(`[prerender routine]`, sourceNode.loc));\r\n                            }\r\n                            {\r\n                                const sourceNode = pass.particleInstance.sourceNode;\r\n                                lenses.push(createCodeLens(`[material]`, sourceNode.loc));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lenses;\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { IDMap, IMap } from \"@lib/idl/IMap\";\r\nimport { ENodeCreateMode as ENodeCreationMode, EOperationType, EParserFlags, EParserType, ExpectedSymbols, IAdditionalFuncInfo, IOperation, IOperationMap, IParser, IParserParams, IPosition, IProductions, IRange, IRule, IRuleFunctionDMap, IRuleMap, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { Item } from \"./Item\";\r\nimport { LexerEngine } from \"./Lexer\";\r\nimport { State } from \"./State\";\r\nimport { END_POSITION, END_SYMBOL, FLAG_RULE_CREATE_NODE, FLAG_RULE_FUNCTION, FLAG_RULE_EXPOSE_NODE, INLINE_COMMENT_SYMBOL, LEXER_RULES, START_SYMBOL, T_EMPTY, UNUSED_SYMBOL, FLAG_RULE_SKIP_NODE } from \"./symbols\";\r\n\r\nexport enum EParserErrors {\r\n    GrammarAddOperation = 2001,\r\n    GrammarAddStateLink,\r\n    GrammarUnexpectedSymbol,\r\n    GrammarInvalidAdditionalFuncName,\r\n    GrammarInvalidKeyword\r\n};\r\n\r\n\r\ntype Terminals = Set<string>;\r\n\r\n\r\nexport class GrammarDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Grammar diagnostics\", 'G');\r\n    }\r\n\r\n\r\n    protected resolveFilename(code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(code: number, desc: IMap<any>): IRange {\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(code: number, desc: IMap<any>): IPosition {\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParserErrors.GrammarAddOperation]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old operation: {oldOperation}\\n\" +\r\n                \"New operation: {newOperation}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\" +\r\n                `\\n\\n{stateDesc}`,\r\n            [EParserErrors.GrammarAddStateLink]: \"Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\\n\" +\r\n                \"Conflict in state with index: {stateIndex}. With grammar symbol: \\\"{grammarSymbol}\\\"\\n\" +\r\n                \"Old next state: {oldNextStateIndex}\\n\" +\r\n                \"New next state: {newNextStateIndex}\\n\" +\r\n                \"For more info init parser in debug-mode and see syntax table and list of states.\",\r\n            [EParserErrors.GrammarUnexpectedSymbol]: \"Grammar error. Can`t generate rules from grammar\\n\" +\r\n                \"Unexpected symbol: {unexpectedSymbol}\\n\" +\r\n                \"Expected: {expectedSymbol}\",\r\n            [EParserErrors.GrammarInvalidAdditionalFuncName]: \"Grammar error. Empty additional function name.\",\r\n            [EParserErrors.GrammarInvalidKeyword]: \"Grammar error. Bad keyword: {badKeyword}\\n\" +\r\n                \"All keyword must be define in lexer rule block.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class AbstractParser implements IParser {\r\n    //Process params\r\n\r\n    // TODO: make readonly\r\n    lexerEngine: LexerEngine;\r\n\r\n    //\r\n    // Grammar based Info\r\n    //\r\n\r\n    private _syntaxTable: ISyntaxTable;\r\n\r\n\r\n    /**\r\n     * General structure:\r\n     *  { [symbol name]: { [rule index]: IRule } }\r\n     */\r\n    private _productions: IProductions;\r\n    private _states: State[];\r\n\r\n    /**\r\n * Auxiliary map for all symbols from grammar: symbolName => symbolName.\r\n * For ex.: T_PUNCTUATOR_61 => '='\r\n */\r\n    private _grammarSymbols: Map<string, string>;\r\n\r\n    // functions described in grammar's flags\r\n    private _additionalFuncInfoList: IAdditionalFuncInfo[];\r\n    private _adidtionalFunctByStateDMap: IRuleFunctionDMap;\r\n\r\n    // Additioanal info\r\n\r\n    // flags for rules (extracted from grammar's flags)\r\n    private _ruleCreationModeMap: IMap<number>;\r\n\r\n    // Temp\r\n\r\n    // aux. cache for first terminals\r\n    private _firstTerminalsCache: IMap<Terminals>;\r\n    // private _followTerminalsCache: IDMap<boolean>;\r\n\r\n\r\n    //\r\n    // LALR specific\r\n    //\r\n\r\n    /**\r\n     * Auxiliary map: [item index] => { [item index]: true }\r\n     * Expectation correspondence map.\r\n     */\r\n    // NOTE: default JS object significantly faster than Map<number, Set<number>>\r\n    //       for this case :/\r\n    private _expectedExtensionDMap: IDMap<boolean>;\r\n    private _baseItems: Item[];\r\n    private _closureForItemsCache: IMap<State>;\r\n\r\n    // TODO: use dedicated type for parser engine\r\n    private _diag: GrammarDiagnostics;\r\n\r\n    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR\r\n    constructor({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this._syntaxTable = null;\r\n\r\n        this._productions = null;\r\n        this._baseItems = null;\r\n        this._states = null;\r\n\r\n        this._additionalFuncInfoList = null;\r\n        this._adidtionalFunctByStateDMap = null;\r\n\r\n        this._ruleCreationModeMap = null;\r\n\r\n        this._firstTerminalsCache = null;\r\n        // this._followTerminalsCache = null;\r\n        this._closureForItemsCache = null;\r\n\r\n        this._expectedExtensionDMap = null;\r\n        this._diag = new GrammarDiagnostics;\r\n\r\n        this.init({ grammar, flags, type });\r\n    }\r\n\r\n    get syntaxTable(): ISyntaxTable {\r\n        return this._syntaxTable;\r\n    }\r\n\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string {\r\n        const funcDMap = this._adidtionalFunctByStateDMap;\r\n\r\n        if (!isNull(funcDMap) &&\r\n            isDef(funcDMap[stateIndex]) &&\r\n            isDef(funcDMap[stateIndex][grammarSymbol])) {\r\n            return funcDMap[stateIndex][grammarSymbol];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreationMode {\r\n        return this._ruleCreationModeMap[nonTerminal];\r\n    }\r\n\r\n\r\n    getGrammarSymbols(): Map<string, string> {\r\n        return this._grammarSymbols;\r\n    }\r\n\r\n    protected init({ grammar, flags = EParserFlags.k_Default, type = EParserType.k_LALR }: IParserParams) {\r\n        this.lexerEngine = new LexerEngine();\r\n\r\n        this.generateRules(grammar, flags);\r\n        this.buildSyntaxTable(type);\r\n        this.generateFunctionByStateMap();\r\n\r\n        if (!bf.testAll(flags, EParserFlags.k_Debug)) {\r\n            this.clearMem();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    printStates(isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.warn(\"It`s impossible to print states. You must init parser in debug-mode\");\r\n            return;\r\n        }\r\n        const mesg = \"\\n\" + this.statesToString(isBaseOnly);\r\n        console.log(mesg);\r\n    }\r\n\r\n\r\n    printState(stateIndex: number, isBaseOnly: boolean = true): void {\r\n        if (!isDef(this._states)) {\r\n            console.log(\"It`s impossible to print states. You must init parser in debug-mode.\");\r\n            return;\r\n        }\r\n\r\n        var state = this._states[stateIndex];\r\n        if (!isDef(state)) {\r\n            console.log(\"Can not print stete with index: \" + stateIndex.toString());\r\n            return;\r\n        }\r\n\r\n        console.log(`\\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);\r\n    }\r\n\r\n\r\n    protected critical(code, desc) {\r\n        this._diag.critical(code, desc);\r\n    }\r\n\r\n    private grammarError(code: number, desc) {\r\n        let file = \"grammar\";\r\n\r\n        switch (code) {\r\n            case EParserErrors.GrammarAddOperation:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;\r\n                    this.critical(code, {\r\n                        file, line: 0, stateIndex, grammarSymbol,\r\n                        oldOperation: AbstractParser.operationToString(oldOperation),\r\n                        newOperation: AbstractParser.operationToString(newOperation),\r\n                        stateDesc: this._states[stateIndex].toString()\r\n                    });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarAddStateLink:\r\n                {\r\n                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;\r\n                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarUnexpectedSymbol:\r\n                {\r\n                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;\r\n                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidAdditionalFuncName:\r\n                {\r\n                    const { grammarLine } = desc;\r\n                    this.critical(code, { file, line: grammarLine });\r\n                }\r\n                break;\r\n            case EParserErrors.GrammarInvalidKeyword:\r\n                {\r\n                    const { grammarLine, badKeyword } = desc;\r\n                    this.critical(code, { file, line: grammarLine, badKeyword })\r\n                }\r\n                break;\r\n            default:\r\n                throw \"invalid case!!!!\";\r\n        }\r\n    }\r\n\r\n\r\n    private clearMem(): void {\r\n        delete this._states;\r\n\r\n        delete this._productions;\r\n        delete this._baseItems;\r\n        // delete this._followTerminalsCache;\r\n        delete this._firstTerminalsCache;\r\n        delete this._closureForItemsCache;\r\n        delete this._expectedExtensionDMap;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for the state's dublicate.\r\n     */\r\n    private hasState(state: State, type: EParserType): State {\r\n        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;\r\n    }\r\n\r\n\r\n    private nonTerminals(): string[] {\r\n        return Object.keys(this._productions);\r\n    }\r\n\r\n    private rules(nonTerminal: string): IRule[] {\r\n        const prods = this._productions[nonTerminal];\r\n        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;\r\n    }\r\n\r\n    private ruleCreationMode(symbol: string) {\r\n        return this._ruleCreationModeMap[symbol];\r\n    }\r\n\r\n    /**\r\n     * terminals & non-terminals;\r\n     */\r\n    private symbols(): string[] {\r\n        return [...this._grammarSymbols.keys()];\r\n    }\r\n\r\n    private isTerminal(symbol: string): boolean {\r\n        return !(this._productions[symbol]);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'stateList' and set item's index in it.\r\n     */\r\n    private pushState(state: State): void {\r\n        state.index = this._states.length;\r\n        this._states.push(state);\r\n    }\r\n\r\n\r\n    /**\r\n     * Add item to 'baseItemList' and set item's index in it.\r\n     */\r\n    private pushBaseItem(item: Item): void {\r\n        item.index = this._baseItems.length;\r\n        this._baseItems.push(item);\r\n    }\r\n\r\n\r\n    private tryAddState(state: State, type: EParserType): State {\r\n        let res = this.hasState(state, type);\r\n\r\n        if (isNull(res)) {\r\n            if (type === EParserType.k_LR0) {\r\n                state.eachItem(item => this.pushBaseItem(item));\r\n            }\r\n\r\n            this.pushState(state);\r\n            this.closure(state, type);\r\n\r\n            return state;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private hasEmptyRule(symbol: string): boolean {\r\n        if (this.isTerminal(symbol)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this.rules(symbol).find(rule => rule.right.length === 0);\r\n    }\r\n\r\n\r\n    private pushInSyntaxTable(syntaxTable: ISyntaxTable, stateIndex: number, symbol: string, operation: IOperation): void {\r\n        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};\r\n\r\n        if (isDef(syntaxTable[stateIndex][symbol])) {\r\n            this.grammarError(EParserErrors.GrammarAddOperation, {\r\n                stateIndex: stateIndex,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol),\r\n                oldOperation: this._syntaxTable[stateIndex][symbol],\r\n                newOperation: operation\r\n            });\r\n        }\r\n\r\n        syntaxTable[stateIndex][symbol] = operation;\r\n    }\r\n\r\n\r\n    private addStateLink(state: State, nextState: State, symbol: string): void {\r\n        let isAddState = state.addNextState(symbol, nextState);\r\n        if (!isAddState) {\r\n            this.grammarError(EParserErrors.GrammarAddStateLink, {\r\n                stateIndex: state.index,\r\n                oldNextStateIndex: state.nextStates[symbol] || null,\r\n                newNextStateIndex: nextState.index,\r\n                grammarSymbol: this.convertGrammarSymbol(symbol)\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    private firstTerminals(symbol: string): Terminals {\r\n        if (this.isTerminal(symbol)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(this._firstTerminalsCache[symbol])) {\r\n            return this._firstTerminalsCache[symbol];\r\n        }\r\n\r\n        const rules = this.rules(symbol);\r\n        const res: Terminals = this._firstTerminalsCache[symbol] = new Set<string>();\r\n\r\n        if (this.hasEmptyRule(symbol)) {\r\n            res.add(T_EMPTY);\r\n        }\r\n\r\n        if (isNull(rules)) {\r\n            return res;\r\n        }\r\n\r\n        for (let i = 0; i < rules.length; ++i) {\r\n            const rule = rules[i];\r\n            const right = rule.right;\r\n\r\n            let isFinish = false;\r\n\r\n            for (let j = 0; j < right.length; j++) {\r\n                if (right[j] === symbol) {\r\n                    if (res.has(T_EMPTY)) {\r\n                        continue;\r\n                    }\r\n\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n\r\n                const terminals = this.firstTerminals(right[j]);\r\n\r\n                if (isNull(terminals)) {\r\n                    res.add(right[j]);\r\n                } else {\r\n                    for (const terminal of terminals) {\r\n                        res.add(terminal);\r\n                    }\r\n                }\r\n\r\n                if (!this.hasEmptyRule(right[j])) {\r\n                    isFinish = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!isFinish) {\r\n                res.add(T_EMPTY);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    // private followTerminal(symbolVal: string): IMap<boolean> {\r\n    //     if (isDef(this._followTerminalsCache[symbolVal])) {\r\n    //         return this._followTerminalsCache[symbolVal];\r\n    //     }\r\n\r\n    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;\r\n    //     var pRulesDMap: IRuleDMap = this._rulesDMap;\r\n    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];\r\n\r\n    //     var rule: IRule;\r\n    //     var pTempRes: IMap<boolean>;\r\n    //     var pTempKeys: string[];\r\n    //     var res: IMap<boolean>;\r\n\r\n    //     var right: string[];\r\n    //     var isFinish: boolean;\r\n\r\n    //     var sFirstKey: string;\r\n    //     var sSecondKey: string;\r\n\r\n    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};\r\n\r\n    //     if (isNull(pRulesDMap)) {\r\n    //         return res;\r\n    //     }\r\n\r\n    //     rulesDMapKeys = Object.keys(pRulesDMap);\r\n    //     for (i = 0; i < rulesDMapKeys.length; i++) {\r\n    //         sFirstKey = rulesDMapKeys[i];\r\n\r\n    //         if (isNull(pRulesDMap[sFirstKey])) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);\r\n\r\n    //         for (j = 0; j < pRulesMapKeys.length; j++) {\r\n    //             rule = pRulesDMap[sFirstKey][sSecondKey];\r\n    //             right = rule.right;\r\n\r\n    //             for (k = 0; k < right.length; k++) {\r\n    //                 if (right[k] === symbolVal) {\r\n    //                     if (k === right.length - 1) {\r\n    //                         pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                         pTempKeys = Object.keys(pTempRes);\r\n    //                         for (m = 0; m < pTempKeys.length; i++) {\r\n    //                             res[pTempKeys[m]] = true;\r\n    //                         }\r\n    //                     }\r\n    //                     else {\r\n    //                         isFinish = false;\r\n\r\n    //                         for (l = k + 1; l < right.length; l++) {\r\n    //                             pTempRes = this.firstTerminal(right[l]);\r\n\r\n    //                             if (isNull(pTempRes)) {\r\n    //                                 res[right[l]] = true;\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                             else {\r\n    //                                 pTempKeys = Object.keys(pTempRes);\r\n    //                                 for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                     res[pTempKeys[m]] = true;\r\n    //                                 }\r\n    //                             }\r\n\r\n    //                             if (!pTempRes[T_EMPTY]) {\r\n    //                                 isFinish = true;\r\n    //                                 break;\r\n    //                             }\r\n    //                         }\r\n\r\n    //                         if (!isFinish) {\r\n    //                             pTempRes = this.followTerminal(rule.left);\r\n\r\n    //                             pTempKeys = Object.keys(pTempRes);\r\n    //                             for (m = 0; m < pTempKeys.length; i++) {\r\n    //                                 res[pTempKeys[m]] = true;\r\n    //                             }\r\n    //                         }\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     return res;\r\n    // }\r\n\r\n    private firstTerminalsForSet(symbolList: string[], expectedSymbols: ExpectedSymbols): Terminals {\r\n        const res = new Set<string>();\r\n\r\n        for (let i = 0; i < symbolList.length; i++) {\r\n            const terminals = this.firstTerminals(symbolList[i]);\r\n\r\n            if (isNull(terminals)) {\r\n                res.add(symbolList[i]);\r\n                return res;\r\n            }\r\n\r\n            let isEmpty = false;\r\n            for (const symbol of terminals) {\r\n                if (symbol === T_EMPTY) {\r\n                    isEmpty = true;\r\n                    continue;\r\n                }\r\n                res.add(symbol);\r\n            }\r\n\r\n            if (!isEmpty) {\r\n                return res;\r\n            }\r\n        }\r\n\r\n        if (!isNull(expectedSymbols)) {\r\n            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    private generateRules(grammarSource: string, flags: EParserFlags): void {\r\n        let allRuleList: string[] = grammarSource.split(/\\r?\\n/);\r\n        let tempRule: string[];\r\n        let rule: IRule;\r\n        let isLexerBlock = false;\r\n\r\n        this._productions = <IProductions>{};\r\n        this._additionalFuncInfoList = <IAdditionalFuncInfo[]>[];\r\n        this._ruleCreationModeMap = <IMap<number>>{};\r\n        this._grammarSymbols = new Map([['END_SYMBOL', END_SYMBOL]]);\r\n\r\n        let i = 0, j = 0;\r\n\r\n        // append all nodes ignoring any flags\r\n        const forceAppendAllMode = bf.testAll(flags, EParserFlags.k_ForceAppendAll);\r\n        // force unwind node if it is marked as '--expose'\r\n        const allowExposeMode = bf.testAll(flags, EParserFlags.k_AllowExposeMode);\r\n        // force add node if it is marked as '--add'\r\n        const allowAddMode = bf.testAll(flags, EParserFlags.k_AllowAddMode);\r\n        // remove node from parsing tree if it is marked as '--skip'\r\n        const allowSkipMode = bf.testAll(flags, EParserFlags.k_AllowSkipMode);\r\n\r\n        let symbolsWithNodeMap: IMap<number> = this._ruleCreationModeMap;\r\n\r\n        let name: string;\r\n\r\n        let nRules = 0;\r\n\r\n        for (i = 0; i < allRuleList.length; i++) {\r\n            if (allRuleList[i] === \"\" || allRuleList[i] === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // split rule like 'S : Program'\r\n            tempRule = allRuleList[i].trim().split(/\\s* \\s*/);\r\n\r\n            // ignore rules starting with '#'\r\n            if (tempRule[0][0] == INLINE_COMMENT_SYMBOL) {\r\n                continue;\r\n            }\r\n\r\n            if (isLexerBlock) {\r\n                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === \"\")) &&\r\n                    ((tempRule[2][0] === \"\\\"\" || tempRule[2][0] === \"'\") && tempRule[2].length > 3)) {\r\n\r\n                    //TERMINALS\r\n                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],\r\n                            expectedSymbol: tempRule[2][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);\r\n\r\n                    var ch: string = tempRule[2][0];\r\n\r\n\r\n                    if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);\r\n                    }\r\n                    else {\r\n                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);\r\n                    }\r\n\r\n                    this._grammarSymbols.set(name, tempRule[2]);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // looking for '--LEXER--' keyword\r\n            if (tempRule[0] === LEXER_RULES) {\r\n                isLexerBlock = true;\r\n                continue;\r\n            }\r\n\r\n            //NON TERMNINAL RULES\r\n            if (!isDef(this._productions[tempRule[0]])) {\r\n                this._productions[tempRule[0]] = <IRuleMap>{};\r\n            }\r\n\r\n            rule = {\r\n                left: tempRule[0],\r\n                right: <string[]>[],\r\n                index: 0\r\n            };\r\n\r\n            this._grammarSymbols.set(tempRule[0], tempRule[0]);\r\n\r\n            if (forceAppendAllMode) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowExposeMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Default;\r\n            } else if (allowAddMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n            } else if (allowSkipMode && !isDef(symbolsWithNodeMap[tempRule[0]])) {\r\n                symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n            }\r\n\r\n            for (j = 2; j < tempRule.length; j++) {\r\n                if (tempRule[j] === \"\") {\r\n                    continue;\r\n                }\r\n                // handle flag '--add'\r\n                if (tempRule[j] === FLAG_RULE_CREATE_NODE) {\r\n                    if (allowAddMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Necessary;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (tempRule[j] === FLAG_RULE_SKIP_NODE) {\r\n                    if (allowSkipMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Skip;\r\n                    }\r\n                    continue;\r\n                }\r\n                // handle flag '--expose'\r\n                if (tempRule[j] === FLAG_RULE_EXPOSE_NODE) {\r\n                    if (allowExposeMode && !forceAppendAllMode) {\r\n                        symbolsWithNodeMap[tempRule[0]] = ENodeCreationMode.k_Expose;\r\n                    }\r\n                    continue;\r\n                }\r\n                // looking for additional user functions like '--F includeCode'\r\n                if (tempRule[j] === FLAG_RULE_FUNCTION) {\r\n                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });\r\n                    }\r\n\r\n                    const funcInfo = <IAdditionalFuncInfo>{\r\n                        name: tempRule[j + 1],\r\n                        position: rule.right.length,\r\n                        rule: rule\r\n                    };\r\n                    this._additionalFuncInfoList.push(funcInfo);\r\n                    j++;\r\n                    continue;\r\n                }\r\n                // handle string literlas\r\n                if (tempRule[j][0] === \"'\" || tempRule[j][0] === \"\\\"\") {\r\n                    if (tempRule[j].length !== 3) {\r\n                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {\r\n                            badKeyword: tempRule[j],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n                    if (tempRule[j][0] !== tempRule[j][2]) {\r\n                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {\r\n                            unexpectedSymbol: tempRule[j][2],\r\n                            expectedSymbol: tempRule[j][0],\r\n                            grammarLine: i\r\n                        });\r\n                    }\r\n\r\n                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);\r\n                    rule.right.push(name);\r\n                    this._grammarSymbols.set(name, tempRule[j][1]);\r\n                }\r\n                else {\r\n                    rule.right.push(tempRule[j]);\r\n                    this._grammarSymbols.set(tempRule[j], tempRule[j]);\r\n                }\r\n            }\r\n\r\n            rule.index = nRules;\r\n            this._productions[tempRule[0]][rule.index] = rule;\r\n            nRules++;\r\n\r\n            // TODO: emit diagnostics error instead.\r\n            assert(nRules != 1 || isDef(this._productions[START_SYMBOL][0]));\r\n        }\r\n    }\r\n\r\n\r\n    private generateFunctionByStateMap(): void {\r\n        const stateList = this._states;\r\n        const funcInfoList = this._additionalFuncInfoList;\r\n        const funcByStateDMap = this._adidtionalFunctByStateDMap = <IRuleFunctionDMap>{};\r\n\r\n        for (let i = 0; i < funcInfoList.length; i++) {\r\n            const funcInfo = funcInfoList[i];\r\n            const rule = funcInfo.rule;\r\n            const pos = funcInfo.position;\r\n            const grammarSymbol = rule.right[pos - 1];\r\n\r\n            for (let j = 0; j < stateList.length; j++) {\r\n                if (stateList[j].hasRule(rule, pos)) {\r\n                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};\r\n                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateFirstState_LR0(): void {\r\n        const state = new State();\r\n        // START_SYMBOL should be always defined at the beginning of grammar\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n        const item = new Item(firstRule, 0);\r\n\r\n        this.pushBaseItem(item);\r\n        state.push(item);\r\n\r\n        this.closure_LR0(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private generateFirstState_LR(): void {\r\n        const state = new State();\r\n        const firstRule = this._productions[START_SYMBOL][0];\r\n\r\n        state.push(new Item(firstRule, 0, [END_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this.pushState(state);\r\n    }\r\n\r\n\r\n    private closure(state: State, type: EParserType) {\r\n        if (type === EParserType.k_LR0) {\r\n            this.closure_LR0(state);\r\n        } else {\r\n            this.closure_LR(state);\r\n        }\r\n    }\r\n\r\n\r\n    private closure_LR0(state: State) {\r\n        // NOTE: loop grows implicitly inside state.tryPush() function.\r\n        //       do not change this loop.\r\n        state.eachItem(item => {\r\n            const symbol = item.symbolName();\r\n            if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private closure_LR(state: State) {\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            state.eachItem(item => {\r\n                const symbol = item.symbolName();\r\n                if (symbol !== END_POSITION && !this.isTerminal(symbol)) {\r\n                    const nextSymbols = item.rule.right.slice(item.pos + 1);\r\n                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);\r\n\r\n                    this.rules(symbol).forEach(rule => {\r\n                        expectedTerminals.forEach(expectedTerminal => {\r\n                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private static nextState_LR0(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                nextState.push(new Item(item.rule, item.pos + 1));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private static nextState_LR(state: State, symbol: string): State {\r\n        const nextState = new State();\r\n\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === symbol) {\r\n                const expectedSymbols = Array.from(item.expectedSymbols);\r\n                nextState.push(new Item(item.rule, item.pos + 1, expectedSymbols));\r\n            }\r\n        });\r\n\r\n        return nextState;\r\n    }\r\n\r\n\r\n    private deleteNotBaseItems(): void {\r\n        this._states.forEach(state => state.deleteNotBase());\r\n    }\r\n\r\n\r\n    private closureForItem({ rule, pos }: Item): State {\r\n        const indexVal = rule.index + \"_\" + pos;\r\n\r\n        let state = this._closureForItemsCache[indexVal];\r\n        if (isDef(state)) {\r\n            return state;\r\n        }\r\n\r\n        state = new State();\r\n        state.push(new Item(rule, pos, [UNUSED_SYMBOL]));\r\n\r\n        this.closure_LR(state);\r\n        this._closureForItemsCache[indexVal] = state;\r\n\r\n        return state;\r\n    }\r\n\r\n\r\n    private addLinkExpected(item: Item, itemX: Item): void {\r\n        let table = this._expectedExtensionDMap;\r\n        let index = item.index;\r\n\r\n        table[index] = table[index] || {};\r\n        table[index][itemX.index] = true;\r\n    }\r\n\r\n\r\n    private determineExpected(testState: State, symbol: string): void {\r\n        const stateNext = testState.nextStates[symbol] || null;\r\n\r\n        if (isNull(stateNext)) {\r\n            return;\r\n        }\r\n\r\n        // at this moment all items already 'base' because of\r\n        // deleteNotBase() call before.\r\n        testState.eachBaseItem(baseItem => {\r\n            const state = this.closureForItem(baseItem);\r\n            stateNext.eachBaseItem(baseItemNext => {\r\n                const item = state.hasChildItem(baseItemNext);\r\n                if (item) {\r\n                    item.expectedSymbols.forEach(symbol => {\r\n                        if (symbol === UNUSED_SYMBOL) {\r\n                            this.addLinkExpected(baseItem, baseItemNext);\r\n                        } else {\r\n                            baseItemNext.addExpected(symbol);\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    private generateLinksExpected(): void {\r\n        const states = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        states.forEach(state =>\r\n            symbols.forEach(symbol =>\r\n                this.determineExpected(state, symbol)));\r\n    }\r\n\r\n\r\n    private expandExpected(): void {\r\n        const baseItems = this._baseItems;\r\n        const itemExpected = baseItems.map(item => true);\r\n        const table = this._expectedExtensionDMap;\r\n\r\n        baseItems[0].addExpected(END_SYMBOL);\r\n        itemExpected[0] = (true);\r\n\r\n        let isNewExpected: boolean;\r\n        do {\r\n            isNewExpected = false;\r\n            baseItems.forEach((baseItem) => {\r\n                if (itemExpected[baseItem.index] && isDefAndNotNull(table[baseItem.index])) {\r\n                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));\r\n\r\n                    baseItem.expectedSymbols.forEach(expectedSymbol => {\r\n                        indexesOfExpectedItems.forEach(expectedIndex => {\r\n                            const baseItemExpected = baseItems[expectedIndex];\r\n                            if (baseItemExpected.addExpected(expectedSymbol)) {\r\n                                itemExpected[expectedIndex] = true;\r\n                                isNewExpected = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                itemExpected[baseItem.index] = false;\r\n            });\r\n        } while (isNewExpected);\r\n    }\r\n\r\n\r\n    private generateStates(type: EParserType): void {\r\n        if (type === EParserType.k_LR0) {\r\n            this.generateStates_LR0();\r\n        }\r\n        else if (type === EParserType.k_LR1) {\r\n            this.generateStates_LR();\r\n        }\r\n        else if (type === EParserType.k_LALR) {\r\n            this.generateStates_LALR();\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR0(): void {\r\n        this.generateFirstState_LR0();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                const symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR0(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR0);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private generateStates_LR(): void {\r\n        this._firstTerminalsCache = {};\r\n        this.generateFirstState_LR();\r\n\r\n        const stateList = this._states;\r\n        const symbols = this.symbols();\r\n\r\n        // NOTE: do not change this loop!\r\n        for (let i = 0; i < stateList.length; i++) {\r\n            const state = stateList[i];\r\n            for (let j = 0; j < symbols.length; j++) {\r\n                let symbol = symbols[j];\r\n                let stateNext = AbstractParser.nextState_LR(state, symbol);\r\n\r\n                if (!stateNext.isEmpty()) {\r\n                    stateNext = this.tryAddState(stateNext, EParserType.k_LR1);\r\n                    this.addStateLink(state, stateNext, symbol);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private generateStates_LALR(): void {\r\n        this._baseItems = [];\r\n        this._expectedExtensionDMap = {};\r\n        this._closureForItemsCache = {};\r\n        this._firstTerminalsCache = {};\r\n\r\n        this.generateStates_LR0();\r\n        this.deleteNotBaseItems();\r\n        this.generateLinksExpected();\r\n        this.expandExpected();\r\n\r\n        this._states.forEach(state => this.closure_LR(state));\r\n    }\r\n\r\n\r\n    private addReducing(syntaxTable: ISyntaxTable, state: State, reduceOperationsMap: IOperationMap): void {\r\n        state.eachItem(item => {\r\n            if (item.symbolName() === END_POSITION) {\r\n                if (item.rule.left === START_SYMBOL) {\r\n                    this.pushInSyntaxTable(syntaxTable, state.index, END_SYMBOL, { type: EOperationType.k_Success });\r\n                } else {\r\n                    for (const expectedSymbol of item.expectedSymbols) {\r\n                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    private addShift(syntaxTable: ISyntaxTable, state: State, shiftOperationsMap: IOperationMap) {\r\n        const nextStates = state.nextStates;\r\n        const nextSymbols = Object.keys(nextStates);\r\n        for (let i = 0; i < nextSymbols.length; i++) {\r\n            const nextState = nextStates[nextSymbols[i]];\r\n            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);\r\n        }\r\n    }\r\n\r\n    private buildSyntaxTable(type: EParserType): void {\r\n        this._states = [];\r\n        this._syntaxTable = {};\r\n\r\n        const stateList = this._states;\r\n        const syntaxTable = this._syntaxTable;\r\n\r\n        this.generateStates(type);\r\n\r\n        const reduceOperationsMap: IOperationMap = {};\r\n        const shiftOperationsMap: IOperationMap = {};\r\n\r\n        stateList.forEach(state => {\r\n            shiftOperationsMap[state.index] = <IOperation>{\r\n                type: EOperationType.k_Shift,\r\n                stateIndex: state.index\r\n            };\r\n        })\r\n\r\n        const nonTerminals = this.nonTerminals();\r\n        nonTerminals.forEach(nonTerminal => {\r\n            this.rules(nonTerminal).forEach(rule => {\r\n                reduceOperationsMap[rule.index] = {\r\n                    type: EOperationType.k_Reduce,\r\n                    rule: rule\r\n                };\r\n            });\r\n        });\r\n\r\n        //Build syntax table\r\n        stateList.forEach(state => {\r\n            this.addReducing(syntaxTable, state, reduceOperationsMap);\r\n            this.addShift(syntaxTable, state, shiftOperationsMap);\r\n        });\r\n    }\r\n\r\n\r\n    private statesToString(isBaseOnly: boolean = true): string {\r\n        if (!this._states) {\r\n            return \"\";\r\n        }\r\n\r\n        let msg = \"\";\r\n        for (let i = 0; i < this._states.length; i++) {\r\n            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);\r\n            msg += \" \";\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    private static operationToString(operation: IOperation): string {\r\n        let opVal: string = \"\";\r\n\r\n        switch (operation.type) {\r\n            case EOperationType.k_Shift:\r\n                opVal = \"SHIFT to state \" + operation.stateIndex.toString();\r\n                break;\r\n            case EOperationType.k_Reduce:\r\n                opVal = \"REDUCE by rule { \" + AbstractParser.ruleToString(operation.rule) + \" }\";\r\n                break;\r\n            case EOperationType.k_Success:\r\n                opVal = \"SUCCESS\";\r\n                break;\r\n        }\r\n\r\n        return opVal;\r\n    }\r\n\r\n\r\n    private static ruleToString(rule: IRule): string {\r\n        let ruleVal: string;\r\n\r\n        ruleVal = rule.left + \" : \" + rule.right.join(\" \");\r\n\r\n        return ruleVal;\r\n    }\r\n\r\n\r\n    private convertGrammarSymbol(symbol: string): string {\r\n        if (!this.isTerminal(symbol)) {\r\n            return symbol;\r\n        }\r\n        return this.lexerEngine.getTerminalValueByName(symbol);\r\n    }\r\n\r\n\r\n\r\n    private static $parserEngine: IParser = null;\r\n    private static $parserParams: IParserParams = null;\r\n\r\n    // /**\r\n    //  * Create a singleton instance of parser for internal use.\r\n    //  */\r\n    // static init(\r\n    //     parserParams: IParserParams, \r\n    //     ParserEngineConstructor: new (grammar, flags, type) => IParserEngine = null\r\n    //     ): IParserEngine {\r\n    //     const { grammar, flags, type } = parserParams;\r\n\r\n    //     if (!grammar) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (deepEqual(parserParams, ParserEngine.$parserParams)) {\r\n    //         return ParserEngine.$parserEngine;\r\n    //     }\r\n\r\n    //     if (isNull(ParserEngineConstructor)) {\r\n    //         ParserEngineConstructor = ParserEngine;\r\n    //     }\r\n\r\n    //     console.time();\r\n    //     console.log('%c Creating parser engine....', 'background: #222; color: #bada55');\r\n    //     ParserEngine.$parserParams = parserParams;\r\n\r\n    //     try {\r\n    //         ParserEngine.$parserEngine = new ParserEngineConstructor(grammar, flags, type);\r\n    //         console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n    //     } catch (e) {\r\n    //         ParserEngine.$parserEngine = null;\r\n    //         console.error('%c [ FAILED ]', 'background: #ffdcd6; color: #ff0000');\r\n\r\n    //         if (e instanceof DiagnosticException) {\r\n    //             verbose(e.stack);\r\n    //         }\r\n    //         throw e;\r\n    //     }\r\n\r\n    //     console.timeEnd();\r\n\r\n    //     return ParserEngine.$parserEngine;\r\n    // }\r\n\r\n\r\n    // static async parse(source: string, uri = \"stdin\", flags = EParsingFlags.k_Optimize) {\r\n\r\n    //     const engine = ParserEngine.$parserEngine;\r\n\r\n    //     const timeLabel = `parse ${uri}`;\r\n    //     console.time(timeLabel);\r\n    //     // All diagnostic exceptions should be already handled inside parser.\r\n    //     const parser = new ParserEngine.$parserEngine.parse(source, filename, flags)\r\n    //     let result = await ;\r\n    //     console.timeEnd(timeLabel);\r\n\r\n    //     let diag = ParserEngine.$parserEngine.getDiagnostics();\r\n    //     let ast = ParserEngine.$parserEngine.getSyntaxTree();\r\n\r\n    //     return { result, diag, ast };\r\n    // }\r\n}\r\n\r\n","import { EInstructionTypes, IProvideInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IProvideInstructionSettings extends IInstructionSettings {\r\n    moduleName: string;\r\n}\r\n\r\nexport class ProvideInstruction extends Instruction implements IProvideInstruction {\r\n    protected _value: string;\r\n\r\n    constructor({ moduleName, ...settings }: IProvideInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Provide, ...settings });\r\n        \r\n        this._value = moduleName;\r\n    }\r\n\r\n    get moduleName(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { instruction, type } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport class ProxyTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _host: ITypeInstruction;\r\n\r\n    constructor(settings: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ProxyType, ...settings });\r\n        this._host = null;\r\n    }\r\n\r\n    get host(): ITypeInstruction {\r\n        return this._host;\r\n    }\r\n    \r\n    get writable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return this.isResolved() ? this.host.writable : true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this.isResolved() ? this.host.name : 'auto';\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.isResolved() ? this.host.size : instruction.UNDEFINE_SIZE;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.host;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return this.isResolved() ? this.host.arrayElementType : null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return this.isResolved() ? this.host.length : instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n    \r\n    get fieldNames(): string[] {\r\n        return this.isResolved() ? this.host.fieldNames : [];\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.isResolved() ? this.host.fields : [];\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isResolved(): boolean {\r\n        return !isNull(this.host);\r\n    }\r\n\r\n\r\n    resolve(host: ITypeInstruction) {\r\n        this._host = host;\r\n    }\r\n\r\n    isSampler(): boolean {\r\n        return this.isResolved() ? this.host.isSampler() : false;\r\n    }\r\n\r\n    isTexture(): boolean {\r\n        return this.isResolved() ? this.host.isTexture() : false;\r\n    }\r\n\r\n    isUAV(): boolean {\r\n        return this.isResolved() ? this.host.isUAV() : false;\r\n    }\r\n    \r\n    toString(): string {\r\n        return this.isResolved() ? this.host.toString() : this.name;\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.isResolved() ? this.host.toDeclString() : null;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.isResolved() ? this.host.toCode() : this.name;\r\n    }\r\n\r\n    \r\n    isBase(): boolean {\r\n        return this.isResolved() ? this.host.isBase() : false;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return this.isResolved() ? this.host.isArray() : false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return this.isResolved() ? this.host.isNotBaseArray() : false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return this.isResolved() ? this.host.isComplex() : false;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.isResolved() ? this.host.isConst() : false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this.isResolved() ? this.host.isContainArray() : false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this.isResolved() ? this.host.isContainSampler() : false;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this.isResolved() ? this.host.isContainComplexType() : false;\r\n    }\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return this.isResolved() ? this.host.hasField(fieldName) : false;\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getField(fieldName) : null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.isResolved() ? this.host.getMethod(methodName, args) : null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;\r\n    }\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { SCOPE, T_STRING } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IStringInstructionSettings extends IInstructionSettings {\r\n    value: string;\r\n}\r\n\r\n\r\nexport class StringInstruction extends ExprInstruction implements ILiteralInstruction<string> {\r\n    protected _value: string;\r\n\r\n\t/**\r\n\t * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n\t */\r\n    constructor({ value, scope, ...settings }: IStringInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StringExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: VariableTypeInstruction.wrapAsConst(T_STRING, SCOPE), scope, ...settings });\r\n        \r\n        this._value = value;\r\n    }\r\n\r\n    \r\n    get value(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._value;\r\n    }\r\n\r\n\r\n    evaluate(): boolean {\r\n        this._evalResult = this._value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IAttributeInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdInstruction, IStmtBlockInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IFunctionDeclInstructionSettings extends IDeclInstructionSettings {\r\n    definition: IFunctionDefInstruction;\r\n    implementation?: IStmtBlockInstruction;\r\n    attributes?: IAttributeInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]\r\n * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction\r\n */\r\nexport class FunctionDeclInstruction extends DeclInstruction implements IFunctionDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n    \r\n\r\n    constructor({ definition, implementation = null, attributes = null, ...settings }: IFunctionDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDecl, ...settings });\r\n\r\n        this.def = Instruction.$withParent(definition, this);\r\n        this.impl = Instruction.$withParent(implementation, this);\r\n        this.attributes = (attributes || []).map(attr => Instruction.$withParent(attr, this));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.def.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this.def.id;\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this.def.semantic;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code = '';\r\n        code += this.def.toCode();\r\n        if (this.impl) {\r\n            code += this.impl.toCode();\r\n        } else {\r\n            code += ';';\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { EInstructionTypes, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IIdInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n}\r\n\r\nexport class IdInstruction extends Instruction implements IIdInstruction {\r\n    readonly name: string;\r\n\r\n    constructor({ name, ...settings }: IIdInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Id, ...settings });\r\n        this.name = name;\r\n    }\r\n    \r\n    \r\n    toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IPostfixArithmeticInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type PostfixOperator = \"++\" | \"--\";\r\n\r\nexport interface IPostfixArithmeticInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: PostfixOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr ++\r\n * (-- | ++) Instruction\r\n */\r\nexport class PostfixArithmeticInstruction extends ExprInstruction implements IPostfixArithmeticInstruction {\r\n    protected _operator: PostfixOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    \r\n    constructor({ expr, operator, ...settings }: IPostfixArithmeticInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });\r\n\r\n        this._operator = operator;\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n\r\n        code += this.expr.toCode();\r\n        code += this.operator;\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n}\r\n\r\n","import { ICompileExprInstruction, IFunctionDeclInstruction, IPassInstruction, IStructDeclInstruction, ITechniqueInstruction, ITypeInstruction, IStmtInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// import { EPartFxInstructionTypes } from \"./IPartFxInstruction\";\r\n\r\nexport enum EPartFxPassGeometry {\r\n    k_Billboard,\r\n    k_Cylinder,\r\n    k_Box,\r\n    k_Sphere,\r\n    k_Line\r\n}\r\n\r\nexport interface IPartFxPassInstruction extends IPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly particleInstance: ITypeInstruction;\r\n    readonly geometry: EPartFxPassGeometry;\r\n    readonly instanceCount: number;\r\n\r\n    /** check if the pass is ready for runtime */\r\n    isValid(): boolean;\r\n}\r\n\r\n\r\n export interface IPartFxInstruction extends ITechniqueInstruction {\r\n\r\n    readonly spawnRoutine: ICompileExprInstruction;\r\n    readonly initRoutine: ICompileExprInstruction;\r\n    readonly updateRoutine: ICompileExprInstruction;\r\n\r\n    readonly particle: ITypeInstruction;\r\n    readonly capacity: number;\r\n\r\n    readonly passList: IPartFxPassInstruction[];\r\n\r\n    /** check if the technique is ready for runtime */\r\n    isValid(): boolean;\r\n }\r\n\r\n\r\n export interface ISpawnStmtInstruction extends IStmtInstruction {\r\n    readonly name: string;\r\n    readonly count: number;\r\n    readonly args: IExprInstruction[];\r\n    \r\n    // resolved properties\r\n    readonly fx: IPartFxInstruction;\r\n    readonly init: IFunctionDeclInstruction;\r\n }","import { EInstructionTypes, IArithmeticExprInstruction, IAssignmentExprInstruction, ICastExprInstruction, ICompileExprInstruction, IComplexExprInstruction, IConditionalExprInstruction, IConstructorCallInstruction, IDeclStmtInstruction, IExprStmtInstruction, IForStmtInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIfStmtInstruction, IInitExprInstruction, IInstruction, ILogicalExprInstruction, IPostfixArithmeticInstruction, IPostfixIndexInstruction, IPostfixPointInstruction, IRelationalExprInstruction, IReturnStmtInstruction, ISamplerStateBlockInstruction, IStmtBlockInstruction, ITypeInstruction, IUnaryExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IWhileStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\n// TODO: move it to helpers\r\nexport function visitor(owner: IInstruction, cb: (instr: IInstruction, owner?: IInstruction) => void) {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n\r\n    const visit = (instr: IInstruction) => { \r\n        if (instr) {\r\n            cb(instr, owner); \r\n            visitor(instr, cb) \r\n        }\r\n    };\r\n\r\n    switch (owner.instructionType) {\r\n\r\n        //\r\n        // Stmt\r\n        //\r\n\r\n        case EInstructionTypes.k_ReturnStmt:\r\n            visit((owner as IReturnStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_DeclStmt:\r\n            (owner as IDeclStmtInstruction).declList.forEach(decl => visit(decl));\r\n            break;\r\n        case EInstructionTypes.k_ExprStmt:\r\n            visit((owner as IExprStmtInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_IfStmt:\r\n            visit((owner as IIfStmtInstruction).cond);\r\n            visit((owner as IIfStmtInstruction).conseq);\r\n            visit((owner as IIfStmtInstruction).contrary);\r\n            break;\r\n        case EInstructionTypes.k_StmtBlock:\r\n            (owner as IStmtBlockInstruction).stmtList.forEach(stmt => visit(stmt));\r\n            break;\r\n        case EInstructionTypes.k_ForStmt:\r\n            visit((owner as IForStmtInstruction).init);\r\n            visit((owner as IForStmtInstruction).cond);\r\n            visit((owner as IForStmtInstruction).body);\r\n            visit((owner as IForStmtInstruction).step);\r\n            break;\r\n        case EInstructionTypes.k_WhileStmt:\r\n            visit((owner as IWhileStmtInstruction).cond);\r\n            visit((owner as IWhileStmtInstruction).body);\r\n            break;\r\n\r\n        //\r\n        // Expr\r\n        //\r\n\r\n        case EInstructionTypes.k_ArithmeticExpr:\r\n            visit((owner as IArithmeticExprInstruction).left);\r\n            visit((owner as IArithmeticExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_AssignmentExpr:\r\n            visit((owner as IAssignmentExprInstruction).left);\r\n            visit((owner as IAssignmentExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_CastExpr:\r\n            visit((owner as ICastExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_CompileExpr:\r\n            (owner as ICompileExprInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as ICompileExprInstruction).function);\r\n            break;\r\n        case EInstructionTypes.k_ComplexExpr:\r\n            visit((owner as IComplexExprInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_ConditionalExpr:\r\n            visit((owner as IConditionalExprInstruction).left);\r\n            visit((owner as IConditionalExprInstruction).right);\r\n            visit((owner as IConditionalExprInstruction).condition);\r\n            break;\r\n        case EInstructionTypes.k_ConstructorCallExpr:\r\n            (owner as IConstructorCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IConstructorCallInstruction).ctor);\r\n            break;\r\n        case EInstructionTypes.k_FunctionCallExpr:\r\n            (owner as IFunctionCallInstruction).args.forEach(arg => visit(arg));\r\n            // visit((owner as IFunctionCallInstruction).decl);\r\n            break;\r\n        case EInstructionTypes.k_IdExpr:\r\n            visit((owner as IIdExprInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_InitExpr:\r\n            (owner as IInitExprInstruction).args.forEach(arg => visit(arg));\r\n            break;\r\n        case EInstructionTypes.k_IntExpr:\r\n        case EInstructionTypes.k_FloatExpr:\r\n        case EInstructionTypes.k_BoolExpr:\r\n        case EInstructionTypes.k_StringExpr:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_LogicalExpr:\r\n            visit((owner as ILogicalExprInstruction).left);\r\n            visit((owner as ILogicalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            visit((owner as IPostfixArithmeticInstruction).expr);\r\n            break;\r\n        case EInstructionTypes.k_PostfixIndexExpr:\r\n            visit((owner as IPostfixIndexInstruction).element);\r\n            visit((owner as IPostfixIndexInstruction).index);\r\n            break;\r\n        case EInstructionTypes.k_PostfixPointExpr:\r\n            visit((owner as IPostfixPointInstruction).element);\r\n            visit((owner as IPostfixPointInstruction).postfix);\r\n            break;\r\n        case EInstructionTypes.k_RelationalExpr:\r\n            visit((owner as IRelationalExprInstruction).left);\r\n            visit((owner as IRelationalExprInstruction).right);\r\n            break;\r\n        case EInstructionTypes.k_SamplerStateBlockExpr:\r\n            (owner as ISamplerStateBlockInstruction).params.forEach(param => visit(param));\r\n            visit((owner as ISamplerStateBlockInstruction).texture);\r\n            break;\r\n        case EInstructionTypes.k_UnaryExpr:\r\n            visit((owner as IUnaryExprInstruction).expr);\r\n            break;\r\n\r\n        //\r\n        // Others\r\n        //\r\n        case EInstructionTypes.k_ComplexType:\r\n            (owner as ITypeInstruction).fields.forEach(field => visit(field));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDef:\r\n            visit((owner as IFunctionDefInstruction).returnType);\r\n            visit((owner as IFunctionDefInstruction).id);\r\n            (owner as IFunctionDefInstruction).params.forEach(param => visit(param));\r\n            break;\r\n        case EInstructionTypes.k_FunctionDecl:\r\n            visit((owner as IFunctionDeclInstruction).def);\r\n            visit((owner as IFunctionDeclInstruction).impl);\r\n            break;\r\n        case EInstructionTypes.k_VariableDecl:\r\n            visit((owner as IVariableDeclInstruction).type);\r\n            visit((owner as IVariableDeclInstruction).initExpr);\r\n            visit((owner as IVariableDeclInstruction).id);\r\n            break;\r\n        case EInstructionTypes.k_VariableType:\r\n            visit((owner as IVariableTypeInstruction).subType);\r\n            break;\r\n        case EInstructionTypes.k_Id:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_SystemFunctionDecl:\r\n        case EInstructionTypes.k_SystemType:\r\n            // nothing todo\r\n            break;\r\n        case EInstructionTypes.k_BreakStmt:\r\n            break;\r\n\r\n        default:\r\n            console.error('unsupported instruction type found');\r\n    }\r\n}\r\n\r\nexport const Visitor = {\r\n    each: visitor\r\n};\r\n\r\n","import { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\n\r\nexport enum EInstructionTypes {\r\n    k_Instruction = 0,\r\n    \r\n    k_Id,\r\n    k_Provide,\r\n    k_Collector,\r\n    k_Keyword,      // FIXME: useless type\r\n    k_Simple,       // FIXME: useless type\r\n    k_SamplerState,\r\n    k_Attribute,\r\n    k_Annotation,   // FIXME: instruction is not fully implemented\r\n    k_UsageType,    // FIXME: instruction is not implemented\r\n    \r\n    k_Typed,        // NOTE: Abstract type\r\n    k_VariableType,\r\n    k_SystemType,\r\n    k_ComplexType,\r\n    k_ProxyType,\r\n    \r\n    k_Expr,         // NOTE: Abstract type\r\n    k_IdExpr,\r\n    k_IntExpr,\r\n    k_FloatExpr,\r\n    k_BoolExpr,\r\n    k_StringExpr,\r\n    k_ArithmeticExpr,\r\n    k_AssignmentExpr,\r\n    k_RelationalExpr,\r\n    k_LogicalExpr,\r\n    k_ConditionalExpr,\r\n    k_CastExpr,\r\n    k_UnaryExpr,\r\n    k_PostfixIndexExpr,\r\n    k_PostfixPointExpr,\r\n    k_PostfixArithmeticExpr,\r\n    k_ComplexExpr,\r\n    k_FunctionCallExpr,\r\n    k_ConstructorCallExpr,\r\n    k_CompileExpr,\r\n    k_InitExpr,\r\n    k_SamplerStateBlockExpr,\r\n\r\n    k_Decl,\r\n    k_TypeDecl,\r\n    k_VariableDecl,\r\n    k_StructDecl,\r\n    k_FunctionDecl,\r\n    k_SystemFunctionDecl,\r\n    k_FunctionDef,\r\n    k_PassDecl,\r\n    k_TechniqueDecl,\r\n    \r\n    k_Stmt,\r\n    k_ExprStmt,\r\n    k_BreakStmt,\r\n    k_WhileStmt,\r\n    k_ForStmt,\r\n    k_IfStmt,\r\n    k_DeclStmt,\r\n    k_ReturnStmt,\r\n    k_SemicolonStmt,\r\n    k_StmtBlock,\r\n    \r\n    // part fx\r\n    k_PartFxDecl,\r\n    k_PartFxPass,\r\n    k_SpawnStmt\r\n}\r\n\r\n\r\nexport enum ECheckStage {\r\n    CODE_TARGET_SUPPORT, /* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */\r\n    SELF_CONTAINED /* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */\r\n    // VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ \r\n}\r\n\r\nexport enum EVarUsedMode {\r\n    k_Read,\r\n    k_Write,\r\n    k_ReadWrite,\r\n    k_Undefined,\r\n    k_Default = k_ReadWrite\r\n}\r\n\r\n\r\nexport interface IInstructionError {\r\n    code: number;\r\n    info: any;\r\n}\r\n\r\nexport interface ITypeUseInfoContainer {\r\n    type: IVariableTypeInstruction;\r\n    isRead: boolean;\r\n    isWrite: boolean;\r\n    numRead: number;\r\n    numWrite: number;\r\n    numUsed: number;\r\n}\r\n\r\nexport enum EExtractExprType {\r\n    k_Header,\r\n\r\n    k_Float,\r\n    k_Int,\r\n    k_Bool,\r\n\r\n    k_Float2,\r\n    k_Int2,\r\n    k_Bool2,\r\n\r\n    k_Float3,\r\n    k_Int3,\r\n    k_Bool3,\r\n\r\n    k_Float4,\r\n    k_Int4,\r\n    k_Bool4,\r\n\r\n    k_Float4x4\r\n}\r\n\r\n\r\nexport enum EScopeType {\r\n    k_System,\r\n    k_Global,\r\n    k_Default,\r\n    k_Struct,\r\n    k_Annotation\r\n}\r\n\r\n\r\nexport interface ITypeTemplate {\r\n    readonly scope: IScope;\r\n    readonly name: string;\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction;\r\n    typeName(args?: ITypeInstruction[]): string;\r\n}\r\n\r\n\r\nexport interface IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n    \r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n\r\n    /** Recursive check for all parents for strict mode */\r\n    isStrict(): boolean;\r\n\r\n    findVariable(variableName: string): IVariableDeclInstruction;\r\n    findType(typeName: string): ITypeInstruction;\r\n    findTypeTemplate(typeName: string): ITypeTemplate;\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction | null | undefined;\r\n    findTechnique(techName: string): ITechniqueInstruction | null;\r\n\r\n    /** @deprecated */\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction;\r\n\r\n    addVariable(variable: IVariableDeclInstruction): boolean;\r\n    addType(type: ITypeInstruction): boolean;\r\n    addTypeTemplate(template: ITypeTemplate): boolean;\r\n    addFunction(func: IFunctionDeclInstruction): boolean;\r\n    addTechnique(technique: ITechniqueInstruction): boolean;\r\n}\r\n\r\n\r\n/**\r\n * All opertion are represented by: \r\n * operator : arg1 ... argn\r\n * Operator and instructions may be empty.\r\n */\r\nexport interface IInstruction {\r\n    readonly parent: IInstruction;\r\n    readonly scope: IScope;\r\n\r\n    readonly sourceNode: IParseNode | null;\r\n    readonly instructionType: EInstructionTypes;\r\n    readonly instructionID: number;\r\n    readonly instructionName: string;\r\n\r\n    toString(): string;\r\n    toCode(): string;\r\n\r\n    /** Internal API */\r\n    $withParent<T extends IInstruction>(parent: IInstruction): T;\r\n    $withNoParent<T extends IInstruction>(): T;\r\n\r\n    /** @deprecated */\r\n    _check(eStage: ECheckStage): boolean;\r\n    /** @deprecated */\r\n    _getLastError(): IInstructionError;\r\n    /** @deprecated */\r\n    _setError(eCode: number, pInfo?: any): void;\r\n    /** @deprecated */\r\n    _clearError(): void;\r\n    /** @deprecated */\r\n    _isErrorOccured(): boolean;\r\n}\r\n\r\n\r\nexport interface IInstructionCollector extends IInstruction {\r\n    readonly instructions: IInstruction[];\r\n}\r\n\r\n\r\nexport interface ISimpleInstruction extends IInstruction {\r\n    readonly value: string;\r\n}\r\n\r\n\r\nexport interface IProvideInstruction extends IInstruction {\r\n    readonly moduleName: string;\r\n}\r\n\r\n\r\n\r\nexport interface ITypeInstruction extends IInstruction {\r\n    readonly size: number;\r\n    readonly name: string;\r\n    readonly baseType: ITypeInstruction;\r\n    readonly length: number;\r\n    readonly arrayElementType: ITypeInstruction;\r\n\r\n    readonly writable: boolean;\r\n    readonly readable: boolean;\r\n\r\n    readonly fieldNames: string[];\r\n    readonly fields: IVariableDeclInstruction[];\r\n    readonly methods: IFunctionDeclInstruction[];\r\n\r\n    /** \r\n     * @deprecated\r\n     * Use type.equals() instead.\r\n     */\r\n    isEqual(type: ITypeInstruction): boolean;\r\n\r\n    isBase(): boolean;\r\n    isArray(): boolean;\r\n    // Returns true is type is user defined array.\r\n    // an user defined array like: float f[4]\r\n    // not: float4 \r\n    isNotBaseArray(): boolean;\r\n    isComplex(): boolean;\r\n    isConst(): boolean;\r\n\r\n    /** @deprecated */\r\n    isContainArray(): boolean;\r\n    /** @deprecated */\r\n    isContainSampler(): boolean;\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean;\r\n\r\n    hasField(fieldName: string): boolean;\r\n    hasFieldWithSematics(semantic: string);\r\n    hasAllUniqueSemantics(): boolean;\r\n    hasFieldWithoutSemantics(): boolean;\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction;\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction;\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    getMethod(methodName: string, args?: Array<ITypeInstruction | RegExp>): IFunctionDeclInstruction;\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string;\r\n\r\n\r\n    isUAV(): boolean;\r\n    isSampler(): boolean;\r\n    isTexture(): boolean;\r\n}\r\n\r\n\r\nexport type IVariableUsage = 'uniform' | 'const' | 'in' | 'out' | 'inout';\r\n\r\nexport interface IVariableTypeInstruction extends ITypeInstruction {\r\n    readonly usages: IVariableUsage[];\r\n    readonly subType: ITypeInstruction;\r\n    readonly padding: number;\r\n\r\n    isUniform(): boolean;\r\n\r\n    hasUsage(usageName: IVariableUsage): boolean;\r\n\r\n    // for structures internal usage\r\n    $overwritePadding(val: number): void;\r\n}\r\n\r\n\r\nexport interface ITypedInstruction extends IInstruction {\r\n    readonly type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport interface IConditionalExprInstruction extends IExprInstruction {\r\n    readonly condition: IExprInstruction;\r\n    readonly left: ITypedInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IDeclInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly semantic: string;\r\n    readonly annotation: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionDefInstruction extends IDeclInstruction {\r\n    readonly returnType: IVariableTypeInstruction;\r\n    readonly name: string;\r\n    readonly params: IVariableDeclInstruction[];\r\n}\r\n\r\n\r\nexport interface ITypeDeclInstruction extends IDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface ISamplerStateInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly value: IInstruction;\r\n}\r\n\r\n\r\nexport interface IVariableDeclInstruction extends IDeclInstruction, ITypedInstruction {\r\n    readonly id: IIdInstruction;\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly initExpr: IInitExprInstruction;\r\n\r\n    readonly defaultValue: any;\r\n\r\n    isParameter(): boolean;\r\n    isLocal(): boolean;\r\n    isGlobal(): boolean;\r\n    isField(): boolean;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclInstruction extends IDeclInstruction {\r\n    readonly def: IFunctionDefInstruction;\r\n    readonly impl: IStmtBlockInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStructDeclInstruction extends IInstruction {\r\n\r\n}\r\n\r\n\r\nexport interface IIdInstruction extends IInstruction {\r\n    readonly name: string;\r\n}\r\n\r\n\r\nexport interface IKeywordInstruction extends IInstruction {\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface IExprInstruction extends ITypedInstruction {\r\n    readonly type: IVariableTypeInstruction;\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean;\r\n    /** @deprecated */\r\n    getEvalValue(): any;\r\n\r\n    isConst(): boolean;\r\n    isConstExpr(): boolean;\r\n}\r\n\r\nexport type ILogicalOperator = \"&&\" | \"||\";\r\n\r\nexport interface ILogicalExprInstruction extends IExprInstruction {\r\n    operator: ILogicalOperator;\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n}\r\n\r\nexport type IUnaryOperator = \"+\" | \"-\" | \"!\" | \"++\" | \"--\";\r\n\r\nexport interface IUnaryExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: IUnaryOperator;\r\n}\r\n\r\nexport interface IPostfixPointInstruction extends IExprInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixIndexInstruction extends IExprInstruction {\r\n    readonly index: IExprInstruction;\r\n    readonly element: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IConstructorCallInstruction extends IExprInstruction {\r\n    readonly args: IInstruction[];\r\n    readonly ctor: IVariableTypeInstruction;\r\n}\r\n\r\nexport interface IArithmeticExprInstruction extends IExprInstruction {\r\n    readonly right: IExprInstruction;\r\n    readonly left: IExprInstruction;\r\n    readonly operator: '+' | '-' | '/' | '*' | '%';\r\n}\r\n\r\nexport interface ICastExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n\r\n    isUseless(): boolean;\r\n}\r\n\r\n\r\nexport interface IComplexExprInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\n\r\nexport interface IPostfixArithmeticInstruction extends IExprInstruction {\r\n    readonly expr: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\n\r\nexport interface ISamplerStateBlockInstruction extends IExprInstruction {\r\n    readonly texture: IVariableDeclInstruction;\r\n    readonly params: ISamplerStateInstruction[];\r\n    readonly operator: string;\r\n}\r\n\r\n\r\nexport interface ICompileExprInstruction extends IExprInstruction {\r\n    readonly function: IFunctionDeclInstruction;\r\n    readonly args: IExprInstruction[];\r\n}\r\n\r\n\r\nexport interface IRelationalExprInstruction extends IExprInstruction {\r\n    readonly left: IExprInstruction;\r\n    readonly right: IExprInstruction;\r\n    readonly operator: string;\r\n}\r\n\r\nexport interface IAssignmentExprInstruction extends IExprInstruction {\r\n    readonly operator: string;\r\n    readonly left: IExprInstruction;\r\n    readonly right: ITypedInstruction;\r\n}\r\n\r\n\r\nexport interface IInitExprInstruction extends IExprInstruction {\r\n    readonly args: IExprInstruction[];\r\n\r\n    isArray(): boolean;\r\n    isConst(): boolean;\r\n\r\n    // todo: refactor this!!\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean;\r\n}\r\n\r\n\r\nexport interface IIdExprInstruction extends IExprInstruction {\r\n    readonly name: string;\r\n    readonly id: IIdInstruction;\r\n\r\n    /** @helpers */\r\n    readonly type: IVariableTypeInstruction;\r\n    readonly decl: IVariableDeclInstruction;\r\n}\r\n\r\n\r\nexport interface IFunctionCallInstruction extends IExprInstruction {\r\n    readonly callee: IExprInstruction;\r\n    readonly args: IExprInstruction[];\r\n\r\n    // move it to method?\r\n    readonly decl: IFunctionDeclInstruction;   \r\n}\r\n\r\n\r\nexport interface ILiteralInstruction<T = number | boolean | string> extends IExprInstruction {\r\n    readonly value: T;\r\n}\r\n\r\n\r\nexport type IExprDerived =\r\n    | IArithmeticExprInstruction\r\n    | IAssignmentExprInstruction\r\n    | ICastExprInstruction\r\n    | ICompileExprInstruction\r\n    | IComplexExprInstruction\r\n    | IConditionalExprInstruction\r\n    | IConstructorCallInstruction\r\n    | IFunctionCallInstruction\r\n    | IIdExprInstruction\r\n    | IInitExprInstruction\r\n    | ILiteralInstruction<number>\r\n    | ILiteralInstruction<boolean>\r\n    | ILiteralInstruction<string>\r\n    | ILogicalExprInstruction\r\n    | IPostfixArithmeticInstruction\r\n    | IPostfixIndexInstruction\r\n    | IPostfixPointInstruction\r\n    | IRelationalExprInstruction\r\n    | ISamplerStateBlockInstruction\r\n    | IUnaryExprInstruction;\r\n\r\nexport interface IAnnotationInstruction extends IInstruction {\r\n}\r\n\r\n\r\nexport interface IStmtInstruction extends IInstruction {\r\n}\r\n\r\nexport interface IAttributeInstruction extends IInstruction {\r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n}\r\n\r\nexport interface IForStmtInstruction extends IStmtInstruction {\r\n    readonly init: ITypedInstruction;\r\n    readonly cond: IExprInstruction;\r\n    readonly step: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n}\r\n\r\nexport type IDoWhileOperator = \"do\" | \"while\";\r\n\r\nexport interface IWhileStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly body: IStmtInstruction;\r\n    readonly operator: IDoWhileOperator;\r\n}\r\n\r\nexport interface IDeclStmtInstruction extends IStmtInstruction {\r\n    readonly declList: IDeclInstruction[];\r\n}\r\n\r\nexport type IReturnOperator = \"return\";\r\n\r\nexport interface IReturnStmtInstruction extends IStmtInstruction {\r\n    readonly operator: IReturnOperator;\r\n    readonly expr: IExprInstruction;\r\n}\r\n\r\nexport interface IIfStmtInstruction extends IStmtInstruction {\r\n    readonly cond: IExprInstruction;\r\n    readonly conseq: IStmtInstruction;\r\n    readonly contrary: IStmtInstruction;\r\n    readonly attributes: IAttributeInstruction[];\r\n}\r\n\r\n\r\nexport interface IStmtBlockInstruction extends IStmtInstruction {\r\n    readonly stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n\r\nexport interface IExprStmtInstruction extends IStmtInstruction {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n\r\nexport interface IPassInstruction extends IDeclInstruction {\r\n    readonly id: IIdInstruction;\r\n\r\n    readonly vertexShader: IFunctionDeclInstruction;\r\n    readonly pixelShader: IFunctionDeclInstruction;\r\n\r\n    readonly renderStates: IMap<ERenderStateValues>;\r\n    getState(type: ERenderStates): ERenderStateValues;\r\n}\r\n\r\n\r\nexport type IStmtDerived =\r\n    | IDeclStmtInstruction\r\n    | IReturnStmtInstruction\r\n    | IIfStmtInstruction\r\n    | IStmtBlockInstruction\r\n    | IExprStmtInstruction\r\n    | IWhileStmtInstruction\r\n    | IForStmtInstruction;\r\n\r\n\r\nexport enum ETechniqueType {\r\n    k_BasicFx,  // << basic Microsoft DirectX like effect\r\n    k_PartFx,\r\n    k_Unknown\r\n}\r\n\r\nexport interface ITechniqueInstruction extends IDeclInstruction {\r\n    readonly passList: IPassInstruction[];\r\n    readonly type: ETechniqueType;\r\n}\r\n\r\n\r\nexport interface IFunctionDeclListMap {\r\n    [functionName: string]: IFunctionDeclInstruction[];\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IConstructorCallInstruction, IExprInstruction, IInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConstructorCallInstructionSettings extends IInstructionSettings {\r\n    ctor: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Resresnt ctor(arg1,..., argn)\r\n * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction \r\n */\r\nexport class ConstructorCallInstruction extends ExprInstruction implements IConstructorCallInstruction {\r\n    protected _args: IInstruction[];\r\n    protected _ctor: IVariableTypeInstruction;\r\n    \r\n\r\n    constructor({ ctor, args = null, ...settings }: IConstructorCallInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });\r\n\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n        this._ctor = Instruction.$withParent(ctor, this);\r\n    }\r\n\r\n    \r\n    get args() : IInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n    \r\n    get ctor(): IVariableTypeInstruction {\r\n        return this._ctor;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n\r\n        code += this.ctor.toCode();\r\n        code += \"(\";\r\n\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        for (var i: number = 0; i < this.args.length; i++) {\r\n            if (!(<IExprInstruction>this.args[i]).isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        if (!this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        var res: any = null;\r\n        var jsTypeCtor: any = SystemScope.getExternalType(this.type);\r\n        var args: any[] = new Array(this.args.length);\r\n\r\n        if (isNull(jsTypeCtor)) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            if (SystemScope.isScalarType(this.type)) {\r\n                var pTestedInstruction: IExprInstruction = <IExprInstruction>this.args[0];\r\n                if (this.args.length > 1 || !pTestedInstruction.evaluate()) {\r\n                    return false;\r\n                }\r\n\r\n                res = jsTypeCtor(pTestedInstruction.getEvalValue());\r\n            }\r\n            else {\r\n                for (var i: number = 0; i < this.args.length; i++) {\r\n                    var pTestedInstruction: IExprInstruction = <IExprInstruction>this.args[i];\r\n\r\n                    if (pTestedInstruction.evaluate()) {\r\n                        args[i - 1] = pTestedInstruction.getEvalValue();\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                res = new jsTypeCtor;\r\n                res.set.apply(res, args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import { assert, isDef, isDefAndNotNull } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, ExpectedSymbols, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { State } from \"./State\";\r\nimport { END_POSITION, T_EMPTY } from \"./symbols\";\r\n\r\nexport class Item {\r\n    rule: IRule;\r\n    /**\r\n     * Position in item. \r\n     * left: right0,   right1, ...., rightN;\r\n     *               ^\r\n     *               position\r\n     */\r\n    pos: number;\r\n    /**\r\n     * Index in parser.\r\n     * (Uniq ID)\r\n     */\r\n    index: number;\r\n\r\n    expectedSymbols: ExpectedSymbols;\r\n\r\n    constructor(rule: IRule, pos: number, expectedSymbols?: string[]) {\r\n        this.rule = rule;\r\n        this.pos = pos;\r\n        this.index = 0;\r\n        this.expectedSymbols = new Set<string>();\r\n\r\n        if (expectedSymbols) {\r\n            expectedSymbols.forEach(symbol => this.addExpected(symbol));\r\n        }\r\n    }\r\n\r\n    isEqual(item: Item, type: EParserType = EParserType.k_LR0): boolean {\r\n        if (type === EParserType.k_LR0) {\r\n            return (this.rule === item.rule && this.pos === item.pos);\r\n        } \r\n        \r\n        if (type === EParserType.k_LR1) {\r\n            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {\r\n                return false;\r\n            }\r\n\r\n            for (const symbol of this.expectedSymbols) {\r\n                if (!item.isExpected(symbol)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } \r\n\r\n        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.\r\n        return false;\r\n    }\r\n\r\n    isParentItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos + 1);\r\n    }\r\n\r\n    isChildItem(item: Item): boolean {\r\n        return (this.rule === item.rule && this.pos === item.pos - 1);\r\n    }\r\n\r\n    symbolName(): string {\r\n        const right = this.rule.right;\r\n        if (this.pos === right.length) {\r\n            return END_POSITION;\r\n        }\r\n        return right[this.pos];\r\n    }\r\n\r\n    // lastSymbolName(): string {\r\n    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;\r\n    // }\r\n\r\n    // // get next symbol name\r\n    // nextSymbolName(): string {\r\n    //     return this.rule.right[this.pos + 1] || END_POSITION;\r\n    // }\r\n\r\n    isExpected(symbol: string): boolean {\r\n        return this.expectedSymbols.has(symbol);\r\n    }\r\n\r\n    addExpected(symbol: string): boolean {\r\n        if (this.isExpected(symbol)) {\r\n            return false;\r\n        }\r\n        this.expectedSymbols.add(symbol);\r\n        return true;\r\n    }\r\n\r\n    toString(grammarSymbols: Map<string, string> = null): string {\r\n        const { left, right } = this.rule;\r\n\r\n        let msg = `${left} -> `;\r\n\r\n        msg += right\r\n            .map(s => Item.decodeSymbol(s, grammarSymbols))\r\n            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))\r\n            .join(' ');\r\n\r\n        if (this.pos === right.length) {\r\n            msg += \" . \";\r\n        }\r\n\r\n        if (this.expectedSymbols) {\r\n            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));\r\n\r\n            if (expectedTokens.length) {\r\n                msg += \", \" + expectedTokens.join(' ');\r\n            }\r\n        }\r\n\r\n        return msg;\r\n    }\r\n\r\n\r\n    static decodeSymbol(s: string, grammarSymbols: Map<string, string>) {\r\n        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);\r\n    }\r\n}\r\n","import { T_BOOL, SCOPE } from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IUnaryExprInstruction, IUnaryOperator } from '@lib/idl/IInstruction';\r\n\r\nimport { ExprInstruction } from './ExprInstruction';\r\nimport { IInstructionSettings, Instruction } from './Instruction';\r\nimport { VariableTypeInstruction } from './VariableTypeInstruction';\r\n\r\nexport interface IUnaryExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n    operator: IUnaryOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent + - ! ++ -- expr\r\n * (+|-|!|++|--|) Instruction\r\n */\r\nexport class UnaryExprInstruction extends ExprInstruction implements IUnaryExprInstruction {\r\n    protected _operator: IUnaryOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, operator, ...settings }: IUnaryExprInstructionSettings) {\r\n        super({\r\n            instrType: EInstructionTypes.k_UnaryExpr,\r\n            // NOTE: type wraping is no really necessary, just for debug purposes\r\n            type: operator === '!'\r\n                ? VariableTypeInstruction.wrapAsConst(T_BOOL, SCOPE)\r\n                : expr.type,\r\n            ...settings\r\n        });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): IUnaryOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = '';\r\n        sCode += this.operator;\r\n        sCode += this.expr.toCode();\r\n\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n\r\n\r\n    evaluate(): boolean {\r\n        var op = this.operator;\r\n        var expr = <IExprInstruction>this.expr;\r\n\r\n        if (!expr.evaluate()) {\r\n            return false;\r\n        }\r\n\r\n        var res: any = null;\r\n\r\n        try {\r\n            res = expr.getEvalValue();\r\n            switch (op) {\r\n                case '+':\r\n                    res = +res;\r\n                    break;\r\n                case '-':\r\n                    res = -res;\r\n                    break;\r\n                case '!':\r\n                    res = !res;\r\n                    break;\r\n                case '++':\r\n                    res = ++res;\r\n                    break;\r\n                case '--':\r\n                    res = --res;\r\n                    break;\r\n            }\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import { Visitor } from \"@lib/fx/Visitors\";\r\nimport { EInstructionTypes, IFunctionCallInstruction, IFunctionDeclInstruction, IInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISLDocument } from \"@lib/idl/ISLDocument\";\r\nimport { checkRange } from \"@lib/parser/util\";\r\nimport { ParameterInformation, Position, SignatureHelp, SignatureInformation, TextDocument } from \"vscode-languageserver-types\";\r\n\r\nconst asRange = (instr: IInstruction) => instr.sourceNode.loc;\r\n\r\nexport class SLSignatureHelp {\r\n    doSignatureHelp(textDocument: TextDocument, position: Position, slDocument: ISLDocument): SignatureHelp {\r\n        if (!slDocument) {\r\n            return null;\r\n        }\r\n        \r\n        const offset = textDocument.offsetAt(position);\r\n        const decl = slDocument.root.instructions.find(instr => checkRange(asRange(instr), offset));\r\n        \r\n        if (decl) {\r\n            // console.log(decl);\r\n            if (decl.instructionType === EInstructionTypes.k_FunctionDecl) {\r\n\r\n                let fcall: IFunctionCallInstruction = null;\r\n                Visitor.each(decl, instr => {\r\n                    if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n                        if (checkRange(asRange(instr), offset)) {\r\n                            fcall = <IFunctionCallInstruction>instr;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (!fcall) {\r\n                    return null;\r\n                }\r\n\r\n                const fdecl = <IFunctionDeclInstruction>fcall.decl;\r\n                const fnList = fdecl.scope.functions[fdecl.name];\r\n                const signatures = fnList.map(fn =>\r\n                    SignatureInformation.create(\r\n                        fn.def.toCode(),\r\n                        null, // no documentation provided\r\n                        ...fn.def.params.map(param => ParameterInformation.create(param.name))\r\n                    ));\r\n\r\n                let activeSignature = fnList.indexOf(fdecl);\r\n                let activeParameter = 0;\r\n\r\n                if (activeSignature !== -1) {\r\n                    activeParameter = fcall.args.findIndex(arg =>\r\n                        checkRange(asRange(arg), offset));\r\n                } else {\r\n                    activeSignature = 0;\r\n                    console.error(`could not find active signature for: '${fdecl.def.toCode()}'`);\r\n                }\r\n\r\n                return { signatures, activeParameter, activeSignature };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","import { assert, isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport { EScopeType, IFunctionDeclInstruction, IScope, ITechniqueInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { fn, type } from \"./helpers\";\r\n\r\nexport interface IScopeSettings {\r\n    type?: EScopeType;\r\n    parent?: IScope;\r\n    strictMode?: boolean;\r\n}\r\n\r\n\r\n\r\nexport class Scope implements IScope {\r\n    strictMode: boolean;\r\n\r\n    readonly parent: IScope;\r\n    readonly type: EScopeType;\r\n\r\n    readonly variables: IMap<IVariableDeclInstruction>;\r\n    readonly types: IMap<ITypeInstruction>;\r\n    readonly functions: IMap<IFunctionDeclInstruction[]>;\r\n    readonly techniques: IMap<ITechniqueInstruction>;\r\n    readonly typeTemplates: IMap<ITypeTemplate>;\r\n\r\n    constructor({ type = EScopeType.k_Default, parent = null, strictMode = false }: IScopeSettings) {\r\n        this.type = type;\r\n        this.parent = parent;\r\n        this.strictMode = strictMode;\r\n\r\n        this.variables = {};\r\n        this.types = {};\r\n        this.functions = {};\r\n        this.techniques = {};\r\n        this.typeTemplates = {};\r\n    }\r\n\r\n\r\n    isStrict(): boolean {\r\n        return this.filter(scope => scope.strictMode);\r\n    }\r\n\r\n\r\n    findVariable(varName: string): IVariableDeclInstruction {\r\n        return this.filter(scope => scope.variables[varName] || null);\r\n    }\r\n\r\n\r\n    findTypeTemplate(typeName: string): ITypeTemplate {\r\n        return this.filter(scope => scope.typeTemplates[typeName] || null);\r\n    }\r\n\r\n\r\n    findType(typeName: string): ITypeInstruction {\r\n        return this.filter(scope => scope.types[typeName] || null);\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    findFunction(funcName: string, args: Array<ITypeInstruction | RegExp> = null): IFunctionDeclInstruction | null | undefined {\r\n        return this.filter(scope => fn.matchList(scope.functions[funcName], args))\r\n    }\r\n\r\n\r\n    findTechnique(techName: string): ITechniqueInstruction {\r\n        return this.filter(scope => scope.techniques[techName] || null);\r\n    }\r\n\r\n\r\n    findFunctionInScope(func: IFunctionDeclInstruction): IFunctionDeclInstruction {\r\n        let res = fn.matchList(this.functions[func.name], func.def.params.map(param => param? param.type : null));\r\n        assert(res !== undefined);\r\n        return res;\r\n    }\r\n\r\n    \r\n    addVariable(variable: IVariableDeclInstruction): boolean {\r\n        let variableMap = this.variables;\r\n        let varName = variable.name;\r\n\r\n        if (!this.variables[varName]) {\r\n            variableMap[varName] = variable;\r\n            assert(variable.scope === this);\r\n        }\r\n        else {\r\n            // console.error(`letiable '${varName}' already exists in scope:`, this);\r\n            return false;\r\n        }\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    addTypeTemplate(template: ITypeTemplate): boolean {\r\n        if (isDefAndNotNull(this.typeTemplates[template.name])) {\r\n            return false;\r\n        }\r\n\r\n        this.typeTemplates[template.name] = template;\r\n        return true;\r\n    }\r\n\r\n    // todo: remove scopeId from argumts, use type.scope instead.\r\n    addType(type: ITypeInstruction): boolean {\r\n        if (this.types[type.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.types[type.name] = type;\r\n        console.assert(type.scope === this);\r\n        return true;\r\n    }\r\n\r\n\r\n    addFunction(func: IFunctionDeclInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n        assert(func.scope === this);\r\n\r\n        let funcMap = this.functions;\r\n        let funcName = func.name;\r\n\r\n        funcMap[funcName] = funcMap[funcName] || [];\r\n        const funcOverloads = funcMap[funcName];\r\n\r\n        let targetFunc = this.findFunctionInScope(func);\r\n\r\n        if (!targetFunc) {\r\n            funcOverloads.push(func);\r\n        } else {\r\n            assert(!isNull(func.impl));\r\n            assert(isNull(targetFunc.impl));\r\n            let i = funcOverloads.indexOf(targetFunc);\r\n            funcOverloads[i] = func;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    addTechnique(technique: ITechniqueInstruction): boolean {\r\n        assert(this.type <= EScopeType.k_Global);\r\n\r\n        if (this.techniques[technique.name]) {\r\n            return false;\r\n        }\r\n\r\n        this.techniques[technique.name] = technique;\r\n        assert(technique.scope === this);\r\n        return false;\r\n    }\r\n\r\n    private filter<T>(cb: (scope: IScope) => T | null): T \r\n    {\r\n        let scope: IScope = this;\r\n        while (!isNull(scope)) {\r\n            let res = cb(scope);\r\n            if (!isNull(res)) {\r\n                return res;\r\n            }\r\n            scope = scope.parent;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class ProgramScope {\r\n    globalScope: IScope;\r\n    currentScope: IScope;\r\n\r\n\r\n    constructor(parent: IScope) {\r\n        assert(parent !== null);\r\n        let type = EScopeType.k_Global;\r\n        this.globalScope = new Scope({ parent, type });\r\n        this.currentScope = this.globalScope;\r\n    }\r\n\r\n\r\n    validate(): void {\r\n        assert(this.currentScope === this.globalScope);\r\n    }\r\n\r\n\r\n    push(type: EScopeType = EScopeType.k_Default): void {\r\n        assert(this.currentScope !== null);\r\n        assert(type >= EScopeType.k_Default);\r\n\r\n        let parent = this.currentScope;\r\n        let scope = new Scope({ parent, type });\r\n\r\n        this.currentScope = scope;\r\n    }\r\n\r\n\r\n    pop(): void {\r\n        assert(this.currentScope !== null);\r\n        this.currentScope = this.currentScope.parent;\r\n        assert(this.currentScope !== null);\r\n    }\r\n}\r\n","import { assert, isBoolean, isNull, isNumber, PropertiesDiff } from \"@lib/common\";\r\nimport { expression, instruction, type, variable } from \"@lib/fx/analisys/helpers\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EInstructionTypes, IAnnotationInstruction, ICompileExprInstruction, IDeclInstruction, IExprInstruction, IFunctionDeclInstruction, IIdInstruction, IInstruction, IInstructionCollector, IPassInstruction, IStmtInstruction, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IParseNode } from \"@lib/idl/parser/IParser\";\r\nimport { EPartFxPassGeometry, IPartFxInstruction, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { Analyzer, Context, ICompileValidator } from \"./Analyzer\";\r\nimport { IdInstruction } from \"./instructions/IdInstruction\";\r\nimport { PartFxInstruction } from \"./instructions/part/PartFxInstruction\";\r\nimport { PartFxPassInstruction } from \"./instructions/part/PartFxPassInstruction\";\r\nimport { SpawnInstruction } from \"./instructions/part/SpawnInstruction\";\r\nimport { ProgramScope } from \"./ProgramScope\";\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_UINT, T_VOID } from \"./SystemScope\";\r\n\r\ntype IPartFxPassProperties = PropertiesDiff<IPartFxPassInstruction, IPassInstruction>;\r\n// type is internal property which is always ETechniqueType.k_PartFx for particle fx's,\r\n// so we can omit it.\r\ntype IPartFxProperties = Omit<PropertiesDiff<IPartFxInstruction, IDeclInstruction>, \"type\">;\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\nclass FxContext extends Context {\r\n    /** Main particle structure type describing particle's simulation. */\r\n    particleCore: ITypeInstruction;\r\n    /** Particle instance structure type which describe per pass render instance of the particle. */\r\n    particleInstance: ITypeInstruction;\r\n\r\n    spawnStmts: SpawnInstruction[] = [];\r\n\r\n    // beginFunc(): void {\r\n    //     super.beginFunc();\r\n    // }\r\n\r\n    // endFunc(): void {\r\n    //     super.endFunc();\r\n    // }\r\n\r\n    beginPartFxPass(): void {\r\n        this.beginPass();\r\n        this.particleInstance = null;\r\n    }\r\n\r\n    endPartFxPass(): void {\r\n        this.particleInstance = null;\r\n        this.endPass();\r\n    }\r\n\r\n    beginPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n\r\n    endPartFx(): void {\r\n        this.particleCore = null;\r\n    }\r\n}\r\n\r\n\r\nfunction sliceNode(source: IParseNode, from: number, to?: number): IParseNode {\r\n    const { children, parent, name, value, loc } = source;\r\n    return {\r\n        children: children.slice(from, to),\r\n        parent,\r\n        name,\r\n        value,\r\n        loc\r\n    };\r\n}\r\n\r\n\r\nexport class FxAnalyzer extends Analyzer {\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'Init'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_SPAWN = 'spawn'\r\n     */\r\n    protected analyzeSpawnStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const count = Number(children.slice(-3, -2)[0].value);\r\n        const name = children.slice(-5, -4)[0].value;\r\n        const args = <IExprInstruction[]>[];\r\n\r\n        for (let i = children.length - 7; i >= 2; i--) {\r\n            if (children[i].value !== ',') {\r\n                const arg = this.analyzeExpr(context, program, children[i]);\r\n                args.push(arg);\r\n            }\r\n        }\r\n\r\n        const spawnStmt = new SpawnInstruction({ sourceNode, scope, name, args, count });\r\n        context.spawnStmts.push(spawnStmt);\r\n\r\n        return spawnStmt;\r\n    }\r\n\r\n    protected analyzeSimpleStmt(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_SPAWN':\r\n                return this.analyzeSpawnStmt(context, program, sourceNode);\r\n\r\n            default:\r\n                return super.analyzeSimpleStmt(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'SpawnRoutine'\r\n     */\r\n    protected analyzePartFXProperty(context: FxContext, program: ProgramScope, sourceNode: IParseNode): any {\r\n        const children = sourceNode.children;\r\n        console.log(sourceNode);\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *         T_NON_TYPE_ID = 'P0'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePartFXPassDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxPassInstruction {\r\n\r\n        context.beginPartFxPass();\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        // temp solution in order to not highlight useless pass states in the next analysis call.\r\n        context.renderStates = renderStates;\r\n\r\n        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);\r\n\r\n        const sorting = isBoolean(fxStates.sorting) ? fxStates.sorting : true;\r\n        const prerenderRoutine = fxStates.prerenderRoutine || null;\r\n        const geometry = fxStates.geometry || EPartFxPassGeometry.k_Billboard;\r\n        const instanceCount = fxStates.instanceCount || 1;\r\n\r\n        //\r\n        // Validation of the shader input\r\n        //\r\n\r\n        let pixelShader = entry.pixel;\r\n\r\n        /**\r\n         * Vertex shader validation pattern:\r\n         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);\r\n         */\r\n\r\n        let vertexShader = entry.vertex;\r\n        if (vertexShader) {\r\n            const requiredSemantics = ['POSITION', 'POSITION0'];\r\n            let hasInstance = false;\r\n            let hasRequiredSemantics = false;\r\n            for (const param of vertexShader.def.params) {\r\n                hasInstance = hasInstance ||\r\n                    param.type.subType === context.particleInstance;\r\n                hasRequiredSemantics = hasRequiredSemantics ||\r\n                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));\r\n            }\r\n\r\n            if (!hasInstance) {\r\n                context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n                    { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });\r\n                vertexShader = pixelShader = null;\r\n            }\r\n\r\n            // if (!hasRequiredSemantics) {\r\n            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,\r\n            //         { tooltip: 'doesn\\'t have requiredsemantics.' });\r\n            //     vertexShader = pixelShader = null;\r\n            // }\r\n        }\r\n\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ sourceNode: children[i], scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PartFxPassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            id,\r\n\r\n            sorting,\r\n            geometry,\r\n            instanceCount,\r\n            prerenderRoutine,\r\n\r\n            renderStates,\r\n            pixelShader,\r\n            vertexShader\r\n        });\r\n\r\n        //TODO: add annotation and id\r\n\r\n        context.endPartFxPass();\r\n\r\n        return pass;\r\n    }\r\n\r\n\r\n    // TODO: use explicit return type\r\n    protected analyzePartFxStateBlock(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n        const children = sourceNode.children;\r\n        let states: Partial<IPartFxPassProperties> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n    * AST example:\r\n    *    PassState\r\n    *         T_PUNCTUATOR_59 = ';'\r\n    *       + PassStateExpr \r\n    *         T_PUNCTUATOR_61 = '='\r\n    *         T_NON_TYPE_ID = 'STATE_ONE'\r\n    */\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'STATE_TWO'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PassStateExpr\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    // TODO: add explicit type for fx statess\r\n    protected analyzePartFXPassProperies(context: FxContext, program: ProgramScope, sourceNode: IParseNode): Partial<IPartFxPassProperties> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateName: string = children[children.length - 1].value.toUpperCase();\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        let fxStates: Partial<IPartFxPassProperties> = {};\r\n\r\n        if (isNull(exprNode.value) || isNull(stateName)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            // TODO: return correct state list\r\n            return fxStates;\r\n        }\r\n\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_PUNCTUATOR_125 = '}'\r\n         *         T_UINT = '1'\r\n         *         T_PUNCTUATOR_44 = ','\r\n         *         T_KW_TRUE = 'true'\r\n         *         T_PUNCTUATOR_123 = '{'\r\n         */\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: string[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                // TODO: validate values with names\r\n                values[j] = stateExprNode.children[i].value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                // case ERenderStates.BLENDFUNC:\r\n                //     if (values.length !== 2) {\r\n                //         console.warn('Pass state are incorrect.');\r\n                //         return {};\r\n                //     }\r\n                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                //     break;\r\n                default:\r\n                    console.warn('Pass fx state is incorrect.');\r\n                    return fxStates;\r\n            }\r\n        }\r\n        /**\r\n         * AST example:\r\n         *    PassStateExpr\r\n         *         T_NON_TYPE_ID = 'FALSE'\r\n         */\r\n        else {\r\n            let value: string = null;\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ('InstanceCount'.toUpperCase()):\r\n                    fxStates.instanceCount = Number(value) || 1;\r\n                    break;\r\n                case ('Geometry'.toUpperCase()):\r\n                    const types = [\r\n                        'Billboard',\r\n                        'Cylinder',\r\n                        'Box',\r\n                        'Sphere',\r\n                        'Line'\r\n                    ].map(type => type.toUpperCase());\r\n\r\n                    fxStates.geometry = Math.max(0, types.indexOf(value)) as EPartFxPassGeometry;\r\n                    break;\r\n                case ('Sorting'.toUpperCase()):\r\n                    // TODO: use correct validation with diag error output\r\n                    assert(value == 'TRUE' || value == 'FALSE');\r\n                    fxStates.sorting = (value === 'TRUE');\r\n                    break;\r\n                case ('PrerenderRoutine'.toUpperCase()):\r\n                    {\r\n                        /**\r\n                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.\r\n                        */\r\n                        let validators: ICompileValidator[] = [\r\n                            /* prerender(Part part, PartInstance instance) */\r\n                            { ret: T_VOID, args: [context.particleCore, null] },\r\n                            /* prerender(Part part, PartInstance instance, int instanceId) */\r\n                            { ret: T_VOID, args: [context.particleCore, null, SystemScope.T_INT] },\r\n                        ];\r\n\r\n                        //\r\n                        // TODO: add string-based validators like this:\r\n                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);\r\n                        //\r\n\r\n                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);\r\n\r\n                        if (!prerenderRoutine) {\r\n                            break;\r\n                        }\r\n\r\n                        //\r\n                        // check arguments\r\n                        //\r\n\r\n                        let fn = prerenderRoutine.function;\r\n\r\n                        /** first argument's type */\r\n                        let argv = fn.def.params.map(param => param.type);\r\n\r\n                        if (argv.length < 2) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        if (!argv[0].readable || /*!argv[0].isEqual(context.particle)*/ argv[0].subType !== context.particleCore ||\r\n                            argv[0].isNotBaseArray() ||\r\n                            !argv[1].hasUsage('out') || !argv[1].writable || argv[1].isNotBaseArray()) {\r\n                            context.error(exprNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });\r\n                            prerenderRoutine = null;\r\n                        }\r\n\r\n                        //         argv[1]: \"out PartInstance\"\r\n                        // argv[1].subType: \"PartInstance\"\r\n                        context.particleInstance = argv[1].subType;\r\n                        fxStates.prerenderRoutine = prerenderRoutine;\r\n                    }\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n\r\n        return fxStates;\r\n    }\r\n\r\n\r\n    protected analyzePartFXBody(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxProperties {\r\n        let passList: IPartFxPassInstruction[] = [];\r\n        let spawnRoutine: ICompileExprInstruction = null;\r\n        let initRoutine: ICompileExprInstruction = null;\r\n        let updateRoutine: ICompileExprInstruction = null;\r\n        let particle: ITypeInstruction = null;\r\n        let capacity: number = null;\r\n\r\n        const children = sourceNode.children;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassState':\r\n                    {\r\n                        let sourceNode = children[i];\r\n                        let stateName = sourceNode.children[3].value; // \"T_NON_TYPE_ID\"\r\n                        switch (stateName.toUpperCase()) {\r\n                            case ('Capacity'.toUpperCase()):\r\n                                {\r\n                                    // TODO: make correct validation of the capacity value and emit errors\r\n                                    //       through diagnostics system. \r\n                                    const snum = sourceNode.children[1].children[0].value;\r\n                                    assert(isNumber(Number(snum)));\r\n                                    capacity = Number(snum) || -1;\r\n                                    break;\r\n                                }\r\n                            case ('SpawnRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Spawn routine expected as 'int spawn(void)'.\r\n                                     */\r\n                                    let validator = { ret: T_INT, args: [] };\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, [validator]);\r\n                                }\r\n                                break;\r\n                            case ('InitRoutine'.toUpperCase()):\r\n                                {\r\n                                    /** Init routine expected as 'void init(in Part part)'. */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_VOID, args: [null, T_INT] },   /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null, T_UINT] },  /* init(PART part, int partId) */\r\n                                        { ret: T_VOID, args: [null] },          /* init(PART part) */\r\n                                    ];\r\n\r\n                                    // TODO: show error in case of both functions are found\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!initRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    let fn = initRoutine.function;\r\n                                    /** first argument's type */\r\n                                    let type = fn.def.params[0].type;\r\n\r\n                                    if ((!type.hasUsage('out') && !type.hasUsage('inout')) || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        initRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                            case ('UpdateRoutine'.toUpperCase()):\r\n                                {\r\n                                    /**\r\n                                     * Update routine expected as 'void update(inout Part part)'.\r\n                                     */\r\n                                    let validators: ICompileValidator[] = [\r\n                                        { ret: T_BOOL, args: [null, T_INT] }, /* update(PART part, int partId) */\r\n                                        { ret: T_BOOL, args: [null] },        /* update(PART part) */\r\n                                    ];\r\n\r\n                                    let objectExrNode = sourceNode.children[1].children[0];\r\n                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    //\r\n                                    // check arguments\r\n                                    //\r\n\r\n                                    const fn = updateRoutine.function;\r\n                                    const fdef = fn.def;\r\n                                    const paramList = fdef.params;\r\n\r\n                                    if (paramList.length < 1 || paramList.length > 2) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    /** first argument's type */\r\n                                    let type = paramList[0].type;\r\n\r\n                                    if (!type.hasUsage('out') && !type.hasUsage('inout') || type.isNotBaseArray()) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (particle && type.subType !== particle) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    //\r\n                                    // Check return type\r\n                                    //\r\n\r\n                                    if (!fdef.returnType.isEqual(T_BOOL)) {\r\n                                        context.error(objectExrNode, EErrors.InvalidCompileFunctionNotValid,\r\n                                            { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });\r\n                                        updateRoutine = null;\r\n                                    }\r\n\r\n                                    if (!updateRoutine) {\r\n                                        break;\r\n                                    }\r\n\r\n                                    // type is referencing to VariableType of argument,\r\n                                    // while substitute type referencing to declaration. \r\n                                    particle = type.subType;\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Note: all fx properties should be parsed prior to pass declaraion analysis\r\n        // because some of them are critical for pass validation\r\n        context.particleCore = particle;\r\n\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            switch (children[i].name) {\r\n                case 'PassDecl':\r\n                    {\r\n                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);\r\n\r\n                        if (!pass.isValid()) {\r\n                            context.warn((pass.id && pass.id.sourceNode) || children[i], EWarnings.IncompletePass, {\r\n                                techniqueName: pass.name,\r\n                                tooltip: `The pass is not completed. Not all required parameters are specified.`\r\n                            });\r\n                        }\r\n\r\n                        assert(!isNull(pass));\r\n                        passList.push(pass);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        return { passList, spawnRoutine, initRoutine, updateRoutine, particle, capacity };\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PartFxDecl\r\n     *       + PartFxBody \r\n     *       + Annotation \r\n     *       + Semantic \r\n     *       + ComplexNameOpt \r\n     *         T_KW_FXPART = 'partFx'\r\n     */\r\n    protected analyzePartFXDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IPartFxInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let props: IPartFxProperties = null;\r\n\r\n        context.beginPartFx();\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n\r\n            switch (children[i].name) {\r\n                case 'Annotation':\r\n                    annotation = this.analyzeAnnotation(children[i]);\r\n                    break;\r\n                case 'Semantic':\r\n                    semantic = this.analyzeSemantic(children[i]);\r\n                    break;\r\n                case 'PartFxBody':\r\n                    props = this.analyzePartFXBody(context, program, children[i]);\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        context.endPartFx();\r\n\r\n        const partFx = new PartFxInstruction({\r\n            sourceNode, name, semantic, annotation, scope, ...props\r\n        });\r\n\r\n        if (!partFx.isValid()) {\r\n            // highlight name only\r\n            context.warn(children[children.length - 2], EWarnings.IncompleteTechnique, {\r\n                techniqueName: partFx.name,\r\n                tooltip: `The technique is not completed. Not all required parameters are specified.`\r\n            });\r\n        }\r\n\r\n        FxAnalyzer.addTechnique(context, program, partFx);\r\n        return partFx;\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: FxContext, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'PartFxDecl':\r\n                return [this.analyzePartFXDecl(context, program, sourceNode)];\r\n            default:\r\n                return super.analyzeUnknDecl(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n    protected createContext(uri: string): FxContext {\r\n        return new FxContext(uri);\r\n    }\r\n\r\n\r\n    protected validate(context: FxContext, program: ProgramScope, root: IInstructionCollector) {\r\n        super.validate(context, program, root);\r\n\r\n        const scope = program.globalScope;\r\n\r\n        // NOTE: all effects are assumed to be valid\r\n        const fxList = <IPartFxInstruction[]>root.instructions.filter(instr => instr.instructionType === EInstructionTypes.k_PartFxDecl);\r\n\r\n        //\r\n        // spawn operator validation\r\n        //\r\n\r\n        for (const spawnStmt of context.spawnStmts) {\r\n            const bImportedEffect = false;\r\n            //parse as the spawn from the same effect\r\n\r\n            assert(!bImportedEffect, 'unsupported');\r\n\r\n            if (!bImportedEffect) {\r\n\r\n                let initializer = <IFunctionDeclInstruction>null;\r\n                for (const fx of fxList) {\r\n                    // looking for Init(out Part part, int partId: PART_ID, ...parameters)\r\n                    let args = [fx.particle, T_INT, ...spawnStmt.args.map(asType)];\r\n                    initializer = scope.findFunction(spawnStmt.name, args);\r\n\r\n                    // in case of signature not found:\r\n                    // looking for signature like: Init(out Part part, ...parameters)\r\n                    if (!initializer) {\r\n                        // looaking for signature like: Init(out Part part, ...parameters)\r\n                        // TODO: check that second parameter doesn't have PART_ID semantic in \r\n                        //       order to not find false positive signature\r\n                        args = [fx.particle, ...spawnStmt.args.map(asType)];\r\n                        initializer = scope.findFunction(spawnStmt.name, args);\r\n                    }\r\n\r\n                    if (initializer) {\r\n                        spawnStmt.$resolve(fx, initializer);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!initializer) {\r\n                    context.error(spawnStmt.sourceNode, EErrors.PartFx_InvalidSpawnStmtInitializerNotFound,\r\n                        { tooltip: 'Invalid spawn statement. Effect initializer not found.' });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","import { isString } from \"@lib/common\";\r\n\r\n// helper class to always pass strings by pointer and not by value;\r\nexport class StringRef {\r\n    constructor(readonly content: string) {\r\n\r\n    }\r\n\r\n    valueOf(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.content;\r\n    }\r\n\r\n    toSource(): string {\r\n        return this.content;\r\n    }\r\n\r\n    static make(val: string | StringRef): StringRef {\r\n        if (!isString(val)) {\r\n            return <StringRef>val;\r\n        }\r\n        return new StringRef(`${val}`);\r\n    }\r\n}\r\n\r\n","import { IDiagnosticReport, IDiagnostics } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { StringRef } from \"@lib/util/StringRef\";\r\n\r\nexport enum ENodeCreateMode {\r\n    k_Default,\r\n    k_Necessary,\r\n    k_Expose,\r\n    k_Skip\r\n}\r\n\r\nexport enum EParserCode {\r\n    // k_Pause,\r\n    k_Ok,\r\n    k_Error\r\n}\r\n\r\nexport enum EParserType {\r\n    k_LR0,\r\n    k_LR1,\r\n    k_LALR\r\n}\r\n\r\nexport enum IASTDocumentFlags {\r\n    k_Optimize = 0x0008,\r\n    k_DeveloperMode = 0x0010\r\n}\r\n\r\n\r\nexport enum EParserFlags {\r\n    k_ForceAppendAll = 0x0001,\r\n    k_AllowExposeMode = 0x0002,\r\n    k_AllowAddMode = 0x0004,\r\n    k_AllowSkipMode = 0x008,\r\n    k_Default = k_AllowAddMode | k_AllowExposeMode | k_AllowSkipMode,\r\n    k_Debug = 0x0010\r\n}\r\n\r\n\r\nexport enum ETokenType {\r\n    k_NumericLiteral = 1,\r\n    k_SinglelineCommentLiteral,\r\n    k_MultilineCommentLiteral,\r\n    k_StringLiteral,\r\n    k_PunctuatorLiteral,\r\n    k_WhitespaceLiteral,\r\n    k_NewlineLiteral,\r\n    k_IdentifierLiteral,\r\n    k_KeywordLiteral,\r\n    k_Unknown,\r\n    k_End\r\n}\r\n\r\n\r\nexport type IFile = StringRef;\r\n\r\nexport interface IPosition {\r\n    file: IFile;\r\n    line: number; \r\n    column: number;\r\n    offset?: number;\r\n}\r\n\r\n// todo: add support for range over multiple files;\r\nexport interface IRange {\r\n    start: IPosition;\r\n    end: IPosition;\r\n}\r\n\r\nexport interface IToken {\r\n    index: number;\r\n    value: string;\r\n    name?: string;\r\n    type?: ETokenType;\r\n\r\n    loc?: IRange;\r\n    // range?: number[];\r\n}\r\n\r\n\r\n/**\r\n * Grammar rule corresponding to the entry from grammar file.\r\n */\r\nexport interface IRule {\r\n    left: string;\r\n    right: string[];\r\n\r\n    /**\r\n     * rule index based on parser's '_nRules'; \r\n     */\r\n    index: number;\r\n}\r\n\r\nexport enum EOperationType {\r\n    k_Error = 100,\r\n    k_Shift,\r\n    k_Reduce,\r\n    k_Success,\r\n    k_Ok\r\n}\r\n\r\nexport type IRuleFunction = () => EOperationType | Promise<EOperationType>;\r\n\r\nexport interface IParseNode {\r\n    children: IParseNode[];\r\n    parent: IParseNode;\r\n    name: string;\r\n    value: string;\r\n    loc?: IRange;\r\n}\r\n\r\nexport interface IParseTree {\r\n    readonly nodes: IParseNode[];\r\n    readonly lastNode: IParseNode;\r\n    readonly optimized: boolean;\r\n    readonly root: IParseNode;\r\n\r\n    addToken(pToken: IToken): void;\r\n    reduceByRule(pRule: IRule, eCreate: ENodeCreateMode): void;\r\n    finishTree(): void;\r\n    \r\n    $pop(loc?: IRange): void;\r\n\r\n\r\n    /** @deprecated */\r\n    clone(): IParseTree;\r\n    /** @deprecated */\r\n    toString(): string;\r\n    /** @deprecated */\r\n    toHTMLString(node?: IParseNode, padding?: string): string;\r\n}\r\n\r\n\r\nexport interface ILexerEngine {\r\n    readonly keywords: IMap<string>;\r\n    readonly punctuators: IMap<string>;\r\n    readonly punctuatorsFirstSymbols: IMap<boolean>;\r\n\r\n\r\n    addPunctuator(value: string, name?: string): string;\r\n    addKeyword(value: string, name: string): string;\r\n\r\n    getTerminalValueByName(name: string): string;\r\n\r\n    isLineTerminator(symbol: string): boolean;\r\n    isKeyword(value: string): boolean;\r\n    isPunctuator(value: string): boolean;\r\n    isNumberStart(ch: string, ch1: string): boolean;\r\n    isCommentStart(ch: string, ch1: string): boolean;\r\n    isStringStart(ch: string): boolean;\r\n    isPunctuatorStart(ch: string): boolean;\r\n    isWhiteSpaceStart(ch: string): boolean;\r\n    isNewlineStart(ch: string): boolean;\r\n    isIdentifierStart(ch: string): boolean;\r\n}\r\n\r\n\r\nexport interface IASTConfig {\r\n    parser?: IParser;\r\n    knownTypes?: Set<string>;\r\n    ruleFunctions?: Map<string, IRuleFunction>;\r\n}\r\n\r\n\r\nexport interface IASTDocument {\r\n    readonly uri: string;\r\n    readonly diagnosticReport: IDiagnosticReport;\r\n    readonly root: IParseNode;\r\n}\r\n\r\n\r\n\r\n\r\nexport interface IOperation {\r\n    type: EOperationType;\r\n    rule?: IRule;\r\n    stateIndex?: number;\r\n}\r\n\r\nexport interface IOperationMap {\r\n    [grammarSymbol: string]: IOperation;\r\n    [stateIndex: number]: IOperation;\r\n}\r\n\r\nexport interface ISyntaxTable {\r\n    [stateIndex: number]: {\r\n        [terminal: string]: IOperation;\r\n    }\r\n}\r\n\r\n\r\nexport interface IRuleMap {\r\n    [ruleIndex: number]: IRule;\r\n}\r\n\r\nexport interface IProductions {\r\n    [nonTerminal: string]: IRuleMap;\r\n}\r\n\r\n// TODO: remove type\r\nexport interface IRuleFunctionMap {\r\n    [grammarSymbolOrFuncName: string]: string;\r\n}\r\n\r\nexport interface IRuleFunctionDMap {\r\n    [stateIndex: number]: IRuleFunctionMap;\r\n}\r\n\r\nexport interface IAdditionalFuncInfo {\r\n    name: string;\r\n    position: number;\r\n    rule: IRule;\r\n}\r\n\r\nexport interface IParser {\r\n    readonly lexerEngine: ILexerEngine;\r\n    readonly syntaxTable: ISyntaxTable;\r\n\r\n    findFunctionByState(stateIndex: number, grammarSymbol: string): string\r\n    getRuleCreationMode(nonTerminal: string): ENodeCreateMode;\r\n    getGrammarSymbols(): Map<string, string>;    \r\n}\r\n\r\n\r\nexport interface IParserParams {\r\n    grammar: string;\r\n    flags?: number; // EParserFlags\r\n    type?: EParserType;\r\n}\r\n\r\n\r\nexport type ExpectedSymbols = Set<string>;\r\n","import { EInstructionTypes, IExprInstruction, IReturnOperator, IReturnStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IReturnStmtInstructionSettings extends IInstructionSettings {\r\n    expr?: IExprInstruction;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Represent return expr;\r\n * return ExprInstruction\r\n */\r\nexport class ReturnStmtInstruction extends StmtInstruction implements IReturnStmtInstruction {\r\n    protected _operator: IReturnOperator;\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr = null, ...settings }: IReturnStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ReturnStmt, ...settings });\r\n        \r\n        this._operator = \"return\";\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get operator(): IReturnOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        if (this.expr) {\r\n            return \"return \" + this.expr.toCode() + \";\";\r\n        }\r\n        else {\r\n            return \"return;\";\r\n        }\r\n    }\r\n}\r\n\r\n","import { assert, isNull } from '@lib/common';\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IInitExprInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from './DeclInstruction';\r\nimport { type } from '../helpers';\r\nimport { Instruction } from './Instruction';\r\n\r\n// import * as SystemScope from '@lib/fx/analisys/SystemScope';\r\n\r\nexport interface IVariableDeclInstructionSettings extends IDeclInstructionSettings {\r\n    id: IIdInstruction;\r\n    type: IVariableTypeInstruction;\r\n    init?: IInitExprInstruction;\r\n\r\n    // EVariableUsageFlags\r\n    usageFlags?: number;\r\n}\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport enum EVariableUsageFlags {\r\n    k_Local     = 0x01,\r\n    k_Global    = 0x02,\r\n    k_Argument  = 0x04,\r\n}\r\n\r\n/**\r\n * Represent type var_name [= init_expr]\r\n * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction\r\n */\r\nexport class VariableDeclInstruction extends DeclInstruction implements IVariableDeclInstruction {\r\n\r\n    protected _id: IIdInstruction;\r\n    protected _type: IVariableTypeInstruction;\r\n    protected _initExpr: IInitExprInstruction;\r\n    protected _usageFlags: number;\r\n\r\n \r\n    constructor({ id, type, init = null, usageFlags = 0, ...settings }: IVariableDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableDecl, ...settings });\r\n\r\n        this._id = Instruction.$withParent(id, this);\r\n        this._type = Instruction.$withNoParent(type);\r\n        this._initExpr = Instruction.$withParent(init, this);\r\n        this._usageFlags = usageFlags;\r\n\r\n        assert(!this.isParameter() || (isNull(this.parent) || this.parent.instructionType == EInstructionTypes.k_FunctionDef));\r\n        assert(this.isLocal() || !this.isLocal());\r\n        assert(!this.isParameter() || this.isLocal());\r\n    }\r\n\r\n\r\n    get initExpr(): IInitExprInstruction {\r\n        return this._initExpr;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    get defaultValue(): any {\r\n        this._initExpr.evaluate();\r\n        return this._initExpr.getEvalValue();\r\n    }\r\n\r\n\r\n    get type(): IVariableTypeInstruction {\r\n        return <IVariableTypeInstruction>this._type;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    isGlobal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Global);\r\n    }\r\n\r\n\r\n    isLocal(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Local);\r\n    }\r\n\r\n    isParameter(): boolean {\r\n        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);\r\n    }\r\n\r\n\r\n\r\n    isField(): boolean {\r\n        if (isNull(this.parent)) {\r\n            return false;\r\n        }\r\n\r\n        var eParentType: EInstructionTypes = this.parent.instructionType;\r\n        if (eParentType === EInstructionTypes.k_VariableType ||\r\n            eParentType === EInstructionTypes.k_ComplexType ||\r\n            eParentType === EInstructionTypes.k_SystemType) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        var code = '';        \r\n        code = this.type.toCode();\r\n        code += ' ' + this.id.toCode();\r\n\r\n        if (this.type.isNotBaseArray()) {\r\n            var iLength: number = this.type.length;\r\n            code += '[' + iLength + ']';\r\n        }\r\n\r\n        if (!isNull(this.initExpr) &&\r\n            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?\r\n            !this.type.isUniform()) {\r\n            code += '=' + this.initExpr.toCode();\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IExprInstruction, IStmtInstruction, IWhileStmtInstruction, IDoWhileOperator } from \"@lib/idl/IInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n\r\n\r\nexport interface IWhileStmtInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    body: IStmtInstruction;\r\n    operator: IDoWhileOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent while(expr) stmt\r\n * ( while || do_while) ExprInstruction StmtInstruction\r\n */\r\nexport class WhileStmtInstruction extends StmtInstruction implements IWhileStmtInstruction {\r\n    protected _operator: IDoWhileOperator;\r\n    protected _cond: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    \r\n    constructor({ cond, body, operator, ...settings }: IWhileStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_WhileStmt, ...settings });\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this.cond;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n\r\n    get operator(): IDoWhileOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        if (this.operator === \"while\") {\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \")\";\r\n            code += this.body.toCode();\r\n        }\r\n        else {\r\n            code += \"do\";\r\n            code += this.body.toCode();\r\n            code += \"while(\";\r\n            code += this.cond.toCode();\r\n            code += \");\";\r\n        }\r\n        return code;\r\n    }\r\n}\r\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IComplexExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IComplexExprInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent (expr)\r\n * EMPTY_OPERATOR ExprInstruction\r\n */\r\nexport class ComplexExprInstruction extends ExprInstruction implements IComplexExprInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n\r\n    constructor({ expr, ...settings }: IComplexExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    \r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return \"(\" + this.expr.toCode() + \")\";\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.expr).isConst();\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        if ((<IExprInstruction>this.expr).evaluate()) {\r\n            this._evalResult = (<IExprInstruction>this.expr).getEvalValue();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","import { EInstructionTypes, IInstruction, ISamplerStateInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISamplerStateInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    value: IInstruction;\r\n}\r\n\r\nexport class SamplerStateInstruction extends Instruction implements ISamplerStateInstruction {\r\n    protected _name: string;\r\n    protected _value: IInstruction;\r\n\r\n    constructor({ name, value, ...settings }: ISamplerStateInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SamplerState, ...settings });\r\n        \r\n        this._name = name;\r\n        this._value = Instruction.$withParent(value, this);\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get value(): IInstruction {\r\n        return this.value;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        console.error(\"@not_implemented\");\r\n        return null;\r\n    }\r\n\r\n    toCode(): string {\r\n        console.error(\"@not_implmented\");\r\n        return null;\r\n    }\r\n}\r\n\r\n","import { assert, isDef, isDefAndNotNull, isNull, mwalk } from '@lib/common';\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ERenderStates } from '@lib/idl/ERenderStates';\r\nimport { ERenderStateValues } from '@lib/idl/ERenderStateValues';\r\nimport { ECheckStage, EInstructionTypes, EScopeType, ETechniqueType, IAnnotationInstruction, IAttributeInstruction, IConstructorCallInstruction, IDeclInstruction, IDoWhileOperator, IExprInstruction, IFunctionCallInstruction, IFunctionDeclInstruction, IFunctionDefInstruction, IIdExprInstruction, IIdInstruction, IInitExprInstruction, IInstruction, IInstructionCollector, IInstructionError, ILiteralInstruction, ILogicalOperator, IPassInstruction, IProvideInstruction, ISamplerStateInstruction, IScope, IStmtBlockInstruction, IStmtInstruction, ITechniqueInstruction, ITypeDeclInstruction, ITypedInstruction, ITypeInstruction, IUnaryOperator, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IParseNode, IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\n\r\nimport { AnalyzerDiagnostics } from '../AnalyzerDiagnostics';\r\nimport { visitor } from '../Visitors';\r\nimport { expression, instruction, type } from './helpers';\r\nimport { ArithmeticExprInstruction, ArithmeticOperator } from './instructions/ArithmeticExprInstruction';\r\nimport { AssigmentOperator, AssignmentExprInstruction } from \"./instructions/AssignmentExprInstruction\";\r\nimport { AttributeInstruction } from './instructions/AttributeInstruction';\r\nimport { BoolInstruction } from './instructions/BoolInstruction';\r\nimport { BreakOperator, BreakStmtInstruction } from './instructions/BreakStmtInstruction';\r\nimport { CastExprInstruction } from './instructions/CastExprInstruction';\r\nimport { CompileExprInstruction } from './instructions/CompileExprInstruction';\r\nimport { ComplexExprInstruction } from './instructions/ComplexExprInstruction';\r\nimport { ComplexTypeInstruction } from './instructions/ComplexTypeInstruction';\r\nimport { ConditionalExprInstruction } from './instructions/ConditionalExprInstruction';\r\nimport { ConstructorCallInstruction } from './instructions/ConstructorCallInstruction';\r\nimport { DeclStmtInstruction } from './instructions/DeclStmtInstruction';\r\nimport { ExprStmtInstruction } from './instructions/ExprStmtInstruction';\r\nimport { FloatInstruction } from './instructions/FloatInstruction';\r\nimport { ForStmtInstruction } from './instructions/ForStmtInstruction';\r\nimport { FunctionCallInstruction } from './instructions/FunctionCallInstruction';\r\nimport { FunctionDeclInstruction } from './instructions/FunctionDeclInstruction';\r\nimport { FunctionDefInstruction } from './instructions/FunctionDefInstruction';\r\nimport { IdExprInstruction } from './instructions/IdExprInstruction';\r\nimport { IdInstruction } from './instructions/IdInstruction';\r\nimport { IfStmtInstruction } from './instructions/IfStmtInstruction';\r\nimport { InitExprInstruction } from './instructions/InitExprInstruction';\r\nimport { Instruction } from './instructions/Instruction';\r\nimport { InstructionCollector } from './instructions/InstructionCollector';\r\nimport { IntInstruction } from './instructions/IntInstruction';\r\nimport { LogicalExprInstruction } from './instructions/LogicalExprInstruction';\r\nimport { PassInstruction } from './instructions/PassInstruction';\r\nimport { PostfixArithmeticInstruction, PostfixOperator } from './instructions/PostfixArithmeticInstruction';\r\nimport { PostfixIndexInstruction } from './instructions/PostfixIndexInstruction';\r\nimport { PostfixPointInstruction } from './instructions/PostfixPointInstruction';\r\nimport { ProvideInstruction } from \"./instructions/ProvideInstruction\";\r\nimport { ProxyTypeInstruction } from './instructions/ProxyTypeInstruction';\r\nimport { RelationalExprInstruction, RelationOperator } from './instructions/RelationalExprInstruction';\r\nimport { ReturnStmtInstruction } from './instructions/ReturnStmtInstruction';\r\nimport { SamplerOperator, SamplerStateBlockInstruction } from './instructions/SamplerStateBlockInstruction';\r\nimport { SamplerStateInstruction } from \"./instructions/SamplerStateInstruction\";\r\nimport { SemicolonStmtInstruction } from './instructions/SemicolonStmtInstruction';\r\nimport { StmtBlockInstruction } from './instructions/StmtBlockInstruction';\r\nimport { StringInstruction } from './instructions/StringInstruction';\r\nimport { SystemTypeInstruction } from './instructions/SystemTypeInstruction';\r\nimport { TechniqueInstruction } from './instructions/TechniqueInstruction';\r\nimport { TypeDeclInstruction } from './instructions/TypeDeclInstruction';\r\nimport { UnaryExprInstruction } from './instructions/UnaryExprInstruction';\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from './instructions/VariableDeclInstruction';\r\nimport { VariableTypeInstruction } from './instructions/VariableTypeInstruction';\r\nimport { WhileStmtInstruction } from './instructions/WhileStmtInstruction';\r\nimport { ProgramScope } from './ProgramScope';\r\nimport * as SystemScope from './SystemScope';\r\nimport { T_BOOL, T_INT, T_UINT, T_VOID } from './SystemScope';\r\n\r\ntype IErrorInfo = IMap<any>;\r\ntype IWarningInfo = IMap<any>;\r\n\r\n\r\nfunction validate(instr: IInstruction, expectedType: EInstructionTypes) {\r\n    assert(instr.instructionType === expectedType);\r\n}\r\n\r\n// TODO: refactor it\r\nfunction findConstructor(type: ITypeInstruction, args: IExprInstruction[]): IVariableTypeInstruction {\r\n    return new VariableTypeInstruction({ type, scope: null });\r\n}\r\n\r\n\r\nfunction _errorFromInstruction(context: Context, sourceNode: IParseNode, pError: IInstructionError): void {\r\n    context.error(sourceNode, pError.code, isNull(pError.info) ? {} : pError.info);\r\n}\r\n\r\n\r\nfunction checkInstruction<INSTR_T extends IInstruction>(context: Context, inst: INSTR_T, stage: ECheckStage): INSTR_T {\r\n    // TODO: rework this api\r\n    if (!inst._check(stage)) {\r\n        _errorFromInstruction(context, inst.sourceNode, inst._getLastError());\r\n        return null;\r\n    }\r\n    return inst;\r\n}\r\n\r\nconst asType = (instr: ITypedInstruction): ITypeInstruction => instr ? instr.type : null;\r\n\r\n\r\n// FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\nconst asRelaxedType = (instr: ITypedInstruction): ITypeInstruction | RegExp => {\r\n    if (!instr) {\r\n        return null;\r\n    }\r\n\r\n    // if (instruction.isLiteral(instr)) {\r\n        if (instr.type.isEqual(T_INT) || instr.type.isEqual(T_UINT)) {\r\n            // temp workaround in order to match int to uint and etc. \r\n            return /^int$|^uint$/g;\r\n        }\r\n    // }\r\n\r\n    return instr.type;\r\n};\r\n\r\n// TODO: rework 'auto' api\r\nfunction tryResolveProxyType(type: IVariableTypeInstruction, host: ITypeInstruction) {\r\n    if (type.subType.instructionType === EInstructionTypes.k_ProxyType) {\r\n        const proxy = <ProxyTypeInstruction>type.subType;\r\n        if (!proxy.isResolved()) {\r\n            proxy.resolve(host);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction getRenderStateValue(state: ERenderStates, value: string): ERenderStateValues {\r\n    let eValue: ERenderStateValues = ERenderStateValues.UNDEF;\r\n\r\n    switch (state) {\r\n        case ERenderStates.ALPHABLENDENABLE:\r\n        case ERenderStates.ALPHATESTENABLE:\r\n            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');\r\n            return ERenderStateValues.UNDEF;\r\n\r\n        case ERenderStates.BLENDENABLE:\r\n        case ERenderStates.CULLFACEENABLE:\r\n        case ERenderStates.ZENABLE:\r\n        case ERenderStates.ZWRITEENABLE:\r\n        case ERenderStates.DITHERENABLE:\r\n        case ERenderStates.SCISSORTESTENABLE:\r\n        case ERenderStates.STENCILTESTENABLE:\r\n        case ERenderStates.POLYGONOFFSETFILLENABLE:\r\n            switch (value) {\r\n                case 'TRUE':\r\n                    eValue = ERenderStateValues.TRUE;\r\n                    break;\r\n                case 'FALSE':\r\n                    eValue = ERenderStateValues.FALSE;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '\r\n                        + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.CULLFACE:\r\n            switch (value) {\r\n                case 'FRONT':\r\n                    eValue = ERenderStateValues.FRONT;\r\n                    break;\r\n                case 'BACK':\r\n                    eValue = ERenderStateValues.BACK;\r\n                    break\r\n                case 'FRONT_AND_BACK':\r\n                    eValue = ERenderStateValues.FRONT_AND_BACK;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.FRONTFACE:\r\n            switch (value) {\r\n                case 'CW':\r\n                    eValue = ERenderStateValues.CW;\r\n                    break;\r\n                case 'CCW':\r\n                    eValue = ERenderStateValues.CCW;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.SRCBLEND:\r\n        case ERenderStates.DESTBLEND:\r\n        case ERenderStates.SRCBLENDALPHA:\r\n        case ERenderStates.DESTBLENDALPHA:\r\n        case ERenderStates.SRCBLENDCOLOR:\r\n        case ERenderStates.DESTBLENDCOLOR:\r\n        case ERenderStates.BLENDFUNC:\r\n        case ERenderStates.BLENDFUNCSEPARATE:\r\n            switch (value) {\r\n                case 'ZERO':\r\n                    eValue = ERenderStateValues.ZERO;\r\n                    break;\r\n                case 'ONE':\r\n                    eValue = ERenderStateValues.ONE;\r\n                    break;\r\n                case 'SRCCOLOR':\r\n                    eValue = ERenderStateValues.SRCCOLOR;\r\n                    break;\r\n                case 'INVSRCCOLOR':\r\n                    eValue = ERenderStateValues.INVSRCCOLOR;\r\n                    break;\r\n                case 'SRCALPHA':\r\n                    eValue = ERenderStateValues.SRCALPHA;\r\n                    break;\r\n                case 'INVSRCALPHA':\r\n                    eValue = ERenderStateValues.INVSRCALPHA;\r\n                    break;\r\n                case 'DESTALPHA':\r\n                    eValue = ERenderStateValues.DESTALPHA;\r\n                    break;\r\n                case 'INVDESTALPHA':\r\n                    eValue = ERenderStateValues.INVDESTALPHA;\r\n                    break;\r\n                case 'DESTCOLOR':\r\n                    eValue = ERenderStateValues.DESTCOLOR;\r\n                    break;\r\n                case 'INVDESTCOLOR':\r\n                    eValue = ERenderStateValues.INVDESTCOLOR;\r\n                    break;\r\n                case 'SRCALPHASAT':\r\n                    eValue = ERenderStateValues.SRCALPHASAT;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.BLENDEQUATION:\r\n        case ERenderStates.BLENDEQUATIONSEPARATE:\r\n        case ERenderStates.BLENDEQUATIONCOLOR:\r\n        case ERenderStates.BLENDEQUATIONALPHA:\r\n            switch (value) {\r\n                case 'FUNCADD':\r\n                case 'ADD':\r\n                    eValue = ERenderStateValues.FUNCADD;\r\n                    break;\r\n                case 'FUNCSUBTRACT':\r\n                case 'SUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCSUBTRACT;\r\n                    break;\r\n                case 'FUNCREVERSESUBTRACT':\r\n                case 'REVERSESUBTRACT':\r\n                    eValue = ERenderStateValues.FUNCREVERSESUBTRACT;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n\r\n        case ERenderStates.ZFUNC:\r\n            switch (value) {\r\n                case 'NEVER':\r\n                    eValue = ERenderStateValues.NEVER;\r\n                    break;\r\n                case 'LESS':\r\n                    eValue = ERenderStateValues.LESS;\r\n                    break;\r\n                case 'EQUAL':\r\n                    eValue = ERenderStateValues.EQUAL;\r\n                    break;\r\n                case 'LESSEQUAL':\r\n                    eValue = ERenderStateValues.LESSEQUAL;\r\n                    break;\r\n                case 'GREATER':\r\n                    eValue = ERenderStateValues.GREATER;\r\n                    break;\r\n                case 'NOTEQUAL':\r\n                    eValue = ERenderStateValues.NOTEQUAL;\r\n                    break;\r\n                case 'GREATEREQUAL':\r\n                    eValue = ERenderStateValues.GREATEREQUAL;\r\n                    break;\r\n                case 'ALWAYS':\r\n                    eValue = ERenderStateValues.ALWAYS;\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n        case ERenderStates.PRIMITIVETOPOLOGY:\r\n            switch (value) {\r\n                case 'TRIANGLELIST':\r\n                    eValue = ERenderStateValues.TRIANGLELIST;\r\n                    break;\r\n                case 'LINELIST':\r\n                    eValue = ERenderStateValues.LINELIST;\r\n                    break;\r\n                default:\r\n                    console.warn('Unsupported render state ZFUNC value used: ' +\r\n                        value + '.');\r\n                    return eValue;\r\n            }\r\n            break;\r\n    }\r\n\r\n    return eValue;\r\n}\r\n\r\n\r\n\r\n\r\nfunction addTypeDecl(context: Context, scope: IScope, typeDecl: ITypeDeclInstruction): void {\r\n    if (SystemScope.findType(typeDecl.name)) {\r\n        context.error(typeDecl.sourceNode, EErrors.SystemTypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n\r\n    let isAdded = scope.addType(typeDecl.type);\r\n    if (!isAdded) {\r\n        context.error(typeDecl.sourceNode, EErrors.TypeRedefinition, { typeName: typeDecl.name });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction checkFunctionForRecursion(context: Context, func: IFunctionDeclInstruction, stack: number[]): boolean {\r\n    if (stack.indexOf(func.instructionID) !== -1) {\r\n        context.error(func.sourceNode,\r\n            EErrors.InvalidFunctionRecursionNotAllowed,\r\n            { funcName: func.name });\r\n        return false;\r\n    }\r\n\r\n    let recursionFound = false;\r\n\r\n    stack = [...stack, func.instructionID];\r\n    const recursionChecker = (instr: IInstruction) => {\r\n        if (instr.instructionType === EInstructionTypes.k_FunctionCallExpr) {\r\n            let fcall = (instr as IFunctionCallInstruction);\r\n            let fdecl = fcall.decl;\r\n            if (fdecl.instructionType === EInstructionTypes.k_SystemFunctionDecl) {\r\n                return;\r\n            }\r\n\r\n            // NOTE: it is possible that the declaration was not complete \r\n            //       at the time of the call, so you need to look for a \r\n            //       version with implementation\r\n            fdecl = fdecl.scope.findFunctionInScope(fdecl);\r\n            if (isNull(fdecl.impl)) {\r\n                context.error(instr.sourceNode,\r\n                    EErrors.InvalidFunctionImplementationNotFound,\r\n                    { funcName: fdecl.name });\r\n                return;\r\n            }\r\n\r\n            // visitor(fdecl.impl, recursionChecker);\r\n            recursionFound = recursionFound ||\r\n                checkFunctionForRecursion(context, fdecl, stack);\r\n        }\r\n    };\r\n\r\n    visitor(func.impl, recursionChecker);\r\n\r\n    return !recursionFound;\r\n}\r\n\r\nfunction checkFunctionsForRecursion(context: Context, program: ProgramScope) {\r\n    const gs = program.globalScope;\r\n\r\n    let recusrionFound = false;\r\n    mwalk(gs.functions, funcOverloads => {\r\n        funcOverloads.forEach(func => {\r\n            recusrionFound = recusrionFound ||\r\n                !checkFunctionForRecursion(context, func, []);\r\n        })\r\n    });\r\n\r\n    return !recusrionFound;\r\n}\r\n\r\n\r\n\r\nfunction checkForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForVertexUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    if (!checkReturnTypeForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    if (!checkArgumentsForPixelUsage(funcDef)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nfunction checkReturnTypeForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    const returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (returnType.isEqual(SystemScope.T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    if (returnType.isComplex()) {\r\n        if (returnType.hasFieldWithoutSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        if (!returnType.hasAllUniqueSemantics()) {\r\n            return false;\r\n        }\r\n\r\n        // isGood = returnType._hasFieldWithSematic(\"POSITION\");\r\n        // if(!isGood){\r\n        // \treturn false;\r\n        // }\r\n\r\n        // samplers cant be interpolators\r\n        if (returnType.isContainSampler()) {\r\n            return false;\r\n        }\r\n\r\n        // Forbid fileds with user-defined types\r\n        // or any other complex types.\r\n        if (returnType.isContainComplexType()) {\r\n            return false;\r\n        }\r\n    } else {\r\n        if (!returnType.isEqual(SystemScope.T_FLOAT4)) {\r\n            return false;\r\n        }\r\n\r\n        if (funcDef.semantic !== \"POSITION\") {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// todo: add support for dual source blending\r\n// todo: add support for MRT\r\nfunction checkReturnTypeForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let returnType = <IVariableTypeInstruction>funcDef.returnType;\r\n\r\n    if (returnType.isEqual(SystemScope.T_VOID)) {\r\n        return true;\r\n    }\r\n\r\n    // TODO: add MRT support\r\n    if (!returnType.isBase()) {\r\n        return false;\r\n    }\r\n\r\n    if (!returnType.isEqual(SystemScope.T_FLOAT4)) {\r\n        return false;\r\n    }\r\n\r\n    if (funcDef.semantic !== \"COLOR\") {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForVertexUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isAttributeByStruct = false;\r\n    let isAttributeByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (isNull(param.semantic)) {\r\n                if (param.type.isBase() ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics()) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByStruct = true;\r\n            } else if (!isNull(param.semantic)) {\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isAttributeByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        } else if (isAttributeByStruct) {\r\n            return false;\r\n        } else if (isAttributeByParams) {\r\n            if (isNull(param.semantic)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction checkArgumentsForPixelUsage(funcDef: IFunctionDefInstruction): boolean {\r\n    let params = funcDef.params;\r\n    let isVaryingsByStruct = false;\r\n    let isVaryingsByParams = false;\r\n    let isStartAnalyze = false;\r\n\r\n    for (let i: number = 0; i < params.length; i++) {\r\n        let param: IVariableDeclInstruction = params[i];\r\n\r\n        if (param.type.isUniform()) {\r\n            continue;\r\n        }\r\n\r\n        if (!isStartAnalyze) {\r\n            if (param.semantic === \"\") {\r\n                if (param.type.isBase() ||\r\n                    param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics() ||\r\n                    param.type.isContainSampler()) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByStruct = true;\r\n            } else if (param.semantic !== \"\") {\r\n                if (param.type.isContainSampler() ||\r\n                    SystemScope.isSamplerType(param.type)) {\r\n                    return false;\r\n                }\r\n\r\n                if (param.type.isComplex() &&\r\n                    (param.type.hasFieldWithoutSemantics() ||\r\n                        !param.type.hasAllUniqueSemantics())) {\r\n                    return false;\r\n                }\r\n\r\n                isVaryingsByParams = true;\r\n            }\r\n\r\n            isStartAnalyze = true;\r\n        }\r\n        else if (isVaryingsByStruct) {\r\n            return false;\r\n        }\r\n        else if (isVaryingsByParams) {\r\n            if (param.semantic === \"\") {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isContainSampler() ||\r\n                SystemScope.isSamplerType(param.type)) {\r\n                return false;\r\n            }\r\n\r\n            if (param.type.isComplex() &&\r\n                (param.type.hasFieldWithoutSemantics() ||\r\n                    !param.type.hasAllUniqueSemantics())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\nexport interface ICompileValidator {\r\n    // validate with custom arguments ignoring statements inside compile expression.\r\n    args?: ITypeInstruction[];\r\n    ret?: ITypeInstruction;\r\n}\r\n\r\n\r\n\r\nexport class Context {\r\n    readonly uri: string | null;\r\n    readonly diagnostics: AnalyzerDiagnostics;\r\n\r\n    /** driven from provide declaration */\r\n    moduleName: string | null;\r\n\r\n    // funct states\r\n    func: boolean;                              // Are we inside a function analysis?\r\n    funcDef: IFunctionDefInstruction | null;    // Current function definition.\r\n    haveCurrentFunctionReturnOccur: boolean;    // TODO: replace with array of return statements.\r\n\r\n    renderStates: IMap<ERenderStateValues>;\r\n\r\n    constructor(uri: string) {\r\n        this.diagnostics = new AnalyzerDiagnostics;\r\n        this.uri = uri;\r\n        this.moduleName = null;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n    }\r\n\r\n\r\n    beginFunc(): void {\r\n        this.func = true;\r\n        this.haveCurrentFunctionReturnOccur = false;\r\n        this.funcDef = null; // << will be set inside analyzeFunctionDecl();\r\n    }\r\n\r\n    endFunc(): void {\r\n        this.func = false\r\n    }\r\n\r\n\r\n    beginPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n    endPass(): void {\r\n        this.renderStates = null;\r\n    }\r\n\r\n\r\n    error(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.error(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    critical(sourceNode: IParseNode, code: number, info: IErrorInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.critical(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    warn(sourceNode: IParseNode, code: number, info: IWarningInfo = {}): void {\r\n        let loc = this.resolveNodeSourceLocation(sourceNode);\r\n        let file = this.uri;\r\n\r\n        this.diagnostics.warning(code, { file, loc, info });\r\n    }\r\n\r\n\r\n    private resolveNodeSourceLocation(sourceNode: IParseNode): IRange {\r\n        if (!isDefAndNotNull(sourceNode)) {\r\n            return null;\r\n        }\r\n\r\n        if (isDef(sourceNode.loc)) {\r\n            return sourceNode.loc;\r\n        }\r\n\r\n        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class Analyzer {\r\n\r\n\r\n    protected analyzeUseDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): void {\r\n        program.currentScope.strictMode = true;\r\n    }\r\n\r\n\r\n    protected analyzeComplexName(sourceNode: IParseNode): string {\r\n        const children = sourceNode.children;\r\n        let name: string = '';\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            name += children[i].value;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ProvideDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_PROVIDE = 'provide'\r\n     */\r\n    protected analyzeProvideDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IProvideInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children.length === 3) {\r\n            let moduleName = this.analyzeComplexName(children[1]);;\r\n            if (!isNull(context.moduleName)) {\r\n                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);\r\n            }\r\n            context.moduleName = moduleName;\r\n            assert(children[2].name === 'T_KW_PROVIDE');\r\n            return new ProvideInstruction({ sourceNode, moduleName, scope });\r\n        }\r\n\r\n        context.error(sourceNode, EErrors.UnsupportedProvideAs);\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    InitExpr\r\n     *         T_UINT = '0'\r\n     */\r\n    protected analyzeInitExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IInitExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let args: IExprInstruction[] = [];\r\n\r\n        if (children.length === 1) {\r\n            args.push(this.analyzeExpr(context, program, children[0]));\r\n        }\r\n        else {\r\n            for (let i = 0; i < children.length; i++) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    args.push(this.analyzeInitExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: determ type!!\r\n        const initExpr: IInitExprInstruction = new InitExprInstruction({ scope, sourceNode, args, type: null });\r\n        return initExpr;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVariableDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);\r\n        const vars: IVariableDeclInstruction[] = [];\r\n\r\n        if (isNull(generalType)) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars.push(this.analyzeVariable(context, program, children[i], generalType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UsageType\r\n     *       + Type \r\n     *       + Usage \r\n     */\r\n    protected analyzeUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        let usagesRaw: IVariableUsage[] = [];\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null\r\n                }\r\n            }\r\n            else if (children[i].name === 'Usage') {\r\n                usagesRaw.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        const usageIn = usagesRaw.indexOf('in') !== -1;\r\n        const usageOut = usagesRaw.indexOf('out') !== -1;\r\n        const usageInout = usagesRaw.indexOf('inout') !== -1;\r\n        const usageConst = usagesRaw.indexOf('const') !== -1;\r\n        const usageUniform = usagesRaw.indexOf('uniform') !== -1;\r\n\r\n        // TODO: emit errors in case of inconsistent usages\r\n        // TODO: remplace with bitflags\r\n        let usages: IVariableUsage[] = [];\r\n        if (usageInout) {\r\n            usages.push('inout');\r\n            // emit error in case of uniform\r\n            // emit error in case of const\r\n        } else {\r\n            if (usageIn && usageOut) {\r\n                usages.push('inout');\r\n                // emit error in case of uniform\r\n                // emit error in case of const\r\n            } else {\r\n                if (usageIn) {\r\n                    usages.push('in');\r\n                }\r\n                if (usageOut) {\r\n                    usages.push('out');\r\n                    // emit error in case of const\r\n                    // emit error in case of uniform\r\n                } else {\r\n                    if (usageConst) usages.push('const');\r\n                    if (usageUniform) usages.push('uniform');\r\n                }\r\n            }\r\n        }\r\n\r\n        let varType = new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n        return checkInstruction(context, varType, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Type\r\n     *         T_TYPE_ID = 'float3'\r\n     */\r\n    protected analyzeType(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n\r\n        switch (sourceNode.name) {\r\n            case 'T_TYPE_ID':\r\n                if (sourceNode.value === 'auto') {\r\n                    type = new ProxyTypeInstruction({ scope });\r\n                    break;\r\n                }\r\n\r\n                type = scope.findType(sourceNode.value);\r\n\r\n                if (isNull(type)) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });\r\n                }\r\n                break;\r\n            case 'Struct':\r\n                type = this.analyzeStruct(context, program, sourceNode);\r\n                break;\r\n\r\n            case 'T_KW_VOID':\r\n                type = T_VOID;\r\n                break;\r\n\r\n            case 'ScalarType':\r\n            case 'ObjectType':\r\n                {\r\n                    let typeName = children[children.length - 1].value;\r\n\r\n                    if (children.length !== 1) {\r\n                        assert(children[children.length - 2].value === '<' && children[0].value === '>');\r\n                        const tplName = typeName;\r\n                        const args = children\r\n                            .slice(1, -2)\r\n                            .reverse()\r\n                            .filter((v, i) => i % 2 == 0)\r\n                            .map(sourceNode => this.analyzeType(context, program, sourceNode));\r\n\r\n                        const template = scope.findTypeTemplate(typeName);\r\n\r\n                        if (isNull(template)) {\r\n                            context.error(sourceNode, EErrors.InvalidTypeNameTemplateNotFound,\r\n                                { tplName, args: args.map(arg => arg.toCode()) });\r\n                            return null;\r\n                        }\r\n\r\n                        // TODO: validate register\r\n                        // TODO: use ESystemTypes enumeration\r\n                        const SYSTEM_TYPES = ['RWBuffer', 'RWStructuredBuffer', 'AppendStructuredBuffer'];\r\n                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {\r\n                            if (scope.type != EScopeType.k_Global) {\r\n                                context.error(sourceNode, EErrors.InvalidTypeScope,\r\n                                    { typeName: template.name, tooltip: 'only global scope allowed' });\r\n                                return null;\r\n                            }\r\n                        }\r\n\r\n                        typeName = template.typeName(args);\r\n                        type = scope.findType(typeName);\r\n\r\n                        if (isNull(type)) {\r\n                            type = template.produceType(scope, args);\r\n                            if (isNull(type)) {\r\n                                context.error(sourceNode, EErrors.CannotProduceType, { typeName });\r\n                                return null;\r\n                            }\r\n                            scope.addType(type);\r\n                        }\r\n                    } else {\r\n                        type = scope.findType(typeName);\r\n                    }\r\n\r\n                    if (isNull(type)) {\r\n                        context.error(sourceNode, EErrors.InvalidTypeNameNotType, { typeName });\r\n                        return null;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case 'VectorType':\r\n            case 'MatrixType':\r\n                context.error(sourceNode, EErrors.InvalidTypeVectorMatrix);\r\n                break;\r\n\r\n            case 'BaseType':\r\n            case 'Type':\r\n                return this.analyzeType(context, program, children[0]);\r\n        }\r\n\r\n        return type;\r\n    }\r\n\r\n\r\n    protected analyzeUsage(sourceNode: IParseNode): IVariableUsage {\r\n        sourceNode = sourceNode.children[0];\r\n        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout'];\r\n        assert(supportedUsages.indexOf(sourceNode.value) !== -1);\r\n        return <IVariableUsage>sourceNode.value;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Variable\r\n     *       + Initializer \r\n     *       + Semantic \r\n     *       + VariableDim\r\n     *              T_PUNCTUATOR_93 = ']'\r\n     *              T_NON_TYPE_ID = 'N'\r\n     *              T_PUNCTUATOR_91 = '['\r\n     *            + VariableDim\r\n     *                   T_NON_TYPE_ID = 'x'\r\n     *                   ^^^^^^^^^^^^^^^^^^\r\n     */\r\n    protected analyzeVariable(context: Context, program: ProgramScope, sourceNode: IParseNode, generalType: IVariableTypeInstruction): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let init: IInitExprInstruction = null;\r\n        let semantic = '';\r\n        let usageFlags = 0;\r\n\r\n        if (!context.func) {\r\n            usageFlags |= EVariableUsageFlags.k_Global;\r\n        } else {\r\n            // All variables found inside function definition are arguments.\r\n            if (!context.funcDef) {\r\n                usageFlags |= EVariableUsageFlags.k_Argument;\r\n            }\r\n            usageFlags |= EVariableUsageFlags.k_Local;\r\n        }\r\n\r\n\r\n        let id: IIdInstruction = null;\r\n        let arrayIndex: IExprInstruction = null;\r\n        let type: IVariableTypeInstruction = null;\r\n\r\n        let vdimNode = children[children.length - 1];\r\n        do {\r\n            let vdimChildren = vdimNode.children;\r\n\r\n            if (vdimChildren.length === 1) {\r\n                const name = vdimChildren[0].value;\r\n                id = new IdInstruction({ scope, sourceNode, name });\r\n                break;\r\n            }\r\n\r\n            assert(vdimChildren.length == 4);\r\n\r\n            if (!isNull(arrayIndex)) {\r\n                // usage of generalType.source node instead of sourceNode was done for more clear debugging\r\n                generalType = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n            }\r\n\r\n            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);\r\n            vdimNode = vdimChildren[vdimChildren.length - 1];\r\n        } while (true);\r\n\r\n        // using generalType.source node instead of sourceNode was done for more clear degging\r\n        type = new VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });\r\n\r\n        for (let i = children.length - 2; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else if (children[i].name === 'Initializer') {\r\n                let args = this.analyzeInitializerArguments(context, program, children[i]);\r\n                init = new InitExprInstruction({ scope, sourceNode: children[i], args, type });\r\n\r\n                let isValidInit = false;\r\n                try {\r\n                    isValidInit = init.optimizeForVariableType(type);\r\n                } catch (e) { };\r\n\r\n                if (!isValidInit) {\r\n                    // TODO: make it warning\r\n                    context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n                    init = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        const varDecl = new VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });\r\n        assert(scope.type != EScopeType.k_System);\r\n\r\n        if (SystemScope.hasVariable(varDecl.name)) {\r\n            context.error(sourceNode, EErrors.SystemVariableRedefinition, { varName: varDecl.name });\r\n        }\r\n\r\n        const isAdded = scope.addVariable(varDecl);\r\n        if (!isAdded) {\r\n            switch (scope.type) {\r\n                case EScopeType.k_Global:\r\n                case EScopeType.k_Default:\r\n                    context.error(sourceNode, EErrors.VariableRedefinition, { varName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Struct:\r\n                    context.error(sourceNode, EErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });\r\n                    break;\r\n                case EScopeType.k_Annotation:\r\n                    context.error(sourceNode, EErrors.InvalidNewAnnotationVar, { varName: varDecl.name });\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return checkInstruction(context, varDecl, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Annotation\r\n     *         T_PUNCTUATOR_62 = '>'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     */\r\n    protected analyzeAnnotation(sourceNode: IParseNode): IAnnotationInstruction {\r\n        // todo\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_NON_TYPE_ID = 'SEMANTIC'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    Semantic\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'u2'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_REGISTER = 'register'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     */\r\n    protected analyzeSemantic(sourceNode: IParseNode): string {\r\n        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Initializer\r\n     *         T_UINT = '10'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *       + CastExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *    Initializer\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + InitExpr \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     */\r\n    protected analyzeInitializerArguments(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction[] {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let args: IExprInstruction[] = [];\r\n\r\n        if (children.length === 2) {\r\n            args.push(this.analyzeExpr(context, program, children[0]));\r\n        }\r\n        else {\r\n            for (let i = children.length - 3; i >= 1; i--) {\r\n                if (children[i].name === 'InitExpr') {\r\n                    args.push(this.analyzeInitExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        return args;\r\n    }\r\n\r\n\r\n\r\n    protected analyzeExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n\r\n        switch (name) {\r\n            case 'ObjectExpr':\r\n                return this.analyzeObjectExpr(context, program, sourceNode);\r\n            case 'ComplexExpr':\r\n                return this.analyzeComplexExpr(context, program, sourceNode);\r\n            case 'PostfixExpr':\r\n                return this.analyzePostfixExpr(context, program, sourceNode);\r\n            case 'UnaryExpr':\r\n                return this.analyzeUnaryExpr(context, program, sourceNode);\r\n            case 'CastExpr':\r\n                return this.analyzeCastExpr(context, program, sourceNode);\r\n            case 'ConditionalExpr':\r\n                return this.analyzeConditionalExpr(context, program, sourceNode);\r\n            case 'MulExpr':\r\n            case 'AddExpr':\r\n                return this.analyzeArithmeticExpr(context, program, sourceNode);\r\n            case 'RelationalExpr':\r\n            case 'EqualityExpr':\r\n                return this.analyzeRelationExpr(context, program, sourceNode);\r\n            case 'AndExpr':\r\n            case 'OrExpr':\r\n                return this.analyzeLogicalExpr(context, program, sourceNode);\r\n            case 'AssignmentExpr':\r\n                return this.analyzeAssignmentExpr(context, program, sourceNode);\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeIdExpr(context, program, sourceNode);\r\n            case 'T_STRING':\r\n            case 'T_UINT':\r\n            case 'T_FLOAT':\r\n            case 'T_KW_TRUE':\r\n            case 'T_KW_FALSE':\r\n                return this.analyzeSimpleExpr(context, program, sourceNode);\r\n            default:\r\n                context.error(sourceNode, EErrors.UnsupportedExpr, { exprName: name });\r\n                break;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'fs_skybox'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeObjectExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        let name = sourceNode.children[sourceNode.children.length - 1].name;\r\n\r\n        switch (name) {\r\n            case 'T_KW_COMPILE':\r\n                return this.analyzeCompileExpr(context, program, sourceNode);\r\n            case 'T_KW_SAMPLER_STATE':\r\n                return this.analyzeSamplerStateBlock(context, program, sourceNode);\r\n            default:\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'main'\r\n     *         T_KW_COMPILE = 'compile'\r\n     */\r\n    protected analyzeCompileExpr(context: Context, program: ProgramScope, sourceNode: IParseNode, validators?: ICompileValidator[]): CompileExprInstruction {\r\n        const children = sourceNode.children;\r\n        const shaderFuncName = children[children.length - 2].value;\r\n        const scope = program.currentScope;\r\n\r\n        let compileArgs: IExprInstruction[] = null;\r\n        let retType: ITypeInstruction = null;\r\n        let args: ITypeInstruction[] = null;\r\n\r\n        if (children.length > 4) {\r\n            compileArgs = [];\r\n            for (let i = children.length - 4; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    compileArgs.push(this.analyzeExpr(context, program, children[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        args = compileArgs ? compileArgs.map(asType) : null;\r\n\r\n        let func: IFunctionDeclInstruction = null;\r\n\r\n        if (validators) {\r\n            for (let validator of validators) {\r\n                args = compileArgs ? compileArgs.map(asType) : null;\r\n                retType = null;\r\n\r\n                args = validator.args || args;\r\n                retType = validator.ret || retType;\r\n\r\n                func = program.globalScope.findFunction(shaderFuncName, args);\r\n                if (func) {\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            func = program.globalScope.findFunction(shaderFuncName, args);\r\n        }\r\n\r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });\r\n            return null;\r\n        }\r\n\r\n        if (retType) {\r\n            if (!func.def.returnType.isEqual(retType)) {\r\n                context.error(sourceNode, EErrors.InvalidCompileFunctionNotValid, {\r\n                    funcName: shaderFuncName,\r\n                    funcType: retType.toCode(),\r\n                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `\r\n                });\r\n                return null;\r\n            }\r\n        }\r\n\r\n        let type = VariableTypeInstruction.wrap(<IVariableTypeInstruction>func.def.returnType, scope);\r\n\r\n        let expr = new CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ObjectExpr\r\n     *       + StateBlock \r\n     *         T_KW_SAMPLER_STATE = 'sampler_state'\r\n     */\r\n    protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        sourceNode = sourceNode.children[0];\r\n\r\n        let scope = program.currentScope;\r\n        let children = sourceNode.children;\r\n        let operator: SamplerOperator = \"sampler_state\";\r\n        let texture = null;\r\n        let params = <ISamplerStateInstruction[]>[];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let param = this.analyzeSamplerState(context, program, children[i]);\r\n            if (!isNull(param)) {\r\n                params.push(param);\r\n            }\r\n        }\r\n\r\n        let expr = new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });\r\n        checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return expr;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    State\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         StateExpr\r\n     *              T_PUNCTUATOR_62 = '>'\r\n     *              T_NON_TYPE_ID = 'tex0'\r\n     *              T_PUNCTUATOR_60 = '<'\r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'Texture'\r\n     */\r\n    protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (children[children.length - 2].name === 'StateIndex') {\r\n            context.error(sourceNode, EErrors.UnsupportedStateIndex);\r\n            return null;\r\n        }\r\n\r\n        let stateExprNode = children[children.length - 3];\r\n        let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n        let stateType = children[children.length - 1].value.toUpperCase();\r\n        let stateValue = '';\r\n\r\n        if (isNull(subStateExprNode.value)) {\r\n            context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n            return null;\r\n        }\r\n\r\n        switch (stateType) {\r\n            case 'TEXTURE':\r\n                if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {\r\n                    context.error(subStateExprNode, EErrors.InvalidSamplerTexture);\r\n                    return null;\r\n                }\r\n\r\n                let texNameNode = stateExprNode.children[1];\r\n                let texName = texNameNode.value;\r\n                if (isNull(texName) || !scope.findVariable(texName)) {\r\n                    context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);\r\n                    return null;\r\n                }\r\n\r\n                let texDecl = scope.findVariable(texName);\r\n                let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });\r\n                let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });\r\n\r\n                return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });\r\n            case 'ADDRESSU': /* WRAP_S */\r\n            case 'ADDRESSV': /* WRAP_T */\r\n                stateValue = subStateExprNode.value.toUpperCase();\r\n                switch (stateValue) {\r\n                    case 'WRAP':\r\n                    case 'CLAMP':\r\n                    case 'MIRROR':\r\n                        break;\r\n                    default:\r\n                        // TODO: move to errors\r\n                        // console.warn('Webgl don`t support this wrapmode: ' + stateValue);\r\n                        return null;\r\n                }\r\n                break;\r\n\r\n            case 'MAGFILTER':\r\n            case 'MINFILTER':\r\n                stateValue = subStateExprNode.value.toUpperCase();\r\n                switch (stateValue) {\r\n                    case 'POINT':\r\n                        stateValue = 'NEAREST';\r\n                        break;\r\n                    case 'POINT_MIPMAP_POINT':\r\n                        stateValue = 'NEAREST_MIPMAP_NEAREST';\r\n                        break;\r\n                    case 'LINEAR_MIPMAP_POINT':\r\n                        stateValue = 'LINEAR_MIPMAP_NEAREST';\r\n                        break;\r\n                    case 'POINT_MIPMAP_LINEAR':\r\n                        stateValue = 'NEAREST_MIPMAP_LINEAR';\r\n                        break;\r\n\r\n                    case 'NEAREST':\r\n                    case 'LINEAR':\r\n                    case 'NEAREST_MIPMAP_NEAREST':\r\n                    case 'LINEAR_MIPMAP_NEAREST':\r\n                    case 'NEAREST_MIPMAP_LINEAR':\r\n                    case 'LINEAR_MIPMAP_LINEAR':\r\n                        break;\r\n                    default:\r\n                        // TODO: move to erros api\r\n                        // console.warn('Webgl don`t support this texture filter: ' + stateValue);\r\n                        return null;\r\n                }\r\n                break;\r\n\r\n            default:\r\n                // TODO: move to erros api\r\n                console.warn('Don`t support this texture param: ' + stateType);\r\n                return null;\r\n        }\r\n\r\n        return new SamplerStateInstruction({\r\n            sourceNode,\r\n            scope,\r\n            name: stateType,\r\n            value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_FLOAT = '2.'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_FLOAT = '1.'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_TYPE_ID = 'float4'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + PostfixPointExpr \r\n     */\r\n    protected analyzeComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'PostfixPointExpr':\r\n            case 'T_NON_TYPE_ID':\r\n                return this.analyzeFunctionCallExpr(context, program, sourceNode);\r\n            case 'BaseType':\r\n            case 'T_TYPE_ID':\r\n                return this.analyzeConstructorCallExpr(context, program, sourceNode);\r\n            default:\r\n                return this.analyzeSimpleComplexExpr(context, program, sourceNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    protected analyzeCallee(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        return this.analyzeExpr(context, program, children[children.length - 1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_NON_TYPE_ID = 'a'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'foo'\r\n     */\r\n    /**\r\n     * AST example:\r\n     *    PostfixPointExpr\r\n     *         T_NON_TYPE_ID = 'IncrementCounter'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *       + PostfixExpr \r\n     */\r\n    protected analyzeFunctionCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        \r\n        const firstNodeName = children[children.length - 1].name;\r\n \r\n        const args: IExprInstruction[] = [];\r\n        if (children.length > 3) {\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    const arg = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(arg);\r\n                }\r\n            }\r\n        }\r\n\r\n        let funcName: string = null;\r\n        let func: IFunctionDeclInstruction = null;\r\n        let callee: IExprInstruction = null;\r\n\r\n        switch (firstNodeName) {\r\n            // call as function\r\n            case 'T_NON_TYPE_ID':\r\n                {\r\n                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address\r\n                    funcName = children[children.length - 1].value;\r\n                    func = globalScope.findFunction(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n            // call as method\r\n            case 'PostfixPointExpr':\r\n                {\r\n                    callee = this.analyzeCallee(context, program, children[children.length - 1]);\r\n                    funcName = children[children.length - 1].children[0].value; // method name\r\n                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));\r\n                }\r\n                break;\r\n        }\r\n        \r\n\r\n        if (isNull(func)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName });\r\n            return null;\r\n        }\r\n\r\n\r\n        if (func.instructionType !== EInstructionTypes.k_FunctionDecl &&\r\n            func.instructionType !== EInstructionTypes.k_SystemFunctionDecl) {\r\n            console.error(\"@undefined_behavior\");\r\n            return null;\r\n        }\r\n\r\n\r\n\r\n        const params = func.def.params;\r\n\r\n        for (let i = 0; i < args.length; i++) {\r\n            if (isNull(args[i])) {\r\n                continue;\r\n            }\r\n            if (params[i].type.hasUsage('out')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                    return null;\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                    return null;\r\n                }\r\n            } else if (params[i].type.hasUsage('inout')) {\r\n                const decl = expression.unwind(args[i]);\r\n                if (isNull(decl)) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidExprIsNotLValue);\r\n                    return null;\r\n                }\r\n                if (!args[i].type.writable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForWriting);\r\n                    return null;\r\n                }\r\n\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            } else {\r\n                if (!args[i].type.readable) {\r\n                    context.error(args[i].sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        const type = VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?\r\n        const expr = new FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });\r\n\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ComplexExpr\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *       + BaseType \r\n     */\r\n    protected analyzeConstructorCallExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IConstructorCallInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const ctorType = this.analyzeType(context, program, children[children.length - 1]);\r\n\r\n        if (isNull(ctorType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotType);\r\n            return null;\r\n        }\r\n\r\n        let args: IExprInstruction[] = null;\r\n        if (children.length > 3) {\r\n            let argumentExpr: IExprInstruction = null;\r\n\r\n            args = [];\r\n\r\n            for (let i = children.length - 3; i > 0; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = this.analyzeExpr(context, program, children[i]);\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: add correct implementation! \r\n        const exprType = findConstructor(ctorType, args);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(args)) {\r\n            for (let i = 0; i < args.length; i++) {\r\n                if (!args[i].type.readable) {\r\n                    context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n        const expr = new ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    // TODO: add comment!\r\n    protected analyzeSimpleComplexExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[1]);\r\n        if (isNull(expr)) {\r\n            return null\r\n        }\r\n        // let type = <IVariableTypeInstruction>expr.type;\r\n\r\n        let complexExpr = new ComplexExprInstruction({ scope, sourceNode, expr });\r\n        return checkInstruction(context, complexExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const symbol = children[children.length - 2].value;\r\n\r\n        switch (symbol) {\r\n            case '[':\r\n                return this.analyzePostfixIndex(context, program, sourceNode);\r\n            case '.':\r\n                return this.analyzePostfixPoint(context, program, sourceNode);\r\n            case '++':\r\n            case '--':\r\n                return this.analyzePostfixArithmetic(context, program, sourceNode);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    protected analyzePostfixIndex(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(postfixExpr)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        if (!postfixExprType.isArray()) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });\r\n            return null;\r\n        }\r\n\r\n        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const indexExprType = indexExpr.type;\r\n\r\n        if (!(indexExprType.isEqual(T_INT) || indexExprType.isEqual(T_UINT))) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     * @param fieldName \r\n     */\r\n    protected createFieldDecl(elementType: IVariableTypeInstruction, fieldName: string): IVariableDeclInstruction {\r\n        if (!elementType.hasField(fieldName)) {\r\n            return null;\r\n        }\r\n\r\n        // in case of typical postfix exp. like \"element.postfix\":\r\n        //      elementType => type defrived from the parameter or variable declaration or derived from another expr\r\n        //      elementType.subType => original complex (structure) type\r\n        // in case of something else, like ccall with postfix \"float2(1.0, 2.0).yx\":\r\n        //      elementType => original system type\r\n\r\n        const scope = elementType.scope;\r\n        const { id, type, type: { padding, length }, semantic } =\r\n            // FIXME: remove 'logical OR' operation, always use subType\r\n            (elementType.subType || elementType).getField(fieldName); // arrayIndex\r\n\r\n\r\n\r\n        // note: sourceNode for field is being used from the original complex structure.\r\n\r\n        // let arrayIndex: IExprInstruction = null;\r\n        // if (type.isNotBaseArray()) {\r\n        //     // using of length instead of arrayIndex because of lack of api functionality :/\r\n        //     assert(length != Instruction.UNDEFINE_LENGTH, \"undefined behaviour found\");\r\n        //     arrayIndex = new IntInstruction({ scope, value: String(length) });\r\n        // }\r\n\r\n        const fieldType = new VariableTypeInstruction({ type, scope, padding, sourceNode: type.sourceNode/*, arrayIndex*/ });\r\n        const fieldId = new IdInstruction({ scope, name: id.name, sourceNode: id.sourceNode });\r\n        const field = new VariableDeclInstruction({ scope, id: fieldId, type: fieldType, semantic, sourceNode: fieldId.sourceNode });\r\n\r\n        return Instruction.$withParent(field, elementType);\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param elementType Type of the element. (**element.postfix**)\r\n     */\r\n    protected analyzePostfixPointField(context: Context, program: ProgramScope, sourceNode: IParseNode, elementType: IVariableTypeInstruction): IIdExprInstruction {\r\n        if (isNull(elementType)) {\r\n            return null;\r\n        }\r\n\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;                             // fiedl name\r\n        // const decl = this.createFieldDecl(elementType, name);   // field decl\r\n        const decl = elementType.getField(name);\r\n\r\n        if (isNull(decl)) {\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        const expr = new IdExprInstruction({ scope, sourceNode, id, decl });\r\n\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_NON_TYPE_ID = 'val'\r\n     *         T_PUNCTUATOR_46 = '.'\r\n     *         T_NON_TYPE_ID = 'some'\r\n     */\r\n    /** \r\n     * Expressions like: \r\n     *      **(element.postfix)** \r\n     */\r\n    protected analyzePostfixPoint(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const element = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        if (isNull(element)) {\r\n            // TODO: emit error?\r\n            return null;\r\n        }\r\n\r\n        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);\r\n\r\n        if (isNull(postfix)) {\r\n            const fieldName = children[children.length - 3].value;\r\n            context.error(sourceNode, EErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixPointInstruction({ sourceNode, scope, element, postfix });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PostfixExpr\r\n     *         T_OP_INC = '++'\r\n     *         T_NON_TYPE_ID = 'b'\r\n     */\r\n    protected analyzePostfixArithmetic(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <PostfixOperator>children[0].value;\r\n\r\n        const postfixExpr = this.analyzeExpr(context, program, children[1]);\r\n        const postfixExprType = <IVariableTypeInstruction>postfixExpr.type;\r\n\r\n        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidPostfixArithmetic, {\r\n                operator: operator,\r\n                typeName: String(postfixExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const expr = new PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    UnaryExpr\r\n     *         T_NON_TYPE_ID = 'x'\r\n     *         T_PUNCTUATOR_33 = '!'\r\n     */\r\n    protected analyzeUnaryExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const operator = <IUnaryOperator>children[1].value;\r\n        const scope = program.currentScope;\r\n\r\n        let expr = this.analyzeExpr(context, program, children[0]);\r\n        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidUnaryOperation, {\r\n                operator: operator,\r\n                tyename: String(expr.type)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        let unaryExpr: IExprInstruction = null;\r\n\r\n        // shortcut for replacment of unary expressions with literals\r\n        if (operator === '-' || operator === '+') {\r\n            if (instruction.isLiteral(expr)) {\r\n                switch (expr.instructionType) {\r\n                    case EInstructionTypes.k_IntExpr:\r\n                        {\r\n                            let lit = <IntInstruction>expr;\r\n                            let signed = operator === '-' || lit.signed;\r\n                            unaryExpr = new IntInstruction({ scope, sourceNode, value: Number(`${operator}${lit.value}`), signed });\r\n                        }\r\n                        break;\r\n                    case EInstructionTypes.k_FloatExpr:\r\n                        unaryExpr = new FloatInstruction({ scope, sourceNode, value: Number(`${operator}${(<ILiteralInstruction<number>>expr).value}`) });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!unaryExpr) {\r\n            unaryExpr = new UnaryExprInstruction({ scope, sourceNode, expr, operator });\r\n        }\r\n\r\n        return checkInstruction(context, unaryExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    CastExpr\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ConstType \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeCastExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const type = this.analyzeConstTypeDim(context, program, children[2]);\r\n        const sourceExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(sourceExpr)) {\r\n            return null;\r\n        }\r\n\r\n        if (!(<IVariableTypeInstruction>sourceExpr.type).readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        const expr = new CastExprInstruction({ scope, sourceNode, sourceExpr, type });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConditionalExpr\r\n     *         T_KW_FALSE = 'false'\r\n     *         T_PUNCTUATOR_58 = ':'\r\n     *         T_KW_TRUE = 'true'\r\n     *         T_PUNCTUATOR_63 = '?'\r\n     *         T_NON_TYPE_ID = 'isOk'\r\n     */\r\n    protected analyzeConditionalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n\r\n        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);\r\n        const rightExpr = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(conditionExpr) || isNull(leftExpr) || isNull(rightExpr)) {\r\n            context.error(conditionExpr ? conditionExpr.sourceNode : sourceNode, EErrors.InvalidConditionType, { typeName: '[unknown]' });\r\n            return null;\r\n        }\r\n\r\n        const conditionType = <IVariableTypeInstruction>conditionExpr.type;\r\n        const leftExprType = <IVariableTypeInstruction>leftExpr.type;\r\n        const rightExprType = <IVariableTypeInstruction>rightExpr.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!conditionType.isEqual(boolType)) {\r\n            context.error(conditionExpr.sourceNode, EErrors.InvalidConditionType, { typeName: String(conditionType) });\r\n            return null;\r\n        }\r\n\r\n        if (!leftExprType.isEqual(rightExprType)) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidConditonValueTypes, {\r\n                leftTypeName: String(leftExprType),\r\n                rightTypeName: String(rightExprType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!conditionType.readable) {\r\n            context.error(conditionType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!leftExprType.readable) {\r\n            context.error(leftExprType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!rightExprType.readable) {\r\n            context.error(rightExprType.sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        const condExpr = new ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });\r\n        return checkInstruction(context, condExpr, ECheckStage.CODE_TARGET_SUPPORT);;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AddExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_43 = '+'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeArithmeticExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope\r\n        const operator = <ArithmeticOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (!left || !right) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: '[unknown]',\r\n                rightTypeName: '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);\r\n\r\n        if (isNull(type)) {\r\n            context.error(sourceNode, EErrors.InvalidArithmeticOperation, {\r\n                operator: operator,\r\n                leftTypeName: String(leftType),\r\n                rightTypeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        const arithmeticExpr = new ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });\r\n        return checkInstruction(context, arithmeticExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    RelationalExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_PUNCTUATOR_60 = '<'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeRelationExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <RelationOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = left ? left.type : null;\r\n        const rightType = right ? right.type : null;\r\n\r\n        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator,\r\n            leftType, rightType,\r\n            left ? left.sourceNode : null,\r\n            right ? right.sourceNode : null);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidRelationalOperation, {\r\n                operator: operator,\r\n                leftTypeName: leftType ? type.signature(leftType) : '[unknown]',\r\n                rightTypeName: rightType ? type.signature(rightType) : '[unknown]'\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!left || !right) {\r\n            return null;\r\n        }\r\n\r\n        const relationExpr = new RelationalExprInstruction({ sourceNode, scope, left, right, operator });\r\n        return checkInstruction(context, relationExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    OrExpr\r\n     *         T_NON_TYPE_ID = 'b'\r\n     *         T_OP_OR = '||'\r\n     *         T_NON_TYPE_ID = 'a'\r\n     */\r\n    protected analyzeLogicalExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <ILogicalOperator>sourceNode.children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        const boolType = T_BOOL;\r\n\r\n        if (!leftType.isEqual(boolType)) {\r\n            context.error(leftType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(leftType)\r\n            });\r\n            return null;\r\n        }\r\n        if (!rightType.isEqual(boolType)) {\r\n            context.error(rightType.sourceNode, EErrors.InvalidLogicOperation, {\r\n                operator: operator,\r\n                typeName: String(rightType)\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (!leftType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        if (!rightType.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n        let logicalExpr = new LogicalExprInstruction({ scope, sourceNode, left, right, operator });\r\n        return checkInstruction(context, logicalExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    AssignmentExpr\r\n     *         T_UINT = '10'\r\n     *         T_OP_AE = '+='\r\n     *         T_NON_TYPE_ID = 'x'\r\n     */\r\n    protected analyzeAssignmentExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const operator = <AssigmentOperator>children[1].value;\r\n\r\n        const left = this.analyzeExpr(context, program, children[children.length - 1]);\r\n\r\n        if (!expression.unwind(left)) {\r\n            // Invalid left-hand side in assignment\r\n            context.error(sourceNode, EErrors.InvalidLeftHandSideInAssignment, {\r\n                operator: operator\r\n            });\r\n        }\r\n\r\n        const right = this.analyzeExpr(context, program, children[0]);\r\n\r\n        if (isNull(left) || isNull(right)) {\r\n            return null;\r\n        }\r\n\r\n        const leftType = <IVariableTypeInstruction>left.type;\r\n        const rightType = <IVariableTypeInstruction>right.type;\r\n\r\n        let exprType: IVariableTypeInstruction = null;\r\n\r\n        if (operator !== '=') {\r\n            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode);\r\n            if (isNull(exprType)) {\r\n                context.error(sourceNode, EErrors.InvalidArithmeticAssigmentOperation, {\r\n                    operator: operator,\r\n                    leftTypeName: type.signature(leftType),\r\n                    rightTypeName: type.signature(rightType)\r\n                });\r\n            }\r\n        } else {\r\n            exprType = rightType;\r\n        }\r\n\r\n        // FIXME: show corrent source nodes for left and right expression.\r\n        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType);\r\n\r\n        if (isNull(exprType)) {\r\n            context.error(sourceNode, EErrors.InvalidAssigmentOperation, {\r\n                leftTypeName: type.signature(leftType),\r\n                rightTypeName: type.signature(rightType)\r\n            });\r\n        }\r\n\r\n        let assigmentExpr = new AssignmentExprInstruction({ scope, sourceNode, left, right, operator });\r\n        return checkInstruction(context, assigmentExpr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    T_NON_TYPE_ID = 'name'\r\n     */\r\n    protected analyzeIdExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const scope = program.currentScope;\r\n        const name = sourceNode.value;\r\n        const decl = scope.findVariable(name);\r\n\r\n        if (isNull(decl)) {\r\n            context.error(sourceNode, EErrors.UnknownVarName, { varName: name });\r\n            return null;\r\n        }\r\n\r\n        const id = new IdInstruction({ scope, sourceNode, name });\r\n        const expr = new IdExprInstruction({ scope, sourceNode, id, decl });\r\n        return checkInstruction(context, expr, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    protected analyzeSimpleExpr(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const name = sourceNode.name;\r\n        const value = sourceNode.value;\r\n        const scope = program.currentScope;\r\n\r\n        switch (name) {\r\n            case 'T_UINT':\r\n                {\r\n                    const match = value.match(/^([0-9]+)(u?)$/);\r\n                    const signed = match[2] !== 'u';\r\n                    return new IntInstruction({ scope, sourceNode, value: Number(match[1]), signed });\r\n                }\r\n            case 'T_FLOAT':\r\n                return new FloatInstruction({ scope, sourceNode, value: Number(value) });\r\n            case 'T_STRING':\r\n                return new StringInstruction({ scope, sourceNode, value });\r\n            case 'T_KW_TRUE':\r\n                return new BoolInstruction({ scope, sourceNode, value: true });\r\n            case 'T_KW_FALSE':\r\n                return new BoolInstruction({ scope, sourceNode, value: false });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ConstType\r\n     *       + Type \r\n     */\r\n    protected analyzeConstTypeDim(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length > 1) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeUsage);\r\n            return null;\r\n        }\r\n\r\n        const type = <IVariableTypeInstruction>(this.analyzeType(context, program, children[0]));\r\n\r\n        if (!type.isBase()) {\r\n            context.error(sourceNode, EErrors.InvalidCastTypeNotBase, { typeName: String(type) });\r\n        }\r\n\r\n        return checkInstruction(context, type, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeVarStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n        const children = sourceNode.children;\r\n\r\n        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);\r\n        let vars: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'Variable') {\r\n                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));\r\n            }\r\n        }\r\n\r\n        return vars;\r\n    }\r\n\r\n\r\n    protected analyzeUsageStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'StructDecl') {\r\n                type = this.analyzeStructDecl(context, program, children[i]);\r\n                const typeDecl = new TypeDeclInstruction({ scope, sourceNode: children[i], type });\r\n                addTypeDecl(context, scope, typeDecl);\r\n            } else if (children[i].name === 'Usage') {\r\n                const usage = this.analyzeUsage(children[i]);\r\n                usages.push(usage);\r\n            }\r\n        }\r\n\r\n        assert(!isNull(type));\r\n        let varType = new VariableTypeInstruction({ scope, sourceNode, usages, type });\r\n        return checkInstruction(context, varType, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     *    Struct\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStruct(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let name: string = null;\r\n        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {\r\n            name = children[children.length - 2].value;\r\n        }\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const struct = new ComplexTypeInstruction({ scope, sourceNode, fields, name });\r\n        return checkInstruction(context, struct, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + FunctionDef \r\n     */\r\n    /**\r\n     * AST example:\r\n     *    FunctionDecl\r\n     *       + StmtBlock \r\n     *       + Annotation \r\n     *       + FunctionDef \r\n     */\r\n    protected analyzeFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IFunctionDeclInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const globalScope = program.globalScope;\r\n        const lastNodeValue = children[0].value;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let implementation: IStmtBlockInstruction = null;\r\n\r\n        program.push(EScopeType.k_Default);\r\n\r\n        const attributes = [];\r\n        while (children[children.length - 1 - attributes.length].name === 'Attribute') {\r\n            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));\r\n        }\r\n\r\n        const definition = this.analyzeFunctionDef(context, program, children[children.length - 1 - attributes.length]);\r\n\r\n        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)\r\n        let func = globalScope.findFunction(definition.name, definition.params.map(asType));\r\n\r\n        if (!isDef(func)) {\r\n            context.error(sourceNode, EErrors.CannotChooseFunction, { funcName: definition.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func) && func.impl) {\r\n            context.error(sourceNode, EErrors.FunctionRedefinition, { funcName: definition.name });\r\n            program.pop();\r\n            return null;\r\n        }\r\n\r\n        if (!isNull(func)) {\r\n            if (!func.def.returnType.isEqual(definition.returnType)) {\r\n                context.error(sourceNode, EErrors.InvalidFuncDefenitionReturnType, { funcName: definition.name });\r\n                program.pop();\r\n                return null;\r\n            }\r\n        }\r\n\r\n        assert(context.funcDef === null);\r\n\r\n        // TODO: rewrite context ?\r\n        context.funcDef = definition;\r\n\r\n        if (children.length === 3) {\r\n            annotation = this.analyzeAnnotation(children[1]);\r\n        }\r\n\r\n        if (lastNodeValue !== ';') {\r\n            // TODO: do to increase scope depth inside stmt block!!\r\n            implementation = this.analyzeStmtBlock(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        let hasVoidType = definition.returnType.isEqual(T_VOID);\r\n\r\n        // validate unreachable code.\r\n        if (!isNull(implementation)) {\r\n            let stmtList = implementation.stmtList;\r\n\r\n            // stmtList = stmtList.slice().reverse();\r\n            for (let i = stmtList.length - 1; i >= 0; --i) {\r\n                if (stmtList[i].instructionType == EInstructionTypes.k_ReturnStmt) {\r\n                    if (i != stmtList.length - 1) {\r\n                        context.error(stmtList[i + 1].sourceNode, EErrors.UnreachableCode);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        assert(scope == globalScope);\r\n        func = new FunctionDeclInstruction({ sourceNode, scope, definition, implementation, annotation, attributes });\r\n\r\n        // NOTE: possible implicit replacement of function \r\n        //       without implementaion inside addFunction() call.\r\n        if (!globalScope.addFunction(func)) {\r\n            context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: definition.name });\r\n        }\r\n\r\n        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !isNull(implementation)) {\r\n            context.error(sourceNode, EErrors.InvalidFunctionReturnStmtNotFound, { funcName: definition.name });\r\n        }\r\n\r\n        return func;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    FunctionDef\r\n     *       + ParamList \r\n     *         T_NON_TYPE_ID = 'bar'\r\n     *       + UsageType \r\n     */\r\n    protected analyzeFunctionDef(context: Context, program: ProgramScope, sourceNode: IParseNode): FunctionDefInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const nameNode = children[children.length - 2];\r\n        const name = nameNode.value;\r\n\r\n        const retTypeNode = children[children.length - 1];\r\n        let returnType = this.analyzeUsageType(context, program, retTypeNode);\r\n\r\n        // TODO: is it really needed?\r\n        if (returnType.isContainSampler()) {\r\n            context.error(retTypeNode, EErrors.InvalidFunctionReturnType, { funcName: name });\r\n            return null;\r\n        }\r\n\r\n        let id = new IdInstruction({ scope, name, sourceNode: nameNode });\r\n\r\n        let semantic: string = null;\r\n        if (children.length === 4) {\r\n            semantic = this.analyzeSemantic(children[0]);\r\n        }\r\n\r\n        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);\r\n        let funcDef = new FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic })\r\n\r\n        checkInstruction(context, funcDef, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return funcDef;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamList\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + ParameterDecl \r\n     *         T_PUNCTUATOR_40 = '('\r\n     */\r\n    protected analyzeParamList(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction[] {\r\n\r\n        const children = sourceNode.children;\r\n        let paramList: IVariableDeclInstruction[] = [];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            if (children[i].name === 'ParameterDecl') {\r\n                let param = this.analyzeParameterDecl(context, program, children[i]);\r\n                paramList.push(param);\r\n            }\r\n        }\r\n\r\n        return paramList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParameterDecl\r\n     *       + Variable \r\n     *       + ParamUsageType \r\n     */\r\n    protected analyzeParameterDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableDeclInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        const type = this.analyzeParamUsageType(context, program, children[1]);\r\n\r\n        if (isNull(type)) {\r\n            return null;\r\n        }\r\n\r\n        const param = this.analyzeVariable(context, program, children[0], type);\r\n\r\n        return param;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ParamUsageType\r\n     *       + Type \r\n     *       + ParamUsage \r\n     */\r\n    protected analyzeParamUsageType(context: Context, program: ProgramScope, sourceNode: IParseNode): IVariableTypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let usages: IVariableUsage[] = [];\r\n        let type: ITypeInstruction = null;\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            if (children[i].name === 'Type') {\r\n                type = this.analyzeType(context, program, children[i]);\r\n                if (isNull(type)) {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (children[i].name === 'ParamUsage') {\r\n                usages.push(this.analyzeUsage(children[i]));\r\n            }\r\n        }\r\n\r\n        let paramType = new VariableTypeInstruction({ scope, sourceNode, type, usages });\r\n        checkInstruction(context, paramType, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return paramType;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    StmtBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + Stmt \r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeStmtBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtBlockInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        if (!children) {\r\n            return null;\r\n        }\r\n\r\n        let stmtList: IStmtInstruction[] = [];\r\n        for (let i = children.length - 2; i > 0; i--) {\r\n            let stmt = this.analyzeStmt(context, program, children[i]);\r\n            if (!isNull(stmt)) {\r\n                stmtList.push(stmt);\r\n            }\r\n        }\r\n\r\n        const stmtBlock = new StmtBlockInstruction({ sourceNode, scope, stmtList });\r\n        checkInstruction(context, stmtBlock, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return stmtBlock;\r\n    }\r\n\r\n\r\n    protected analyzeStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const children = sourceNode.children;\r\n        let nonAttrNode = children.length;\r\n        let nonAttrNodeName: string;\r\n\r\n        do {\r\n            nonAttrNodeName = children[--nonAttrNode].name;\r\n        } while (nonAttrNodeName === 'Attribute');\r\n\r\n        switch (nonAttrNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, children[0]);\r\n                return null;\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n            case 'T_KW_IF':\r\n                return this.analyzeIfStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeSimpleStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const firstNodeName: string = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'T_KW_RETURN':\r\n                return this.analyzeReturnStmt(context, program, sourceNode);\r\n\r\n            case 'T_KW_DO':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n\r\n            case 'StmtBlock':\r\n                {\r\n                    program.push(EScopeType.k_Default);\r\n                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);\r\n                    program.pop();\r\n                    return stmtBlock;\r\n                }\r\n            case 'T_KW_DISCARD':\r\n            case 'T_KW_BREAK':\r\n            case 'T_KW_CONTINUE':\r\n                return this.analyzeBreakStmt(context, program, sourceNode);\r\n\r\n            case 'TypeDecl':\r\n            case 'VariableDecl':\r\n            case 'VarStructDecl':\r\n                return this.analyzeDeclStmt(context, program, children[0]);\r\n\r\n            default:\r\n                if (children.length === 2) {\r\n                    return this.analyzeExprStmt(context, program, sourceNode);\r\n                }\r\n\r\n                return new SemicolonStmtInstruction({ sourceNode, scope });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_NON_TYPE_ID = 'y'\r\n     *         T_KW_RETURN = 'return'\r\n     */\r\n    protected analyzeReturnStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        assert(context.func);\r\n\r\n        const funcReturnType = context.funcDef.returnType;\r\n        context.haveCurrentFunctionReturnOccur = true;\r\n        \r\n        if (children.length === 2) {\r\n            tryResolveProxyType(funcReturnType, T_VOID);\r\n        }\r\n\r\n        if (funcReturnType.isEqual(T_VOID) && children.length === 3) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtVoid);\r\n            return null;\r\n        }\r\n        else if (!funcReturnType.isEqual(T_VOID) && children.length === 2) {\r\n            context.error(sourceNode, EErrors.InvalidReturnStmtEmpty);\r\n            return null;\r\n        }   \r\n\r\n        let expr: IExprInstruction = null;\r\n        if (children.length === 3) {\r\n            expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n            if (isNull(expr)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n\r\n            tryResolveProxyType(funcReturnType, expr.type);\r\n\r\n            if (!funcReturnType.isEqual(expr.type)) {\r\n                context.error(sourceNode, EErrors.InvalidReturnStmtTypesNotEqual);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const returnStmtInstruction = new ReturnStmtInstruction({ sourceNode, scope, expr });\r\n        checkInstruction(context, returnStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return returnStmtInstruction;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_KW_BREAK = 'break'\r\n     */\r\n    protected analyzeBreakStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        const operator: BreakOperator = <BreakOperator>children[1].value;\r\n\r\n        if (operator === 'discard' && !isNull(context.funcDef)) {\r\n            // context.currentFunction.vertex = (false);\r\n        }\r\n\r\n        const breakStmtInstruction = new BreakStmtInstruction({ sourceNode, scope, operator });\r\n        checkInstruction(context, breakStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return breakStmtInstruction;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    VariableDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *         T_PUNCTUATOR_44 = ','\r\n     *       + Variable \r\n     *       + UsageType \r\n     */\r\n    protected analyzeDeclStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const nodeName = sourceNode.name;\r\n\r\n        let declList: IDeclInstruction[] = [];\r\n\r\n        switch (nodeName) {\r\n            case 'TypeDecl':\r\n                declList.push(this.analyzeTypeDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VariableDecl':\r\n                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));\r\n                break;\r\n            case 'VarStructDecl':\r\n                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));\r\n                break;\r\n        }\r\n\r\n        const declStmtInstruction = new DeclStmtInstruction({ sourceNode, scope, declList });\r\n        checkInstruction(context, declStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return declStmtInstruction;\r\n    }\r\n\r\n\r\n    protected analyzeExprStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const expr = this.analyzeExpr(context, program, children[1]);\r\n\r\n        const exprStmt = new ExprStmtInstruction({ sourceNode, scope, expr });\r\n        checkInstruction(context, exprStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return exprStmt;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *    SimpleStmt\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_WHILE = 'while'\r\n     *       + Stmt \r\n     *         T_KW_DO = 'do'\r\n     */\r\n    protected analyzeWhileStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isDoWhile = (children[children.length - 1].value === 'do');\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;\r\n        const boolType = T_BOOL;\r\n\r\n\r\n        let cond: IExprInstruction = null;\r\n        let conditionType: IVariableTypeInstruction = null;\r\n        let body: IStmtInstruction = null;\r\n        let operator: IDoWhileOperator = \"do\";\r\n\r\n        if (isDoWhile) {\r\n            operator = \"do\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!conditionType.isEqual(boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            operator = \"while\";\r\n            cond = this.analyzeExpr(context, program, children[2]);\r\n            conditionType = <IVariableTypeInstruction>cond.type;\r\n\r\n            if (!conditionType.isEqual(boolType)) {\r\n                context.error(sourceNode, EErrors.InvalidWhileCondition, { typeName: String(conditionType) });\r\n                return null;\r\n            }\r\n\r\n            if (isNonIfStmt) {\r\n                body = this.analyzeNonIfStmt(context, program, children[0]);\r\n            }\r\n            else {\r\n                body = this.analyzeStmt(context, program, children[0]);\r\n            }\r\n        }\r\n\r\n        const whileStmt = new WhileStmtInstruction({ sourceNode, scope, cond, body, operator });\r\n        checkInstruction(context, whileStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return whileStmt;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Attribute\r\n     *         T_PUNCTUATOR_93 = ']'\r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '3'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '2'\r\n     *         T_PUNCTUATOR_44 = ','\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_NON_TYPE_ID = 'loop'\r\n     *         T_PUNCTUATOR_91 = '['\r\n     */\r\n    protected analyzeAttribute(context: Context, program: ProgramScope, sourceNode: IParseNode): IAttributeInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const name = children[children.length - 2].value;\r\n\r\n        let args: ILiteralInstruction<number | boolean>[] = null;\r\n\r\n        if (children.length > 3) {\r\n            let argumentExpr: ILiteralInstruction<boolean | number> = null;\r\n\r\n            args = [];\r\n            for (let i = children.length - 4; i > 1; i--) {\r\n                if (children[i].value !== ',') {\r\n                    argumentExpr = <ILiteralInstruction<number | boolean>>this.analyzeSimpleExpr(context, program, children[i]);\r\n\r\n                    // TODO: emit diagnostics error\r\n                    assert(\r\n                        argumentExpr.instructionType === EInstructionTypes.k_BoolExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_FloatExpr ||\r\n                        argumentExpr.instructionType === EInstructionTypes.k_IntExpr);\r\n\r\n                    args.push(argumentExpr);\r\n                }\r\n            }\r\n        }\r\n\r\n        return new AttributeInstruction({ scope, sourceNode, name, args });\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    Stmt\r\n     *       + Stmt \r\n     *         T_KW_ELSE = 'else'\r\n     *       + NonIfStmt \r\n     *         T_PUNCTUATOR_41 = ')'\r\n     *         T_UINT = '1'\r\n     *         T_PUNCTUATOR_40 = '('\r\n     *         T_KW_IF = 'if'\r\n     *       + Attribute \r\n     *       + Attribute \r\n     */\r\n    protected analyzeIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n\r\n        let attributes = [];\r\n        while (children[children.length - 1 - attributes.length].name === 'Attribute') {\r\n            attributes.push(this.analyzeAttribute(context, program, children[children.length - 1 - attributes.length]));\r\n        }\r\n\r\n        const isIfElse = (children.length - attributes.length === 7);\r\n\r\n        const cond = this.analyzeExpr(context, program, children[children.length - 3 - attributes.length]);\r\n\r\n        if (!cond || !cond.type.isEqual(T_BOOL)) {\r\n            context.error(sourceNode, EErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });\r\n        }\r\n\r\n        let conseq: IStmtInstruction = null;\r\n        let contrary: IStmtInstruction = null;\r\n\r\n        if (isIfElse) {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[2]);\r\n            contrary = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            conseq = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n\r\n        if (!cond) {\r\n            return null;\r\n        }\r\n\r\n        const ifStmt = new IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attributes });\r\n        checkInstruction(context, ifStmt, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return ifStmt;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    NonIfStmt\r\n     *       + SimpleStmt \r\n     */\r\n    protected analyzeNonIfStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'SimpleStmt':\r\n                return this.analyzeSimpleStmt(context, program, children[0]);\r\n            case 'T_KW_WHILE':\r\n                return this.analyzeWhileStmt(context, program, sourceNode);\r\n            case 'T_KW_FOR':\r\n                return this.analyzeForStmt(context, program, sourceNode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeForStmt(context: Context, program: ProgramScope, sourceNode: IParseNode): IStmtInstruction {\r\n        const scope = program.currentScope;\r\n        const children = sourceNode.children;\r\n        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');\r\n\r\n        let body: IStmtInstruction = null;\r\n        let init: ITypedInstruction = null;\r\n        let cond: IExprInstruction = null;\r\n        let step: IExprInstruction = null;\r\n\r\n\r\n        if (children[1].name === 'ERROR') {\r\n            return null;\r\n        }\r\n\r\n        program.push();\r\n\r\n        init = this.analyzeForInit(context, program, children[children.length - 3]);\r\n        cond = this.analyzeForCond(context, program, children[children.length - 4]);\r\n        step = null;\r\n\r\n        if (children.length === 7) {\r\n            step = this.analyzeForStep(context, program, children[2]);\r\n        }\r\n\r\n        if (isNonIfStmt) {\r\n            body = this.analyzeNonIfStmt(context, program, children[0]);\r\n        }\r\n        else {\r\n            body = this.analyzeStmt(context, program, children[0]);\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const pForStmtInstruction = new ForStmtInstruction({ sourceNode, scope, init, cond, step, body });\r\n        checkInstruction(context, pForStmtInstruction, ECheckStage.CODE_TARGET_SUPPORT);\r\n\r\n        return pForStmtInstruction;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + AssignmentExpr \r\n     *    ForInit\r\n     *       + VariableDecl \r\n     *    ForInit\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + Expr \r\n     */\r\n    protected analyzeForInit(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypedInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const firstNodeName = children[children.length - 1].name;\r\n\r\n        switch (firstNodeName) {\r\n            case 'VariableDecl':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeVariableDecl(context, program, children[0])[0] || null;\r\n            case 'Expr':\r\n                // TODO: fixme!! \r\n                // add support for expressions like \"a = 1, b = 2, c = 3\"\r\n                return this.analyzeExpr(context, program, children[0]);\r\n        }\r\n\r\n        // ForInit : ';'\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForCond\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + RelationalExpr \r\n     */\r\n    protected analyzeForCond(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n\r\n        if (children.length === 1) {\r\n            return null;\r\n        }\r\n\r\n        return this.analyzeExpr(context, program, children[1]);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    ForStep\r\n     *       + UnaryExpr \r\n     */\r\n    protected analyzeForStep(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {\r\n        const children = sourceNode.children;\r\n        if (children.length == 0) {\r\n            return null;\r\n        }\r\n        const step = this.analyzeExpr(context, program, children[0]);\r\n        return step;\r\n    }\r\n\r\n\r\n    protected analyzeTechniqueDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITechniqueInstruction {\r\n        const children = sourceNode.children;\r\n        const name = this.analyzeComplexName(children[children.length - 2]);\r\n        // Specifies whether name should be interpreted as globalNamespace.name or just a name;\r\n        const isComplexName = children[children.length - 2].children.length !== 1;\r\n        const scope = program.currentScope;\r\n\r\n        let annotation: IAnnotationInstruction = null;\r\n        let semantic: string = null;\r\n        let passList: IPassInstruction[] = null;\r\n        let techniqueType: ETechniqueType = ETechniqueType.k_BasicFx;\r\n\r\n        for (let i = children.length - 3; i >= 0; i--) {\r\n            if (children[i].name === 'Annotation') {\r\n                annotation = this.analyzeAnnotation(children[i]);\r\n            } else if (children[i].name === 'Semantic') {\r\n                semantic = this.analyzeSemantic(children[i]);\r\n            } else {\r\n                passList = this.analyzeTechnique(context, program, children[i]);\r\n            }\r\n        }\r\n\r\n        const technique = new TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passList, scope });\r\n        Analyzer.addTechnique(context, program, technique);\r\n        return technique;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    TechniqueBody\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassDecl \r\n     *       + PassDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzeTechnique(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction[] {\r\n        const children = sourceNode.children;\r\n        let passList: IPassInstruction[] = [];\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let pass = this.analyzePassDecl(context, program, children[i]);\r\n            assert(!isNull(pass));\r\n            passList.push(pass);\r\n        }\r\n        return passList;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassDecl\r\n     *       + PassStateBlock \r\n     *       + Annotation \r\n     *         T_NON_TYPE_ID = 'name'\r\n     *         T_KW_PASS = 'pass'\r\n     */\r\n    protected analyzePassDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IPassInstruction {\r\n\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);\r\n        const renderStates = this.analyzePassStateBlock(context, program, children[0]);\r\n\r\n        let id: IIdInstruction = null;\r\n        for (let i = 0; i < children.length; ++i) {\r\n            if (children[i].name === \"T_NON_TYPE_ID\") {\r\n                let name = children[i].value;\r\n                id = new IdInstruction({ scope, name });\r\n            }\r\n        }\r\n\r\n        const pass = new PassInstruction({\r\n            scope,\r\n            sourceNode,\r\n            renderStates,\r\n            id,\r\n            pixelShader: entry.pixel,\r\n            vertexShader: entry.vertex\r\n        });\r\n        //TODO: add annotation and id\r\n\r\n        return pass;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'VertexShader'\r\n     */\r\n    protected analyzePassStateBlockForShaders(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode): { vertex: IFunctionDeclInstruction; pixel: IFunctionDeclInstruction; } {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        let pixel: IFunctionDeclInstruction = null;\r\n        let vertex: IFunctionDeclInstruction = null;\r\n\r\n        const supportedTypeNames = ['vertexshader', 'pixelshader'];\r\n\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            let func: IFunctionDeclInstruction = null;\r\n\r\n            const childrenIth = children[i].children;\r\n            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();\r\n\r\n            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);\r\n\r\n            if (!isNull(func)) {\r\n                switch (shaderTypeName) {\r\n                    case 'vertexshader':\r\n                        assert(vertex == null);\r\n                        vertex = func;\r\n                        break;\r\n                    case 'pixelshader':\r\n                        assert(pixel == null);\r\n                        pixel = func;\r\n                        break;\r\n                    default:\r\n                        // TODO: make error!\r\n                        console.error('function is not suitable as shader entry point');\r\n                }\r\n            }\r\n        }\r\n\r\n        return { vertex, pixel };\r\n    }\r\n\r\n\r\n    protected analyzePassStateForShader(context: Context, program: ProgramScope,\r\n        sourceNode: IParseNode, shaderType: string): IFunctionDeclInstruction {\r\n\r\n        assert(shaderType === 'vertexshader' || shaderType === 'pixelshader');\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        const compileExpr = <CompileExprInstruction>this.analyzeExpr(context, program, exprNode);\r\n        const shaderFunc = compileExpr.function;\r\n\r\n        if (shaderType === 'vertexshader') {\r\n            if (!checkForVertexUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n        else {\r\n            if (!checkForPixelUsage(shaderFunc.def)) {\r\n                context.error(sourceNode, EErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });\r\n            }\r\n        }\r\n\r\n        return shaderFunc;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassStateBlock\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + PassState \r\n     *       + PassState \r\n     *       + PassState \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     */\r\n    protected analyzePassStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n        const children = sourceNode.children;\r\n        let states: IMap<ERenderStateValues> = {}\r\n        for (let i = children.length - 2; i >= 1; i--) {\r\n            states = { ...states, ...this.analyzePassState(context, program, children[i]) };\r\n        }\r\n        return states;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    PassState\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + PassStateExpr \r\n     *         T_PUNCTUATOR_61 = '='\r\n     *         T_NON_TYPE_ID = 'ZWRITE'\r\n     */\r\n    protected analyzePassState(context: Context, program: ProgramScope, sourceNode: IParseNode): IMap<ERenderStateValues> {\r\n\r\n        const children = sourceNode.children;\r\n\r\n        const stateType = children[children.length - 1].value.toUpperCase();\r\n        const stateName = ERenderStates[stateType] || null;\r\n\r\n        if (isNull(stateName)) {\r\n            return {};\r\n        }\r\n\r\n        const stateExprNode = children[children.length - 3];\r\n        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];\r\n\r\n        if (isNull(exprNode.value)) {\r\n            console.warn('Pass state is incorrect.'); // TODO: move to warnings\r\n            return {};\r\n        }\r\n\r\n        let renderStates: IMap<ERenderStateValues> = {};\r\n        if (exprNode.value === '{' && stateExprNode.children.length > 3) {\r\n            const values: ERenderStateValues[] = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));\r\n            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {\r\n                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());\r\n            }\r\n\r\n            switch (stateName) {\r\n                case ERenderStates.BLENDFUNC:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[0];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[1];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDFUNCSEPARATE:\r\n                    if (values.length !== 4) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];\r\n                    renderStates[ERenderStates.SRCBLENDALPHA] = values[2];\r\n                    renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];\r\n                    renderStates[ERenderStates.DESTBLENDALPHA] = values[3];\r\n                    break;\r\n\r\n                case ERenderStates.BLENDEQUATIONSEPARATE:\r\n                    if (values.length !== 2) {\r\n                        console.warn('Pass state are incorrect.');\r\n                        return {};\r\n                    }\r\n                    renderStates[ERenderStates.BLENDEQUATIONCOLOR] = values[0];\r\n                    renderStates[ERenderStates.BLENDEQUATIONALPHA] = values[1];\r\n                    break;\r\n\r\n                default:\r\n                    console.warn('Pass state is incorrect.');\r\n                    return {};\r\n            }\r\n        }\r\n        else {\r\n            let value: string = '';\r\n            if (exprNode.value === '{') {\r\n                value = stateExprNode.children[1].value.toUpperCase();\r\n            }\r\n            else {\r\n                value = exprNode.value.toUpperCase();\r\n            }\r\n\r\n            const stateValue = getRenderStateValue(stateName, value);\r\n\r\n            if (stateValue !== ERenderStateValues.UNDEF) {\r\n                switch (stateName) {\r\n                    case ERenderStates.SRCBLEND:\r\n                        renderStates[ERenderStates.SRCBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.SRCBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.DESTBLEND:\r\n                        renderStates[ERenderStates.DESTBLENDCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.DESTBLENDALPHA] = stateValue;\r\n                        break;\r\n                    case ERenderStates.BLENDEQUATION:\r\n                        renderStates[ERenderStates.BLENDEQUATIONCOLOR] = stateValue;\r\n                        renderStates[ERenderStates.BLENDEQUATIONALPHA] = stateValue;\r\n                        break;\r\n                    default:\r\n                        renderStates[stateName] = stateValue;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return renderStates;\r\n    }\r\n\r\n    /**\r\n     * AST example:\r\n     *    ImportDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + ComplexNameOpt \r\n     *         T_KW_IMPORT = 'import'\r\n     */\r\n    // TODO: restore functionality! \r\n    protected analyzeImportDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): null {\r\n        const children = sourceNode.children;\r\n        const componentName = this.analyzeComplexName(children[children.length - 2]);\r\n\r\n        // if (!isNull(technique)) {\r\n        //     //We can import techniques from the same file, but on this stage they don`t have component yet.\r\n        //     //So we need special mehanism to add them on more belated stage\r\n        //     // let sShortedComponentName: string = componentName;\r\n        //     if (!isNull(context.moduleName)) {\r\n        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + \".\", \"\");\r\n        //     }\r\n\r\n        //     throw null;\r\n        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];\r\n        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {\r\n        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);\r\n        //     //     return;\r\n        //     // }\r\n        // }\r\n\r\n        const sourceTechnique: ITechniqueInstruction = null;//fx.techniques[componentName];\r\n        if (!sourceTechnique) {\r\n            context.error(sourceNode, EErrors.ImportedComponentNotExists, { componentName: componentName });\r\n            return null;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    StructDecl\r\n     *         T_PUNCTUATOR_125 = '}'\r\n     *       + VariableDecl \r\n     *         T_PUNCTUATOR_123 = '{'\r\n     *         T_NON_TYPE_ID = 'S'\r\n     *         T_KW_STRUCT = 'struct'\r\n     */\r\n    protected analyzeStructDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n        const name = children[children.length - 2].value;\r\n\r\n        program.push(EScopeType.k_Struct);\r\n\r\n        let fields: IVariableDeclInstruction[] = [];\r\n        for (let i = children.length - 4; i >= 1; i--) {\r\n            if (children[i].name === 'VariableDecl') {\r\n                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));\r\n            }\r\n        }\r\n\r\n        program.pop();\r\n\r\n        const struct = new ComplexTypeInstruction({ scope, sourceNode, name, fields });\r\n        return checkInstruction(context, struct, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    /**\r\n     * AST example:\r\n     *    TypeDecl\r\n     *         T_PUNCTUATOR_59 = ';'\r\n     *       + StructDecl \r\n     */\r\n    protected analyzeTypeDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): ITypeDeclInstruction {\r\n        const children = sourceNode.children;\r\n        const scope = program.currentScope;\r\n\r\n        let type: ITypeInstruction = null;\r\n        if (children.length === 2) {\r\n            type = this.analyzeStructDecl(context, program, children[1]);\r\n        }\r\n        else {\r\n            context.error(sourceNode, EErrors.UnsupportedTypeDecl);\r\n        }\r\n\r\n\r\n        let typeDecl = new TypeDeclInstruction({ scope, sourceNode, type });\r\n        addTypeDecl(context, scope, typeDecl);\r\n        return checkInstruction(context, typeDecl, ECheckStage.CODE_TARGET_SUPPORT);\r\n    }\r\n\r\n\r\n    protected analyzeUnknDecl(context: Context, program: ProgramScope, sourceNode: IParseNode): IInstruction[] {\r\n        switch (sourceNode.name) {\r\n            case 'TechniqueDecl':\r\n                return [this.analyzeTechniqueDecl(context, program, sourceNode)];\r\n            case 'UseDecl':\r\n                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!\r\n                return null;\r\n            case 'ImportDecl':\r\n                return [this.analyzeImportDecl(context, program, sourceNode)];\r\n            case 'ProvideDecl':\r\n                return [this.analyzeProvideDecl(context, program, sourceNode)];\r\n            case 'TypeDecl':\r\n                return [this.analyzeTypeDecl(context, program, sourceNode)];\r\n            case 'VariableDecl':\r\n                return this.analyzeVariableDecl(context, program, sourceNode);\r\n            case 'VarStructDecl':\r\n                return this.analyzeVarStructDecl(context, program, sourceNode);\r\n            case 'FunctionDecl':\r\n                assert(program.currentScope == program.globalScope);\r\n                let fdecl = null;\r\n                context.beginFunc();\r\n                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);\r\n                context.endFunc();\r\n                return [fdecl];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected analyzeGlobals(context: Context, program: ProgramScope, slastDocument: ISLASTDocument): IInstruction[] {\r\n        if (isNull(slastDocument) || isNull(slastDocument.root)) {\r\n            return null;\r\n        }\r\n\r\n        const children = slastDocument.root.children;\r\n        let globals: IInstruction[] = [];\r\n\r\n        if (isNull(children)) {\r\n            return [];\r\n        }\r\n\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));\r\n        }\r\n\r\n        return globals.filter(decl => !!decl);\r\n    }\r\n\r\n\r\n    protected createContext(uri: string): Context {\r\n        return new Context(uri);\r\n    }\r\n\r\n    protected createProgram(document: ISLDocument = null): ProgramScope {\r\n        let parent = <IScope>SystemScope.SCOPE;\r\n        if (!isNull(document)) {\r\n            parent = document.root.scope;\r\n        }\r\n        return new ProgramScope(parent);\r\n    }\r\n\r\n    /**\r\n     * Post-analysis validation.\r\n     */\r\n    protected validate(context: Context, program: ProgramScope, root: IInstructionCollector) {\r\n        checkFunctionsForRecursion(context, program);\r\n        program.validate();\r\n    }\r\n\r\n\r\n    async parse(slastDocument: ISLASTDocument, document?: ISLDocument): Promise<ISLDocument> {\r\n        const uri = slastDocument.uri;\r\n        // console.time(`analyze(${uri})`);\r\n\r\n        const program = this.createProgram(document);\r\n        const context = this.createContext(uri);\r\n\r\n        let instructions: IInstruction[] = null;\r\n        try {\r\n            instructions = this.analyzeGlobals(context, program, slastDocument);\r\n        } catch (e) {\r\n            // critical errors were occured\r\n            // throw e;\r\n            console.error(e);\r\n        }\r\n\r\n        // console.timeEnd(`analyze(${uri})`);\r\n\r\n        const root = new InstructionCollector({ scope: program.globalScope, instructions });\r\n        this.validate(context, program, root);\r\n\r\n\r\n        const diagnosticReport = Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);\r\n        return { root, diagnosticReport, uri };\r\n    }\r\n\r\n\r\n    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {\r\n    //     if (isSystemFunction(func)) {\r\n    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });\r\n    //     }\r\n\r\n    //     let isFunctionAdded: boolean = program.addFunction(func);\r\n\r\n    //     if (!isFunctionAdded) {\r\n    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });\r\n    //     }\r\n    // }\r\n\r\n\r\n    protected static addTechnique(context: Context, program: ProgramScope, technique: ITechniqueInstruction): void {\r\n        let name: string = technique.name;\r\n\r\n        if (!isNull(program.globalScope.findTechnique(name))) {\r\n            context.error(technique.sourceNode, EErrors.TechniqueNameRedefinition, { techName: name });\r\n            return;\r\n        }\r\n\r\n        program.globalScope.addTechnique(technique);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * Check the possibility of using the operator between the two types.\r\n    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.\r\n     *\r\n     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =\r\n     * @leftType {IVariableTypeInstruction} Type of the left side of the expression.\r\n     * @rightType {IVariableTypeInstruction} Type of the right side of the expression.\r\n     */\r\n    protected static checkTwoOperandExprTypes(\r\n        context: Context,\r\n        operator: string,\r\n        leftType: IVariableTypeInstruction,\r\n        rightType: IVariableTypeInstruction,\r\n        leftSourceNode: IParseNode = leftType.sourceNode,\r\n        rightSourceNode: IParseNode = rightType.sourceNode): IVariableTypeInstruction {\r\n\r\n        if (!leftType || !rightType) {\r\n            return null;\r\n        }\r\n\r\n        const isComplex = leftType.isComplex() || rightType.isComplex();\r\n        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();\r\n        const isSampler = SystemScope.isSamplerType(leftType) || SystemScope.isSamplerType(rightType);\r\n\r\n        const boolType = <IVariableTypeInstruction>T_BOOL;\r\n        // const constBoolType = VariableTypeInstruction.wrapAsConst(T_BOOL, SystemScope.SCOPE);\r\n\r\n        if (isArray || isSampler) {\r\n            return null;\r\n        }\r\n\r\n        if (operator === '%' || operator === '%=') {\r\n            return null;\r\n        }\r\n\r\n        if (Analyzer.isAssignmentOperator(operator)) {\r\n            if (!leftType.writable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForWriting);\r\n                return null;\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n\r\n            if (operator !== '=' && !leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n            }\r\n        }\r\n        else {\r\n            if (!leftType.readable) {\r\n                context.error(leftSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n\r\n            if (!rightType.readable) {\r\n                context.error(rightSourceNode, EErrors.InvalidTypeForReading);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (isComplex) {\r\n            if (operator === '=' && leftType.isEqual(rightType)) {\r\n                return <IVariableTypeInstruction>leftType;\r\n            }\r\n            // samplers and arrays can't be compared directly\r\n            else if (Analyzer.isEqualOperator(operator) && !leftType.isContainArray() && !leftType.isContainSampler()) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        // FIXME: use operands' scope instead of system scope?\r\n        const leftBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>leftType.baseType, SystemScope.SCOPE);\r\n        const rightBaseType = VariableTypeInstruction.wrap(<SystemTypeInstruction>rightType.baseType, SystemScope.SCOPE);\r\n\r\n\r\n        if (leftType.isConst() && Analyzer.isAssignmentOperator(operator)) {\r\n            // TODO: emit proper error\r\n            return null;\r\n        }\r\n\r\n        if (leftType.isEqual(rightType)) {\r\n            if (Analyzer.isArithmeticalOperator(operator)) {\r\n                if (!SystemScope.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {\r\n                    return leftBaseType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (Analyzer.isRelationalOperator(operator)) {\r\n                if (SystemScope.isScalarType(leftType)) {\r\n                    return boolType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else if (Analyzer.isEqualOperator(operator)) {\r\n                return boolType;\r\n            }\r\n            else if (operator === '=') {\r\n                return leftBaseType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n\r\n        }\r\n\r\n        // temp workaround for INT/UINT comparison\r\n        if (Analyzer.isRelationalOperator(operator)) {\r\n            if ((leftType.isEqual(T_UINT) && rightType.isEqual(T_INT)) ||\r\n                (leftType.isEqual(T_INT) && rightType.isEqual(T_UINT))) {\r\n                return boolType;\r\n            }\r\n        }\r\n\r\n        if (Analyzer.isArithmeticalOperator(operator)) {\r\n            if (SystemScope.isBoolBasedType(leftType) || SystemScope.isBoolBasedType(rightType) ||\r\n                SystemScope.isFloatBasedType(leftType) !== SystemScope.isFloatBasedType(rightType) ||\r\n                SystemScope.isIntBasedType(leftType) !== SystemScope.isIntBasedType(rightType) || \r\n                SystemScope.isUIntBasedType(leftType) !== SystemScope.isUIntBasedType(rightType)) {\r\n                return null;\r\n            }\r\n\r\n            if (SystemScope.isScalarType(leftType)) {\r\n                return rightBaseType;\r\n            }\r\n\r\n            if (SystemScope.isScalarType(rightType)) {\r\n                return leftBaseType;\r\n            }\r\n\r\n            if (operator === '*' || operator === '*=') {\r\n                if (SystemScope.isMatrixType(leftType) && SystemScope.isVectorType(rightType) &&\r\n                    leftType.length === rightType.length) {\r\n                    return rightBaseType;\r\n                }\r\n                else if (SystemScope.isMatrixType(rightType) && SystemScope.isVectorType(leftType) &&\r\n                    leftType.length === rightType.length) {\r\n                    return leftBaseType;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (operator === '=') {\r\n            // TODO: move conversion logic inside TypeInstruction.\r\n            if ((leftType.isEqual(T_INT) && rightType.isEqual(T_UINT)) ||\r\n                (leftType.isEqual(T_UINT) && rightType.isEqual(T_INT))) {\r\n                return leftType;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Проверят возможность использования оператора к типу данных.\r\n     * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.\r\n     *\r\n     * @operator {string} Один из операторов: + - ! ++ --\r\n     * @leftType {IVariableTypeInstruction} Тип операнда\r\n     */\r\n    protected static checkOneOperandExprType(context: Context, sourceNode: IParseNode, operator: string,\r\n        type: IVariableTypeInstruction): IVariableTypeInstruction {\r\n\r\n        const isComplex = type.isComplex();\r\n        const isArray = type.isNotBaseArray();\r\n        const isSampler = SystemScope.isSamplerType(type);\r\n\r\n        if (isComplex || isArray || isSampler) {\r\n            return null;\r\n        }\r\n\r\n        if (!type.readable) {\r\n            context.error(sourceNode, EErrors.InvalidTypeForReading);\r\n            return null;\r\n        }\r\n\r\n\r\n        if (operator === '++' || operator === '--') {\r\n            if (!type.writable) {\r\n                context.error(sourceNode, EErrors.InvalidTypeForWriting);\r\n                return null;\r\n            }\r\n\r\n            return type;\r\n        }\r\n\r\n        if (operator === '!') {\r\n            const boolType = <IVariableTypeInstruction>T_BOOL;\r\n            // validate(boolType, EInstructionTypes.k_VariableDecl);\r\n\r\n            if (type.isEqual(boolType)) {\r\n                return boolType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (SystemScope.isBoolBasedType(type)) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (<SystemTypeInstruction>type.baseType) as any; // << TODO: fixme!!!! remove \"any\"!\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n    protected static isAssignmentOperator(operator: string): boolean {\r\n        return operator === '+=' || operator === '-=' ||\r\n            operator === '*=' || operator === '/=' ||\r\n            operator === '%=' || operator === '=';\r\n    }\r\n\r\n\r\n    protected static isArithmeticalOperator(operator: string): boolean {\r\n        return operator === '+' || operator === '+=' ||\r\n            operator === '-' || operator === '-=' ||\r\n            operator === '*' || operator === '*=' ||\r\n            operator === '/' || operator === '/=';\r\n    }\r\n\r\n\r\n    protected static isRelationalOperator(operator: string): boolean {\r\n        return operator === '>' || operator === '>=' ||\r\n            operator === '<' || operator === '<=';\r\n    }\r\n\r\n\r\n    protected static isEqualOperator(operator: string): boolean {\r\n        return operator === '==' || operator === '!=';\r\n    }\r\n}\r\n\r\n\r\n","import { deepEqual } from \"@lib/common\";\r\nimport { EParserFlags, EParserType, IParserParams } from \"@lib/idl/parser/IParser\";\r\nimport { IParser } from \"@lib/idl/parser/IParser\"\r\nimport { AbstractParser } from \"@lib/parser/AbstractParser\";\r\nimport slGrammar from 'raw-loader!./HLSL.gr';\r\n\r\nexport class SLParser extends AbstractParser {\r\n    protected init({ grammar = slGrammar, type = EParserType.k_LALR, flags = EParserFlags.k_Default }: IParserParams) {\r\n        super.init({ grammar, type, flags });\r\n    }\r\n}\r\n\r\nlet paramsDefault: IParserParams = null;\r\nlet parserDefault: IParser = null;\r\n\r\nexport function defaultSLGrammar(): string {\r\n    return slGrammar;\r\n}\r\n\r\nexport function defaultSLParser(): IParser {\r\n    if (!parserDefault) {\r\n        createDefaultSLParser();\r\n    }\r\n    return parserDefault;\r\n}\r\n\r\n/**\r\n * Internal debugging functionality, no need to use without necessary.\r\n */\r\nexport function createDefaultSLParser(params: IParserParams = { grammar: slGrammar }) {\r\n    if (deepEqual(paramsDefault, params)) {\r\n        return;\r\n    }\r\n    paramsDefault = params;\r\n    parserDefault = new SLParser(params);\r\n}\r\n","import { EInstructionTypes, IInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport namespace instruction {\r\n    export const UNDEFINE_LENGTH: number = 0xffffff;\r\n    export const UNDEFINE_SIZE: number = 0xffffff;\r\n    export const UNDEFINE_PADDING: number = 0xffffff;\r\n    export const UNDEFINE_NAME: string = \"undef\";\r\n\r\n    export function isExpression(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_ConditionalExpr:\r\n            case EInstructionTypes.k_ConstructorCallExpr:\r\n            case EInstructionTypes.k_AssignmentExpr:\r\n            case EInstructionTypes.k_ArithmeticExpr:\r\n            case EInstructionTypes.k_InitExpr:\r\n            case EInstructionTypes.k_IdExpr:\r\n            case EInstructionTypes.k_FunctionCallExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_PostfixArithmeticExpr:\r\n            case EInstructionTypes.k_PostfixIndexExpr:\r\n            case EInstructionTypes.k_PostfixPointExpr:\r\n            case EInstructionTypes.k_ComplexExpr:\r\n            case EInstructionTypes.k_CastExpr:\r\n            case EInstructionTypes.k_UnaryExpr:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isStatement(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_Stmt:\r\n            case EInstructionTypes.k_DeclStmt:\r\n            case EInstructionTypes.k_ReturnStmt:\r\n            case EInstructionTypes.k_IfStmt:\r\n            case EInstructionTypes.k_StmtBlock:\r\n            case EInstructionTypes.k_ExprStmt:\r\n            case EInstructionTypes.k_WhileStmt:\r\n            case EInstructionTypes.k_ForStmt:\r\n            case EInstructionTypes.k_BreakStmt:\r\n            case EInstructionTypes.k_SemicolonStmt:\r\n                // todo: add other types!!!\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    export function isLiteral(instr: IInstruction): boolean {\r\n        switch (instr.instructionType) {\r\n            case EInstructionTypes.k_IntExpr:\r\n            case EInstructionTypes.k_FloatExpr:\r\n            case EInstructionTypes.k_BoolExpr:\r\n            case EInstructionTypes.k_StringExpr:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}","import { isDef, isNull } from \"@lib/common\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, ISamplerStateBlockInstruction, ISamplerStateInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { ISamplerState } from \"@lib/idl/ISamplerState\";\r\nimport { ETextureFilters, ETextureWrapModes } from \"@lib/idl/ITexture\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type SamplerOperator = \"sampler_state\";\r\n\r\nexport interface ISamplerStateBlockInstructionSettings extends IInstructionSettings {\r\n    operator: SamplerOperator;\r\n    params?: ISamplerStateInstruction[];\r\n}\r\n\r\n\r\n/**\r\n  * Represetn sampler_state { states }\r\n  */\r\nexport class SamplerStateBlockInstruction extends ExprInstruction implements ISamplerStateBlockInstruction {\r\n    protected _samplerParams: ISamplerStateInstruction[];\r\n    protected _operator: SamplerOperator;\r\n\r\n\r\n    constructor({ operator, params = [], ...settings }: ISamplerStateBlockInstructionSettings) {\r\n        // todo: resolve type from texture type!\r\n        super({ instrType: EInstructionTypes.k_SamplerStateBlockExpr, type: SystemScope.T_SAMPLER, ...settings } );\r\n        \r\n        this._samplerParams = params.map(param => Instruction.$withParent(param, this));\r\n        this._operator = operator;\r\n    }\r\n\r\n    \r\n    get texture(): IVariableDeclInstruction {\r\n        let params = this._samplerParams;\r\n        for (let i = 0; i < params.length; ++ i) {\r\n            if (params[i].name === \"TEXTURE\") {\r\n                return <IVariableDeclInstruction>params[i].value;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    \r\n    get params(): ISamplerStateInstruction[] {\r\n        return this._samplerParams;\r\n    }\r\n\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    // todo: rewrite it!\r\n    evaluate(): boolean {\r\n        var samplerState: ISamplerState = {\r\n            textureName: \"\",\r\n\r\n            wrap_s: 0,\r\n            wrap_t: 0,\r\n\r\n            mag_filter: 0,\r\n            min_filter: 0\r\n        };\r\n\r\n        if (!isNull(this.texture)) {\r\n            samplerState.textureName = this.texture.name;\r\n        }\r\n\r\n        if (!isNull(this._samplerParams)) {\r\n            if (isDef(this._samplerParams[\"ADDRESSU\"])) {\r\n                samplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams[\"ADDRESSU\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"ADDRESSV\"])) {\r\n                samplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._samplerParams[\"ADDRESSV\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"MAGFILTER\"])) {\r\n                samplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams[\"MAGFILTER\"]);\r\n            }\r\n\r\n            if (isDef(this._samplerParams[\"MINFILTER\"])) {\r\n                samplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._samplerParams[\"MINFILTER\"]);\r\n            }\r\n        }\r\n\r\n\r\n        this._evalResult = samplerState;\r\n        return true;\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    static convertWrapMode(sState: string): ETextureWrapModes {\r\n        switch (sState) {\r\n            case \"WRAP\":\r\n                return ETextureWrapModes.REPEAT;\r\n            case \"CLAMP\":\r\n                return ETextureWrapModes.CLAMP_TO_EDGE;\r\n            case \"MIRROR\":\r\n                return ETextureWrapModes.MIRRORED_REPEAT;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n    \r\n\r\n    // TODO: move it to helpers\r\n    static convertFilters(sState: string): ETextureFilters {\r\n        switch (sState) {\r\n            case \"NEAREST\":\r\n                return ETextureFilters.NEAREST;\r\n            case \"LINEAR\":\r\n                return ETextureFilters.LINEAR;\r\n            case \"NEAREST_MIPMAP_NEAREST\":\r\n                return ETextureFilters.NEAREST_MIPMAP_NEAREST;\r\n            case \"LINEAR_MIPMAP_NEAREST\":\r\n                return ETextureFilters.LINEAR_MIPMAP_NEAREST;\r\n            case \"NEAREST_MIPMAP_LINEAR\":\r\n                return ETextureFilters.NEAREST_MIPMAP_LINEAR;\r\n            case \"LINEAR_MIPMAP_LINEAR\":\r\n                return ETextureFilters.LINEAR_MIPMAP_LINEAR;\r\n            default:\r\n                return 0;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwSet = new WeakSet();\r\nconst transferHandlers = new Map([\r\n    [\r\n        \"proxy\",\r\n        {\r\n            canHandle: obj => obj && obj[proxyMarker],\r\n            serialize(obj) {\r\n                const { port1, port2 } = new MessageChannel();\r\n                expose(obj, port1);\r\n                return [port2, [port2]];\r\n            },\r\n            deserialize: (port) => {\r\n                port.start();\r\n                return wrap(port);\r\n            }\r\n        }\r\n    ],\r\n    [\r\n        \"throw\",\r\n        {\r\n            canHandle: obj => throwSet.has(obj),\r\n            serialize(obj) {\r\n                const isError = obj instanceof Error;\r\n                let serialized = obj;\r\n                if (isError) {\r\n                    serialized = {\r\n                        isError,\r\n                        message: obj.message,\r\n                        stack: obj.stack\r\n                    };\r\n                }\r\n                return [serialized, []];\r\n            },\r\n            deserialize(obj) {\r\n                if (obj.isError) {\r\n                    throw Object.assign(new Error(), obj);\r\n                }\r\n                throw obj;\r\n            }\r\n        }\r\n    ]\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (e) {\r\n            returnValue = e;\r\n            throwSet.add(e);\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch(e => {\r\n            throwSet.add(e);\r\n            return e;\r\n        })\r\n            .then(returnValue => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep) {\r\n    return createProxy(ep);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = []) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(function () { }, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map(p => p.toString())\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map(p => p.toString())\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map(p => p.toString()),\r\n                value\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map(p => p.toString()),\r\n                argumentList\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map(p => p.toString()),\r\n                argumentList\r\n            }, transferables).then(fromWireValue);\r\n        }\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self) {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, \"*\", transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context)\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue\r\n                },\r\n                transferables\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value\r\n        },\r\n        transferCache.get(value) || []\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise(resolve => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { T_INT, T_UINT, SCOPE } from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\n\r\nexport interface IIntInstructionSettings extends IInstructionSettings {\r\n    value: number;\r\n    signed: boolean;\r\n}\r\n\r\nexport class IntInstruction extends ExprInstruction implements ILiteralInstruction<number> {\r\n    readonly value: number;\r\n    readonly signed: boolean;\r\n    /**\r\n     * EMPTY_OPERATOR EMPTY_ARGUMENTS\r\n     */\r\n    constructor({ value, signed, scope, ...settings }: IIntInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_IntExpr, \r\n            // NOTE: type wraping is no really necessary, just for debug purposes \r\n            type: VariableTypeInstruction.wrapAsConst(signed ? T_INT : T_UINT, SCOPE), scope, ...settings });\r\n\r\n        this.value = value;\r\n        this.signed = signed;\r\n\r\n        if (!signed) {\r\n            this.value >>>= 0;\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    toString(): string {\r\n        // return `${this.value}${this.signed? '' : 'u'}`;\r\n        return `${this.value}`;\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    \r\n    evaluate(): boolean {\r\n        this._evalResult = this.value;\r\n        return true;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\n","import { isDefAndNotNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors as EErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EAnalyzerWarnings as EWarnings } from '@lib/idl/EAnalyzerWarnings';\r\nimport { EDiagnosticCategory } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { IRange } from \"@lib/idl/parser/IParser\";\r\nimport { Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\ninterface IAnalyzerDiagDesc {\r\n    file: string;\r\n    loc: IRange;\r\n    info: any; // TODO: fixme\r\n}\r\n\r\n\r\nexport class AnalyzerDiagnostics extends Diagnostics<IAnalyzerDiagDesc> {\r\n    constructor() {\r\n        super(\"Analyzer Diagnostics\", 'A');\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: IAnalyzerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: IAnalyzerDiagDesc): IRange {\r\n        return desc.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        // TODO: fill all errors.\r\n        // TODO: add support for warnings\r\n        return {\r\n            [EErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \\'*type*\\' type expected.', // TODO: specify type\r\n            [EErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \\'void\\' type expected.',\r\n            [EErrors.FunctionRedefinition]: 'Function redefinition. Function with name \\'{info.funcName}\\' already declared.', // TODO: add location where function declared before\r\n            [EErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \\'{info.funcName}\\' but another type already declared.', // TODO: specify prev type and location\r\n            [EErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.', // TODO: specify func name and return type details.\r\n            [EErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',\r\n        };\r\n    }\r\n\r\n    protected resolveDescription(code: number, category: EDiagnosticCategory, desc: IAnalyzerDiagDesc): string {\r\n        let descList = this.diagnosticMessages();\r\n        if (isDefAndNotNull(descList[code])) {\r\n            return super.resolveDescription(code, category, desc);\r\n        }\r\n\r\n        let { file, loc, ...data } = desc;\r\n        if (category == EDiagnosticCategory.k_Warning) {\r\n            return `${EWarnings[code]}: ${JSON.stringify(data)}`;\r\n        }\r\n        return `${EErrors[code]}: ${JSON.stringify(data)}`;\r\n    }\r\n}\r\n","import { assert, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { FunctionDeclInstruction, IFunctionDeclInstructionSettings } from \"./FunctionDeclInstruction\";\r\n\r\nexport interface ISystemFunctionInstructionSettings extends IFunctionDeclInstructionSettings {\r\n    vertex?: boolean;\r\n    pixel?: boolean;\r\n}\r\n\r\n\r\nexport class SystemFunctionInstruction extends FunctionDeclInstruction implements IFunctionDeclInstruction {\r\n    protected _bForVertex: boolean;\r\n    protected _bForPixel: boolean;\r\n    \r\n     constructor({ vertex = true, pixel = true, implementation = null, ...settings }: ISystemFunctionInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemFunctionDecl, implementation: null, ...settings });\r\n        \r\n        assert(isNull(implementation));\r\n\r\n        this._bForVertex = vertex;\r\n        this._bForPixel = pixel;\r\n    }\r\n\r\n\r\n    checkVertexUsage(): boolean {\r\n        return this._bForVertex;\r\n    }\r\n\r\n\r\n    checkPixelUsage(): boolean {\r\n        return this._bForPixel;\r\n    }\r\n\r\n\r\n    $makeVertexCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForVertex = val;\r\n    }\r\n\r\n\r\n    $makePixelCompatible(val: boolean): void {\r\n        console.warn(\"@deprecated\");\r\n        this._bForPixel = val;\r\n    }\r\n}\r\n\r\n","import { isString } from '@lib/common';\r\nimport { IDiagnosticReport } from '@lib/idl/IDiagnostics';\r\nimport { IMap } from '@lib/idl/IMap';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { ETokenType, IFile, ILexerEngine, IPosition, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { Diagnostics } from '@lib/util/Diagnostics';\r\nimport { StringRef } from '@lib/util/StringRef';\r\n\r\nimport { END_SYMBOL, EOF, ERROR, T_FLOAT, T_LINE_TERMINATOR, T_NON_TYPE_ID, T_STRING, T_TYPE_ID, T_UINT, UNKNOWN_TOKEN } from './symbols';\r\n\r\ninterface ILexerDiagDesc {\r\n    file: string;\r\n    token: IToken;\r\n}\r\n\r\n\r\nenum ELexerErrors {\r\n    UnknownToken = 2101,\r\n    InvalidToken = 2102\r\n};\r\n\r\n\r\nclass LexerDiagnostics extends Diagnostics<ILexerDiagDesc> {\r\n    constructor() {\r\n        super(\"Lexer Diagnostics\", 'L');\r\n    }\r\n\r\n    protected resolveFilename(code: number, desc: ILexerDiagDesc): string {\r\n        return desc.file;\r\n    }\r\n\r\n    protected resolveRange(code: number, desc: ILexerDiagDesc): IRange {\r\n        return desc.token.loc;\r\n    }\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [ELexerErrors.UnknownToken]: \"Unknown token: {token.value}.\",\r\n            [ELexerErrors.InvalidToken]: \"Invalid token: {token.value}.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport class LexerEngine implements ILexerEngine {\r\n    readonly keywords: IMap<string> = {};\r\n    readonly punctuators: IMap<string> = {};\r\n    readonly punctuatorsFirstSymbols: IMap<boolean> = {};\r\n\r\n\r\n    addPunctuator(value: string, name: string = LexerEngine.getPunctuatorName(value)): string {\r\n        this.punctuators[value] = name;\r\n        this.punctuatorsFirstSymbols[value[0]] = true;\r\n        return name;\r\n    }\r\n\r\n\r\n    addKeyword(value: string, name: string): string {\r\n        this.keywords[value] = name;\r\n        return name;\r\n    }\r\n\r\n\r\n    getTerminalValueByName(name: string): string {\r\n        let value = \"\";\r\n\r\n        for (value in this.punctuators) {\r\n            if (this.punctuators[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        for (value in this.keywords) {\r\n            if (this.keywords[value] === name) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n\r\n    isLineTerminator(symbol: string): boolean {\r\n        return (symbol === \"\\n\" || symbol === \"\\r\" || symbol === \"\\u2028\" || symbol === \"\\u2029\");\r\n    }\r\n\r\n\r\n    isKeyword(value: string): boolean {\r\n        return !!(this.keywords[value]);\r\n    }\r\n\r\n\r\n    isPunctuator(value: string): boolean {\r\n        return !!(this.punctuators[value]);\r\n    }\r\n\r\n\r\n    isNumberStart(ch: string, ch1: string): boolean {\r\n        if ((ch >= \"0\") && (ch <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        if (ch === \".\" && (ch1 >= \"0\") && (ch1 <= \"9\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isCommentStart(ch: string, ch1: string): boolean {\r\n        if (ch === \"/\" && (ch1 === \"/\" || ch1 === \"*\")) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    isStringStart(ch: string): boolean {\r\n        if (ch === \"\\\"\" || ch === \"'\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isPunctuatorStart(ch: string): boolean {\r\n        if (this.punctuatorsFirstSymbols[ch]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isWhiteSpaceStart(ch: string): boolean {\r\n        if (ch === \" \" || ch === \"\\t\") {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isNewlineStart(ch: string): boolean {\r\n        if (ch === \"\\n\" || ch === \"\\r\" ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    isIdentifierStart(ch: string): boolean {\r\n        if ((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    static getPunctuatorName(value: string): string {\r\n        return \"T_PUNCTUATOR_\" + value.charCodeAt(0);\r\n    }\r\n}\r\n\r\ninterface ILexerConfig {\r\n    engine?: LexerEngine;\r\n    knownTypes?: Set<string>;\r\n    skipComments?: boolean;\r\n}\r\n\r\nexport class Lexer {\r\n    index: number;\r\n    lineNumber: number;\r\n    columnNumber: number;\r\n    uri: IFile;\r\n    source: string;\r\n\r\n    engine: LexerEngine;\r\n    diagnostics: LexerDiagnostics;\r\n    knownTypes: Set<string>;\r\n    skipComments: boolean;\r\n\r\n    constructor({ engine = new LexerEngine, knownTypes = new Set(), skipComments = true }: ILexerConfig) {\r\n        this.lineNumber = 0;\r\n        this.columnNumber = 0;\r\n        this.index = 0;\r\n\r\n        this.diagnostics = new LexerDiagnostics;\r\n        this.knownTypes = knownTypes;\r\n        this.engine = engine;\r\n        this.skipComments = skipComments;\r\n    }\r\n\r\n    setup(textDocument: ITextDocument) {\r\n        this.uri = StringRef.make(textDocument.uri);\r\n        this.source = textDocument.source;\r\n    }\r\n\r\n\r\n    getDiagnosticReport(): IDiagnosticReport {\r\n        return this.diagnostics.resolve();\r\n    }\r\n\r\n\r\n    getNextToken(allowLineTerminators?: boolean): IToken {\r\n        let ch = this.currentChar();\r\n        if (!ch) {\r\n            let pos = this.pos();\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: END_SYMBOL,\r\n                value: END_SYMBOL,\r\n                loc: {\r\n                    start: pos,\r\n                    end: { ...pos }\r\n                }\r\n            };\r\n        }\r\n        let tokenType = this.identityTokenType();\r\n        let token: IToken = null;\r\n        switch (tokenType) {\r\n            case ETokenType.k_NumericLiteral:\r\n                token = this.scanNumber();\r\n                break;\r\n            case ETokenType.k_SinglelineCommentLiteral:\r\n            case ETokenType.k_MultilineCommentLiteral:\r\n                token = this.scanComment();\r\n                if (this.skipComments) {\r\n                    token = this.getNextToken();\r\n                }\r\n                break;\r\n            case ETokenType.k_StringLiteral:\r\n                token = this.scanString();\r\n                break;\r\n            case ETokenType.k_PunctuatorLiteral:\r\n                token = this.scanPunctuator();\r\n                break;\r\n            case ETokenType.k_IdentifierLiteral:\r\n                token = this.scanIdentifier();\r\n                break;\r\n            case ETokenType.k_NewlineLiteral:\r\n                token = this.scanLineTerminators();\r\n                if (!allowLineTerminators) {\r\n                    token = this.getNextToken();\r\n                }\r\n                break;\r\n            case ETokenType.k_WhitespaceLiteral:\r\n                this.scanWhiteSpace();\r\n                token = this.getNextToken();\r\n                break;\r\n            default:\r\n                {\r\n                    // TODO: move this code to scanInvalid()\r\n                    const start = this.pos();\r\n                    let value = '';\r\n                    while (this.identityTokenType() === ETokenType.k_Unknown && this.index < this.source.length) {\r\n                        value += this.currentChar();\r\n                        this.readNextChar();\r\n                    }\r\n                    token = {\r\n                        index: this.index,\r\n                        name: UNKNOWN_TOKEN,\r\n                        value,\r\n                        loc: { start, end: this.pos() }\r\n                    };\r\n                    // console.warn(value);\r\n                    this.emitError(ELexerErrors.UnknownToken, token);\r\n                    return token;\r\n                }\r\n        }\r\n        return token;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    getLocation() {\r\n        return { line: this.lineNumber, file: this.uri };\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    setSource(sSource: string): void {\r\n        this.source = sSource;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    setIndex(iIndex: number): void {\r\n        this.index = iIndex;\r\n    }\r\n\r\n\r\n    private pos(n: number = 0): IPosition {\r\n        return {\r\n            file: this.uri,\r\n            line: this.lineNumber,\r\n            column: this.columnNumber + n,\r\n            offset: this.index + n\r\n        };\r\n    }\r\n\r\n\r\n    private emitError(code: number, token: IToken): void {\r\n        this.diagnostics.error(code, { file: `${this.uri}`, token });\r\n    }\r\n\r\n\r\n    private identityTokenType(): ETokenType {\r\n        if (this.isIdentifierStart()) {\r\n            return ETokenType.k_IdentifierLiteral;\r\n        }\r\n        if (this.isWhiteSpaceStart()) {\r\n            return ETokenType.k_WhitespaceLiteral;\r\n        }\r\n        if (this.isNewlineStart()) {\r\n            return ETokenType.k_NewlineLiteral;\r\n        }\r\n        if (this.isStringStart()) {\r\n            return ETokenType.k_StringLiteral;\r\n        }\r\n        if (this.isCommentStart()) {\r\n            // TODO: return exact type (separate multiline/singleline comment parsings)\r\n            return ETokenType.k_SinglelineCommentLiteral;\r\n        }\r\n        if (this.isNumberStart()) {\r\n            return ETokenType.k_NumericLiteral;\r\n        }\r\n        if (this.isPunctuatorStart()) {\r\n            return ETokenType.k_PunctuatorLiteral;\r\n        }\r\n        return ETokenType.k_Unknown;\r\n    }\r\n\r\n\r\n    private isNumberStart(): boolean {\r\n        return this.engine.isNumberStart(this.currentChar(), this.nextChar());\r\n    }\r\n\r\n\r\n    private isCommentStart(): boolean {\r\n        return this.engine.isCommentStart(this.currentChar(), this.nextChar())\r\n    }\r\n\r\n\r\n    private isStringStart(): boolean {\r\n        return this.engine.isStringStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isPunctuatorStart(): boolean {\r\n        return this.engine.isPunctuatorStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isWhiteSpaceStart(): boolean {\r\n        return this.engine.isWhiteSpaceStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isNewlineStart(): boolean {\r\n        return this.engine.isNewlineStart(this.currentChar());\r\n    }\r\n\r\n\r\n    private isIdentifierStart(): boolean {\r\n        return this.engine.isIdentifierStart(this.currentChar());\r\n    }\r\n\r\n\r\n\r\n\r\n    private nextChar(): string {\r\n        return this.source[this.index + 1];\r\n    }\r\n\r\n\r\n    private currentChar(): string {\r\n        return this.source[<number>this.index];\r\n    }\r\n\r\n\r\n    private readNextChar(): string {\r\n        this.index++;\r\n        this.columnNumber++;\r\n        return this.source[<number>this.index];\r\n    }\r\n\r\n\r\n    private scanString(): IToken {\r\n        let chFirst = this.currentChar();\r\n        let value = chFirst;\r\n        let ch = \"\";\r\n        let chPrevious = chFirst;\r\n        let isGoodFinish = false;\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            value += ch;\r\n            if (ch === chFirst && chPrevious !== \"\\\\\") {\r\n                isGoodFinish = true;\r\n                this.readNextChar();\r\n                break;\r\n            }\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            return <IToken>{\r\n                index: this.index,\r\n                name: T_STRING,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_StringLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanPunctuator(): IToken {\r\n        let value = this.currentChar();\r\n        let start = this.pos();\r\n        let ch: string;\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch) {\r\n                value += ch;\r\n                if (!this.engine.isPunctuator(value)) {\r\n                    value = value.slice(0, value.length - 1);\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return <IToken>{\r\n            index: this.index,\r\n            name: this.engine.punctuators[value],\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    private scanNumber(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = \"\";\r\n        let isFloat = false;\r\n        let chPrevious = ch;\r\n        let isGoodFinish = false;\r\n        let isE = false; // exponential\r\n        let isU = false; // unsigned\r\n        let start = this.pos();\r\n\r\n        if (ch === \".\") {\r\n            value += 0;\r\n            isFloat = true;\r\n        }\r\n\r\n        value += ch;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (ch === \".\") {\r\n                if (isFloat || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isFloat = true;\r\n                }\r\n            }\r\n            else if (ch === \"e\") {\r\n                if (isE || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isE = true;\r\n                }\r\n            }\r\n            else if (ch === \"u\") {\r\n                if (isE || isU) {\r\n                    break;\r\n                }\r\n                else {\r\n                    isU = true;\r\n                }\r\n            }\r\n            else if (((ch === \"+\" || ch === \"-\") && chPrevious === \"e\")) {\r\n                value += ch;\r\n                chPrevious = ch;\r\n                continue;\r\n            }\r\n            else if (ch === \"f\" && isFloat) {\r\n                ch = this.readNextChar();\r\n                if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                    break;\r\n                }\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            else if ((ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\")) {\r\n                break;\r\n            }\r\n            else if (!((ch >= \"0\") && (ch <= \"9\")) || !ch || isU) {\r\n                if ((isE && chPrevious !== \"+\" && chPrevious !== \"-\" && chPrevious !== \"e\") || !isE) {\r\n                    isGoodFinish = true;\r\n                }\r\n                break;\r\n            }\r\n            value += ch;\r\n            chPrevious = ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            let name = isFloat ? T_FLOAT : T_UINT;\r\n            return <IToken>{\r\n                index: this.index,\r\n                name,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_NumericLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanIdentifier(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = ch;\r\n        let start = this.pos();\r\n        let isGoodFinish = false;\r\n\r\n        while (true) {\r\n            ch = this.readNextChar();\r\n            if (!ch) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            if (!((ch === \"_\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\") || (ch >= \"0\" && ch <= \"9\"))) {\r\n                isGoodFinish = true;\r\n                break;\r\n            }\r\n            value += ch;\r\n        }\r\n\r\n        if (isGoodFinish) {\r\n            if (this.engine.isKeyword(value)) {\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name: this.engine.keywords[value],\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                let name = this.knownTypes.has(value) ? T_TYPE_ID : T_NON_TYPE_ID;\r\n                return <IToken>{\r\n                    index: this.index,\r\n                    name,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            if (!ch) {\r\n                ch = EOF;\r\n            }\r\n            value += ch;\r\n\r\n            const token = {\r\n                index: this.index,\r\n                type: ETokenType.k_IdentifierLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n            this.emitError(ELexerErrors.InvalidToken, token);\r\n            return Lexer.makeUnknownToken(token);\r\n        }\r\n    }\r\n\r\n\r\n    private scanLineTerminators(): IToken {\r\n        let ch = this.currentChar();\r\n        let value = '';\r\n        let start = this.pos();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            if (this.engine.isLineTerminator(ch)) {\r\n                value += ch;\r\n                if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                    this.lineNumber--;\r\n                }\r\n                this.lineNumber++;\r\n                ch = this.readNextChar();\r\n                this.columnNumber = 0;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n\r\n        let name = T_LINE_TERMINATOR;\r\n        return <IToken>{\r\n            index: this.index,\r\n            name,\r\n            value,\r\n            loc: {\r\n                start,\r\n                end: this.pos()\r\n            }\r\n        };\r\n    }\r\n    private scanWhiteSpace(): boolean {\r\n        let ch = this.currentChar();\r\n\r\n        while (true) {\r\n            if (!ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"\\t\") {\r\n                // possible way to convert tab to multiple spaces\r\n                this.columnNumber += 0;\r\n            }\r\n            else if (ch !== \" \") {\r\n                break;\r\n            }\r\n            ch = this.readNextChar();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private scanComment(): IToken {\r\n        let value = this.currentChar();\r\n        let ch = this.readNextChar();\r\n        let start = this.pos();\r\n        value += ch;\r\n\r\n        if (ch === \"/\") {\r\n            //Line Comment\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.readNextChar();\r\n                    this.columnNumber = 0;\r\n                    break;\r\n                }\r\n                value += ch;\r\n            }\r\n\r\n            return {\r\n                index: this.index,\r\n                type: ETokenType.k_SinglelineCommentLiteral,\r\n                value,\r\n                loc: {\r\n                    start,\r\n                    end: this.pos()\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            //Multiline Comment\r\n            let chPrevious = ch;\r\n            let isGoodFinish = false;\r\n            let start = this.pos();\r\n\r\n            while (true) {\r\n                ch = this.readNextChar();\r\n                if (!ch) {\r\n                    break;\r\n                }\r\n                value += ch;\r\n                if (ch === \"/\" && chPrevious === \"*\") {\r\n                    isGoodFinish = true;\r\n                    this.readNextChar();\r\n                    break;\r\n                }\r\n                if (this.engine.isLineTerminator(ch)) {\r\n                    if (ch === \"\\r\" && this.nextChar() === \"\\n\") {\r\n                        this.lineNumber--;\r\n                    }\r\n                    this.lineNumber++;\r\n                    this.columnNumber = -1;\r\n                }\r\n                chPrevious = ch;\r\n            }\r\n\r\n            if (isGoodFinish) {\r\n                return {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                if (!ch) {\r\n                    ch = EOF;\r\n                }\r\n                value += ch;\r\n\r\n                const token = {\r\n                    index: this.index,\r\n                    type: ETokenType.k_MultilineCommentLiteral,\r\n                    value,\r\n                    loc: {\r\n                        start,\r\n                        end: this.pos()\r\n                    }\r\n                };\r\n\r\n                this.emitError(ELexerErrors.InvalidToken, token);\r\n                return Lexer.makeUnknownToken(token);\r\n            }\r\n        }\r\n    }\r\n\r\n    static makeUnknownToken(token: IToken): IToken {\r\n        return {\r\n            ...token,\r\n            type: undefined,\r\n            name: UNKNOWN_TOKEN,\r\n            loc: {\r\n                start: { ...token.loc.start },\r\n                end: { ...token.loc.end }\r\n            }\r\n        };\r\n    }\r\n}\r\n","import * as bf from './bf';\r\nexport default bf;\r\n","import { assert } from \"@lib/common\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { type } from \"./type\";\r\n\r\nexport namespace variable {\r\n    /**\r\n * @param decl Variable declaraion (decl.isParameter() must be true).\r\n * @returns Serial number of the declaration among the function parameters or -1 otherwise.\r\n */\r\n    export function parameterIndex(decl: IVariableDeclInstruction): number {\r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return -1;\r\n        }\r\n        // all parameters must be a children on function definition!\r\n        assert(decl.parent.instructionType === EInstructionTypes.k_FunctionDef);\r\n        return (<IFunctionDefInstruction>decl.parent).params.indexOf(decl);\r\n    }\r\n\r\n    /**\r\n     * @returns Offset in bytes from the beginning of the parameters' list.\r\n     */\r\n    export function parameterOffset(decl: IVariableDeclInstruction): number {\r\n        // todo: add support for 'inout', 'out' usages \r\n        if (!decl.isParameter()) {\r\n            console.error('invalid call.');\r\n            return 0;\r\n        }\r\n\r\n        let idx = parameterIndex(decl);\r\n        let offset = 0;\r\n        for (let i = 0; i < idx; ++i) {\r\n            offset += (<IFunctionDefInstruction>decl.parent).params[i].type.size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n        /**\r\n     * Helper:\r\n     *  Returns 'structName.fieldName' for structs;\r\n     *  Returns 'varName' for variables;\r\n     */\r\n    export function fullName(decl: IVariableDeclInstruction) {\r\n        if (decl.isField() &&\r\n            type.findParentVariableDecl(<IVariableTypeInstruction>decl.parent)) {\r\n\r\n            let name = '';\r\n            let parentType = decl.parent.instructionType;\r\n\r\n            if (parentType === EInstructionTypes.k_VariableType) {\r\n                name = type.resolveVariableDeclFullName(<IVariableTypeInstruction>decl.parent);\r\n            }\r\n\r\n            name += '.' + decl.name;\r\n            return name;\r\n        }\r\n        return decl.name;\r\n    }\r\n\r\n\r\n    export interface IRegister {\r\n        type: 'u' | 'b' | 't' | 's' | null;\r\n        index: number;\r\n        // space ?\r\n    };\r\n\r\n    export function resolveRegister(decl: IVariableDeclInstruction): IRegister {\r\n        let type = null;\r\n        let index = -1;\r\n\r\n        const semantic = decl.semantic;\r\n        if (semantic) {\r\n            const match = semantic.match(/^register\\(([utbs]{1})([\\d]+)\\)$/);\r\n            if (match) {\r\n                type = match[1];\r\n                index = Number(match[2]);\r\n            }\r\n        }\r\n\r\n        if (decl.type.isUAV()) {\r\n            assert(type === null || type === 'u');\r\n            type = 'u';\r\n        }\r\n\r\n        if (decl.type.isTexture()) {\r\n            assert(type === null || type === 't');\r\n            type = 't';\r\n        }\r\n\r\n        if (decl.type.isSampler()) {\r\n            assert(type === null || type === 's');\r\n            type = 's';\r\n        }\r\n\r\n        // TODO: buffers\r\n\r\n        return { type, index };\r\n    }\r\n}","import { createDefaultSLParser } from '@lib/fx/SLParser';\r\nimport { EDiagnosticCategory, IDiagnosticMessage } from '@lib/idl/IDiagnostics';\r\nimport { ILanguageService } from '@lib/idl/ILanguageService';\r\nimport { ISLDocument } from '@lib/idl/ISLDocument';\r\nimport { IParserParams } from '@lib/idl/parser/IParser';\r\nimport { getLanguageService } from '@lib/language-service/LanguageService';\r\nimport * as Comlink from 'comlink';\r\nimport { CodeLens, Diagnostic, DiagnosticSeverity, Position, Range, SignatureHelp, TextDocument, TextDocumentIdentifier } from 'vscode-languageserver-types';\r\n\r\n/* tslint:disable:typedef */\r\n/* tslint:disable:no-empty */\r\n/* tslint:disable:forin */\r\n/* tslint:disable:no-for-in */\r\n\r\n// supress all console messages for debugging/development purposes\r\n// import NULL_LOGGER from '@lib/util/NullLogger';\r\n// console = <any>NULL_LOGGER;\r\n\r\n\r\nfunction asTextDocument({ _content, _languageId, _lineOffsets, _uri, _version }): TextDocument {\r\n    return TextDocument.create(_uri, _languageId, _version, _content);\r\n}\r\n\r\n\r\nfunction asDiagnostic(diagEntry: IDiagnosticMessage): Diagnostic {\r\n    const { code, content, start, end, category } = diagEntry;\r\n\r\n    const severities = {\r\n        [EDiagnosticCategory.k_Error]: DiagnosticSeverity.Error,\r\n        [EDiagnosticCategory.k_Warning]: DiagnosticSeverity.Warning\r\n    };\r\n\r\n    return {\r\n        range: Range.create(start.line, start.column, (end || start).line, (end || start).column),\r\n        severity: severities[category],\r\n        code,\r\n        message: content\r\n    };\r\n}\r\n\r\n\r\n\r\nclass LanguageServiceProvider {\r\n    private service: ILanguageService;\r\n    private documents: Map<string, { textDocument: TextDocument; slDocument: ISLDocument }> = new Map();\r\n\r\n    init(parserParams: IParserParams, parsingFlags: number) {\r\n        console.log('%c Creating parser for language service provider...', 'background: #222; color: #bada55');\r\n        try {\r\n            createDefaultSLParser(parserParams);\r\n            console.log('%c [ DONE ]', 'background: #222; color: #bada55');\r\n        } catch (e) {\r\n            console.error('could not initialize parser.');\r\n            return null;\r\n        }\r\n\r\n        this.service = getLanguageService(parsingFlags);\r\n    }\r\n\r\n    async validate(rawDocument): Promise<Diagnostic[]> {\r\n        const textDocument = asTextDocument(rawDocument);\r\n\r\n        const slDocument = await this.service.parseDocument(textDocument);\r\n        this.documents.set(textDocument.uri, { textDocument, slDocument });\r\n\r\n        return slDocument.diagnosticReport.messages.map(asDiagnostic);\r\n    }\r\n\r\n    async provideFxCodeLenses(textDocumentIdentifier: TextDocumentIdentifier): Promise<CodeLens[]> {\r\n        if (!this.service) {\r\n            return [];\r\n        }\r\n\r\n        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);\r\n        return this.service.doFxCodeLenses(textDocument, slDocument);\r\n    }\r\n\r\n    async provideSignatureHelp(textDocumentIdentifier: TextDocumentIdentifier, position: Position): Promise<SignatureHelp> {\r\n        if (!this.service) {\r\n            return null;\r\n        }\r\n\r\n        const { textDocument, slDocument } = await this.getDocument(textDocumentIdentifier);\r\n        return this.service.doSignatureHelp(textDocument, position, slDocument);\r\n    }\r\n\r\n    private getDocument(textDocumentIdentifier: TextDocumentIdentifier): { textDocument: TextDocument; slDocument: ISLDocument } {\r\n        if (!this.documents.has(textDocumentIdentifier.uri)) {\r\n            console.warn('could not find document', textDocumentIdentifier.uri);\r\n            return { textDocument: null, slDocument: null };\r\n        }\r\n        return this.documents.get(textDocumentIdentifier.uri);\r\n    }\r\n}\r\n\r\nexport type ILanguageServiceProvider = LanguageServiceProvider;\r\n\r\nComlink.expose(new LanguageServiceProvider());\r\n\r\n","import { assert, isNull, isObject } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport { FunctionDefInstruction } from \"@lib/fx/analisys/instructions/FunctionDefInstruction\";\r\nimport { IdInstruction } from \"@lib/fx/analisys/instructions/IdInstruction\";\r\nimport { SystemFunctionInstruction } from \"@lib/fx/analisys/instructions/SystemFunctionInstruction\";\r\nimport { ISystemTypeInstructionSettings, SystemTypeInstruction } from \"@lib/fx/analisys/instructions/SystemTypeInstruction\";\r\nimport { EVariableUsageFlags, VariableDeclInstruction } from \"@lib/fx/analisys/instructions/VariableDeclInstruction\";\r\nimport { VariableTypeInstruction } from \"@lib/fx/analisys/instructions/VariableTypeInstruction\";\r\nimport { Scope } from \"@lib/fx/analisys/ProgramScope\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EInstructionTypes, EScopeType, IFunctionDeclInstruction, IScope, ITypedInstruction, ITypeInstruction, ITypeTemplate, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\n// TODO: use it\r\nexport enum ESystemTypes {\r\n    k_Sampler,\r\n    k_Sampler2D,\r\n    k_Sampler3D,\r\n    k_SamplerCube,\r\n    k_RWBuffer,\r\n    k_RWStructuredBuffer,\r\n    k_AppendStructuredBuffer\r\n};\r\n\r\nconst scope = new Scope({ type: EScopeType.k_System });\r\n\r\nconst systemFunctionHashMap: IMap<boolean> = {};\r\nconst TEMPLATE_TYPE = \"template\";\r\n\r\n\r\nfunction _emitException(message: string) {\r\n    throw new Error(message);\r\n}\r\n\r\n// todo: rewrite it!\r\nfunction _error(code: number, info = {}): void {\r\n    _emitException(EAnalyzerErrors[code]);\r\n}\r\n\r\ntype ITypeInfo = Pick<ISystemTypeInstructionSettings, Exclude<keyof ISystemTypeInstructionSettings, 'scope'>>;\r\n\r\nfunction generateSystemType(name: string, size?: number, elementType?: ITypeInstruction, \r\n    length?: number, fields?: IVariableDeclInstruction[], methods?: IFunctionDeclInstruction[]): SystemTypeInstruction;\r\n// function generateSystemType({ name, length, elementType, fields, size, methods }: ITypeInfo): SystemTypeInstruction;\r\nfunction generateSystemType(...args: any[]): SystemTypeInstruction {\r\n    let name: string;\r\n    let size: number;\r\n    let elementType: ITypeInstruction;\r\n    let length: number;\r\n    let fields: IVariableDeclInstruction[];\r\n    let methods: IFunctionDeclInstruction[];\r\n\r\n    // if (isObject(args[0])) {\r\n    //     ({ name, size, elementType, length, fields, methods } = args[0]);\r\n    // } else{\r\n        [ name, size, elementType, length, fields, methods ] = args;\r\n    // }\r\n\r\n    if (getSystemType(name)) {\r\n        console.error(`type already exists: ${name}`);\r\n        return null;\r\n    }\r\n\r\n    const type = new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });\r\n    scope.addType(type);\r\n\r\n    return type;\r\n}\r\n\r\n\r\nclass TypeTemplate implements ITypeTemplate {\r\n    readonly name: string;\r\n    readonly scope: IScope;\r\n    \r\n    constructor(name: string, scope: IScope) {\r\n        this.name = name;\r\n        this.scope = scope;\r\n    }\r\n\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    typeName(args?: ITypeInstruction[]): string {\r\n        if (args) {\r\n            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;\r\n        }\r\n        return this.name;\r\n    }\r\n}\r\n\r\n\r\nclass RWBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        if (!args[0].isBase()) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\nclass RWStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('RWStructuredBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n        \r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        \r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'IncrementCounter' });\r\n            let definition = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n        {\r\n            let returnType = new VariableTypeInstruction({ type: scope.findType(\"uint\"), scope });\r\n            let id = new IdInstruction({ scope, name: 'DecrementCounter' });\r\n            let definition = new FunctionDefInstruction({ scope, returnType, id });\r\n            let func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n\r\n\r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\nclass AppendStructuredBufferTemplate extends TypeTemplate {\r\n    constructor() {\r\n        super('AppendStructuredBuffer', scope);\r\n    }\r\n    produceType(scope: IScope, args?: ITypeInstruction[]): ITypeInstruction {\r\n        if (args.length !== 1) {\r\n            // TODO: print error\r\n            return null;\r\n        }\r\n\r\n        const name = this.typeName(args);\r\n        const size = -1; \r\n        const elementType = args[0];\r\n        const length = instruction.UNDEFINE_LENGTH;\r\n        const fields: IVariableDeclInstruction[] = [];\r\n        const methods: IFunctionDeclInstruction[] = [];\r\n        const uav = true;\r\n        {\r\n            const paramList = [];\r\n\r\n            {\r\n                const type = new VariableTypeInstruction({ type: args[0], scope });\r\n                const id = new IdInstruction({ scope, name: 'Append' });\r\n                const usageFlags = EVariableUsageFlags.k_Argument | EVariableUsageFlags.k_Local;\r\n                const param0 = new VariableDeclInstruction({ scope, type, id, usageFlags });\r\n                paramList.push(param0);\r\n            }\r\n\r\n            const returnType = new VariableTypeInstruction({ type: scope.findType(\"void\"), scope });\r\n            const id = new IdInstruction({ scope, name: 'Append' });\r\n            const definition = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n            const func = new SystemFunctionInstruction({ scope, definition, pixel: false, vertex: false });\r\n            methods.push(func);\r\n        }\r\n        \r\n        return new SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, uav });\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction addFieldsToVectorFromSuffixObject(fields: IVariableDeclInstruction[], suffixMap: IMap<boolean>, baseType: string) {\r\n    for (let suffix in suffixMap) {\r\n        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : \"\");\r\n        const fieldBaseType = getSystemType(fieldTypeName);\r\n\r\n        assert(fieldBaseType);\r\n\r\n        const fieldId = new IdInstruction({ scope, name: suffix });\r\n        const fieldType = new VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] })\r\n\r\n        fields.push(new VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));\r\n    }\r\n}\r\n\r\n\r\nfunction addSystemTypeScalar(): void {\r\n    generateSystemType(\"void\", 0);\r\n    generateSystemType(\"int\", 4);\r\n    generateSystemType(\"uint\", 4);\r\n    generateSystemType(\"bool\", 4);\r\n    generateSystemType(\"float\", 4);\r\n    generateSystemType(\"string\");\r\n    generateSystemType(\"texture\");\r\n    generateSystemType(\"sampler\");\r\n    generateSystemType(\"sampler2D\");\r\n    generateSystemType(\"samplerCUBE\");\r\n}\r\n\r\n\r\nfunction addSystemTypeVector(): void {\r\n    let XYSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let XYZSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let XYZWSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    let RGSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let RGBSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let RGBASuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    let STSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let STPSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n    let STPQSuffix: IMap<boolean> = <IMap<boolean>>{};\r\n\r\n    generateSuffixLiterals([\"x\", \"y\"], XYSuffix);\r\n    generateSuffixLiterals([\"x\", \"y\", \"z\"], XYZSuffix);\r\n    generateSuffixLiterals([\"x\", \"y\", \"z\", \"w\"], XYZWSuffix);\r\n\r\n    generateSuffixLiterals([\"r\", \"g\"], RGSuffix);\r\n    generateSuffixLiterals([\"r\", \"g\", \"b\"], RGBSuffix);\r\n    generateSuffixLiterals([\"r\", \"g\", \"b\", \"a\"], RGBASuffix);\r\n\r\n    generateSuffixLiterals([\"s\", \"t\"], STSuffix);\r\n    generateSuffixLiterals([\"s\", \"t\", \"p\"], STPSuffix);\r\n    generateSuffixLiterals([\"s\", \"t\", \"p\", \"q\"], STPQSuffix);\r\n\r\n\r\n    let float = getSystemType(\"float\");\r\n    let int = getSystemType(\"int\");\r\n    let uint = getSystemType(\"uint\");\r\n    let bool = getSystemType(\"bool\");\r\n\r\n    let float2 = generateSystemType(\"float2\", -1, float, 2);\r\n    let float3 = generateSystemType(\"float3\", -1, float, 3);\r\n    let float4 = generateSystemType(\"float4\", -1, float, 4);\r\n\r\n    let int2 = generateSystemType(\"int2\", -1, int, 2);\r\n    let int3 = generateSystemType(\"int3\", -1, int, 3);\r\n    let int4 = generateSystemType(\"int4\", -1, int, 4);\r\n\r\n    let uint2 = generateSystemType(\"uint2\", -1, uint, 2);\r\n    let uint3 = generateSystemType(\"uint3\", -1, uint, 3);\r\n    let uint4 = generateSystemType(\"uint4\", -1, uint, 4);\r\n\r\n    let bool2 = generateSystemType(\"bool2\", -1, bool, 2);\r\n    let bool3 = generateSystemType(\"bool3\", -1, bool, 3);\r\n    let bool4 = generateSystemType(\"bool4\", -1, bool, 4);\r\n\r\n    {\r\n        let suf2f: IVariableDeclInstruction[] = [];\r\n        // program.push(EScopeType.k_Struct);\r\n        addFieldsToVectorFromSuffixObject(suf2f, XYSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf2f, RGSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf2f, STSuffix, \"float\");\r\n        // program.pop();\r\n        suf2f.forEach(field => float2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3f, XYZSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf3f, RGBSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf3f, STPSuffix, \"float\");\r\n        suf3f.forEach(field => float3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4f: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4f, XYZWSuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf4f, RGBASuffix, \"float\");\r\n        addFieldsToVectorFromSuffixObject(suf4f, STPQSuffix, \"float\");\r\n        suf4f.forEach(field => float4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2i, XYSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf2i, RGSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf2i, STSuffix, \"int\");\r\n        suf2i.forEach(field => int2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3i, XYZSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf3i, RGBSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf3i, STPSuffix, \"int\");\r\n        suf3i.forEach(field => int3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4i: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4i, XYZWSuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf4i, RGBASuffix, \"int\");\r\n        addFieldsToVectorFromSuffixObject(suf4i, STPQSuffix, \"int\");\r\n        suf4i.forEach(field => int4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2ui, XYSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf2ui, RGSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf2ui, STSuffix, \"uint\");\r\n        suf2ui.forEach(field => uint2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3ui, XYZSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf3ui, RGBSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf3ui, STPSuffix, \"uint\");\r\n        suf3ui.forEach(field => uint3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4ui: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4ui, XYZWSuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf4ui, RGBASuffix, \"uint\");\r\n        addFieldsToVectorFromSuffixObject(suf4ui, STPQSuffix, \"uint\");\r\n        suf4ui.forEach(field => uint4.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf2b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf2b, XYSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf2b, RGSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf2b, STSuffix, \"bool\");\r\n        suf2b.forEach(field => bool2.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf3b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf3b, XYZSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf3b, RGBSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf3b, STPSuffix, \"bool\");\r\n        suf3b.forEach(field => bool3.addField(field));\r\n    }\r\n\r\n    {\r\n        let suf4b: IVariableDeclInstruction[] = [];\r\n        addFieldsToVectorFromSuffixObject(suf4b, XYZWSuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf4b, RGBASuffix, \"bool\");\r\n        addFieldsToVectorFromSuffixObject(suf4b, STPQSuffix, \"bool\");\r\n        suf4b.forEach(field => bool4.addField(field));\r\n    }\r\n}\r\n\r\n\r\nfunction addSystemTypeMatrix(): void {\r\n    let float2 = getSystemType(\"float2\");\r\n    let float3 = getSystemType(\"float3\");\r\n    let float4 = getSystemType(\"float4\");\r\n\r\n    let int2 = getSystemType(\"int2\");\r\n    let int3 = getSystemType(\"int3\");\r\n    let int4 = getSystemType(\"int4\");\r\n\r\n    let uint2 = getSystemType(\"uint2\");\r\n    let uint3 = getSystemType(\"uint3\");\r\n    let uint4 = getSystemType(\"uint4\");\r\n\r\n    let bool2 = getSystemType(\"bool2\");\r\n    let bool3 = getSystemType(\"bool3\");\r\n    let bool4 = getSystemType(\"bool4\");\r\n\r\n    generateSystemType(\"float2x2\", -1, float2, 2);\r\n    generateSystemType(\"float2x3\", -1, float2, 3);\r\n    generateSystemType(\"float2x4\", -1, float2, 4);\r\n\r\n    generateSystemType(\"float3x2\", -1, float3, 2);\r\n    generateSystemType(\"float3x3\", -1, float3, 3);\r\n    generateSystemType(\"float3x4\", -1, float3, 4);\r\n\r\n    generateSystemType(\"float4x2\", -1, float4, 2);\r\n    generateSystemType(\"float4x3\", -1, float4, 3);\r\n    generateSystemType(\"float4x4\", -1, float4, 4);\r\n\r\n    generateSystemType(\"int2x2\", -1, int2, 2);\r\n    generateSystemType(\"int2x3\", -1, int2, 3);\r\n    generateSystemType(\"int2x4\", -1, int2, 4);\r\n\r\n    generateSystemType(\"int3x2\", -1, int3, 2);\r\n    generateSystemType(\"int3x3\", -1, int3, 3);\r\n    generateSystemType(\"int3x4\", -1, int3, 4);\r\n\r\n    generateSystemType(\"int4x2\", -1, int4, 2);\r\n    generateSystemType(\"int4x3\", -1, int4, 3);\r\n    generateSystemType(\"int4x4\", -1, int4, 4);\r\n\r\n    generateSystemType(\"bool2x2\", -1, bool2, 2);\r\n    generateSystemType(\"bool2x3\", -1, bool2, 3);\r\n    generateSystemType(\"bool2x4\", -1, bool2, 4);\r\n\r\n    generateSystemType(\"bool3x2\", -1, bool3, 2);\r\n    generateSystemType(\"bool3x3\", -1, bool3, 3);\r\n    generateSystemType(\"bool3x4\", -1, bool3, 4);\r\n\r\n    generateSystemType(\"bool4x2\", -1, bool4, 2);\r\n    generateSystemType(\"bool4x3\", -1, bool4, 3);\r\n    generateSystemType(\"bool4x4\", -1, bool4, 4);\r\n}\r\n\r\n\r\nfunction generateSuffixLiterals(literals: string[], output: IMap<boolean>, depth: number = 0): void {\r\n    if (depth >= literals.length) {\r\n        return;\r\n    }\r\n\r\n    if (depth === 0) {\r\n        for (let i = 0; i < literals.length; i++) {\r\n            output[literals[i]] = true;\r\n        }\r\n\r\n        depth = 1;\r\n    }\r\n\r\n    const outputKeys = Object.keys(output);\r\n\r\n    for (let i = 0; i < literals.length; i++) {\r\n        for (let j = 0; j < outputKeys.length; j++) {\r\n            if (outputKeys[j].indexOf(literals[i]) !== -1) {\r\n                output[outputKeys[j] + literals[i]] = false;\r\n            }\r\n            else {\r\n                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;\r\n            }\r\n        }\r\n    }\r\n\r\n    depth++;\r\n\r\n    generateSuffixLiterals(literals, output, depth);\r\n}\r\n\r\n\r\nfunction generateSystemFunctionInstance(type: ITypeInstruction, name: string, paramTypes: ITypeInstruction[], vertex: boolean, pixel: boolean) {\r\n    let paramList = paramTypes.map((type, n) => {\r\n        return new VariableDeclInstruction({ \r\n            type: new VariableTypeInstruction({ type, scope }), \r\n            id: new IdInstruction({ name: `p${n}`, scope }), \r\n            scope });\r\n    });\r\n\r\n    let returnType = new VariableTypeInstruction({ type, scope });\r\n    let id = new IdInstruction({ scope, name });\r\n    let definition = new FunctionDefInstruction({ scope, returnType, id, paramList });\r\n    let func = new SystemFunctionInstruction({ scope, definition, pixel, vertex });\r\n\r\n    scope.addFunction(func);\r\n}\r\n\r\n\r\n/**\r\n * Exampler:\r\n *  generateSystemFunction(\"dot\", \"dot($1,$2)\",   \"float\",    [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n *                         name   translationExpr returnType  argsTypes                       templateTypes\r\n */\r\nfunction generateSystemFunction(\r\n    name: string,\r\n    returnTypeName: string,\r\n    paramTypeNames: string[],\r\n    templateTypes: string[],\r\n    isForVertex: boolean = true,\r\n    isForPixel: boolean = true): void {\r\n\r\n    if (!isNull(templateTypes)) {\r\n        for (let i = 0; i < templateTypes.length; i++) {\r\n            let funcHash = name + \"(\";\r\n            let returnType = (returnTypeName === TEMPLATE_TYPE) ?\r\n                getSystemType(templateTypes[i]) :\r\n                getSystemType(returnTypeName);\r\n            let paramTypes: ITypeInstruction[] = [];\r\n\r\n            for (let j = 0; j < paramTypeNames.length; j++) {\r\n                if (paramTypeNames[j] === TEMPLATE_TYPE) {\r\n                    paramTypes.push(getSystemType(templateTypes[i]));\r\n                    funcHash += templateTypes[i] + \",\";\r\n                }\r\n                else {\r\n                    paramTypes.push(getSystemType(paramTypeNames[j]));\r\n                    funcHash += paramTypeNames[j] + \",\"\r\n                }\r\n            }\r\n\r\n            funcHash += \")\";\r\n\r\n            if (systemFunctionHashMap[funcHash]) {\r\n                _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n            }\r\n\r\n            generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);\r\n            systemFunctionHashMap[funcHash] = true;\r\n        }\r\n    }\r\n    else {\r\n        if (returnTypeName === TEMPLATE_TYPE) {\r\n            _emitException(\"Bad return type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n        }\r\n\r\n        let funcHash = name + \"(\";\r\n        let returnType = getSystemType(returnTypeName);\r\n        let paramTypes: ITypeInstruction[] = [];\r\n\r\n        for (let i = 0; i < paramTypeNames.length; i++) {\r\n            if (paramTypeNames[i] === TEMPLATE_TYPE) {\r\n                _emitException(\"Bad argument type(TEMPLATE_TYPE) for system function '\" + name + \"'.\");\r\n            }\r\n            else {\r\n                paramTypes.push(getSystemType(paramTypeNames[i]));\r\n                funcHash += paramTypeNames[i] + \",\";\r\n            }\r\n        }\r\n\r\n        funcHash += \")\";\r\n\r\n        if (systemFunctionHashMap[funcHash]) {\r\n            _error(EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });\r\n        }\r\n\r\n        generateSystemFunctionInstance(returnType, name, paramTypes, isForVertex, isForPixel);\r\n        systemFunctionHashMap[funcHash] = true;\r\n    }\r\n}\r\n\r\n\r\n// function generateNotBuiltInSystemFunction(name: string, definition: string, implementation: string,\r\n//     returnTypeName: string,\r\n//     usedTypes: string[],\r\n//     usedFunctions: string[]): void {\r\n\r\n//     if (scope.hasFunction(name)) {\r\n//         console.warn(`Builtin function ${name} already exists.`);\r\n//         return;\r\n//     }\r\n\r\n//     let builtIn = false;\r\n//     let returnType = getSystemType(returnTypeName);\r\n//     let id = new IdInstruction({ scope, name })\r\n//     let func = new SystemFunctionInstruction({ scope, id, returnType, definition, implementation, builtIn });\r\n\r\n//     let usedExtSystemTypes: ITypeDeclInstruction[] = [];\r\n//     let usedExtSystemFunctions: IFunctionDeclInstruction[] = [];\r\n\r\n//     if (!isNull(usedTypes)) {\r\n//         for (let i = 0; i < usedTypes.length; i++) {\r\n//             let typeDecl: ITypeDeclInstruction = <ITypeDeclInstruction>getSystemType(usedTypes[i]).parent;\r\n//             if (!isNull(typeDecl)) {\r\n//                 usedExtSystemTypes.push(typeDecl);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     if (!isNull(usedFunctions)) {\r\n//         for (let i = 0; i < usedFunctions.length; i++) {\r\n//             let pFindFunction: IFunctionDeclInstruction = scope.findFunction(usedFunctions[i]);\r\n//             usedExtSystemFunctions.push(pFindFunction);\r\n//         }\r\n//     }\r\n\r\n//     func.$setUsedSystemData(usedExtSystemTypes, usedExtSystemFunctions);\r\n//     func.$closeSystemDataInfo();\r\n\r\n//     scope.addFunction(func);\r\n// }\r\n\r\n\r\n// TODO: rework system function templates for better readability\r\nfunction addSystemFunctions(): void {\r\n    generateSystemFunction(\"dot\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul\r\n    // TODO: add support for int|uint|bool based vectors \r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(\"mul\", TEMPLATE_TYPE, [\"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\", \"float2x2\", \"float3x3\", \"float4x4\"]);\r\n    generateSystemFunction(\"mul\", \"float4\", [\"float4\", TEMPLATE_TYPE], [\"float4x4\", \"float4x3\", \"float4x2\"]);\r\n    generateSystemFunction(\"mul\", \"float3\", [\"float3\", TEMPLATE_TYPE], [\"float3x4\", \"float3x3\", \"float3x2\"]);\r\n    generateSystemFunction(\"mul\", \"float2\", [\"float2\", TEMPLATE_TYPE], [\"float2x4\", \"float2x3\", \"float2x2\"]);\r\n    generateSystemFunction(\"mul\", \"float4\", [TEMPLATE_TYPE, \"float4\"], [\"float4x4\", \"float3x4\", \"float2x4\"]);\r\n    generateSystemFunction(\"mul\", \"float3\", [TEMPLATE_TYPE, \"float3\"], [\"float4x3\", \"float3x3\", \"float2x3\"]);\r\n    generateSystemFunction(\"mul\", \"float2\", [TEMPLATE_TYPE, \"float2\"], [\"float4x2\", \"float3x2\", \"float2x2\"]);\r\n\r\n    /**\r\n     * scalar = int|uint|float\r\n     * vector = vector<int|uint|float, n>, n = 2,3,4\r\n     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4\r\n     * \r\n     * scalar mul(scalar, scalar)\r\n     * vector mul(scalar, vector)\r\n     * vector mul(vector, scalar)\r\n     * vector mul(vector, vector)\r\n     * matrix mul(scalar, matrix)\r\n     * matrix mul(matrix, scalar)\r\n     * vector mul(vector, matrix)\r\n     * vector mul(matrix, vector)\r\n     * matrix mul(matrix, matrix)\r\n     */\r\n\r\n    generateSystemFunction(\"mod\", \"float\", [\"float\", \"float\"], null);\r\n    generateSystemFunction(\"floor\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"ceil\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"fract\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"abs\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sign\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"normalize\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"length\", \"float\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"cross\", \"float3\", [\"float3\", \"float3\"], null);\r\n    generateSystemFunction(\"reflect\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"int\"], [\"int2\", \"int3\", \"int4\"]);\r\n\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"max\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"uint\"], [\"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"int\"], [\"int2\", \"int3\", \"int4\"]);\r\n\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"min\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"uint\"], [\"uint2\", \"uint3\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"clamp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\", \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"pow\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"mod\", TEMPLATE_TYPE, [TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"exp\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"exp2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"log\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"log2\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"inversesqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sqrt\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"all\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    generateSystemFunction(\"any\", \"bool\", [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n    generateSystemFunction(\"not\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"distance\", \"float\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"lessThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"lessThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"lessThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"lessThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"lessThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"lessThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"equal\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"equal\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"equal\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(\"equal\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"notEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"notEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"notEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n    generateSystemFunction(\"notEqual\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"bool2\", \"bool3\", \"bool4\"]);\r\n\r\n    generateSystemFunction(\"greaterThan\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"greaterThan\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"greaterThan\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool2\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float2\", \"int2\", \"uint2\"]);\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool3\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float3\", \"int3\", \"uint3\"]);\r\n    generateSystemFunction(\"greaterThanEqual\", \"bool4\", [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float4\", \"int4\", \"uint4\"]);\r\n\r\n\r\n    generateSystemFunction(\"radians\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"degrees\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"sin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"cos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"tan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"asin\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"acos\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"atan\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler\", \"float2\"], null);\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler2D\", \"float2\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float4\"], null);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\"], null);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"sampler\", \"float3\"], null);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\"], null);\r\n\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2D\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"tex2DProj\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, false, true);\r\n    generateSystemFunction(\"texCUBE\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, false, true);\r\n\r\n    generateSystemFunction(\"tex2DLod\", \"float4\", [\"sampler\", \"float2\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DLod\", \"float4\", [\"sampler2D\", \"float2\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler\", \"float4\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"tex2DProjLod\", \"float4\", [\"sampler2D\", \"float4\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"texCUBELod\", \"float4\", [\"sampler\", \"float3\", \"float\"], null, true, false);\r\n    generateSystemFunction(\"texCUBELod\", \"float4\", [\"samplerCUBE\", \"float3\", \"float\"], null, true, false);\r\n\r\n    //OES_standard_derivatives\r\n\r\n    generateSystemFunction(\"dFdx\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"dFdy\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"width\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"fwidth\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    // generateSystemFunction(\"smoothstep\", \"float3\", [\"float3\", \"float3\", \"float3\"], null);\r\n\r\n    generateSystemFunction(\"smoothstep\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"smoothstep\", TEMPLATE_TYPE, [\"float\", \"float\", TEMPLATE_TYPE], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"frac\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n    generateSystemFunction(\"lerp\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, \"float\"], [\"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"saturate\", TEMPLATE_TYPE, [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\"]);\r\n\r\n    generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"float\"/*, \"uint\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"int\"/*, \"uint\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float2\", [TEMPLATE_TYPE], [\"int2\"/*, \"uint2\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float3\", [TEMPLATE_TYPE], [\"int3\"/*, \"uint3\"*/]);\r\n    generateSystemFunction(\"asfloat\", \"float4\", [TEMPLATE_TYPE], [\"int4\"/*, \"uint4\"*/]);\r\n    \r\n    generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"uint\"]);\r\n    generateSystemFunction(\"asint\", \"int2\", [TEMPLATE_TYPE], [\"float2\", \"uint2\"]);\r\n    generateSystemFunction(\"asint\", \"int3\", [TEMPLATE_TYPE], [\"float3\", \"uint3\"]);\r\n    generateSystemFunction(\"asint\", \"int4\", [TEMPLATE_TYPE], [\"float4\", \"uint4\"]);\r\n    \r\n    generateSystemFunction(\"asuint\", \"uint\", [TEMPLATE_TYPE], [\"float\", \"int\"]);\r\n    generateSystemFunction(\"asuint\", \"uint2\", [TEMPLATE_TYPE], [\"float2\", \"int2\"]);\r\n    generateSystemFunction(\"asuint\", \"uint3\", [TEMPLATE_TYPE], [\"float3\", \"int3\"]);\r\n    generateSystemFunction(\"asuint\", \"uint4\", [TEMPLATE_TYPE], [\"float4\", \"int4\"]);\r\n\r\n    generateSystemFunction(\"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"int\"]);\r\n    // generateSystemFunction(\"InterlockedAdd\", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], [\"uint\"]);\r\n\r\n    // generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"asfloat\", \"float\", [TEMPLATE_TYPE], [\"int\", \"int2\", \"int3\", \"int4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n    // generateSystemFunction(\"asint\", \"int\", [TEMPLATE_TYPE], [\"float\", \"float2\", \"float3\", \"float4\", \"uint\", \"uint2\", \"uint3\", \"uint4\"]);\r\n}\r\n\r\n\r\n\r\n// function generateSystemVariable(name: string, typeName: string,\r\n//     isForVertex: boolean, isForPixel: boolean, readonly: boolean): void {\r\n\r\n//     if (scope.hasVariable(name)) {\r\n//         return;\r\n//     }\r\n\r\n//     let id = new IdInstruction({ scope, name });\r\n//     let type = new VariableTypeInstruction({ scope, type: getSystemType(typeName), writable: readonly });\r\n//     let variableDecl = new VariableDeclInstruction({ scope, id, type, builtIn: true });\r\n\r\n//     variableDecl.$makeVertexCompatible(isForVertex);\r\n//     variableDecl.$makePixelCompatible(isForPixel);\r\n\r\n//     scope.addVariable(variableDecl);\r\n// }\r\n\r\n\r\nfunction getSystemType(typeName: string): SystemTypeInstruction {\r\n    //boolean, string, float and others\r\n    let type = <SystemTypeInstruction>scope.findType(typeName);\r\n    assert(!type || (type.instructionType === EInstructionTypes.k_SystemType));\r\n    return type;\r\n}\r\n\r\n\r\n// function addSystemVariables(): void {\r\n    // generateSystemVariable(\"fragColor\", \"gl_FragColor\", \"float4\", false, true, true);\r\n    // generateSystemVariable(\"fragCoord\", \"gl_FragCoord\", \"float4\", false, true, true);\r\n    // generateSystemVariable(\"frontFacing\", \"gl_FrontFacing\", \"bool\", false, true, true);\r\n    // generateSystemVariable(\"pointCoord\", \"gl_PointCoord\", \"float2\", false, true, true);\r\n// }\r\n\r\n\r\nfunction initSystemTypes(): void {\r\n    addSystemTypeScalar();\r\n    addSystemTypeVector();\r\n    addSystemTypeMatrix();\r\n    \r\n    scope.addTypeTemplate(new RWBufferTemplate);\r\n    scope.addTypeTemplate(new RWStructuredBufferTemplate);\r\n    scope.addTypeTemplate(new AppendStructuredBufferTemplate);\r\n}\r\n\r\n\r\nfunction initSystemFunctions(): void {\r\n    addSystemFunctions();\r\n}\r\n\r\n\r\n// function initSystemVariables(): void {\r\n//     addSystemVariables();\r\n// }\r\n\r\n\r\ninitSystemTypes();\r\ninitSystemFunctions();\r\n// initSystemVariables();\r\n\r\n/**\r\n * Export API\r\n */\r\n\r\nexport const SCOPE = scope;\r\n\r\nexport const T_VOID = scope.findType(\"void\");\r\nexport const T_STRING = scope.findType(\"string\");\r\n\r\nexport const T_FLOAT = scope.findType(\"float\");\r\nexport const T_FLOAT2 = scope.findType(\"float2\");\r\nexport const T_FLOAT3 = scope.findType(\"float3\");\r\nexport const T_FLOAT4 = scope.findType(\"float4\");\r\n\r\nexport const T_FLOAT2X2 = scope.findType(\"float2x2\");\r\nexport const T_FLOAT3X3 = scope.findType(\"float3x3\");\r\nexport const T_FLOAT4X4 = scope.findType(\"float4x4\");\r\n\r\nexport const T_BOOL = scope.findType(\"bool\");\r\nexport const T_BOOL2 = scope.findType(\"bool2\");\r\nexport const T_BOOL3 = scope.findType(\"bool3\");\r\nexport const T_BOOL4 = scope.findType(\"bool4\");\r\n\r\nexport const T_BOOL2X2 = scope.findType(\"bool2x2\");\r\nexport const T_BOOL3X3 = scope.findType(\"bool3x3\");\r\nexport const T_BOOL4X4 = scope.findType(\"bool4x4\");\r\n\r\nexport const T_INT = scope.findType(\"int\");\r\nexport const T_INT2 = scope.findType(\"int2\");\r\nexport const T_INT3 = scope.findType(\"int3\");\r\nexport const T_INT4 = scope.findType(\"int4\");\r\n\r\nexport const T_UINT = scope.findType(\"uint\");\r\nexport const T_UINT2 = scope.findType(\"uint2\");\r\nexport const T_UINT3 = scope.findType(\"uint3\");\r\nexport const T_UINT4 = scope.findType(\"uint4\");\r\n\r\nexport const T_INT2X2 = scope.findType(\"int2x2\");\r\nexport const T_INT3X3 = scope.findType(\"int3x3\");\r\nexport const T_INT4X4 = scope.findType(\"int4x4\");\r\n\r\nexport const T_SAMPLER = scope.findType(\"sampler\");\r\nexport const T_SAMPLER_2D = scope.findType(\"sampler2D\");\r\nexport const T_SAMPLER_CUBE = scope.findType(\"samplerCUBE\");\r\n\r\nexport const findType = (typeName: string) => scope.findType(typeName);\r\nexport const findVariable = (varName: string) => scope.findVariable(varName);\r\nexport const findTechnique = (techName: string) => scope.findTechnique(techName);\r\nexport const findFunction = (funcName: string, args?: ITypeInstruction[]) => scope.findFunction(funcName, args);\r\n\r\nexport const hasType = (typeName: string) => !isNull(scope.findType(typeName));\r\nexport const hasVariable = (varName: string) => !isNull(scope.findVariable(varName));\r\nexport const hasTechnique = (techName: string) => !isNull(scope.findTechnique(techName));\r\n\r\nexport function isMatrixType(type: ITypeInstruction): boolean { \r\n    return type.isEqual(getSystemType(\"float2x2\")) ||\r\n        type.isEqual(getSystemType(\"float3x3\")) ||\r\n        type.isEqual(getSystemType(\"float4x4\")) ||\r\n        type.isEqual(getSystemType(\"int2x2\")) ||\r\n        type.isEqual(getSystemType(\"int3x3\")) ||\r\n        type.isEqual(getSystemType(\"int4x4\")) ||\r\n        type.isEqual(getSystemType(\"bool2x2\")) ||\r\n        type.isEqual(getSystemType(\"bool3x3\")) ||\r\n        type.isEqual(getSystemType(\"bool4x4\"));\r\n}\r\n\r\n\r\nexport function isVectorType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(getSystemType(\"float2\")) ||\r\n        type.isEqual(getSystemType(\"float3\")) ||\r\n        type.isEqual(getSystemType(\"float4\")) ||\r\n        type.isEqual(getSystemType(\"bool2\")) ||\r\n        type.isEqual(getSystemType(\"bool3\")) ||\r\n        type.isEqual(getSystemType(\"bool4\")) ||\r\n        type.isEqual(getSystemType(\"int2\")) ||\r\n        type.isEqual(getSystemType(\"int3\")) ||\r\n        type.isEqual(getSystemType(\"int4\")) || \r\n        type.isEqual(getSystemType(\"uint2\")) ||\r\n        type.isEqual(getSystemType(\"uint3\")) ||\r\n        type.isEqual(getSystemType(\"uint4\"));\r\n}\r\n\r\n\r\nexport function isScalarType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_BOOL) ||\r\n        type.isEqual(T_INT) ||\r\n        type.isEqual(T_UINT) ||\r\n        type.isEqual(T_FLOAT);\r\n}\r\n\r\n\r\nexport function isFloatBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_FLOAT) ||\r\n        type.isEqual(T_FLOAT2) ||\r\n        type.isEqual(T_FLOAT3) ||\r\n        type.isEqual(T_FLOAT4) ||\r\n        type.isEqual(T_FLOAT2X2) ||\r\n        type.isEqual(T_FLOAT3X3) ||\r\n        type.isEqual(T_FLOAT4X4);\r\n}\r\n\r\n\r\nexport function isIntBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_INT) ||\r\n        type.isEqual(T_INT2) ||\r\n        type.isEqual(T_INT3) ||\r\n        type.isEqual(T_INT4) ||\r\n        type.isEqual(T_INT2X2) ||\r\n        type.isEqual(T_INT3X3) ||\r\n        type.isEqual(T_INT4X4);\r\n}\r\n\r\n\r\nexport function isUIntBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_UINT) ||\r\n        type.isEqual(T_UINT2) ||\r\n        type.isEqual(T_UINT3) ||\r\n        type.isEqual(T_UINT4);\r\n}\r\n\r\n\r\nexport function isBoolBasedType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_BOOL) ||\r\n        type.isEqual(T_BOOL2) ||\r\n        type.isEqual(T_BOOL3) ||\r\n        type.isEqual(T_BOOL4) ||\r\n        type.isEqual(T_BOOL2X2) ||\r\n        type.isEqual(T_BOOL3X3) ||\r\n        type.isEqual(T_BOOL4X4);\r\n}\r\n\r\n\r\nexport function isSamplerType(type: ITypeInstruction): boolean {\r\n    return type.isEqual(T_SAMPLER) ||\r\n        type.isEqual(getSystemType(\"sampler2D\")) ||\r\n        type.isEqual(getSystemType(\"samplerCUBE\"));\r\n}\r\n\r\n\r\n\r\n/** @deprecated */\r\nexport function getExternalType(type: ITypeInstruction): any {\r\n    if (type.isEqual(T_INT) ||\r\n        type.isEqual(T_UINT) ||\r\n        type.isEqual(T_FLOAT)) {\r\n        return Number;\r\n    }\r\n    else if (type.isEqual(T_BOOL)) {\r\n        return \"Boolean\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT2) ||\r\n        type.isEqual(T_BOOL2) ||\r\n        type.isEqual(T_INT2) ||\r\n        type.isEqual(T_UINT2)) {\r\n        return \"Vec2\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT3) ||\r\n        type.isEqual(T_BOOL3) ||\r\n        type.isEqual(T_INT3) ||\r\n        type.isEqual(T_UINT3)) {\r\n        return \"Vec3\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT4) ||\r\n        type.isEqual(T_BOOL4) ||\r\n        type.isEqual(T_INT4) ||\r\n        type.isEqual(T_UINT4)) {\r\n        return \"Vec4\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT2X2) ||\r\n        type.isEqual(T_BOOL2X2) ||\r\n        type.isEqual(T_INT2X2)) {\r\n        return \"Vec2\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT3X3) ||\r\n        type.isEqual(T_BOOL3X3) ||\r\n        type.isEqual(T_INT3X3)) {\r\n        return \"Mat3\";\r\n    }\r\n    else if (type.isEqual(T_FLOAT4X4) ||\r\n        type.isEqual(T_BOOL4X4) ||\r\n        type.isEqual(T_INT4X4)) {\r\n        return \"Mat4\";\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { ECheckStage, EInstructionTypes, IExprInstruction, IForStmtInstruction, IStmtInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IForStmtInstructionSettings extends IInstructionSettings {\r\n    init?: ITypedInstruction;\r\n    cond?: IExprInstruction;\r\n    step?: IExprInstruction;\r\n    body?: IStmtInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent for(forInit forCond ForStep) stmt\r\n * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction\r\n */\r\nexport class ForStmtInstruction extends StmtInstruction implements IForStmtInstruction {\r\n    protected _init: ITypedInstruction;\r\n    protected _cond: IExprInstruction;\r\n    protected _step: IExprInstruction;\r\n    protected _body: IStmtInstruction;\r\n\r\n    constructor({ init = null, cond = null, step = null, body = null, ...settings }: IForStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ForStmt, ...settings });\r\n\r\n        this._init = Instruction.$withParent(init, this);\r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._step = Instruction.$withParent(step, this);\r\n        this._body = Instruction.$withParent(body, this);\r\n    }\r\n\r\n\r\n    get init(): ITypedInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    get cond(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n\r\n    get step(): IExprInstruction {\r\n        return this._step;\r\n    }\r\n\r\n\r\n    get body(): IStmtInstruction {\r\n        return this._body;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"for(\";\r\n\r\n        code += this._init.toCode() + \";\";\r\n        code += this._cond.toCode() + \";\";\r\n        code += this._step.toCode() + \")\";\r\n        code += this._body.toCode();\r\n\r\n        return code;\r\n    }\r\n\r\n    // TODO: move it to Analysis.ts\r\n    check(stage: ECheckStage, info: any = null): boolean {\r\n        if (isNull(this._step)) {\r\n            this._setError(EAnalyzerErrors.InvalidForStepEmpty);\r\n            return false;\r\n        }\r\n\r\n        if (isNull(this._init)) {\r\n            this._setError(EAnalyzerErrors.InvalidForInitEmptyIterator);\r\n            return false;\r\n        }\r\n\r\n        if (this._init.instructionType !== EInstructionTypes.k_VariableDecl) {\r\n            this._setError(EAnalyzerErrors.InvalidForInitExpr);\r\n            return false;\r\n        }\r\n\r\n        if (isNull(this._cond)) {\r\n            this._setError(EAnalyzerErrors.InvalidForConditionEmpty);\r\n            return false;\r\n        }\r\n\r\n        if (this._cond.instructionType !== EInstructionTypes.k_RelationalExpr) {\r\n            this._setError(EAnalyzerErrors.InvalidForConditionRelation);\r\n            return false;\r\n        }\r\n\r\n        if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||\r\n            this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||\r\n            this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {\r\n            \r\n            // todo: rewrite this check!!\r\n            // var sOperator: string = this._step.operator;\r\n            // if (sOperator !== \"++\" && sOperator !== \"--\" &&\r\n            //     sOperator !== \"+=\" && sOperator !== \"-=\") {\r\n            //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });\r\n            //     return false;\r\n            // }\r\n        }\r\n        else {\r\n            this._setError(EAnalyzerErrors.InvalidForStepExpr);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { EInstructionTypes, IAssignmentExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport type AssigmentOperator = \"=\" | \"+=\" | \"-=\" | \"/=\" | \"*=\" | \"%=\";\r\n\r\nexport interface IAssignmentExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: ITypedInstruction;\r\n    operator: AssigmentOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr = += -= /= *= %= someExpr\r\n * (=|+=|-=|*=|/=|%=) Instruction Instruction\r\n */\r\nexport class AssignmentExprInstruction extends ExprInstruction implements IAssignmentExprInstruction {\r\n    protected _leftValue: IExprInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n    protected _operator: AssigmentOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IAssignmentExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });\r\n\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n    get operator(): string {\r\n        return this._operator;\r\n    }\r\n\r\n    toCode(): string {\r\n        var code: string = \"\";\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypedInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypedInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\nexport class TypedInstruction extends Instruction implements ITypedInstruction {\r\n    protected _type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypedInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Typed, ...settings });\r\n        \r\n        this._type = Instruction.$withNoParent(type);\r\n\r\n        // todo: remove this check\r\n        if (isNull(this._type)) {\r\n            console.warn(\"Something goes wrong! Type is not specified!\", this);\r\n        }\r\n    }\r\n\r\n\r\n    get type(): ITypeInstruction {\r\n        return this._type;\r\n    }\r\n}\r\n","export const END_POSITION               = 'END';                 // item, parser\r\nexport const T_EMPTY                    = 'EMPTY';               // item, parser\r\nexport const UNKNOWN_TOKEN              = 'UNKNOWN';             // lexer\r\nexport const START_SYMBOL               = 'S';                   // parser\r\nexport const UNUSED_SYMBOL              = '##';                  // parser\r\nexport const INLINE_COMMENT_SYMBOL      = '#';                   // parser\r\n// TODO: do not use ambigious name 'ERROR'\r\nexport const ERROR                      = 'ERROR';               // parser\r\nexport const END_SYMBOL                 = '$';                   // lexer, parser\r\nexport const LEXER_RULES                = '--LEXER--';           // parser\r\nexport const FLAG_RULE_CREATE_NODE      = '--add';                // parser\r\nexport const FLAG_RULE_SKIP_NODE        = '--skip';              // parser\r\nexport const FLAG_RULE_EXPOSE_NODE      = '--expose';            // parser\r\nexport const FLAG_RULE_FUNCTION         = '--F';                 // parser\r\nexport const EOF                        = 'EOF';                 // lexer\r\nexport const T_STRING                   = 'T_STRING';            // lexer\r\nexport const T_FLOAT                    = 'T_FLOAT';             // lexer\r\nexport const T_UINT                     = 'T_UINT';              // lexer\r\nexport const T_TYPE_ID                  = 'T_TYPE_ID';           // lexer\r\nexport const T_NON_TYPE_ID              = 'T_NON_TYPE_ID';       // lexer\r\nexport const T_LINE_TERMINATOR          = 'T_LINE_TERMINATOR';   // lexer\r\n","import { EInstructionTypes, IDeclInstruction, IDeclStmtInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IDeclStmtInstructionSettings extends IInstructionSettings {\r\n    declList?: IDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent TypeDecl or VariableDecl or VarStructDecl\r\n * EMPTY DeclInstruction\r\n */\r\nexport class DeclStmtInstruction extends StmtInstruction implements IDeclStmtInstruction {\r\n    private _declList: IDeclInstruction[];\r\n\r\n    \r\n    constructor({ declList = null, ...settings }: IDeclStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_DeclStmt, ...settings });\r\n        \r\n        this._declList = (declList || []).map(decl => Instruction.$withParent(decl, this));\r\n    }\r\n\r\n\r\n    get declList(): IDeclInstruction[] {\r\n        return this._declList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code = '';\r\n        var declList = <IVariableDeclInstruction[]>this.declList;\r\n\r\n        for (var i: number = 0; i < this.declList.length; i++) {\r\n            code += declList[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n\r\n\r\n\r\n","export enum EAnalyzerWarnings {\r\n    UnsupportedRenderStateTypeUsed = 3000,\r\n    IncompleteTechnique,\r\n    IncompletePass,\r\n    UselessPassState,\r\n    // part fx\r\n}","import { ISLASTDocument } from '@lib/idl/ISLASTDocument';\r\nimport { ITextDocument } from '@lib/idl/ITextDocument';\r\nimport { EOperationType, EParserCode, IASTConfig, IRange, IToken } from '@lib/idl/parser/IParser';\r\nimport { ASTDocument, EParsingErrors } from \"@lib/parser/ASTDocument\";\r\nimport { Lexer } from '@lib/parser/Lexer';\r\nimport { END_SYMBOL } from '@lib/parser/symbols';\r\nimport * as URI from \"@lib/uri/uri\"\r\n\r\nimport { defaultSLParser } from './SLParser';\r\n\r\n// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));\r\n\r\nconst PREDEFINED_TYPES = [\r\n    'float2', 'float3', 'float4',\r\n    'float2x2', 'float3x3', 'float4x4',\r\n    'int2', 'int3', 'int4',\r\n    'uint2', 'uint3', 'uint4',\r\n    'bool2', 'bool3', 'bool4',\r\n    'auto'\r\n];\r\n\r\nexport class SLASTDocument extends ASTDocument implements ISLASTDocument {\r\n    protected includeList: Map<string, IRange>;\r\n    protected lexers: Lexer[];\r\n    protected tokens: IToken[];\r\n\r\n    constructor({ parser = defaultSLParser() }: IASTConfig = {}) {\r\n        super({ parser, knownTypes: new Set(PREDEFINED_TYPES) });\r\n    }\r\n\r\n    get includes(): Map<string, IRange> {\r\n        return this.includeList;\r\n    }\r\n    \r\n    async parse(textDocument: ITextDocument, flags?: number): Promise<EParserCode> {\r\n        this.includeList.set(textDocument.uri, null);\r\n        return await super.parse(textDocument, flags);\r\n    }\r\n\r\n\r\n    protected init(config: IASTConfig) {\r\n        super.init(config);\r\n\r\n        this.includeList = new Map();\r\n        this.lexers = [];\r\n        this.tokens = [];\r\n        this.ruleFunctions.set('addType', this._addType.bind(this));\r\n        this.ruleFunctions.set('includeCode', this._includeCode.bind(this));\r\n    }\r\n\r\n    private _addType(): EOperationType {\r\n        const tree = this.tree;\r\n        const node = tree.lastNode;\r\n        const typeId = node.children[node.children.length - 2].value;\r\n        this.knownTypes.add(typeId);\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private emitFileNotFound(file: string, range: IRange) {\r\n        this.diag.error(EParsingErrors.GeneralCouldNotReadFile, { ...this.lexer.getLocation(), loc: range, target: file });\r\n    }\r\n\r\n\r\n    protected readToken(): IToken {\r\n        const token = super.readToken();\r\n        if (token.value === END_SYMBOL) {\r\n            if (this.lexers.length > 0) {\r\n                this.lexer = this.lexers.pop();\r\n                return this.tokens.pop();\r\n            }\r\n        }\r\n        return token;\r\n    }\r\n\r\n\r\n    private async _includeCode(): Promise<EOperationType> {\r\n        let tree = this.tree;\r\n        let node = tree.lastNode;\r\n        let file = node.value;\r\n\r\n        //cuttin qoutes\r\n        const includeURL = file.substr(1, file.length - 2);\r\n        const uri = URI.resolve(includeURL, `${this.uri}`);\r\n\r\n        if (this.includeList.has(uri)) {\r\n            console.warn(`'${uri}' file has already been included previously.`);\r\n            return EOperationType.k_Ok;\r\n        } \r\n\r\n        this.includeList.set(uri, node.loc);\r\n\r\n        try {\r\n            const response = await fetch(uri);\r\n            \r\n            if (!response.ok) {\r\n                this.emitFileNotFound(uri, node.loc);\r\n                return EOperationType.k_Error;\r\n            }\r\n\r\n        const source = await response.text();\r\n            \r\n            //\r\n            // Replace lexer with new one \r\n            //\r\n\r\n            this.lexers.push(this.lexer);\r\n            this.tokens.push(this.token);\r\n            this.lexer = new Lexer({\r\n                engine: this.parser.lexerEngine,\r\n                knownTypes: this.knownTypes\r\n            });\r\n            this.lexer.setup({ source, uri });\r\n            this.token = this.readToken();\r\n\r\n            return EOperationType.k_Ok;\r\n        } catch (e) {\r\n            console.error(e);\r\n            this.emitFileNotFound(file, node.loc);\r\n        }\r\n\r\n        return EOperationType.k_Error;\r\n    }\r\n}\r\n\r\n\r\nexport async function createSLASTDocument(textDocument: ITextDocument, flags?: number): Promise<ISLASTDocument> {\r\n    const document = new SLASTDocument();\r\n    await document.parse(textDocument, flags);\r\n    return document;\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { IPassInstructionSettings, PassInstruction } from \"@lib/fx/analisys/instructions/PassInstruction\";\r\nimport { EInstructionTypes, ICompileExprInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { EPartFxPassGeometry, IPartFxPassInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nexport interface IPartFxPassInstructionSettings extends IPassInstructionSettings {\r\n    sorting?: boolean;\r\n    prerenderRoutine: ICompileExprInstruction;\r\n    geometry: EPartFxPassGeometry;\r\n    instanceCount?: number;\r\n}\r\n\r\n\r\nexport class PartFxPassInstruction extends PassInstruction implements IPartFxPassInstruction {\r\n    readonly sorting: boolean;\r\n    readonly prerenderRoutine: ICompileExprInstruction;\r\n    readonly geometry: EPartFxPassGeometry;\r\n    readonly instanceCount: number;\r\n\r\n    constructor({ sorting = false, instanceCount = 1, prerenderRoutine, geometry, ...settings }: IPartFxPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PartFxPass, ...settings });\r\n        \r\n        this.sorting = sorting;\r\n        this.prerenderRoutine = prerenderRoutine;\r\n        this.geometry = geometry;\r\n        this.instanceCount = instanceCount;\r\n    }\r\n\r\n    get particleInstance(): ITypeInstruction {\r\n        if (isNull(this.prerenderRoutine)) {\r\n            return null;\r\n        }\r\n\r\n        return this.prerenderRoutine.function.def.params[1].type.subType;\r\n    }\r\n\r\n    isValid(): boolean {\r\n        return !!this.particleInstance && !!this.prerenderRoutine;\r\n    }\r\n}\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { fn, type, instruction } from '@lib/fx/analisys/helpers';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ISystemTypeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    size: number;\r\n    elementType?: ITypeInstruction;\r\n    length?: number;\r\n    fields?: IVariableDeclInstruction[];\r\n    methods?: IFunctionDeclInstruction[];\r\n    writable?: boolean;\r\n    readable?: boolean;\r\n    complex?: boolean;\r\n    sampler?: boolean;\r\n    texture?: boolean;\r\n    uav?: boolean;\r\n}\r\n\r\nexport class SystemTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _size: number;\r\n    protected _elementType: ITypeInstruction;\r\n    protected _length: number;\r\n    protected _fields: IVariableDeclInstruction[];\r\n    protected _methods: IFunctionDeclInstruction[];\r\n    protected _bIsWritable: boolean;\r\n    protected _bIsReadable: boolean;\r\n    protected _bIsComplex: boolean;\r\n    protected _bIsUAV: boolean;\r\n    protected _bIsTexture: boolean;\r\n    protected _bIsSampler: boolean;\r\n    \r\n\r\n    constructor({\r\n        name, \r\n        size = 0,\r\n        elementType = null, \r\n        length = 1, \r\n        fields = [],\r\n        methods = [],\r\n        writable = true, \r\n        readable = true, \r\n        complex = false,\r\n        sampler = false,\r\n        texture = false,\r\n        uav = false,\r\n        ...settings\r\n    }: ISystemTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SystemType, ...settings });\r\n\r\n        this._name = name;\r\n        this._size = size;\r\n        this._elementType = Instruction.$withNoParent(elementType);\r\n        this._length = length;\r\n        this._fields = [];\r\n        this._methods = [];\r\n        this._bIsWritable = writable;\r\n        this._bIsReadable = readable;\r\n        this._bIsComplex = complex;\r\n        this._bIsSampler = sampler;\r\n        this._bIsTexture = texture;\r\n        this._bIsUAV = uav;\r\n\r\n        fields.forEach(field => this.addField(field));\r\n        methods.forEach(method => this.addMethod(method));\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        return this._bIsWritable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        return this._bIsReadable;\r\n    }\r\n\r\n\r\n    set name(sName: string) {\r\n        this._name = sName;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get hash(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get strongHash(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    get size(): number {\r\n        if (this.isArray()) {\r\n            if (this.length === instruction.UNDEFINE_LENGTH) {\r\n                return instruction.UNDEFINE_LENGTH;\r\n            }\r\n            return this.arrayElementType.size * this.length;\r\n        }\r\n        return this._size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n\r\n    get arrayElementType(): ITypeInstruction {\r\n        return this._elementType;\r\n    }\r\n\r\n\r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this._fields;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this._methods;\r\n    }\r\n\r\n\r\n    get fieldNames(): string[] {\r\n        return this._fields.map(field => field.name);\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return this._bIsSampler;\r\n    }\r\n\r\n\r\n    isTexture(): boolean {\r\n        return this._bIsTexture;\r\n    }\r\n\r\n\r\n    isUAV(): boolean {\r\n        return this._bIsUAV;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n\r\n    toDeclString(): string {\r\n        console.warn('@pure_virtual');\r\n        return '';\r\n    }\r\n\r\n\r\n    isBase(): boolean {\r\n        return true;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this.arrayElementType);\r\n    }\r\n\r\n\r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this._bIsComplex;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainSampler(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainPointer(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    isContainComplexType(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        return this.name || type.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return !!this.getField(fieldName);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields.find(field => field.name === fieldName) || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction | undefined | null {\r\n        const list = this._methods.filter(method => method.name === methodName);\r\n        return fn.matchList(list, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        console.error(\"@undefined_behavior\");\r\n        return null;\r\n    }\r\n\r\n\r\n    /** internal api */\r\n    addField(field: IVariableDeclInstruction): void {\r\n        console.assert(this.getField(field.name) === null);\r\n        this._fields.push(Instruction.$withParent(field, this));\r\n    }\r\n\r\n    /** internal api */\r\n    addMethod(method: IFunctionDeclInstruction): void {\r\n        console.assert(isNull(this.getMethod(method.name, method.def.params.map(param => param.type))));\r\n        this._methods.push(Instruction.$withParent(method, this));\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IConditionalExprInstruction, IExprInstruction, ITypedInstruction } from \"@lib/idl/IInstruction\";\r\nimport { type } from '@lib/fx/analisys/helpers';\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IConditionalExprInstructionSettings extends IInstructionSettings {\r\n    cond: IExprInstruction;\r\n    left: ITypedInstruction;\r\n    right: ITypedInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represen boolExpr ? someExpr : someExpr\r\n * EMPTY_OPERATOR Instruction Instruction Instruction \r\n */\r\nexport class ConditionalExprInstruction extends ExprInstruction implements IConditionalExprInstruction {\r\n    protected _cond: IExprInstruction;\r\n    protected _leftValue: ITypedInstruction;\r\n    protected _rightValue: ITypedInstruction;\r\n\r\n    constructor({ cond, left, right, ...settings }: IConditionalExprInstructionSettings) {\r\n        // todo: do not use {left.type} here\r\n        super({ instrType: EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings});\r\n\r\n        console.assert(type.equals(left.type, right.type, true));\r\n        \r\n        this._cond = Instruction.$withParent(cond, this);\r\n        this._leftValue = Instruction.$withParent(left, this);\r\n        this._rightValue = Instruction.$withParent(right, this);\r\n    }\r\n\r\n\r\n    get condition(): IExprInstruction {\r\n        return this._cond;\r\n    }\r\n\r\n    \r\n    get left(): ITypedInstruction {\r\n        return this._leftValue;\r\n    }\r\n\r\n\r\n    get right(): ITypedInstruction {\r\n        return this._rightValue;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '(';\r\n        code += this.condition.toCode();\r\n        code += '?';\r\n        code += this.left.toCode();\r\n        code += ':';\r\n        code += this.right.toCode();\r\n        code += ')';\r\n        return code;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.condition).isConst() &&\r\n            (<IExprInstruction>this.left).isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IPartFxInstruction, ISpawnStmtInstruction } from \"@lib/idl/part/IPartFx\";\r\n\r\nimport { IInstructionSettings } from \"../Instruction\";\r\nimport { StmtInstruction } from \"../StmtInstruction\";\r\n\r\nexport interface ISpawnInstructionSettings extends IInstructionSettings {\r\n    count: number;\r\n    args: IExprInstruction[];\r\n    name: string;\r\n}\r\n\r\n\r\nexport class SpawnInstruction extends StmtInstruction implements ISpawnStmtInstruction {\r\n    readonly count: number;\r\n    readonly args: IExprInstruction[];\r\n    readonly name: string;\r\n    \r\n    private _fx: IPartFxInstruction = null;\r\n    private _init: IFunctionDeclInstruction = null;\r\n\r\n    constructor({ count, name, args, ...settings }: ISpawnInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SpawnStmt, ...settings });\r\n\r\n        this.count = count;\r\n        this.args = args;\r\n        this.name = name;\r\n    }    \r\n\r\n    \r\n    get fx(): IPartFxInstruction {\r\n        return this._fx;\r\n    }\r\n\r\n\r\n    get init(): IFunctionDeclInstruction {\r\n        return this._init;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;\r\n    }\r\n\r\n    // delayed resolve of the spawn instructions\r\n    $resolve(fx: IPartFxInstruction, init: IFunctionDeclInstruction): void {\r\n        this._fx = fx;\r\n        this._init = init;\r\n    }\r\n}\r\n","import { isEqual } from \"./bf/bf\";\r\nimport { IMap } from \"./idl/IMap\";\r\n\r\nexport let typeOf: (x: any) => string = (x: any): string => {\r\n    const s: string = typeof x;\r\n\r\n    if (s === 'object') {\r\n        if (x) {\r\n            if (x instanceof Array) {\r\n                return 'array';\r\n            } else if (x instanceof Object) {\r\n                return s;\r\n            }\r\n\r\n            const sClassName: string = Object.prototype.toString.call(x);\r\n\r\n            if (sClassName === '[object Window]') {\r\n                return 'object';\r\n            }\r\n\r\n            if ((sClassName === '[object Array]' ||\r\n                (typeof x.length) === 'number' &&\r\n                (typeof x.splice) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('splice')\r\n\r\n            )) {\r\n                return 'array';\r\n            }\r\n\r\n            if ((sClassName === '[object Function]' ||\r\n                (typeof x.call) !== 'undefined' &&\r\n                (typeof x.propertyIsEnumerable) !== 'undefined' &&\r\n                !x.propertyIsEnumerable('call'))) {\r\n                return 'function';\r\n            }\r\n        } else {\r\n            return 'null';\r\n        }\r\n    } else if (s === 'function' && (typeof x.call) === 'undefined') {\r\n        return 'object';\r\n    }\r\n\r\n    return s;\r\n};\r\n\r\nexport let isDef = (x: any): boolean => x !== undefined;\r\nexport let isDefAndNotNull = (x: any): boolean => x != null;\r\nexport let isEmpty = (x: any): boolean => x.length === 0;\r\nexport let isNull = (x: any): boolean => x === null;\r\nexport let isBoolean = (x: any): boolean => typeof x === 'boolean';\r\nexport let isString = (x: any): boolean => typeof x === 'string';\r\nexport let isNumber = (x: any): boolean => typeof x === 'number';\r\nexport let isFloat = isNumber;\r\nexport let isInt = (x: any): boolean => isNumber(x) && (~~x === x);\r\nexport let isUint = (x: any): boolean => isInt(x) && x > 0;\r\nexport let isFunction = (x: any): boolean => typeOf(x) === 'function';\r\nexport let isObject = (x: any): boolean => {\r\n    const T: string = typeOf(x);\r\n    return T === 'object' || T === 'array' || T === 'function';\r\n};\r\nexport let isArrayBuffer = (x: any): boolean => x instanceof ArrayBuffer;\r\nexport let isTypedArray = (x: any): boolean => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';\r\nexport let isBlob = (x: any): boolean => x instanceof Blob;\r\nexport let isArray = (x: any): boolean => typeOf(x) === 'array';\r\n// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);\r\nexport let deepEqual = (a: Object, b: Object) => JSON.stringify(a) === JSON.stringify(b);\r\n\r\n\r\nexport type Nullable<T> = {[P in keyof T]: T[P] | null } | null;\r\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\nexport type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\r\nexport type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\r\nexport type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\r\nexport type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\r\n/** For ex: retrieve the properties of the child that the parent does not have. */\r\nexport type Diff<T1, T2> = Pick<T1, Exclude<keyof T1, keyof T2>>;\r\nexport type NonFunctionDiff<T1, T2> = NonFunctionProperties<Diff<T1, T2>>;\r\nexport type PropertiesDiff<T1, T2> = Writeable<NonFunctionDiff<T1, T2>>;\r\nexport type MakeOptional<T> = { [P in keyof T]?: T[P]; };\r\n\r\nexport const assert = console.assert.bind(console);\r\nexport const verbose = console.log.bind(console);\r\n\r\n/** 'ForEach' for maps. */\r\nexport function mwalk<T>(map: IMap<T>, cb: (element: T, key?: string, i?: number) => boolean | void) {\r\n    let i = 0;\r\n    for (const key in map) {\r\n        if (cb(map[key], key, i++) === false) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n","import { EInstructionTypes, ICompileExprInstruction, IExprInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ICompileExprInstructionSettings extends IExprInstructionSettings {\r\n    operand: IFunctionDeclInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\n/**\r\n  * Represetn compile vs_func(...args)\r\n  * compile IdExprInstruction ExprInstruction ... ExprInstruction\r\n  */\r\nexport class CompileExprInstruction extends ExprInstruction implements ICompileExprInstruction {\r\n    protected _operand: IFunctionDeclInstruction;\r\n    protected _args: IExprInstruction[];\r\n\r\n\r\n    constructor({ operand, args = null, ...settings }: ICompileExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_CompileExpr, ...settings });\r\n\r\n        this._operand = Instruction.$withParent(operand, this);\r\n        this._args = (args || []).map(arg => Instruction.$withParent(arg, this));\r\n    }\r\n\r\n    \r\n    get function(): IFunctionDeclInstruction {\r\n        return <IFunctionDeclInstruction>this._operand;\r\n    }\r\n\r\n    \r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IPostfixIndexInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixIndexInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    index: IExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent element[index]\r\n * EMPTY_OPERATOR Instruction ExprInstruction\r\n */\r\nexport class PostfixIndexInstruction extends ExprInstruction implements IPostfixIndexInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly index: IExprInstruction;\r\n\r\n    constructor({ element, index, ...settings }: IPostfixIndexInstructionSettings) {\r\n        super({ \r\n            instrType: EInstructionTypes.k_PostfixIndexExpr, \r\n            type: (element.type as IVariableTypeInstruction).arrayElementType, ...settings });\r\n            \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.index = Instruction.$withParent(index, this);\r\n    }\r\n\r\n    toCode(): string {\r\n        return `${this.element.toCode()}[${this.index.toCode()}]`;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return this.element.isConst() && this.index.isConst();\r\n    }\r\n}\r\n\r\n\r\n","export enum ETextureFilters {\r\n    UNDEF = 0x0000,\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n    NEAREST_MIPMAP_NEAREST = 0x2700,\r\n    LINEAR_MIPMAP_NEAREST = 0x2701,\r\n    NEAREST_MIPMAP_LINEAR = 0x2702,\r\n    LINEAR_MIPMAP_LINEAR = 0x2703\r\n}\r\n\r\nexport enum ETextureWrapModes {\r\n    UNDEF = 0x0000,\r\n    REPEAT = 0x2901,\r\n    CLAMP_TO_EDGE = 0x812F,\r\n    MIRRORED_REPEAT = 0x8370\r\n}\r\n\r\nexport enum ETextureParameters {\r\n    MAG_FILTER = 0x2800,\r\n    MIN_FILTER,\r\n    WRAP_S,\r\n    WRAP_T\r\n}\r\n\r\nexport enum ETextureTypes {\r\n    TEXTURE_2D = 0x0DE1,\r\n    TEXTURE_CUBE_MAP = 0x8513,\r\n}\r\n\r\nexport enum ECubeFace {\r\n    POSITIVE_X = 0,\r\n    NEGATIVE_X = 1,\r\n    POSITIVE_Y = 2,\r\n    NEGATIVE_Y = 3,\r\n    POSITIVE_Z = 4,\r\n    NEGATIVE_Z = 5,\r\n}\r\n\r\nexport enum ETextureCubeFlags {\r\n    POSITIVE_X = 0x00000001,\r\n    NEGATIVE_X = 0x00000002,\r\n    POSITIVE_Y = 0x00000004,\r\n    NEGATIVE_Y = 0x00000008,\r\n    POSITIVE_Z = 0x0000000c,\r\n    NEGATIVE_Z = 0x000000010,\r\n}\r\n\r\nexport enum ETextureUnits {\r\n    TEXTURE0 = 0x84C0\r\n}\r\n\r\n\r\n","import { isNull } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, EScopeType, IExprInstruction, IInitExprInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represents:\r\n *   int a[3] = { 1, 2, 3 };\r\n *              -----------\r\n */\r\n\r\nexport interface IInitExprInstructionSettings extends IExprInstructionSettings {\r\n    type: IVariableTypeInstruction;\r\n    args?: IExprInstruction[];\r\n}\r\n\r\nexport class InitExprInstruction extends ExprInstruction implements IInitExprInstruction {\r\n    private _args: IExprInstruction[];\r\n\r\n    // Returns true if it is user-defined array.\r\n    private _isArray: boolean; // todo: remove\r\n\r\n    constructor({ type, args = [], ...settings }: IInitExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_InitExpr, type, ...settings });\r\n\r\n        this._isArray = false;\r\n        this._args = args.map(arg => Instruction.$withParent(arg, this));\r\n\r\n        // if (!this.optimizeForVariableType(type)) {\r\n        //     context.error(sourceNode, EErrors.InvalidVariableInitializing, { varName: id.name });\r\n        //     return null;\r\n        // }\r\n    }\r\n\r\n\r\n    get args(): IExprInstruction[] {\r\n        return this._args;\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return this._isArray;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = '';\r\n\r\n        if (!isNull(this.type)) {\r\n            code += this.type.toCode();\r\n        }\r\n        code += \"(\";\r\n\r\n        for (let i: number = 0; i < this.args.length; i++) {\r\n            code += this.args[i].toCode();\r\n\r\n            if (i !== this.args.length - 1) {\r\n                code += \",\";\r\n            }\r\n        }\r\n\r\n        code += \")\";\r\n\r\n        return code;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        let bConst: boolean;\r\n        let args: IExprInstruction[] = <IExprInstruction[]>this.args;\r\n\r\n        for (let i: number = 0; i < args.length; i++) {\r\n            if (!args[i].isConst()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param type The type of the variable for which the initializer was created.\r\n     */\r\n    // TODO: move it to Analysis.ts\r\n    optimizeForVariableType(type: IVariableTypeInstruction): boolean {\r\n        // It's a global user defined array or just not unit array;\r\n        // Trying to exclude types like float1.\r\n        if ((type.isNotBaseArray() && type.scope.type <= EScopeType.k_Global) ||\r\n            (type.isArray() && this.args.length > 1)) {\r\n\r\n            if (type.length === instruction.UNDEFINE_LENGTH ||\r\n                (type.isNotBaseArray() && this.args.length !== type.length) ||\r\n                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {\r\n                return false;\r\n            }\r\n\r\n            if (type.isNotBaseArray()) {\r\n                this._isArray = true;\r\n            }\r\n\r\n            let arrayElementType = <IVariableTypeInstruction>type.arrayElementType;\r\n            let isOk = false;\r\n            let testedInstruction: IExprInstruction = null;\r\n\r\n            for (let i = 0; i < this.args.length; i++) {\r\n                testedInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (testedInstruction.instructionType === EInstructionTypes.k_InitExpr) {\r\n                    isOk = (<IInitExprInstruction>testedInstruction).optimizeForVariableType(arrayElementType);\r\n                    if (!isOk) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    if (SystemScope.isSamplerType(arrayElementType)) {\r\n                        if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        isOk = testedInstruction.type.isEqual(arrayElementType);\r\n                        if (!isOk) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n        else {\r\n            let firstInstruction = <IExprInstruction>this.args[0];\r\n\r\n            if (this.args.length === 1 &&\r\n                firstInstruction.instructionType !== EInstructionTypes.k_InitExpr) {\r\n\r\n                if (SystemScope.isSamplerType(type)) {\r\n                    if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (firstInstruction.type.isEqual(type)) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (this.args.length === 1) {\r\n                return false;\r\n            }\r\n\r\n            let args = <IInitExprInstruction[]>this.args;\r\n            let fieldNameList = type.fieldNames;\r\n\r\n            for (let i = 0; i < args.length; i++) {\r\n                let pFieldType: IVariableTypeInstruction = type.getField(fieldNameList[i]).type;\r\n                if (!args[i].optimizeForVariableType(pFieldType)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            this._type = type.baseType;\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    evaluate(): boolean {\r\n        if (!this.isConst()) {\r\n            this._evalResult = null;\r\n            return false;\r\n        }\r\n\r\n        let res: any = null;\r\n\r\n        if (this._isArray) {\r\n            res = new Array(this.args.length);\r\n\r\n            for (let i: number = 0; i < this.args.length; i++) {\r\n                let evalInstruction = (<IExprInstruction>this.args[i]);\r\n\r\n                if (evalInstruction.evaluate()) {\r\n                    res[i] = evalInstruction.getEvalValue();\r\n                }\r\n            }\r\n        }\r\n        else if (this.args.length === 1) {\r\n            let pEvalInstruction = (<IExprInstruction>this.args[0]);\r\n            pEvalInstruction.evaluate();\r\n            res = pEvalInstruction.getEvalValue();\r\n        }\r\n        else {\r\n            let jsTypeCtor: any = SystemScope.getExternalType(this.type);\r\n            let args: any[] = new Array(this.args.length);\r\n\r\n            if (isNull(jsTypeCtor)) {\r\n                return false;\r\n            }\r\n\r\n            try {\r\n                if (SystemScope.isScalarType(this.type)) {\r\n                    let testedInstruction: IExprInstruction = <IExprInstruction>this.args[1];\r\n                    if (this.args.length > 2 || !testedInstruction.evaluate()) {\r\n                        return false;\r\n                    }\r\n\r\n                    res = jsTypeCtor(testedInstruction.getEvalValue());\r\n                }\r\n                else {\r\n                    for (let i: number = 0; i < this.args.length; i++) {\r\n                        let testedInstruction: IExprInstruction = <IExprInstruction>this.args[i];\r\n\r\n                        if (testedInstruction.evaluate()) {\r\n                            args[i] = testedInstruction.getEvalValue();\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    res = new jsTypeCtor;\r\n                    res.set.apply(res, args);\r\n                }\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._evalResult = res;\r\n        return true;\r\n    }\r\n}\r\n","import bf from \"@lib/bf\";\r\nimport { isDef, isNull } from \"@lib/common\";\r\nimport { assert } from \"@lib/common\";\r\nimport { IDiagnosticReport } from \"@lib/idl/IDiagnostics\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ITextDocument } from \"@lib/idl/ITextDocument\";\r\nimport { IASTDocumentFlags as EASTParsingFlags, EOperationType, EParserCode, IASTConfig, IASTDocument, IFile, IParseNode, IParser, IParseTree, IPosition, IRange, IRuleFunction, ISyntaxTable, IToken } from \"@lib/idl/parser/IParser\";\r\nimport { DiagnosticException, Diagnostics } from \"@lib/util/Diagnostics\";\r\n\r\nimport { Lexer } from \"./Lexer\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { END_SYMBOL, ERROR, UNKNOWN_TOKEN } from \"./symbols\";\r\nimport { extendRange } from \"./util\";\r\n\r\nexport enum EParsingErrors {\r\n    SyntaxUnknownError = 2051,\r\n    SyntaxUnexpectedEOF,\r\n    SyntaxRecoverableStateNotFound,\r\n\r\n    GeneralCouldNotReadFile = 2200,\r\n    GeneralParsingLimitIsReached\r\n};\r\n\r\n\r\n\r\nexport class ParsingDiagnostics extends Diagnostics<IMap<any>> {\r\n    constructor() {\r\n        super(\"Parsing diagnostics\", 'P');\r\n    }\r\n\r\n\r\n    protected resolveFilename(code: number, desc: IMap<any>): string {\r\n        return desc.file;\r\n    }\r\n\r\n\r\n    protected resolveRange(code: number, desc: IMap<any>): IRange {\r\n        switch (code) {\r\n            case EParsingErrors.SyntaxUnknownError:\r\n            case EParsingErrors.SyntaxUnexpectedEOF:\r\n                return desc.token.loc;\r\n            case EParsingErrors.GeneralCouldNotReadFile:\r\n                return desc.loc;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    protected resolvePosition(code: number, desc: IMap<any>): IPosition {\r\n        console.assert(code != EParsingErrors.SyntaxUnknownError);\r\n        return { line: desc.line, column: 0, file: null };\r\n    }\r\n\r\n\r\n    protected diagnosticMessages() {\r\n        return {\r\n            [EParsingErrors.SyntaxUnknownError]: \"Syntax error during parsing. Token: '{token.value}'\\n\" +\r\n                \"Line: {token.loc.start.line}. Column: {token.loc.start.column}.\",\r\n            [EParsingErrors.SyntaxUnexpectedEOF]: \"Syntax error. Unexpected EOF.\",\r\n            [EParsingErrors.GeneralCouldNotReadFile]: \"Could not read file '{target}'.\",\r\n            [EParsingErrors.GeneralParsingLimitIsReached]: \"Parsing limit is reached.\",\r\n            [EParsingErrors.SyntaxRecoverableStateNotFound]: \"Recoverable state not found.\"\r\n        };\r\n    }\r\n}\r\n\r\n\r\nfunction cloneToken(token: IToken): IToken {\r\n    return {\r\n        ...token,\r\n        loc: {\r\n            start: { ...token.loc.start },\r\n            end: { ...token.loc.end }\r\n        }\r\n    };\r\n}\r\n\r\n\r\n// class Context {\r\n//     allowErrorRecoverty: boolean = true;\r\n//     developerMode: boolean = false;\r\n\r\n//     lexer: Lexer;\r\n//     diagnostics: ParsingDiagnostics;\r\n//     knownTypes: Set<string>;\r\n//     ruleFunctions: Map<string, IRuleFunction>;\r\n    \r\n//     stack: number[] = [0];\r\n\r\n\r\n//     constructor() {\r\n//         this.diagnostics = new ParsingDiagnostics;\r\n//     }\r\n\r\n//     readToken() {\r\n//         return this.lexer.getNextToken();\r\n//     }\r\n\r\n\r\n//     private error(code: number, token: IToken) {\r\n//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n\r\n//     private critical(code: number, token: IToken = null) {\r\n//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });\r\n//     }\r\n// }\r\n\r\n\r\nexport class ASTDocument implements IASTDocument {\r\n    protected parser: IParser;\r\n    protected knownTypes: Set<string>;\r\n    protected ruleFunctions: Map<string, IRuleFunction>;\r\n\r\n    protected diag: ParsingDiagnostics;\r\n    protected tree: IParseTree;\r\n    protected stack: number[];\r\n    protected lexer: Lexer;\r\n    protected token: IToken;\r\n\r\n    constructor(config: IASTConfig) {\r\n        assert(config.parser, 'parser engine is not defined');\r\n        this.init(config);\r\n    }\r\n\r\n    protected init({ parser, knownTypes = new Set(), ruleFunctions = new Map }: IASTConfig) {\r\n        const lexerEngine = parser.lexerEngine;\r\n\r\n        this.parser = parser;\r\n        this.knownTypes = knownTypes;\r\n        this.ruleFunctions = ruleFunctions;\r\n        this.lexer = new Lexer({\r\n            engine: lexerEngine,\r\n            knownTypes\r\n        });\r\n    }\r\n\r\n\r\n    get uri(): string {\r\n        return this.lexer.uri.toString();\r\n    }\r\n\r\n\r\n    get diagnosticReport(): IDiagnosticReport {\r\n        let lexerReport = this.lexer.getDiagnosticReport();\r\n        let parserReport = this.diag.resolve();\r\n        return Diagnostics.mergeReports([lexerReport, parserReport]);\r\n    }\r\n\r\n    get root(): IParseNode {\r\n        return this.tree.root;\r\n    }\r\n\r\n\r\n    async parse(textDocument: ITextDocument, flags: number = EASTParsingFlags.k_Optimize): Promise<EParserCode> {\r\n        const developerMode = bf.testAll(flags, EASTParsingFlags.k_DeveloperMode);\r\n        const allowErrorRecoverty = true;\r\n        const optimizeTree = bf.testAll(flags, EASTParsingFlags.k_Optimize);\r\n\r\n        this.diag = new ParsingDiagnostics;\r\n        this.tree = new ParseTree(optimizeTree);\r\n        this.stack = [0];\r\n        this.lexer.setup(textDocument);\r\n        this.token = this.readToken();\r\n\r\n        if (this.token.value === END_SYMBOL) {\r\n            return EParserCode.k_Ok;\r\n        }\r\n\r\n        await this.run({ developerMode, allowErrorRecoverty });\r\n\r\n        // clear context\r\n\r\n        // this.stack = null;\r\n        // this.lexer = null;\r\n        // this.token = null;\r\n        // diag\r\n        // tree\r\n\r\n        // end of clear\r\n\r\n        if (this.diag.hasErrors()) {\r\n            console.error('parsing was ended with errors.');\r\n            return EParserCode.k_Error;\r\n        }\r\n\r\n        return EParserCode.k_Ok;\r\n    }\r\n\r\n\r\n    protected readToken(): IToken {\r\n        return this.lexer.getNextToken();\r\n    }\r\n\r\n    \r\n    protected emitError(code: number, token: IToken) {\r\n        this.diag.error(code, { ...this.lexer.getLocation(), token });\r\n    }\r\n\r\n    \r\n    protected emitCritical(code: number, token: IToken = null) {\r\n        this.diag.critical(code, { ...this.lexer.getLocation(), token });\r\n    }\r\n\r\n\r\n    private restoreState(syntaxTable: ISyntaxTable, parseTree: ParseTree, stack: number[], causingErrorToken: IToken, errorToken: IToken) {\r\n        while (true) {\r\n            let recoverableState = -1;\r\n            for (let i = stack.length - 1; i >= 0; --i) {\r\n                const errorOp = syntaxTable[stack[i]][ERROR];\r\n                const isRecoverableState = (isDef(errorOp) &&\r\n                    errorOp.type === EOperationType.k_Shift &&\r\n                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);\r\n                if (isRecoverableState) {\r\n                    recoverableState = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (recoverableState !== -1) {\r\n                const recoveredStateIndex = stack[recoverableState];\r\n                // current op will be: syntaxTable[recoveredStateIndex][ERROR];\r\n\r\n                let stackDiff = stack.length - 1 - recoverableState;\r\n                while (stackDiff != 0) {\r\n                    // extend error token location with the already processed tokens\r\n                    parseTree.$pop(errorToken.loc);\r\n                    stack.pop();\r\n                    stackDiff--;\r\n                }\r\n\r\n                // recoverable state found so continue normal processing as it would be before the error\r\n                return recoveredStateIndex;\r\n            }\r\n\r\n            extendRange(errorToken.loc, causingErrorToken.loc);\r\n\r\n            if (causingErrorToken.value === END_SYMBOL) {\r\n                // state cant be recovered\r\n                break;\r\n            }\r\n\r\n            // try to restore from the next token\r\n            // FIXME: \r\n            const nextToken = this.readToken();\r\n            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    \r\n    private async operationAdditionalAction(stateIndex: number, grammarSymbol: string): Promise<EOperationType> {\r\n        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);\r\n        if (!isNull(funcName)) {\r\n            assert(!!this.ruleFunctions.has(funcName));\r\n            return await this.ruleFunctions.get(funcName)();\r\n        }\r\n        return EOperationType.k_Ok;\r\n    }\r\n\r\n\r\n    private async run({ developerMode = false, allowErrorRecoverty = true }): Promise<void> {\r\n\r\n        const { syntaxTable } = this.parser;\r\n        const { stack, tree } = this;\r\n\r\n        const undefinedToken: IToken = { index: -1, name: null, value: null };\r\n        let causingErrorToken: IToken = undefinedToken;\r\n\r\n        // debug mode\r\n        const opLimit = 10000;\r\n        let opCounter = 0;\r\n\r\n        try {\r\n            breakProcessing:\r\n            while (true) {\r\n                // global recursion prevention in debug mode\r\n                if (developerMode) {\r\n                    if (opCounter > opLimit) {\r\n                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);\r\n                    }\r\n                    opCounter++;\r\n                }\r\n\r\n                let currStateIndex = stack[stack.length - 1];\r\n                let op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                if (allowErrorRecoverty) {\r\n                    if (!op) {\r\n                        // recursion prevention\r\n                        if (causingErrorToken.index !== this.token.index) {\r\n                            if (this.token.value === END_SYMBOL) {\r\n                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);\r\n                            } else {\r\n                                this.emitError(EParsingErrors.SyntaxUnknownError, this.token);\r\n                            }\r\n                        } else {\r\n                            // one more attempt to recover but from the next token\r\n                            this.token = this.readToken();\r\n                            // NOTE: in order to prevent recusrion on END_SYMBOL\r\n                            causingErrorToken = undefinedToken;\r\n                            continue;\r\n                        }\r\n\r\n                        causingErrorToken = cloneToken(this.token);\r\n                        // token = { ...token, name: ERROR };\r\n                        this.token = { ...cloneToken(this.token), name: ERROR };\r\n                    }\r\n\r\n                    op = syntaxTable[currStateIndex][this.token.name];\r\n\r\n                    const errorProcessing = this.token.name === ERROR;\r\n                    const errorReductionEnded = !op || (errorProcessing && (op.type === EOperationType.k_Shift));\r\n\r\n                    // state must be recovered if operation is undefined or error reduction was ended. \r\n                    if (errorReductionEnded) {\r\n                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. \r\n                        let recoveryToken = cloneToken(causingErrorToken);\r\n                        while (recoveryToken.name === UNKNOWN_TOKEN) {\r\n                            recoveryToken = this.readToken();\r\n                        }\r\n                        currStateIndex = this.restoreState(syntaxTable, <ParseTree>tree, stack, recoveryToken, this.token /* error token */);\r\n                        if (currStateIndex === -1) {\r\n                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);\r\n                        }\r\n\r\n                        // perform error shift op.\r\n                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'\r\n                        stack.push(op.stateIndex);\r\n                        tree.addToken(this.token/* error token */);\r\n                        this.token = recoveryToken;\r\n\r\n                        // const nextOp = syntaxTable[op.stateIndex][token.name];\r\n                        // if (nextOp.type === EOperationType.k_Reduce) {\r\n                        //     tokenBuffer.push(rec);\r\n                        // }\r\n\r\n                        // return to normal precesing loop\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isDef(op)) {\r\n                    switch (op.type) {\r\n                        case EOperationType.k_Success:\r\n                            break breakProcessing;\r\n\r\n                        case EOperationType.k_Shift:\r\n                            {\r\n                                const stateIndex = op.stateIndex;\r\n                                stack.push(stateIndex);\r\n                                tree.addToken(this.token);\r\n\r\n                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, this.token.name);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                } else if (additionalOperationCode === EOperationType.k_Ok) {\r\n                                    this.token = this.readToken();\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case EOperationType.k_Reduce:\r\n                            {\r\n                                const ruleLength = op.rule.right.length;\r\n                                stack.length -= ruleLength;\r\n\r\n                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;\r\n\r\n                                stack.push(stateIndex);\r\n                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));\r\n\r\n                                const additionalOperationCode = await this.operationAdditionalAction(stateIndex, op.rule.left);\r\n                                if (additionalOperationCode === EOperationType.k_Error) {\r\n                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                                }\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    assert(!allowErrorRecoverty, `unexpected end, something went wrong :/`);\r\n                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);\r\n                }\r\n            }\r\n\r\n            tree.finishTree();\r\n        } catch (e) {\r\n            if (!(e instanceof DiagnosticException)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { assert, isDefAndNotNull, isNull, isNumber } from \"@lib/common\";\r\nimport { instruction, type } from \"@lib/fx/analisys/helpers\";\r\nimport { EInstructionTypes, IExprInstruction, IFunctionDeclInstruction, IScope, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction, IVariableUsage } from '@lib/idl/IInstruction';\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IVariableTypeInstructionSettings extends IInstructionSettings {\r\n    type: ITypeInstruction;\r\n    usages?: IVariableUsage[];\r\n    arrayIndex?: IExprInstruction;\r\n    padding?: number;\r\n\r\n    readable?: boolean;\r\n    writable?: boolean;\r\n}\r\n\r\n\r\nexport class VariableTypeInstruction extends Instruction implements IVariableTypeInstruction {\r\n    protected _subType: ITypeInstruction;\r\n    protected _usageList: IVariableUsage[];\r\n\r\n    /** overrites for defautl read/write tests (for internal usage) */\r\n    protected _isWritable: boolean;\r\n    protected _isReadable: boolean;\r\n\r\n    protected _arrayIndexExpr: IExprInstruction;\r\n    protected _arrayElementType: IVariableTypeInstruction;\r\n    protected _padding: number;\r\n\r\n    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = instruction.UNDEFINE_PADDING, ...settings }: IVariableTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_VariableType, ...settings });\r\n\r\n        type = type.$withNoParent();\r\n        this._usageList = [];\r\n\r\n        let instrType = type.instructionType;\r\n        if (instrType === EInstructionTypes.k_ProxyType ||\r\n            instrType === EInstructionTypes.k_SystemType ||\r\n            instrType === EInstructionTypes.k_ComplexType) {\r\n            this._subType = type;\r\n        }\r\n        else {\r\n            let varType = <IVariableTypeInstruction>type;\r\n            // TODO: review this code\r\n            if (!varType.isNotBaseArray()) {\r\n                this._subType = varType.subType;\r\n                varType.usages.forEach(usage => this.addUsage(usage))\r\n            }\r\n            else {\r\n                this._subType = type;\r\n            }\r\n        }\r\n\r\n        assert(isDefAndNotNull(this._subType));\r\n        assert(isDefAndNotNull(this._usageList));\r\n\r\n        this._isWritable = writable;\r\n        this._isReadable = readable;\r\n\r\n        this._arrayIndexExpr = null;\r\n        this._arrayElementType = null;\r\n        this._padding = padding;\r\n\r\n        if (arrayIndex) {\r\n            //TODO: add support for v[][10]\r\n            this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType, usages: this._usageList }), this);\r\n            this._arrayIndexExpr = Instruction.$withParent(arrayIndex, this);\r\n        }\r\n\r\n        usages.forEach(usage => this.addUsage(usage));\r\n\r\n        // todo: construct arrayElementType here! with proper usages!\r\n        // if (this.isArray()) {\r\n        //     if (isNull(this._arrayElementType)) {\r\n        //         this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ scope: this.scope, type: this.subType.arrayElementType, usages: this.usageList }), this);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.baseType.name;\r\n    }\r\n\r\n\r\n    get writable(): boolean {\r\n        if (!this._isWritable) {\r\n            return false;\r\n        }\r\n\r\n        if ((this.isArray() && !this.isBase()) || this.isUniform()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isConst()) {\r\n            return false;\r\n        }\r\n\r\n        // check for hasUsage('in') ?\r\n\r\n        return this.subType.writable;\r\n    }\r\n\r\n\r\n    get readable(): boolean {\r\n        if (!this._isReadable) {\r\n            return false;\r\n        }\r\n\r\n        if (this.hasUsage(\"out\")) {\r\n            return false;\r\n        }\r\n\r\n        return this.subType.readable;\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return this.subType.methods;\r\n    }\r\n\r\n\r\n    // TODO: move to helpers\r\n    get size(): number {\r\n        if (!isNull(this._arrayElementType)) {\r\n            const size = this._arrayElementType.size;\r\n            const length = this.length;\r\n            if (length === instruction.UNDEFINE_LENGTH || size === instruction.UNDEFINE_SIZE) {\r\n                return instruction.UNDEFINE_SIZE;\r\n            }\r\n            return size * length;\r\n        }\r\n        return this.subType.size;\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this.subType.baseType;\r\n    }\r\n\r\n\r\n    get length(): number {\r\n        if (!this.isNotBaseArray()) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        if (this.isNotBaseArray() && isNull(this._arrayElementType)) {\r\n            return this.subType.length;\r\n        }\r\n\r\n        // TODO: rework evaluation api!\r\n\r\n        let isEval = this._arrayIndexExpr.evaluate();\r\n\r\n        if (isEval) {\r\n            let iValue: number = <number>this._arrayIndexExpr.getEvalValue();\r\n            if (isNumber(iValue)) {\r\n                return iValue;\r\n            }\r\n        }\r\n\r\n        return instruction.UNDEFINE_LENGTH;\r\n    }\r\n\r\n\r\n    get padding(): number {\r\n        return this._padding;\r\n    }\r\n\r\n\r\n    get arrayElementType(): IVariableTypeInstruction {\r\n        if (!this.isArray()) {\r\n            return null;\r\n        }\r\n\r\n        // todo: fix this.subType.arrayElementType!\r\n        return this._arrayElementType || <IVariableTypeInstruction>this.subType.arrayElementType;\r\n    }\r\n\r\n\r\n\r\n    get fieldNames(): string[] {\r\n        return this.subType.fieldNames;\r\n    }\r\n\r\n\r\n    get usages(): IVariableUsage[] {\r\n        return this._usageList;\r\n    }\r\n\r\n\r\n    get subType(): ITypeInstruction {\r\n        return this._subType;\r\n    }\r\n\r\n\r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.subType.fields;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        // TODO: fix this condition\r\n        return this.name || this.subType.toString() || type.hash(this);\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        let code: string = \"\";\r\n        if (!isNull(this._usageList)) {\r\n            for (let i: number = 0; i < this._usageList.length; i++) {\r\n                code += this._usageList[i] + \" \";\r\n            }\r\n        }\r\n\r\n        code += this.subType.toCode();\r\n\r\n        return code;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        return this.subType.toDeclString();\r\n    }\r\n\r\n    // todo: add explanation!\r\n    isBase(): boolean {\r\n        return this.subType.isBase() && isNull(this._arrayElementType);\r\n    }\r\n\r\n\r\n    isArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isArray();\r\n    }\r\n\r\n\r\n    // Returns true if the type is user defined array.\r\n    // like an ordinary array: int a[5]\r\n    // not a base array like: float4/int3 etc.\r\n    isNotBaseArray(): boolean {\r\n        return !isNull(this._arrayElementType) || this.subType.isNotBaseArray();\r\n    }\r\n\r\n\r\n    isComplex(): boolean {\r\n        return this.subType.isComplex();\r\n    }\r\n\r\n\r\n\r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this.subType.isContainArray();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this.subType.isContainSampler();\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this.subType.isContainComplexType();\r\n    }\r\n\r\n\r\n    isUniform(): boolean {\r\n        return this.hasUsage(\"uniform\");\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.hasUsage(\"const\");\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isSampler();\r\n    }\r\n\r\n\r\n    isTexture(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isTexture();\r\n    }\r\n\r\n\r\n    isUAV(): boolean {\r\n        return !this.isNotBaseArray() && this.subType.isUAV();\r\n    }\r\n\r\n\r\n    $overwritePadding(val: number) {\r\n        this._padding = val;\r\n    }\r\n\r\n\r\n    private addUsage(usage: IVariableUsage): void {\r\n        if (!this.hasUsage(usage)) {\r\n            this._usageList.push(usage);\r\n        }\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return this.subType.hasField(fieldName);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return this.subType.hasFieldWithSematics(semantic);\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        return this.subType.hasAllUniqueSemantics();\r\n    }\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        return this.subType.hasFieldWithoutSemantics();\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getField(fieldName);\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return this.subType.getMethod(methodName, args);\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        // TODO: propogate usages?\r\n        return this.subType.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    hasUsage(usage: IVariableUsage): boolean {\r\n        if (this._usageList.find(knownUsage => knownUsage === usage)) {\r\n            return true;\r\n        }\r\n\r\n        if (!isNull(this.subType) && this.subType.instructionType === EInstructionTypes.k_VariableType) {\r\n            return (<IVariableTypeInstruction>this.subType).hasUsage(usage);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Helpers\r\n     */\r\n\r\n\r\n    static wrap(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope });\r\n    }\r\n\r\n    static wrapAsConst(type: ITypeInstruction, scope: IScope): IVariableTypeInstruction {\r\n        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });\r\n    }\r\n}\r\n","import { DeclInstruction, IDeclInstructionSettings } from \"@lib/fx/analisys/instructions/DeclInstruction\";\r\nimport { Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { EInstructionTypes, IFunctionDefInstruction, IIdInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { fn, type } from \"@lib/fx/analisys/helpers\";\r\n\r\nexport interface IFunctionDefInstructionSettings extends IDeclInstructionSettings {\r\n    returnType: IVariableTypeInstruction;\r\n    id: IIdInstruction;\r\n    paramList?: IVariableDeclInstruction[];\r\n}\r\n\r\n/**\r\n * Represent type func(...args)[:Semantic]\r\n * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction\r\n */\r\nexport class FunctionDefInstruction extends DeclInstruction implements IFunctionDefInstruction {\r\n    readonly params: IVariableDeclInstruction[];\r\n    readonly returnType: IVariableTypeInstruction;\r\n    \r\n    protected _id: IIdInstruction;\r\n\r\n    constructor({ returnType, id, paramList = [], ...settings }: IFunctionDefInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_FunctionDef, ...settings });\r\n\r\n        this.params = paramList.map(param => Instruction.$withParent(param, this));\r\n        this.returnType = Instruction.$withParent(returnType, this);\r\n        this._id = Instruction.$withParent(id, this);\r\n    }\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n    \r\n\r\n    get name(): string {\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    toString(): string {\r\n        let def = type.signature(this.returnType) + \" \" + this.name + \"(\";\r\n\r\n        for (let i: number = 0; i < this.params.length; i++) {\r\n            def += type.signature(this.params[i].type) + \",\";\r\n        }\r\n\r\n        def += \")\";\r\n        // TODO: add semantic\r\n        return def;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        const { _id: id, returnType, params } = this;\r\n        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;\r\n    }\r\n}\r\n","import { IInstructionSettings, Instruction } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport { StmtInstruction } from \"@lib/fx/analisys/instructions/StmtInstruction\";\r\nimport { EInstructionTypes, IExprInstruction, IExprStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport interface IExprStmtInstructionSettings extends IInstructionSettings {\r\n    expr: IExprInstruction;\r\n}\r\n\r\n/**\r\n * Represent expr;\r\n * EMPTY_OPERTOR ExprInstruction \r\n */\r\nexport class ExprStmtInstruction extends StmtInstruction implements IExprStmtInstruction {\r\n    protected _expr: IExprInstruction;\r\n\r\n    constructor({ expr, ...settings }: IExprStmtInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ExprStmt, ...settings });\r\n\r\n        this._expr = Instruction.$withParent(expr, this);\r\n    }\r\n\r\n    get expr(): IExprInstruction {\r\n        return this._expr;\r\n    }\r\n\r\n    toCode(): string {\r\n        return this._expr.toCode() + ';';\r\n    }\r\n}\r\n","import { isDef, isDefAndNotNull, isNull } from \"@lib/common\";\r\nimport * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EAnalyzerErrors } from '@lib/idl/EAnalyzerErrors';\r\nimport { EInstructionTypes, IFunctionDeclInstruction, ITypeDeclInstruction, ITypeInstruction, IVariableDeclInstruction, IVariableTypeInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\n\r\nimport { instruction, type } from \"../helpers\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IComplexTypeInstructionSettings extends IInstructionSettings {\r\n    name?: string;\r\n    fields: IVariableDeclInstruction[]; // << todo: replace this Array<Instruction>;\r\n}\r\n\r\nexport class ComplexTypeInstruction extends Instruction implements ITypeInstruction {\r\n    protected _name: string;\r\n    protected _fields: IMap<IVariableDeclInstruction>;\r\n\r\n    // helpers\r\n    protected _isContainArray: boolean;\r\n    protected _isContainSampler: boolean;\r\n    protected _isContainComplexType: boolean;\r\n\r\n    constructor({ name = null, fields, ...settings }: IComplexTypeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ComplexType, ...settings });\r\n\r\n        this._name = name;\r\n        this._fields = {};\r\n\r\n        this._isContainArray = false;\r\n        this._isContainSampler = false;\r\n        this._isContainComplexType = false;\r\n\r\n        this.addFields(fields.filter(field => !isNull(field)).map(field => Instruction.$withParent(field, this)));\r\n    }\r\n\r\n    \r\n    get writable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get readable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    get size(): number {\r\n        return this.calcSize();\r\n    }\r\n\r\n\r\n    get baseType(): ITypeInstruction {\r\n        return this;\r\n    }\r\n\r\n    \r\n    get arrayElementType(): ITypeInstruction {\r\n        return null;\r\n    }\r\n\r\n    \r\n    get typeDecl(): ITypeDeclInstruction {\r\n        return <ITypeDeclInstruction>this.parent;\r\n    }\r\n\r\n    \r\n    get length(): number {\r\n        return 0;\r\n    }\r\n\r\n    \r\n    get fieldNames(): string[] {\r\n        return Object.keys(this._fields);\r\n    }\r\n\r\n    \r\n    get fields(): IVariableDeclInstruction[] {\r\n        return this.fieldNames.map( name => this._fields[name] );\r\n    }\r\n\r\n\r\n    get methods(): IFunctionDeclInstruction[] {\r\n        return [];\r\n    }\r\n\r\n\r\n    isSampler(): boolean {\r\n        return false;\r\n    }\r\n\r\n    isTexture(): boolean {\r\n        return false;\r\n    }\r\n\r\n    isUAV(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    toString(): string {\r\n        return this.name || type.hash(this);\r\n    }\r\n\r\n    /** @deprecated */\r\n    toDeclString(): string {\r\n        var code: string = \"struct \" + this._name + \"{\";\r\n\r\n        for (var i: number = 0; i < this.fields.length; i++) {\r\n            code += \"\\t\" + this.fields[i].toCode() + \";\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    isEqual(value: ITypeInstruction): boolean {\r\n        return type.equals(this, value);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return this._name;\r\n    }\r\n\r\n    \r\n    isBase(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isNotBaseArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    isComplex(): boolean {\r\n        return true;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return false;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainArray(): boolean {\r\n        return this._isContainArray;\r\n    }\r\n\r\n    \r\n    /** @deprecated */\r\n    isContainSampler(): boolean {\r\n        return this._isContainSampler;\r\n    }\r\n\r\n    /** @deprecated */\r\n    isContainComplexType(): boolean {\r\n        return this._isContainComplexType;\r\n    }\r\n\r\n\r\n    private addField(variable: IVariableDeclInstruction): void {\r\n        var varName: string = variable.name;\r\n        this._fields[varName] = variable;\r\n\r\n        var type: IVariableTypeInstruction = variable.type;\r\n\r\n        if (type.isNotBaseArray() || type.isContainArray()) {\r\n            this._isContainArray = true;\r\n        }\r\n\r\n        if (SystemScope.isSamplerType(type) || type.isContainSampler()) {\r\n            this._isContainSampler = true;\r\n        }\r\n\r\n        if (type.isComplex()) {\r\n            this._isContainComplexType = true;\r\n        }\r\n    }\r\n\r\n    private addFields(fields: IVariableDeclInstruction[]): void {\r\n        for (var i = 0; i < fields.length; i++) {\r\n            this.addField(fields[i]);\r\n        }\r\n\r\n        this.calculatePaddings();\r\n    }\r\n\r\n\r\n    hasField(fieldName: string): boolean {\r\n        return isDef(this._fields[fieldName]);\r\n    }\r\n\r\n\r\n    hasFieldWithSematics(semantic: string): boolean {\r\n        return !!this.getFieldBySemantics(semantic);\r\n    }\r\n\r\n\r\n    getField(fieldName: string): IVariableDeclInstruction {\r\n        return this._fields[fieldName] || null;\r\n    }\r\n\r\n\r\n    getMethod(methodName: string, args?: ITypeInstruction[]): IFunctionDeclInstruction {\r\n        return null;\r\n    }\r\n\r\n\r\n    getFieldBySemantics(semantic: string): IVariableDeclInstruction {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            if (semantic == field.semantic) {\r\n                return field;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    \r\n    public calcSize(): number {\r\n        let size: number = 0;\r\n\r\n        for (let i: number = 0; i < this.fields.length; i++) {\r\n            let iFieldSize: number = this.fields[i].type.size;\r\n\r\n            if (iFieldSize === instruction.UNDEFINE_SIZE) {\r\n                size = instruction.UNDEFINE_SIZE;\r\n                break;\r\n            }\r\n            else {\r\n                size += iFieldSize;\r\n            }\r\n        }\r\n\r\n        return size;\r\n    }\r\n\r\n\r\n\r\n    hasFieldWithoutSemantics(): boolean {\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            if (semantic == null || semantic == '') {\r\n                return true;\r\n            }\r\n            if (field.type.hasFieldWithoutSemantics()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    hasAllUniqueSemantics(): boolean {\r\n        let fieldBySemantics: IMap<IVariableDeclInstruction> = {};\r\n\r\n        for (let i in this._fields) {\r\n            let field = this._fields[i];\r\n            let semantic = field.semantic;\r\n            \r\n            if (isDefAndNotNull(fieldBySemantics[semantic])) {\r\n                return false;\r\n            }\r\n\r\n            fieldBySemantics[semantic] = field;\r\n\r\n            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private calculatePaddings(): void {\r\n        let padding: number = 0;\r\n\r\n        for (let i: number = 0; i < this.fields.length; i++) {\r\n            let varType: IVariableTypeInstruction = this.fields[i].type;\r\n            let varSize: number = varType.size;\r\n\r\n            if (varSize === instruction.UNDEFINE_SIZE) {\r\n                this._setError(EAnalyzerErrors.CannotCalcPadding, { typeName: this.name });\r\n                return;\r\n            }\r\n\r\n            varType.$overwritePadding(padding);\r\n            padding += varSize;\r\n        }\r\n    }\r\n}\r\n","import { EInstructionTypes, IInstruction, IInstructionCollector } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IInstructionCollectorSettings extends IInstructionSettings {\r\n    instructions?: IInstruction[];\r\n}\r\n\r\nexport class InstructionCollector extends Instruction implements IInstructionCollector {\r\n    protected _instructions: IInstruction[];\r\n\r\n    constructor({ instructions = [], ...settings }: IInstructionCollectorSettings) {\r\n        super({ instrType: EInstructionTypes.k_Collector, ...settings });\r\n\r\n        this._instructions = instructions;\r\n    }\r\n\r\n\r\n    get instructions(): IInstruction[] {\r\n        return this._instructions;\r\n    }\r\n\r\n    push(instr: IInstruction): void {\r\n        this._instructions.push(instr);\r\n    }\r\n\r\n    toCode(): string {\r\n        let code = \"\";\r\n        for (const instr of  this.instructions) {\r\n            switch (instr.instructionType) {\r\n                case EInstructionTypes.k_VariableDecl:\r\n                    code += instr.toCode() + ';\\n';\r\n                break;\r\n                default:\r\n                    code += instr.toCode() + '\\n';\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}","import { EInstructionTypes } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\n/**\r\n * Represent empty statement only semicolon ;\r\n * ;\r\n */\r\nexport class SemicolonStmtInstruction extends StmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_SemicolonStmt, ...settings });\r\n    }\r\n\r\n    toCode(): string {\r\n        return \";\";\r\n    }\r\n}\r\n","import { isNull } from \"@lib/common\";\r\nimport { isNumber } from \"@lib/common\";\r\nimport { ERenderStates } from \"@lib/idl/ERenderStates\";\r\nimport { ERenderStateValues } from \"@lib/idl/ERenderStateValues\";\r\nimport { EInstructionTypes, IAnnotationInstruction, IFunctionDeclInstruction, IIdInstruction, IPassInstruction } from \"@lib/idl/IInstruction\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { ISamplerState } from \"@lib/idl/ISamplerState\";\r\nimport { ETextureFilters, ETextureWrapModes } from \"@lib/idl/ITexture\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface IPassInstructionSettings extends IDeclInstructionSettings {\r\n    vertexShader?: IFunctionDeclInstruction;\r\n    pixelShader?: IFunctionDeclInstruction;\r\n    renderStates?: IMap<ERenderStateValues>;\r\n    id?: IIdInstruction;\r\n}\r\n\r\n\r\nexport class PassInstruction extends DeclInstruction implements IPassInstruction {\r\n    protected _id: IIdInstruction;\r\n    protected _vertexShader: IFunctionDeclInstruction;\r\n    protected _pixelShader: IFunctionDeclInstruction;\r\n    protected _passStateMap: IMap<ERenderStateValues>;\r\n\r\n    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }: IPassInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PassDecl, ...settings });\r\n\r\n        this._passStateMap = {};\r\n        PassInstruction.clearRenderStateMap(this._passStateMap);\r\n        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);\r\n \r\n        this._vertexShader = Instruction.$withNoParent(vertexShader);\r\n        this._pixelShader = Instruction.$withNoParent(pixelShader);\r\n\r\n        this._id = id;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return this._id;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        if (isNull(this._id)) {\r\n            return null;\r\n        }\r\n        return this._id.name;\r\n    }\r\n\r\n\r\n    get vertexShader(): IFunctionDeclInstruction {\r\n        return this._vertexShader;\r\n    }\r\n\r\n    get pixelShader(): IFunctionDeclInstruction {\r\n        return this._pixelShader;\r\n    }\r\n\r\n\r\n    getState(state: ERenderStates): ERenderStateValues {\r\n        return this._passStateMap[state];\r\n    }\r\n\r\n    get renderStates(): IMap<ERenderStateValues> {\r\n        return this._passStateMap;\r\n    }\r\n\r\n    // TODO: move it to helpers\r\n    private static createRenderStateMap(): IMap<ERenderStateValues> {\r\n        let map: IMap<ERenderStateValues> = <IMap<ERenderStateValues>>{};\r\n        PassInstruction.clearRenderStateMap(map);\r\n\r\n        return map;\r\n    }\r\n\r\n    // TODO: move it to helpers\r\n    private static copyRenderStateMap(from: IMap<ERenderStateValues>, to: IMap<ERenderStateValues>): void {\r\n        if (isNull(from)) {\r\n            return;\r\n        }\r\n\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { to[rs] = from[rs] || to[rs] });\r\n    }\r\n\r\n\r\n    // TODO: move it to helpers\r\n    private static clearRenderStateMap(map: IMap<ERenderStateValues>): void {\r\n        Object\r\n            .keys(ERenderStates)\r\n            .filter(k => isNumber(ERenderStates[k]))\r\n            .map(k => ERenderStates[k])\r\n            .forEach(rs => { map[rs] = ERenderStateValues.UNDEF });\r\n    }\r\n\r\n\r\n    /** @deprecated */\r\n    // TODO: move it to helpers\r\n    private static createSamplerState(): ISamplerState {\r\n        return <ISamplerState>{\r\n            textureName: \"\",\r\n            texture: null,\r\n            wrap_s: ETextureWrapModes.UNDEF,\r\n            wrap_t: ETextureWrapModes.UNDEF,\r\n            mag_filter: ETextureFilters.UNDEF,\r\n            min_filter: ETextureFilters.UNDEF\r\n            /*wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,\r\n            wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,\r\n            mag_filter: ETextureFilters.LINEAR,\r\n            min_filter: ETextureFilters.LINEAR*/\r\n        };\r\n    }\r\n}\r\n\r\n","import { EInstructionTypes, IStmtBlockInstruction, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\nimport { StmtInstruction } from \"./StmtInstruction\";\r\n\r\nexport interface IStmtBlockInstructionSettings extends IInstructionSettings {\r\n    stmtList: IStmtInstruction[];\r\n}\r\n\r\n\r\n/**\r\n * Represent {stmts}\r\n * EMPTY_OPERATOR StmtInstruction ... StmtInstruction\r\n */\r\nexport class StmtBlockInstruction extends StmtInstruction implements IStmtBlockInstruction {\r\n    protected _stmtList: IStmtInstruction[];\r\n\r\n    \r\n    constructor({ stmtList, ...settings }: IStmtBlockInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_StmtBlock, ...settings });\r\n        this._stmtList = stmtList.map(stmt => Instruction.$withParent(stmt, this));\r\n    }\r\n\r\n\r\n    get stmtList(): IStmtInstruction[] {\r\n        return this._stmtList;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = \"{\" + \"\\n\";\r\n\r\n        for (var i: number = 0; i < this.stmtList.length; i++) {\r\n            code += \"\\t\" + this.stmtList[i].toCode() + \"\\n\";\r\n        }\r\n\r\n        code += \"}\";\r\n\r\n        return code;\r\n    }\r\n}\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\n/**\r\n * The Position namespace provides helper functions to work with\r\n * [Position](#Position) literals.\r\n */\r\nexport var Position;\r\n(function (Position) {\r\n    /**\r\n     * Creates a new Position literal from the given line and character.\r\n     * @param line The position's line.\r\n     * @param character The position's character.\r\n     */\r\n    function create(line, character) {\r\n        return { line: line, character: character };\r\n    }\r\n    Position.create = create;\r\n    /**\r\n     * Checks whether the given liternal conforms to the [Position](#Position) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\r\n    }\r\n    Position.is = is;\r\n})(Position || (Position = {}));\r\n/**\r\n * The Range namespace provides helper functions to work with\r\n * [Range](#Range) literals.\r\n */\r\nexport var Range;\r\n(function (Range) {\r\n    function create(one, two, three, four) {\r\n        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\r\n            return { start: Position.create(one, two), end: Position.create(three, four) };\r\n        }\r\n        else if (Position.is(one) && Position.is(two)) {\r\n            return { start: one, end: two };\r\n        }\r\n        else {\r\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\r\n        }\r\n    }\r\n    Range.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n    }\r\n    Range.is = is;\r\n})(Range || (Range = {}));\r\n/**\r\n * The Location namespace provides helper functions to work with\r\n * [Location](#Location) literals.\r\n */\r\nexport var Location;\r\n(function (Location) {\r\n    /**\r\n     * Creates a Location literal.\r\n     * @param uri The location's uri.\r\n     * @param range The location's range.\r\n     */\r\n    function create(uri, range) {\r\n        return { uri: uri, range: range };\r\n    }\r\n    Location.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n    }\r\n    Location.is = is;\r\n})(Location || (Location = {}));\r\n/**\r\n * The LocationLink namespace provides helper functions to work with\r\n * [LocationLink](#LocationLink) literals.\r\n */\r\nexport var LocationLink;\r\n(function (LocationLink) {\r\n    /**\r\n     * Creates a LocationLink literal.\r\n     * @param targetUri The definition's uri.\r\n     * @param targetRange The full range of the definition.\r\n     * @param targetSelectionRange The span of the symbol definition at the target.\r\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n     */\r\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\r\n    }\r\n    LocationLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\r\n            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\r\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n    }\r\n    LocationLink.is = is;\r\n})(LocationLink || (LocationLink = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [Color](#Color) literals.\r\n */\r\nexport var Color;\r\n(function (Color) {\r\n    /**\r\n     * Creates a new Color literal.\r\n     */\r\n    function create(red, green, blue, alpha) {\r\n        return {\r\n            red: red,\r\n            green: green,\r\n            blue: blue,\r\n            alpha: alpha,\r\n        };\r\n    }\r\n    Color.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.red)\r\n            && Is.number(candidate.green)\r\n            && Is.number(candidate.blue)\r\n            && Is.number(candidate.alpha);\r\n    }\r\n    Color.is = is;\r\n})(Color || (Color = {}));\r\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * [ColorInformation](#ColorInformation) literals.\r\n */\r\nexport var ColorInformation;\r\n(function (ColorInformation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(range, color) {\r\n        return {\r\n            range: range,\r\n            color: color,\r\n        };\r\n    }\r\n    ColorInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Range.is(candidate.range) && Color.is(candidate.color);\r\n    }\r\n    ColorInformation.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [ColorPresentation](#ColorPresentation) literals.\r\n */\r\nexport var ColorPresentation;\r\n(function (ColorPresentation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(label, textEdit, additionalTextEdits) {\r\n        return {\r\n            label: label,\r\n            textEdit: textEdit,\r\n            additionalTextEdits: additionalTextEdits,\r\n        };\r\n    }\r\n    ColorPresentation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate.label)\r\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n    }\r\n    ColorPresentation.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\n/**\r\n * Enum of known range kinds\r\n */\r\nexport var FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * [FoldingRange](#FoldingRange) literals.\r\n */\r\nexport var FoldingRange;\r\n(function (FoldingRange) {\r\n    /**\r\n     * Creates a new FoldingRange literal.\r\n     */\r\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\r\n        var result = {\r\n            startLine: startLine,\r\n            endLine: endLine\r\n        };\r\n        if (Is.defined(startCharacter)) {\r\n            result.startCharacter = startCharacter;\r\n        }\r\n        if (Is.defined(endCharacter)) {\r\n            result.endCharacter = endCharacter;\r\n        }\r\n        if (Is.defined(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    FoldingRange.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.startLine) && Is.number(candidate.startLine)\r\n            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))\r\n            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))\r\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n    }\r\n    FoldingRange.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\r\n */\r\nexport var DiagnosticRelatedInformation;\r\n(function (DiagnosticRelatedInformation) {\r\n    /**\r\n     * Creates a new DiagnosticRelatedInformation literal.\r\n     */\r\n    function create(location, message) {\r\n        return {\r\n            location: location,\r\n            message: message\r\n        };\r\n    }\r\n    DiagnosticRelatedInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n    }\r\n    DiagnosticRelatedInformation.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\n/**\r\n * The diagnostic's severity.\r\n */\r\nexport var DiagnosticSeverity;\r\n(function (DiagnosticSeverity) {\r\n    /**\r\n     * Reports an error.\r\n     */\r\n    DiagnosticSeverity.Error = 1;\r\n    /**\r\n     * Reports a warning.\r\n     */\r\n    DiagnosticSeverity.Warning = 2;\r\n    /**\r\n     * Reports an information.\r\n     */\r\n    DiagnosticSeverity.Information = 3;\r\n    /**\r\n     * Reports a hint.\r\n     */\r\n    DiagnosticSeverity.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * [Diagnostic](#Diagnostic) literals.\r\n */\r\nexport var Diagnostic;\r\n(function (Diagnostic) {\r\n    /**\r\n     * Creates a new Diagnostic literal.\r\n     */\r\n    function create(range, message, severity, code, source, relatedInformation) {\r\n        var result = { range: range, message: message };\r\n        if (Is.defined(severity)) {\r\n            result.severity = severity;\r\n        }\r\n        if (Is.defined(code)) {\r\n            result.code = code;\r\n        }\r\n        if (Is.defined(source)) {\r\n            result.source = source;\r\n        }\r\n        if (Is.defined(relatedInformation)) {\r\n            result.relatedInformation = relatedInformation;\r\n        }\r\n        return result;\r\n    }\r\n    Diagnostic.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && Range.is(candidate.range)\r\n            && Is.string(candidate.message)\r\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n    }\r\n    Diagnostic.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\n/**\r\n * The Command namespace provides helper functions to work with\r\n * [Command](#Command) literals.\r\n */\r\nexport var Command;\r\n(function (Command) {\r\n    /**\r\n     * Creates a new Command literal.\r\n     */\r\n    function create(title, command) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { title: title, command: command };\r\n        if (Is.defined(args) && args.length > 0) {\r\n            result.arguments = args;\r\n        }\r\n        return result;\r\n    }\r\n    Command.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\r\nexport var TextEdit;\r\n(function (TextEdit) {\r\n    /**\r\n     * Creates a replace text edit.\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     */\r\n    function replace(range, newText) {\r\n        return { range: range, newText: newText };\r\n    }\r\n    TextEdit.replace = replace;\r\n    /**\r\n     * Creates a insert text edit.\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     */\r\n    function insert(position, newText) {\r\n        return { range: { start: position, end: position }, newText: newText };\r\n    }\r\n    TextEdit.insert = insert;\r\n    /**\r\n     * Creates a delete text edit.\r\n     * @param range The range of text to be deleted.\r\n     */\r\n    function del(range) {\r\n        return { range: range, newText: '' };\r\n    }\r\n    TextEdit.del = del;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && Is.string(candidate.newText)\r\n            && Range.is(candidate.range);\r\n    }\r\n    TextEdit.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\r\nexport var TextDocumentEdit;\r\n(function (TextDocumentEdit) {\r\n    /**\r\n     * Creates a new `TextDocumentEdit`\r\n     */\r\n    function create(textDocument, edits) {\r\n        return { textDocument: textDocument, edits: edits };\r\n    }\r\n    TextDocumentEdit.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && VersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n            && Array.isArray(candidate.edits);\r\n    }\r\n    TextDocumentEdit.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nexport var CreateFile;\r\n(function (CreateFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'create',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    CreateFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    CreateFile.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nexport var RenameFile;\r\n(function (RenameFile) {\r\n    function create(oldUri, newUri, options) {\r\n        var result = {\r\n            kind: 'rename',\r\n            oldUri: oldUri,\r\n            newUri: newUri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    RenameFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    RenameFile.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nexport var DeleteFile;\r\n(function (DeleteFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'delete',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    DeleteFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));\r\n    }\r\n    DeleteFile.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nexport var WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&\r\n            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\r\n                if (Is.string(change.kind)) {\r\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                }\r\n                else {\r\n                    return TextDocumentEdit.is(change);\r\n                }\r\n            }));\r\n    }\r\n    WorkspaceEdit.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nvar TextEditChangeImpl = /** @class */ (function () {\r\n    function TextEditChangeImpl(edits) {\r\n        this.edits = edits;\r\n    }\r\n    TextEditChangeImpl.prototype.insert = function (position, newText) {\r\n        this.edits.push(TextEdit.insert(position, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.replace = function (range, newText) {\r\n        this.edits.push(TextEdit.replace(range, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.delete = function (range) {\r\n        this.edits.push(TextEdit.del(range));\r\n    };\r\n    TextEditChangeImpl.prototype.add = function (edit) {\r\n        this.edits.push(edit);\r\n    };\r\n    TextEditChangeImpl.prototype.all = function () {\r\n        return this.edits;\r\n    };\r\n    TextEditChangeImpl.prototype.clear = function () {\r\n        this.edits.splice(0, this.edits.length);\r\n    };\r\n    return TextEditChangeImpl;\r\n}());\r\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\r\nvar WorkspaceChange = /** @class */ (function () {\r\n    function WorkspaceChange(workspaceEdit) {\r\n        var _this = this;\r\n        this._textEditChanges = Object.create(null);\r\n        if (workspaceEdit) {\r\n            this._workspaceEdit = workspaceEdit;\r\n            if (workspaceEdit.documentChanges) {\r\n                workspaceEdit.documentChanges.forEach(function (change) {\r\n                    if (TextDocumentEdit.is(change)) {\r\n                        var textEditChange = new TextEditChangeImpl(change.edits);\r\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                    }\r\n                });\r\n            }\r\n            else if (workspaceEdit.changes) {\r\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\r\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                    _this._textEditChanges[key] = textEditChange;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\r\n        /**\r\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\r\n         * use to be returned from a workspace edit operation like rename.\r\n         */\r\n        get: function () {\r\n            return this._workspaceEdit;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\r\n        if (VersionedTextDocumentIdentifier.is(key)) {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    documentChanges: []\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.documentChanges) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var textDocument = key;\r\n            var result = this._textEditChanges[textDocument.uri];\r\n            if (!result) {\r\n                var edits = [];\r\n                var textDocumentEdit = {\r\n                    textDocument: textDocument,\r\n                    edits: edits\r\n                };\r\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[textDocument.uri] = result;\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    changes: Object.create(null)\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.changes) {\r\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n            }\r\n            var result = this._textEditChanges[key];\r\n            if (!result) {\r\n                var edits = [];\r\n                this._workspaceEdit.changes[key] = edits;\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[key] = result;\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    WorkspaceChange.prototype.createFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\r\n    };\r\n    WorkspaceChange.prototype.deleteFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.checkDocumentChanges = function () {\r\n        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n    };\r\n    return WorkspaceChange;\r\n}());\r\nexport { WorkspaceChange };\r\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\r\n */\r\nexport var TextDocumentIdentifier;\r\n(function (TextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new TextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     */\r\n    function create(uri) {\r\n        return { uri: uri };\r\n    }\r\n    TextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri);\r\n    }\r\n    TextDocumentIdentifier.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\r\n */\r\nexport var VersionedTextDocumentIdentifier;\r\n(function (VersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new VersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param uri The document's text.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri: uri, version: version };\r\n    }\r\n    VersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\r\n    }\r\n    VersionedTextDocumentIdentifier.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * [TextDocumentItem](#TextDocumentItem) literals.\r\n */\r\nexport var TextDocumentItem;\r\n(function (TextDocumentItem) {\r\n    /**\r\n     * Creates a new TextDocumentItem literal.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language identifier.\r\n     * @param version The document's version number.\r\n     * @param text The document's text.\r\n     */\r\n    function create(uri, languageId, version, text) {\r\n        return { uri: uri, languageId: languageId, version: version, text: text };\r\n    }\r\n    TextDocumentItem.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\r\n    }\r\n    TextDocumentItem.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\r\nexport var MarkupKind;\r\n(function (MarkupKind) {\r\n    /**\r\n     * Plain text is supported as a content format\r\n     */\r\n    MarkupKind.PlainText = 'plaintext';\r\n    /**\r\n     * Markdown is supported as a content format\r\n     */\r\n    MarkupKind.Markdown = 'markdown';\r\n})(MarkupKind || (MarkupKind = {}));\r\n(function (MarkupKind) {\r\n    /**\r\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n    }\r\n    MarkupKind.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nexport var MarkupContent;\r\n(function (MarkupContent) {\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n    }\r\n    MarkupContent.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\n/**\r\n * The kind of a completion entry.\r\n */\r\nexport var CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind.Text = 1;\r\n    CompletionItemKind.Method = 2;\r\n    CompletionItemKind.Function = 3;\r\n    CompletionItemKind.Constructor = 4;\r\n    CompletionItemKind.Field = 5;\r\n    CompletionItemKind.Variable = 6;\r\n    CompletionItemKind.Class = 7;\r\n    CompletionItemKind.Interface = 8;\r\n    CompletionItemKind.Module = 9;\r\n    CompletionItemKind.Property = 10;\r\n    CompletionItemKind.Unit = 11;\r\n    CompletionItemKind.Value = 12;\r\n    CompletionItemKind.Enum = 13;\r\n    CompletionItemKind.Keyword = 14;\r\n    CompletionItemKind.Snippet = 15;\r\n    CompletionItemKind.Color = 16;\r\n    CompletionItemKind.File = 17;\r\n    CompletionItemKind.Reference = 18;\r\n    CompletionItemKind.Folder = 19;\r\n    CompletionItemKind.EnumMember = 20;\r\n    CompletionItemKind.Constant = 21;\r\n    CompletionItemKind.Struct = 22;\r\n    CompletionItemKind.Event = 23;\r\n    CompletionItemKind.Operator = 24;\r\n    CompletionItemKind.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\r\nexport var InsertTextFormat;\r\n(function (InsertTextFormat) {\r\n    /**\r\n     * The primary text to be inserted is treated as a plain string.\r\n     */\r\n    InsertTextFormat.PlainText = 1;\r\n    /**\r\n     * The primary text to be inserted is treated as a snippet.\r\n     *\r\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n     * the end of the snippet. Placeholders with equal identifiers are linked,\r\n     * that is typing in one will update others too.\r\n     *\r\n     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\r\n     */\r\n    InsertTextFormat.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\r\nexport var CompletionItem;\r\n(function (CompletionItem) {\r\n    /**\r\n     * Create a completion item and seed it with a label.\r\n     * @param label The completion item's label\r\n     */\r\n    function create(label) {\r\n        return { label: label };\r\n    }\r\n    CompletionItem.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\r\nexport var CompletionList;\r\n(function (CompletionList) {\r\n    /**\r\n     * Creates a new completion list.\r\n     *\r\n     * @param items The completion items.\r\n     * @param isIncomplete The list is not complete.\r\n     */\r\n    function create(items, isIncomplete) {\r\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n    }\r\n    CompletionList.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nexport var MarkedString;\r\n(function (MarkedString) {\r\n    /**\r\n     * Creates a marked string from plain text.\r\n     *\r\n     * @param plainText The plain text.\r\n     */\r\n    function fromPlainText(plainText) {\r\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    }\r\n    MarkedString.fromPlainText = fromPlainText;\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n    }\r\n    MarkedString.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nexport var Hover;\r\n(function (Hover) {\r\n    /**\r\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n            MarkedString.is(candidate.contents) ||\r\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\r\n    }\r\n    Hover.is = is;\r\n})(Hover || (Hover = {}));\r\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * [ParameterInformation](#ParameterInformation) literals.\r\n */\r\nexport var ParameterInformation;\r\n(function (ParameterInformation) {\r\n    /**\r\n     * Creates a new parameter information literal.\r\n     *\r\n     * @param label A label string.\r\n     * @param documentation A doc string.\r\n     */\r\n    function create(label, documentation) {\r\n        return documentation ? { label: label, documentation: documentation } : { label: label };\r\n    }\r\n    ParameterInformation.create = create;\r\n    ;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * [SignatureInformation](#SignatureInformation) literals.\r\n */\r\nexport var SignatureInformation;\r\n(function (SignatureInformation) {\r\n    function create(label, documentation) {\r\n        var parameters = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            parameters[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { label: label };\r\n        if (Is.defined(documentation)) {\r\n            result.documentation = documentation;\r\n        }\r\n        if (Is.defined(parameters)) {\r\n            result.parameters = parameters;\r\n        }\r\n        else {\r\n            result.parameters = [];\r\n        }\r\n        return result;\r\n    }\r\n    SignatureInformation.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nexport var DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind.Text = 1;\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind.Read = 2;\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * [DocumentHighlight](#DocumentHighlight) literals.\r\n */\r\nexport var DocumentHighlight;\r\n(function (DocumentHighlight) {\r\n    /**\r\n     * Create a DocumentHighlight object.\r\n     * @param range The range the highlight applies to.\r\n     */\r\n    function create(range, kind) {\r\n        var result = { range: range };\r\n        if (Is.number(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentHighlight.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nexport var SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind.File = 1;\r\n    SymbolKind.Module = 2;\r\n    SymbolKind.Namespace = 3;\r\n    SymbolKind.Package = 4;\r\n    SymbolKind.Class = 5;\r\n    SymbolKind.Method = 6;\r\n    SymbolKind.Property = 7;\r\n    SymbolKind.Field = 8;\r\n    SymbolKind.Constructor = 9;\r\n    SymbolKind.Enum = 10;\r\n    SymbolKind.Interface = 11;\r\n    SymbolKind.Function = 12;\r\n    SymbolKind.Variable = 13;\r\n    SymbolKind.Constant = 14;\r\n    SymbolKind.String = 15;\r\n    SymbolKind.Number = 16;\r\n    SymbolKind.Boolean = 17;\r\n    SymbolKind.Array = 18;\r\n    SymbolKind.Object = 19;\r\n    SymbolKind.Key = 20;\r\n    SymbolKind.Null = 21;\r\n    SymbolKind.EnumMember = 22;\r\n    SymbolKind.Struct = 23;\r\n    SymbolKind.Event = 24;\r\n    SymbolKind.Operator = 25;\r\n    SymbolKind.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\nexport var SymbolInformation;\r\n(function (SymbolInformation) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the location of the symbol.\r\n     * @param uri The resource of the location of symbol, defaults to the current document.\r\n     * @param containerName The name of the symbol containing the symbol.\r\n     */\r\n    function create(name, kind, range, uri, containerName) {\r\n        var result = {\r\n            name: name,\r\n            kind: kind,\r\n            location: { uri: uri, range: range }\r\n        };\r\n        if (containerName) {\r\n            result.containerName = containerName;\r\n        }\r\n        return result;\r\n    }\r\n    SymbolInformation.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\n/**\r\n * Represents programming constructs like variables, classes, interfaces etc.\r\n * that appear in a document. Document symbols can be hierarchical and they\r\n * have two ranges: one that encloses its definition and one that points to\r\n * its most interesting range, e.g. the range of an identifier.\r\n */\r\nvar DocumentSymbol = /** @class */ (function () {\r\n    function DocumentSymbol() {\r\n    }\r\n    return DocumentSymbol;\r\n}());\r\nexport { DocumentSymbol };\r\n(function (DocumentSymbol) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param detail The detail of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the symbol.\r\n     * @param selectionRange The selectionRange of the symbol.\r\n     * @param children Children of the symbol.\r\n     */\r\n    function create(name, detail, kind, range, selectionRange, children) {\r\n        var result = {\r\n            name: name,\r\n            detail: detail,\r\n            kind: kind,\r\n            range: range,\r\n            selectionRange: selectionRange\r\n        };\r\n        if (children !== void 0) {\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentSymbol.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n            (candidate.detail === void 0 || Is.string(candidate.detail)) &&\r\n            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&\r\n            (candidate.children === void 0 || Array.isArray(candidate.children));\r\n    }\r\n    DocumentSymbol.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\n/**\r\n * A set of predefined code action kinds\r\n */\r\nexport var CodeActionKind;\r\n(function (CodeActionKind) {\r\n    /**\r\n     * Base kind for quickfix actions: 'quickfix'\r\n     */\r\n    CodeActionKind.QuickFix = 'quickfix';\r\n    /**\r\n     * Base kind for refactoring actions: 'refactor'\r\n     */\r\n    CodeActionKind.Refactor = 'refactor';\r\n    /**\r\n     * Base kind for refactoring extraction actions: 'refactor.extract'\r\n     *\r\n     * Example extract actions:\r\n     *\r\n     * - Extract method\r\n     * - Extract function\r\n     * - Extract variable\r\n     * - Extract interface from class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorExtract = 'refactor.extract';\r\n    /**\r\n     * Base kind for refactoring inline actions: 'refactor.inline'\r\n     *\r\n     * Example inline actions:\r\n     *\r\n     * - Inline function\r\n     * - Inline variable\r\n     * - Inline constant\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorInline = 'refactor.inline';\r\n    /**\r\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n     *\r\n     * Example rewrite actions:\r\n     *\r\n     * - Convert JavaScript function to class\r\n     * - Add or remove parameter\r\n     * - Encapsulate field\r\n     * - Make method static\r\n     * - Move method to base class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n    /**\r\n     * Base kind for source actions: `source`\r\n     *\r\n     * Source code actions apply to the entire file.\r\n     */\r\n    CodeActionKind.Source = 'source';\r\n    /**\r\n     * Base kind for an organize imports source action: `source.organizeImports`\r\n     */\r\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n})(CodeActionKind || (CodeActionKind = {}));\r\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * [CodeActionContext](#CodeActionContext) literals.\r\n */\r\nexport var CodeActionContext;\r\n(function (CodeActionContext) {\r\n    /**\r\n     * Creates a new CodeActionContext literal.\r\n     */\r\n    function create(diagnostics, only) {\r\n        var result = { diagnostics: diagnostics };\r\n        if (only !== void 0 && only !== null) {\r\n            result.only = only;\r\n        }\r\n        return result;\r\n    }\r\n    CodeActionContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\r\n    }\r\n    CodeActionContext.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nexport var CodeAction;\r\n(function (CodeAction) {\r\n    function create(title, commandOrEdit, kind) {\r\n        var result = { title: title };\r\n        if (Command.is(commandOrEdit)) {\r\n            result.command = commandOrEdit;\r\n        }\r\n        else {\r\n            result.edit = commandOrEdit;\r\n        }\r\n        if (kind !== void null) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeAction.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && Is.string(candidate.title) &&\r\n            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n            (candidate.kind === void 0 || Is.string(candidate.kind)) &&\r\n            (candidate.edit !== void 0 || candidate.command !== void 0) &&\r\n            (candidate.command === void 0 || Command.is(candidate.command)) &&\r\n            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\r\n    }\r\n    CodeAction.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * [CodeLens](#CodeLens) literals.\r\n */\r\nexport var CodeLens;\r\n(function (CodeLens) {\r\n    /**\r\n     * Creates a new CodeLens literal.\r\n     */\r\n    function create(range, data) {\r\n        var result = { range: range };\r\n        if (Is.defined(data))\r\n            result.data = data;\r\n        return result;\r\n    }\r\n    CodeLens.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n    }\r\n    CodeLens.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * [FormattingOptions](#FormattingOptions) literals.\r\n */\r\nexport var FormattingOptions;\r\n(function (FormattingOptions) {\r\n    /**\r\n     * Creates a new FormattingOptions literal.\r\n     */\r\n    function create(tabSize, insertSpaces) {\r\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\r\n    }\r\n    FormattingOptions.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n    }\r\n    FormattingOptions.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\n/**\r\n * A document link is a range in a text document that links to an internal or external resource, like another\r\n * text document or a web site.\r\n */\r\nvar DocumentLink = /** @class */ (function () {\r\n    function DocumentLink() {\r\n    }\r\n    return DocumentLink;\r\n}());\r\nexport { DocumentLink };\r\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * [DocumentLink](#DocumentLink) literals.\r\n */\r\n(function (DocumentLink) {\r\n    /**\r\n     * Creates a new DocumentLink literal.\r\n     */\r\n    function create(range, target, data) {\r\n        return { range: range, target: target, data: data };\r\n    }\r\n    DocumentLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n    }\r\n    DocumentLink.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\nexport var EOL = ['\\n', '\\r\\n', '\\r'];\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new ITextDocument literal from the given uri and content.\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)\r\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n    }\r\n    TextDocument.is = is;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits, function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n    function mergeSort(data, compare) {\r\n        if (data.length <= 1) {\r\n            // sorted\r\n            return data;\r\n        }\r\n        var p = (data.length / 2) | 0;\r\n        var left = data.slice(0, p);\r\n        var right = data.slice(p);\r\n        mergeSort(left, compare);\r\n        mergeSort(right, compare);\r\n        var leftIdx = 0;\r\n        var rightIdx = 0;\r\n        var i = 0;\r\n        while (leftIdx < left.length && rightIdx < right.length) {\r\n            var ret = compare(left[leftIdx], right[rightIdx]);\r\n            if (ret <= 0) {\r\n                // smaller_equal -> take left to preserve order\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            else {\r\n                // greater -> take right\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n        }\r\n        while (leftIdx < left.length) {\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        while (rightIdx < right.length) {\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n        return data;\r\n    }\r\n})(TextDocument || (TextDocument = {}));\r\n/**\r\n * Represents reasons why a text document is saved.\r\n */\r\nexport var TextDocumentSaveReason;\r\n(function (TextDocumentSaveReason) {\r\n    /**\r\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\r\n     * or by an API call.\r\n     */\r\n    TextDocumentSaveReason.Manual = 1;\r\n    /**\r\n     * Automatic after a delay.\r\n     */\r\n    TextDocumentSaveReason.AfterDelay = 2;\r\n    /**\r\n     * When the editor lost focus.\r\n     */\r\n    TextDocumentSaveReason.FocusOut = 3;\r\n})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = null;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (event, version) {\r\n        this._content = event.text;\r\n        this._version = version;\r\n        this._lineOffsets = null;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === null) {\r\n            var lineOffsets = [];\r\n            var text = this._content;\r\n            var isLineStart = true;\r\n            for (var i = 0; i < text.length; i++) {\r\n                if (isLineStart) {\r\n                    lineOffsets.push(i);\r\n                    isLineStart = false;\r\n                }\r\n                var ch = text.charAt(i);\r\n                isLineStart = (ch === '\\r' || ch === '\\n');\r\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                    i++;\r\n                }\r\n            }\r\n            if (isLineStart && text.length > 0) {\r\n                lineOffsets.push(text.length);\r\n            }\r\n            this._lineOffsets = lineOffsets;\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return Position.create(0, offset);\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return Position.create(line, offset - lineOffsets[line]);\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FullTextDocument;\r\n}());\r\nvar Is;\r\n(function (Is) {\r\n    var toString = Object.prototype.toString;\r\n    function defined(value) {\r\n        return typeof value !== 'undefined';\r\n    }\r\n    Is.defined = defined;\r\n    function undefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    Is.undefined = undefined;\r\n    function boolean(value) {\r\n        return value === true || value === false;\r\n    }\r\n    Is.boolean = boolean;\r\n    function string(value) {\r\n        return toString.call(value) === '[object String]';\r\n    }\r\n    Is.string = string;\r\n    function number(value) {\r\n        return toString.call(value) === '[object Number]';\r\n    }\r\n    Is.number = number;\r\n    function func(value) {\r\n        return toString.call(value) === '[object Function]';\r\n    }\r\n    Is.func = func;\r\n    function objectLiteral(value) {\r\n        // Strictly speaking class instances pass this check as well. Since the LSP\r\n        // doesn't use classes we ignore this for now. If we do we need to add something\r\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n        return value !== null && typeof value === 'object';\r\n    }\r\n    Is.objectLiteral = objectLiteral;\r\n    function typedArray(value, check) {\r\n        return Array.isArray(value) && value.every(check);\r\n    }\r\n    Is.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n","import { isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, IArithmeticExprInstruction, IExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction, IExprInstructionSettings } from \"./ExprInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport type ArithmeticOperator = \"+\" | \"-\" | \"/\" | \"*\" | \"%\";\r\n\r\nexport interface IArithmeticExprInstructionSettings extends IExprInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ArithmeticOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr + / - * % someExpr\r\n * (+|-|*|/|%) Instruction Instruction\r\n */\r\nexport class ArithmeticExprInstruction extends ExprInstruction implements IArithmeticExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: ArithmeticOperator;\r\n\r\n    constructor({ left, right, operator, ...settings }: IArithmeticExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_ArithmeticExpr, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n    get operator(): ArithmeticOperator {\r\n        return this._operator;\r\n    }\r\n    \r\n\r\n    evaluate(): boolean {\r\n        var pValL: any = this._leftOperand.evaluate() ? this._leftOperand.getEvalValue() : null;\r\n        var pValR: any = this._rightOperand.evaluate() ? this._rightOperand.getEvalValue() : null;\r\n\r\n        if (isNull(pValL) || isNull(pValR)) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            switch (this.operator) {\r\n                case \"+\":\r\n                    this._evalResult = pValL + pValR;\r\n                    break;\r\n                case \"-\":\r\n                    this._evalResult = pValL - pValR;\r\n                    break;\r\n                case \"*\":\r\n                    this._evalResult = pValL * pValR;\r\n                    break;\r\n                case \"/\":\r\n                    this._evalResult = pValL / pValR;\r\n                    break;\r\n                case \"%\":\r\n                    this._evalResult = pValL % pValR;\r\n                    break;\r\n            }\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this._leftOperand.toCode();\r\n        sCode += this.operator;\r\n        sCode += this._rightOperand.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    isConst(): boolean {\r\n        return this.left.isConst() && this.right.isConst();\r\n    }\r\n}\r\n\r\n\r\n","import { EInstructionTypes, IAnnotationInstruction, IDeclInstruction, IIdInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IDeclInstructionSettings extends IInstructionSettings {\r\n    readonly semantic?: string;\r\n    readonly annotation?: IAnnotationInstruction;\r\n}\r\n\r\n\r\nexport class DeclInstruction extends Instruction implements IDeclInstruction {\r\n    protected _semantic: string\r\n    protected _annotation: IAnnotationInstruction;\r\n    \r\n    constructor({ semantic = null, annotation = null, ...settings }: IDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Decl, ...settings });\r\n\r\n        this._semantic = semantic;\r\n        this._annotation = Instruction.$withParent(annotation, this);\r\n    }\r\n\r\n\r\n    get semantic(): string {\r\n        return this._semantic;\r\n    }\r\n\r\n\r\n    get annotation(): IAnnotationInstruction {\r\n        return this._annotation;\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return null;\r\n    }\r\n\r\n\r\n    get id(): IIdInstruction {\r\n        return null;\r\n    }\r\n}\r\n","import { IFunctionDefInstruction, IVariableDeclInstruction, ITypeInstruction, IFunctionDeclInstruction } from \"@lib/idl/IInstruction\";\r\nimport { type } from \"@lib/fx/analisys/helpers\";\r\nimport { isNull } from \"@lib/common\";\r\n\r\nexport namespace fn {\r\n\r\n    function signatureParam(param: IVariableDeclInstruction, strong: boolean): string {\r\n        return `${type.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;\r\n    }\r\n\r\n    export function signature(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, params } = def;\r\n        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n    export function signatureEx(def: IFunctionDefInstruction, strong: boolean = false): string {\r\n        const { name, returnType, params } = def;\r\n        return `${type.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;\r\n    }\r\n\r\n\r\n    export function numArgsRequired(def: IFunctionDefInstruction): number {\r\n        return def.params.filter((param) => !param || !param.initExpr).length;\r\n    }\r\n\r\n\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function match(def: IFunctionDefInstruction, args: Array<ITypeInstruction | RegExp>, strong: boolean = false): boolean {\r\n        if (!strong && isNull(args)) {\r\n            return true;\r\n        }\r\n\r\n        if (args.length > def.params.length || numArgsRequired(def) > args.length) {\r\n            return false;\r\n        }\r\n\r\n        return args.every((arg, i) => \r\n            (!strong && isNull(arg)) ||\r\n            (!strong && isNull(def.params[i].type)) ||\r\n            type.equals(arg, def.params[i].type, strong)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Find function by name and list of types.\r\n     * returns:\r\n     *   'null' if there is no requested function; \r\n     *   'undefined' if there more then one function; \r\n     *    function if all is ok;\r\n     */\r\n    // FIXME: refuse from the regular expressions in favor of a full typecasting graph\r\n    export function matchList(funcList: IFunctionDeclInstruction[],\r\n        args: Array<ITypeInstruction | RegExp>,\r\n        strong: boolean = false): IFunctionDeclInstruction | null | undefined {\r\n\r\n        if (!funcList) {\r\n            return null;\r\n        }\r\n\r\n        const res = funcList.filter(func => fn.match(func.def, args, strong));\r\n        if (res.length > 1) {\r\n            return undefined;\r\n        }\r\n\r\n        if (res.length === 1) {\r\n            return res[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}","import { assert, isDef, isNull } from \"@lib/common\";\r\nimport { EInstructionTypes, ITypeDeclInstruction, ITypeInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { DeclInstruction, IDeclInstructionSettings } from \"./DeclInstruction\";\r\nimport { Instruction } from \"./Instruction\";\r\n\r\nexport interface ITypeDeclInstructionSettings extends IDeclInstructionSettings {\r\n    type: ITypeInstruction;\r\n}\r\n\r\n\r\n// TODO: add description comment.\r\nexport class TypeDeclInstruction extends DeclInstruction implements ITypeDeclInstruction {\r\n    readonly type: ITypeInstruction;\r\n\r\n    constructor({ type, ...settings }: ITypeDeclInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_TypeDecl, ...settings });\r\n        this.type =  Instruction.$withParent(type, this);\r\n        assert(isDef(this.type));\r\n    }\r\n\r\n\r\n    get name(): string {\r\n        return this.type.name;\r\n    }\r\n    \r\n\r\n    toCode(): string {\r\n        return this.type.toDeclString() + \";\";\r\n    }\r\n}\r\n","import { EInstructionTypes, IStmtInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\n/**\r\n * Represent all kind of statements\r\n */\r\nexport class StmtInstruction extends Instruction implements IStmtInstruction {\r\n    \r\n    constructor({ ...settings }: IInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Stmt, ...settings });\r\n    }    \r\n}\r\n","import { EInstructionTypes, IAttributeInstruction, IInstruction, ILiteralInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IAttributeInstructionSettings extends IInstructionSettings {\r\n    name: string;\r\n    args: ILiteralInstruction<boolean | number>[];\r\n}\r\n\r\n/**\r\n * Represent attributes:\r\n *  [numthreads(1, 2, 3)]\r\n *  [loop]\r\n *  [branch]\r\n */\r\nexport class AttributeInstruction extends Instruction implements IAttributeInstruction {\r\n    \r\n    readonly name: string;\r\n    readonly args: ILiteralInstruction<number | boolean>[];\r\n\r\n    constructor({ name, args, ...settings }: IAttributeInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_Attribute, ...settings });\r\n\r\n        this.name = name;\r\n        this.args = args;\r\n    }    \r\n\r\n    toCode(): string {\r\n        return `[${this.name}${ this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})`: `` }]`;\r\n    }\r\n}\r\n","import { isString, isNull, isDef } from \"../common\";\r\nimport * as path from \"../path/path\"\r\nimport { IDataURI } from \"../idl/IDataURI\";\r\n\r\nclass URI {\r\n    private _scheme: string = null;\r\n    private _userinfo: string = null;\r\n    private _host: string = null;\r\n    private _port: number = 0;\r\n    private _path: string = null;\r\n    private _query: string = null;\r\n    private _fragment: string = null;\r\n\r\n    get urn(): string {\r\n        return (this._path ? this._path : \"\") +\r\n            (this._query ? '?' + this._query : \"\") +\r\n            (this._fragment ? '#' + this._fragment : \"\");\r\n    }\r\n\r\n    get url(): string {\r\n        return (this._scheme ? this._scheme : \"\") + this.authority;\r\n    }\r\n\r\n    get authority(): string {\r\n        return (this._host ? '//' + (this._userinfo ? this._userinfo + '@' : \"\") +\r\n            this._host + (this._port ? ':' + this._port : \"\") : \"\");\r\n    }\r\n\r\n    get scheme(): string {\r\n        return this._scheme;\r\n    }\r\n\r\n    get protocol(): string {\r\n        if (!this._scheme) {\r\n            return this._scheme;\r\n        }\r\n\r\n        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));\r\n    }\r\n\r\n    get userInfo(): string {\r\n        return this._userinfo;\r\n    }\r\n\r\n    get host(): string {\r\n        return this._host;\r\n    }\r\n\r\n    set host(sHost: string) {\r\n        //TODO: check host format\r\n        this._host = sHost;\r\n    }\r\n\r\n    get port(): number {\r\n        return this._port;\r\n    }\r\n\r\n    set port(iPort: number) {\r\n        this._port = iPort;\r\n    }\r\n\r\n    get path(): string {\r\n        return this._path;\r\n    }\r\n\r\n    set path(sPath: string) {\r\n        // debug_assert(!isNull(sPath.match(new RegExp(\"^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$\"))), \r\n        //     \"invalid path used: \" + sPath);\r\n        //TODO: check path format\r\n        this._path = sPath;\r\n    }\r\n\r\n    get query(): string {\r\n        //TODO: check query format\r\n        return this._query;\r\n    }\r\n\r\n    set query(sQuery: string) {\r\n        this._query = sQuery;\r\n    }\r\n\r\n    get fragment(): string {\r\n        return this._fragment;\r\n    }\r\n\r\n\r\n    constructor(uri: URI);\r\n    constructor(uri: string);\r\n    constructor(uri?) {\r\n        if (uri) {\r\n            this.set(uri);\r\n        }\r\n    }\r\n\r\n    set(uri: URI);\r\n    set(uri: string);\r\n    set(data?): URI {\r\n        if (isString(data)) {\r\n            var uri: RegExpExecArray = URI.uriExp.exec(<string>data);\r\n\r\n            console.assert(uri !== null, 'Invalid URI format used.\\nused uri: ' + data);\r\n\r\n            if (!uri) {\r\n                return null;\r\n            }\r\n\r\n            this._scheme = uri[1] || null;\r\n            this._userinfo = uri[2] || null;\r\n            this._host = uri[3] || null;\r\n            this._port = parseInt(uri[4]) || null;\r\n            this._path = uri[5] || uri[6] || null;\r\n            this._query = uri[7] || null;\r\n            this._fragment = uri[8] || null;\r\n\r\n            return this;\r\n\r\n        }\r\n        else if (data instanceof URI) {\r\n            return this.set(data.toString());\r\n        }\r\n\r\n        console.error('Unexpected data type was used.');\r\n\r\n        return null;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.url + this.urn;\r\n    }\r\n\r\n    //------------------------------------------------------------------//\r\n    //----- Validate a URI -----//\r\n    //------------------------------------------------------------------//\r\n    //- The different parts are kept in their own groups and can be recombined\r\n    //  depending on the scheme:\r\n    //  - http as $1://$3:$4$5?$7#$8\r\n    //  - ftp as $1://$2@$3:$4$5\r\n    //  - mailto as $1:$6?$7\r\n    //- groups are as follows:\r\n    //  1   == scheme\r\n    //  2   == userinfo\r\n    //  3   == host\r\n    //  4   == port\r\n    //  5,6 == path (5 if it has an authority, 6 if it doesn't)\r\n    //  7   == query\r\n    //  8   == fragment\r\n\r\n\r\n    private static uriExp: RegExp = new RegExp(\"^([a-z0-9+.-]+:)?(?:\\\\/\\\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\\\d*))?(\\\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$\", \"i\");\r\n\r\n    /*\r\n     composed as follows:\r\n     ^\r\n     ([a-z0-9+.-]+):                            #scheme\r\n     (?:\r\n     //                            #it has an authority:\r\n     (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?    #userinfo\r\n     ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)        #host\r\n     (?::(\\d*))?                        #port\r\n     (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     |\r\n     #it doesn't have an authority:\r\n     (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?    #path\r\n     )\r\n     (?:\r\n     \\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #query string\r\n     )?\r\n     (?:\r\n     #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)    #fragment\r\n     )?\r\n     $\r\n     */\r\n}\r\n\r\n\r\nfunction normalizeURIPath(file: URI): URI {\r\n    if (!isNull(file.path)) {\r\n        if (file.scheme === \"filesystem:\") {\r\n            var uri = parse(file.path);\r\n\r\n            uri.path = path.normalize(uri.path);\r\n            file.path = uri.toString();\r\n        }\r\n        else {\r\n            file.path = path.normalize(file.path);\r\n        }\r\n    }\r\n\r\n    return file;\r\n}\r\n\r\n\r\n\r\nexport function resolve(from: string, to: string = document.location.href): string {\r\n    var currentPath = parse(to);\r\n    var file = parse(from);\r\n    var dirname: string;\r\n\r\n    normalizeURIPath(file);\r\n    normalizeURIPath(currentPath);\r\n\r\n    if (!isNull(file.scheme) || !isNull(file.host) || path.parse(file.path).isAbsolute()) {\r\n        //another server or absolute path\r\n        return from;\r\n    }\r\n\r\n    dirname = path.parse(currentPath.path).dirname;\r\n    currentPath.path = dirname ? (dirname + \"/\" + from) : from;\r\n\r\n    return normalizeURIPath(currentPath).toString();\r\n}\r\n\r\n\r\nexport function parseDataURI(uri: string): IDataURI {\r\n    var re: RegExp = /^data:([\\w\\d\\-\\/]+)?(;charset=[\\w\\d\\-]*)?(;base64)?,(.*)$/;\r\n    var m: string[] = uri.match(re);\r\n\r\n    return {\r\n        //like [text/plain]\r\n        mediatype: m[1] || null,\r\n        //like [;charset=windows-1251]\r\n        charset: isString(m[2]) ? m[2].substr(9) : null,\r\n        //like [;base64]\r\n        base64: isDef(m[3]),\r\n        data: m[4] || null\r\n    };\r\n}\r\n\r\n\r\nexport function parse(uri: string): URI {\r\n    return new URI(uri);\r\n}\r\n\r\n\r\nexport function currentScript(): HTMLScriptElement {\r\n    if (isDef(document['currentScript'])) {\r\n        return <HTMLScriptElement>document['currentScript'];\r\n    }\r\n\r\n    var scripts: HTMLCollectionOf<HTMLScriptElement> = document.getElementsByTagName(\"script\");\r\n    return scripts[scripts.length - 1];\r\n}\r\n\r\n\r\nexport function currentPath(): string {\r\n    var uri = parse(currentScript().src);\r\n    let dirname = path.parse(uri.path).dirname;\r\n    return uri.url + dirname + \"/\";\r\n}\r\n\r\n\r\nexport function here(): URI {\r\n    return new URI(document.location.href);\r\n}\r\n","import { EInstructionTypes, IExprInstruction, IIdExprInstruction, IPostfixPointInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface IPostfixPointInstructionSettings extends IInstructionSettings {\r\n    element: IExprInstruction;\r\n    postfix: IIdExprInstruction;\r\n}\r\n\r\n\r\n/**\r\n * Represent someExpr.id\r\n * EMPTY_OPERATOR Instruction IdInstruction\r\n */\r\nexport class PostfixPointInstruction extends ExprInstruction implements IPostfixPointInstruction {\r\n    readonly element: IExprInstruction;\r\n    readonly postfix: IIdExprInstruction;\r\n\r\n\r\n    constructor({ element, postfix, ...settings }: IPostfixPointInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });\r\n        \r\n        this.element = Instruction.$withParent(element, this);\r\n        this.postfix = Instruction.$withParent(postfix, this);\r\n    }\r\n\r\n    \r\n    toCode(): string {\r\n        return `${this.element.toCode()}.${this.postfix.toCode()}`;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return this.element.isConst();\r\n    }\r\n}\r\n\r\n","export { expression } from './expression';\r\nexport { fn } from './fn';\r\nexport { instruction } from './instruction';\r\nexport { type } from './type';\r\nexport { variable } from './variable';\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IMap } from \"@lib/idl/IMap\";\r\nimport { EParserType, IRule } from \"@lib/idl/parser/IParser\";\r\n\r\nimport { Item } from \"./Item\";\r\n\r\nexport class State {\r\n    index: number;\r\n    nextStates: IMap<State>;\r\n\r\n    private items: Item[];\r\n    private numBaseItems: number;\r\n    // for debug only\r\n    private numOtherItems: number;\r\n\r\n    constructor() {\r\n        this.nextStates = {};\r\n        this.index = 0;\r\n\r\n        this.items = [];\r\n        this.numBaseItems = 0;\r\n        this.numOtherItems = 0;\r\n    }\r\n\r\n\r\n    eachItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.items.length; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n\r\n    eachBaseItem(cb: (item: Item, i?: number) => void) {\r\n        // NOTE: do not try to change this for loop\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            cb(this.items[i], i);\r\n        }\r\n    }\r\n\r\n    \r\n    isExpected(symbol: string): boolean {\r\n        return !!this.items.find(item => item.isExpected(symbol));\r\n    }\r\n\r\n\r\n    hasItem(value: Item, type: EParserType): Item {\r\n        return this.items.find(item => item.isEqual(value, type)) || null;\r\n    }\r\n\r\n    \r\n    hasParentItem(value: Item): Item {\r\n        return this.items.find(item => item.isParentItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasChildItem(value: Item): Item {\r\n        return this.items.find(item => item.isChildItem(value)) || null;\r\n    }\r\n\r\n    \r\n    hasRule(rule: IRule, pos: number): boolean {\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const item = this.items[i];\r\n            if (item.rule === rule && item.pos === pos) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    isEmpty(): boolean {\r\n        return !(this.items.length);\r\n    }\r\n\r\n    \r\n    isEqual(state: State, type: EParserType): boolean {\r\n        if (this.numBaseItems !== state.numBaseItems) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < this.numBaseItems; ++i) {\r\n            const baseItemA = this.items[i];\r\n\r\n            let isEqual = false;\r\n            for (let i = 0; i < state.numBaseItems; ++i) {\r\n                const baseItemB = state.items[i];\r\n                if (baseItemA.isEqual(baseItemB, type)) {\r\n                    isEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isEqual) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    push(item: Item): void {\r\n        if (this.items.length === 0 || item.pos > 0) {\r\n            assert(this.numOtherItems === 0);\r\n            this.numBaseItems++;\r\n        } else {\r\n            this.numOtherItems++;\r\n        }\r\n        this.items.push(item);\r\n    }\r\n\r\n\r\n    tryPush_LR0(rule: IRule, pos: number): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return false;\r\n        }\r\n\r\n        const item = new Item(rule, pos);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n\r\n    tryPush_LR(rule: IRule, pos: number, expectedSymbol: string): boolean {\r\n        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));\r\n        if (sameItem) {\r\n            return sameItem.addExpected(expectedSymbol);\r\n        }\r\n\r\n        const item = new Item(rule, pos, [expectedSymbol]);\r\n        this.push(item);\r\n        return true;\r\n    }\r\n\r\n    \r\n    addNextState(symbol: string, state: State): boolean {\r\n        if (this.nextStates[symbol]) {\r\n            return false;\r\n        }\r\n\r\n        this.nextStates[symbol] = state;\r\n        return true;\r\n    }\r\n\r\n    \r\n    deleteNotBase(): void {\r\n        this.items.length = this.numBaseItems;\r\n    }\r\n\r\n    \r\n    toString(isBase: boolean = true, grammarSymbols: Map<string, string> = null): string {\r\n        const items = isBase? this.items.slice(0, this.numBaseItems) : this.items;\r\n        return `State ${this.index}:\\n` +\r\n            items.map(item => `\\t\\t${item.toString(grammarSymbols)}\\n`).join();\r\n    }\r\n}\r\n","import * as SystemScope from \"@lib/fx/analisys/SystemScope\";\r\nimport { EInstructionTypes, IExprInstruction, ILogicalExprInstruction, ILogicalOperator } from \"@lib/idl/IInstruction\";\r\n\r\nimport { ExprInstruction } from \"./ExprInstruction\";\r\nimport { IInstructionSettings, Instruction } from \"./Instruction\";\r\n\r\nexport interface ILogicalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: ILogicalOperator;\r\n}\r\n\r\n\r\n/**\r\n * Represent boolExpr && || boolExpr\r\n * (&& | ||) Instruction Instruction\r\n */\r\nexport class LogicalExprInstruction extends ExprInstruction implements ILogicalExprInstruction {\r\n    protected _operator: ILogicalOperator;\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n\r\n    constructor({ left, right, operator, ...settings }: ILogicalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_LogicalExpr, type: SystemScope.T_BOOL, ...settings });\r\n\r\n        this._leftOperand = Instruction.$withParent(left, this);\r\n        this._rightOperand = Instruction.$withParent(right, this);\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get operator(): ILogicalOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var sCode: string = \"\";\r\n        sCode += this.left.toCode();\r\n        sCode += this.operator;\r\n        sCode += this.right.toCode();\r\n        return sCode;\r\n    }\r\n\r\n    \r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n","import { assert } from \"@lib/common\";\r\nimport { IPosition, IRange } from \"@lib/idl/parser/IParser\";\r\n\r\nexport function positionMin(a: IPosition, b: IPosition): IPosition {\r\n    assert(String(a.file) === String(b.file));\r\n    return {\r\n        offset: Math.min(a.offset, b.offset),\r\n        line: Math.min(a.line, b.line),\r\n        column: Math.min(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\nexport function positionMax(a: IPosition, b: IPosition): IPosition {\r\n    assert(String(a.file) === String(b.file));\r\n    return {\r\n        offset: Math.max(a.offset, b.offset),\r\n        line: Math.max(a.line, b.line),\r\n        column: Math.max(a.column, b.column),\r\n        file: a.file\r\n    };\r\n}\r\n\r\n\r\nexport function cloneRange(range: IRange): IRange {\r\n    return { start: { ...range.start }, end: { ...range.end } };\r\n}\r\n\r\n\r\nexport function extendRange(parent: IRange, child: IRange): IRange {\r\n    if (child.start.file !== parent.start.file) {\r\n        return parent;\r\n    }\r\n    \r\n    if (child.start.line < parent.start.line) {\r\n        parent.start = { ...child.start };\r\n    } else if (child.start.line === parent.start.line) {\r\n        parent.start = positionMin(child.start, parent.start);\r\n    }\r\n\r\n    if (child.end.line > parent.end.line) {\r\n        parent.end = { ...child.end };\r\n    } else if (child.end.line === parent.end.line) {\r\n        parent.end = positionMax(child.end, parent.end);\r\n    }\r\n\r\n    return parent;\r\n}\r\n\r\nexport function commonRange(...rangeList: IRange[]): IRange {\r\n    const MAX_I32 = Number.MAX_SAFE_INTEGER;\r\n    const MIN_I32 = Number.MIN_SAFE_INTEGER;\r\n\r\n    const file = rangeList[0].start.file;\r\n    \r\n    let start: IPosition = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };\r\n    let end: IPosition = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };\r\n\r\n    rangeList.forEach(range => start = positionMin(start, range.start));\r\n    rangeList.forEach(range => end = positionMax(end, range.end));\r\n\r\n    return { start, end };\r\n}\r\n\r\nexport const checkRange = (range: IRange, offset: number) => range.start.offset <= offset && range.end.offset > offset;","import { ExprInstruction } from \"@lib/fx/analisys/instructions/ExprInstruction\";\r\nimport { IInstructionSettings } from \"@lib/fx/analisys/instructions/Instruction\";\r\nimport * as SystemScope from '@lib/fx/analisys/SystemScope';\r\nimport { EInstructionTypes, IExprInstruction, IRelationalExprInstruction } from \"@lib/idl/IInstruction\";\r\n\r\nexport type RelationOperator = \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\";\r\n\r\nexport interface IRelationalExprInstructionSettings extends IInstructionSettings {\r\n    left: IExprInstruction;\r\n    right: IExprInstruction;\r\n    operator: RelationOperator;\r\n}\r\n\r\n/**\r\n * Represent someExpr == != < > <= >= someExpr\r\n * (==|!=|<|>|<=|>=) Instruction Instruction\r\n */\r\nexport class RelationalExprInstruction extends ExprInstruction implements IRelationalExprInstruction {\r\n    protected _leftOperand: IExprInstruction;\r\n    protected _rightOperand: IExprInstruction;\r\n    protected _operator: RelationOperator;\r\n\r\n\r\n    constructor({ left, right, operator, ...settings }: IRelationalExprInstructionSettings) {\r\n        super({ instrType: EInstructionTypes.k_RelationalExpr, type: SystemScope.T_BOOL, ...settings });\r\n        this._leftOperand = left;\r\n        this._rightOperand = right;\r\n        this._operator = operator;\r\n    }\r\n\r\n\r\n    get left(): IExprInstruction {\r\n        return this._leftOperand;\r\n    }\r\n\r\n\r\n    get right(): IExprInstruction {\r\n        return this._rightOperand;\r\n    }\r\n\r\n\r\n    get operator(): RelationOperator {\r\n        return this._operator;\r\n    }\r\n\r\n\r\n    toCode(): string {\r\n        var code: string = '';\r\n        code += this.left.toCode();\r\n        code += this.operator;\r\n        code += this.right.toCode();\r\n        return code;\r\n    }\r\n\r\n\r\n    isConst(): boolean {\r\n        return (<IExprInstruction>this.left).isConst() &&\r\n            (<IExprInstruction>this.right).isConst();\r\n    }\r\n}\r\n\r\n\r\n","export default \"S : Program\\r\\nProgram : --add\\r\\nProgram : Decls\\r\\n\\r\\nDecls : Decl --expose\\r\\nDecls : Decls Decl\\r\\n\\r\\nDecl : ';'\\r\\nDecl : TypeDecl\\r\\nDecl : VariableDecl\\r\\nDecl : VarStructDecl\\r\\nDecl : FunctionDecl\\r\\nDecl : TechniqueDecl\\r\\n#if FX_PART\\r\\n    Decl : PartFxDecl\\r\\n#endif \\r\\nDecl : UseDecl\\r\\nDecl : ImportDecl\\r\\nDecl : ProvideDecl\\r\\nDecl : IncludeDecl\\r\\nDecl : ERROR\\r\\n\\r\\nIncludeDecl : '#' T_KW_INCLUDE String --skip --F includeCode\\r\\n\\r\\nImportDecl : T_KW_IMPORT String ';'\\r\\n\\r\\nProvideDecl : T_KW_PROVIDE ComplexNameOpt ';'\\r\\nProvideDecl : T_KW_PROVIDE ComplexNameOpt T_KW_AS ComplexNameOpt ';'\\r\\n\\r\\nUseDecl : T_KW_USE Mode\\r\\nMode : T_KW_STRICT\\r\\n\\r\\nUsages : Usage --expose\\r\\nUsages : Usages Usage\\r\\nUsage : T_KW_STATIC --add\\r\\nUsage : T_KW_UNIFORM\\r\\nUsage : T_KW_EXTERN\\r\\nUsage : T_KW_VOLATILE\\r\\nUsage : T_KW_INLINE\\r\\nUsage : ConstUsage\\r\\n\\r\\nConstUsages : ConstUsage --expose\\r\\nConstUsages : ConstUsages ConstUsage\\r\\nConstUsage : T_KW_CONST\\r\\nConstUsage : T_KW_ROW_MAJOR\\r\\nConstUsage : T_KW_COLUMN_MAJOR\\r\\n\\r\\nUsageType : Type --add\\r\\nUsageType : Usages Type\\r\\n\\r\\nUsageStructDecl : StructDecl --add\\r\\nUsageStructDecl : Usages StructDecl\\r\\n\\r\\nTypeDecl : T_KW_TYPEDEF ConstType TypeDefs ';' --add\\r\\nTypeDecl : T_KW_TYPEDEF ConstStructDecl TypeDefs ';'\\r\\nTypeDecl : StructDecl --F addType ';'\\r\\nTypeDefs : VariableDim\\r\\nTypeDefs : VariableDim ',' TypeDefs\\r\\n\\r\\n# GenericParams : '<' Arguments '>'\\r\\n# GenericParamsOpt: --expose\\r\\n# GenericParamsOpt: GenericParams\\r\\n\\r\\nType : BaseType --add\\r\\nType : Struct\\r\\nType : TypeId\\r\\nType : T_KW_STRUCT TypeId\\r\\n\\r\\nConstType : Type --add\\r\\nConstType : ConstUsages Type\\r\\nConstTypeDim : ConstType --expose\\r\\nConstTypeDim : ConstTypeDim '[' ConstantExpr ']'\\r\\n\\r\\nBaseType : T_KW_VOID --add\\r\\nBaseType : ScalarType\\r\\nBaseType : VectorType\\r\\nBaseType : MatrixType\\r\\nBaseType : ObjectType\\r\\n\\r\\nScalarType : T_KW_BOOL --add\\r\\nScalarType : T_KW_INT\\r\\nScalarType : T_KW_UINT\\r\\nScalarType : T_KW_HALF\\r\\nScalarType : T_KW_FLOAT\\r\\nScalarType : T_KW_DOUBLE\\r\\n\\r\\nVectorType : T_KW_VECTOR --add\\r\\nVectorType : T_KW_VECTOR '<' ScalarType ',' AddExpr '>'\\r\\n\\r\\nMatrixType : T_KW_MATRIX --add\\r\\nMatrixType : T_KW_MATRIX '<' ScalarType ',' ConstantExpr ',' AddExpr '>'\\r\\n\\r\\nObjectType : T_KW_STRING --add\\r\\nObjectType : T_KW_TEXTURE\\r\\nObjectType : T_KW_TEXTURE1D\\r\\nObjectType : T_KW_TEXTURE2D\\r\\nObjectType : T_KW_TEXTURE3D\\r\\nObjectType : T_KW_TEXTURECUBE\\r\\nObjectType : T_KW_SAMPLER\\r\\nObjectType : T_KW_SAMPLER1D\\r\\nObjectType : T_KW_SAMPLER2D\\r\\nObjectType : T_KW_SAMPLER3D\\r\\nObjectType : T_KW_SAMPLERCUBE\\r\\nObjectType : T_KW_PIXELSHADER\\r\\nObjectType : T_KW_VERTEXSHADER\\r\\nObjectType : T_KW_PIXELFRAGMENT\\r\\nObjectType : T_KW_VERTEXFRAGMENT\\r\\nObjectType : T_KW_STATEBLOCK\\r\\nObjectType : T_KW_RWBUFFER '<' Type '>'\\r\\nObjectType : T_KW_RWSTRUCTUREDBUFFER '<' Type '>'\\r\\nObjectType : T_KW_APPENDSTRUCTUREDBUFFER '<' Type '>'\\r\\n\\r\\n\\r\\n# struct Name\\r\\n# {\\r\\n#     [InterpolationModifier] Type[RxC] MemberName;\\r\\n#     ...\\r\\n# };\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509668(v=vs.85).aspx\\r\\n\\r\\nStruct : T_KW_STRUCT '{' '}' --add\\r\\nStruct : T_KW_STRUCT '{' StructDecls '}'\\r\\nStructDecl : T_KW_STRUCT Id '{' '}' --add\\r\\nStructDecl : T_KW_STRUCT Id '{' UseDecl StructDecls '}'\\r\\nStructDecl : T_KW_STRUCT Id '{' StructDecls '}'\\r\\n\\r\\nConstStructDecl : StructDecl\\r\\nConstStructDecl : ConstUsages StructDecl\\r\\n\\r\\nStructDecls : VariableDecl --expose\\r\\nStructDecls : VariableDecl StructDecls\\r\\n\\r\\nSemantic : ':' Id --add\\r\\nSemantic : ':' T_KW_REGISTER '(' Register ')'\\r\\nSemantics : Semantic\\r\\nSemantics : Semantics Semantic\\r\\nSemanticsOpt :\\r\\nSemanticsOpt : Semantics\\r\\n\\r\\nRegister : Id\\r\\nRegister : Target ',' Id\\r\\n\\r\\nAnnotation : AnnotationBegin AnnotationEnd  --add\\r\\nAnnotation : AnnotationBegin AnnotationDecls AnnotationEnd\\r\\nAnnotationOpt :\\r\\nAnnotationOpt : Annotation\\r\\nAnnotationBegin : '<'\\r\\nAnnotationDecls : VariableDecl\\r\\nAnnotationDecls : VariableDecl AnnotationDecls\\r\\nAnnotationEnd : '>'\\r\\n\\r\\nInitializer : '=' AssignmentExpr --add\\r\\nInitializer : '=' ERROR --add\\r\\nInitializer : '=' '{' InitExprs '}'\\r\\nInitializer : '=' '{' InitExprs ',' '}'\\r\\n\\r\\n# InitializerOpt :\\r\\n# InitializerOpt : Initializer\\r\\n\\r\\n\\r\\n# [Storage_Class] [Type_Modifier] Type Name[Index]\\r\\n#    [: Semantic]\\r\\n#    [: Packoffset]\\r\\n#    [: Register];\\r\\n#    [Annotations]\\r\\n#    [= Initial_Value]\\r\\n#\\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509706(v=vs.85).aspx\\r\\n\\r\\nVariableDecl : UsageType Variables ';' --add\\r\\nVariableDecl : UsageType Variables ERROR --add\\r\\nVarStructDecl : UsageStructDecl Variables ';' --add\\r\\nVariables : Variable --expose\\r\\nVariables : Variables ',' Variable\\r\\n# Variables : Variables ERROR Variable\\r\\nVariables : Variables ',' ERROR\\r\\nVariable : VariableDim SemanticsOpt AnnotationOpt Initializer --add\\r\\nVariable : VariableDim SemanticsOpt AnnotationOpt --add\\r\\nVariableDim : NonTypeId --add\\r\\nVariableDim : VariableDim '[' ConstantExpr ']'\\r\\n\\r\\n\\r\\n# [StorageClass] [clipplanes()] [precise] Return_Value Name ( [ArgumentList] ) [: Semantic]\\r\\n# {ок\\r\\n#   [StatementBlock]\\r\\n# };\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509607(v=vs.85).aspx\\r\\n\\r\\nFunctionDecl : Attributes FunctionDef ';' --add\\r\\nFunctionDecl : FunctionDef ';' --add\\r\\nFunctionDecl : Attributes FunctionDef AnnotationOpt StmtBlock\\r\\nFunctionDecl : FunctionDef AnnotationOpt StmtBlock\\r\\n\\r\\n# TODO: remove it;\\r\\nFunctionDecl : Attributes FunctionDef AnnotationOpt ERROR\\r\\nFunctionDecl : FunctionDef AnnotationOpt ERROR\\r\\n\\r\\nFunctionDef : UsageType NonTypeId ParamList SemanticsOpt\\r\\n\\r\\nAttribute : '[' Id '(' ArgumentsOpt ')' ']'\\r\\nAttribute : '[' Id ']'\\r\\nAttributes : Attribute --expose\\r\\nAttributes : Attributes Attribute\\r\\nAttributesOpt : --expose\\r\\nAttributesOpt : Attributes\\r\\n\\r\\nParamList : '(' ')'\\r\\nParamList : '(' T_KW_VOID ')'\\r\\nParamList : '(' ParameterDecls ')'\\r\\n\\r\\n\\r\\n# [InputModifier] Type Name [: Semantic] [InterpolationModifier] [= Initializers]\\r\\n# \\r\\n# https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb509606(v=vs.85).aspx\\r\\n\\r\\nParameterDecls : ParameterDecl --expose\\r\\nParameterDecls : ParameterDecls ',' ParameterDecl\\r\\nParameterDecls : ParameterDecls ERROR ParameterDecl\\r\\nParameterDecls : ParameterDecls ',' ERROR\\r\\nParameterDecls : ERROR\\r\\nParameterDecl : ParamUsageType Variable\\r\\n\\r\\nParamUsageType : Type --add\\r\\nParamUsageType : ParamUsages Type\\r\\n\\r\\nParamUsages : ParamUsage --expose\\r\\nParamUsages : ParamUsages ParamUsage\\r\\nParamUsage : T_KW_IN --add\\r\\nParamUsage : T_KW_OUT\\r\\nParamUsage : T_KW_INOUT\\r\\nParamUsage : T_KW_UNIFORM\\r\\nParamUsage : ConstUsage\\r\\n\\r\\n\\r\\nTechniqueDecl : T_KW_TECHNIQUE ComplexNameOpt SemanticsOpt AnnotationOpt TechniqueBody --add\\r\\nTechniqueBody : '{' '}'  --add\\r\\nTechniqueBody : '{' PassDecls '}'\\r\\n\\r\\nComplexNameOpt : ComplexName --add\\r\\nComplexName : Id --expose\\r\\nComplexName : ComplexName '.' Id\\r\\n\\r\\nPassDecls : PassDecl --expose\\r\\nPassDecls : PassDecls PassDecl\\r\\nPassDecl : T_KW_PASS IdOpt AnnotationOpt PassStateBlock --add\\r\\nPassDecl : ';'\\r\\n\\r\\nPassStateBlock : '{' '}' --add\\r\\nPassStateBlock : '{' PassStates '}'\\r\\nPassStates : PassState --expose\\r\\nPassStates : PassStates PassState\\r\\n\\r\\nPassState : Id StateIndex '=' PassStateExpr ';' --add\\r\\n\\r\\n# todo: move all particles declarations to separate grammar!\\r\\n#if FX_PART\\r\\n\\r\\nPartFxDecl : T_KW_FXPART ComplexNameOpt SemanticsOpt AnnotationOpt PartFxBody --add\\r\\n\\r\\nPartFxBody : '{' '}' \\r\\nPartFxBody : '{' PartFxProperties '}'\\r\\n\\r\\nPartFxProperties : PartFxProperty --expose\\r\\nPartFxProperties : PartFxProperties PartFxProperty\\r\\n\\r\\nPartFxProperty : PassState\\r\\nPartFxProperty : PassDecl\\r\\n\\r\\n#endif // FX_PART\\r\\n\\r\\nStateBlock : '{' '}' --add\\r\\nStateBlock : '{' States '}'\\r\\n\\r\\n\\r\\nStates : State --expose\\r\\nStates : States State\\r\\nState : Id StateIndex '=' StateExpr ';' --add\\r\\n\\r\\nStateIndex :\\r\\nStateIndex : '[' Uint ']'\\r\\n\\r\\nStmtBlock : '{' '}' --add\\r\\nStmtBlock : '{' Stmts '}'  \\r\\n\\r\\nStmts : Stmt --expose\\r\\nStmts : Stmts Stmt\\r\\n\\r\\n# SimpleStmt : ERROR ';' \\r\\n# SimpleStmt : ';' --add\\r\\n\\r\\nSimpleStmt : Expr ';'\\r\\nSimpleStmt : Expr ERROR\\r\\nSimpleStmt : T_KW_RETURN ';'\\r\\nSimpleStmt : T_KW_RETURN Expr ';'\\r\\nSimpleStmt : T_KW_RETURN ERROR ';'\\r\\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' Expr ')' ';'\\r\\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' ERROR ')' ';'\\r\\nSimpleStmt : StmtBlock\\r\\nSimpleStmt : T_KW_DISCARD ';'\\r\\nSimpleStmt : TypeDecl\\r\\nSimpleStmt : VariableDecl --add\\r\\nSimpleStmt : VarStructDecl\\r\\nSimpleStmt : T_KW_BREAK ';'\\r\\nSimpleStmt : T_KW_BREAK ERROR\\r\\nSimpleStmt : T_KW_CONTINUE ';'\\r\\nSimpleStmt : T_KW_CONTINUE ERROR\\r\\n\\r\\n#if FX_PART\\r\\nSimpleStmt : T_KW_SPAWN '(' Uint ')' NonTypeId '(' ArgumentsOpt ')' ';'\\r\\n#endif\\r\\n\\r\\n\\r\\nNonIfStmt : SimpleStmt --add\\r\\nNonIfStmt : WhileStmt NonIfStmt\\r\\nNonIfStmt : ForStmt NonIfStmt\\r\\n\\r\\nStmt : SimpleStmt --add\\r\\nStmt : UseDecl\\r\\nStmt : WhileStmt Stmt\\r\\nStmt : ForStmt Stmt\\r\\nStmt : IfStmt Stmt\\r\\nStmt : IfStmt NonIfStmt T_KW_ELSE Stmt\\r\\nStmt : ERROR\\r\\nStmt : ';'\\r\\n\\r\\nIfStmt : AttributesOpt T_KW_IF '(' Expr ')' --expose\\r\\nIfStmt : AttributesOpt T_KW_IF '(' ERROR ')' --expose\\r\\n\\r\\nWhileStmt : T_KW_WHILE '(' Expr ')' --expose\\r\\nWhileStmt : T_KW_WHILE '(' ERROR ')' --expose\\r\\n\\r\\nForStmt : For '(' ForInit ForCond ForStep ')' --expose\\r\\nForStmt : For ERROR --expose\\r\\n\\r\\nFor : T_KW_FOR\\r\\n\\r\\nForInit : ';' --add\\r\\nForInit : Expr ';'\\r\\nForInit : VariableDecl\\r\\nForInit : ERROR ';'\\r\\n\\r\\nForCond : ';' --add\\r\\nForCond : Expr ';'\\r\\nForCond : ERROR ';'\\r\\n\\r\\nForStep : --add\\r\\nForStep : Expr\\r\\nForStep : ERROR\\r\\n\\r\\nDwordExpr : Dword\\r\\nDwordExpr : Dword '|' DwordExpr\\r\\n\\r\\nDwordExprSeq : DwordExpr --expose\\r\\nDwordExprSeq : DwordExpr ',' DwordExprSeq\\r\\n\\r\\nPassStateExpr : DwordExpr --add\\r\\nPassStateExpr : ComplexExpr\\r\\nPassStateExpr : '{' DwordExprSeq '}'\\r\\n\\r\\nStateExpr : DwordExpr --add\\r\\nStateExpr : ComplexExpr\\r\\nStateExpr : '{' InitExprs '}'\\r\\nStateExpr : '{' InitExprs ',' '}'\\r\\nStateExpr : '<' RelationalExpr '>'\\r\\n\\r\\nSimpleExpr : T_KW_TRUE\\r\\nSimpleExpr : T_KW_FALSE\\r\\nSimpleExpr : Uint\\r\\nSimpleExpr : Float\\r\\nSimpleExpr : String\\r\\nSimpleExpr : NonTypeId\\r\\n\\r\\nComplexExpr : '(' Expr ')'\\r\\nComplexExpr : TypeId '(' ArgumentsOpt ')'\\r\\nComplexExpr : BaseType '(' ArgumentsOpt ')'\\r\\nComplexExpr : NonTypeId '(' ArgumentsOpt ')'\\r\\nComplexExpr : PostfixPointExpr '(' ArgumentsOpt ')'\\r\\nComplexExpr : ObjectExpr\\r\\n\\r\\nObjectExpr : T_KW_COMPILE NonTypeId '(' ArgumentsOpt ')'\\r\\nObjectExpr : T_KW_SAMPLER_STATE StateBlock\\r\\nObjectExpr : T_KW_COMPILE_FRAGMENT Target NonTypeId '(' ArgumentsOpt ')'\\r\\nObjectExpr : T_KW_STATEBLOCK_STATE StateBlock\\r\\n\\r\\nPrimaryExpr : ComplexExpr\\r\\nPrimaryExpr : SimpleExpr\\r\\nPostfixExpr : PrimaryExpr\\r\\nPostfixExpr : PostfixExpr '[' Expr ']'\\r\\nPostfixExpr : PostfixExpr '[' ERROR ']'\\r\\nPostfixExpr : PostfixExpr '.' Id\\r\\nPostfixExpr : PostfixExpr T_OP_INC\\r\\nPostfixExpr : PostfixExpr T_OP_DEC\\r\\n\\r\\nPostfixPointExpr : PostfixExpr '.' Id\\r\\n\\r\\nUnaryExpr : PostfixExpr\\r\\nUnaryExpr : T_OP_INC UnaryExpr\\r\\nUnaryExpr : T_OP_DEC UnaryExpr\\r\\n# UnaryExpr : T_OP_INC ERROR\\r\\n# UnaryExpr : T_OP_DEC ERROR\\r\\nUnaryExpr : '!' CastExpr\\r\\n# UnaryExpr : '!' ERROR\\r\\nUnaryExpr : '-' CastExpr\\r\\nUnaryExpr : '+' CastExpr\\r\\n\\r\\nCastExpr : UnaryExpr\\r\\nCastExpr : '(' ConstTypeDim ')' CastExpr\\r\\nCastExpr : '(' ERROR ')' CastExpr\\r\\n\\r\\nMulExpr : CastExpr\\r\\nMulExpr : MulExpr '*' CastExpr\\r\\nMulExpr : MulExpr '/' CastExpr\\r\\nMulExpr : MulExpr '%' CastExpr\\r\\n\\r\\nMulExpr : ERROR '*' CastExpr\\r\\nMulExpr : ERROR '/' CastExpr\\r\\nMulExpr : ERROR '%' CastExpr\\r\\nMulExpr : MulExpr '*' ERROR\\r\\nMulExpr : MulExpr '/' ERROR\\r\\nMulExpr : MulExpr '%' ERROR\\r\\n# MulExpr : ERROR '*' ERROR\\r\\n# MulExpr : ERROR '/' ERROR\\r\\n# MulExpr : ERROR '%' ERROR\\r\\n\\r\\nAddExpr : MulExpr\\r\\nAddExpr : AddExpr '+' MulExpr\\r\\nAddExpr : AddExpr '-' MulExpr\\r\\n\\r\\nAddExpr : AddExpr '+' ERROR\\r\\nAddExpr : AddExpr '-' ERROR\\r\\n\\r\\nRelationalExpr : AddExpr\\r\\nRelationalExpr : RelationalExpr '<' AddExpr\\r\\nRelationalExpr : RelationalExpr '>' AddExpr\\r\\nRelationalExpr : RelationalExpr T_OP_LE AddExpr\\r\\nRelationalExpr : RelationalExpr T_OP_GE AddExpr\\r\\n\\r\\nRelationalExpr : ERROR '<' AddExpr\\r\\nRelationalExpr : RelationalExpr '<' ERROR\\r\\nRelationalExpr : ERROR '<' ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr '>' ERROR\\r\\nRelationalExpr : ERROR '>' AddExpr\\r\\nRelationalExpr : ERROR '>' ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr T_OP_LE ERROR\\r\\nRelationalExpr : ERROR T_OP_LE AddExpr\\r\\nRelationalExpr : ERROR T_OP_LE ERROR\\r\\n\\r\\nRelationalExpr : RelationalExpr T_OP_GE ERROR\\r\\nRelationalExpr : ERROR T_OP_GE AddExpr\\r\\nRelationalExpr : ERROR T_OP_GE ERROR\\r\\n\\r\\nEqualityExpr : RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_EQ RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_NE RelationalExpr\\r\\nEqualityExpr : ERROR T_OP_EQ RelationalExpr\\r\\nEqualityExpr : EqualityExpr T_OP_NE ERROR\\r\\nEqualityExpr : ERROR T_OP_NE ERROR\\r\\n\\r\\nAndExpr : EqualityExpr\\r\\nAndExpr : AndExpr T_OP_AND EqualityExpr\\r\\nAndExpr : ERROR T_OP_AND EqualityExpr\\r\\nAndExpr : AndExpr T_OP_AND ERROR\\r\\n\\r\\nOrExpr : AndExpr\\r\\nOrExpr : OrExpr T_OP_OR AndExpr\\r\\nOrExpr : OrExpr T_OP_OR ERROR\\r\\nOrExpr : ERROR T_OP_OR AndExpr\\r\\n\\r\\nConditionalExpr : OrExpr\\r\\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ConditionalExpr\\r\\nConditionalExpr : ERROR '?' AssignmentExpr ':' ConditionalExpr\\r\\nConditionalExpr : OrExpr '?' ERROR ':' ConditionalExpr\\r\\nConditionalExpr : OrExpr '?' AssignmentExpr ':' ERROR\\r\\nConditionalExpr : OrExpr '?' ERROR ':' ERROR\\r\\nConditionalExpr : ERROR '?' ERROR ':' ERROR\\r\\nConditionalExpr : ERROR '?' ERROR ':' ConditionalExpr\\r\\n\\r\\nAssignmentExpr : ConditionalExpr\\r\\nAssignmentExpr : CastExpr '=' AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_ME AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_DE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_RE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_AE AssignmentExpr\\r\\nAssignmentExpr : CastExpr T_OP_SE AssignmentExpr\\r\\n\\r\\nArguments : AssignmentExpr --expose\\r\\nArguments : Arguments ',' AssignmentExpr\\r\\nArguments : Arguments ERROR AssignmentExpr\\r\\nArguments : Arguments ',' ERROR\\r\\nArgumentsOpt : --expose\\r\\nArgumentsOpt : Arguments\\r\\n\\r\\nInitExpr : AssignmentExpr --add\\r\\nInitExpr : '{' InitExprs '}'\\r\\nInitExpr : '{' InitExprs ',' '}'\\r\\nInitExprs : InitExpr --expose\\r\\nInitExprs : InitExprs ',' InitExpr\\r\\n\\r\\nConstantExpr : AssignmentExpr\\r\\nExpr : AssignmentExpr\\r\\nExpr : Expr ',' AssignmentExpr\\r\\nExpr : Expr ',' ERROR\\r\\nExpr : ERROR ',' ERROR\\r\\nExpr : ERROR ',' AssignmentExpr\\r\\n\\r\\nDword : Uint\\r\\nDword : '-' Uint\\r\\nDword : Float\\r\\nDword : '-' Float\\r\\nDword : DwordId\\r\\nDword : Uint DwordId\\r\\nDwordId : Id\\r\\nDwordId : T_KW_TRUE\\r\\nDwordId : T_KW_FALSE\\r\\nDwordId : T_KW_TEXTURE\\r\\n\\r\\nId : TypeId\\r\\nId : NonTypeId\\r\\nIdOpt :\\r\\nIdOpt : Id\\r\\n\\r\\nTarget : NonTypeId\\r\\n\\r\\nUint : T_UINT\\r\\nFloat : T_FLOAT\\r\\n\\r\\nStrings : String\\r\\nStrings : Strings String\\r\\nString : T_STRING\\r\\n\\r\\nTypeId : T_TYPE_ID\\r\\nNonTypeId : T_NON_TYPE_ID\\r\\nLineTerminator : T_LINE_TERMINATOR\\r\\n\\r\\nAsmDecl : T_KW_DECL '{'\\r\\nAsm : T_KW_ASM '{'\\r\\nAsmFragment : T_KW_ASM_FRAGMENT '{'\\r\\n\\r\\n--LEXER--\\r\\n\\r\\nT_KW_STATIC : \\\"static\\\"\\r\\nT_KW_UNIFORM : \\\"uniform\\\"\\r\\nT_KW_EXTERN : \\\"extern\\\"\\r\\nT_KW_VOLATILE : \\\"volatile\\\"\\r\\nT_KW_INLINE : \\\"inline\\\"\\r\\nT_KW_CONST : \\\"const\\\"\\r\\nT_KW_ROW_MAJOR : \\\"row_major\\\"\\r\\nT_KW_COLUMN_MAJOR : \\\"column_major\\\"\\r\\nT_KW_TYPEDEF : \\\"typedef\\\"\\r\\nT_KW_STRUCT : \\\"struct\\\"\\r\\nT_KW_VOID : \\\"void\\\"\\r\\nT_KW_BOOL : \\\"bool\\\"\\r\\nT_KW_INT : \\\"int\\\"\\r\\nT_KW_UINT : \\\"uint\\\"\\r\\nT_KW_HALF : \\\"half\\\"\\r\\nT_KW_FLOAT : \\\"float\\\"\\r\\nT_KW_DOUBLE : \\\"double\\\"\\r\\nT_KW_VECTOR : \\\"vector\\\"\\r\\nT_KW_MATRIX : \\\"matrix\\\"\\r\\nT_KW_STRING : \\\"string\\\"\\r\\nT_KW_TEXTURE : \\\"texture\\\"\\r\\nT_KW_TEXTURE1D : \\\"texture1D\\\"\\r\\nT_KW_TEXTURE2D : \\\"texture2D\\\"\\r\\nT_KW_TEXTURE3D : \\\"texture3D\\\"\\r\\nT_KW_TEXTURECUBE : \\\"texturecube\\\"\\r\\nT_KW_SAMPLER : \\\"sampler\\\"\\r\\nT_KW_SAMPLER1D : \\\"sampler1D\\\"\\r\\nT_KW_SAMPLER2D : \\\"sampler2D\\\"\\r\\nT_KW_SAMPLER3D : \\\"sampler3D\\\"\\r\\nT_KW_SAMPLERCUBE : \\\"samplerCUBE\\\"\\r\\nT_KW_RWBUFFER : \\\"RWBuffer\\\"\\r\\nT_KW_RWSTRUCTUREDBUFFER : \\\"RWStructuredBuffer\\\"\\r\\nT_KW_APPENDSTRUCTUREDBUFFER : \\\"AppendStructuredBuffer\\\"\\r\\nT_KW_PIXELSHADER : \\\"pixelshader\\\"\\r\\nT_KW_VERTEXSHADER : \\\"vertexshader\\\"\\r\\nT_KW_PIXELFRAGMENT : \\\"pixelfragment\\\"\\r\\nT_KW_VERTEXFRAGMENT : \\\"vertexfragment\\\"\\r\\nT_KW_STATEBLOCK : \\\"stateblock\\\"\\r\\nT_KW_REGISTER : \\\"register\\\"\\r\\nT_KW_IN : \\\"in\\\"\\r\\nT_KW_OUT : \\\"out\\\"\\r\\nT_KW_INOUT : \\\"inout\\\"\\r\\nT_KW_TECHNIQUE : \\\"technique\\\"\\r\\n#if FX_PART\\r\\n    T_KW_FXPART : \\\"partFx\\\"\\r\\n#endif\\r\\nT_KW_PASS : \\\"pass\\\"\\r\\nT_KW_RETURN : \\\"return\\\"\\r\\nT_KW_DO : \\\"do\\\"\\r\\nT_KW_DISCARD : \\\"discard\\\"\\r\\nT_KW_WHILE : \\\"while\\\"\\r\\nT_KW_IF : \\\"if\\\"\\r\\nT_KW_ELSE : \\\"else\\\"\\r\\nT_KW_FOR : \\\"for\\\"\\r\\nT_KW_TRUE : \\\"true\\\"\\r\\nT_KW_FALSE : \\\"false\\\"\\r\\nT_KW_COMPILE : \\\"compile\\\"\\r\\nT_KW_SAMPLER_STATE : \\\"sampler_state\\\"\\r\\nT_KW_COMPILE_FRAGMENT : \\\"compile_fragment\\\"\\r\\nT_KW_STATEBLOCK_STATE : \\\"stateblock_state\\\"\\r\\nT_KW_DECL : \\\"decl\\\"\\r\\nT_KW_ASM : \\\"asm\\\"\\r\\nT_KW_ASM_FRAGMENT : \\\"asm_fragment\\\"\\r\\nT_KW_USE : \\\"use\\\"\\r\\nT_KW_STRICT : \\\"strict\\\"\\r\\nT_KW_IMPORT : \\\"import\\\"\\r\\nT_KW_PROVIDE : \\\"provide\\\"\\r\\nT_KW_SWITCH : \\\"switch\\\"\\r\\nT_KW_CASE : \\\"case\\\"\\r\\nT_KW_DEFAULT : \\\"default\\\"\\r\\nT_KW_BREAK : \\\"break\\\"\\r\\n#if FX_PART\\r\\nT_KW_SPAWN : \\\"spawn\\\"\\r\\n#endif\\r\\nT_KW_CONTINUE : \\\"continue\\\"\\r\\nT_KW_AS : \\\"as\\\"\\r\\nT_KW_INCLUDE : \\\"include\\\"\\r\\nT_OP_INC : \\\"++\\\"\\r\\nT_OP_DEC : \\\"--\\\"\\r\\nT_OP_LE : \\\">=\\\"\\r\\nT_OP_GE : \\\"<=\\\"\\r\\nT_OP_EQ : \\\"==\\\"\\r\\nT_OP_NE : \\\"!=\\\"\\r\\nT_OP_AND : \\\"&&\\\"\\r\\nT_OP_OR : \\\"||\\\"\\r\\nT_OP_ME : \\\"*=\\\"\\r\\nT_OP_DE : \\\"/=\\\"\\r\\nT_OP_RE : \\\"%=\\\"\\r\\nT_OP_AE : \\\"+=\\\"\\r\\nT_OP_SE : \\\"-=\\\"\";","import { IPosition } from \"./parser/IParser\";\r\n\r\nexport enum EDiagnosticCategory {\r\n    k_Warning,\r\n    k_Error\r\n}\r\n\r\n\r\nexport interface IDiagnosticEntry<DESC_T> {\r\n    category: EDiagnosticCategory;\r\n    code: number;\r\n    desc: DESC_T;\r\n}\r\n\r\n\r\ntype IDiagnosticDescription = string;\r\n\r\nexport interface IDiagnosticMessage {\r\n    code: string;\r\n    category: EDiagnosticCategory;\r\n    start?: IPosition;\r\n    end?: IPosition;\r\n    file?: string;\r\n    content: string;\r\n}\r\n\r\nexport interface IDiagnosticReport {\r\n    errors: number;\r\n    warnings: number;\r\n\r\n    messages: IDiagnosticMessage[];\r\n}\r\n\r\n\r\n\r\nexport interface IDiagnostics<DESC_T> {\r\n    reset(): void;\r\n    resolve(): IDiagnosticReport;\r\n    error(code: number, desc: DESC_T);\r\n    warning(code: number, desc: DESC_T);\r\n    critical(code: number, desc: DESC_T);\r\n    prettyPrint(): string;\r\n    hasErrors(): boolean;\r\n    getLastError(): IDiagnosticMessage;\r\n}\r\n","export enum EAnalyzerErrors {\r\n    SystemTypeRedefinition = 2202,\r\n    TypeRedefinition,\r\n    VariableRedefinition,\r\n    SystemVariableRedefinition,\r\n    FunctionRedifinition,\r\n    SystemFunctionRedefinition,\r\n\r\n    UnsupportedTypeDecl,\r\n    UnsupportedExpr,\r\n    UnknownVarName,\r\n    InvalidArithmeticOperation,\r\n    InvalidArithmeticAssigmentOperation,\r\n    InvalidAssigmentOperation,\r\n    InvalidLeftHandSideInAssignment,\r\n    InvalidRelationalOperation,\r\n    InvalidLogicOperation,\r\n    InvalidConditionType ,\r\n    InvalidConditonValueTypes,\r\n    InvalidCastTypeUsage,\r\n    InvalidCastTypeNotBase,\r\n    InvalidCastUnknownType,\r\n    InvalidUnaryOperation,\r\n    InvalidPostfixNotArray,\r\n    InvalidPostfixNotIntIndex,\r\n    InvalidPostfixNotField,\r\n    InvalidPostfixArithmetic,\r\n    InvalidComplexNotFunction,\r\n    InvalidComplexNotType,\r\n    InvalidComplexNotConstructor,\r\n    InvalidCompileNotFunction,\r\n    InvalidCompileFunctionNotValid,\r\n    FunctionRedefinition,\r\n    InvalidWhileCondition,\r\n    InvalidDoWhileCondition,\r\n    InvalidIfCondition,\r\n    InvalidForInitExpr,\r\n    InvalidForInitEmptyIterator,\r\n    InvalidForConditionEmpty,\r\n    InvalidForConditionRelation,\r\n    InvalidForStepEmpty,\r\n    InvalidForStepOperator,\r\n    InvalidForStepExpr,\r\n    InvalidNewFieldForStructName,\r\n    InvalidNewFieldForStructSematic,\r\n    InvalidNewAnnotationVar,\r\n    InvalidFunctionParameterDefenitionDefaultNeeded,\r\n    CannotChooseFunction,\r\n    InvalidFuncDefenitionReturnType,\r\n    InvalidSystemFunctionReturnType,\r\n    InvalidTypeNameNotType,\r\n    InvalidTypeNameTemplateNotFound,\r\n    InvalidTypeScope,\r\n    CannotProduceType,\r\n    InvalidTypeVectorMatrix,\r\n    TechniqueNameRedefinition,\r\n    InvalidFunctionRecursionNotAllowed,\r\n    InvalidFunctionImplementationNotFound,\r\n    // InvalidFunctionUsageVertex,\r\n    // InvalidFunctionUsagePixel,\r\n    FunctionIsNotCompatibleWithVertexShader,\r\n    FunctionIsNotCompatibleWithPixelShader,\r\n    InvalidReturnStmtVoid,\r\n    InvalidReturnStmtEmpty,\r\n    InvalidReturnStmtTypesNotEqual,\r\n    InvalidFunctionReturnType,\r\n    InvalidFunctionParameterUsage,\r\n    InvalidTypeForWriting,\r\n    InvalidTypeForReading,\r\n    InvalidExprIsNotLValue,\r\n    InvalidVariableInitializing,\r\n    UnsupportedStateIndex,\r\n    InvalidSamplerTexture,\r\n    CannotCalcPadding,\r\n    ImportedComponentNotExists,\r\n    InvalidFunctionReturnStmtNotFound,\r\n    UnsupportedProvideAs,\r\n    UnreachableCode,\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    PartFx_VertexShaderParametersMismatch,\r\n    PartFx_InvalidSpawnStmtInitializerNotFound\r\n};\r\n"],"sourceRoot":""}