"use strict";
(global["webpackChunkinflux"] = global["webpackChunkinflux"] || []).push([["sandbox"],{

/***/ "eX6A":
/*!*************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/sandbox/styles/custom/dat-gui.css ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "9Qo4");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "xqvs");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/getUrl.js */ "GsOf");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw== */ "ScS0"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".dg.main.taller-than-window .close-button {\r\n    border-top: 1px solid #ddd;\r\n}\r\n\r\n.dg.main .close-button {\r\n    background-color: #ccc;\r\n}\r\n \r\n.dg.main .close-button:hover {\r\n    background-color: #ddd;\r\n}\r\n\r\n.dg {\r\n    color: #555;\r\n    text-shadow: none !important;\r\n}\r\n\r\n.dg.main::-webkit-scrollbar {\r\n    background: #fafafa;\r\n}\r\n\r\n.dg.main::-webkit-scrollbar-thumb {\r\n    background: #bbb;\r\n}\r\n \r\n.dg li:not(.folder) {\r\n    background: #fafafa;\r\n    border-bottom: 1px solid #ddd;\r\n}\r\n \r\n.dg li.save-row .button {\r\n    text-shadow: none !important;\r\n}\r\n\r\n.dg li.title {\r\n    background: #e8e8e8 url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") 6px 10px no-repeat;\r\n}\r\n\r\n.dg .cr.function:hover,.dg .cr.boolean:hover {\r\n    background: #fff;\r\n}\r\n \r\n.dg .c input[type=text] {\r\n    background: #e9e9e9;\r\n}\r\n \r\n.dg .c input[type=text]:hover {\r\n    background: #eee;\r\n}\r\n \r\n.dg .c input[type=text]:focus {\r\n    background: #eee;\r\n    color: #555;\r\n}\r\n \r\n.dg .c .slider {\r\n    background: #e9e9e9;\r\n}\r\n\r\n.dg .c .slider:hover {\r\n    background: #eee;\r\n}", "",{"version":3,"sources":["webpack://./src/sandbox/styles/custom/dat-gui.css"],"names":[],"mappings":"AAAA;IACI,0BAA0B;AAC9B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,WAAW;IACX,4BAA4B;AAChC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;IACnB,6BAA6B;AACjC;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,8EAA8I;AAClJ;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,gBAAgB;IAChB,WAAW;AACf;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;AACpB","sourcesContent":[".dg.main.taller-than-window .close-button {\r\n    border-top: 1px solid #ddd;\r\n}\r\n\r\n.dg.main .close-button {\r\n    background-color: #ccc;\r\n}\r\n \r\n.dg.main .close-button:hover {\r\n    background-color: #ddd;\r\n}\r\n\r\n.dg {\r\n    color: #555;\r\n    text-shadow: none !important;\r\n}\r\n\r\n.dg.main::-webkit-scrollbar {\r\n    background: #fafafa;\r\n}\r\n\r\n.dg.main::-webkit-scrollbar-thumb {\r\n    background: #bbb;\r\n}\r\n \r\n.dg li:not(.folder) {\r\n    background: #fafafa;\r\n    border-bottom: 1px solid #ddd;\r\n}\r\n \r\n.dg li.save-row .button {\r\n    text-shadow: none !important;\r\n}\r\n\r\n.dg li.title {\r\n    background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\r\n}\r\n\r\n.dg .cr.function:hover,.dg .cr.boolean:hover {\r\n    background: #fff;\r\n}\r\n \r\n.dg .c input[type=text] {\r\n    background: #e9e9e9;\r\n}\r\n \r\n.dg .c input[type=text]:hover {\r\n    background: #eee;\r\n}\r\n \r\n.dg .c input[type=text]:focus {\r\n    background: #eee;\r\n    color: #555;\r\n}\r\n \r\n.dg .c .slider {\r\n    background: #e9e9e9;\r\n}\r\n\r\n.dg .c .slider:hover {\r\n    background: #eee;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "iz1S":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/sandbox/styles/custom/fonts/OpenSans/stylesheet.css ***!
  \*******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "9Qo4");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ "xqvs");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/getUrl.js */ "GsOf");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBoldItalic.eot */ "TWab"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBoldItalic.woff */ "ytbO"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBoldItalic.ttf */ "iTsd"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-LightItalic.eot */ "Y/V/"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-LightItalic.woff */ "cG71"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-LightItalic.ttf */ "unS+"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Bold.eot */ "nU2I"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Bold.woff */ "phpT"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Bold.ttf */ "hm/n"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBoldItalic.eot */ "k000"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBoldItalic.woff */ "8wxu"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBoldItalic.ttf */ "ASCZ"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Light.eot */ "S5Bv"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_13___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Light.woff */ "wf1j"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_14___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Light.ttf */ "go9E"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_15___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Italic.eot */ "TmKA"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_16___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Italic.woff */ "vib5"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_17___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Italic.ttf */ "EH0b"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_18___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Regular.eot */ "FEm/"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_19___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Regular.woff */ "YUzg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_20___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-Regular.ttf */ "B9Gu"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_21___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBold.eot */ "8371"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_22___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBold.woff */ "O0ak"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_23___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-SemiBold.ttf */ "X6xQ"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_24___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBold.eot */ "ByKz"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_25___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBold.woff */ "5hm/"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_26___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-ExtraBold.ttf */ "X0ru"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_27___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-BoldItalic.eot */ "KISA"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_28___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-BoldItalic.woff */ "vjGn"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_29___ = new URL(/* asset import */ __webpack_require__(/*! OpenSans-BoldItalic.ttf */ "hxng"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);
var ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);
var ___CSS_LOADER_URL_REPLACEMENT_13___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_14___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_10___);
var ___CSS_LOADER_URL_REPLACEMENT_15___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_11___);
var ___CSS_LOADER_URL_REPLACEMENT_16___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___);
var ___CSS_LOADER_URL_REPLACEMENT_17___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_18___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_13___);
var ___CSS_LOADER_URL_REPLACEMENT_19___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_14___);
var ___CSS_LOADER_URL_REPLACEMENT_20___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_15___);
var ___CSS_LOADER_URL_REPLACEMENT_21___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_15___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_22___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_16___);
var ___CSS_LOADER_URL_REPLACEMENT_23___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_17___);
var ___CSS_LOADER_URL_REPLACEMENT_24___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_18___);
var ___CSS_LOADER_URL_REPLACEMENT_25___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_18___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_26___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_19___);
var ___CSS_LOADER_URL_REPLACEMENT_27___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_20___);
var ___CSS_LOADER_URL_REPLACEMENT_28___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_21___);
var ___CSS_LOADER_URL_REPLACEMENT_29___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_21___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_30___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_22___);
var ___CSS_LOADER_URL_REPLACEMENT_31___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_23___);
var ___CSS_LOADER_URL_REPLACEMENT_32___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_24___);
var ___CSS_LOADER_URL_REPLACEMENT_33___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_24___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_34___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_25___);
var ___CSS_LOADER_URL_REPLACEMENT_35___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_26___);
var ___CSS_LOADER_URL_REPLACEMENT_36___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_27___);
var ___CSS_LOADER_URL_REPLACEMENT_37___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_27___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_38___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_28___);
var ___CSS_LOADER_URL_REPLACEMENT_39___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_29___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* This stylesheet generated by Transfonter (https://transfonter.org) on October 3, 2017 10:08 PM */\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\r\n\tsrc: local('Open Sans SemiBold Italic'), local('OpenSans-SemiBoldItalic'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") format('truetype');\r\n\tfont-weight: 600;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ");\r\n\tsrc: local('Open Sans Light Italic'), local('OpenSans-LightItalic'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ") format('truetype');\r\n\tfont-weight: 300;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + ");\r\n\tsrc: local('Open Sans Bold'), local('OpenSans-Bold'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_9___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_10___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_11___ + ") format('truetype');\r\n\tfont-weight: bold;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_12___ + ");\r\n\tsrc: local('Open Sans ExtraBold Italic'), local('OpenSans-ExtraBoldItalic'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_13___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_14___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_15___ + ") format('truetype');\r\n\tfont-weight: 800;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_16___ + ");\r\n\tsrc: local('Open Sans Light'), local('OpenSans-Light'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_17___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_18___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_19___ + ") format('truetype');\r\n\tfont-weight: 300;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_20___ + ");\r\n\tsrc: local('Open Sans Italic'), local('OpenSans-Italic'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_21___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_22___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_23___ + ") format('truetype');\r\n\tfont-weight: normal;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_24___ + ");\r\n\tsrc: local('Open Sans Regular'), local('OpenSans-Regular'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_25___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_26___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_27___ + ") format('truetype');\r\n\tfont-weight: normal;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_28___ + ");\r\n\tsrc: local('Open Sans SemiBold'), local('OpenSans-SemiBold'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_29___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_30___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_31___ + ") format('truetype');\r\n\tfont-weight: 600;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_32___ + ");\r\n\tsrc: local('Open Sans ExtraBold'), local('OpenSans-ExtraBold'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_33___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_34___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_35___ + ") format('truetype');\r\n\tfont-weight: 800;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url(" + ___CSS_LOADER_URL_REPLACEMENT_36___ + ");\r\n\tsrc: local('Open Sans Bold Italic'), local('OpenSans-BoldItalic'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_37___ + ") format('embedded-opentype'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_38___ + ") format('woff'),\r\n\t\turl(" + ___CSS_LOADER_URL_REPLACEMENT_39___ + ") format('truetype');\r\n\tfont-weight: bold;\r\n\tfont-style: italic;\r\n}\r\n", "",{"version":3,"sources":["webpack://./src/sandbox/styles/custom/fonts/OpenSans/stylesheet.css"],"names":[],"mappings":"AAAA,mGAAmG;;AAEnG;CACC,wBAAwB;CACxB,4CAAuC;CACvC;;;4DAGsD;CACtD,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,4CAAoC;CACpC;;;4DAGmD;CACnD,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,4CAA6B;CAC7B;;;6DAG4C;CAC5C,iBAAiB;CACjB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAAwC;CACxC;;;6DAGuD;CACvD,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAA8B;CAC9B;;;6DAG6C;CAC7C,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAA+B;CAC/B;;;6DAG8C;CAC9C,mBAAmB;CACnB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAAgC;CAChC;;;6DAG+C;CAC/C,mBAAmB;CACnB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAAiC;CACjC;;;6DAGgD;CAChD,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAAkC;CAClC;;;6DAGiD;CACjD,gBAAgB;CAChB,kBAAkB;AACnB;;AAEA;CACC,wBAAwB;CACxB,6CAAmC;CACnC;;;6DAGkD;CAClD,iBAAiB;CACjB,kBAAkB;AACnB","sourcesContent":["/* This stylesheet generated by Transfonter (https://transfonter.org) on October 3, 2017 10:08 PM */\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-SemiBoldItalic.eot');\r\n\tsrc: local('Open Sans SemiBold Italic'), local('OpenSans-SemiBoldItalic'),\r\n\t\turl('OpenSans-SemiBoldItalic.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-SemiBoldItalic.woff') format('woff'),\r\n\t\turl('OpenSans-SemiBoldItalic.ttf') format('truetype');\r\n\tfont-weight: 600;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-LightItalic.eot');\r\n\tsrc: local('Open Sans Light Italic'), local('OpenSans-LightItalic'),\r\n\t\turl('OpenSans-LightItalic.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-LightItalic.woff') format('woff'),\r\n\t\turl('OpenSans-LightItalic.ttf') format('truetype');\r\n\tfont-weight: 300;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-Bold.eot');\r\n\tsrc: local('Open Sans Bold'), local('OpenSans-Bold'),\r\n\t\turl('OpenSans-Bold.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-Bold.woff') format('woff'),\r\n\t\turl('OpenSans-Bold.ttf') format('truetype');\r\n\tfont-weight: bold;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-ExtraBoldItalic.eot');\r\n\tsrc: local('Open Sans ExtraBold Italic'), local('OpenSans-ExtraBoldItalic'),\r\n\t\turl('OpenSans-ExtraBoldItalic.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-ExtraBoldItalic.woff') format('woff'),\r\n\t\turl('OpenSans-ExtraBoldItalic.ttf') format('truetype');\r\n\tfont-weight: 800;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-Light.eot');\r\n\tsrc: local('Open Sans Light'), local('OpenSans-Light'),\r\n\t\turl('OpenSans-Light.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-Light.woff') format('woff'),\r\n\t\turl('OpenSans-Light.ttf') format('truetype');\r\n\tfont-weight: 300;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-Italic.eot');\r\n\tsrc: local('Open Sans Italic'), local('OpenSans-Italic'),\r\n\t\turl('OpenSans-Italic.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-Italic.woff') format('woff'),\r\n\t\turl('OpenSans-Italic.ttf') format('truetype');\r\n\tfont-weight: normal;\r\n\tfont-style: italic;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-Regular.eot');\r\n\tsrc: local('Open Sans Regular'), local('OpenSans-Regular'),\r\n\t\turl('OpenSans-Regular.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-Regular.woff') format('woff'),\r\n\t\turl('OpenSans-Regular.ttf') format('truetype');\r\n\tfont-weight: normal;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-SemiBold.eot');\r\n\tsrc: local('Open Sans SemiBold'), local('OpenSans-SemiBold'),\r\n\t\turl('OpenSans-SemiBold.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-SemiBold.woff') format('woff'),\r\n\t\turl('OpenSans-SemiBold.ttf') format('truetype');\r\n\tfont-weight: 600;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-ExtraBold.eot');\r\n\tsrc: local('Open Sans ExtraBold'), local('OpenSans-ExtraBold'),\r\n\t\turl('OpenSans-ExtraBold.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-ExtraBold.woff') format('woff'),\r\n\t\turl('OpenSans-ExtraBold.ttf') format('truetype');\r\n\tfont-weight: 800;\r\n\tfont-style: normal;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: 'Open Sans';\r\n\tsrc: url('OpenSans-BoldItalic.eot');\r\n\tsrc: local('Open Sans Bold Italic'), local('OpenSans-BoldItalic'),\r\n\t\turl('OpenSans-BoldItalic.eot?#iefix') format('embedded-opentype'),\r\n\t\turl('OpenSans-BoldItalic.woff') format('woff'),\r\n\t\turl('OpenSans-BoldItalic.ttf') format('truetype');\r\n\tfont-weight: bold;\r\n\tfont-style: italic;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "UeFz":
/*!****************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/default_mat_frag.glsl ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n    gl_FragColor = vColor;\r\n}\r\n");

/***/ }),

/***/ "6M9U":
/*!****************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/default_mat_vert.glsl ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nattribute vec3 position;\r\nattribute vec4 color;\r\nattribute float size;\r\nattribute vec3 offset;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n    vColor = color;\r\n    vec4 viewPos = modelViewMatrix * vec4(offset, 1.0) + vec4(position * size, 0.0);\r\n    gl_Position = projectionMatrix * viewPos;\r\n}\r\n");

/***/ }),

/***/ "jhCH":
/*!********************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/lwi_colored_mat_frag.glsl ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = vColor;\r\n}\r\n");

/***/ }),

/***/ "0VNV":
/*!********************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/lwi_colored_mat_vert.glsl ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\n\r\nuniform mat4 modelMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv;\r\n\r\n/*\r\n\r\nstruct LwiInstance {\r\n    float4 dynData[2]: META;\r\n    float3x4 worldMatr: TRANSFORM0;\r\n    float3x4 worldMatrPrev: TRANSFORM1;\r\n};\r\n\r\nwebgl doesn't support non-squared matrices or arrays in attributes (!)\r\n\r\n*/\r\n\r\nattribute vec4 a_dynData_0;\r\nattribute vec4 a_dynData_1;\r\n\r\nattribute vec4 a_worldMat_0;\r\nattribute vec4 a_worldMat_1;\r\nattribute vec4 a_worldMat_2;\r\n\r\nattribute vec4 a_worldMatPrev_0;\r\nattribute vec4 a_worldMatPrev_1;\r\nattribute vec4 a_worldMatPrev_2;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() \r\n{\r\n    vec4 zero = vec4(position, 1.0);\r\n    \r\n    vec4 pos;\r\n    pos.x = dot(a_worldMat_0, zero);\r\n    pos.y = dot(a_worldMat_1, zero);\r\n    pos.z = dot(a_worldMat_2, zero);\r\n    pos.w = 1.0;\r\n\r\n    vec4 viewPos = viewMatrix * pos;\r\n    gl_Position = projectionMatrix * viewPos;\r\n\r\n    vec3 lightDir;\r\n    lightDir = normalize(vec3(1.0, 4.0, 1.0));\r\n\r\n    float NdL;\r\n    NdL = max(0.0, dot(normal, lightDir) * 0.75);\r\n    vColor = vec4(vec3(NdL), 0.0) + vec4(0.25, 0.25, 0.25, 1.0) * a_dynData_0;\r\n}\r\n");

/***/ }),

/***/ "HHfF":
/*!************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/lwi_mat_frag.glsl ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() \r\n{\r\n    gl_FragColor = vColor;\r\n}\r\n");

/***/ }),

/***/ "76Yc":
/*!************************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/lwi_mat_vert.glsl ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\r\n\r\nuniform mat4 modelMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv;\r\n\r\n/*\r\n\r\nstruct LwiInstance {\r\n    float4 dynData[2]: META;\r\n    float3x4 worldMatr: TRANSFORM0;\r\n    float3x4 worldMatrPrev: TRANSFORM1;\r\n};\r\n\r\nwebgl doesn't support non-squared matrices or arrays in attributes (!)\r\n\r\n*/\r\n\r\nattribute vec4 a_dynData_0;\r\nattribute vec4 a_dynData_1;\r\n\r\nattribute vec4 a_worldMat_0;\r\nattribute vec4 a_worldMat_1;\r\nattribute vec4 a_worldMat_2;\r\n\r\nattribute vec4 a_worldMatPrev_0;\r\nattribute vec4 a_worldMatPrev_1;\r\nattribute vec4 a_worldMatPrev_2;\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() \r\n{\r\n    vec4 zero = vec4(position, 1.0);\r\n    \r\n    vec4 pos;\r\n    pos.x = dot(a_worldMat_0, zero);\r\n    pos.y = dot(a_worldMat_1, zero);\r\n    pos.z = dot(a_worldMat_2, zero);\r\n    pos.w = 1.0;\r\n\r\n    vec4 viewPos = viewMatrix * pos;\r\n    gl_Position = projectionMatrix * viewPos;\r\n\r\n    vec3 lightDir;\r\n    lightDir = normalize(vec3(1.0, -4.0, 0.0));\r\n\r\n    float NdL;\r\n    NdL = max(0.0, dot(normal, lightDir) * 0.5);\r\n    vColor = vec4(vec3(NdL), 0.0) + vec4(0.5, 0.5, 0.5, 1.0);\r\n}\r\n");

/***/ }),

/***/ "+s+v":
/*!****************************!*\
  !*** ./src/lib/fx/HLSL.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HLSL": () => (/* reexport default export from named module */ _HLSL_gr__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _HLSL_gr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HLSL.gr */ "Zvko");




/***/ }),

/***/ "45qh":
/*!****************************************************************!*\
  !*** ./src/sandbox/containers/editor/LanguageServiceWorker.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LanguageServiceWorker": () => (/* reexport safe */ worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var worker_loader_LanguageServiceProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! worker-loader!./LanguageServiceProvider */ "aBBW");



/***/ }),

/***/ "5byo":
/*!***************************************************************!*\
  !*** ./src/sandbox/containers/playground/shaders/fx/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defMatFS": () => (/* reexport safe */ _default_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "defMatVS": () => (/* reexport safe */ _default_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "lwiColoredMatFS": () => (/* reexport safe */ _lwi_colored_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "lwiColoredMatVS": () => (/* reexport safe */ _lwi_colored_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "lwiMatFS": () => (/* reexport safe */ _lwi_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "lwiMatVS": () => (/* reexport safe */ _lwi_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _default_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default_mat_vert.glsl */ "6M9U");
/* harmony import */ var _default_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_mat_frag.glsl */ "UeFz");
/* harmony import */ var _lwi_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lwi_mat_vert.glsl */ "76Yc");
/* harmony import */ var _lwi_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lwi_mat_frag.glsl */ "HHfF");
/* harmony import */ var _lwi_colored_mat_vert_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lwi_colored_mat_vert.glsl */ "0VNV");
/* harmony import */ var _lwi_colored_mat_frag_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lwi_colored_mat_frag.glsl */ "jhCH");







/***/ }),

/***/ "zwOj":
/*!***********************************************!*\
  !*** ./src/sandbox/styles/custom/dat-gui.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "0Yvd");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "9Hkc");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "TId8");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "Ass9");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "zKo0");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "jzgE");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../node_modules/css-loader/dist/cjs.js!./dat-gui.css */ "eX6A");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_dat_gui_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "N9h6":
/*!*****************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/stylesheet.css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "0Yvd");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "9Hkc");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "TId8");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "Ass9");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "zKo0");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "jzgE");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_stylesheet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../../../node_modules/css-loader/dist/cjs.js!./stylesheet.css */ "iz1S");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_stylesheet_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_stylesheet_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_stylesheet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_stylesheet_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "/ig4":
/*!**************************!*\
  !*** ./src/lib/bf/bf.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "clearAll": () => (/* binding */ clearAll),
/* harmony export */   "clearBit": () => (/* binding */ clearBit),
/* harmony export */   "clearFlags": () => (/* binding */ clearFlags),
/* harmony export */   "equal": () => (/* binding */ equal),
/* harmony export */   "flag": () => (/* binding */ flag),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "isNotEqaul": () => (/* binding */ isNotEqaul),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "setAll": () => (/* binding */ setAll),
/* harmony export */   "setBit": () => (/* binding */ setBit),
/* harmony export */   "setFlags": () => (/* binding */ setFlags),
/* harmony export */   "testAll": () => (/* binding */ testAll),
/* harmony export */   "testAny": () => (/* binding */ testAny),
/* harmony export */   "testBit": () => (/* binding */ testBit),
/* harmony export */   "totalBits": () => (/* binding */ totalBits),
/* harmony export */   "totalSet": () => (/* binding */ totalSet)
/* harmony export */ });
/**
 *    @a x  .
 */
var flag = (x) => (1 << (x));
/**
 *     @a value    @a bit  .
 */
var testBit = (value, bit) => ((value & flag(bit)) != 0);
/**
 *     @a value    ,
 *     @a set.
 */
var testAll = (value, set) => (((value) & (set)) == (set));
/**
 *     @a value        ,
 *     @a set.
 */
var testAny = (value, set) => (((value) & (set)) != 0);
/**
 *     @a bit   @a value  
 */
var setBit = (value, bit, setting = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
 *
 */
var clearBit = (value, bit) => ((value) &= ~flag((bit)));
/**
 *     @a bit   @a value  
 */
var setAll = (value, set, setting = true) => (setting ? ((value) |= (set)) : ((value) &= ~(set)));
/**
 *      @a value  ,
 *      @a set
 */
var clearAll = (value, set) => ((value) &= ~(set));
/**
 *      @a value  ,
 *      @a set
 */
var equal = (value, src) => { value = src; };
/**
 *   @a value  @a src
 */
var isEqual = (value, src) => value == src;
/**
 *   @a value   @a src  true
 */
var isNotEqaul = (value, src) => value != src;
/**
 *   @a value  @a src
 */
var set = (value, src) => { value = src; };
/**
 *   @a value
 */
var clear = (value) => { value = 0; };
/**
 *      @a value  ,
 *      @a src
 */
var setFlags = (value, src) => (value |= src);
/**
 *      @a value  ,
 *      @a src
 */
var clearFlags = (value, src) => value &= ~src;
/**
 *     @a value .    true.
 *     false.
 */
var isEmpty = (value) => (value == 0);
/**
 *      @a value.
 *      32.
 */
var totalBits = (value) => 32;
/**
 *       @a value.
 */
var totalSet = (value) => {
    var count = 0;
    var total = totalBits(value);
    for (var i = total; i; --i) {
        count += (value & 1);
        value >>= 1;
    }
    return (count);
};


/***/ }),

/***/ "SSye":
/*!*****************************!*\
  !*** ./src/lib/bf/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bf */ "/ig4");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_bf__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "cOQ3":
/*!***************************!*\
  !*** ./src/lib/common.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "deepEqual": () => (/* binding */ deepEqual),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "isBlob": () => (/* binding */ isBlob),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDef": () => (/* binding */ isDef),
/* harmony export */   "isDefAndNotNull": () => (/* binding */ isDefAndNotNull),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isFloat": () => (/* binding */ isFloat),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isInt": () => (/* binding */ isInt),
/* harmony export */   "isNull": () => (/* binding */ isNull),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isTypedArray": () => (/* binding */ isTypedArray),
/* harmony export */   "isUint": () => (/* binding */ isUint),
/* harmony export */   "mwalk": () => (/* binding */ mwalk),
/* harmony export */   "typeOf": () => (/* binding */ typeOf),
/* harmony export */   "verbose": () => (/* binding */ verbose)
/* harmony export */ });
let typeOf = (x) => {
    const s = typeof x;
    if (s === 'object') {
        if (x) {
            if (x instanceof Array) {
                return 'array';
            }
            else if (x instanceof Object) {
                return s;
            }
            const sClassName = Object.prototype.toString.call(x);
            if (sClassName === '[object Window]') {
                return 'object';
            }
            if ((sClassName === '[object Array]' ||
                (typeof x.length) === 'number' &&
                    (typeof x.splice) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('splice'))) {
                return 'array';
            }
            if ((sClassName === '[object Function]' ||
                (typeof x.call) !== 'undefined' &&
                    (typeof x.propertyIsEnumerable) !== 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                return 'function';
            }
        }
        else {
            return 'null';
        }
    }
    else if (s === 'function' && (typeof x.call) === 'undefined') {
        return 'object';
    }
    return s;
};
let isDef = (x) => x !== undefined;
let isDefAndNotNull = (x) => x != null;
let isEmpty = (x) => x.length === 0;
let isNull = (x) => x === null;
let isBoolean = (x) => typeof x === 'boolean';
let isString = (x) => typeof x === 'string';
let isNumber = (x) => typeof x === 'number';
let isFloat = isNumber;
let isInt = (x) => isNumber(x) && (~~x === x);
let isUint = (x) => isInt(x) && x > 0;
let isFunction = (x) => typeOf(x) === 'function';
let isObject = (x) => {
    const T = typeOf(x);
    return T === 'object' || T === 'array' || T === 'function';
};
let isArrayBuffer = (x) => x instanceof ArrayBuffer;
let isTypedArray = (x) => x !== null && typeof x === 'object' && typeof x.byteOffset === 'number';
let isBlob = (x) => x instanceof Blob;
let isArray = (x) => typeOf(x) === 'array';
// export let assignIfDef = (val: any, def: any) => (isDef(val) ? val : def);
let deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
const assert = console.assert.bind(console);
const verbose = console.log.bind(console);
/** 'ForEach' for maps. */
function mwalk(map, cb) {
    let i = 0;
    for (const key in map) {
        if (cb(map[key], key, i++) === false) {
            break;
        }
    }
}


/***/ }),

/***/ "GtHH":
/*!*******************************************!*\
  !*** ./src/lib/fx/AnalyzerDiagnostics.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnalyzerDiagnostics": () => (/* binding */ AnalyzerDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");





class AnalyzerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics {
    constructor() {
        super("Analyzer Diagnostics", 'A');
    }
    resolveFilename(category, code, desc) {
        return desc.file.toString();
    }
    resolveRange(category, code, desc) {
        return desc.loc;
    }
    diagnosticMessages() {
        // TODO: fill all errors.
        // TODO: add support for warnings
        return {
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtEmpty]: 'Invalid return statement. Expression with \'*type*\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtVoid]: 'Invalid return statement. Expression with \'void\' type expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedefinition]: 'Function redefinition. Function with name \'{info.funcName}\' already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFuncDefenitionReturnType]: 'Invalid function defenition return type. Function with the same name \'{info.funcName}\' but another type already declared.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnStmtNotFound]: 'Return statement expected.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializing]: 'Invalid variable initializing.',
            [_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotFunction]: ({ info }) => `Function definition for "${info.funcName}(${info.args.join(', ')})" has not been found.`
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            return `${_lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors[code]}: ${JSON.stringify(data)}`;
    }
}


/***/ }),

/***/ "sg/z":
/*!************************************!*\
  !*** ./src/lib/fx/FXSLDocument.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFXSLDocument": () => (/* binding */ createFXSLDocument),
/* harmony export */   "extendFXSLDocument": () => (/* binding */ extendFXSLDocument)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analisys/FxAnalyzer */ "rHPT");
/* harmony import */ var _SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SLASTDocument */ "s/Ev");



;
async function createFXSLDocument(document, opts = {}, parent = null) {
    let textDocument;
    let slastDocument;
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(document.source)) {
        textDocument = document;
        slastDocument = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textDocument, opts);
    }
    else {
        slastDocument = document;
    }
    const timeLabel = `createFXSLDocument(${slastDocument.uri})`;
    console.time(timeLabel);
    const analyzer = new _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__.FxAnalyzer;
    const slDocument = await analyzer.parse(slastDocument, parent);
    console.timeEnd(timeLabel);
    return slDocument;
}
async function extendFXSLDocument(textAddition, base, expressions, opts = {}) {
    let addition = null;
    if (textAddition) {
        const knownTypes = Object.keys(base.root.scope.types);
        const { flags, includeResolver } = opts;
        addition = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textAddition, { flags, knownTypes, includeResolver });
    }
    const analyzer = new _analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__.FxAnalyzer;
    const slDocument = analyzer.extend(addition, base, expressions);
    return slDocument;
}


/***/ }),

/***/ "s/Ev":
/*!*************************************!*\
  !*** ./src/lib/fx/SLASTDocument.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SLASTDocument": () => (/* binding */ SLASTDocument),
/* harmony export */   "createSLASTDocument": () => (/* binding */ createSLASTDocument)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/ASTDocument */ "7GK7");
/* harmony import */ var _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/Preprocessor */ "nYIV");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _SLParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SLParser */ "/oCY");





// const readFile = fname => fetch(fname).then(resp => resp.text(), reason => console.warn('!!!', reason));
const PREDEFINED_TYPES = [
    'half2', 'half3', 'half4',
    'float2', 'float3', 'float4',
    'float2x2', 'float2x3', 'float2x4',
    'float3x2', 'float3x3', 'float3x4',
    'float4x2', 'float4x3', 'float4x4',
    'int2', 'int3', 'int4',
    'uint2', 'uint3', 'uint4',
    'bool2', 'bool3', 'bool4',
    'auto'
];
class SLASTDocument extends _lib_parser_ASTDocument__WEBPACK_IMPORTED_MODULE_1__.ASTDocument {
    constructor({ parser = (0,_SLParser__WEBPACK_IMPORTED_MODULE_4__.defaultSLParser)(), knownTypes = new Set(), ...settings } = {}) {
        super({ parser, knownTypes: new Set([...PREDEFINED_TYPES, ...knownTypes]), ...settings });
    }
    get includes() {
        return this.preprocessor.includeMap;
    }
    get unreachableCode() {
        return this.preprocessor.unreachableCodeList;
    }
    get macros() {
        return [...this.preprocessor.macros];
    }
    get unresolvedMacros() {
        return this.preprocessor.unresolvedMacros;
    }
    get uri() {
        return this.preprocessor.uri;
    }
    get diagnosticReport() {
        let preprocessorReport = this.preprocessor.getDiagnosticReport();
        let parserReport = this.diag.resolve();
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_3__.Diagnostics.mergeReports([preprocessorReport, parserReport]);
    }
    init(config) {
        super.init(config);
        const { knownTypes } = this;
        const { includeResolver, defines } = config;
        this.preprocessor = new _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__.Preprocessor(this.parser.lexerEngine, { knownTypes, includeResolver, defines });
        this.ruleFunctions.set('addType', this._addType.bind(this));
        this.ruleFunctions.set('addTypeDef', this._addTypeDef.bind(this));
        this.ruleFunctions.set('print', this._print.bind(this));
    }
    _addType() {
        const tree = this.tree;
        const node = tree.lastNode;
        const typeId = node.value;
        this.knownTypes.add(typeId);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    _addTypeDef() {
        const tree = this.tree;
        const node = tree.lastNode;
        const typeId = node.children[0].value;
        this.knownTypes.add(typeId);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    _print() {
        const tree = this.tree;
        const node = tree.lastNode;
        console.log(node);
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EOperationType.k_Ok;
    }
    setTextDocument(textDocument) {
        this.preprocessor.setTextDocument(textDocument);
    }
    async readToken() {
        const token = await this.preprocessor.readToken();
        // replacement of the original token location with the macro location
        const macroLoc = this.preprocessor.macroLocation();
        if (macroLoc) {
            token.loc = macroLoc;
        }
        return token;
    }
}
;
async function createSLASTDocument(textDocument, opts = {}) {
    const { flags, knownTypes, includeResolver, defines } = opts;
    const document = new SLASTDocument({ knownTypes: new Set([...(knownTypes || [])]), includeResolver, defines });
    // const timeLabel = `createSLASTDocument(${textDocument.uri})`;
    // console.time(timeLabel);
    await document.parse(textDocument, flags);
    // console.timeEnd(timeLabel);
    return document;
}


/***/ }),

/***/ "7Nqm":
/*!**********************************!*\
  !*** ./src/lib/fx/SLDocument.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSLDocument": () => (/* binding */ createSLDocument),
/* harmony export */   "extendSLDocument": () => (/* binding */ extendSLDocument)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analisys/Analyzer */ "R35j");
/* harmony import */ var _SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SLASTDocument */ "s/Ev");



async function createSLDocument(document, opts = {}) {
    let textDocument = document;
    let slastDocument = document;
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(textDocument.source)) {
        let { flags, includeResolver } = opts;
        slastDocument = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textDocument, { flags, includeResolver });
    }
    const timeLabel = `createSLDocument(${slastDocument.uri})`;
    console.time(timeLabel);
    const analyzer = new _analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__.Analyzer;
    const slDocument = await analyzer.parse(slastDocument);
    console.timeEnd(timeLabel);
    return slDocument;
}
// export async function extendSLDocument2(addition: ISLASTDocument, base: ISLDocument, expressions?: IMap<IExprSubstCallback>): Promise<ISLDocument> {
//     const analyzer = new Analyzer;
//     const slDocument = analyzer.extend(addition, base, expressions);
//     return slDocument;
// }
async function extendSLDocument(textAddition, base, expressions, opts = {}) {
    let addition = null;
    if (textAddition) {
        let knownTypes = Object.keys(base.root.scope.types);
        let { flags, includeResolver } = opts;
        addition = await (0,_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textAddition, { flags, knownTypes, includeResolver });
    }
    const analyzer = new _analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__.Analyzer;
    const slDocument = analyzer.extend(addition, base, expressions);
    return slDocument;
}


/***/ }),

/***/ "/oCY":
/*!********************************!*\
  !*** ./src/lib/fx/SLParser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SLParser": () => (/* binding */ SLParser),
/* harmony export */   "createDefaultSLParser": () => (/* binding */ createDefaultSLParser),
/* harmony export */   "defaultSLGrammar": () => (/* binding */ defaultSLGrammar),
/* harmony export */   "defaultSLParser": () => (/* binding */ defaultSLParser)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/AbstractParser */ "BF0t");
/* harmony import */ var _HLSL__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HLSL */ "+s+v");



// import slGrammar from 'raw-loader!./HLSL.gr';

class SLParser extends _lib_parser_AbstractParser__WEBPACK_IMPORTED_MODULE_2__.AbstractParser {
    init({ grammar = _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LALR, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_Default }) {
        super.init({ grammar, type, flags });
    }
}
let paramsDefault = null;
let parserDefault = null;
function defaultSLGrammar() {
    return _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL;
}
function defaultSLParser() {
    if (!parserDefault) {
        createDefaultSLParser();
    }
    return parserDefault;
}
/**
 * Internal debugging functionality, no need to use without necessary.
 */
function createDefaultSLParser(params = { grammar: _HLSL__WEBPACK_IMPORTED_MODULE_3__.HLSL }) {
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(paramsDefault, params)) {
        return;
    }
    paramsDefault = params;
    parserDefault = new SLParser(params);
}


/***/ }),

/***/ "E5ji":
/*!************************************!*\
  !*** ./src/lib/fx/TextDocument.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTextDocument": () => (/* binding */ createTextDocument)
/* harmony export */ });
/* harmony import */ var _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/util/StringRef */ "Cx6u");

async function createTextDocument(uri, source, offset = null) {
    uri = _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_0__.StringRef.make(uri);
    return { uri, source, offset };
}


/***/ }),

/***/ "bVKE":
/*!*************************************!*\
  !*** ./src/lib/fx/UniformHelper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function UniformHelper(storage = new Uint8Array(256)) {
    let offset = 0;
    let mapping = [];
    let self = { set, finish };
    function finish() {
        let uniforms = {};
        mapping.forEach((entry, i, arr) => {
            let length = (i < (arr.length - 1) ? arr[i + 1].offset : offset) - entry.offset;
            let data = new Uint8Array(storage.buffer, storage.byteOffset + entry.offset, length);
            uniforms[entry.name] = data;
        });
        return uniforms;
    }
    function set(name) {
        mapping.push({ name, offset });
        function float2(x, y) {
            float(x);
            float(y);
            return self;
        }
        function float3(x, y, z) {
            float(x);
            float(y);
            float(z);
            return self;
        }
        function float4(x, y, z, w) {
            float3(x, y, z);
            float(w);
            return self;
        }
        function float(x) {
            (new DataView(storage.buffer, storage.byteOffset)).setFloat32(offset, x, true);
            offset += 4;
            console.assert(offset < storage.byteLength);
            return self;
        }
        function int(x) {
            (new DataView(storage.buffer, storage.byteOffset)).setInt32(offset, x, true);
            offset += 4;
            console.assert(offset < storage.byteLength);
            return self;
        }
        function raw(data) {
            for (let u8 of data) {
                storage[offset] = u8;
                offset++;
            }
            console.assert(offset < storage.byteLength);
            return self;
        }
        return { float4, float3, float2, float, int, raw };
    }
    return self;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UniformHelper);
// let u8 = new Uint8Array(256);
// let helper = UniformHelper(u8);
// helper.set('elapsedTime').float(0);


/***/ }),

/***/ "q04y":
/*!********************************!*\
  !*** ./src/lib/fx/Visitors.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Visitor": () => (/* binding */ Visitor),
/* harmony export */   "visitor": () => (/* binding */ visitor)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");

// TODO: move it to helpers
function visitor(owner, cb) {
    if (!owner) {
        return;
    }
    const visit = (instr) => {
        if (instr) {
            cb(instr, owner);
            visitor(instr, cb);
        }
    };
    switch (owner.instructionType) {
        //
        // Stmt
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt:
            owner.declList.forEach(decl => visit(decl));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ExprStmt:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IfStmt:
            visit(owner.cond);
            visit(owner.conseq);
            visit(owner.contrary);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock:
            owner.stmtList.forEach(stmt => visit(stmt));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt:
            visit(owner.init);
            visit(owner.cond);
            visit(owner.body);
            visit(owner.step);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt:
            visit(owner.cond);
            visit(owner.body);
            break;
        //
        // Expr
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CastExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as ICompileExprInstruction).function);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileShader11Expr:
            visit(owner.func);
            owner.args.forEach(arg => visit(arg));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr:
            visit(owner.left);
            visit(owner.right);
            visit(owner.condition);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IConstructorCallInstruction).ctor);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr:
            owner.args.forEach(arg => visit(arg));
            // visit((owner as IFunctionCallInstruction).decl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr:
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_InitExpr:
            owner.args.forEach(arg => visit(arg));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StateBlockExpr:
            console.assert(false, 'not implemented');
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StringExpr:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_NullExpr:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_LogicalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr:
            visit(owner.expr);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr:
            visit(owner.element);
            visit(owner.index);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr:
            visit(owner.element);
            visit(owner.postfix);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_RelationalExpr:
            visit(owner.left);
            visit(owner.right);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SamplerStateBlockExpr:
            owner.params.forEach(param => visit(param));
            visit(owner.texture);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_UnaryExpr:
            visit(owner.expr);
            break;
        //
        // Others
        //
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexType:
            owner.fields.forEach(field => visit(field));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDef:
            visit(owner.returnType);
            visit(owner.id);
            owner.params.forEach(param => visit(param));
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDecl:
            visit(owner.def);
            visit(owner.impl);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableDecl:
            visit(owner.type);
            visit(owner.initExpr);
            visit(owner.id);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableType:
            visit(owner.subType);
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Id:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SystemFunctionDecl:
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SystemType:
            // nothing todo
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt:
            break;
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SpawnStmt:
            // nothing todo?
            break;
        default:
            console.error('unsupported instruction type found');
    }
}
const Visitor = {
    each: visitor
};


/***/ }),

/***/ "R35j":
/*!*****************************************!*\
  !*** ./src/lib/fx/analisys/Analyzer.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Analyzer": () => (/* binding */ Analyzer),
/* harmony export */   "Context": () => (/* binding */ Context)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _lib_fx_AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/AnalyzerDiagnostics */ "GtHH");
/* harmony import */ var _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/fx/Visitors */ "q04y");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./helpers */ "pEQR");
/* harmony import */ var _instructions_AnnotationInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instructions/AnnotationInstruction */ "0qyf");
/* harmony import */ var _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./instructions/ArithmeticExprInstruction */ "+tx1");
/* harmony import */ var _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./instructions/AssignmentExprInstruction */ "eck/");
/* harmony import */ var _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./instructions/AttributeInstruction */ "rs/O");
/* harmony import */ var _instructions_BitwiseExprInstruction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./instructions/BitwiseExprInstruction */ "l236");
/* harmony import */ var _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./instructions/BoolInstruction */ "d+t4");
/* harmony import */ var _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./instructions/BreakStmtInstruction */ "t33R");
/* harmony import */ var _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./instructions/CastExprInstruction */ "KHnE");
/* harmony import */ var _instructions_CbufferInstruction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./instructions/CbufferInstruction */ "r+W1");
/* harmony import */ var _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./instructions/CompileExprInstruction */ "MV/g");
/* harmony import */ var _instructions_CompileShader11Instruction__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./instructions/CompileShader11Instruction */ "Ugh4");
/* harmony import */ var _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./instructions/ComplexExprInstruction */ "RRea");
/* harmony import */ var _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./instructions/ComplexTypeInstruction */ "G0Ba");
/* harmony import */ var _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./instructions/ConditionalExprInstruction */ "IsZF");
/* harmony import */ var _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./instructions/ConstructorCallInstruction */ "RIdR");
/* harmony import */ var _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./instructions/DeclStmtInstruction */ "YZc1");
/* harmony import */ var _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./instructions/ExprStmtInstruction */ "ubxH");
/* harmony import */ var _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./instructions/FloatInstruction */ "OsKO");
/* harmony import */ var _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./instructions/ForStmtInstruction */ "r82U");
/* harmony import */ var _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./instructions/FunctionCallInstruction */ "y57x");
/* harmony import */ var _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./instructions/FunctionDeclInstruction */ "BLpd");
/* harmony import */ var _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./instructions/IdInstruction */ "Muaz");
/* harmony import */ var _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./instructions/IfStmtInstruction */ "AAir");
/* harmony import */ var _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./instructions/InitExprInstruction */ "lavR");
/* harmony import */ var _instructions_Instruction__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./instructions/Instruction */ "hbjL");
/* harmony import */ var _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./instructions/IntInstruction */ "s0og");
/* harmony import */ var _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./instructions/LogicalExprInstruction */ "Oxvu");
/* harmony import */ var _instructions_NullInstruction__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./instructions/NullInstruction */ "a5rM");
/* harmony import */ var _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./instructions/PassInstruction */ "Z/0D");
/* harmony import */ var _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./instructions/PostfixArithmeticInstruction */ "fxHi");
/* harmony import */ var _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./instructions/PostfixIndexInstruction */ "yhcv");
/* harmony import */ var _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _instructions_Preset__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./instructions/Preset */ "6z3E");
/* harmony import */ var _instructions_PresetProperty__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./instructions/PresetProperty */ "vF1C");
/* harmony import */ var _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./instructions/ProvideInstruction */ "Tk3Z");
/* harmony import */ var _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./instructions/ProxyTypeInstruction */ "ijf+");
/* harmony import */ var _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./instructions/RelationalExprInstruction */ "2i/b");
/* harmony import */ var _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./instructions/ReturnStmtInstruction */ "UL2e");
/* harmony import */ var _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./instructions/SemicolonStmtInstruction */ "Po1l");
/* harmony import */ var _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./instructions/StateBlockInstruction */ "z98Y");
/* harmony import */ var _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./instructions/StmtBlockInstruction */ "fc3/");
/* harmony import */ var _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./instructions/StringInstruction */ "mlvU");
/* harmony import */ var _instructions_Technique11Instruction__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./instructions/Technique11Instruction */ "QdWn");
/* harmony import */ var _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./instructions/TechniqueInstruction */ "dmHP");
/* harmony import */ var _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./instructions/TypeDeclInstruction */ "Jg/d");
/* harmony import */ var _instructions_TypedefInstruction__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./instructions/TypedefInstruction */ "bYYM");
/* harmony import */ var _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./instructions/UnaryExprInstruction */ "Dbly");
/* harmony import */ var _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./instructions/WhileStmtInstruction */ "eHl7");
/* harmony import */ var _ProgramScope__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./ProgramScope */ "zHDc");
/* harmony import */ var _system_utils__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./system/utils */ "BeyE");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./SystemScope */ "c0pO");
/* module decorator */ module = __webpack_require__.hmd(module);




































































// TODO: refactor it
function findConstructor(type, args) {
    return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ type, scope: null });
}
const asType = (instr) => instr ? instr.type : null;
// FIXME: refuse from the regular expressions in favor of a full typecasting graph
// relax only uint => int
const asRelaxedType = (instr) => {
    if (!instr) {
        return null;
    }
    const type = (instr.getField) ? instr : instr.type;
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^
    //          hacky way to check if "type" instruction (not "typed")
    // hack to NULL expression to any type
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(type, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_NULL)) {
        return /^.*$/;
    }
    // allow "int" => "float" substitution
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(type) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(type) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(type)) {
        // temp workaround in order to match int to uint and etc. 
        const n = `${type.length > 1 ? type.length : ''}`;
        return new RegExp(`^int${n}$|^uint${n}$|^bool${n}$|^float${n}$`, "g");
    }
    return type;
};
// TODO: rework 'auto' api
function tryResolveProxyType(type, host) {
    if (type.subType && type.subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_ProxyType) {
        const proxy = type.subType;
        if (!proxy.isResolved()) {
            proxy.resolve(host);
        }
    }
}
/** @deprecated */
function getRenderStateValue(state, value) {
    let eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF;
    switch (state) {
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ALPHABLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ALPHATESTENABLE:
            console.warn('ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.');
            return _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.CULLFACEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZWRITEENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DITHERENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SCISSORTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.STENCILTESTENABLE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.POLYGONOFFSETFILLENABLE:
            switch (value) {
                case 'TRUE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.TRUE;
                    break;
                case 'FALSE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FALSE;
                    break;
                default:
                    console.warn('Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: '
                        + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.CULLFACE:
            switch (value) {
                case 'FRONT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FRONT;
                    break;
                case 'BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.BACK;
                    break;
                case 'FRONT_AND_BACK':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FRONT_AND_BACK;
                    break;
                default:
                    console.warn('Unsupported render state CULLFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.FRONTFACE:
            switch (value) {
                case 'CW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.CW;
                    break;
                case 'CCW':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.CCW;
                    break;
                default:
                    console.warn('Unsupported render state FRONTFACE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLEND:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNC:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNCSEPARATE:
            switch (value) {
                case 'ZERO':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ZERO;
                    break;
                case 'ONE':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ONE;
                    break;
                case 'SRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCCOLOR;
                    break;
                case 'INVSRCCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVSRCCOLOR;
                    break;
                case 'SRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCALPHA;
                    break;
                case 'INVSRCALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVSRCALPHA;
                    break;
                case 'DESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.DESTALPHA;
                    break;
                case 'INVDESTALPHA':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVDESTALPHA;
                    break;
                case 'DESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.DESTCOLOR;
                    break;
                case 'INVDESTCOLOR':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.INVDESTCOLOR;
                    break;
                case 'SRCALPHASAT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.SRCALPHASAT;
                    break;
                default:
                    console.warn('Unsupported render state SRCBLEND/DESTBLEND value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATION:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONSEPARATE:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR:
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA:
            switch (value) {
                case 'FUNCADD':
                case 'ADD':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCADD;
                    break;
                case 'FUNCSUBTRACT':
                case 'SUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCSUBTRACT;
                    break;
                case 'FUNCREVERSESUBTRACT':
                case 'REVERSESUBTRACT':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.FUNCREVERSESUBTRACT;
                    break;
                default:
                    console.warn('Unsupported render state BLENDEQUATION/BLENDEQUATIONSEPARATE value used: ' + value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.ZFUNC:
            switch (value) {
                case 'NEVER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.NEVER;
                    break;
                case 'LESS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LESS;
                    break;
                case 'EQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.EQUAL;
                    break;
                case 'LESSEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LESSEQUAL;
                    break;
                case 'GREATER':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.GREATER;
                    break;
                case 'NOTEQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.NOTEQUAL;
                    break;
                case 'GREATEREQUAL':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.GREATEREQUAL;
                    break;
                case 'ALWAYS':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.ALWAYS;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
        case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.PRIMITIVETOPOLOGY:
            switch (value) {
                case 'TRIANGLELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.TRIANGLELIST;
                    break;
                case 'LINELIST':
                    eValue = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.LINELIST;
                    break;
                default:
                    console.warn('Unsupported render state ZFUNC value used: ' +
                        value + '.');
                    return eValue;
            }
            break;
    }
    return eValue;
}
function addTypeDecl(context, scope, typeDecl) {
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(typeDecl.name)) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemTypeRedefinition, { typeName: typeDecl.name });
    }
    let isAdded = scope.addType(typeDecl.type);
    if (!isAdded) {
        context.error(typeDecl.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: typeDecl.name });
    }
}
// TODO: rework to support complex typ defenitions like 
//  typedef const float4 TYPE_T;
//          ^^^^^^
// IP: at the moment type defenitions are not supported
function addTypeAlias(context, scope, typedef) {
    if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(typedef.alias)) {
        context.error(typedef.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemTypeRedefinition, { typeName: typedef.name });
    }
    let isAdded = scope.addTypeAlias(typedef.type, typedef.alias);
    if (!isAdded) {
        context.error(typedef.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: typedef.alias });
    }
}
function checkFunctionForRecursion(context, func, stack) {
    if (stack.indexOf(func.instructionID) !== -1) {
        context.error(func.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionRecursionNotAllowed, { funcName: func.name });
        return false;
    }
    let recursionFound = false;
    stack = [...stack, func.instructionID];
    const recursionChecker = (instr) => {
        if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FunctionCallExpr) {
            let fcall = instr;
            let fdecl = fcall.decl;
            if (fdecl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemFunctionDecl) {
                return;
            }
            // NOTE: it is possible that the declaration was not complete 
            //       at the time of the call, so you need to look for a 
            //       version with implementation
            fdecl = fdecl.scope.findFunctionInScope(fdecl);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(fdecl.impl)) {
                if (fdecl.attrs.find(attr => attr.name === 'extern')) {
                    // todo: use context info
                    context.warn(instr.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ExternCall);
                }
                else {
                    context.error(instr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionImplementationNotFound, { funcName: fdecl.name });
                }
                return;
            }
            // visitor(fdecl.impl, recursionChecker);
            recursionFound = recursionFound ||
                checkFunctionForRecursion(context, fdecl, stack);
        }
    };
    (0,_lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_9__.visitor)(func.impl, recursionChecker);
    return !recursionFound;
}
function checkFunctionsForRecursion(context, program) {
    const gs = program.globalScope;
    let recusrionFound = false;
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.mwalk)(gs.functions, funcOverloads => {
        funcOverloads.forEach(func => {
            recusrionFound = recusrionFound ||
                !checkFunctionForRecursion(context, func, []);
        });
    });
    return !recusrionFound;
}
function checkForVertexUsage(funcDef) {
    if (!checkReturnTypeForVertexUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForVertexUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkForPixelUsage(funcDef) {
    if (!checkReturnTypeForPixelUsage(funcDef)) {
        return false;
    }
    if (!checkArgumentsForPixelUsage(funcDef)) {
        return false;
    }
    return true;
}
function checkReturnTypeForVertexUsage(funcDef) {
    const returnType = funcDef.returnType;
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID)) {
        return true;
    }
    if (returnType.isComplex()) {
        if (returnType.hasFieldWithoutSemantics()) {
            // todo: emit warning
            // return false;
        }
        if (!returnType.hasAllUniqueSemantics()) {
            return false;
        }
        // Forbid fileds with user-defined types
        // or any other complex types?
        // if (returnType.isContainComplexType()) 
        {
            //return false;
        }
    }
    else {
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4)) {
            return false;
        }
        if (funcDef.semantic !== "POSITION") {
            return false;
        }
    }
    return true;
}
// todo: add support for dual source blending
// todo: add support for MRT
function checkReturnTypeForPixelUsage(funcDef) {
    let returnType = funcDef.returnType;
    if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID)) {
        return true;
    }
    // TODO: add MRT support
    if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(returnType)) {
        return false;
    }
    if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4)) {
        return false;
    }
    if (funcDef.semantic !== "COLOR") {
        // todo: emit warning
        // return false;
    }
    return true;
}
function checkArgumentsForVertexUsage(funcDef) {
    let params = funcDef.params;
    let isAttributeByStruct = false;
    let isAttributeByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(param.type) ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics()) {
                    return false;
                }
                isAttributeByStruct = true;
            }
            else if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isAttributeByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isAttributeByStruct) {
            return false;
        }
        else if (isAttributeByParams) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(param.semantic)) {
                return false;
            }
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
function checkArgumentsForPixelUsage(funcDef) {
    let params = funcDef.params;
    let isVaryingsByStruct = false;
    let isVaryingsByParams = false;
    let isStartAnalyze = false;
    for (let i = 0; i < params.length; i++) {
        let param = params[i];
        if (param.type.isUniform()) {
            continue;
        }
        if (!isStartAnalyze) {
            if (param.semantic === "") {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(param.type) ||
                    param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics()) {
                    // todo: check that there are no samplers in properties
                    return false;
                }
                isVaryingsByStruct = true;
            }
            else if (param.semantic !== "") {
                // todo: check that there are no samplers in properties
                if (param.type.isComplex() &&
                    (param.type.hasFieldWithoutSemantics() ||
                        !param.type.hasAllUniqueSemantics())) {
                    return false;
                }
                isVaryingsByParams = true;
            }
            isStartAnalyze = true;
        }
        else if (isVaryingsByStruct) {
            return false;
        }
        else if (isVaryingsByParams) {
            if (param.semantic === "") {
                // todo: emit warning
                // return false;
            }
            // todo: check that there are no samplers in properties
            if (param.type.isComplex() &&
                (param.type.hasFieldWithoutSemantics() ||
                    !param.type.hasAllUniqueSemantics())) {
                return false;
            }
        }
    }
    return true;
}
class Context {
    constructor(uri, expressions) {
        this.diagnostics = new _lib_fx_AnalyzerDiagnostics__WEBPACK_IMPORTED_MODULE_8__.AnalyzerDiagnostics;
        this.uri = uri;
        this.moduleName = null;
        this.haveCurrentFunctionReturnOccur = false;
        this.expressions = expressions || {};
    }
    beginCbuffer() { this.cbuffer = true; }
    endCbuffer() { this.cbuffer = false; }
    beginFunc() {
        this.func = true;
        this.haveCurrentFunctionReturnOccur = false;
        this.funcDef = null; // << will be set inside analyzeFunctionDecl();
    }
    endFunc() {
        this.func = false;
    }
    beginPass() {
        this.renderStates = null;
    }
    endPass() {
        this.renderStates = null;
    }
    error(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.error(code, { file, loc, info });
    }
    critical(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.critical(code, { file, loc, info });
    }
    warn(sourceNode, code, info = {}) {
        let loc = this.resolveNodeSourceLocation(sourceNode);
        let file = this.uri;
        this.diagnostics.warning(code, { file, loc, info });
    }
    resolveNodeSourceLocation(sourceNode) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(sourceNode)) {
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(sourceNode.loc)) {
            return sourceNode.loc;
        }
        return this.resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);
    }
}
class Analyzer {
    analyzeUseDecl(context, program, sourceNode) {
        program.currentScope.strictMode = true;
    }
    analyzeComplexName(sourceNode) {
        const children = sourceNode.children;
        let name = '';
        for (let i = children.length - 1; i >= 0; i--) {
            name += children[i].value;
        }
        return name;
    }
    /**
     * AST example:
     *    ProvideDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_PROVIDE = 'provide'
     */
    analyzeProvideDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (children.length === 3) {
            let moduleName = this.analyzeComplexName(children[1]);
            ;
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(context.moduleName)) {
                console.warn(`Context module overriding detected '${context.moduleName}' => '${module}'`);
            }
            context.moduleName = moduleName;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(children[2].name === 'T_KW_PROVIDE');
            return new _instructions_ProvideInstruction__WEBPACK_IMPORTED_MODULE_48__.ProvideInstruction({ sourceNode, moduleName, scope });
        }
        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedProvideAs);
        return null;
    }
    /**
     * AST example:
     *    InitExpr
     *         T_UINT = '0'
     *    InitExpr
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeInitExprChildren(context, program, sourceNode, children, expectedType, exprSourceNode = null) {
        const scope = program.currentScope;
        // raw value like "int a = 1"
        if (children.length === 1) {
            const initExpr = this.analyzeExpr(context, program, children[0]);
            if (!initExpr) {
                return null;
            }
            // NOTE: exprSourceNode => source node of the whole expression like "const float name = value" for better error highlighting.
            //                                                                               ^^^^^^^^^^^^
            //       sourceNode => source node of the init expr: const float3 name = { 1, 2, 3 };
            //                                                                    ^^^^^^^^^^^^^
            //       sourceNode => source node of the init expr: const float3[1] name = { { 1, 2, 3 } };
            //                                                                            ^^^^^^^^^^^
            const resType = Analyzer.checkTwoOperandExprTypes(context, '=', expectedType, initExpr.type, sourceNode /* Use correct source node! */, initExpr.sourceNode, exprSourceNode || sourceNode, { isInitializing: true });
            if (!resType) {
                // omit error, all errors must be already fired above (inside checkTwoOperandExprTypes)
                return null;
            }
            ////////////////////////////////////////////////
            // IP: quick hack to avoid future conversions
            ////////////////////////////////////////////////
            // cast uint <=> int constant if possible
            // if (initExpr.instructionType === EInstructionTypes.k_IntExpr && !types.equals(initExpr.type, expectedType)) {
            //     let { scope, sourceNode, base, exp, signed, heximal } = <IntInstruction>initExpr;
            //     signed = expectedType.name === 'int';
            //     return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
            // }
            // if (!types.equals(initExpr.type, expectedType)) {
            //     return new CastExprInstruction({scope, sourceNode, sourceExpr: initExpr, type: expectedType});
            // }
            ////////////////////////////////////////////////
            ////////////////////////////////////////////////
            return initExpr;
        }
        // It's a global user defined array or just not unit array;
        // Trying to exclude types like float1.
        else if ((expectedType.isNotBaseArray() && expectedType.scope.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global) ||
            expectedType.isArray()) {
            const args = [];
            const numArgs = (children.length - 1) / 2;
            if (expectedType.length === _helpers__WEBPACK_IMPORTED_MODULE_10__.instruction.UNDEFINE_LENGTH ||
                (expectedType.isNotBaseArray() && numArgs !== expectedType.length) ||
                (!expectedType.isNotBaseArray() && numArgs !== expectedType.baseType.length)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializingEx, {
                    tooltip: `attemp to init an array with invalid number of arguments. expected: ${expectedType.length}, given: ${numArgs}`
                });
                return null;
            }
            const arrayElementType = expectedType.arrayElementType;
            /**
             * AST example:
             *    InitExpr
             *         T_PUNCTUATOR_125 = '}'
             *       + InitExpr
             *         T_PUNCTUATOR_44 = ','
             *       + InitExpr
             *         T_PUNCTUATOR_123 = '{'
             */
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].name === 'InitExpr') {
                    const initExpr = this.analyzeInitExpr(context, program, children[i], arrayElementType);
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(initExpr)) {
                        // omit error because it was already produced by the call above
                        return null;
                    }
                    args.push(initExpr);
                }
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(expectedType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableType);
            return new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__.InitExprInstruction({ scope, sourceNode, args, type: expectedType });
        }
        else if (expectedType.isComplex()) {
            const numArgs = (children.length - 1) / 2;
            const fieldNameList = expectedType.fields.map(f => f.name);
            const args = [];
            if (numArgs !== fieldNameList.length) {
                // TODO: emit error (invalid number of arguments)
                return null;
            }
            /**
             * AST example:
             *    InitExpr
             *         T_PUNCTUATOR_125 = '}'
             *       + InitExpr
             *         T_PUNCTUATOR_44 = ','
             *       + InitExpr
             *         T_PUNCTUATOR_123 = '{'
             */
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].name === 'InitExpr') {
                    const fieldType = expectedType.getField(fieldNameList[i]).type;
                    const initExpr = this.analyzeInitExpr(context, program, children[i], fieldType);
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(initExpr)) {
                        // omit error because it was already produced by the call above
                        return null;
                    }
                    args.push(initExpr);
                }
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(expectedType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableType);
            return new _instructions_InitExprInstruction__WEBPACK_IMPORTED_MODULE_36__.InitExprInstruction({ scope, sourceNode, args, type: expectedType });
        }
        else {
            const numArgs = (children.length - 1) / 2;
            // handle cases like: int a = { 1 };
            if (numArgs !== 1) {
                // TODO: emit error (invalid number of arguments)
                return null;
            }
            const exprNode = children[children.length - 2];
            let initExpr = null;
            if (exprNode.name === 'InitExpr')
                initExpr = this.analyzeInitExpr(context, program, exprNode, expectedType);
            else
                initExpr = this.analyzeExpr(context, program, children[children.length - 2]);
            // TODO: use checkTwoOperandTypes() function instead
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expectedType, initExpr.type)) {
                // TODO: emit error
                return null;
            }
            return initExpr;
        }
        return null;
    }
    /**
     * AST example:
     *    InitExpr
     *         T_UINT = '0'
     *    InitExpr
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeInitExpr(context, program, sourceNode, expectedType) {
        return this.analyzeInitExprChildren(context, program, sourceNode, sourceNode.children, expectedType);
    }
    /**
     * AST example:
     *    SamplerStateDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + StateBlock
     *         T_NON_TYPE_ID = 'MeshTextureSampler'
     *         T_KW_SAMPLER_STATE = 'SamplerState'
     */
    /** @deprecated */
    analyzeSamplerStateDecl(context, program, sourceNode) {
        return null;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeVariableDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const generalType = this.analyzeUsageType(context, program, children[children.length - 1]);
        const vars = [];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(generalType)) {
            return null;
        }
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars.push(this.analyzeVariable(context, program, children[i], generalType));
            }
        }
        return vars;
    }
    /**
     * AST example:
     *    UsageType
     *       + Type
     *       + Usage
     */
    analyzeUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        let usagesRaw = [];
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                // basically, just get type from scope
                type = this.analyzeType(context, program, children[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'Usage') {
                usagesRaw.push(this.analyzeUsage(children[i]));
            }
        }
        const usageIn = usagesRaw.includes('in');
        const usageOut = usagesRaw.includes('out');
        const usageInout = usagesRaw.includes('inout');
        const usageConst = usagesRaw.includes('const');
        const usageUniform = usagesRaw.includes('uniform');
        const usageUnsigned = usagesRaw.includes('unsigned');
        const usageStatic = usagesRaw.includes('static');
        // TODO: emit errors in case of inconsistent usages
        // TODO: remplace with bitflags
        let usages = [];
        if (usageInout) {
            usages.push('inout');
            // emit error in case of uniform
            // emit error in case of const
        }
        else {
            if (usageIn && usageOut) {
                usages.push('inout');
                // emit error in case of uniform
                // emit error in case of const
            }
            else {
                if (usageIn) {
                    usages.push('in');
                }
                if (usageOut) {
                    usages.push('out');
                    // emit error in case of const
                    // emit error in case of uniform
                }
                else {
                    if (usageConst)
                        usages.push('const');
                    if (usageUniform)
                        usages.push('uniform');
                }
            }
        }
        if (usageStatic) {
            usages.push('static');
        }
        if (usageUnsigned && !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(type)) {
            console.error('invalid unsigned usage');
        }
        // wrap type with usages
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, type, usages });
    }
    /**
     * AST example:
     *    Type
     *         T_TYPE_ID = 'float3'
     */
    analyzeType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        switch (sourceNode.name) {
            case 'T_TYPE_ID':
                if (sourceNode.value === 'auto') {
                    type = new _instructions_ProxyTypeInstruction__WEBPACK_IMPORTED_MODULE_49__.ProxyTypeInstruction({ scope });
                    break;
                }
                type = scope.findType(sourceNode.value);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameNotType, { typeName: sourceNode.value });
                }
                break;
            case 'Struct':
                type = this.analyzeStruct(context, program, sourceNode);
                break;
            case 'T_KW_VOID':
                type = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID;
                break;
            case 'ScalarType':
            case 'ObjectType':
                {
                    let typeName = children[children.length - 1].value;
                    if (children.length !== 1) {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(children[children.length - 2].value === '<' && children[0].value === '>');
                        const tplName = typeName;
                        const args = children
                            .slice(1, -2)
                            .reverse()
                            .filter((v, i) => i % 2 == 0)
                            .map(sourceNode => this.analyzeType(context, program, sourceNode));
                        const template = scope.findTypeTemplate(typeName);
                        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(template)) {
                            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameTemplateNotFound, { tplName, args: args.map(arg => arg.toCode()) });
                            return null;
                        }
                        // TODO: validate register
                        // TODO: use ESystemTypes enumeration
                        const SYSTEM_TYPES = [
                            'Buffer',
                            'RWBuffer',
                            'RWStructuredBuffer',
                            'AppendStructuredBuffer',
                            'RWTexture1D',
                            'RWTexture2D',
                            'RWTexture3D',
                            'Texture1D',
                            'Texture2D',
                            'Texture3D',
                            'Texture2DArray',
                            'TextureCubeArray',
                        ];
                        if (SYSTEM_TYPES.indexOf(template.name) !== -1) {
                            if (scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeScope, { typeName: template.name, tooltip: 'only global scope allowed' });
                                return null;
                            }
                        }
                        typeName = template.typeName(args);
                        type = scope.findType(typeName);
                        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                            type = template.produceType(scope, args);
                            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotProduceType, { typeName });
                                return null;
                            }
                            scope.addType(type);
                        }
                    }
                    else {
                        type = scope.findType(typeName);
                    }
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                        context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeNameNotType, { typeName });
                        return null;
                    }
                }
                break;
            case 'VectorType':
            case 'MatrixType':
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeVectorMatrix);
                break;
            case 'BaseType':
            case 'Type':
                return this.analyzeType(context, program, children[0]);
        }
        return type;
    }
    analyzeUsage(sourceNode) {
        sourceNode = sourceNode.children[0];
        const supportedUsages = ['uniform', 'const', 'in', 'out', 'inout', 'static', 'unsigned', 'precise', 'inline'];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(supportedUsages.indexOf(sourceNode.value) !== -1, sourceNode.value);
        return sourceNode.value;
    }
    /**
     * AST example:
     *    CbufferDecl
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_125 = '}'
     *       + VarStructDecl
     *         T_PUNCTUATOR_123 = '{'
     *       + Annotation
     *       + Semantic
     *         T_NON_TYPE_ID = 'NAME'
     *         T_KW_CBUFFER = 'cbuffer'
     *
     * AST example:
     *    CbufferDecl
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_125 = '}'
     *       + VarStructDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_KW_CBUFFER = 'cbuffer'
     */
    analyzeCbufferDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = '';
        let id = null;
        context.beginCbuffer();
        let ic = children.length - 2;
        if (children[ic].name === 'T_NON_TYPE_ID') {
            id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode: children[ic], name: children[ic].value });
            ic--;
        }
        if (children[ic].name === 'Semantic') {
            semantic = this.analyzeSemantic(children[ic]);
            const match = semantic.match(/^register\(([utbs]{1})([\d]+)\)$/);
            if (match) {
                const rtype = match[1];
                if (rtype !== 'b') {
                    context.warn(children[ic], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.InvalidCbufferRegister);
                }
            }
            ic--;
        }
        if (children[ic].name === 'Annotation') {
            annotation = this.analyzeAnnotation(context, program, children[ic]);
            ic--;
        }
        ic--;
        // program.push(EScopeType.k_Cbuffer);
        let fields = [];
        for (let i = ic; i >= 2; i--) {
            switch (children[i].name) {
                case 'VariableDecl':
                    fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
                    break;
                case 'VarStructDecl':
                    fields = fields.concat(this.analyzeVarStructDecl(context, program, children[i]));
                    break;
                default:
                    context.error(children[i], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, {});
            }
        }
        // program.pop();
        context.endCbuffer();
        const aligment = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4.size; // float4 aligment!
        const name = id.name;
        const type = new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, name, fields, aligment });
        {
            let isAdded = scope.addType(type);
            if (!isAdded) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TypeRedefinition, { typeName: name });
            }
        }
        const cbuf = new _instructions_CbufferInstruction__WEBPACK_IMPORTED_MODULE_19__.CbufferInstruction({ id, type, sourceNode, semantic, annotation, scope });
        {
            let isAdded = scope.addCbuffer(cbuf);
            if (!isAdded) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CbufferRedefinition, { typeName: name });
            }
        }
        return cbuf;
    }
    /**
     * AST example:
     *    Variable
     *       + Initializer
     *       + Semantic
     *       + VariableDim
     *              T_PUNCTUATOR_93 = ']'
     *              T_NON_TYPE_ID = 'N'
     *              T_PUNCTUATOR_91 = '['
     *            + VariableDim
     *                   T_NON_TYPE_ID = 'x'
     *                   ^^^^^^^^^^^^^^^^^^
     */
    analyzeVariable(context, program, sourceNode, generalType) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let annotation = null;
        let init = null;
        let semantic = '';
        let usageFlags = 0;
        if (!context.func) {
            if (scope.type !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Global;
            }
            if (context.cbuffer) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Cbuffer;
            }
        }
        else {
            // All variables found inside function definition are arguments.
            if (!context.funcDef) {
                usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Argument;
            }
            usageFlags |= _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Local;
        }
        let id = null;
        let arrayIndex = null;
        let type = null;
        let vdimNode = children[children.length - 1];
        do {
            let vdimChildren = vdimNode.children;
            if (vdimChildren.length === 1) {
                const name = vdimChildren[0].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
                break;
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(vdimChildren.length == 4);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(arrayIndex)) {
                // usage of generalType.source node instead of sourceNode was done for more clear debugging
                generalType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
            }
            arrayIndex = this.analyzeExpr(context, program, vdimChildren[vdimChildren.length - 3]);
            vdimNode = vdimChildren[vdimChildren.length - 1];
        } while (true);
        // using generalType.source node instead of sourceNode was done for more clear debugging
        type = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode: generalType.sourceNode, type: generalType, arrayIndex });
        /**
         * (state block initializer)
         * AST example:
         *    Initializer
         *       + StateBlock
         */
        /**
         * (list initializer)
         * AST example:
         *    Initializer
         *         T_UINT = '1'
         *         T_PUNCTUATOR_61 = '='
         */
        const doInitUsingList = (sourceNode) => sourceNode.children[sourceNode.children.length - 1]?.value == '=';
        for (let i = children.length - 2; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else if (children[i].name === 'Initializer') {
                if (doInitUsingList(children[i])) {
                    init = this.analyzeInitializer(context, program, children[i], type, sourceNode);
                }
                else {
                    init = this.analyzeStateBlock(context, program, children[i].children[0], type);
                }
                switch (type.name) {
                    case 'BlendState':
                    case 'SamplerState':
                    case 'SamplerComparisonState':
                    case 'DepthStencilState':
                    case 'RasterizerState':
                        // todo: validate properties
                        console.assert(!doInitUsingList(children[i]));
                        console.assert(!type.isNotBaseArray() || type.length == init.blocks.length);
                        break;
                    default:
                        console.assert(doInitUsingList(children[i]));
                }
                if (!init) {
                    // TODO: make it warning
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidVariableInitializing, { varName: id.name });
                }
            }
        }
        const varDecl = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({ sourceNode, scope, type, init, id, semantic, annotation, usageFlags });
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(scope.type != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_System);
        if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.hasVariable(varDecl.name)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.SystemVariableRedefinition, { varName: varDecl.name });
        }
        const isAdded = scope.addVariable(varDecl);
        if (!isAdded) {
            switch (scope.type) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Global:
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.VariableRedefinition, { varName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidNewFieldForStructName, { fieldName: varDecl.name });
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Annotation:
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidNewAnnotationVar, { varName: varDecl.name });
                    break;
            }
        }
        return varDecl;
    }
    /**
     * AST example:
     *    AnnotationDecls
     *       + AnnotationDecls
     *       + VariableDecl
     */
    analyzeAnnotationDecls(context, program, sourceNode) {
        const children = sourceNode.children;
        let decls = [];
        for (let i = children.length - 1; i >= 0; i--) {
            switch (children[i].name) {
                case 'AnnotationDecls':
                    decls.push(...this.analyzeAnnotationDecls(context, program, children[i]));
                    break;
                case 'VariableDecl':
                    decls.push(...this.analyzeVariableDecl(context, program, children[i]));
                    break;
            }
        }
        return decls;
    }
    /**
     * AST example:
     *    Annotation
     *         T_PUNCTUATOR_62 = '>'
     *         T_PUNCTUATOR_60 = '<'
     */
    analyzeAnnotation(context, $program, sourceNode) {
        // IP: hucky way to not add annotation variables to real scope
        const program = new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScope(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        const scope = program.currentScope;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Annotation);
        const decls = [
            ...sourceNode.children.filter(node => node.name == 'AnnotationDecls').map(node => this.analyzeAnnotationDecls(context, program, node)).flat(),
            ...sourceNode.children.filter(node => node.name == 'VariableDecl').map(node => this.analyzeVariableDecl(context, program, node)).flat()
        ];
        program.pop();
        if (!decls || !decls.length)
            return null;
        return new _instructions_AnnotationInstruction__WEBPACK_IMPORTED_MODULE_11__.AnnotationInstruction({ scope, sourceNode, decls });
    }
    /**
     * AST example:
     *    Semantic
     *         T_NON_TYPE_ID = 'SEMANTIC'
     *         T_PUNCTUATOR_58 = ':'
     */
    /**
     * AST example:
     *    Semantic
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'u2'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_REGISTER = 'register'
     *         T_PUNCTUATOR_58 = ':'
     */
    analyzeSemantic(sourceNode) {
        return sourceNode.children.slice(0, -1).reverse().map(child => child.value).join('');
    }
    /**
     * AST example:
     *    Initializer
     *         T_UINT = '10'
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *       + CastExpr
     *         T_PUNCTUATOR_61 = '='
     *    Initializer
     *         T_PUNCTUATOR_125 = '}'
     *       + InitExpr
     *         T_PUNCTUATOR_44 = ','
     *       + InitExpr
     *         T_PUNCTUATOR_123 = '{'
     *         T_PUNCTUATOR_61 = '='
     */
    analyzeInitializer(context, program, sourceNode, expectedType, exprSourceNode = null) {
        const children = sourceNode.children;
        // IP: hacky varification to be sure that it's not a 
        if (children[children.length - 1]?.value == '=') {
            console.assert(children[children.length - 1].name === 'T_PUNCTUATOR_61');
            return this.analyzeInitExprChildren(context, program, sourceNode, children.slice(0, -1), expectedType, exprSourceNode);
        }
        console.assert(false, 'not valid branch');
        return null;
    }
    analyzeExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        switch (name) {
            case 'ObjectExpr':
                return this.analyzeObjectExpr(context, program, sourceNode);
            case 'ComplexExpr':
                return this.analyzeComplexExpr(context, program, sourceNode);
            case 'PostfixExpr':
                return this.analyzePostfixExpr(context, program, sourceNode);
            case 'UnaryExpr':
                return this.analyzeUnaryExpr(context, program, sourceNode);
            case 'CastExpr':
                return this.analyzeCastExpr(context, program, sourceNode);
            case 'ConditionalExpr':
                return this.analyzeConditionalExpr(context, program, sourceNode);
            case 'MulExpr':
            case 'AddExpr':
                return this.analyzeArithmeticExpr(context, program, sourceNode);
            case 'RelationalExpr':
            case 'EqualityExpr':
                return this.analyzeRelationExpr(context, program, sourceNode);
            case 'LogicalAndExpr':
            case 'LogicalOrExpr':
                return this.analyzeLogicalExpr(context, program, sourceNode);
            case 'AssignmentExpr':
                return this.analyzeAssignmentExpr(context, program, sourceNode);
            case 'AndExpr':
            case 'ShiftExpr':
            case 'InclusiveOrExpr':
            case 'ExclusiveOrExpr':
                return this.analyzeBitwiseExpr(context, program, sourceNode);
            case 'T_NON_TYPE_ID':
                return this.analyzeIdExpr(context, program, sourceNode);
            case 'T_STRING':
            case 'T_UINT':
            case 'T_FLOAT':
            case 'T_KW_TRUE':
            case 'T_KW_FALSE':
                return this.analyzeSimpleExpr(context, program, sourceNode);
            default:
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedExpr, { exprName: name });
                break;
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *       + StateBlock
     *         T_KW_SAMPLER_STATE = 'sampler_state'
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'fs_skybox'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeObjectExpr(context, program, sourceNode) {
        let name = sourceNode.children[sourceNode.children.length - 1].name;
        switch (name) {
            /** @deprecated */
            case 'T_KW_COMPILE':
                return this.analyzeCompileExpr(context, program, sourceNode);
            case 'T_KW_COMPILE_SHADER':
                return this.analyzeCompileShader11(context, program, sourceNode);
                return null;
            default:
        }
        return null;
    }
    /**
     * AST example:
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *       + ComplexExpr
     *         T_PUNCTUATOR_44 = ','
     *         T_NON_TYPE_ID = 'vs_4_0_level_9_1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_COMPILE_SHADER = 'CompileShader'
     */
    analyzeCompileShader11(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        // CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )
        const shaderNode = children[1]; // RenderSceneVS( 1, true, true )
        const versionNode = children[3]; // vs_4_0_level_9_1
        const ver = versionNode.value;
        const entryNode = shaderNode.children[shaderNode.children.length - 1]; // RenderSceneVS
        const funcName = entryNode.value;
        const args = [];
        for (let i = shaderNode.children.length - 3; i > 0; i--) {
            if (shaderNode.children[i].value !== ',') {
                args.push(this.analyzeExpr(context, program, shaderNode.children[i]));
            }
        }
        //findFunction(funcName, args);
        const func = program.globalScope.functions[funcName][0]; // todo: get suitable?
        const shaderType = ver.substring(0, 2);
        const sh = {
            'vs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VERTEX_SHADER,
            'ps': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_PIXEL_SHADER,
            'gs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_GEOMETRY_SHADER,
            'cs': _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_COMPUTE_SHADER
        };
        const type = sh[shaderType];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(type), `unknown shader type '${shaderType} (${ver})' has been used`);
        return new _instructions_CompileShader11Instruction__WEBPACK_IMPORTED_MODULE_21__.CompileShader11Instruction({ scope, sourceNode, ver, args, func, type });
    }
    /**
     * AST example:
     *    ObjectExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'main'
     *         T_KW_COMPILE = 'compile'
     */
    analyzeCompileExpr(context, program, sourceNode, validators) {
        const children = sourceNode.children;
        const shaderFuncName = children[children.length - 2].value;
        const scope = program.currentScope;
        let compileArgs = null;
        let retType = null;
        let args = null;
        if (children.length > 4) {
            compileArgs = [];
            for (let i = children.length - 4; i > 0; i--) {
                if (children[i].value !== ',') {
                    compileArgs.push(this.analyzeExpr(context, program, children[i]));
                }
            }
        }
        args = compileArgs ? compileArgs.map(asType) : null;
        let func = null;
        if (validators) {
            for (let validator of validators) {
                args = compileArgs ? compileArgs.map(asType) : null;
                retType = null;
                args = validator.args || args;
                retType = validator.ret || retType;
                func = program.globalScope.findFunction(shaderFuncName, args);
                if (func) {
                    // skip function if validator is not suitable
                    if (validator.ret && !_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(validator.ret, func.def.returnType)) {
                        // skip this function
                        continue;
                    }
                    break;
                }
            }
        }
        else {
            func = program.globalScope.findFunction(shaderFuncName, args);
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCompileNotFunction, { funcName: shaderFuncName });
            return null;
        }
        if (retType) {
            // show error if we found some variant of function but return type mismath
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(func.def.returnType, retType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCompileFunctionNotValid, {
                    funcName: shaderFuncName,
                    funcType: retType.toCode(),
                    tooltip: `Return type mismatch: expected '${retType.toCode()}' a is a '${func.def.returnType.toCode()}' `
                });
                return null;
            }
        }
        let type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(func.def.returnType, scope);
        return new _instructions_CompileExprInstruction__WEBPACK_IMPORTED_MODULE_20__.CompileExprInstruction({ args: compileArgs, scope, type, operand: func, sourceNode });
    }
    // /**
    //  * AST example:
    //  *    ObjectExpr
    //  *       + StateBlock 
    //  *         T_KW_SAMPLER_STATE = 'sampler_state'
    //  */
    // protected analyzeSamplerStateBlock(context: Context, program: ProgramScope, sourceNode: IParseNode): IExprInstruction {
    //     sourceNode = sourceNode.children[0];
    //     let scope = program.currentScope;
    //     let children = sourceNode.children;
    //     let operator: SamplerOperator = "sampler_state";
    //     let texture = null;
    //     let params = <ISamplerStateInstruction[]>[];
    //     for (let i = children.length - 2; i >= 1; i--) {
    //         let param = this.analyzeSamplerState(context, program, children[i]);
    //         if (!isNull(param)) {
    //             params.push(param);
    //         }
    //     }
    //     return new SamplerStateBlockInstruction({ sourceNode, scope, operator, params });
    // }
    // /**
    //  * AST example:
    //  *    State
    //  *         T_PUNCTUATOR_59 = ';'
    //  *         StateExpr
    //  *              T_PUNCTUATOR_62 = '>'
    //  *              T_NON_TYPE_ID = 'tex0'
    //  *              T_PUNCTUATOR_60 = '<'
    //  *         T_PUNCTUATOR_61 = '='
    //  *         T_NON_TYPE_ID = 'Texture'
    //  */
    // protected analyzeSamplerState(context: Context, program: ProgramScope, sourceNode: IParseNode): SamplerStateInstruction {
    //     const children = sourceNode.children;
    //     const scope = program.currentScope;
    //     if (children[children.length - 2].name === 'StateIndex') {
    //         context.error(sourceNode, EErrors.UnsupportedStateIndex);
    //         return null;
    //     }
    //     let stateExprNode = children[children.length - 3];
    //     let subStateExprNode = stateExprNode.children[stateExprNode.children.length - 1];
    //     let stateType = children[children.length - 1].value.toUpperCase();
    //     let stateValue = '';
    //     if (isNull(subStateExprNode.value)) {
    //         context.error(subStateExprNode, EErrors.InvalidSamplerTexture);
    //         return null;
    //     }
    //     switch (stateType) {
    //         case 'TEXTURE':
    //             if (stateExprNode.children.length !== 3 || subStateExprNode.value === '{') {
    //                 context.error(subStateExprNode, EErrors.InvalidSamplerTexture);
    //                 return null;
    //             }
    //             let texNameNode = stateExprNode.children[1];
    //             let texName = texNameNode.value;
    //             if (isNull(texName) || !scope.findVariable(texName)) {
    //                 context.error(stateExprNode.children[1], EErrors.InvalidSamplerTexture);
    //                 return null;
    //             }
    //             let texDecl = scope.findVariable(texName);
    //             let texId = new IdInstruction({ scope, sourceNode: texNameNode, name: texName });
    //             let tex = new IdExprInstruction({ scope, sourceNode: texNameNode, id: texId, decl: texDecl });
    //             return new SamplerStateInstruction({ scope, sourceNode, name: stateType, value: tex });
    //         case 'ADDRESSU': /* WRAP_S */
    //         case 'ADDRESSV': /* WRAP_T */
    //             stateValue = subStateExprNode.value.toUpperCase();
    //             switch (stateValue) {
    //                 case 'WRAP':
    //                 case 'CLAMP':
    //                 case 'MIRROR':
    //                     break;
    //                 default:
    //                     // TODO: move to errors
    //                     // console.warn('Webgl don`t support this wrapmode: ' + stateValue);
    //                     return null;
    //             }
    //             break;
    //         case 'MAGFILTER':
    //         case 'MINFILTER':
    //             stateValue = subStateExprNode.value.toUpperCase();
    //             switch (stateValue) {
    //                 case 'POINT':
    //                     stateValue = 'NEAREST';
    //                     break;
    //                 case 'POINT_MIPMAP_POINT':
    //                     stateValue = 'NEAREST_MIPMAP_NEAREST';
    //                     break;
    //                 case 'LINEAR_MIPMAP_POINT':
    //                     stateValue = 'LINEAR_MIPMAP_NEAREST';
    //                     break;
    //                 case 'POINT_MIPMAP_LINEAR':
    //                     stateValue = 'NEAREST_MIPMAP_LINEAR';
    //                     break;
    //                 case 'NEAREST':
    //                 case 'LINEAR':
    //                 case 'NEAREST_MIPMAP_NEAREST':
    //                 case 'LINEAR_MIPMAP_NEAREST':
    //                 case 'NEAREST_MIPMAP_LINEAR':
    //                 case 'LINEAR_MIPMAP_LINEAR':
    //                     break;
    //                 default:
    //                     // TODO: move to erros api
    //                     // console.warn('Webgl don`t support this texture filter: ' + stateValue);
    //                     return null;
    //             }
    //             break;
    //         default:
    //             // TODO: move to erros api
    //             console.warn('Don`t support this texture param: ' + stateType);
    //             return null;
    //     }
    //     return new SamplerStateInstruction({
    //         sourceNode,
    //         scope,
    //         name: stateType,
    //         value: new StringInstruction({ sourceNode: stateExprNode, scope, value: stateValue })
    //     });
    // }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_FLOAT = '2.'
     *         T_PUNCTUATOR_44 = ','
     *         T_FLOAT = '1.'
     *         T_PUNCTUATOR_40 = '('
     *         T_TYPE_ID = 'float4'
     */
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *       + PostfixPointExpr
     */
    analyzeComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'PostfixPointExpr':
            case 'T_NON_TYPE_ID':
                return this.analyzeFunctionCallExpr(context, program, sourceNode);
            case 'BaseType':
            case 'T_TYPE_ID':
                return this.analyzeConstructorCallExpr(context, program, sourceNode);
            default:
                return this.analyzeSimpleComplexExpr(context, program, sourceNode);
        }
    }
    analyzeCallee(context, program, sourceNode) {
        const children = sourceNode.children;
        return this.analyzeExpr(context, program, children[children.length - 1]);
    }
    createTracePseudoDeclaration(context, program, args) {
        const scope = program.globalScope; // global scope (!)
        const attrs = [new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__.AttributeInstruction({ scope, name: "extern", args: null })];
        const impl = null;
        const returnType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID, scope);
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: "trace" });
        const paramList = args.map((arg, i) => {
            // todo: fully deduce base type 
            const type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrapAsConst(arg.type.baseType, scope);
            const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: `p${i}` });
            const usageFlags = _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Argument | _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.EVariableUsageFlags.k_Local;
            return new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({ scope, type, id, usageFlags });
        });
        const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, returnType, id, paramList });
        const traceFunc = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ scope, def, impl, attrs });
        scope.addFunction(traceFunc);
        return traceFunc;
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_44 = ','
     *         T_NON_TYPE_ID = 'a'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'foo'
     */
    /**
     * AST example:
     *    PostfixPointExpr
     *         T_NON_TYPE_ID = 'IncrementCounter'
     *         T_PUNCTUATOR_46 = '.'
     *       + PostfixExpr
     */
    analyzeFunctionCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const firstNodeName = children[children.length - 1].name;
        let funcName = null;
        let func = null;
        let callee = null;
        let args = [];
        switch (firstNodeName) {
            // call as function
            case 'T_NON_TYPE_ID':
                {
                    // TODO: validate intrinsics like 'InterlockedAdd', check that dest is UAV address
                    funcName = children[children.length - 1].value;
                    if (children.length > 3) {
                        for (let i = children.length - 3; i > 0; i--) {
                            if (children[i].value !== ',') {
                                const arg = this.analyzeExpr(context, program, children[i]);
                                args.push(arg);
                            }
                        }
                    }
                    const noStrictTypeWereProvided = args.every(arg => arg?.type != asRelaxedType(arg));
                    // don't relax all types because it's useless
                    // like: (0, 0, 0) => (float|int, float|int)
                    // relax only uint => int if not strict types were provided 
                    func = globalScope.findFunction(funcName, args.map(arg => arg?.type || null));
                    // still not found?
                    if (!func) {
                        // last resort for cases like: "sqrt(2)"
                        func = globalScope.findFunction(funcName, args.map(asRelaxedType));
                    }
                    // special case for debug "void trace(...)" function
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func) && funcName === 'trace') {
                        func = this.createTracePseudoDeclaration(context, program, args);
                    }
                }
                break;
            // call as method
            case 'PostfixPointExpr':
                {
                    callee = this.analyzeCallee(context, program, children[children.length - 1]);
                    funcName = children[children.length - 1].children[0].value; // method name
                    if (children.length > 3) {
                        for (let i = children.length - 3; i > 0; i--) {
                            if (children[i].value !== ',') {
                                const arg = this.analyzeExpr(context, program, children[i]);
                                args.push(arg);
                            }
                        }
                    }
                    func = callee.type.getMethod(funcName, args.map(asRelaxedType));
                }
                break;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotFunction, { funcName, args: args.map(arg => _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(arg?.type)) });
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotChooseFunction, { funcName });
            return null;
        }
        if (args.includes(null)) {
            return null;
        }
        if (func.def.params.filter(p => !p.initExpr).length > args.length) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedExpr, { funcName });
            return null;
        }
        args.forEach((x, i) => {
            const param = func.def.params[i];
            const arg = args[i];
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(param.type, arg.type)) {
                context.warn(arg.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { info: `${arg.type.toCode()} => ${param.type.toCode()}` });
            }
        });
        if (func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FunctionDecl &&
            func.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemFunctionDecl) {
            console.error("@undefined_behavior");
            return null;
        }
        const params = func.def.params;
        for (let i = 0; i < args.length; i++) {
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(args[i])) {
                continue;
            }
            if (params[i].type.usages.includes('out')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(args[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidExprIsNotLValue);
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
                }
            }
            else if (params[i].type.usages.includes('inout')) {
                const decl = _helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(args[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidExprIsNotLValue);
                }
                if (!args[i].type.writable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
                }
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
            else {
                if (!args[i].type.readable) {
                    context.error(args[i].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
        }
        {
            const type = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(func.def.returnType, scope); // TODO: remove wrap?
            return new _instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_30__.FunctionCallInstruction({ scope, type, decl: func, args, sourceNode, callee });
        }
    }
    /**
     * AST example:
     *    ComplexExpr
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *       + BaseType
     */
    analyzeConstructorCallExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const ctorType = this.analyzeType(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(ctorType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotType);
            return null;
        }
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 3; i > 0; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeExpr(context, program, children[i]);
                    args.push(argumentExpr);
                }
            }
        }
        // TODO: add correct implementation! 
        const exprType = findConstructor(ctorType, args);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidComplexNotConstructor, { typeName: String(ctorType) });
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(args)) {
            for (let i = 0; i < args.length; i++) {
                if (!args[i] || !args[i].type.readable) {
                    context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
                }
            }
        }
        return new _instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_25__.ConstructorCallInstruction({ scope, sourceNode, ctor: exprType, args });
    }
    // TODO: add comment!
    analyzeSimpleComplexExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
            return null;
        }
        return new _instructions_ComplexExprInstruction__WEBPACK_IMPORTED_MODULE_22__.ComplexExprInstruction({ scope, sourceNode, expr });
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const symbol = children[children.length - 2].value;
        switch (symbol) {
            case '[':
                return this.analyzePostfixIndex(context, program, sourceNode);
            case '.':
                return this.analyzePostfixPoint(context, program, sourceNode);
            case '++':
            case '--':
                return this.analyzePostfixArithmetic(context, program, sourceNode);
        }
        return null;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_PUNCTUATOR_93 = ']'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_91 = '['
     *         T_NON_TYPE_ID = 'some'
     */
    analyzePostfixIndex(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const postfixExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(postfixExpr)) {
            // TODO: emit error?
            return null;
        }
        const postfixExprType = postfixExpr.type;
        if (!postfixExprType.isArray()) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotArray, { typeName: String(postfixExprType) });
            return null;
        }
        const indexExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const indexExprType = indexExpr.type;
        if (!(_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(indexExprType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT) || _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(indexExprType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_UINT))) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotIntIndex, { typeName: String(indexExprType) });
            return null;
        }
        return new _instructions_PostfixIndexInstruction__WEBPACK_IMPORTED_MODULE_44__.PostfixIndexInstruction({ scope, sourceNode, element: postfixExpr, index: indexExpr });
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     * @param fieldName
     */
    static createFieldDecl(elementType, fieldName) {
        if (!elementType.getField(fieldName)) {
            return null;
        }
        const decl = 
        // FIXME: remove 'logical OR' operation, always use subType
        (elementType.subType || elementType).getField(fieldName); // arrayIndex
        const { type } = decl;
        // in case of typical postfix exp. like "element.postfix":
        //      elementType => type derived from the parameter or variable declaration or derived from another expr
        //      elementType.subType => original complex (structure) type
        // in case of something else, like ccall with postfix "float2(1.0, 2.0).yx":
        //      elementType => original system type
        const fieldType = new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({
            scope: type.scope,
            sourceNode: type.sourceNode,
            type,
            readable: elementType.readable,
            writable: elementType.writable,
            /*aligment,*/
            padding: type.padding
        });
        const fieldId = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope: decl.scope, name: decl.id.name, sourceNode: decl.id.sourceNode });
        const field = new _instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_61__.VariableDeclInstruction({
            semantic: decl.semantic,
            scope: decl.scope,
            type: fieldType,
            sourceNode: decl.sourceNode,
            id: fieldId,
            usageFlags: decl.usageFlags
        });
        return _instructions_Instruction__WEBPACK_IMPORTED_MODULE_37__.Instruction.$withParent(field, elementType);
    }
    /**
     *
     * @param elementType Type of the element. (**element.postfix**)
     */
    analyzePostfixPointField(context, program, sourceNode, elementType) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(elementType)) {
            return null;
        }
        const scope = program.currentScope;
        const name = sourceNode.value; // fiedl name
        const decl = Analyzer.createFieldDecl(elementType, name); // field decl
        // const decl = elementType.getField(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
        return new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__.IdExprInstruction({ scope, sourceNode, id, decl });
        ;
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_NON_TYPE_ID = 'val'
     *         T_PUNCTUATOR_46 = '.'
     *         T_NON_TYPE_ID = 'some'
     */
    /**
     * Expressions like:
     *      **(element.postfix)**
     */
    analyzePostfixPoint(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const element = this.analyzeExpr(context, program, children[children.length - 1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(element)) {
            // TODO: emit error?
            return null;
        }
        const postfix = this.analyzePostfixPointField(context, program, children[children.length - 3], element.type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(postfix)) {
            const fieldName = children[children.length - 3].value;
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixNotField, { typeName: String(element.type), fieldName });
            return null;
        }
        return new _instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_45__.PostfixPointInstruction({ sourceNode, scope, element, postfix });
    }
    /**
     * AST example:
     *    PostfixExpr
     *         T_OP_INC = '++'
     *         T_NON_TYPE_ID = 'b'
     */
    analyzePostfixArithmetic(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[0].value;
        const postfixExpr = this.analyzeExpr(context, program, children[1]);
        const postfixExprType = postfixExpr.type;
        const exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, postfixExprType);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidPostfixArithmetic, {
                operator: operator,
                typeName: String(postfixExprType)
            });
            return null;
        }
        return new _instructions_PostfixArithmeticInstruction__WEBPACK_IMPORTED_MODULE_43__.PostfixArithmeticInstruction({ scope, sourceNode, operator, expr: postfixExpr });
    }
    /**
     * AST example:
     *    UnaryExpr
     *         T_NON_TYPE_ID = 'x'
     *         T_PUNCTUATOR_33 = '!'
     */
    analyzeUnaryExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const operator = children[1].value;
        const scope = program.currentScope;
        let expr = this.analyzeExpr(context, program, children[0]);
        let exprType = Analyzer.checkOneOperandExprType(context, sourceNode, operator, expr.type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidUnaryOperation, {
                operator: operator,
                tyename: String(expr.type)
            });
            return null;
        }
        let unaryExpr = null;
        // shortcut for replacment of unary expressions with literals
        if (operator === '-' || operator === '+') {
            if (_helpers__WEBPACK_IMPORTED_MODULE_10__.instruction.isLiteral(expr)) {
                switch (expr.instructionType) {
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_IntExpr:
                        {
                            let lit = expr;
                            let { base, signed, heximal, exp } = lit;
                            signed = operator === '-' || lit.signed;
                            // TODO: emit warning in case of '-100u' expr.
                            base = operator === '-' ? -base : base;
                            unaryExpr = new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
                        }
                        break;
                    case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FloatExpr:
                        unaryExpr = new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__.FloatInstruction({ scope, sourceNode, value: Number(`${operator}${expr.value}`) });
                }
            }
        }
        if (!unaryExpr) {
            unaryExpr = new _instructions_UnaryExprInstruction__WEBPACK_IMPORTED_MODULE_60__.UnaryExprInstruction({ scope, sourceNode, expr, operator });
        }
        return unaryExpr;
    }
    /**
     * AST example:
     *    CastExpr
     *         T_NON_TYPE_ID = 'y'
     *         T_PUNCTUATOR_41 = ')'
     *       + ConstType
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeCastExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const type = this.analyzeConstTypeDim(context, program, children[2]);
        if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBase(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastTypeNotBase, { typeName: String(type) });
        }
        const sourceExpr = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(sourceExpr)) {
            return null;
        }
        if (!sourceExpr.type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        return new _instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_18__.CastExprInstruction({ scope, sourceNode, sourceExpr, type });
    }
    /**
     * AST example:
     *    ConditionalExpr
     *         T_KW_FALSE = 'false'
     *         T_PUNCTUATOR_58 = ':'
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_63 = '?'
     *         T_NON_TYPE_ID = 'isOk'
     */
    analyzeConditionalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const conditionExpr = this.analyzeExpr(context, program, children[children.length - 1]);
        const leftExpr = this.analyzeExpr(context, program, children[children.length - 3]);
        const rightExpr = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(conditionExpr)) {
            context.error(children[children.length - 1], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(leftExpr)) {
            context.error(children[children.length - 3], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(rightExpr)) {
            context.error(children[0], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: '[unknown]' });
            return null;
        }
        const conditionType = conditionExpr.type;
        const leftExprType = leftExpr.type;
        const rightExprType = rightExpr.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
            context.error(conditionExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditionType, { typeName: String(conditionType) });
            return null;
        }
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftExprType, rightExprType)) {
            context.error(leftExprType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidConditonValueTypes, {
                leftTypeName: String(leftExprType),
                rightTypeName: String(rightExprType)
            });
            return null;
        }
        if (!conditionType.readable) {
            context.error(conditionExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${conditionExpr.toCode()}` });
        }
        if (!leftExprType.readable) {
            context.error(leftExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${leftExpr.toCode()}` });
        }
        if (!rightExprType.readable) {
            context.error(rightExpr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `${rightExpr.toCode()}` });
        }
        return new _instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_24__.ConditionalExprInstruction({ scope, sourceNode, cond: conditionExpr, left: leftExpr, right: rightExpr });
    }
    /**
     * AST example:
     *    AddExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_43 = '+'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeArithmeticExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        if (!left || !right) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: '[unknown]',
                rightTypeName: '[unknown]'
            });
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticOperation, {
                operator: operator,
                leftTypeName: String(leftType),
                rightTypeName: String(rightType)
            });
            return null;
        }
        return new _instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_12__.ArithmeticExprInstruction({ scope, sourceNode, left, right, operator, type });
    }
    /**
     * AST example:
     *    RelationalExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_PUNCTUATOR_60 = '<'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeRelationExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left && left.type;
        const rightType = right && right.type;
        const exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left && left.sourceNode, right && right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidRelationalOperation, {
                operator: operator,
                leftTypeName: leftType ? _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType) : '[unknown]',
                rightTypeName: rightType ? _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType) : '[unknown]'
            });
            return null;
        }
        if (!left || !right) {
            return null;
        }
        return new _instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_50__.RelationalExprInstruction({ sourceNode, scope, left, right, operator });
    }
    /**
     * AST example:
     *    LogicalOrExpr
     *         T_NON_TYPE_ID = 'b'
     *         T_OP_OR = '||'
     *         T_NON_TYPE_ID = 'a'
     */
    analyzeLogicalExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        const leftType = left.type;
        const rightType = right.type;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, boolType)) {
            context.error(leftType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLogicOperation, {
                operator: operator,
                typeName: String(leftType)
            });
            return null;
        }
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(rightType, boolType)) {
            context.error(rightType.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLogicOperation, {
                operator: operator,
                typeName: String(rightType)
            });
            return null;
        }
        if (!leftType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        if (!rightType.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        return new _instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_40__.LogicalExprInstruction({ scope, sourceNode, left, right, operator });
    }
    /**
     * AST example:
     *    InclusiveOrExpr
     *       + ComplexExpr
     *         T_PUNCTUATOR_124 = '|'
     *       + ComplexExpr
     */
    analyzeBitwiseExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = sourceNode.children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        const right = this.analyzeExpr(context, program, children[0]);
        if (!left || !right) {
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        const type = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidBitwiseOperation, {
                operator: operator,
                leftTypeName: String(leftType),
                rightTypeName: String(rightType)
            });
            return null;
        }
        return new _instructions_BitwiseExprInstruction__WEBPACK_IMPORTED_MODULE_15__.BitwiseExprInstruction({ scope, sourceNode, left, right, type, operator });
    }
    /**
     * AST example:
     *    AssignmentExpr
     *         T_UINT = '10'
     *         T_OP_AE = '+='
     *         T_NON_TYPE_ID = 'x'
     */
    analyzeAssignmentExpr(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        const left = this.analyzeExpr(context, program, children[children.length - 1]);
        if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.expression.unwind(left)) {
            // Invalid left-hand side in assignment
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidLeftHandSideInAssignment, {
                operator: operator
            });
        }
        const right = this.analyzeExpr(context, program, children[0]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(left) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(right)) {
            return null;
        }
        const leftType = left.type;
        const rightType = right.type;
        let exprType = null;
        if (operator !== '=') {
            exprType = Analyzer.checkTwoOperandExprTypes(context, operator, leftType, rightType, left.sourceNode, right.sourceNode, sourceNode);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidArithmeticAssigmentOperation, {
                    operator: operator,
                    leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType),
                    rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType)
                });
            }
        }
        else {
            exprType = rightType;
        }
        // FIXME: show corrent source nodes for left and right expression.
        exprType = Analyzer.checkTwoOperandExprTypes(context, '=', leftType, exprType, left.sourceNode, null, sourceNode);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprType)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidAssigmentOperation, {
                leftTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(leftType),
                rightTypeName: _helpers__WEBPACK_IMPORTED_MODULE_10__.types.signature(rightType)
            });
        }
        return new _instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_13__.AssignmentExprInstruction({ scope, sourceNode, left, right, operator });
    }
    /**
     * AST example:
     *    T_NON_TYPE_ID = 'name'
     */
    analyzeIdExpr(context, program, sourceNode) {
        const scope = program.currentScope;
        const name = sourceNode.value;
        // beginning-of-hack
        // hack to support pseudo-dynamic expression
        //
        const exprSubst = context.expressions[name];
        if (exprSubst) {
            return exprSubst(context, program, sourceNode);
        }
        // end-of-hack
        // explicit support of built in HLSL 'NULL' define
        if (name === 'NULL') {
            // const { base, signed, heximal, exp } = parseUintLiteral('0');
            // return new IntInstruction({ scope, sourceNode, base, exp, signed, heximal }); 
            return new _instructions_NullInstruction__WEBPACK_IMPORTED_MODULE_41__.NullInstruction({ scope, sourceNode });
        }
        const decl = scope.findVariable(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownVarName, { varName: name });
            return null;
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, sourceNode, name });
        return new _instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_33__.IdExprInstruction({ scope, sourceNode, id, decl });
    }
    analyzeSimpleExpr(context, program, sourceNode) {
        const name = sourceNode.name;
        const value = sourceNode.value;
        const scope = program.currentScope;
        switch (name) {
            case 'T_UINT':
                {
                    const { base, signed, heximal, exp } = (0,_system_utils__WEBPACK_IMPORTED_MODULE_65__.parseUintLiteral)(value);
                    return new _instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_39__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
                }
            case 'T_FLOAT':
                return new _instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_28__.FloatInstruction({ scope, sourceNode, value: Number(value) });
            case 'T_STRING':
                return new _instructions_StringInstruction__WEBPACK_IMPORTED_MODULE_55__.StringInstruction({ scope, sourceNode, value });
            case 'T_KW_TRUE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__.BoolInstruction({ scope, sourceNode, value: true });
            case 'T_KW_FALSE':
                return new _instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_16__.BoolInstruction({ scope, sourceNode, value: false });
        }
        return null;
    }
    /**
     * AST example:
     *    ConstType
     *       + Type
     */
    analyzeConstTypeDim(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length > 1) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastTypeUsage);
            return null;
        }
        const type = (this.analyzeType(context, program, children[0]));
        return type;
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *       + UsageType
     */
    analyzeVarStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        let usageType = this.analyzeUsageStructDecl(context, program, children[children.length - 1]);
        let vars = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'Variable') {
                vars = vars.concat(this.analyzeVariable(context, program, children[i], usageType));
            }
        }
        return vars;
    }
    analyzeUsageStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'StructDecl') {
                type = this.analyzeStructDecl(context, program, children[i]);
                const typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__.TypeDeclInstruction({ scope, sourceNode: children[i], type });
                addTypeDecl(context, scope, typeDecl);
            }
            else if (children[i].name === 'Usage') {
                const usage = this.analyzeUsage(children[i]);
                usages.push(usage);
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type));
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, usages, type });
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *       + VariableDecl
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     *    Struct
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStruct(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let name = null;
        if (children[children.length - 2].name === 'T_NON_TYPE_ID') {
            name = children[children.length - 2].value;
        }
        let fields = [];
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct);
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        let aligment = 1;
        if (context.cbuffer) {
            aligment = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_FLOAT4.size;
        }
        return new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, fields, name, aligment });
    }
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + FunctionDef
     */
    /**
     * AST example:
     *    FunctionDecl
     *       + StmtBlock
     *       + Annotation
     *       + FunctionDef
     */
    analyzeFunctionDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        const lastNodeValue = children[0].value;
        let annotation = null;
        let impl = null;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default);
        const attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        const def = this.analyzeFunctionDef(context, program, children[children.length - 1 - attrs.length]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(def)) {
            // TODO: emit proper error
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, {});
            program.pop();
            return null;
        }
        // looking for function with exact type signatures (that's why we cant use 'asRelaxedType' predicate here!)
        let func = globalScope.findFunction(def.name, def.params.map(asType));
        // undedined means that there are more than one instance 
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.CannotChooseFunction, { funcName: def.name });
            program.pop();
            return null;
        }
        // todo: handle the case when definition without implementation is occured later than the found function with implementation
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func) && func.impl) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedefinition, { funcName: def.name });
            program.pop();
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(func.def.returnType, def.returnType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFuncDefenitionReturnType, { funcName: def.name });
                program.pop();
                return null;
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(context.funcDef === null);
        // TODO: rewrite context ?
        context.funcDef = def;
        if (children.length === 3) {
            annotation = this.analyzeAnnotation(context, program, children[1]);
        }
        if (lastNodeValue !== ';') {
            // TODO: do to increase scope depth inside stmt block!!
            impl = this.analyzeStmtBlock(context, program, children[0]);
        }
        program.pop();
        let hasVoidType = _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(def.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID);
        // validate unreachable code.
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl)) {
            let stmtList = impl.stmtList;
            // stmtList = stmtList.slice().reverse();
            for (let i = stmtList.length - 1; i >= 0; --i) {
                if (stmtList[i].instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_ReturnStmt) {
                    if (i != stmtList.length - 1) {
                        context.error(stmtList[i + 1].sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnreachableCode);
                    }
                    break;
                }
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(scope == globalScope);
        func = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ sourceNode, scope, def, impl, annotation, attrs: attrs });
        // NOTE: possible implicit replacement of function 
        //       without implementaion inside addFunction() call.
        if (!globalScope.addFunction(func)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionRedifinition, { funcName: def.name });
        }
        if (!hasVoidType && !context.haveCurrentFunctionReturnOccur && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl)) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnStmtNotFound, { funcName: def.name });
        }
        return func;
    }
    /**
     * AST example:
     *    FunctionDef
     *       + ParamList
     *         T_NON_TYPE_ID = 'bar'
     *       + UsageType
     */
    analyzeFunctionDef(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nameNode = children[children.length - 2];
        const name = nameNode.value;
        const retTypeNode = children[children.length - 1];
        let returnType = this.analyzeUsageType(context, program, retTypeNode);
        // TODO: is it really needed?
        if (!returnType) {
            context.error(retTypeNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidFunctionReturnType, { funcName: name });
            return null;
        }
        let id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name, sourceNode: nameNode });
        let semantic = null;
        if (children.length === 4) {
            semantic = this.analyzeSemantic(children[0]);
        }
        let paramList = this.analyzeParamList(context, program, children[children.length - 3]);
        return new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, sourceNode, returnType, id, paramList, semantic });
    }
    /**
     * AST example:
     *    ParamList
     *         T_PUNCTUATOR_41 = ')'
     *       + ParameterDecl
     *         T_PUNCTUATOR_44 = ','
     *       + ParameterDecl
     *         T_PUNCTUATOR_40 = '('
     */
    analyzeParamList(context, program, sourceNode) {
        const children = sourceNode.children;
        let paramList = [];
        for (let i = children.length - 2; i >= 1; i--) {
            if (children[i].name === 'ParameterDecl') {
                let param = this.analyzeParameterDecl(context, program, children[i]);
                paramList.push(param);
            }
        }
        return paramList;
    }
    /**
     * AST example:
     *    ParameterDecl
     *       + Variable
     *       + ParamUsageType
     */
    analyzeParameterDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const type = this.analyzeParamUsageType(context, program, children[1]);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
            return null;
        }
        const param = this.analyzeVariable(context, program, children[0], type);
        return param;
    }
    /**
     * AST example:
     *    ParamUsageType
     *       + Type
     *       + ParamUsage
     */
    analyzeParamUsageType(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let usages = [];
        let type = null;
        for (let i = children.length - 1; i >= 0; i--) {
            if (children[i].name === 'Type') {
                type = this.analyzeType(context, program, children[i]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type)) {
                    return null;
                }
            }
            else if (children[i].name === 'ParamUsage') {
                usages.push(this.analyzeUsage(children[i]));
            }
        }
        return new _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction({ scope, sourceNode, type, usages });
    }
    /**
     * AST example:
     *    StmtBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + Stmt
     *       + Stmt
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeStmtBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (!children) {
            return null;
        }
        let stmtList = [];
        for (let i = children.length - 2; i > 0; i--) {
            let stmt = this.analyzeStmt(context, program, children[i]);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(stmt)) {
                stmtList.push(stmt);
            }
        }
        return new _instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_54__.StmtBlockInstruction({ sourceNode, scope, stmtList });
    }
    analyzeStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        let nonAttrNode = children.length;
        let nonAttrNodeName;
        do {
            nonAttrNodeName = children[--nonAttrNode].name;
        } while (nonAttrNodeName === 'Attribute');
        switch (nonAttrNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'UseDecl':
                this.analyzeUseDecl(context, program, children[0]);
                return null;
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
            case 'T_KW_IF':
                return this.analyzeIfStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_RETURN':
                return this.analyzeReturnStmt(context, program, sourceNode);
            case 'T_KW_DO':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'StmtBlock':
                {
                    program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Default);
                    let stmtBlock = this.analyzeStmtBlock(context, program, children[0]);
                    program.pop();
                    return stmtBlock;
                }
            case 'T_KW_DISCARD':
            case 'T_KW_BREAK':
            case 'T_KW_CONTINUE':
                return this.analyzeBreakStmt(context, program, sourceNode);
            case 'TypeDecl':
            case 'VariableDecl':
            case 'VarStructDecl':
                return this.analyzeDeclStmt(context, program, children[0]);
            default:
                if (children.length === 2) {
                    return this.analyzeExprStmt(context, program, sourceNode);
                }
                return new _instructions_SemicolonStmtInstruction__WEBPACK_IMPORTED_MODULE_52__.SemicolonStmtInstruction({ sourceNode, scope });
        }
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_NON_TYPE_ID = 'y'
     *         T_KW_RETURN = 'return'
     */
    analyzeReturnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(context.func);
        const funcReturnType = context.funcDef.returnType;
        context.haveCurrentFunctionReturnOccur = true;
        if (children.length === 2) {
            tryResolveProxyType(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID);
        }
        if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID) && children.length === 3) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtVoid);
            return null;
        }
        else if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(funcReturnType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID) && children.length === 2) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtEmpty);
            return null;
        }
        let expr = null;
        if (children.length === 3) {
            expr = this.analyzeExpr(context, program, children[1]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtTypesNotEqual);
                return null;
            }
            tryResolveProxyType(funcReturnType, expr.type); // auto foo() { return typedExpr; }
            tryResolveProxyType(expr.type, funcReturnType); // typedFunc foo() { return auto; }
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expr.type, funcReturnType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidReturnStmtTypesNotEqual);
                return null;
            }
        }
        return new _instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_51__.ReturnStmtInstruction({ sourceNode, scope, expr });
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_KW_BREAK = 'break'
     */
    analyzeBreakStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const operator = children[1].value;
        if (operator === 'discard' && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(context.funcDef)) {
            // context.currentFunction.vertex = (false);
        }
        return new _instructions_BreakStmtInstruction__WEBPACK_IMPORTED_MODULE_17__.BreakStmtInstruction({ sourceNode, scope, operator });
    }
    /**
     * AST example:
     *    VariableDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *         T_PUNCTUATOR_44 = ','
     *       + Variable
     *       + UsageType
     */
    analyzeDeclStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const nodeName = sourceNode.name;
        let declList = [];
        switch (nodeName) {
            case 'TypeDecl':
                declList.push(this.analyzeTypeDecl(context, program, sourceNode));
                break;
            case 'VariableDecl':
                declList = declList.concat(this.analyzeVariableDecl(context, program, sourceNode));
                break;
            case 'VarStructDecl':
                declList = declList.concat(this.analyzeVarStructDecl(context, program, sourceNode));
                break;
        }
        return new _instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_26__.DeclStmtInstruction({ sourceNode, scope, declList });
    }
    analyzeExprStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const expr = this.analyzeExpr(context, program, children[1]);
        return new _instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_27__.ExprStmtInstruction({ sourceNode, scope, expr });
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_WHILE = 'while'
     *       + Stmt
     *         T_KW_DO = 'do'
     */
    analyzeWhileStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isDoWhile = (children[children.length - 1].value === 'do');
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt') ? true : false;
        const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
        let cond = null;
        let conditionType = null;
        let body = null;
        let operator = "do";
        if (isDoWhile) {
            operator = "do";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidDoWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            body = this.analyzeStmt(context, program, children[0]);
        }
        else {
            operator = "while";
            cond = this.analyzeExpr(context, program, children[2]);
            conditionType = cond.type;
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(conditionType, boolType)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidWhileCondition, { typeName: String(conditionType) });
                return null;
            }
            if (isNonIfStmt) {
                body = this.analyzeNonIfStmt(context, program, children[0]);
            }
            else {
                body = this.analyzeStmt(context, program, children[0]);
            }
        }
        return new _instructions_WhileStmtInstruction__WEBPACK_IMPORTED_MODULE_63__.WhileStmtInstruction({ sourceNode, scope, cond, body, operator });
    }
    /**
     * AST example:
     *    Attribute
     *         T_PUNCTUATOR_93 = ']'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '3'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '2'
     *         T_PUNCTUATOR_44 = ','
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'loop'
     *         T_PUNCTUATOR_91 = '['
     */
    analyzeAttribute(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const name = children[children.length - 2].value;
        let args = null;
        if (children.length > 3) {
            let argumentExpr = null;
            args = [];
            for (let i = children.length - 4; i > 1; i--) {
                if (children[i].value !== ',') {
                    argumentExpr = this.analyzeSimpleExpr(context, program, children[i]);
                    // TODO: emit diagnostics error
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_BoolExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_FloatExpr ||
                        argumentExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_IntExpr);
                    args.push(argumentExpr);
                }
            }
        }
        return new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_14__.AttributeInstruction({ scope, sourceNode, name, args });
    }
    /**
     * AST example:
     *    Stmt
     *       + Stmt
     *         T_KW_ELSE = 'else'
     *       + NonIfStmt
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_IF = 'if'
     *       + Attribute
     *       + Attribute
     */
    analyzeIfStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        let attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        const isIfElse = (children.length - attrs.length === 7);
        const condNode = children[children.length - 3 - attrs.length];
        const cond = this.analyzeExpr(context, program, condNode);
        if (!cond || !_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(asRelaxedType(cond.type), _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL)) {
            context.error(condNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidIfCondition, { typeName: cond ? String(cond.type) : '[unknown]' });
        }
        else if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(cond.type, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL)) {
            context.warn(condNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${cond.type.name} => bool` });
        }
        let conseq = null;
        let contrary = null;
        if (isIfElse) {
            conseq = this.analyzeNonIfStmt(context, program, children[2]);
            contrary = this.analyzeStmt(context, program, children[0]);
        }
        else {
            conseq = this.analyzeNonIfStmt(context, program, children[0]);
        }
        if (!cond) {
            return null;
        }
        return new _instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_35__.IfStmtInstruction({ sourceNode, scope, cond, conseq, contrary, attrs: attrs });
    }
    /**
     * AST example:
     *    NonIfStmt
     *       + SimpleStmt
     */
    analyzeNonIfStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'SimpleStmt':
                return this.analyzeSimpleStmt(context, program, children[0]);
            case 'T_KW_WHILE':
                return this.analyzeWhileStmt(context, program, sourceNode);
            case 'T_KW_FOR':
                return this.analyzeForStmt(context, program, sourceNode);
        }
        return null;
    }
    analyzeForStmt(context, program, sourceNode) {
        const scope = program.currentScope;
        const children = sourceNode.children;
        const isNonIfStmt = (sourceNode.name === 'NonIfStmt');
        let body = null;
        let init = null;
        let cond = null;
        let step = null;
        let attrs = [];
        while (children[children.length - 1 - attrs.length].name === 'Attribute') {
            attrs.push(this.analyzeAttribute(context, program, children[children.length - 1 - attrs.length]));
        }
        if (children[1].name === 'ERROR') {
            return null;
        }
        program.push();
        const initSourceNode = children[children.length - 3 - attrs.length];
        const condSourceNode = children[children.length - 4 - attrs.length];
        init = this.analyzeForInit(context, program, initSourceNode);
        cond = this.analyzeForCond(context, program, condSourceNode);
        step = null;
        const isEmptyInit = initSourceNode.children[0].name == 'T_PUNCTUATOR_59';
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(init) && !isEmptyInit) {
            context.error(initSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForInitEmptyIterator);
        }
        else if (init.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_VariableDecl) {
            // EAnalyzerErrors.InvalidForInitExpr
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(cond)) {
            context.error(condSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForConditionEmpty);
        }
        else if (cond.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_RelationalExpr) {
            // EAnalyzerErrors.InvalidForConditionRelation
        }
        if (children.length === 7 + attrs.length) {
            step = this.analyzeForStep(context, program, children[2]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(step)) {
                context.error(children[2], _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidForStepEmpty);
            }
        }
        if (isNonIfStmt) {
            body = this.analyzeNonIfStmt(context, program, children[0]);
        }
        else {
            body = this.analyzeStmt(context, program, children[0]);
        }
        //     if (this._step.instructionType === EInstructionTypes.k_UnaryExpr ||
        //         this._step.instructionType === EInstructionTypes.k_AssignmentExpr ||
        //         this._step.instructionType === EInstructionTypes.k_PostfixArithmeticExpr) {
        //         // todo: rewrite this check!!
        //         // var sOperator: string = this._step.operator;
        //         // if (sOperator !== "++" && sOperator !== "--" &&
        //         //     sOperator !== "+=" && sOperator !== "-=") {
        //         //     this._setError(EAnalyzerErrors.BAD_FOR_STEP_OPERATOR, { operator: sOperator });
        //         //     return false;
        //         // }
        //     }
        //     else {
        //         this._setError(EAnalyzerErrors.InvalidForStepExpr);
        //         return false;
        //     }
        program.pop();
        return new _instructions_ForStmtInstruction__WEBPACK_IMPORTED_MODULE_29__.ForStmtInstruction({ sourceNode, scope, init, cond, step, body });
    }
    /**
     * AST example:
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + AssignmentExpr
     *    ForInit
     *       + VariableDecl
     *    ForInit
     *         T_PUNCTUATOR_59 = ';'
     *       + Expr
     */
    analyzeForInit(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'VariableDecl':
                // TODO: fixme!! 
                // add support for expressions like "a = 1, b = 2, c = 3"
                return this.analyzeVariableDecl(context, program, children[0])[0] || null;
            case 'Expr':
            case 'AssignmentExpr':
                return this.analyzeExpr(context, program, children[1]);
        }
        // ForInit : ';'
        return null;
    }
    /**
     * AST example:
     *    ForCond
     *         T_PUNCTUATOR_59 = ';'
     *       + RelationalExpr
     */
    analyzeForCond(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length === 1) {
            return null;
        }
        return this.analyzeExpr(context, program, children[1]);
    }
    /**
     * AST example:
     *    ForStep
     *       + UnaryExpr
     */
    analyzeForStep(context, program, sourceNode) {
        const children = sourceNode.children;
        if (children.length == 0) {
            return null;
        }
        const step = this.analyzeExpr(context, program, children[0]);
        return step;
    }
    analyzePresetProperty(context, program, sourceNode) {
        const children = sourceNode.children;
        const nameNode = children[children.length - 1];
        const propName = nameNode.value;
        const propExprNode = children[children.length - 3];
        const exprNode = propExprNode.children[propExprNode.children.length - 1];
        const scope = program.currentScope;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(propName)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            return null;
        }
        const decl = scope.findVariable(propName);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.PartFx_PresetPropertyHasNotBeenFound);
            return null;
        }
        const type = decl.type;
        /**
         * AST example:
         *    PassStateExpr
         *         T_PUNCTUATOR_125 = '}'
         *         T_UINT = '1'
         *         T_PUNCTUATOR_44 = ','
         *         T_KW_TRUE = 'true'
         *         T_PUNCTUATOR_123 = '{'
         */
        const args = [];
        if (exprNode.value === '{' && propExprNode.children.length > 3) {
            for (let i = propExprNode.children.length - 2; i >= 1; i -= 2) {
                const expr = this.analyzeExpr(context, program, propExprNode.children[i]);
                // todo: use more strict check same as for InitExpr analyze
                if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(expr.type, type.arrayElementType)) {
                    context.warn(propExprNode.children[i], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${expr.type.name} => ${type.arrayElementType.name}` });
                }
                args.push(expr);
            }
        }
        else {
            if (exprNode.value === '{') {
                args.push(this.analyzeExpr(context, program, propExprNode.children[1]));
            }
            else {
                args.push(this.analyzeExpr(context, program, exprNode));
            }
        }
        const id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ name: propName, scope, sourceNode: nameNode });
        return new _instructions_PresetProperty__WEBPACK_IMPORTED_MODULE_47__.PresetProperty({ scope, sourceNode, id, args });
    }
    analyzePresetStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let props = [];
        for (let i = children.length - 2; i >= 1; i--) {
            props.push(this.analyzePresetProperty(context, program, children[i]));
        }
        return props;
    }
    /**
     * AST example:
     *    PresetDecl
     *       + PassStateBlock
     *         T_NON_TYPE_ID = 'X'
     *         T_KW_PRESET = 'preset'
     */
    analyzePresetDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ sourceNode: children[i], scope, name });
            }
        }
        const props = this.analyzePresetStateBlock(context, program, children[0]);
        const preset = new _instructions_Preset__WEBPACK_IMPORTED_MODULE_46__.PresetInstruction({
            scope,
            sourceNode,
            id,
            props
        });
        return preset;
    }
    analyzeTechnique11Decl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let passes = null;
        let presets = null;
        for (let i = children.length - 3; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else {
                [passes] = this.analyzeTechnique11(context, program, children[i]);
            }
        }
        const technique = new _instructions_Technique11Instruction__WEBPACK_IMPORTED_MODULE_56__.Technique11Instruction({ sourceNode, name, semantic, annotation, passes, scope, presets });
        Analyzer.addTechnique11(context, program, technique);
        return technique;
    }
    /** @deprecated */
    analyzeTechniqueDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.Deprecated);
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let passes = null;
        let presets = null;
        let techniqueType = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.ETechniqueType.k_BasicFx;
        for (let i = children.length - 3; i >= 0; i--) {
            if (children[i].name === 'Annotation') {
                annotation = this.analyzeAnnotation(context, program, children[i]);
            }
            else if (children[i].name === 'Semantic') {
                semantic = this.analyzeSemantic(children[i]);
            }
            else {
                [passes, presets] = this.analyzeTechnique(context, program, children[i]);
            }
        }
        const technique = new _instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_57__.TechniqueInstruction({ sourceNode, name, techniqueType, semantic, annotation, passes, scope, presets });
        Analyzer.addTechnique(context, program, technique);
        return technique;
    }
    /**
     * AST example:
     *    TechniqueBody
     *         T_PUNCTUATOR_125 = '}'
     *       + PassDecl
     *       + PassDecl
     *         T_PUNCTUATOR_123 = '{'
     */
    /** @deprecated */
    analyzeTechnique(context, program, sourceNode) {
        const children = sourceNode.children;
        let passes = [];
        let presets = [];
        for (let i = children.length - 2; i >= 1; i--) {
            // IP: hack to support preset extension
            if (children[i].children[0].name === 'PresetDecl') {
                let preset = this.analyzePresetDecl(context, program, children[i].children[0]);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(preset));
                presets.push(preset);
                continue;
            }
            let pass = this.analyzePassDecl(context, program, children[i]);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
            passes.push(pass);
        }
        return [passes, presets];
    }
    /**
     * AST example:
     *    Technique11Body
     *         T_PUNCTUATOR_125 = '}'
     *       + Pass11Decl
     *         T_PUNCTUATOR_123 = '{'
     */
    // todo: add preset support (!)
    // see analyzeTechnique() for example.
    analyzeTechnique11(context, program, sourceNode) {
        const children = sourceNode.children;
        let passes = [];
        let iPass = 0;
        for (let i = children.length - 2; i >= 1; i--) {
            let pass = this.analyzePass11Decl(context, program, children[i], iPass);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
            passes.push(pass);
        }
        return [passes];
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *       + Annotation
     *         T_NON_TYPE_ID = 'name'
     *         T_KW_PASS = 'pass'
     */
    /** @deprecated */
    analyzePassDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name });
            }
        }
        const pass = new _instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_42__.PassInstruction({
            scope,
            sourceNode,
            renderStates,
            id,
            pixelShader: entry.pixel,
            vertexShader: entry.vertex
        });
        //TODO: add annotation and id
        return pass;
    }
    /**
     * AST example:
     *    Pass11Decl
     *       + StmtBlock
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_PASS = 'pass'
     */
    analyzePass11Decl(context, program, sourceNode, iPass = 0) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name, sourceNode: children[i] });
            }
        }
        if (!id) {
            // create fake pass name for better readability
            id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_34__.IdInstruction({ scope, name: `auto_pass_${iPass}` });
        }
        const impl = this.analyzeStmtBlock(context, program, children[0]);
        const returnType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_VOID, scope);
        const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_32__.FunctionDefInstruction({ scope, id, returnType });
        const pass11 = new _instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_31__.FunctionDeclInstruction({ scope, sourceNode, impl, def });
        //TODO: add annotation and id
        return pass11;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'VertexShader'
     */
    /** @deprecated */
    analyzePassStateBlockForShaders(context, program, sourceNode) {
        const children = sourceNode.children;
        let pixel = null;
        let vertex = null;
        const supportedTypeNames = ['vertexshader', 'pixelshader'];
        for (let i = children.length - 2; i >= 1; i--) {
            let func = null;
            const childrenIth = children[i].children;
            const shaderTypeName = childrenIth[childrenIth.length - 1].value.toLowerCase();
            if (supportedTypeNames.indexOf(shaderTypeName) === -1) {
                continue;
            }
            func = this.analyzePassStateForShader(context, program, children[i], shaderTypeName);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func)) {
                switch (shaderTypeName) {
                    case 'vertexshader':
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(vertex == null);
                        vertex = func;
                        break;
                    case 'pixelshader':
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(pixel == null);
                        pixel = func;
                        break;
                    default:
                        // TODO: make error!
                        console.error('function is not suitable as shader entry point');
                }
            }
        }
        return { vertex, pixel };
    }
    analyzePassStateForShader(context, program, sourceNode, shaderType) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(shaderType === 'vertexshader' || shaderType === 'pixelshader');
        const children = sourceNode.children;
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        const compileExpr = this.analyzeExpr(context, program, exprNode);
        if (!compileExpr) {
            return null;
        }
        const shaderFunc = compileExpr.function;
        if (shaderType === 'vertexshader') {
            if (!checkForVertexUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionIsNotCompatibleWithVertexShader, { funcDef: String(shaderFunc) });
            }
        }
        else {
            if (!checkForPixelUsage(shaderFunc.def)) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.FunctionIsNotCompatibleWithPixelShader, { funcDef: String(shaderFunc) });
            }
        }
        return shaderFunc;
    }
    /**
     * AST example:
     *    StateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + State
     *       + State
     *       + State
     *         T_PUNCTUATOR_123 = '{'
     */
    /**
     * AST example:
     *    StateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + StateBlock
     *         T_PUNCTUATOR_44 = ','
     *       + StateBlock
     *         T_PUNCTUATOR_123 = '{'
     */
    analyzeStateBlock(context, program, sourceNode, type) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        if (!type.isNotBaseArray()) {
            let props = {};
            for (let i = children.length - 2; i >= 1; i--) {
                props = { ...props, ...this.analyzeState(context, program, children[i]) };
            }
            return new _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__.StateBlockInstruction({ scope, sourceNode, type, props });
        }
        else {
            let blocks = [];
            for (let i = children.length - 2; i >= 1; i--) {
                if (children[i].value === ',')
                    continue;
                blocks = [...blocks, this.analyzeStateBlock(context, program, children[i], type.subType)];
            }
            return new _instructions_StateBlockInstruction__WEBPACK_IMPORTED_MODULE_53__.StateBlockInstruction({ scope, sourceNode, type, blocks });
        }
    }
    /**
     * AST example:
     *    State
     *         T_PUNCTUATOR_59 = ';'
     *       + StateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'ZWRITE'
     */
    analyzeState(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateName = children[children.length - 1].value;
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value)) {
            console.warn('state is incorrect.'); // TODO: move to warnings
            return {};
        }
        let states = {};
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                values[j] = stateExprNode.children[i].value;
            }
            // todo: convert values to native types
            states[stateName] = values;
        }
        else {
            let value = '';
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value;
            }
            else {
                value = exprNode.value;
            }
            // todo: convert value to native type
            states[stateName] = value;
        }
        return states;
    }
    /**
     * AST example:
     *    PassStateBlock
     *         T_PUNCTUATOR_125 = '}'
     *       + PassState
     *       + PassState
     *       + PassState
     *         T_PUNCTUATOR_123 = '{'
     */
    /** @deprecated */
    analyzePassStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePassState(context, program, children[i]) };
        }
        return states;
    }
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'ZWRITE'
     */
    analyzePassState(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateType = children[children.length - 1].value.toUpperCase();
        const stateName = _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates[stateType];
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__.isNumber)(stateName)) {
            return {};
        }
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            return {};
        }
        let renderStates = {};
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                values[j] = getRenderStateValue(stateName, stateExprNode.children[i].value.toUpperCase());
            }
            switch (stateName) {
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNC:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = values[1];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDFUNCSEPARATE:
                    if (values.length !== 4) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = values[2];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = values[1];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = values[3];
                    break;
                case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONSEPARATE:
                    if (values.length !== 2) {
                        console.warn('Pass state are incorrect.');
                        return {};
                    }
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR] = values[0];
                    renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA] = values[1];
                    break;
                default:
                    console.warn('Pass state is incorrect.');
                    return {};
            }
        }
        else {
            let value = '';
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            const stateValue = getRenderStateValue(stateName, value);
            if (stateValue !== _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_4__.ERenderStateValues.UNDEF) {
                switch (stateName) {
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.SRCBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLEND:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.DESTBLENDALPHA] = stateValue;
                        break;
                    case _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATION:
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONCOLOR] = stateValue;
                        renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_3__.ERenderStates.BLENDEQUATIONALPHA] = stateValue;
                        break;
                    default:
                        renderStates[stateName] = stateValue;
                        break;
                }
            }
        }
        return renderStates;
    }
    /**
     * AST example:
     *    ImportDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + ComplexNameOpt
     *         T_KW_IMPORT = 'import'
     */
    // TODO: restore functionality! 
    analyzeImportDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const componentName = this.analyzeComplexName(children[children.length - 2]);
        // if (!isNull(technique)) {
        //     //We can import techniques from the same file, but on this stage they don`t have component yet.
        //     //So we need special mehanism to add them on more belated stage
        //     // let sShortedComponentName: string = componentName;
        //     if (!isNull(context.moduleName)) {
        //         // sShortedComponentName = componentName.replace(_sProvideNameSpace + ".", "");
        //     }
        //     throw null;
        //     // let pTechniqueFromSameEffect: ITechniqueInstruction = _pTechniqueMap[componentName] || _pTechniqueMap[sShortedComponentName];
        //     // if (isDefAndNotNull(pTechniqueFromSameEffect)) {
        //     //     technique._addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);
        //     //     return;
        //     // }
        // }
        const sourceTechnique = null; //fx.techniques[componentName];
        if (!sourceTechnique) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.ImportedComponentNotExists, { componentName: componentName });
            return null;
        }
        return null;
    }
    /**
     * AST example:
     *    StructDecl
     *         T_PUNCTUATOR_125 = '}'
     *       + VariableDecl
     *         T_PUNCTUATOR_123 = '{'
     *         T_NON_TYPE_ID = 'S'
     *         T_KW_STRUCT = 'struct'
     */
    analyzeStructDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children[children.length - 2].value;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EScopeType.k_Struct);
        let fields = [];
        for (let i = children.length - 4; i >= 1; i--) {
            if (children[i].name === 'VariableDecl') {
                fields = fields.concat(this.analyzeVariableDecl(context, program, children[i]));
            }
        }
        program.pop();
        return new _instructions_ComplexTypeInstruction__WEBPACK_IMPORTED_MODULE_23__.ComplexTypeInstruction({ scope, sourceNode, name, fields });
    }
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + VariableDim
     *       + ConstType
     *         T_KW_TYPEDEF = 'typedef'
     */
    analyzeTypedefDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        // TODO: rework to support complex typ defenitions like 
        //  typedef const float4 TYPE_T;
        //          ^^^^^^
        // IP: at the moment type defenitions are not supported
        const vdimNode = children[1];
        const alias = vdimNode.children[0].value;
        const type = this.analyzeConstTypeDim(context, program, children[2]);
        // this.analyzeConstTypeDim() <= doesn't support 'const float' like expressions with modifiers
        // const type = new TypeAlias()
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // add support for typealiases
        const typedef = new _instructions_TypedefInstruction__WEBPACK_IMPORTED_MODULE_59__.TypedefInstruction({ scope, sourceNode, type, alias });
        addTypeAlias(context, scope, typedef);
        return typedef;
    }
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + StructDecl
     */
    /**
     * AST example:
     *    TypeDecl
     *         T_PUNCTUATOR_59 = ';'
     *       + VariableDim
     *       + ConstType
     *         T_KW_TYPEDEF = 'typedef'
     */
    analyzeTypeDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        let type = null;
        if (children.length === 2) {
            type = this.analyzeStructDecl(context, program, children[1]);
        }
        else if (children.length === 4) {
            return this.analyzeTypedefDecl(context, program, sourceNode);
        }
        else {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnsupportedTypeDecl);
        }
        const typeDecl = new _instructions_TypeDeclInstruction__WEBPACK_IMPORTED_MODULE_58__.TypeDeclInstruction({ scope, sourceNode, type });
        addTypeDecl(context, scope, typeDecl);
        return typeDecl;
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'TechniqueDecl':
                return [this.analyzeTechniqueDecl(context, program, sourceNode)];
            case 'Technique11Decl':
                return [this.analyzeTechnique11Decl(context, program, sourceNode)];
            case 'UseDecl':
                this.analyzeUseDecl(context, program, sourceNode); // << always 'use strict' by default!
                return null;
            case 'ImportDecl':
                return [this.analyzeImportDecl(context, program, sourceNode)];
            case 'ProvideDecl':
                return [this.analyzeProvideDecl(context, program, sourceNode)];
            case 'TypeDecl':
                return [this.analyzeTypeDecl(context, program, sourceNode)];
            case 'VariableDecl':
                return this.analyzeVariableDecl(context, program, sourceNode);
            case 'VarStructDecl':
                return this.analyzeVarStructDecl(context, program, sourceNode);
            case 'FunctionDecl':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(program.currentScope == program.globalScope);
                let fdecl = null;
                context.beginFunc();
                fdecl = this.analyzeFunctionDecl(context, program, sourceNode);
                context.endFunc();
                return [fdecl];
            case 'CbufferDecl':
                return [this.analyzeCbufferDecl(context, program, sourceNode)];
            case 'SamplerStateDecl':
                return [this.analyzeSamplerStateDecl(context, program, sourceNode)];
            case 'T_PUNCTUATOR_59':
                context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.EmptySemicolon);
                return null;
            default:
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.UnknownInstruction, { name });
        }
        return null;
    }
    analyzeGlobals(context, program, slastDocument) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(slastDocument) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(slastDocument.root)) {
            return null;
        }
        const children = slastDocument.root.children;
        let globals = [];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(children)) {
            return [];
        }
        for (let i = children.length - 1; i >= 0; i--) {
            globals.push(...(this.analyzeUnknDecl(context, program, children[i]) || []));
        }
        return globals.filter(decl => !!decl);
    }
    createContext(uri, expressions) {
        return new Context(uri, expressions);
    }
    // create new scope
    createProgram(document = null) {
        let parent = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            parent = document.root.scope;
        }
        return new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScope(parent);
    }
    // extends existing scoope
    createProgramEx(document = null) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return this.createProgram();
        }
        return new _ProgramScope__WEBPACK_IMPORTED_MODULE_64__.ProgramScopeEx(document.root.scope);
    }
    /**
     * Post-analysis validation.
     */
    validate(context, program, root) {
        checkFunctionsForRecursion(context, program);
        program.validate();
    }
    /**
     * Create a new standalone document.
     * @param slastDocument
     * @param document Context source. The scope of the parent document will be used when creating a new one.
     * @returns
     */
    parse(slastDocument, document) {
        const uri = slastDocument.uri;
        const program = this.createProgram(document);
        const context = this.createContext(uri);
        let instructions = null;
        try {
            instructions = this.analyzeGlobals(context, program, slastDocument);
        }
        catch (e) {
            // critical errors were occured
            // throw e;
            console.error(e);
        }
        const root = new _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__.InstructionCollector({ scope: program.globalScope, instructions });
        this.validate(context, program, root);
        const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__.Diagnostics.mergeReports([slastDocument.diagnosticReport, context.diagnostics.resolve()]);
        return { root, diagnosticReport, uri };
    }
    /**
     * Extend existing document. (Base document stay unchanged (!))
     * @param slastAddition Extension. (Can be null if just copy of base document is needed.)
     * @param slBase Original document to be extneded.
     * @param options
     * @returns
     *
     * The idea is to create new documents which references to existings scope and extends
     * existings instruction list, but leave parent document unchanged.
     */
    extend(slastAddition, slBase, expressions) {
        let uri = slBase.uri;
        // new program (scope chain) holds links to known variales, types etc of parent document
        let program = this.createProgramEx(slBase);
        // context is absolutely new (!)
        let context = this.createContext(uri, expressions);
        let instructions = slBase.root.instructions;
        let diagnosticReport = slBase.diagnosticReport;
        if (slastAddition) {
            uri = slastAddition.uri;
            try {
                // new list holds links to existings instructions (!)
                instructions = instructions.concat(this.analyzeGlobals(context, program, slastAddition));
            }
            catch (e) {
                // critical errors were occured
                // throw e;
                console.error(e);
            }
            diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__.Diagnostics.mergeReports([diagnosticReport, slastAddition.diagnosticReport, context.diagnostics.resolve()]);
        }
        const root = new _instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_38__.InstructionCollector({ scope: program.globalScope, instructions });
        this.validate(context, program, root);
        return { root, diagnosticReport, uri };
    }
    // function addFunctionDecl(context: Context, program: ProgramScope, sourceNode: IParseNode, func: IFunctionDeclInstruction): void {
    //     if (isSystemFunction(func)) {
    //         context.error(sourceNode, EErrors.SystemFunctionRedefinition, { funcName: func.name });
    //     }
    //     let isFunctionAdded: boolean = program.addFunction(func);
    //     if (!isFunctionAdded) {
    //         context.error(sourceNode, EErrors.FunctionRedifinition, { funcName: func.name });
    //     }
    // }
    static addTechnique11(context, program, technique) {
        let name = technique.name;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(program.globalScope.findTechnique11(name))) {
            context.error(technique.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TechniqueNameRedefinition, { techName: name });
            return;
        }
        program.globalScope.addTechnique11(technique);
    }
    /** @deprecated */
    static addTechnique(context, program, technique) {
        let name = technique.name;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(program.globalScope.findTechnique(name))) {
            context.error(technique.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.TechniqueNameRedefinition, { techName: name });
            return;
        }
        program.globalScope.addTechnique(technique);
    }
    /**
    * Check the possibility of using the operator between the two types.
    * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.
     *
     * @operator {string} One of the operators: + - * / % += -= *= /= %= = < > <= >= == != =
     * @leftType {ITypeInstruction} Type of the left side of the expression.
     * @rightType {ITypeInstruction} Type of the right side of the expression.
     */
    static checkTwoOperandExprTypes(context, operator, leftType, rightType, leftSourceNode = null, rightSourceNode = null, exprSourceNode = null, { isInitializing = false } = {}) {
        if (!leftType || !rightType) {
            return null;
        }
        leftSourceNode = leftSourceNode || leftType.sourceNode;
        rightSourceNode = rightSourceNode || rightType.sourceNode;
        const isComplex = leftType.isComplex() || rightType.isComplex();
        const isArray = leftType.isNotBaseArray() || rightType.isNotBaseArray();
        // const isSampler = isSamplerType(leftType) || isSamplerType(rightType);
        const constBoolType = (len) => {
            if (len >= 1 && len <= 4) {
                let ba = [_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL2, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL3, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL4];
                return _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrapAsConst(ba[len - 1], _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            console.error('unsupported code branch');
            return null;
        };
        if (isArray /* || isSampler*/) {
            // TODO: allow expressions like: arr1 = arr2; ??
            return null;
        }
        if (Analyzer.isAssignmentOperator(operator)) {
            if (!leftType.writable && !isInitializing) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
            if (operator !== '=' && !leftType.readable) {
                // temp solution for cases like:
                // void f(out int x) 
                // {
                //      x = 10;
                //      x |= 1; // << allow to write here
                // }
                context.error(exprSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading, { tooltip: `lvalue is not readable` });
            }
        }
        else {
            if (!leftType.readable) {
                context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
            if (!rightType.readable) {
                context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
            }
        }
        if (isComplex) {
            if (operator === '=' && _helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, rightType)) {
                return leftType;
            }
            // samplers and arrays can't be compared directly
            else if (Analyzer.isEqualityOperator(operator) && !leftType.isComplex()) {
                return constBoolType(1);
            }
            // TODO: emit error (unsupported operation on complex values)
            return null;
        }
        // FIXME: use operands' scope instead of system scope?
        let leftBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(leftType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        let rightBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(rightType.baseType, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
        if (Analyzer.isBitwiseOperator(operator)) {
            if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(leftType) &&
                !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(leftType)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(leftType)) {
                    // todo: use correct error
                    context.error(leftSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastUnknownType, { tooltip: `${leftType.name} => int` });
                }
                else {
                    context.warn(leftSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });
                }
                leftBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntBasedType(rightType) &&
                !_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isUintBasedType(rightType)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(rightType)) {
                    // todo: use correct error
                    context.error(rightSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidCastUnknownType, { tooltip: `${rightType.name} => int` });
                }
                else {
                    context.warn(rightSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: 'bool => int' });
                }
                rightBaseType = _instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_62__.VariableTypeInstruction.wrap(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_INT, _SystemScope__WEBPACK_IMPORTED_MODULE_66__.SCOPE);
            }
            switch (operator) {
                case '&':
                case '|':
                case '^':
                    if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftBaseType, rightType)) {
                        // TODO: emit warning (bitwise between int and uint)
                    }
            }
            return leftBaseType;
        }
        // hack to allow int/uint comparisson
        if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, asRelaxedType(rightType))) {
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, rightType)) {
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, { tooltip: `${leftType.name} [${operator}] ${rightType.name}` });
            }
            if (Analyzer.isArithmeticalOperator(operator)) {
                if (!_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(leftType) || (operator !== '/' && operator !== '/=')) {
                    return leftBaseType;
                }
                // TODO: emit error (cannot perfome devision with matrices)
                return null;
            }
            else if (Analyzer.isRelationalOperator(operator)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(leftType) || _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(leftType)) {
                    return constBoolType(leftType.length);
                }
                // TODO: allow vectors? for ex: vec3 < vec3 => bool3
                // TODO: emit error (cannot perfome comparison with non-scalar)
                return null;
            }
            else if (Analyzer.isEqualityOperator(operator)) {
                return constBoolType(leftType.length);
            }
            else if (operator === '=') {
                return leftBaseType;
            }
            // TODO: emit error (unknonw operation)
            return null;
        }
        // op: "+", "-", "*", "/"
        //     "+=", "-=", "*=", "/=", "%="
        if (Analyzer.isArithmeticalOperator(operator)) {
            // op: "+", "-", "*", "/", "%"
            const length = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(leftType)
                ? rightType.length
                : _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(rightType)
                    ? leftType.length
                    : Math.min(leftType.length, rightType.length);
            const baseType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determMostPreciseBaseType(leftType, rightType);
            const resultType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.findType(`${baseType.name}${length === 1 ? '' : length}`);
            if (!resultType) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `cannot determ result type for "${leftType.toCode()} ${operator} ${rightType.toCode()}"`);
                return null;
            }
            // op: "+=", "-=", "*=", "/=", "%="
            if (Analyzer.isAssignmentOperator(operator)) {
                if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(leftType, resultType)) {
                    // TODO: add support for imlicit conversions
                    // TODO: emit error (operator cannot be used with a given lvalue)
                    context.error(exprSourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.OperatorCannotBeUsedWithGivenLValue, {});
                    return null;
                }
            }
            if (resultType.length < leftType.length || resultType.length < rightType.length) {
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeTruncation, {
                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`
                });
            }
            if (!_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(_SystemScope__WEBPACK_IMPORTED_MODULE_66__.determBaseType(leftType), _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determBaseType(rightType))) {
                // do not emit errors for expr like: float2 * float, int2 + int etc..
                context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                    tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${resultType.toCode()}`
                });
            }
            /**
             * Special case for matrices
             */
            if (operator === '*' || operator === '*=') {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(leftType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(rightType)) {
                    if (leftType.length === rightType.length) {
                        return rightBaseType;
                    }
                    return null;
                }
                else if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isMatrixType(rightType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isVectorType(leftType)) {
                    if (leftType.length === rightType.length) {
                        return leftBaseType;
                    }
                    return null;
                }
            }
            return resultType;
        }
        if (operator === '=') {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isScalarType(rightType)) {
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.determTypePrecision(leftType) > _SystemScope__WEBPACK_IMPORTED_MODULE_66__.determTypePrecision(rightType)) {
                    context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`
                    });
                    return leftType;
                }
                if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntegerType(leftType) && _SystemScope__WEBPACK_IMPORTED_MODULE_66__.isIntegerType(rightType)) {
                    context.warn(exprSourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerWarnings.ImplicitTypeConversion, {
                        tooltip: `${leftType.toCode()} ${operator} ${rightType.toCode()} => ${leftType.toCode()}`
                    });
                    return leftType;
                }
            }
        }
        return null;
    }
    /**
     * Check the ability to use the operator to the data type.
     * Returns the type obtained as a result of application of the operator, or, if it is impossible to apply, null.
     *
     * @operator {string} One of the operators: + - ! ++ --
     * @leftType {IVariableTypeInstruction} Operand type
     */
    static checkOneOperandExprType(context, sourceNode, operator, type) {
        const isComplex = type.isComplex();
        const isArray = type.isNotBaseArray();
        // const isSampler = isSamplerType(type);
        if (isComplex || isArray /* || isSampler*/) {
            return null;
        }
        if (!type.readable) {
            context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForReading);
        }
        if (operator === '++' || operator === '--') {
            if (!type.writable) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_1__.EAnalyzerErrors.InvalidTypeForWriting);
            }
            return type;
        }
        if (operator === '!') {
            const boolType = _SystemScope__WEBPACK_IMPORTED_MODULE_66__.T_BOOL;
            // validate(boolType, EInstructionTypes.k_VariableDecl);
            if (_helpers__WEBPACK_IMPORTED_MODULE_10__.types.equals(type, boolType)) {
                return boolType;
            }
            else {
                return null;
            }
        }
        else {
            if (_SystemScope__WEBPACK_IMPORTED_MODULE_66__.isBoolBasedType(type)) {
                return null;
            }
            else {
                return type.baseType; // << TODO: fixme!!!! remove "any"!
            }
        }
        return null;
    }
    static isAssignmentOperator(operator) {
        return operator === '+=' || operator === '-=' ||
            operator === '*=' || operator === '/=' ||
            operator === '%=' || operator === '=' ||
            operator === '|=' || operator === '&=' ||
            operator === '>>=' || operator === '<<=' || operator === '^=';
    }
    static isBitwiseOperator(operator) {
        return operator === '>>' || operator === '<<' ||
            operator === '|' || operator === '&' || operator === '^' ||
            operator === '|=' || operator === '&=' ||
            operator === '>>=' || operator === '<<=' || operator === '^=';
    }
    static isArithmeticalOperator(operator) {
        return operator === '+' || operator === '+=' ||
            operator === '-' || operator === '-=' ||
            operator === '*' || operator === '*=' ||
            operator === '/' || operator === '/=' ||
            operator === '%' || operator === '%=';
    }
    static isRelationalOperator(operator) {
        return operator === '>' || operator === '>=' ||
            operator === '<' || operator === '<=';
    }
    static isEqualityOperator(operator) {
        return operator === '==' || operator === '!=';
    }
}


/***/ }),

/***/ "rHPT":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/FxAnalyzer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FxAnalyzer": () => (/* binding */ FxAnalyzer),
/* harmony export */   "FxContext": () => (/* binding */ FxContext)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/EAnalyzerWarnings */ "AW2x");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");
/* harmony import */ var _Analyzer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Analyzer */ "R35j");
/* harmony import */ var _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instructions/IdInstruction */ "Muaz");
/* harmony import */ var _instructions_part_DrawInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./instructions/part/DrawInstruction */ "9jn4");
/* harmony import */ var _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instructions/part/PartFxInstruction */ "0Qwk");
/* harmony import */ var _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./instructions/part/PartFxPassInstruction */ "pCHB");
/* harmony import */ var _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./instructions/part/SpawnInstruction */ "sg/T");
/* harmony import */ var _SystemScope__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SystemScope */ "c0pO");














const asType = (instr) => instr ? instr.type : null;
class FxContext extends _Analyzer__WEBPACK_IMPORTED_MODULE_6__.Context {
    constructor() {
        super(...arguments);
        this.spawnStmts = [];
        this.drawStmts = [];
    }
    // beginFunc(): void {
    //     super.beginFunc();
    // }
    // endFunc(): void {
    //     super.endFunc();
    // }
    beginPartFxPass() {
        this.beginPass();
        this.particleInstance = null;
    }
    endPartFxPass() {
        this.particleInstance = null;
        this.endPass();
    }
    beginPartFx() {
        this.particleCore = null;
    }
    endPartFx() {
        this.particleCore = null;
    }
}
function sliceNode(source, from, to) {
    const { children, parent, name, value, loc } = source;
    return {
        children: children.slice(from, to),
        parent,
        name,
        value,
        loc
    };
}
class FxAnalyzer extends _Analyzer__WEBPACK_IMPORTED_MODULE_6__.Analyzer {
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'Init'
     *         T_PUNCTUATOR_41 = ')'
     *         T_UINT = '10'
     *         T_PUNCTUATOR_40 = '('
     *         T_KW_SPAWN = 'spawn'
     */
    analyzeSpawnStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children.slice(-5, -4)[0].value;
        const args = [];
        for (let i = children.length - 7; i >= 2; i--) {
            if (children[i].value !== ',') {
                const arg = this.analyzeExpr(context, program, children[i]);
                args.push(arg);
            }
        }
        // const { base, signed, heximal, exp } = parseUintLiteral(children.slice(-3, -2)[0].value);
        // const count = new IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
        const count = this.analyzeExpr(context, program, children.slice(-3, -2)[0]);
        // find function name(args)
        const spawnStmt = new _instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_11__.SpawnInstruction({ sourceNode, scope, name, args, count });
        context.spawnStmts.push(spawnStmt);
        return spawnStmt;
    }
    /**
     * AST example:
     *    SimpleStmt
     *         T_PUNCTUATOR_59 = ';'
     *         T_PUNCTUATOR_41 = ')'
     *         T_NON_TYPE_ID = 'part'
     *         T_PUNCTUATOR_40 = '('
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_DRAW = 'draw'
     */
    analyzeDrawStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const scope = program.currentScope;
        const name = children[children.length - 2].value;
        const args = [];
        for (let i = children.length - 4; i >= 2; i--) {
            if (children[i].value !== ',') {
                const arg = this.analyzeExpr(context, program, children[i]);
                args.push(arg);
            }
        }
        const instr = new _instructions_part_DrawInstruction__WEBPACK_IMPORTED_MODULE_8__.DrawInstruction({ sourceNode, scope, name, args });
        const ctx = context.funcDef;
        context.drawStmts.push({ instr, ctx });
        return instr;
    }
    analyzeSimpleStmt(context, program, sourceNode) {
        const children = sourceNode.children;
        const firstNodeName = children[children.length - 1].name;
        switch (firstNodeName) {
            case 'T_KW_SPAWN':
                return this.analyzeSpawnStmt(context, program, sourceNode);
            case 'T_KW_DRAW':
                return this.analyzeDrawStmt(context, program, sourceNode);
            default:
                return super.analyzeSimpleStmt(context, program, sourceNode);
        }
    }
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *         T_NON_TYPE_ID = 'P0'
     *         T_KW_PASS = 'pass'
     */
    /**
     * AST example:
     *    PassDecl
     *       + PassStateBlock
     *         T_KW_PASS = 'pass'
     */
    analyzePartFXPassDecl(context, program, sourceNode) {
        context.beginPartFxPass();
        const children = sourceNode.children;
        const scope = program.currentScope;
        const entry = this.analyzePassStateBlockForShaders(context, program, children[0]);
        const renderStates = this.analyzePassStateBlock(context, program, children[0]);
        // temp solution in order to not highlight useless pass states in the next analysis call.
        context.renderStates = renderStates;
        const fxStates = this.analyzePartFxStateBlock(context, program, children[0]);
        let sorting = (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(fxStates.sorting) ? fxStates.sorting : false;
        const prerenderRoutine = fxStates.prerenderRoutine || null;
        const geometry = fxStates.geometry || null;
        const instanceCount = fxStates.instanceCount || 1;
        if (sorting && prerenderRoutine && _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(prerenderRoutine.function.def.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID)) {
            context.warn(sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_SortingCannotBeApplied);
            context.warn(prerenderRoutine.function.def.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_SortingCannotBeApplied);
        }
        //
        // Validation of the shader input
        //
        let pixelShader = entry.pixel;
        /**
         * Vertex shader validation pattern:
         *  PixelInputType VertexShader(PartInstance partInstance, Geometry geometry);
         */
        let vertexShader = entry.vertex;
        if (vertexShader) {
            const requiredSemantics = ['POSITION', 'POSITION0'];
            let hasInstance = false;
            let hasRequiredSemantics = false;
            for (const param of vertexShader.def.params) {
                hasInstance = hasInstance ||
                    param.type.subType === context.particleInstance;
                hasRequiredSemantics = hasRequiredSemantics ||
                    !!requiredSemantics.find(semantic => param.type.hasFieldWithSematics(semantic));
            }
            if (!hasInstance) {
                context.error(sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_VertexShaderParametersMismatch, { tooltip: 'vertex shader must have a valid material param which is compatible with prerender routine.' });
                vertexShader = pixelShader = null;
            }
            // if (!hasRequiredSemantics) {
            //     context.error(sourceNode, EErrors.PartFx_VertexShaderParametersMismatch,
            //         { tooltip: 'doesn\'t have requiredsemantics.' });
            //     vertexShader = pixelShader = null;
            // }
        }
        //
        // Rest
        //
        let id = null;
        for (let i = 0; i < children.length; ++i) {
            if (children[i].name === "T_NON_TYPE_ID") {
                let name = children[i].value;
                id = new _instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_7__.IdInstruction({ sourceNode: children[i], scope, name });
            }
        }
        let drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__.EPassDrawMode.k_Auto;
        if (id) {
            if (context.drawStmts.find(x => x.instr.name == id.name)) {
                drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_5__.EPassDrawMode.k_Manual;
            }
        }
        const pass = new _instructions_part_PartFxPassInstruction__WEBPACK_IMPORTED_MODULE_10__.PartFxPassInstruction({
            scope,
            sourceNode,
            id,
            sorting,
            geometry,
            instanceCount,
            prerenderRoutine,
            drawMode,
            renderStates,
            pixelShader,
            vertexShader
        });
        //TODO: add annotation and id
        context.endPartFxPass();
        return pass;
    }
    // TODO: use explicit return type
    analyzePartFxStateBlock(context, program, sourceNode) {
        const children = sourceNode.children;
        let states = {};
        for (let i = children.length - 2; i >= 1; i--) {
            states = { ...states, ...this.analyzePartFXPassProperies(context, program, children[i]) };
        }
        return states;
    }
    /**
    * AST example:
    *    PassState
    *         T_PUNCTUATOR_59 = ';'
    *       + PassStateExpr
    *         T_PUNCTUATOR_61 = '='
    *         T_NON_TYPE_ID = 'STATE_ONE'
    */
    /**
     * AST example:
     *    PassState
     *         T_PUNCTUATOR_59 = ';'
     *       + PassStateExpr
     *         T_PUNCTUATOR_61 = '='
     *         T_NON_TYPE_ID = 'STATE_TWO'
     */
    /**
     * AST example:
     *    PassStateExpr
     *         T_PUNCTUATOR_125 = '}'
     *         T_UINT = '1'
     *         T_PUNCTUATOR_44 = ','
     *         T_KW_TRUE = 'true'
     *         T_PUNCTUATOR_123 = '{'
     */
    // TODO: add explicit type for fx statess
    analyzePartFXPassProperies(context, program, sourceNode) {
        const children = sourceNode.children;
        const stateName = children[children.length - 1].value.toUpperCase();
        const stateExprNode = children[children.length - 3];
        const exprNode = stateExprNode.children[stateExprNode.children.length - 1];
        let fxStates = {};
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(exprNode.value) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(stateName)) {
            console.warn('Pass state is incorrect.'); // TODO: move to warnings
            // TODO: return correct state list
            return fxStates;
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_PUNCTUATOR_125 = '}'
         *         T_UINT = '1'
         *         T_PUNCTUATOR_44 = ','
         *         T_KW_TRUE = 'true'
         *         T_PUNCTUATOR_123 = '{'
         */
        if (exprNode.value === '{' && stateExprNode.children.length > 3) {
            const values = new Array(Math.ceil((stateExprNode.children.length - 2) / 2));
            for (let i = stateExprNode.children.length - 2, j = 0; i >= 1; i -= 2, j++) {
                // TODO: validate values with names
                values[j] = stateExprNode.children[i].value.toUpperCase();
            }
            switch (stateName) {
                // case ERenderStates.BLENDFUNC:
                //     if (values.length !== 2) {
                //         console.warn('Pass state are incorrect.');
                //         return {};
                //     }
                //     renderStates[ERenderStates.SRCBLENDCOLOR] = values[0];
                //     renderStates[ERenderStates.SRCBLENDALPHA] = values[0];
                //     renderStates[ERenderStates.DESTBLENDCOLOR] = values[1];
                //     renderStates[ERenderStates.DESTBLENDALPHA] = values[1];
                //     break;
                default:
                    console.warn('Pass fx state is incorrect.');
                    return fxStates;
            }
        }
        /**
         * AST example:
         *    PassStateExpr
         *         T_NON_TYPE_ID = 'FALSE'
         */
        else {
            let value = null;
            if (exprNode.value === '{') {
                value = stateExprNode.children[1].value.toUpperCase();
            }
            else {
                value = exprNode.value.toUpperCase();
            }
            switch (stateName) {
                case ('InstanceCount'.toUpperCase()):
                    fxStates.instanceCount = Number(value) || 1;
                    break;
                case ('Geometry'.toUpperCase()):
                    // Geometry = "sfx_leaves";
                    if (exprNode.name == "T_STRING") {
                        value = value.replace(/^"(.+)"$/, '$1');
                    }
                    // Geometry = Sphere;
                    else {
                        console.assert(exprNode.name === 'T_NON_TYPE_ID');
                    }
                    fxStates.geometry = value.toLowerCase();
                    break;
                case ('Sorting'.toUpperCase()):
                    // TODO: use correct validation with diag error output
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(value == 'TRUE' || value == 'FALSE');
                    fxStates.sorting = (value === 'TRUE');
                    break;
                case ('PrerenderRoutine'.toUpperCase()):
                    {
                        /**
                        * Prerender routine expected as 'void prerender(Part part, out DefaultShaderInput input)'.
                        */
                        let validators = [
                            /* void prerender(in Part part, inout PartInstance instance) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [context.particleCore, null] },
                            /* void prerender(in Part part, inout PartInstance instance, int instanceId) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [context.particleCore, null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                            /* int prerender(in Part part, inout PartInstance instance) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [context.particleCore, null] },
                            /* int prerender(in Part part, inout PartInstance instance, int instanceId) */
                            { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [context.particleCore, null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                        ];
                        //
                        // TODO: add string-based validators like this:
                        // void prerender(Part part, PartInstance instance, int instanceId?: INSTANCE_ID);
                        //
                        let prerenderRoutine = this.analyzeCompileExpr(context, program, exprNode, validators);
                        if (!prerenderRoutine) {
                            break;
                        }
                        //
                        // check arguments
                        //
                        let fn = prerenderRoutine.function;
                        /** first argument's type */
                        let argv = fn.def.params.map(param => param.type);
                        if (argv.length < 2) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' count mismatch.` });
                            prerenderRoutine = null;
                        }
                        if (!argv[0].readable || argv[0].subType !== context.particleCore ||
                            argv[0].isNotBaseArray() ||
                            !(argv[1].usages.includes('out') || argv[1].usages.includes('inout')) || !argv[1].writable || argv[1].isNotBaseArray()) {
                            context.error(exprNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'PrerenderRoutine' arguments' type mismatch.` });
                            prerenderRoutine = null;
                        }
                        //         argv[1]: "out PartInstance"
                        // argv[1].subType: "PartInstance"
                        context.particleInstance = argv[1].subType;
                        fxStates.prerenderRoutine = prerenderRoutine;
                    }
                    break;
                default:
            }
        }
        return fxStates;
    }
    analyzePartFXBody(context, program, sourceNode) {
        let passes = [];
        let spawnRoutine = null;
        let initRoutine = null;
        let updateRoutine = null;
        let particle = null;
        let capacity = null;
        const children = sourceNode.children;
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassState':
                    {
                        let sourceNode = children[i];
                        let stateName = sourceNode.children[3].value; // "T_NON_TYPE_ID"
                        switch (stateName.toUpperCase()) {
                            case ('Capacity'.toUpperCase()):
                                {
                                    // TODO: make correct validation of the capacity value and emit errors
                                    //       through diagnostics system. 
                                    const snum = sourceNode.children[1].children[0].value;
                                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(Number(snum)));
                                    capacity = Number(snum) || -1;
                                    // capacity must be multiple of 64 because of group size is 64
                                    // and we run thread for every alive particle
                                    // todo: fix it usind condition in the beginning of the shader
                                    capacity = Math.floor((capacity + 63) / 64) * 64;
                                    break;
                                }
                            case ('SpawnRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Spawn routine expected as 'int spawn(void)'.
                                     */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT, args: [] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [/.*/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [] }, // void f(void)
                                    ];
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    spawnRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    const params = spawnRoutine.function.def.params;
                                    if (params.length > 0) {
                                        if (!params[0].type.usages.includes('inout')) {
                                            context.warn(params[0].type.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_EmitterPersistentDataMustBeMarkedAsInout);
                                        }
                                    }
                                }
                                break;
                            case ('InitRoutine'.toUpperCase()):
                                {
                                    /** Init routine expected as 'void init(in Part part)'. */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null, /u?int/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null, /u?int/, /u?int/] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_VOID, args: [null] }, /* init(PART part) */
                                    ];
                                    // TODO: show error in case of both functions are found
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    initRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!initRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    let fn = initRoutine.function;
                                    /** first argument's type */
                                    let type = fn.def.params[0].type;
                                    if ((!type.usages.includes('out') && !type.usages.includes('inout')) || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        initRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'InitRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                            case ('UpdateRoutine'.toUpperCase()):
                                {
                                    /**
                                     * Update routine expected as 'void update(inout Part part)'.
                                     */
                                    let validators = [
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL, args: [null, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_INT] },
                                        { ret: _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL, args: [null] }, /* update(PART part) */
                                    ];
                                    let objectExrNode = sourceNode.children[1].children[0];
                                    updateRoutine = this.analyzeCompileExpr(context, program, objectExrNode, validators);
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    //
                                    // check arguments
                                    //
                                    const fn = updateRoutine.function;
                                    const fdef = fn.def;
                                    const paramList = fdef.params;
                                    if (paramList.length < 1 || paramList.length > 2) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    /** first argument's type */
                                    let type = paramList[0].type;
                                    if (!type.usages.includes('out') && !type.usages.includes('inout') || type.isNotBaseArray()) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    if (particle && type.subType !== particle) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' arguments' type mismatch.` });
                                        updateRoutine = null;
                                    }
                                    //
                                    // Check return type
                                    //
                                    if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(fdef.returnType, _SystemScope__WEBPACK_IMPORTED_MODULE_12__.T_BOOL)) {
                                        context.error(objectExrNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.InvalidCompileFunctionNotValid, { funcName: fn.name, tooltip: `'UpdateRoutine' return type mismatch. 'boolean' is expected.` });
                                        updateRoutine = null;
                                    }
                                    if (!updateRoutine) {
                                        break;
                                    }
                                    // type is referencing to VariableType of argument,
                                    // while substitute type referencing to declaration. 
                                    particle = type.subType;
                                }
                                break;
                        }
                    }
                    break;
            }
        }
        // Note: all fx properties should be parsed prior to pass declaraion analysis
        // because some of them are critical for pass validation
        context.particleCore = particle;
        const presets = [];
        for (let i = children.length - 2; i > 0; i--) {
            switch (children[i].name) {
                case 'PassDecl':
                    {
                        // hack to support presets extension
                        if (children[i].children[0].name === 'PresetDecl') {
                            presets.push(this.analyzePresetDecl(context, program, children[i].children[0]));
                            break;
                        }
                        let pass = this.analyzePartFXPassDecl(context, program, children[i]);
                        if (!pass.isValid()) {
                            context.warn((pass.id && pass.id.sourceNode) || children[i], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.IncompletePass, {
                                techniqueName: pass.name,
                                tooltip: `The pass is not completed. Not all required parameters are specified.`
                            });
                        }
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(pass));
                        passes.push(pass);
                    }
                    break;
            }
        }
        return { passes, spawnRoutine, initRoutine, updateRoutine, particle, capacity, presets };
    }
    /**
     * AST example:
     *    PartFxDecl
     *       + PartFxBody
     *       + Annotation
     *       + Semantic
     *       + ComplexNameOpt
     *         T_KW_FXPART = 'partFx'
     */
    analyzePartFXDecl(context, program, sourceNode) {
        const children = sourceNode.children;
        const name = this.analyzeComplexName(children[children.length - 2]);
        // Specifies whether name should be interpreted as globalNamespace.name or just a name;
        const isComplexName = children[children.length - 2].children.length !== 1;
        const scope = program.currentScope;
        let annotation = null;
        let semantic = null;
        let props = null;
        context.beginPartFx();
        for (let i = children.length - 3; i >= 0; i--) {
            switch (children[i].name) {
                case 'Annotation':
                    annotation = this.analyzeAnnotation(context, program, children[i]);
                    break;
                case 'Semantic':
                    semantic = this.analyzeSemantic(children[i]);
                    break;
                case 'PartFxBody':
                    props = this.analyzePartFXBody(context, program, children[i]);
                    break;
            }
        }
        //
        // draw operator finalization
        //
        for (const stmt of context.drawStmts) {
            const { instr, ctx } = stmt;
            const pass = props.passes.find(pass => pass.id.name == instr.name);
            if (!pass) {
                // emit warning not an error
                // because in some cases it may be useful to have several effects with
                // common update routine but different pass set
                context.warn(instr.sourceNode, _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.PartFx_RenderPassWasNotFound, {
                    techniqueName: name,
                    tooltip: `The technique doesn't have pass with name <${instr.name}>`
                });
            }
            const p0Type = ctx.params[0].type;
            if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(p0Type, context.particleCore) || !p0Type.readable) {
                context.error(instr.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_DrawOpOnlyAllowedWithinUpdateRoutine, { tooltip: 'Draw operator only allowed within update routine' });
            }
        }
        context.endPartFx();
        const partFx = new _instructions_part_PartFxInstruction__WEBPACK_IMPORTED_MODULE_9__.PartFxInstruction({
            sourceNode, name, semantic, annotation, scope, ...props
        });
        if (!partFx.isValid()) {
            // highlight name only
            context.warn(children[children.length - 2], _lib_idl_EAnalyzerWarnings__WEBPACK_IMPORTED_MODULE_3__.EAnalyzerWarnings.IncompleteTechnique, {
                techniqueName: partFx.name,
                tooltip: `The technique is not completed. Not all required parameters are specified.`
            });
        }
        FxAnalyzer.addTechnique(context, program, partFx);
        return partFx;
    }
    analyzeUnknDecl(context, program, sourceNode) {
        switch (sourceNode.name) {
            case 'PartFxDecl':
                return [this.analyzePartFXDecl(context, program, sourceNode)];
            default:
                return super.analyzeUnknDecl(context, program, sourceNode);
        }
    }
    createContext(uri) {
        return new FxContext(uri);
    }
    validate(context, program, root) {
        super.validate(context, program, root);
        const scope = program.globalScope;
        if (!root.instructions) {
            return;
        }
        // NOTE: all effects are assumed to be valid
        const fxList = root.instructions.filter(instr => instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_PartFxDecl);
        //
        // spawn operator validation
        //
        for (const spawnStmt of context.spawnStmts) {
            const bImportedEffect = false;
            //parse as the spawn from the same effect
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!bImportedEffect, 'unsupported');
            if (!bImportedEffect) {
                let initializer = null;
                for (const fx of fxList) {
                    // looking for:
                    // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)
                    // Init(out Part part, int partId: PART_ID, ...parameters)
                    // Init(out Part part, ...parameters)
                    let argsList = [[/u?int/, /u?int/], [/u?int/], []]
                        .map(v => [fx.particle, ...v, ...spawnStmt.args.map(asType)]);
                    for (const args of argsList) {
                        initializer = scope.findFunction(spawnStmt.name, args);
                        if (initializer) {
                            break;
                        }
                    }
                    if (initializer) {
                        // spawnStmt.$resolve(fx, initializer);
                        break;
                    }
                }
                if (!initializer) {
                    context.error(spawnStmt.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_2__.EAnalyzerErrors.PartFx_InvalidSpawnStmtInitializerNotFound, { tooltip: 'Invalid spawn statement. Effect initializer not found.' });
                }
            }
        }
    }
}


/***/ }),

/***/ "zHDc":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/ProgramScope.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProgramScope": () => (/* binding */ ProgramScope),
/* harmony export */   "ProgramScopeEx": () => (/* binding */ ProgramScopeEx),
/* harmony export */   "Scope": () => (/* binding */ Scope)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ "pEQR");




class Scope {
    constructor(params) {
        let type;
        let strictMode;
        let parent;
        if (params instanceof Scope) {
            let scope = params;
            ({ type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default, parent = null, strictMode = false } = scope);
            this.variables = { ...(scope.variables) };
            this.types = { ...scope.types };
            this.functions = { ...scope.functions };
            this.techniques = { ...scope.techniques };
            this.techniques11 = { ...scope.techniques11 };
            this.typeTemplates = { ...scope.typeTemplates };
            this.cbuffers = { ...scope.cbuffers };
        }
        else {
            let settings = params;
            ({ type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default, parent = null, strictMode = false } = settings);
            this.variables = {};
            this.types = {};
            this.functions = {};
            this.techniques = {};
            this.techniques11 = {};
            this.typeTemplates = {};
            this.cbuffers = {};
        }
        this.type = type;
        this.parent = parent;
        this.strictMode = strictMode;
    }
    isStrict() {
        return this.filter(scope => scope.strictMode);
    }
    findVariable(varName) {
        return this.filter(scope => scope.variables[varName] || null);
    }
    findTypeTemplate(typeName) {
        return this.filter(scope => scope.typeTemplates[typeName] || null);
    }
    findType(typeName) {
        return this.filter(scope => scope.types[typeName] || null);
    }
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    findFunction(funcName, args = null) {
        return this.filter(scope => _helpers__WEBPACK_IMPORTED_MODULE_3__.fn.matchList(scope.functions[funcName], args));
    }
    findTechnique(techName) {
        return this.filter(scope => scope.techniques[techName] || null);
    }
    findTechnique11(techName) {
        return this.filter(scope => scope.techniques11[techName] || null);
    }
    findCbuffer(cbufName) {
        return this.filter(scope => scope.cbuffers[cbufName] || null);
    }
    findFunctionInScope(func) {
        let res = _helpers__WEBPACK_IMPORTED_MODULE_3__.fn.matchList(this.functions[func.name], func.def.params.map(param => param ? param.type : null));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(res !== undefined);
        return res;
    }
    addVariable(variable) {
        let variableMap = this.variables;
        let varName = variable.name;
        if (!this.variables[varName]) {
            variableMap[varName] = variable;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(variable.scope === this);
        }
        else {
            // console.error(`letiable '${varName}' already exists in scope:`, this);
            return false;
        }
        return true;
    }
    addTypeTemplate(template) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this.typeTemplates[template.name])) {
            return false;
        }
        this.typeTemplates[template.name] = template;
        return true;
    }
    // todo: remove scopeId from argumts, use type.scope instead.
    addType(type) {
        if (this.types[type.name]) {
            return false;
        }
        this.types[type.name] = type;
        console.assert(type.scope === this);
        return true;
    }
    addTypeAlias(t, aliasName) {
        let typeName = null;
        let type = null;
        if ((0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__.isString)(t)) {
            typeName = t;
            type = this.findType(typeName);
        }
        else {
            type = t;
            typeName = type.name;
        }
        const alias = this.findType(aliasName);
        if (alias) {
            return false;
        }
        if (!type) {
            return false;
        }
        // original type must be part of this scope?
        if (!this.findType(typeName)) {
            return false;
        }
        this.types[aliasName] = type;
        return true;
    }
    addFunction(func) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(func.scope === this);
        let funcMap = this.functions;
        let funcName = func.name;
        funcMap[funcName] = funcMap[funcName] || [];
        const funcOverloads = funcMap[funcName];
        let targetFunc = this.findFunctionInScope(func);
        if (!targetFunc) {
            funcOverloads.push(func);
        }
        else {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(func.impl));
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(targetFunc.impl));
            let i = funcOverloads.indexOf(targetFunc);
            funcOverloads[i] = func;
        }
        return true;
    }
    addTechnique(technique) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.techniques[technique.name]) {
            return false;
        }
        this.techniques[technique.name] = technique;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(technique.scope === this);
        return true;
    }
    addTechnique11(technique11) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.techniques11[technique11.name]) {
            return false;
        }
        this.techniques11[technique11.name] = technique11;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(technique11.scope === this);
        return true;
    }
    addCbuffer(cbuf) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global);
        if (this.cbuffers[cbuf.name]) {
            return false;
        }
        this.cbuffers[cbuf.name] = cbuf;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(cbuf.scope === this);
        return true;
    }
    filter(cb) {
        let scope = this;
        while (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope)) {
            let res = cb(scope);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(res)) {
                return res;
            }
            scope = scope.parent;
        }
        return null;
    }
}
class ProgramScope {
    constructor(parent) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(parent)) {
            let type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Global;
            this.globalScope = new Scope({ parent, type });
            this.currentScope = this.globalScope;
        }
    }
    validate() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope === this.globalScope);
    }
    push(type = _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type >= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EScopeType.k_Default);
        let parent = this.currentScope;
        let scope = new Scope({ parent, type });
        this.currentScope = scope;
    }
    pop() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
        this.currentScope = this.currentScope.parent;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.currentScope !== null);
    }
}
class ProgramScopeEx extends ProgramScope {
    constructor(parent) {
        super(null);
        this.globalScope = new Scope(parent); // clone scope
        this.currentScope = this.globalScope;
    }
}


/***/ }),

/***/ "c0pO":
/*!********************************************!*\
  !*** ./src/lib/fx/analisys/SystemScope.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SCOPE": () => (/* binding */ SCOPE),
/* harmony export */   "T_BLEND_STATE": () => (/* binding */ T_BLEND_STATE),
/* harmony export */   "T_BOOL": () => (/* binding */ T_BOOL),
/* harmony export */   "T_BOOL2": () => (/* binding */ T_BOOL2),
/* harmony export */   "T_BOOL2X2": () => (/* binding */ T_BOOL2X2),
/* harmony export */   "T_BOOL3": () => (/* binding */ T_BOOL3),
/* harmony export */   "T_BOOL3X3": () => (/* binding */ T_BOOL3X3),
/* harmony export */   "T_BOOL4": () => (/* binding */ T_BOOL4),
/* harmony export */   "T_BOOL4X4": () => (/* binding */ T_BOOL4X4),
/* harmony export */   "T_COMPUTE_SHADER": () => (/* binding */ T_COMPUTE_SHADER),
/* harmony export */   "T_DEPTH_STENCIL_STATE": () => (/* binding */ T_DEPTH_STENCIL_STATE),
/* harmony export */   "T_FLOAT": () => (/* binding */ T_FLOAT),
/* harmony export */   "T_FLOAT2": () => (/* binding */ T_FLOAT2),
/* harmony export */   "T_FLOAT2X2": () => (/* binding */ T_FLOAT2X2),
/* harmony export */   "T_FLOAT2X3": () => (/* binding */ T_FLOAT2X3),
/* harmony export */   "T_FLOAT2X4": () => (/* binding */ T_FLOAT2X4),
/* harmony export */   "T_FLOAT3": () => (/* binding */ T_FLOAT3),
/* harmony export */   "T_FLOAT3X2": () => (/* binding */ T_FLOAT3X2),
/* harmony export */   "T_FLOAT3X3": () => (/* binding */ T_FLOAT3X3),
/* harmony export */   "T_FLOAT3X4": () => (/* binding */ T_FLOAT3X4),
/* harmony export */   "T_FLOAT4": () => (/* binding */ T_FLOAT4),
/* harmony export */   "T_FLOAT4X2": () => (/* binding */ T_FLOAT4X2),
/* harmony export */   "T_FLOAT4X3": () => (/* binding */ T_FLOAT4X3),
/* harmony export */   "T_FLOAT4X4": () => (/* binding */ T_FLOAT4X4),
/* harmony export */   "T_GEOMETRY_SHADER": () => (/* binding */ T_GEOMETRY_SHADER),
/* harmony export */   "T_HALF": () => (/* binding */ T_HALF),
/* harmony export */   "T_HALF2": () => (/* binding */ T_HALF2),
/* harmony export */   "T_HALF3": () => (/* binding */ T_HALF3),
/* harmony export */   "T_HALF4": () => (/* binding */ T_HALF4),
/* harmony export */   "T_INT": () => (/* binding */ T_INT),
/* harmony export */   "T_INT2": () => (/* binding */ T_INT2),
/* harmony export */   "T_INT2X2": () => (/* binding */ T_INT2X2),
/* harmony export */   "T_INT3": () => (/* binding */ T_INT3),
/* harmony export */   "T_INT3X3": () => (/* binding */ T_INT3X3),
/* harmony export */   "T_INT4": () => (/* binding */ T_INT4),
/* harmony export */   "T_INT4X4": () => (/* binding */ T_INT4X4),
/* harmony export */   "T_NULL": () => (/* binding */ T_NULL),
/* harmony export */   "T_PIXEL_SHADER": () => (/* binding */ T_PIXEL_SHADER),
/* harmony export */   "T_SAMPLER_STATE": () => (/* binding */ T_SAMPLER_STATE),
/* harmony export */   "T_STRING": () => (/* binding */ T_STRING),
/* harmony export */   "T_UINT": () => (/* binding */ T_UINT),
/* harmony export */   "T_UINT2": () => (/* binding */ T_UINT2),
/* harmony export */   "T_UINT3": () => (/* binding */ T_UINT3),
/* harmony export */   "T_UINT4": () => (/* binding */ T_UINT4),
/* harmony export */   "T_VERTEX_SHADER": () => (/* binding */ T_VERTEX_SHADER),
/* harmony export */   "T_VOID": () => (/* binding */ T_VOID),
/* harmony export */   "determBaseType": () => (/* binding */ determBaseType),
/* harmony export */   "determMostPreciseBaseType": () => (/* binding */ determMostPreciseBaseType),
/* harmony export */   "determTypePrecision": () => (/* binding */ determTypePrecision),
/* harmony export */   "findFunction": () => (/* binding */ findFunction),
/* harmony export */   "findTechnique": () => (/* binding */ findTechnique),
/* harmony export */   "findType": () => (/* binding */ findType),
/* harmony export */   "findVariable": () => (/* binding */ findVariable),
/* harmony export */   "hasTechnique": () => (/* binding */ hasTechnique),
/* harmony export */   "hasType": () => (/* binding */ hasType),
/* harmony export */   "hasVariable": () => (/* binding */ hasVariable),
/* harmony export */   "isBase": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBase),
/* harmony export */   "isBlendState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBlendState),
/* harmony export */   "isBoolBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType),
/* harmony export */   "isBuffer": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isBuffer),
/* harmony export */   "isDepthStencilState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isDepthStencilState),
/* harmony export */   "isFloatBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType),
/* harmony export */   "isFloatType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatType),
/* harmony export */   "isHalfBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType),
/* harmony export */   "isIntBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType),
/* harmony export */   "isIntegerType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntegerType),
/* harmony export */   "isMatrixType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isMatrixType),
/* harmony export */   "isPipelineState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isPipelineState),
/* harmony export */   "isRasterizerState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isRasterizerState),
/* harmony export */   "isSamplerState": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isSamplerState),
/* harmony export */   "isScalarType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType),
/* harmony export */   "isTexture": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isTexture),
/* harmony export */   "isUAV": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isUAV),
/* harmony export */   "isUintBasedType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType),
/* harmony export */   "isVectorType": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType),
/* harmony export */   "resolveRegister": () => (/* reexport safe */ _system_utils__WEBPACK_IMPORTED_MODULE_7__.resolveRegister),
/* harmony export */   "typePrecisionAsType": () => (/* binding */ typePrecisionAsType)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _system_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system/api */ "9ebs");
/* harmony import */ var _system_builtin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./system/builtin */ "OC3L");
/* harmony import */ var _system_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./system/matrix */ "L0DD");
/* harmony import */ var _system_scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./system/scalar */ "gzl7");
/* harmony import */ var _system_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./system/utils */ "BeyE");
/* harmony import */ var _system_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./system/vector */ "9oB0");










const scope = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.Scope({ type: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EScopeType.k_System });
(0,_system_scalar__WEBPACK_IMPORTED_MODULE_6__.addSystemTypeScalar)(scope);
(0,_system_vector__WEBPACK_IMPORTED_MODULE_8__.addSystemTypeVector)(scope);
(0,_system_matrix__WEBPACK_IMPORTED_MODULE_5__.addSystemTypeMatrix)(scope);
(0,_system_builtin__WEBPACK_IMPORTED_MODULE_4__.addSystemTypeBuiltin)(scope);
(0,_system_api__WEBPACK_IMPORTED_MODULE_3__.addSystemFunctions)(scope);
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
const findType = (typeName) => scope.findType(typeName);
const findVariable = (varName) => scope.findVariable(varName);
const findTechnique = (techName) => scope.findTechnique(techName);
const findFunction = (funcName, args) => scope.findFunction(funcName, args);
const hasType = (typeName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findType(typeName));
const hasVariable = (varName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findVariable(varName));
const hasTechnique = (techName) => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(scope.findTechnique(techName));
const SCOPE = scope;
const T_VOID = scope.findType("void");
const T_STRING = scope.findType("string");
const T_NULL = scope.findType("null_t");
const T_SAMPLER_STATE = scope.findType("SamplerState");
const T_BLEND_STATE = scope.findType("BlendState");
const T_DEPTH_STENCIL_STATE = scope.findType("DepthStencilState");
const T_FLOAT = scope.findType("float");
const T_FLOAT2 = scope.findType("float2");
const T_FLOAT3 = scope.findType("float3");
const T_FLOAT4 = scope.findType("float4");
const T_HALF = scope.findType("half");
const T_HALF2 = scope.findType("half2");
const T_HALF3 = scope.findType("half3");
const T_HALF4 = scope.findType("half4");
const T_FLOAT2X2 = scope.findType("float2x2");
const T_FLOAT2X3 = scope.findType("float2x3");
const T_FLOAT2X4 = scope.findType("float2x4");
const T_FLOAT3X2 = scope.findType("float3x2");
const T_FLOAT3X3 = scope.findType("float3x3");
const T_FLOAT3X4 = scope.findType("float3x4");
const T_FLOAT4X2 = scope.findType("float4x2");
const T_FLOAT4X3 = scope.findType("float4x3");
const T_FLOAT4X4 = scope.findType("float4x4");
const T_BOOL = scope.findType("bool");
const T_BOOL2 = scope.findType("bool2");
const T_BOOL3 = scope.findType("bool3");
const T_BOOL4 = scope.findType("bool4");
const T_BOOL2X2 = scope.findType("bool2x2");
const T_BOOL3X3 = scope.findType("bool3x3");
const T_BOOL4X4 = scope.findType("bool4x4");
const T_INT = scope.findType("int");
const T_INT2 = scope.findType("int2");
const T_INT3 = scope.findType("int3");
const T_INT4 = scope.findType("int4");
const T_UINT = scope.findType("uint");
const T_UINT2 = scope.findType("uint2");
const T_UINT3 = scope.findType("uint3");
const T_UINT4 = scope.findType("uint4");
const T_INT2X2 = scope.findType("int2x2");
const T_INT3X3 = scope.findType("int3x3");
const T_INT4X4 = scope.findType("int4x4");
// export const T_SAMPLER = scope.findType("sampler");
// export const T_SAMPLER_2D = scope.findType("sampler2D");
// export const T_SAMPLER_CUBE = scope.findType("samplerCUBE");
const T_VERTEX_SHADER = scope.findType("VertexShader");
const T_PIXEL_SHADER = scope.findType("PixelShader");
const T_COMPUTE_SHADER = scope.findType("ComputeShader");
const T_GEOMETRY_SHADER = scope.findType("GeometryShader");
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function determBaseType(type) {
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(type)) {
        return type;
    }
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(type) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isMatrixType)(type)) {
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType)(type)) {
            return T_FLOAT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType)(type)) {
            return T_INT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType)(type)) {
            return T_UINT;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType)(type)) {
            return T_HALF;
        }
        if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType)(type)) {
            return T_BOOL;
        }
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `cannot determ base type of ${type.name}`);
    return null;
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
var ETypePrecision;
(function (ETypePrecision) {
    ETypePrecision[ETypePrecision["k_Bool"] = 0] = "k_Bool";
    ETypePrecision[ETypePrecision["k_Uint"] = 1] = "k_Uint";
    ETypePrecision[ETypePrecision["k_Int"] = 2] = "k_Int";
    ETypePrecision[ETypePrecision["k_Half"] = 3] = "k_Half";
    ETypePrecision[ETypePrecision["k_Float"] = 4] = "k_Float";
    ETypePrecision[ETypePrecision["k_Unknown"] = NaN] = "k_Unknown";
})(ETypePrecision || (ETypePrecision = {}));
;
function determTypePrecision(type) {
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isFloatBasedType)(type))
        return ETypePrecision.k_Float;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isHalfBasedType)(type))
        return ETypePrecision.k_Half;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isIntBasedType)(type))
        return ETypePrecision.k_Int;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isUintBasedType)(type))
        return ETypePrecision.k_Uint;
    if ((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isBoolBasedType)(type))
        return ETypePrecision.k_Bool;
    return ETypePrecision.k_Unknown;
}
function typePrecisionAsType(precision) {
    switch (precision) {
        case ETypePrecision.k_Float: return T_FLOAT;
        case ETypePrecision.k_Half: return T_HALF;
        case ETypePrecision.k_Int: return T_INT;
        case ETypePrecision.k_Uint: return T_UINT;
        case ETypePrecision.k_Bool: return T_BOOL;
    }
    return null;
}
/**
 * Determining the most precise type of two types.
 * Type hierarchy:
 *  float => half => int => uint => bool
 */
function determMostPreciseBaseType(left, right) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(left) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(left));
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isScalarType)(right) || (0,_system_utils__WEBPACK_IMPORTED_MODULE_7__.isVectorType)(right));
    const type = typePrecisionAsType(Math.max(determTypePrecision(left), determTypePrecision(right)));
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type !== null, 'cannot determ base type');
    return type;
}


/***/ }),

/***/ "jbLw":
/*!***************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/expression.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expression": () => (/* binding */ expression)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "IP3g");



var expression;
(function (expression) {
    /**
     * unwind operation returns declaration in case of correct l-value expression;
     */
    function unwind(expr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
            return null;
        }
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PostfixPointExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PostfixIndexExpr:
                return unwind(expr.element);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IdExpr:
                return expr.decl;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_BitwiseExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ArithmeticExpr:
                // arithmetic expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_InitExpr:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'init expression doesn\'t support unwind operation');
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_AssignmentExpr:
                // todo: reseach how it work in HLSL
                //// assigment expression returns right-hand value;
                return unwind(expr.left);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr:
                // cast expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_UnaryExpr:
                // unary expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_RelationalExpr:
                // relation expression returns right-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ConstructorCallExpr:
                // ctor call expression is not allowed as l-value;
                // todo: allow it?
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexExpr:
                return unwind(expr.expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_StringExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_BoolExpr:
                // literal cannot be a left-hand value;
                return null;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionCallExpr:
                // function call expression returns right-hand value;
                return null;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, "unsupported expr found");
                return null;
        }
    }
    expression.unwind = unwind;
    function evalVal(val) {
        if (!val) {
            return 0;
        }
        if (_instruction__WEBPACK_IMPORTED_MODULE_2__.instruction.isLiteral(val)) {
            return val.value;
        }
        if (val.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr) {
            return evalConst(val.expr);
        }
        if (val.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IdExpr) {
            const idExpr = val;
            if (idExpr.decl.isGlobal()) { // and is constant?
                console.assert(idExpr.decl.initExpr.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_InitExpr);
                return evalConst(idExpr.decl.initExpr);
            }
        }
        return -1;
    }
    // simples possible evalator for minimal compartibility
    function evalConst(expr) {
        const val = evalVal(expr);
        if (val >= 0) {
            return val;
        }
        if (expr.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ArithmeticExpr) {
            console.error(`expr "${expr.toCode()}" could not be evaluated`);
            return -1;
        }
        const { left, right, operator } = expr;
        const lval = evalConst(left);
        const rval = evalConst(right);
        if (lval >= 0 && rval >= 0) {
            switch (operator) {
                // todo: use round ? check if integers only
                case '*': return rval * lval;
                case '/': return rval / lval;
                case '+': return rval + lval;
                case '-': return rval - lval;
                default:
                    console.error('unsupported operator');
            }
        }
        console.error(`expr "${expr.toCode()}" could not be evaluated`);
        return -1;
    }
    expression.evalConst = evalConst;
})(expression || (expression = {}));


/***/ }),

/***/ "zoki":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/helpers/fn.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fn": () => (/* binding */ fn)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");


var fn;
(function (fn) {
    function signatureParam(param, strong) {
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.signature(param.type, strong)}${param.initExpr ? '?' : ''}`;
    }
    function signature(def, strong = false) {
        const { name, params } = def;
        return `${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signature = signature;
    function signatureEx(def, strong = false) {
        const { name, returnType, params } = def;
        return `${_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.signature(returnType, strong)} ${name}(${params.map(param => signatureParam(param, strong)).join(', ')})`;
    }
    fn.signatureEx = signatureEx;
    function numArgsRequired(def) {
        return def.params.filter((param) => !param || !param.initExpr).length;
    }
    fn.numArgsRequired = numArgsRequired;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function match(def, args, strong = false) {
        if (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(args)) {
            return true;
        }
        if (args.length > def.params.length || numArgsRequired(def) > args.length) {
            return false;
        }
        return args.every((arg, i) => (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(arg)) ||
            (!strong && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(def.params[i].type)) ||
            _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.equals(arg, def.params[i].type, strong));
    }
    fn.match = match;
    /**
     * Find function by name and list of types.
     * returns:
     *   'null' if there is no requested function;
     *   'undefined' if there more then one function;
     *    function if all is ok;
     */
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function matchList(funcList, args, strong = false) {
        if (!funcList) {
            return null;
        }
        const res = funcList.filter(func => fn.match(func.def, args, strong));
        if (res.length > 1) {
            return undefined;
        }
        if (res.length === 1) {
            return res[0];
        }
        return null;
    }
    fn.matchList = matchList;
})(fn || (fn = {}));


/***/ }),

/***/ "pEQR":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expression": () => (/* reexport safe */ _expression__WEBPACK_IMPORTED_MODULE_0__.expression),
/* harmony export */   "fn": () => (/* reexport safe */ _fn__WEBPACK_IMPORTED_MODULE_1__.fn),
/* harmony export */   "instruction": () => (/* reexport safe */ _instruction__WEBPACK_IMPORTED_MODULE_2__.instruction),
/* harmony export */   "types": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.types),
/* harmony export */   "variable": () => (/* reexport safe */ _variable__WEBPACK_IMPORTED_MODULE_4__.variable)
/* harmony export */ });
/* harmony import */ var _expression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression */ "jbLw");
/* harmony import */ var _fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fn */ "zoki");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction */ "IP3g");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "7MAr");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variable */ "9MfH");







/***/ }),

/***/ "IP3g":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/instruction.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "instruction": () => (/* binding */ instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");

var instruction;
(function (instruction) {
    instruction.UNDEFINE_LENGTH = 0xffffff;
    instruction.UNDEFINE_SIZE = 0xffffff;
    instruction.UNDEFINE_PADDING = 0xffffff;
    instruction.UNDEFINE_NAME = "undef";
    function isExpression(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_InitExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ComplexExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CastExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_UnaryExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_RelationalExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_LogicalExpr:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isExpression = isExpression;
    function isStatement(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Stmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IfStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ExprStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SemicolonStmt:
                // todo: add other types!!!
                return true;
        }
        return false;
    }
    instruction.isStatement = isStatement;
    function isLiteral(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IntExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FloatExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BoolExpr:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StringExpr:
                return true;
        }
        return false;
    }
    instruction.isLiteral = isLiteral;
})(instruction || (instruction = {}));


/***/ }),

/***/ "7MAr":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/helpers/types.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "types": () => (/* binding */ types)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instruction */ "IP3g");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variable */ "9MfH");





var types;
(function (types) {
    // todo: rename it
    /** @deprecated */
    function isInheritedFromVariableDecl(type) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type.parent)) {
            return false;
        }
        const parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            return true;
        }
        else if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType) {
            return isInheritedFromVariableDecl(type.parent);
        }
        return false;
    }
    types.isInheritedFromVariableDecl = isInheritedFromVariableDecl;
    /** @deprecated */
    function isTypeOfField(type) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(type.parent)) {
            return false;
        }
        if (type.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            let pParentDecl = type.parent;
            return pParentDecl.isField();
        }
        return false;
    }
    types.isTypeOfField = isTypeOfField;
    /** @deprecated */
    function findParentContainer(type) {
        if (!isInheritedFromVariableDecl(type) || !isTypeOfField(type)) {
            return null;
        }
        let containerType = findParentVariableDecl(type).parent;
        if (!isInheritedFromVariableDecl(containerType)) {
            return null;
        }
        return findParentVariableDecl(containerType);
    }
    types.findParentContainer = findParentContainer;
    /** @deprecated */
    function findParentVariableDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl) {
            return type.parent;
        }
        return findParentVariableDecl(type.parent);
    }
    types.findParentVariableDecl = findParentVariableDecl;
    /** @deprecated */
    function findParentVariableDeclName(type) {
        let varDecl = findParentVariableDecl(type);
        return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(varDecl) ? null : varDecl.name;
    }
    types.findParentVariableDeclName = findParentVariableDeclName;
    /** @deprecated */
    function finParentTypeDecl(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        let parentType = type.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypeDecl) {
            return type.parent;
        }
        return finParentTypeDecl(type.parent);
    }
    types.finParentTypeDecl = finParentTypeDecl;
    /** @deprecated */
    function finParentTypeDeclName(type) {
        let typeDecl = finParentTypeDecl(type);
        return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(typeDecl) ? null : typeDecl.name;
    }
    types.finParentTypeDeclName = finParentTypeDeclName;
    /** @deprecated */
    function resolveVariableDeclFullName(type) {
        if (!isInheritedFromVariableDecl(type)) {
            console.error("Not from variable decl");
            return null;
        }
        return _variable__WEBPACK_IMPORTED_MODULE_4__.variable.fullName(findParentVariableDecl(type));
    }
    types.resolveVariableDeclFullName = resolveVariableDeclFullName;
    // todo: add comment
    // todo: review this code
    /** @deprecated */
    function findMainVariable(type) {
        if (!isInheritedFromVariableDecl(type)) {
            return null;
        }
        if (isTypeOfField(type)) {
            return findMainVariable(type.parent.parent);
        }
        return findParentVariableDecl(type);
    }
    types.findMainVariable = findMainVariable;
    //
    // Signatures
    //
    function signatureVType(vtype, strong) {
        let prefix = '';
        if (strong) {
            if (vtype.usages.length > 0) {
                prefix = `${vtype.usages.join('_')}_`;
            }
        }
        let postfix = '';
        if (vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        // skip all variable type wrappers
        // is it safe?
        let subType = vtype.subType;
        while (subType.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType)
            subType = subType.subType;
        return `${prefix}${signature(subType)}${postfix}`;
    }
    // function signatureVTypeRelaxed(vtype: IVariableTypeInstruction)
    function signature(type, strong = false) {
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__.isDefAndNotNull)(type)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!strong);
            return '*';
        }
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType:
                return signatureVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType:
                return `${type.name}${type.instructionID}`;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType:
                return type.baseType ? signature(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType:
                return type.name;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported type');
                return null;
        }
    }
    types.signature = signature;
    // export function relaxType(type: ITypeInstruction): ITypeInstruction | RegExp {
    //     if (!type) {
    //         return null;
    //     }
    //     if (types.equals(type, T_INT) || types.equals(type, T_UINT)) {
    //         // temp workaround in order to match int to uint and etc. 
    //         return /^int$|^uint$/g;
    //     }
    //     return type;
    // }
    // // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    // export function asRelaxedType(instr: ITypedInstruction): ITypeInstruction | RegExp {
    //     if (!instr) {
    //         return null;
    //     }
    //     return relaxType(instr.type);
    // };
    //
    // hash
    //
    function hashVType(vtype, strong) {
        let postfix = '';
        if (strong ? vtype.isArray() : vtype.isNotBaseArray()) {
            postfix = '[]';
            if (vtype.length !== _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                postfix = `[${vtype.length}]`;
            }
        }
        return `${hash(vtype.subType)}${postfix}`;
    }
    function hashComplex(ctype, strong) {
        return `{${ctype.fields.map(field => hash(field.type, strong)).join(';')}}`;
    }
    function hash(type, strong = false) {
        switch (type.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType:
                return hashVType(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType:
                return hashComplex(type, strong);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType:
                return type.baseType ? hash(type.baseType) : type.name;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType:
                return type.name;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported type');
                return null;
        }
    }
    types.hash = hash;
    function compareRelaxed(a, b, strong = false) {
        return hash(a, strong) === hash(b, strong);
    }
    types.compareRelaxed = compareRelaxed;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function compare(a, b, strong = false) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(a) || (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(b)) {
            return false;
        }
        if (a instanceof RegExp && b instanceof RegExp) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
            return false;
        }
        if (a instanceof RegExp) {
            let ra = a;
            let sb = signature(b, strong);
            return !!sb.match(ra);
        }
        if (b instanceof RegExp) {
            let sa = signature(a, strong);
            let rb = b;
            return !!sa.match(rb);
        }
        let ta = a;
        let tb = b;
        if (ta.isArray() && tb.isArray()) {
            if (ta.length === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH ||
                tb.length === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_LENGTH) {
                // wnen both types are undefined is valid 
                if (ta.length !== tb.length) {
                    return false;
                }
            }
        }
        return signature(ta, strong) === signature(tb, strong);
    }
    types.compare = compare;
    // FIXME: refuse from the regular expressions in favor of a full typecasting graph
    function equals(a, b, strong = false) {
        return compare(a, b, strong);
    }
    types.equals = equals;
    //
    // utils
    //
    function alignSize(size, aligment) {
        if (size === _instruction__WEBPACK_IMPORTED_MODULE_3__.instruction.UNDEFINE_SIZE) {
            return size;
        }
        const unaligned = size % aligment;
        return unaligned !== 0 ? size + aligment - unaligned : size;
    }
    types.alignSize = alignSize;
})(types || (types = {}));


/***/ }),

/***/ "9MfH":
/*!*************************************************!*\
  !*** ./src/lib/fx/analisys/helpers/variable.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "variable": () => (/* binding */ variable)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "7MAr");



var variable;
(function (variable) {
    /**
     * @param decl Variable declaraion (decl.isParameter() must be true).
     * @returns Serial number of the declaration among the function parameters or -1 otherwise.
     */
    function parameterIndex(decl) {
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return -1;
        }
        // all parameters must be a children on function definition!
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(decl.parent.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionDef);
        return decl.parent.params.indexOf(decl);
    }
    variable.parameterIndex = parameterIndex;
    /**
     * @returns Offset in bytes from the beginning of the parameters' list.
     */
    function parameterOffset(decl) {
        // todo: add support for 'inout', 'out' usages 
        if (!decl.isParameter()) {
            console.error('invalid call.');
            return 0;
        }
        let idx = parameterIndex(decl);
        let offset = 0;
        for (let i = 0; i < idx; ++i) {
            offset += decl.parent.params[i].type.size;
        }
        return offset;
    }
    variable.parameterOffset = parameterOffset;
    /**
     * Helper:
     *  Returns 'structName.fieldName' for structs;
     *  Returns 'varName' for variables;
     */
    function fullName(decl) {
        if (decl.isField() &&
            _types__WEBPACK_IMPORTED_MODULE_2__.types.findParentVariableDecl(decl.parent)) {
            let name = '';
            let parentType = decl.parent.instructionType;
            if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType) {
                name = _types__WEBPACK_IMPORTED_MODULE_2__.types.resolveVariableDeclFullName(decl.parent);
            }
            name += '.' + decl.name;
            return name;
        }
        return decl.name;
    }
    variable.fullName = fullName;
})(variable || (variable = {}));


/***/ }),

/***/ "0qyf":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AnnotationInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationInstruction": () => (/* binding */ AnnotationInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class AnnotationInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ decls, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Annotation, ...settings });
        this.decls = decls;
    }
}


/***/ }),

/***/ "+tx1":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ArithmeticExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArithmeticExprInstruction": () => (/* binding */ ArithmeticExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr + / - * % someExpr
 * (+|-|*|/|%) Instruction Instruction
 */
class ArithmeticExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ArithmeticExpr, ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var sCode = "";
        sCode += this._leftOperand.toCode();
        sCode += ` ${this.operator} `;
        sCode += this._rightOperand.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() && this.right.isConst();
    }
}


/***/ }),

/***/ "eck/":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AssignmentExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssignmentExprInstruction": () => (/* binding */ AssignmentExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr = += -= /= *= %= someExpr
 * (=|+=|-=|*=|/=|%=) Instruction Instruction
 */
class AssignmentExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_AssignmentExpr, type: left.type, ...settings });
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = "";
        code += this.left.toCode();
        code += this.operator;
        code += this.right.toCode();
        return code;
    }
}


/***/ }),

/***/ "rs/O":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/AttributeInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeInstruction": () => (/* binding */ AttributeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


/**
 * Represent attributes:
 *  [numthreads(1, 2, 3)]
 *  [loop]
 *  [branch]
 */
class AttributeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ name, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Attribute, ...settings });
        this.name = name;
        this.args = args;
    }
    toCode() {
        return `[${this.name}${this.args.length > 0 ? `(${this.args.map(arg => arg.toCode()).join(', ')})` : ``}]`;
    }
}


/***/ }),

/***/ "l236":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BitwiseExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitwiseExprInstruction": () => (/* binding */ BitwiseExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr >> << | & ^ someExpr
 * (>>,<<,|,&,^) Instruction Instruction
 */
class BitwiseExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BitwiseExpr, ...settings });
        this.left = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(left, this);
        this.right = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(right, this);
        this.operator = operator;
    }
    toCode() {
        return `${this.left.toCode()} ${this.operator} ${this.right.toCode()}`;
    }
    // FIXME: use isConstExpr instead!
    isConst() {
        return this.left.isConst() && this.right.isConst();
    }
}


/***/ }),

/***/ "d+t4":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BoolInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoolInstruction": () => (/* binding */ BoolInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class BoolInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_BoolExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_BOOL, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return this.value ? "true" : "false";
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "t33R":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/BreakStmtInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BreakStmtInstruction": () => (/* binding */ BreakStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "pGoc");


/**
 * Reprsernt continue; break; discard;
 * (continue || break || discard)
 */
class BreakStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ operator = "break", ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_BreakStmt, ...settings });
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    // todo: validate operator's name
    toCode() {
        console.assert(this.operator == "break");
        return this.operator + ";";
    }
}


/***/ }),

/***/ "KHnE":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CastExprInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CastExprInstruction": () => (/* binding */ CastExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represent (type) expr
 * EMPTY_OPERATOR VariableTypeInstruction Instruction
 */
class CastExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ sourceExpr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_CastExpr, ...settings });
        this.expr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(sourceExpr, this);
    }
    toCode() {
        return `(${this.type.toCode()})(${this.expr.toCode()})`;
    }
    /** @deprecated */
    isUseless() {
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.equals(this.type, this.expr.type);
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "r+W1":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CbufferInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CbufferInstruction": () => (/* binding */ CbufferInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class CbufferInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ id, type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CbufferDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(id, this);
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(type, this);
    }
    get id() {
        return this._id;
    }
    get name() {
        return this.id.name;
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "MV/g":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CompileExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileExprInstruction": () => (/* binding */ CompileExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");


/**
 * Represents compile vs_func(...args)
 * compile IdExprInstruction ExprInstruction ... ExprInstruction
 */
/** @deprecated */
class CompileExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ operand, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileExpr, ...settings });
        this._operand = operand; //Instruction.$withParent(operand, this);
        this._args = args; //(args || []).map(arg => Instruction.$withParent(arg, this));
    }
    get function() {
        return this._operand;
    }
    get args() {
        return this._args;
    }
}


/***/ }),

/***/ "Ugh4":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/CompileShader11Instruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileShader11Instruction": () => (/* binding */ CompileShader11Instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represents CompileShader( vs_4_0_level_9_1, RenderSceneVS( 1, true, true ) )
 */
class CompileShader11Instruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ ver, func, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_CompileShader11Expr, ...settings });
        this.func = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withNoParent(func);
        this.ver = ver;
        this.args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
    }
}


/***/ }),

/***/ "RRea":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComplexExprInstruction": () => (/* binding */ ComplexExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent (expr)
 * EMPTY_OPERATOR ExprInstruction
 */
class ComplexExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexExpr, type: expr.type, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return "(" + this.expr.toCode() + ")";
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "G0Ba":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ComplexTypeInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComplexTypeInstruction": () => (/* binding */ ComplexTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "pEQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// todo: merge with system tpye ?
class ComplexTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ name = null, fields, aligment = 1 /* byte */, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType, ...settings });
        this._name = name;
        this._fields = {};
        this._aligment = aligment;
        this.addFields(fields.filter(field => !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(field)).map(field => _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(field, this)));
    }
    get writable() {
        return true;
    }
    get readable() {
        return true;
    }
    get name() {
        return this._name;
    }
    get size() {
        return this.calculatePaddings(false);
    }
    get aligment() {
        return this._aligment;
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return 0;
    }
    get fields() {
        return Object.values(this._fields);
    }
    get methods() {
        return [];
    }
    toString() {
        return this.name || _helpers__WEBPACK_IMPORTED_MODULE_2__.types.hash(this);
    }
    /** @deprecated */
    toDeclString() {
        var code = "struct " + this._name + "{";
        for (var i = 0; i < this.fields.length; i++) {
            code += "\t" + this.fields[i].toCode() + ";\n";
        }
        code += "}";
        return code;
    }
    toCode() {
        return this._name;
    }
    isArray() {
        return false;
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return true;
    }
    addField(variable) {
        this._fields[variable.name] = variable;
    }
    addFields(fields) {
        for (var i = 0; i < fields.length; i++) {
            this.addField(fields[i]);
        }
        this.calculatePaddings();
    }
    hasFieldWithSematics(semantic) {
        return !!this.getFieldBySemantics(semantic);
    }
    getField(fieldName) {
        return this._fields[fieldName] || null;
    }
    getMethod(methodName, args) {
        return null;
    }
    getFieldBySemantics(semantic) {
        for (let i in this._fields) {
            let field = this._fields[i];
            if (semantic == field.semantic) {
                return field;
            }
        }
        return null;
    }
    hasFieldWithoutSemantics() {
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if (semantic == null || semantic == '') {
                return true;
            }
            if (field.type.hasFieldWithoutSemantics()) {
                return true;
            }
        }
        return false;
    }
    hasAllUniqueSemantics() {
        let fieldBySemantics = {};
        for (let i in this._fields) {
            let field = this._fields[i];
            let semantic = field.semantic;
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(fieldBySemantics[semantic])) {
                return false;
            }
            fieldBySemantics[semantic] = field;
            if (field.type.isComplex() && !field.type.hasAllUniqueSemantics()) {
                return false;
            }
        }
        return true;
    }
    calculatePaddings(override = true) {
        const aligment = this._aligment;
        let padding = 0;
        let aligned = (offset, align) => (offset + (align - 1)) & ~(align - 1);
        for (let i = 0; i < this.fields.length; i++) {
            const varType = this.fields[i].type;
            const varSize = varType.size;
            if (varSize === _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'cannot calc padding');
                return _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE;
            }
            let a = aligned(padding, aligment);
            let b = aligned(padding + varSize, aligment);
            if (b > a) {
                padding = a;
            }
            if (override)
                varType.$overwritePadding(padding, aligment);
            padding += varSize;
        }
        return aligned(padding, aligment);
    }
}


/***/ }),

/***/ "IsZF":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConditionalExprInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConditionalExprInstruction": () => (/* binding */ ConditionalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represen boolExpr ? someExpr : someExpr
 * EMPTY_OPERATOR Instruction Instruction Instruction
 */
class ConditionalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ cond, left, right, ...settings }) {
        // todo: do not use {left.type} here
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConditionalExpr, type: left.type, ...settings });
        console.assert(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, right.type));
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(cond, this);
        this._leftValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(left, this);
        this._rightValue = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(right, this);
    }
    get condition() {
        return this._cond;
    }
    get left() {
        return this._leftValue;
    }
    get right() {
        return this._rightValue;
    }
    toCode() {
        var code = '(';
        code += this.condition.toCode();
        code += '?';
        code += this.left.toCode();
        code += ':';
        code += this.right.toCode();
        code += ')';
        return code;
    }
    isConst() {
        return this.condition.isConst() &&
            this.left.isConst();
    }
}


/***/ }),

/***/ "RIdR":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ConstructorCallInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructorCallInstruction": () => (/* binding */ ConstructorCallInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Resresnt ctor(arg1,..., argn)
 * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction
 */
class ConstructorCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ ctor, args = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ConstructorCallExpr, type: ctor.subType, ...settings });
        this._args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
        this._ctor = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(ctor, this);
    }
    get args() {
        return this._args;
    }
    get ctor() {
        return this._ctor;
    }
    toCode() {
        var code = "";
        code += this.ctor.toCode();
        code += "(";
        for (var i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        for (var i = 0; i < this.args.length; i++) {
            if (!this.args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
}


/***/ }),

/***/ "0xZW":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeclInstruction": () => (/* binding */ DeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class DeclInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ semantic = null, annotation = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Decl, ...settings });
        this._semantic = semantic;
        this._annotation = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(annotation, this);
    }
    get semantic() {
        return this._semantic;
    }
    get annotation() {
        return this._annotation;
    }
    get name() {
        return null;
    }
    get id() {
        return null;
    }
}


/***/ }),

/***/ "YZc1":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/DeclStmtInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeclStmtInstruction": () => (/* binding */ DeclStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent TypeDecl or VariableDecl or VarStructDecl
 * EMPTY DeclInstruction
 */
class DeclStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ declList = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DeclStmt, ...settings });
        this._declList = (declList || []).map(decl => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(decl, this));
    }
    get declList() {
        return this._declList;
    }
    toCode() {
        var code = '';
        var declList = this.declList;
        for (var i = 0; i < this.declList.length; i++) {
            code += declList[i].toCode() + ";\n";
        }
        return code;
    }
}


/***/ }),

/***/ "nqRf":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExprInstruction": () => (/* binding */ ExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/TypedInstruction */ "jSFO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");


class ExprInstruction extends _lib_fx_analisys_instructions_TypedInstruction__WEBPACK_IMPORTED_MODULE_0__.TypedInstruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Expr, ...settings });
        this._evalResult = null;
    }
    get type() {
        return super.type;
    }
    isConst() {
        // console.error("@pure_virtual");
        return false;
    }
    isConstExpr() {
        // todo: implement it properly
        return true;
    }
}


/***/ }),

/***/ "ubxH":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ExprStmtInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExprStmtInstruction": () => (/* binding */ ExprStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtInstruction */ "pGoc");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent expr;
 * EMPTY_OPERTOR ExprInstruction
 */
class ExprStmtInstruction extends _lib_fx_analisys_instructions_StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ expr, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ExprStmt, ...settings });
        this._expr = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_0__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        return (this._expr ? this._expr.toCode() : '') + ';';
    }
}


/***/ }),

/***/ "OsKO":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FloatInstruction.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatInstruction": () => (/* binding */ FloatInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class FloatInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_FloatExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.value = value;
    }
    toString() {
        return String(this.value);
    }
    toCode() {
        return `${this.value}${this.value % 1 === 0 ? '.' : ''}`;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "r82U":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ForStmtInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ForStmtInstruction": () => (/* binding */ ForStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent for(forInit forCond ForStep) stmt
 * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
 */
class ForStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ init = null, cond = null, step = null, body = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ForStmt, ...settings });
        this._init = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(init, this);
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(cond, this);
        this._step = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(step, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(body, this);
    }
    get init() {
        return this._init;
    }
    get cond() {
        return this._cond;
    }
    get step() {
        return this._step;
    }
    get body() {
        return this._body;
    }
    toCode() {
        var code = "for(";
        code += this._init.toCode() + ";";
        code += this._cond.toCode() + ";";
        code += this._step.toCode() + ")";
        code += this._body.toCode();
        return code;
    }
}


/***/ }),

/***/ "y57x":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionCallInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionCallInstruction": () => (/* binding */ FunctionCallInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Respresnt func(arg1,..., argn)
 * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction
 */
class FunctionCallInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ decl, args, callee, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionCallExpr, ...settings });
        this.callee = callee;
        this.args = (args || []).map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(arg, this));
        this.decl = decl;
    }
    toCode() {
        const { callee, decl: { def }, args } = this;
        return `${callee ? callee.toCode() + '.' : ''}${def.id.toCode()}(${args.map(arg => arg.toCode()).join(',')})`;
    }
}


/***/ }),

/***/ "BLpd":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDeclInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionDeclInstruction": () => (/* binding */ FunctionDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
 * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
 */
class FunctionDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ def, impl = null, attrs = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_FunctionDecl, ...settings });
        this.def = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(def, this);
        this.impl = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(impl, this);
        this.attrs = (attrs || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(attr, this));
    }
    get name() {
        return this.def.name;
    }
    get id() {
        return this.def.id;
    }
    get semantic() {
        return this.def.semantic;
    }
    toCode() {
        let code = '';
        code += this.def.toCode();
        if (this.impl) {
            code += this.impl.toCode();
        }
        else {
            code += ';';
        }
        return code;
    }
}


/***/ }),

/***/ "O1LO":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/FunctionDefInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionDefInstruction": () => (/* binding */ FunctionDefInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/DeclInstruction */ "0xZW");
/* harmony import */ var _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/Instruction */ "hbjL");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");




/**
 * Represent type func(...args)[:Semantic]
 * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
 */
class FunctionDefInstruction extends _lib_fx_analisys_instructions_DeclInstruction__WEBPACK_IMPORTED_MODULE_0__.DeclInstruction {
    constructor({ returnType, id, paramList = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionDef, ...settings });
        this.params = paramList.map(param => _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(param, this));
        this.returnType = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(returnType, this);
        this._id = _lib_fx_analisys_instructions_Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(id, this);
    }
    get id() {
        return this._id;
    }
    get name() {
        return this._id.name;
    }
    toString() {
        let def = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.signature(this.returnType) + " " + this.name + "(";
        for (let i = 0; i < this.params.length; i++) {
            def += _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.signature(this.params[i].type) + ",";
        }
        def += ")";
        // TODO: add semantic
        return def;
    }
    toCode() {
        const { _id: id, returnType, params } = this;
        return `${returnType.toCode()} ${id.toCode()}(${params.map(param => param.toCode()).join(', ')})`;
    }
}


/***/ }),

/***/ "kBTl":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdExprInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IdExprInstruction": () => (/* binding */ IdExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class IdExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ id, decl, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_IdExpr, type: decl.type, ...settings });
        this.id = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(id, this);
        this.decl = decl;
    }
    get name() {
        return this.id.name;
    }
    isConst() {
        return this.type.isConst();
    }
    toCode() {
        return this.decl.id.toCode();
    }
}


/***/ }),

/***/ "Muaz":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IdInstruction.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IdInstruction": () => (/* binding */ IdInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class IdInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ name, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Id, ...settings });
        this.name = name;
    }
    toString() {
        return this.name;
    }
    toCode() {
        return this.name;
    }
}


/***/ }),

/***/ "AAir":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IfStmtInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IfStmtInstruction": () => (/* binding */ IfStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");




/**
 * Represent if(expr) stmt or if(expr) stmt else stmt
 * ( if || if_else ) Expr Stmt [Stmt]
 */
class IfStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_3__.StmtInstruction {
    constructor({ cond, conseq, attrs = null, contrary = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_IfStmt, ...settings });
        this.cond = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(cond, this);
        this.conseq = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(conseq, this);
        this.contrary = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(contrary, this);
        this.attrs = (attrs || []).map(attr => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(attr, this));
    }
    toCode() {
        var code = "";
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.contrary)) {
            code += "if(";
            code += this.cond.toCode() + ")";
            code += this.conseq.toCode();
        }
        else {
            code += "if(";
            code += this.cond.toCode() + ") ";
            code += this.conseq.toCode();
            code += "else ";
            code += this.contrary.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ "lavR":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InitExprInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InitExprInstruction": () => (/* binding */ InitExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "hbjL");






class InitExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_4__.ExprInstruction {
    constructor({ type, args = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr, type, ...settings });
        this._args = args.map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withParent(arg, this));
    }
    get args() {
        return this._args;
    }
    isArray() {
        return this.type.isNotBaseArray();
    }
    toCode() {
        let code = '';
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.type)) {
            code += this.type.toCode();
        }
        code += "(";
        for (let i = 0; i < this.args.length; i++) {
            code += this.args[i].toCode();
            if (i !== this.args.length - 1) {
                code += ",";
            }
        }
        code += ")";
        return code;
    }
    isConst() {
        let bConst;
        let args = this.args;
        for (let i = 0; i < args.length; i++) {
            if (!args[i].isConst()) {
                return false;
            }
        }
        return true;
    }
    /**
     *
     * @param type The type of the variable for which the initializer was created.
     */
    // TODO: move it to Analysis.ts
    optimizeForVariableType(type) {
        // It's a global user defined array or just not unit array;
        // Trying to exclude types like float1.
        if ((type.isNotBaseArray() && type.scope.type <= _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EScopeType.k_Global) ||
            (type.isArray() && this.args.length > 1)) {
            if (type.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH ||
                (type.isNotBaseArray() && this.args.length !== type.length) ||
                (!type.isNotBaseArray() && this.args.length !== type.baseType.length)) {
                return false;
            }
            let arrayElementType = type.arrayElementType;
            for (let i = 0; i < this.args.length; i++) {
                let testedInstruction = this.args[i];
                if (testedInstruction.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr) {
                    if (!testedInstruction.optimizeForVariableType(arrayElementType)) {
                        return false;
                    }
                }
                else {
                    // if (SystemScope.isSamplerType(arrayElementType)) {
                    //     if (testedInstruction.instructionType !== EInstructionTypes.k_SamplerStateBlockExpr) {
                    //         return false;
                    //     }
                    // }
                    // else 
                    {
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(testedInstruction.type, arrayElementType)) {
                            return false;
                        }
                    }
                }
            }
            this._type = type.baseType;
            return true;
        }
        else {
            let firstInstruction = this.args[0];
            if (this.args.length === 1 &&
                firstInstruction.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr) {
                // if (SystemScope.isSamplerType(type)) {
                //     if (firstInstruction.instructionType === EInstructionTypes.k_SamplerStateBlockExpr) {
                //         return true;
                //     }
                //     else {
                //         return false;
                //     }
                // }
                // TODO: remove this hack!!
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT)) {
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT)) {
                        return true;
                    }
                }
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(firstInstruction.type, type)) {
                    return true;
                }
                return false;
            }
            else if (this.args.length === 1) {
                return false;
            }
            let args = this.args;
            let fieldNameList = type.fields.map(f => f.name);
            for (let i = 0; i < args.length; i++) {
                let fieldType = type.getField(fieldNameList[i]).type;
                if (!args[i].optimizeForVariableType(fieldType)) {
                    return false;
                }
            }
            this._type = type.baseType;
            return true;
        }
    }
}


/***/ }),

/***/ "hbjL":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Instruction.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Instruction": () => (/* binding */ Instruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");


class Instruction {
    constructor({ scope, instrType /* = EInstructionTypes.k_Instruction*/, sourceNode = null, visible = true }) {
        this._sourceNode = sourceNode;
        this._instructionType = instrType;
        this._instructionID = (Instruction.INSTRUCTION_COUNTER++);
        this._scope = scope;
        this._parent = null;
        this._lastError = null;
    }
    get parent() {
        // console.assert(this._parent, "Parent is not defined!");
        return this._parent;
    }
    get instructionType() {
        console.assert(this._instructionType != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Instruction, "Instruction type 'k_Instruction' is forbidden.");
        return this._instructionType;
    }
    get instructionName() {
        return _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes[this.instructionType];
    }
    get instructionID() {
        return this._instructionID;
    }
    get scope() {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._scope)) {
            return this._scope;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent)) {
            return this.parent.scope;
        }
        return null;
    }
    get sourceNode() {
        return this._sourceNode;
    }
    toString() {
        console.error("@pure_virtual");
        return null;
    }
    toCode() {
        console.error("@pure_virtual");
        return null;
    }
    $withParent(parent) {
        console.assert(this._parent == null, "parent redefenition detected!");
        if (this.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType && this.name === 'float' && this._parent == null && parent != null) {
            debugger;
        }
        this._parent = parent;
        // todo: remove this hack!
        return this;
    }
    // An auxiliary function created to maintain the clarity of the code.
    $withNoParent() {
        return this;
    }
    static $withParent(child, parent) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(child)) {
            return null;
        }
        return child.$withParent(parent);
    }
    static $withNoParent(child) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(child)) {
            return null;
        }
        return child.$withNoParent();
    }
}
Instruction.INSTRUCTION_COUNTER = 0;


/***/ }),

/***/ "pjXG":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/InstructionCollector.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionCollector": () => (/* binding */ InstructionCollector)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class InstructionCollector extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ instructions = [], ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Collector, ...settings });
        this._instructions = instructions;
    }
    get instructions() {
        return this._instructions;
    }
    push(instr) {
        this._instructions.push(instr);
    }
    toCode() {
        let code = "";
        for (const instr of this.instructions) {
            switch (instr.instructionType) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_VariableDecl:
                    code += instr.toCode() + ';\n';
                    break;
                default:
                    code += instr.toCode() + '\n';
            }
        }
        return code;
    }
}


/***/ }),

/***/ "s0og":
/*!************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/IntInstruction.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntInstruction": () => (/* binding */ IntInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class IntInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ base, signed, exp, heximal = false, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_IntExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes 
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(signed ? _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT : _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_UINT, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this.base = base;
        this.exp = exp;
        this.signed = signed;
        this.heximal = heximal;
        if (!signed) {
            this.base >>>= 0;
        }
    }
    get value() {
        return (this.base * Math.pow(10, this.exp));
    }
    toString() {
        return `${this.heximal ? '0x' : ''}${this.base.toString(this.heximal ? 16 : 10).toUpperCase()}${this.exp !== 0 ? `e${this.exp}` : ''}${this.signed ? '' : 'u'}`;
    }
    toCode() {
        return this.toString();
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "Oxvu":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/LogicalExprInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogicalExprInstruction": () => (/* binding */ LogicalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * Represent boolExpr && || boolExpr
 * (&& | ||) Instruction Instruction
 */
class LogicalExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ left, right, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_LogicalExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.T_BOOL, ...settings });
        this._leftOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(left, this);
        this._rightOperand = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(right, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    toCode() {
        var sCode = "";
        sCode += this.left.toCode();
        sCode += this.operator;
        sCode += this.right.toCode();
        return sCode;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "a5rM":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/NullInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullInstruction": () => (/* binding */ NullInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



class NullInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_NullExpr, type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_NULL, scope, ...settings });
    }
    get value() {
        return null;
    }
    toString() {
        return `NULL`;
    }
    toCode() {
        return this.toString();
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "Z/0D":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PassInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PassInstruction": () => (/* binding */ PassInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction */ "hbjL");






class PassInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_4__.DeclInstruction {
    constructor({ id = null, vertexShader = null, pixelShader = null, renderStates = {}, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_PassDecl, ...settings });
        this._passStateMap = {};
        PassInstruction.clearRenderStateMap(this._passStateMap);
        PassInstruction.copyRenderStateMap(renderStates, this._passStateMap);
        this._vertexShader = _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withNoParent(vertexShader);
        this._pixelShader = _Instruction__WEBPACK_IMPORTED_MODULE_5__.Instruction.$withNoParent(pixelShader);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    get name() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._id)) {
            return null;
        }
        return this._id.name;
    }
    get vertexShader() {
        return this._vertexShader;
    }
    get pixelShader() {
        return this._pixelShader;
    }
    getState(state) {
        return this._passStateMap[state];
    }
    get renderStates() {
        return this._passStateMap;
    }
    // TODO: move it to helpers
    static copyRenderStateMap(from, to) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(from)) {
            return;
        }
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates)
            .filter(k => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k])
            .forEach(rs => { to[rs] = from[rs] || to[rs]; });
    }
    // TODO: move it to helpers
    static clearRenderStateMap(map) {
        Object
            .keys(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates)
            .filter(k => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k]))
            .map(k => _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_1__.ERenderStates[k])
            .forEach(rs => { map[rs] = _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_2__.ERenderStateValues.UNDEF; });
    }
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "fxHi":
/*!**************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixArithmeticInstruction.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixArithmeticInstruction": () => (/* binding */ PostfixArithmeticInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr ++
 * (-- | ++) Instruction
 */
class PostfixArithmeticInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ expr, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixArithmeticExpr, type: expr.type, ...settings });
        this._operator = operator;
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(expr, this);
    }
    get expr() {
        return this._expr;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.expr.toCode();
        code += this.operator;
        return code;
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "yhcv":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixIndexInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixIndexInstruction": () => (/* binding */ PostfixIndexInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent element[index]
 * EMPTY_OPERATOR Instruction ExprInstruction
 */
class PostfixIndexInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ element, index, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixIndexExpr,
            type: element.type.arrayElementType, ...settings
        });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(element, this);
        this.index = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(index, this);
    }
    toCode() {
        return `${this.element.toCode()}[${this.index.toCode()}]`;
    }
    isConst() {
        return this.element.isConst() && this.index.isConst();
    }
}


/***/ }),

/***/ "++2t":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PostfixPointInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PostfixPointInstruction": () => (/* binding */ PostfixPointInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



/**
 * Represent someExpr.id
 * EMPTY_OPERATOR Instruction IdInstruction
 */
class PostfixPointInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ element, postfix, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PostfixPointExpr, type: postfix.type, ...settings });
        this.element = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(element, this);
        this.postfix = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(postfix, this);
    }
    toCode() {
        return `${this.element.toCode()}.${this.postfix.toCode()}`;
    }
    isConst() {
        return this.element.isConst();
    }
}


/***/ }),

/***/ "6z3E":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Preset.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PresetInstruction": () => (/* binding */ PresetInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class PresetInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ props, id = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_PresetDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(id, this);
        this._props = props.map(prop => _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(prop, this));
    }
    get id() {
        return this._id;
    }
    get name() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._id)) {
            return null;
        }
        return this._id.name;
    }
    get props() {
        return this._props;
    }
    toCode() {
        return `${this.id} = {\n${this.props.map(prop => prop.toCode()).join(';\n')}\n}`;
    }
}


/***/ }),

/***/ "vF1C":
/*!************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/PresetProperty.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PresetProperty": () => (/* binding */ PresetProperty)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class PresetProperty extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ id, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PresetProperty, ...settings });
        this.id = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(id, this);
        this.args = args.map(arg => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(arg, this));
    }
    resolveDeclaration() {
        return this.scope.findVariable(this.id.name);
    }
    toCode() {
        return `${this.id} = { ${this.args.map(arg => arg.toCode()).join(',')} }`;
    }
}


/***/ }),

/***/ "Tk3Z":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProvideInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProvideInstruction": () => (/* binding */ ProvideInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


class ProvideInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ moduleName, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Provide, ...settings });
        this._value = moduleName;
    }
    get moduleName() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
}


/***/ }),

/***/ "ijf+":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ProxyTypeInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProxyTypeInstruction": () => (/* binding */ ProxyTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "pEQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class ProxyTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor(settings) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ProxyType, ...settings });
        this._host = null;
    }
    get host() {
        return this._host;
    }
    get writable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get readable() {
        return this.isResolved() ? this.host.writable : true;
    }
    get name() {
        return this.isResolved() ? this.host.name : 'auto';
    }
    get size() {
        return this.isResolved() ? this.host.size : _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_SIZE;
    }
    get baseType() {
        return this.host;
    }
    get arrayElementType() {
        return this.isResolved() ? this.host.arrayElementType : null;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this.isResolved() ? this.host.length : _helpers__WEBPACK_IMPORTED_MODULE_2__.instruction.UNDEFINE_LENGTH;
    }
    get fields() {
        return this.isResolved() ? this.host.fields : [];
    }
    get methods() {
        return [];
    }
    isResolved() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.host);
    }
    resolve(host) {
        this._host = host;
    }
    toString() {
        return this.isResolved() ? this.host.toString() : this.name;
    }
    /** @deprecated */
    toDeclString() {
        return this.isResolved() ? this.host.toDeclString() : null;
    }
    toCode() {
        return this.isResolved() ? this.host.toCode() : this.name;
    }
    isArray() {
        return this.isResolved() ? this.host.isArray() : false;
    }
    isNotBaseArray() {
        return this.isResolved() ? this.host.isNotBaseArray() : false;
    }
    isComplex() {
        return this.isResolved() ? this.host.isComplex() : false;
    }
    hasFieldWithSematics(semantic) {
        return this.isResolved() ? this.host.hasFieldWithSematics(semantic) : false;
    }
    getField(fieldName) {
        return this.isResolved() ? this.host.getField(fieldName) : null;
    }
    getMethod(methodName, args) {
        return this.isResolved() ? this.host.getMethod(methodName, args) : null;
    }
    getFieldBySemantics(semantic) {
        return this.isResolved() ? this.host.getFieldBySemantics(semantic) : null;
    }
    hasFieldWithoutSemantics() {
        return this.isResolved() ? this.host.hasFieldWithoutSemantics() : false;
    }
    hasAllUniqueSemantics() {
        return this.isResolved() ? this.host.hasAllUniqueSemantics() : false;
    }
}


/***/ }),

/***/ "2i/b":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/RelationalExprInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RelationalExprInstruction": () => (/* binding */ RelationalExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");



/**
 * Represent someExpr == != < > <= >= someExpr
 * (==|!=|<|>|<=|>=) Instruction Instruction
 */
class RelationalExprInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    constructor({ left, right, operator, instrType, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_RelationalExpr,
            type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__[`T_BOOL${left.type.length > 1 ? left.type.length : ''}`],
            ...settings
        });
        this._leftOperand = left;
        this._rightOperand = right;
        this._operator = operator;
    }
    get left() {
        return this._leftOperand;
    }
    get right() {
        return this._rightOperand;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        code += this.left.toCode();
        code += ` ${this.operator} `;
        code += this.right.toCode();
        return code;
    }
    isConst() {
        return this.left.isConst() &&
            this.right.isConst();
    }
}


/***/ }),

/***/ "UL2e":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/ReturnStmtInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReturnStmtInstruction": () => (/* binding */ ReturnStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent return expr;
 * return ExprInstruction
 */
class ReturnStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ expr = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_ReturnStmt, ...settings });
        this._operator = "return";
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(expr, this);
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        if (this.expr) {
            return "return " + this.expr.toCode() + ";";
        }
        else {
            return "return;";
        }
    }
}


/***/ }),

/***/ "Po1l":
/*!**********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SemicolonStmtInstruction.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SemicolonStmtInstruction": () => (/* binding */ SemicolonStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");


/**
 * Represent empty statement only semicolon ;
 * ;
 */
class SemicolonStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SemicolonStmt, ...settings });
    }
    toCode() {
        return ";";
    }
}


/***/ }),

/***/ "z98Y":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StateBlockInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateBlockInstruction": () => (/* binding */ StateBlockInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");


class StateBlockInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ExprInstruction {
    constructor({ type, blocks = null, props = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StateBlockExpr, type, ...settings });
        this.props = props;
        this.blocks = blocks;
    }
    toCode() {
        console.error(`not implemeted`);
        return null;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "fc3/":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtBlockInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StmtBlockInstruction": () => (/* binding */ StmtBlockInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent {stmts}
 * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
 */
class StmtBlockInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ stmtList, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_StmtBlock, ...settings });
        this._stmtList = stmtList.map(stmt => _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(stmt, this));
    }
    get stmtList() {
        return this._stmtList;
    }
    toCode() {
        var code = "{" + "\n";
        for (var i = 0; i < this.stmtList.length; i++) {
            code += "\t" + this.stmtList[i].toCode() + "\n";
        }
        code += "}";
        return code;
    }
}


/***/ }),

/***/ "pGoc":
/*!*************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StmtInstruction.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StmtInstruction": () => (/* binding */ StmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");


/**
 * Represent all kind of statements
 */
class StmtInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction {
    constructor({ ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Stmt, ...settings });
    }
}


/***/ }),

/***/ "mlvU":
/*!***************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/StringInstruction.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringInstruction": () => (/* binding */ StringInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprInstruction */ "nqRf");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");




class StringInstruction extends _lib_fx_analisys_instructions_ExprInstruction__WEBPACK_IMPORTED_MODULE_0__.ExprInstruction {
    /**
     * EMPTY_OPERATOR EMPTY_ARGUMENTS
     */
    constructor({ value, scope, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_StringExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_STRING, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.SCOPE), scope, ...settings });
        this._value = value;
    }
    get value() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    toCode() {
        return this._value;
    }
    isConst() {
        return true;
    }
}


/***/ }),

/***/ "F8nM":
/*!***********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemFunctionInstruction.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemFunctionInstruction": () => (/* binding */ SystemFunctionInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FunctionDeclInstruction */ "BLpd");



class SystemFunctionInstruction extends _FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_2__.FunctionDeclInstruction {
    // protected _bForCompute;
    // protected _bForGeometry;
    constructor({ vertex = true, pixel = true, impl = null, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemFunctionDecl, impl: null, ...settings });
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(impl));
        this._bForVertex = vertex;
        this._bForPixel = pixel;
    }
    checkVertexUsage() {
        return this._bForVertex;
    }
    checkPixelUsage() {
        return this._bForPixel;
    }
    $makeVertexCompatible(val) {
        console.warn("@deprecated");
        this._bForVertex = val;
    }
    $makePixelCompatible(val) {
        console.warn("@deprecated");
        this._bForPixel = val;
    }
}


/***/ }),

/***/ "/VpG":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/SystemTypeInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemTypeInstruction": () => (/* binding */ SystemTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class SystemTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ name, size = 0, elementType = null, length = 1, fields = [], methods = [], writable = true, readable = true, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemType, ...settings });
        this._name = name;
        this._size = size;
        this._elementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(elementType);
        this._length = length;
        this._fields = [];
        this._methods = [];
        this._bIsWritable = writable;
        this._bIsReadable = readable;
        fields.forEach(field => this.addField(field));
        methods.forEach(method => this.addMethod(method));
    }
    get writable() {
        return this._bIsWritable;
    }
    get readable() {
        return this._bIsReadable;
    }
    get name() {
        return this._name;
    }
    get size() {
        if (this.isArray()) {
            if (this.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH;
            }
            return this.arrayElementType.size * this.length;
        }
        return this._size;
    }
    get baseType() {
        return this;
    }
    get arrayElementType() {
        return this._elementType;
    }
    get typeDecl() {
        return this.parent;
    }
    get length() {
        return this._length;
    }
    get fields() {
        return this._fields;
    }
    get methods() {
        return this._methods;
    }
    toDeclString() {
        console.warn('@pure_virtual');
        return '';
    }
    isArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.arrayElementType);
    }
    isNotBaseArray() {
        return false;
    }
    isComplex() {
        return false;
    }
    isContainPointer() {
        return false;
    }
    toString() {
        return this.name || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.hash(this);
    }
    toCode() {
        return this._name;
    }
    hasFieldWithSematics(semantic) {
        return false;
    }
    hasAllUniqueSemantics() {
        return false;
    }
    hasFieldWithoutSemantics() {
        return false;
    }
    getField(fieldName) {
        return this._fields.find(field => field.name === fieldName) || null;
    }
    getMethod(methodName, args) {
        const list = this._methods.filter(method => method.name === methodName);
        return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.fn.matchList(list, args);
    }
    getFieldBySemantics(semantic) {
        console.error("@undefined_behavior");
        return null;
    }
    /** internal api */
    addField(field) {
        console.assert(this.getField(field.name) === null);
        this._fields.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(field, this));
    }
    /** internal api */
    addMethod(method) {
        console.assert((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.getMethod(method.name, method.def.params.map(param => param.type))));
        this._methods.push(_Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(method, this));
    }
}


/***/ }),

/***/ "QdWn":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/Technique11Instruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Technique11Instruction": () => (/* binding */ Technique11Instruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class Technique11Instruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ name, passes, presets, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_Technique11Decl, ...settings });
        this._name = name;
        this.passes = passes?.map(pass => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(pass, this));
    }
    get name() {
        return this._name;
    }
    /** @deprecated */
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "dmHP":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TechniqueInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TechniqueInstruction": () => (/* binding */ TechniqueInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class TechniqueInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_1__.DeclInstruction {
    constructor({ name, techniqueType, passes, presets, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_TechniqueDecl, ...settings });
        this._name = name;
        this.passes = passes?.map(pass => _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withParent(pass, this));
        this.type = techniqueType;
        this.presets = presets;
    }
    get name() {
        return this._name;
    }
    isValid() {
        return true;
    }
}


/***/ }),

/***/ "Jg/d":
/*!*****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypeDeclInstruction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeDeclInstruction": () => (/* binding */ TypeDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// TODO: add description comment.
class TypeDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypeDecl, ...settings });
        this.type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(type, this);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.type));
    }
    get name() {
        return this.type.name;
    }
    toCode() {
        return this.type.toDeclString() + ";";
    }
}


/***/ }),

/***/ "jSFO":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypedInstruction.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedInstruction": () => (/* binding */ TypedInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Instruction */ "hbjL");



class TypedInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction {
    constructor({ type, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_Typed, ...settings });
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_2__.Instruction.$withNoParent(type);
        // todo: remove this check
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._type)) {
            console.warn("Something goes wrong! Type is not specified!", this);
        }
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "bYYM":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/TypedefInstruction.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedefInstruction": () => (/* binding */ TypedefInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




// TODO: add description comment.
class TypedefInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ type, alias, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_TypedefDecl, ...settings });
        this.type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this.alias = alias;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.type));
    }
    get name() {
        return this.type?.name;
    }
    toCode() {
        return `typedef ${this.type.toDeclString()} ${this.alias};`;
    }
}


/***/ }),

/***/ "Dbly":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/UnaryExprInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnaryExprInstruction": () => (/* binding */ UnaryExprInstruction)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExprInstruction */ "nqRf");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VariableTypeInstruction */ "6EL/");





/**
 * Represent + - ! ++ -- expr
 * (+|-|!|++|--|) Instruction
 */
class UnaryExprInstruction extends _ExprInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprInstruction {
    constructor({ expr, operator, ...settings }) {
        super({
            instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_UnaryExpr,
            // NOTE: type wraping is no really necessary, just for debug purposes
            type: operator === '!'
                ? _VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableTypeInstruction.wrapAsConst(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.T_BOOL, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_0__.SCOPE)
                : expr.type,
            ...settings
        });
        this._expr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(expr, this);
        this._operator = operator;
    }
    get operator() {
        return this._operator;
    }
    get expr() {
        return this._expr;
    }
    toCode() {
        var sCode = '';
        sCode += this.operator;
        sCode += this.expr.toCode();
        return sCode;
    }
    isConst() {
        return this.expr.isConst();
    }
}


/***/ }),

/***/ "k9uP":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableDeclInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVariableUsageFlags": () => (/* binding */ EVariableUsageFlags),
/* harmony export */   "VariableDeclInstruction": () => (/* binding */ VariableDeclInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DeclInstruction */ "0xZW");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




/**
 * @deprecated
 */
var EVariableUsageFlags;
(function (EVariableUsageFlags) {
    EVariableUsageFlags[EVariableUsageFlags["k_Local"] = 1] = "k_Local";
    EVariableUsageFlags[EVariableUsageFlags["k_Global"] = 2] = "k_Global";
    EVariableUsageFlags[EVariableUsageFlags["k_Argument"] = 4] = "k_Argument";
    EVariableUsageFlags[EVariableUsageFlags["k_Cbuffer"] = 8] = "k_Cbuffer";
})(EVariableUsageFlags || (EVariableUsageFlags = {}));
/**
 * Represent type var_name [= init_expr]
 * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
 */
class VariableDeclInstruction extends _DeclInstruction__WEBPACK_IMPORTED_MODULE_2__.DeclInstruction {
    constructor({ id, type, init = null, usageFlags = 0, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableDecl, ...settings });
        this._id = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(id, this);
        this._type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this._initExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(init, this);
        this._usageFlags = usageFlags;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isParameter() || ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent) || this.parent.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_FunctionDef));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isLocal() || !this.isLocal());
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.isParameter() || this.isLocal());
    }
    get usageFlags() {
        return this._usageFlags;
    }
    get initExpr() {
        return this._initExpr;
    }
    get type() {
        return this._type;
    }
    get name() {
        return this._id.name;
    }
    get id() {
        return this._id;
    }
    isGlobal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Global);
    }
    isLocal() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Local);
    }
    isParameter() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Argument);
    }
    isField() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.parent)) {
            return false;
        }
        const parentType = this.parent.instructionType;
        if (parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_VariableType ||
            parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_ComplexType ||
            parentType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_1__.EInstructionTypes.k_SystemType) {
            return true;
        }
        return false;
    }
    isConstant() {
        return !!(this._usageFlags & EVariableUsageFlags.k_Cbuffer) || this.type.isUniform();
    }
    toCode() {
        var code = '';
        code = this.type.toCode();
        code += ' ' + this.id.toCode();
        if (this.type.isNotBaseArray()) {
            var iLength = this.type.length;
            code += '[' + iLength + ']';
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.initExpr) &&
            // !SystemScope.isSamplerType(this.type) && // TODO: is it correct check?
            !this.type.isUniform()) {
            code += '=' + this.initExpr.toCode();
        }
        return code;
    }
}


/***/ }),

/***/ "6EL/":
/*!*********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/VariableTypeInstruction.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariableTypeInstruction": () => (/* binding */ VariableTypeInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction */ "hbjL");




class VariableTypeInstruction extends _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction {
    constructor({ type, usages = [], arrayIndex = null, writable = true, readable = true, padding = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_PADDING, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType, ...settings });
        type = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withNoParent(type);
        this._usageList = [];
        let instrType = type.instructionType;
        if (instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ProxyType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemType ||
            instrType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexType) {
            this._subType = type;
        }
        else {
            let varType = type;
            // TODO: review this code
            if (!varType.isNotBaseArray()) {
                this._subType = varType.subType;
                varType.usages.forEach(usage => this.addUsage(usage));
            }
            else {
                this._subType = type;
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this._subType));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this._usageList));
        this._isWritable = writable;
        this._isReadable = readable;
        this._arrayIndexExpr = null;
        this._arrayElementType = null;
        this._padding = padding;
        this._aligment = 1;
        if (arrayIndex) {
            // todo: add support for v[][10]
            // todo: move elements construction to analyzer, don't make it implicitly
            this._arrayElementType = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: this.subType, usages: this._usageList }), this);
            this._arrayIndexExpr = _Instruction__WEBPACK_IMPORTED_MODULE_3__.Instruction.$withParent(arrayIndex, this);
        }
        // todo: array element type must be constructed with proper usages and read/write flags!
        // else if (this.isArray()) {
        //     this._arrayElementType = Instruction.$withParent(new VariableTypeInstruction({ readable, writable, scope: this.scope, type: type.arrayElementType, usages: this._usageList }), this);
        // }
        usages.forEach(usage => this.addUsage(usage));
    }
    get name() {
        return this.baseType.name;
    }
    get writable() {
        if (!this._isWritable) {
            return false;
        }
        if ( /*(this.isArray() && !this.isBase()) || */this.isUniform()) {
            return false;
        }
        if (this.isConst()) {
            return false;
        }
        // check for usages.includes('in') ?
        return this.subType.writable;
    }
    get readable() {
        if (!this._isReadable) {
            return false;
        }
        if (this.usages.includes("out")) {
            return false;
        }
        return this.subType.readable;
    }
    get methods() {
        return this.subType.methods;
    }
    get aligment() {
        return this._aligment;
    }
    // TODO: move to helpers
    get size() {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType)) {
            const size = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.alignSize(this._arrayElementType.size, this.aligment);
            const length = this.length;
            if (length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH || size === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_SIZE) {
                return _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_SIZE;
            }
            return size * length;
        }
        // return type.alignSize(this.subType.size, this.aligment);
        return this.subType.size;
    }
    get baseType() {
        return this.subType.baseType;
    }
    get length() {
        if (!this.isNotBaseArray()) { // not a user defined array like arr[10]
            // for ex. if type is float3x4 then length is 3
            return this.subType.length;
        }
        // IP: arrays like float[]?
        if (this.isNotBaseArray() && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType)) {
            return this.subType.length;
        }
        // arrays like float[10]
        const expr = this._arrayIndexExpr;
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isLiteral(expr)) {
            return Number(expr.value);
        }
        // arrays like float[N];
        const len = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.evalConst(expr);
        return len < 0 ? _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH : len;
    }
    get padding() {
        return this._padding;
    }
    get arrayElementType() {
        if (!this.isArray()) {
            return null;
        }
        // todo: fix this.subType.arrayElementType!
        return this._arrayElementType || this.subType.arrayElementType;
    }
    get usages() {
        let usages = [...this._usageList];
        let subType = this.subType;
        while (subType && subType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType) {
            const vtype = subType;
            // todo: remove duplicates
            usages = [...usages, ...vtype.usages];
            subType = vtype.subType;
        }
        return usages;
    }
    get subType() {
        return this._subType;
    }
    get fields() {
        return this.subType.fields;
    }
    toString() {
        // TODO: fix this condition
        return this.name || this.subType.toString() || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.hash(this);
    }
    toCode() {
        let code = "";
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._usageList)) {
            for (let i = 0; i < this._usageList.length; i++) {
                code += this._usageList[i] + " ";
            }
        }
        code += this.subType.toCode();
        return code;
    }
    /** @deprecated */
    toDeclString() {
        return this.subType.toDeclString();
    }
    isArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType) || this.subType.isArray();
    }
    // Returns true if the type is user defined array.
    // like an ordinary array: int a[5]
    // not a base array like: float4/int3 etc.
    isNotBaseArray() {
        return !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this._arrayElementType) || this.subType.isNotBaseArray();
    }
    isComplex() {
        return this.subType.isComplex();
    }
    isUniform() {
        return this.usages.includes("uniform");
    }
    isConst() {
        return this.usages.includes("const");
    }
    isUnsigned() {
        return this.usages.includes("unsigned");
    }
    isStatic() {
        return this.usages.includes("static");
    }
    $overwritePadding(padding, aligment) {
        this._padding = padding;
        this._aligment = aligment;
    }
    addUsage(usage) {
        if (!this.usages.includes(usage)) {
            this._usageList.push(usage);
        }
    }
    hasFieldWithSematics(semantic) {
        return this.subType.hasFieldWithSematics(semantic);
    }
    hasAllUniqueSemantics() {
        return this.subType.hasAllUniqueSemantics();
    }
    hasFieldWithoutSemantics() {
        return this.subType.hasFieldWithoutSemantics();
    }
    getField(fieldName) {
        // TODO: propogate usages? atleast readable/writable
        return this.subType.getField(fieldName);
    }
    getMethod(methodName, args) {
        return this.subType.getMethod(methodName, args);
    }
    getFieldBySemantics(semantic) {
        // TODO: propogate usages?
        return this.subType.getFieldBySemantics(semantic);
    }
    /**
     * Helpers
     */
    // TODO: move to type.ts
    /** @deprecated */
    static wrap(type, scope) {
        return new VariableTypeInstruction({ type, scope });
    }
    // TODO: move to type.ts
    /** @deprecated */
    static wrapAsConst(type, scope) {
        return new VariableTypeInstruction({ type, scope, writable: false, usages: ['const'] });
    }
}


/***/ }),

/***/ "eHl7":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/WhileStmtInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WhileStmtInstruction": () => (/* binding */ WhileStmtInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Instruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction */ "hbjL");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StmtInstruction */ "pGoc");



/**
 * Represent while(expr) stmt
 * ( while || do_while) ExprInstruction StmtInstruction
 */
class WhileStmtInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_2__.StmtInstruction {
    constructor({ cond, body, operator, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_WhileStmt, ...settings });
        this._cond = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(cond, this);
        this._body = _Instruction__WEBPACK_IMPORTED_MODULE_1__.Instruction.$withParent(body, this);
        this._operator = operator;
    }
    get cond() {
        return this.cond;
    }
    get body() {
        return this._body;
    }
    get operator() {
        return this._operator;
    }
    toCode() {
        var code = '';
        if (this.operator === "while") {
            code += "while(";
            code += this.cond.toCode();
            code += ")";
            code += this.body.toCode();
        }
        else {
            code += "do";
            code += this.body.toCode();
            code += "while(";
            code += this.cond.toCode();
            code += ");";
        }
        return code;
    }
}


/***/ }),

/***/ "9jn4":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/DrawInstruction.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawInstruction": () => (/* binding */ DrawInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StmtInstruction */ "pGoc");


class DrawInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    constructor({ name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_DrawStmt, ...settings });
        this.name = name;
        this.args = args;
    }
    toCode() {
        return `draw ${this.name};`;
    }
}


/***/ }),

/***/ "0Qwk":
/*!********************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxInstruction.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartFxInstruction": () => (/* binding */ PartFxInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_fx_analisys_instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/TechniqueInstruction */ "dmHP");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");




// var s: IPartFxInstructionSettings;
// s.te
class PartFxInstruction extends _lib_fx_analisys_instructions_TechniqueInstruction__WEBPACK_IMPORTED_MODULE_2__.TechniqueInstruction {
    constructor({ spawnRoutine, initRoutine, updateRoutine, particle, capacity = -1, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_PartFxDecl, techniqueType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.ETechniqueType.k_PartFx, ...settings });
        this.spawnRoutine = spawnRoutine;
        this.initRoutine = initRoutine;
        this.updateRoutine = updateRoutine;
        this.particle = particle;
        this.capacity = capacity;
    }
    isValid() {
        if (!this.spawnRoutine) {
            console.error(`no spawn routine found`);
            return false;
        }
        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_3__.types.equals(this.spawnRoutine.function.def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_VOID)) {
            if (!this.initRoutine) {
                console.error(`init routine must be defined if regular spawner is used`);
                return false;
            }
        }
        if (!this.updateRoutine) {
            console.error(`no update routine found`);
            return false;
        }
        const particleCheck = !!this.particle;
        const passCheck = this.passes && this.passes.filter((pass) => pass.isValid()).length > 0;
        return particleCheck && passCheck;
    }
}


/***/ }),

/***/ "pCHB":
/*!************************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/PartFxPassInstruction.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartFxPassInstruction": () => (/* binding */ PartFxPassInstruction)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PassInstruction */ "Z/0D");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");




class PartFxPassInstruction extends _lib_fx_analisys_instructions_PassInstruction__WEBPACK_IMPORTED_MODULE_1__.PassInstruction {
    constructor({ sorting = false, instanceCount = 1, drawMode = _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_3__.EPassDrawMode.k_Auto, prerenderRoutine, geometry, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PartFxPass, ...settings });
        this.sorting = sorting;
        this.prerenderRoutine = prerenderRoutine;
        this.geometry = geometry;
        this.instanceCount = instanceCount;
        this.drawMode = drawMode;
    }
    get particleInstance() {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.prerenderRoutine)) {
            return null;
        }
        return this.prerenderRoutine.function.def.params[1].type.subType;
    }
    isValid() {
        return !!this.particleInstance && !!this.prerenderRoutine;
    }
}


/***/ }),

/***/ "sg/T":
/*!*******************************************************************!*\
  !*** ./src/lib/fx/analisys/instructions/part/SpawnInstruction.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpawnInstruction": () => (/* binding */ SpawnInstruction)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StmtInstruction */ "pGoc");


class SpawnInstruction extends _StmtInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtInstruction {
    // private _fx: IPartFxInstruction = null;
    // private _init: IFunctionDeclInstruction = null;
    constructor({ count, name, args, ...settings }) {
        super({ instrType: _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.EInstructionTypes.k_SpawnStmt, ...settings });
        this.count = count;
        this.args = args;
        this.name = name;
    }
    // get fx(): IPartFxInstruction {
    //     return this._fx;
    // }
    // get init(): IFunctionDeclInstruction {
    //     return this._init;
    // }
    toCode() {
        return `spawn(${this.count}) ${this.name}(${this.args.map(arg => arg.toCode()).join(', ')});`;
    }
}


/***/ }),

/***/ "Xi4d":
/*!**********************************************************************!*\
  !*** ./src/lib/fx/analisys/system/AppendStructuredBufferTemplate.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");








class AppendStructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('AppendStructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__.VariableTypeInstruction({ type: args[0], scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, name: 'Append' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            const returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_0__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, name: 'Append' });
            const def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_6__.FunctionDefInstruction({ scope, returnType, id, paramList });
            const func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_5__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppendStructuredBufferTemplate);


/***/ }),

/***/ "6tHU":
/*!******************************************************!*\
  !*** ./src/lib/fx/analisys/system/BufferTemplate.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class BufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('Buffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(args[0])) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BufferTemplate);


/***/ }),

/***/ "Zvql":
/*!********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWBufferTemplate.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('RWBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(args[0])) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWBufferTemplate);


/***/ }),

/***/ "o6IR":
/*!******************************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWStructuredBufferTemplate.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");







class RWStructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor() {
        super('RWStructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'IncrementCounter' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ type: scope.findType("uint"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'DecrementCounter' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWStructuredBufferTemplate);


/***/ }),

/***/ "vqrB":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWTexture1DTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWTexture1DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(RWTexture1DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
RWTexture1DTemplate.TYPE_NAME = 'RWTexture1D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWTexture1DTemplate);


/***/ }),

/***/ "cO3W":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/RWTexture2DTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class RWTexture2DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(RWTexture2DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods, });
    }
}
RWTexture2DTemplate.TYPE_NAME = 'RWTexture2D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RWTexture2DTemplate);


/***/ }),

/***/ "b3Cg":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/system/StructuredBufferTemplate.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");



class StructuredBufferTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super('StructuredBuffer');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StructuredBufferTemplate);


/***/ }),

/***/ "/tL8":
/*!**************************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture2DArrayTemplate.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture2DArrayTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture2DArrayTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dx' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dy' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleGrad' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture2DArrayTemplate.TYPE_NAME = 'Texture2DArray';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture2DArrayTemplate);


/***/ }),

/***/ "czsy":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture2DTemplate.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture2DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture2DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            const rtName = `${type.isArray() ? type.arrayElementType.name : type.name}4`;
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: scope.findType(rtName), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Gather' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f1 = scope.findType("float");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f1, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'lod' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleLevel' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dx' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f2 = scope.findType("float2");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f2, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'dy' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleGrad' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'mipLevel' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'width' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'height' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'GetDimensions' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let int3 = scope.findType("int3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: int3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'location' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: elementType, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Load' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture2DTemplate.TYPE_NAME = 'Texture2D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture2DTemplate);


/***/ }),

/***/ "3stO":
/*!*********************************************************!*\
  !*** ./src/lib/fx/analisys/system/Texture3DTemplate.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class Texture3DTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(Texture3DTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
Texture3DTemplate.TYPE_NAME = 'Texture3D';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Texture3DTemplate);


/***/ }),

/***/ "rn9U":
/*!****************************************************************!*\
  !*** ./src/lib/fx/analisys/system/TextureCubeArrayTemplate.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "BeyE");




class TextureCubeArrayTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(TextureCubeArrayTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_1__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
TextureCubeArrayTemplate.TYPE_NAME = 'TextureCubeArray';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextureCubeArrayTemplate);


/***/ }),

/***/ "vjwK":
/*!***********************************************************!*\
  !*** ./src/lib/fx/analisys/system/TextureCubeTemplate.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "BeyE");









class TextureCubeTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(TextureCubeTemplate.TYPE_NAME);
    }
    produceType(scope, args) {
        if (args.length > 1) {
            // TODO: print error
            return null;
        }
        const type = args.length > 0 ? args[0] : scope.findType('float4');
        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isBase)(type)) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = type;
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'Sample' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let samplerState = scope.findType("SamplerState");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: samplerState, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'samplerState' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float3");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'uv' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let f3 = scope.findType("float");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type: f3, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'lod' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableTypeInstruction({ type, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'SampleLevel' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemFunctionInstruction({ scope, def, pixel: true, vertex: true });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
TextureCubeTemplate.TYPE_NAME = 'TextureCube';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextureCubeTemplate);


/***/ }),

/***/ "LRe5":
/*!*******************************************************!*\
  !*** ./src/lib/fx/analisys/system/TriMeshTemplate.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IntInstruction */ "s0og");
/* harmony import */ var _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemFunctionInstruction */ "F8nM");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var _TypeTemplate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TypeTemplate */ "+jyi");










class TriMeshTemplate extends _TypeTemplate__WEBPACK_IMPORTED_MODULE_9__["default"] {
    constructor() {
        super('TriMesh');
    }
    produceType(scope, args) {
        if (args.length !== 1) {
            // TODO: print error
            return null;
        }
        const name = this.typeName(args);
        const size = -1;
        const elementType = args[0];
        const length = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.instruction.UNDEFINE_LENGTH;
        const fields = [];
        const methods = [];
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'vertCount' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param0 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param0);
            }
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'faceCount' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'GetDimensions' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'vert' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: elementType, scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadVertex' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("uint3"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadFace' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__.parseUintLiteral)("6u");
                const arrayIndex = new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__.IntInstruction({ scope, base, exp, signed, heximal });
                const uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'adjacency' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadGSAdjacency' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        {
            const paramList = [];
            {
                let uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'face' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param1 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param1);
            }
            {
                const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_8__.parseUintLiteral)("3u");
                const arrayIndex = new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_3__.IntInstruction({ scope, base, exp, signed, heximal });
                const uint = scope.findType("uint");
                const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: uint, scope, arrayIndex, usages: ['out'] });
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'adjacency' });
                const usageFlags = _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Argument | _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.EVariableUsageFlags.k_Local;
                const param2 = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_6__.VariableDeclInstruction({ scope, type, id, usageFlags });
                paramList.push(param2);
            }
            let returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_7__.VariableTypeInstruction({ type: scope.findType("void"), scope });
            let id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: 'LoadFaceAdjacency' });
            let def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_1__.FunctionDefInstruction({ scope, returnType, id, paramList });
            let func = new _lib_fx_analisys_instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_4__.SystemFunctionInstruction({ scope, def, pixel: false, vertex: false });
            methods.push(func);
        }
        return new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriMeshTemplate);


/***/ }),

/***/ "+jyi":
/*!****************************************************!*\
  !*** ./src/lib/fx/analisys/system/TypeTemplate.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class TypeTemplate {
    constructor(name) {
        this.name = name;
    }
    produceType(scope, args) {
        return null;
    }
    typeName(args) {
        if (args && args.length > 0) {
            return `${this.name}<${args.map(arg => arg.name).join(', ')}>`;
        }
        return this.name;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TypeTemplate);


/***/ }),

/***/ "9ebs":
/*!*******************************************!*\
  !*** ./src/lib/fx/analisys/system/api.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemFunctions": () => (/* binding */ addSystemFunctions)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

// TODO: rework system function templates for better readability
function addSystemFunctions(scope) {
    // todo: rework setup of system functions according with microsoft docs.
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dot", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul
    // TODO: add support for int|uint|bool based vectors 
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, ["float", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4", "float2x2", "float3x3", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float4", ["float4", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4x4", "float4x3", "float4x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float3", ["float3", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3x4", "float3x3", "float3x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float2", ["float2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2x4", "float2x3", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float4"], ["float4x4", "float3x4", "float2x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float3"], ["float4x3", "float3x3", "float2x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mul", "float2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float2"], ["float4x2", "float3x2", "float2x2"]);
    /**
     * scalar = int|uint|float
     * vector = vector<int|uint|float, n>, n = 2,3,4
     * matrix = matrix<scalar, rows, columns>, r = 2,3,4, c = 2,3,4
     *
     * scalar mul(scalar, scalar)
     * vector mul(scalar, vector)
     * vector mul(vector, scalar)
     * vector mul(vector, vector)
     * matrix mul(scalar, matrix)
     * matrix mul(matrix, scalar)
     * vector mul(vector, matrix)
     * vector mul(matrix, vector)
     * matrix mul(matrix, matrix)
     */
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", "float", ["float", "float"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "floor", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "round", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "ceil", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "fract", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "abs", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "abs", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sign", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sign", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "normalize", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "length", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "cross", "float3", ["float3", "float3"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "reflect", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "max", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "int2", "int3", "int4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "min", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint", "uint2", "uint3", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "fmod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "ldexp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "reversebits", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clamp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clamp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float", "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "pow", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "mod", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "exp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "exp2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "log", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "log2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "inversesqrt", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sqrt", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "all", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    // generateSystemFunction(scope, "any", "bool", [TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    /** @deprecated (SM4) */
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "not", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "distance", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThan", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lessThanEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "equal", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "notEqual", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool2", "bool3", "bool4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThan", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "greaterThanEqual", "bool4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "radians", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "degrees", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sin", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "cos", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "sincos", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, `out ${_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE}`, `out ${_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE}`], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "tan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asin", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "acos", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "atan2", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler", "float2"], null);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler2D", "float2"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float3"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float3"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float4"], null);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float4"], null);
    // generateSystemFunction(scope, "texCUBE", "float4", ["sampler", "float3"], null);
    // generateSystemFunction(scope, "texCUBE", "float4", ["samplerCUBE", "float3"], null);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler", "float2", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2D", "float4", ["sampler2D", "float2", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler", "float4", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DProj", "float4", ["sampler2D", "float4", "float"], null, false, true);
    // generateSystemFunction(scope, "texCUBE", "float4", ["sampler", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "texCUBE", "float4", ["samplerCUBE", "float3", "float"], null, false, true);
    // generateSystemFunction(scope, "tex2DLod", "float4", ["sampler", "float2", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DLod", "float4", ["sampler2D", "float2", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler2D", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler", "float4", "float"], null, true, false);
    // generateSystemFunction(scope, "tex2DProjLod", "float4", ["sampler2D", "float4", "float"], null, true, false);
    // generateSystemFunction(scope, "texCUBELod", "float4", ["sampler", "float3", "float"], null, true, false);
    // generateSystemFunction(scope, "texCUBELod", "float4", ["samplerCUBE", "float3", "float"], null, true, false);
    //OES_standard_derivatives
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dFdx", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "dFdy", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "width", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "fwidth", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    // generateSystemFunction(scope, "smoothstep", "float3", ["float3", "float3", "float3"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "smoothstep", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "smoothstep", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, ["float", "float", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "step", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "clip", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_PS);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "frac", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lerp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "lerp", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "float"], ["float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "saturate", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asfloat", "float4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asint", "int4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float", "int", "bool", "uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint2", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float2", "int2", "bool2", "uint2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint3", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float3", "int3", "bool3", "uint3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "asuint", "uint4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["float4", "int4", "bool4", "uint4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "InterlockedAdd", _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, _utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int"]);
    // generateSystemFunction(scope, "InterlockedAdd", TEMPLATE_TYPE, [TEMPLATE_TYPE, TEMPLATE_TYPE, TEMPLATE_TYPE], ["uint"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "f16tof32", "float", ["uint"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "f32tof16", "uint", ["float"], null);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "uint", "float", "bool"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int2", "uint2", "float2", "bool2", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int3", "uint3", "float3", "bool3", "float3x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "any", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int4", "uint4", "float4", "bool4", "float4x4"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int", "uint", "float", "bool"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int2", "uint2", "float2", "bool2", "float2x2"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int3", "uint3", "float3", "bool3", "float3x3"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "all", "bool", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["int4", "uint4", "float4", "bool4", "float4x4"]);
    // DX12
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "WaveGetLaneIndex", "uint", [], ["void"]);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "WaveActiveBallot", "uint4", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["bool"]);
    // control flow
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetVertexShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["VertexShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetPixelShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["PixelShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetGeometryShader", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["GeometryShader"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetDepthStencilState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE, "int"], ["DepthStencilState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetBlendState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["BlendState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW); // todo: use correct arguments
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemFunction)(scope, "SetRasterizerState", "void", [_utils__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_TYPE], ["RasterizerState"], _utils__WEBPACK_IMPORTED_MODULE_0__.USAGE_CONTROL_FLOW); // todo: use correct arguments
}


/***/ }),

/***/ "OC3L":
/*!***********************************************!*\
  !*** ./src/lib/fx/analisys/system/builtin.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeBuiltin": () => (/* binding */ addSystemTypeBuiltin)
/* harmony export */ });
/* harmony import */ var _AppendStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AppendStructuredBufferTemplate */ "Xi4d");
/* harmony import */ var _BufferTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferTemplate */ "6tHU");
/* harmony import */ var _RWBufferTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RWBufferTemplate */ "Zvql");
/* harmony import */ var _RWStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RWStructuredBufferTemplate */ "o6IR");
/* harmony import */ var _RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RWTexture1DTemplate */ "vqrB");
/* harmony import */ var _RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RWTexture2DTemplate */ "cO3W");
/* harmony import */ var _StructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StructuredBufferTemplate */ "b3Cg");
/* harmony import */ var _Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Texture2DArrayTemplate */ "/tL8");
/* harmony import */ var _Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Texture2DTemplate */ "czsy");
/* harmony import */ var _Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Texture3DTemplate */ "3stO");
/* harmony import */ var _TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureCubeArrayTemplate */ "rn9U");
/* harmony import */ var _TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextureCubeTemplate */ "vjwK");
/* harmony import */ var _TriMeshTemplate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TriMeshTemplate */ "LRe5");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils */ "BeyE");














function addSystemTypeBuiltin(scope) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "SamplerState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "SamplerComparisonState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "DepthStencilState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "BlendState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "RasterizerState", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "VertexShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "PixelShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "ComputeShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "GeometryShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "HullShader", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_13__.generateSystemType)(scope, "DomainShader", 4);
    // generateSystemType(scope, "texture");
    // generateSystemType(scope, "sampler");
    // generateSystemType(scope, "sampler2D");
    // generateSystemType(scope, "samplerCUBE");
    scope.addTypeTemplate(new _BufferTemplate__WEBPACK_IMPORTED_MODULE_1__["default"]);
    scope.addTypeTemplate(new _RWBufferTemplate__WEBPACK_IMPORTED_MODULE_2__["default"]);
    scope.addTypeTemplate(new _RWStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_3__["default"]);
    scope.addTypeTemplate(new _AppendStructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_0__["default"]);
    scope.addTypeTemplate(new _StructuredBufferTemplate__WEBPACK_IMPORTED_MODULE_6__["default"]);
    scope.addTypeTemplate(new _TriMeshTemplate__WEBPACK_IMPORTED_MODULE_12__["default"]);
    scope.addTypeTemplate(new _RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__["default"]);
    scope.addTypeTemplate(new _RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__["default"]);
    // TODO: RWTexture3D
    // TODO: Texture1D
    scope.addTypeTemplate(new _Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__["default"]);
    scope.addTypeTemplate(new _Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__["default"]);
    scope.addTypeTemplate(new _TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__["default"]);
    // TODO: Texture1DArray
    scope.addTypeTemplate(new _Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__["default"]);
    // TODO: Texture3DArray
    scope.addTypeTemplate(new _TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__["default"]);
    // produce default Texture2D type
    const templateTexture2D = scope.findTypeTemplate(_Texture2DTemplate__WEBPACK_IMPORTED_MODULE_8__["default"].TYPE_NAME);
    const typeTexture2D = templateTexture2D.produceType(scope, []);
    scope.addType(typeTexture2D);
    // produce default TextureCube type
    const templateTextureCube = scope.findTypeTemplate(_TextureCubeTemplate__WEBPACK_IMPORTED_MODULE_11__["default"].TYPE_NAME);
    const typeTextureCube = templateTextureCube.produceType(scope, []);
    scope.addType(typeTextureCube);
    // produce default Texture3D type
    const templateTexture3D = scope.findTypeTemplate(_Texture3DTemplate__WEBPACK_IMPORTED_MODULE_9__["default"].TYPE_NAME);
    const typeTexture3D = templateTexture3D.produceType(scope, []);
    scope.addType(typeTexture3D);
    // produce default Texture2DArray type
    const templateTexture2DArray = scope.findTypeTemplate(_Texture2DArrayTemplate__WEBPACK_IMPORTED_MODULE_7__["default"].TYPE_NAME);
    const typeTexture2DArray = templateTexture2DArray.produceType(scope, []);
    scope.addType(typeTexture2DArray);
    // produce default TextureCubeArray type
    const templateTextureCubeArray = scope.findTypeTemplate(_TextureCubeArrayTemplate__WEBPACK_IMPORTED_MODULE_10__["default"].TYPE_NAME);
    const typeTextureCubeArray = templateTextureCubeArray.produceType(scope, []);
    scope.addType(typeTextureCubeArray);
    // produce default RWTexture1D type
    const templateRWTexture1D = scope.findTypeTemplate(_RWTexture1DTemplate__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_NAME);
    const typeRWTexture1D = templateRWTexture1D.produceType(scope, []);
    scope.addType(typeRWTexture1D);
    // produce default RWTexture2D type
    const templateRWTexture2D = scope.findTypeTemplate(_RWTexture2DTemplate__WEBPACK_IMPORTED_MODULE_5__["default"].TYPE_NAME);
    const typeRWTexture2D = templateRWTexture2D.produceType(scope, []);
    scope.addType(typeRWTexture2D);
}


/***/ }),

/***/ "L0DD":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/matrix.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeMatrix": () => (/* binding */ addSystemTypeMatrix)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeMatrix(scope) {
    let float2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float2");
    let float3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float3");
    let float4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float4");
    let int2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int2");
    let int3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int3");
    let int4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int4");
    let uint2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint2");
    let uint3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint3");
    let uint4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint4");
    let bool2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool2");
    let bool3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool3");
    let bool4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool4");
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x2", -1, float2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x3", -1, float3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2x4", -1, float4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x2", -1, float2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x3", -1, float3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3x4", -1, float4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x2", -1, float2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x3", -1, float3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4x4", -1, float4, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x2", -1, int2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x3", -1, int3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2x4", -1, int4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x2", -1, int2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x3", -1, int3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3x4", -1, int4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x2", -1, int2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x3", -1, int3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4x4", -1, int4, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x2", -1, bool2, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x3", -1, bool3, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2x4", -1, bool4, 2);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x2", -1, bool2, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x3", -1, bool3, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3x4", -1, bool4, 3);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x2", -1, bool2, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x3", -1, bool3, 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4x4", -1, bool4, 4);
}


/***/ }),

/***/ "gzl7":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/scalar.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeScalar": () => (/* binding */ addSystemTypeScalar)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeScalar(scope) {
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "void", 0);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float", 4);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "string", 4 /* pointer to string */);
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "null_t", 4 /* pointer */);
    // TODO: use dedicated type for half
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, "float", "half");
    console.assert(_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE === false);
}


/***/ }),

/***/ "BeyE":
/*!*********************************************!*\
  !*** ./src/lib/fx/analisys/system/utils.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TYPES": () => (/* binding */ BASE_TYPES),
/* harmony export */   "BLEND_STATE": () => (/* binding */ BLEND_STATE),
/* harmony export */   "BOOL_BASED_TYPES": () => (/* binding */ BOOL_BASED_TYPES),
/* harmony export */   "BUFFER_TYPES": () => (/* binding */ BUFFER_TYPES),
/* harmony export */   "DEPTH_STENCIL_STATE": () => (/* binding */ DEPTH_STENCIL_STATE),
/* harmony export */   "FLOAT_BASED_TYPES": () => (/* binding */ FLOAT_BASED_TYPES),
/* harmony export */   "FLOAT_TYPES": () => (/* binding */ FLOAT_TYPES),
/* harmony export */   "HALF_BASED_TYPES": () => (/* binding */ HALF_BASED_TYPES),
/* harmony export */   "INT_BASED_TYPES": () => (/* binding */ INT_BASED_TYPES),
/* harmony export */   "INT_TYPES": () => (/* binding */ INT_TYPES),
/* harmony export */   "MATRIX_TYPES": () => (/* binding */ MATRIX_TYPES),
/* harmony export */   "RASTERIZER_STATE": () => (/* binding */ RASTERIZER_STATE),
/* harmony export */   "SAMPLER_TYPES": () => (/* binding */ SAMPLER_TYPES),
/* harmony export */   "SCALAR_TYPES": () => (/* binding */ SCALAR_TYPES),
/* harmony export */   "SHADER_TYPES": () => (/* binding */ SHADER_TYPES),
/* harmony export */   "TEMPLATE_TYPE": () => (/* binding */ TEMPLATE_TYPE),
/* harmony export */   "TEXTURE_TYPES": () => (/* binding */ TEXTURE_TYPES),
/* harmony export */   "UAV_TYPES": () => (/* binding */ UAV_TYPES),
/* harmony export */   "UINT_BASED_TYPES": () => (/* binding */ UINT_BASED_TYPES),
/* harmony export */   "USAGE_CONTROL_FLOW": () => (/* binding */ USAGE_CONTROL_FLOW),
/* harmony export */   "USAGE_CS": () => (/* binding */ USAGE_CS),
/* harmony export */   "USAGE_DS": () => (/* binding */ USAGE_DS),
/* harmony export */   "USAGE_GS": () => (/* binding */ USAGE_GS),
/* harmony export */   "USAGE_HS": () => (/* binding */ USAGE_HS),
/* harmony export */   "USAGE_PS": () => (/* binding */ USAGE_PS),
/* harmony export */   "USAGE_VS": () => (/* binding */ USAGE_VS),
/* harmony export */   "USE_STRICT_HALF_TYPE": () => (/* binding */ USE_STRICT_HALF_TYPE),
/* harmony export */   "VECTOR_TYPES": () => (/* binding */ VECTOR_TYPES),
/* harmony export */   "addFieldsToVectorFromSuffixObject": () => (/* binding */ addFieldsToVectorFromSuffixObject),
/* harmony export */   "debugPrint": () => (/* binding */ debugPrint),
/* harmony export */   "defineTypeAlias": () => (/* binding */ defineTypeAlias),
/* harmony export */   "generateSuffixLiterals": () => (/* binding */ generateSuffixLiterals),
/* harmony export */   "generateSystemFunction": () => (/* binding */ generateSystemFunction),
/* harmony export */   "generateSystemType": () => (/* binding */ generateSystemType),
/* harmony export */   "getSystemType": () => (/* binding */ getSystemType),
/* harmony export */   "isBase": () => (/* binding */ isBase),
/* harmony export */   "isBlendState": () => (/* binding */ isBlendState),
/* harmony export */   "isBoolBasedType": () => (/* binding */ isBoolBasedType),
/* harmony export */   "isBuffer": () => (/* binding */ isBuffer),
/* harmony export */   "isDepthStencilState": () => (/* binding */ isDepthStencilState),
/* harmony export */   "isFloatBasedType": () => (/* binding */ isFloatBasedType),
/* harmony export */   "isFloatType": () => (/* binding */ isFloatType),
/* harmony export */   "isHalfBasedType": () => (/* binding */ isHalfBasedType),
/* harmony export */   "isIntBasedType": () => (/* binding */ isIntBasedType),
/* harmony export */   "isIntegerType": () => (/* binding */ isIntegerType),
/* harmony export */   "isMatrixType": () => (/* binding */ isMatrixType),
/* harmony export */   "isPipelineState": () => (/* binding */ isPipelineState),
/* harmony export */   "isRasterizerState": () => (/* binding */ isRasterizerState),
/* harmony export */   "isSamplerState": () => (/* binding */ isSamplerState),
/* harmony export */   "isScalarType": () => (/* binding */ isScalarType),
/* harmony export */   "isShaderType": () => (/* binding */ isShaderType),
/* harmony export */   "isTemplate": () => (/* binding */ isTemplate),
/* harmony export */   "isTexture": () => (/* binding */ isTexture),
/* harmony export */   "isUAV": () => (/* binding */ isUAV),
/* harmony export */   "isUintBasedType": () => (/* binding */ isUintBasedType),
/* harmony export */   "isVectorType": () => (/* binding */ isVectorType),
/* harmony export */   "parseType": () => (/* binding */ parseType),
/* harmony export */   "parseUintLiteral": () => (/* binding */ parseUintLiteral),
/* harmony export */   "resolveRegister": () => (/* binding */ resolveRegister)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/SystemTypeInstruction */ "/VpG");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "GU3W");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../instructions/AttributeInstruction */ "rs/O");
/* harmony import */ var _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../instructions/SystemFunctionInstruction */ "F8nM");












const USE_STRICT_HALF_TYPE = false;
const TEMPLATE_TYPE = "template";
function parseUintLiteral(value) {
    const match = value.match(/^((0x[a-fA-F0-9]{1,8}?|[0-9]+)(e([+-]?[0-9]+))?)([ulUL]*)$/);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match, `cannot parse uint literal: ${value}`);
    const signed = match[5].toLowerCase().indexOf('u') === -1;
    const exp = Number(match[4] || '0');
    const base = Number(match[2]);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!Number.isNaN(base));
    const heximal = value[1] === 'x';
    return { signed, exp, base, heximal };
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function getSystemType(scope, typeName) {
    //boolean, string, float and others
    let type = scope.findType(typeName);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!type || (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_SystemType));
    return type;
}
function generateSystemType(scope, ...args) {
    let name;
    let size;
    let elementType;
    let length;
    let fields;
    let methods;
    [name, size, elementType, length, fields, methods] = args;
    if (getSystemType(scope, name)) {
        console.error(`type already exists: ${name}`);
        return null;
    }
    const type = new _lib_fx_analisys_instructions_SystemTypeInstruction__WEBPACK_IMPORTED_MODULE_3__.SystemTypeInstruction({ scope, name, elementType, length, fields, size, methods });
    scope.addType(type);
    return type;
}
function defineTypeAlias(scope, typeName, aliasName) {
    scope.addTypeAlias(typeName, aliasName);
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function addFieldsToVectorFromSuffixObject(scope, fields, suffixMap, baseType) {
    for (let suffix in suffixMap) {
        const fieldTypeName = baseType + ((suffix.length > 1) ? suffix.length.toString() : "");
        const fieldBaseType = getSystemType(scope, fieldTypeName);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(fieldBaseType);
        const fieldId = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name: suffix });
        const fieldType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({ scope, type: fieldBaseType, writable: suffixMap[suffix] });
        fields.push(new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({ scope, id: fieldId, type: fieldType }));
    }
}
function generateSuffixLiterals(literals, output = {}, depth = 0) {
    if (depth >= /*literals.length*/ 4) {
        return output;
    }
    if (depth === 0) {
        for (let i = 0; i < literals.length; i++) {
            output[literals[i]] = true;
        }
        depth = 1;
    }
    const outputKeys = Object.keys(output);
    for (let i = 0; i < literals.length; i++) {
        for (let j = 0; j < outputKeys.length; j++) {
            if (outputKeys[j].indexOf(literals[i]) !== -1) {
                output[outputKeys[j] + literals[i]] = false;
            }
            else {
                output[outputKeys[j] + literals[i]] = (output[outputKeys[j]] === false) ? false : true;
            }
        }
    }
    depth++;
    return generateSuffixLiterals(literals, output, depth);
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function isTemplate(typename) {
    return typename.split(' ').slice(-1)[0] === TEMPLATE_TYPE;
}
function parseType(scope, typename, typevalue = null) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(typevalue !== TEMPLATE_TYPE);
    const usagesType = (typevalue ? typename.replace(TEMPLATE_TYPE, typevalue) : typename).split(' ');
    const hash = usagesType.slice(-1)[0];
    const type = getSystemType(scope, hash);
    const usages = usagesType.slice(0, -1);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type !== null);
    usages.forEach(usage => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(['in', 'out', 'inout'].indexOf(usage) !== -1));
    return { type, usages, hash };
}
const systemFunctionHashMap = {};
function _emitException(message) {
    throw new Error(message);
}
// todo: rewrite it!
function _error(code, info = {}) {
    _emitException(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors[code]);
}
const USAGE_VS = 0x01;
const USAGE_PS = 0x02;
const USAGE_GS = 0x04;
const USAGE_CS = 0x08;
const USAGE_HS = 0x10;
const USAGE_DS = 0x20;
const USAGE_CONTROL_FLOW = 0x100;
function generateSystemFunctionInstance(scope, retType, name, paramTypes, usage) {
    const paramList = paramTypes.map((typeDesc, n) => {
        return new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.VariableDeclInstruction({
            type: new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({
                type: typeDesc.type,
                usages: typeDesc.usages,
                scope
            }),
            id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ name: `p${n}`, scope }),
            scope
        });
    });
    const returnType = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_5__.VariableTypeInstruction({
        type: retType.type,
        usages: retType.usages,
        scope
    });
    const pixel = !!(usage & USAGE_PS);
    const vertex = !!(usage & USAGE_VS);
    const extern = !!(usage & USAGE_CONTROL_FLOW);
    const attrs = [];
    if (extern) {
        attrs.push(new _instructions_AttributeInstruction__WEBPACK_IMPORTED_MODULE_9__.AttributeInstruction({ scope, name: 'extern' }));
    }
    const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_2__.IdInstruction({ scope, name });
    const def = new _instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_10__.FunctionDefInstruction({ scope, returnType, id, paramList });
    const func = new _instructions_SystemFunctionInstruction__WEBPACK_IMPORTED_MODULE_11__.SystemFunctionInstruction({ scope, def, pixel, vertex, attrs });
    scope.addFunction(func);
}
/**
 * Exampler:
 *  generateSystemFunction("dot", "dot($1,$2)",   "float",    [TEMPLATE_TYPE, TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
 *                         ^^^^^  ^^^^^^^^^^^^    ^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                         name   translationExpr returnType  argsTypes                       templateTypes
 */
function generateSystemFunction(scope, name, returnTypeName, paramTypeNames, templateTypes, usage = USAGE_VS | USAGE_PS) {
    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(templateTypes)) {
        for (let i = 0; i < templateTypes.length; i++) {
            let funcHash = name + "(";
            let returnType = parseType(scope, returnTypeName, templateTypes[i]);
            let paramTypes = [];
            for (let j = 0; j < paramTypeNames.length; j++) {
                const typeDesc = parseType(scope, paramTypeNames[j], templateTypes[i]);
                paramTypes.push(typeDesc);
                funcHash += typeDesc.hash + ",";
            }
            funcHash += ")";
            if (systemFunctionHashMap[funcHash]) {
                _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });
            }
            generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);
            systemFunctionHashMap[funcHash] = true;
        }
    }
    else {
        if (isTemplate(returnTypeName)) {
            _emitException("Bad return type(TEMPLATE_TYPE) for system function '" + name + "'.");
        }
        let funcHash = name + "(";
        let returnType = parseType(scope, returnTypeName);
        let paramTypes = [];
        for (let i = 0; i < paramTypeNames.length; i++) {
            if (isTemplate(paramTypeNames[i])) {
                _emitException("Bad argument type(TEMPLATE_TYPE) for system function '" + name + "'.");
            }
            else {
                const typeDesc = parseType(scope, paramTypeNames[i]);
                paramTypes.push(typeDesc);
                funcHash += typeDesc.hash + ",";
            }
        }
        funcHash += ")";
        if (systemFunctionHashMap[funcHash]) {
            _error(_lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_7__.EAnalyzerErrors.SystemFunctionRedefinition, { funcName: funcHash });
        }
        generateSystemFunctionInstance(scope, returnType, name, paramTypes, usage);
        systemFunctionHashMap[funcHash] = true;
    }
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
const SCALAR_TYPES = [
    'bool',
    'int',
    'uint',
    'half',
    'float'
];
const INT_TYPES = [
    'int', 'uint'
];
const FLOAT_TYPES = [
    'float'
];
const INT_BASED_TYPES = [
    'int',
    'int2', 'int3', 'int4',
    'int2x2', 'int2x3', 'int2x4',
    'int3x2', 'int3x3', 'int3x4',
    'int4x2', 'int4x3', 'int4x4',
];
const UINT_BASED_TYPES = [
    'uint',
    'uint2', 'uint3', 'uint4',
    'uint2x2', 'uint2x3', 'uint2x4',
    'uint3x2', 'uint3x3', 'uint3x4',
    'uint4x2', 'uint4x3', 'uint4x4',
];
const HALF_BASED_TYPES = [
    'half',
    'half2', 'half3', 'half4',
    'half2x2', 'half2x3', 'half2x4',
    'half3x2', 'half3x3', 'half3x4',
    'half4x2', 'half4x3', 'half4x4',
];
const FLOAT_BASED_TYPES = [
    'float',
    'float2', 'float3', 'float4',
    'float2x2', 'float2x3', 'float2x4',
    'float3x2', 'float3x3', 'float3x4',
    'float4x2', 'float4x3', 'float4x4',
];
const BOOL_BASED_TYPES = [
    'bool',
    'bool2', 'bool3', 'bool4',
    'bool2x2', 'bool2x3', 'bool2x4',
    'bool3x2', 'bool3x3', 'bool3x4',
    'bool4x2', 'bool4x3', 'bool4x4',
];
const VECTOR_TYPES = [
    'bool2', 'bool3', 'bool4',
    'int2', 'int3', 'int4',
    'uint2', 'uint3', 'uint4',
    'half2', 'half3', 'half4',
    'float2', 'float3', 'float4'
];
const MATRIX_TYPES = [
    'bool2x2', 'bool2x3', 'bool2x4', 'bool3x2', 'bool3x3', 'bool3x4', 'bool4x2', 'bool4x3', 'bool4x4',
    'int2x2', 'int2x3', 'int2x4', 'int3x2', 'int3x3', 'int3x4', 'int4x2', 'int4x3', 'int4x4',
    'uint2x2', 'uint2x3', 'uint2x4', 'uint3x2', 'uint3x3', 'uint3x4', 'uint4x2', 'uint4x3', 'uint4x4',
    'half2x2', 'half2x3', 'half2x4', 'half3x2', 'half3x3', 'half3x4', 'half4x2', 'half4x3', 'half4x4',
    'float2x2', 'float2x3', 'float2x4', 'float3x2', 'float3x3', 'float3x4', 'float4x2', 'float4x3', 'float4x4',
];
const BASE_TYPES = [
    ...SCALAR_TYPES, ...VECTOR_TYPES, ...MATRIX_TYPES
];
const UAV_TYPES = [
    'RWTexture1D',
    'RWTexture2D',
    'RWTexture3D',
    'RWBuffer',
    'RWStructuredBuffer',
    'AppendStructuredBuffer'
];
const TEXTURE_TYPES = [
    'Texture1D',
    'Texture2D',
    'Texture3D',
    'TextureCube',
    'Texture2DArray',
    'TextureCubeArray',
    'RWTexture1D',
    'RWTexture2D',
    'RWTexture3D',
];
const BUFFER_TYPES = [
    'Buffer',
    'RWBuffer',
    'RWStructuredBuffer',
    'AppendStructuredBuffer',
    'StructuredBuffer'
];
const SAMPLER_TYPES = [
    'SamplerState',
    'SamplerComparisonState'
];
const BLEND_STATE = 'BlendState';
const DEPTH_STENCIL_STATE = 'DepthStencilState';
const RASTERIZER_STATE = 'RasterizerState';
const SHADER_TYPES = [
    'VertexShader',
    'PixelShader',
    'GeometryShader',
    'HullShader',
    'DomainShader',
    'ComputeShader'
];
const skipTemplate = (name) => name.match(/([\w][\w\d]+)(<[\w][\w\d]+>)?/)[1];
// note: arrays like "Texture2D[5]" also return true in this checks (!)
const isUAV = (type) => UAV_TYPES.includes(skipTemplate(type.name));
const isTexture = (type) => TEXTURE_TYPES.includes(skipTemplate(type.name));
const isBuffer = (type) => BUFFER_TYPES.includes(skipTemplate(type.name));
// note: arrays like "BlendState[5]" also return true in this checks (!)
const isSamplerState = (type) => SAMPLER_TYPES.includes(type.name);
const isBlendState = (type) => [BLEND_STATE].includes(type.name);
const isDepthStencilState = (type) => [DEPTH_STENCIL_STATE].includes(type.name);
const isRasterizerState = (type) => [RASTERIZER_STATE].includes(type.name);
// note: arrays like "BlendState[5]" also return true in this checks (!)
const isPipelineState = (type) => [
    BLEND_STATE,
    DEPTH_STENCIL_STATE,
    RASTERIZER_STATE
].includes(type.name);
const isShaderType = (type) => SHADER_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
// note: arrays like "float4[4]" return false in this checks (!)
const isBase = (type) => BASE_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isVectorType = (type) => VECTOR_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isMatrixType = (type) => MATRIX_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isScalarType = (type) => SCALAR_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isIntegerType = (type) => INT_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isFloatType = (type) => FLOAT_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isIntBasedType = (type) => INT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isUintBasedType = (type) => UINT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isBoolBasedType = (type) => BOOL_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isHalfBasedType = (type) => HALF_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
const isFloatBasedType = (type) => FLOAT_BASED_TYPES.includes(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(type));
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
function resolveRegister(decl) {
    let type = null;
    let index = -1;
    const semantic = decl.semantic;
    if (semantic) {
        const match = semantic.match(/^register\(([utbs]{1})([\d]+)\)$/);
        if (match) {
            type = match[1];
            index = Number(match[2]);
        }
    }
    if (isUAV(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 'u');
        type = 'u';
    }
    if (isTexture(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 't');
        type = 't';
    }
    if (isSamplerState(decl.type)) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 's');
        type = 's';
    }
    if (decl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_CbufferDecl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === null || type === 'b');
        type = 'b';
    }
    // TODO: buffers
    return { type, index };
}
///////////////////////////////////////////////////////
function alignL(content, len) {
    let diff = Math.max(0, len - content.length);
    return `${Array(diff).fill(' ').join('')}${content}`;
}
function alignR(content, len) {
    let diff = Math.max(0, len - content.length);
    return `${content}${Array(diff).fill(' ').join('')}`;
}
class Emitter extends _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__.CodeEmitter {
    emitFunctionDefinition(ctx, def, attrs) {
        const { typeName } = this.resolveType(ctx, def.returnType);
        // this.emitKeyword(alignL(typeName, 10));
        // this.emitKeyword(alignR(def.name, 16));
        attrs?.forEach(attr => this.emitLine(`[${attr.name}]`));
        this.emitKeyword(typeName);
        this.emitKeyword(def.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitParams(ctx, def.params);
        this.emitChar(')');
    }
}
function debugPrint(scope) {
    const ctx = new _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_6__.CodeContext;
    const emitter = new Emitter({ omitEmptyParams: true });
    const { functions, types, typeTemplates } = scope;
    emitter.begin();
    for (let name in types) {
        const type = types[name];
        emitter.emitLine(`// ${type.name};`);
    }
    emitter.end();
    emitter.begin();
    for (let name in typeTemplates) {
        const tpl = typeTemplates[name];
        emitter.emitLine(`// ${tpl.name};`);
    }
    emitter.end();
    emitter.begin();
    for (let name in functions) {
        const overloads = functions[name];
        for (const fn of overloads) {
            emitter.emitFunctionDefinition(ctx, fn.def, fn.attrs);
            emitter.emitChar(';');
            emitter.emitNewline();
        }
        emitter.emitNewline();
    }
    emitter.end();
    return emitter.toString();
}


/***/ }),

/***/ "9oB0":
/*!**********************************************!*\
  !*** ./src/lib/fx/analisys/system/vector.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addSystemTypeVector": () => (/* binding */ addSystemTypeVector)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "BeyE");

function addSystemTypeVector(scope) {
    const XYSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xy");
    const XYZSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xyz");
    const XYZWSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("xyzw");
    const RGSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rg");
    const RGBSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rgb");
    const RGBASuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("rgba");
    const STSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("st");
    const STPSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("stp");
    const STPQSuffix = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSuffixLiterals)("stpq");
    let float = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "float");
    let half = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "half");
    let int = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "int");
    let uint = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "uint");
    let bool = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getSystemType)(scope, "bool");
    let float2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float2", -1, float, 2);
    let float3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float3", -1, float, 3);
    let float4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "float4", -1, float, 4);
    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE) {
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float2', 'half2');
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float3', 'half3');
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.defineTypeAlias)(scope, 'float4', 'half4');
    }
    let int2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int2", -1, int, 2);
    let int3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int3", -1, int, 3);
    let int4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "int4", -1, int, 4);
    let uint2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint2", -1, uint, 2);
    let uint3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint3", -1, uint, 3);
    let uint4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "uint4", -1, uint, 4);
    let bool2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool2", -1, bool, 2);
    let bool3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool3", -1, bool, 3);
    let bool4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "bool4", -1, bool, 4);
    {
        let suf2f = [];
        // program.push(EScopeType.k_Struct);
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, XYSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, RGSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, STSuffix, "float");
        // program.pop();
        suf2f.forEach(field => float2.addField(field));
    }
    {
        let suf3f = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, XYZSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, RGBSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, STPSuffix, "float");
        suf3f.forEach(field => float3.addField(field));
    }
    {
        let suf4f = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, XYZWSuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, RGBASuffix, "float");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, STPQSuffix, "float");
        suf4f.forEach(field => float4.addField(field));
    }
    if (_utils__WEBPACK_IMPORTED_MODULE_0__.USE_STRICT_HALF_TYPE) {
        let half2 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half2", -1, half, 2);
        let half3 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half3", -1, half, 3);
        let half4 = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemType)(scope, "half4", -1, half, 4);
        {
            let suf2f = [];
            // program.push(EScopeType.k_Struct);
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, XYSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, RGSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2f, STSuffix, "half");
            // program.pop();
            suf2f.forEach(field => half2.addField(field));
        }
        {
            let suf3f = [];
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, XYZSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, RGBSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3f, STPSuffix, "half");
            suf3f.forEach(field => half3.addField(field));
        }
        {
            let suf4f = [];
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, XYZWSuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, RGBASuffix, "half");
            (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4f, STPQSuffix, "half");
            suf4f.forEach(field => half4.addField(field));
        }
    }
    {
        let suf2i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, XYSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, RGSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2i, STSuffix, "int");
        suf2i.forEach(field => int2.addField(field));
    }
    {
        let suf3i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, XYZSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, RGBSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3i, STPSuffix, "int");
        suf3i.forEach(field => int3.addField(field));
    }
    {
        let suf4i = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, XYZWSuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, RGBASuffix, "int");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4i, STPQSuffix, "int");
        suf4i.forEach(field => int4.addField(field));
    }
    {
        let suf2ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, XYSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, RGSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2ui, STSuffix, "uint");
        suf2ui.forEach(field => uint2.addField(field));
    }
    {
        let suf3ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, XYZSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, RGBSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3ui, STPSuffix, "uint");
        suf3ui.forEach(field => uint3.addField(field));
    }
    {
        let suf4ui = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, XYZWSuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, RGBASuffix, "uint");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4ui, STPQSuffix, "uint");
        suf4ui.forEach(field => uint4.addField(field));
    }
    {
        let suf2b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, XYSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, RGSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf2b, STSuffix, "bool");
        suf2b.forEach(field => bool2.addField(field));
    }
    {
        let suf3b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, XYZSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, RGBSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf3b, STPSuffix, "bool");
        suf3b.forEach(field => bool3.addField(field));
    }
    {
        let suf4b = [];
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, XYZWSuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, RGBASuffix, "bool");
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addFieldsToVectorFromSuffixObject)(scope, suf4b, STPQSuffix, "bool");
        suf4b.forEach(field => bool4.addField(field));
    }
}


/***/ }),

/***/ "kaOZ":
/*!***************************************!*\
  !*** ./src/lib/fx/autotests/index.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "run": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_parser_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/helpers */ "wKf3");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "sg/z");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__]);
_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




function nativeFromString(str) {
    switch (str.toLowerCase()) {
        case 'true': return true;
        case 'false': return false;
        default:
            return Number(str) || 0;
    }
}
/**
 *
 * @param source SL text document with test markup inside.
 */
async function parse(textDocument) {
    let description = null;
    let tests = [];
    let test;
    let rules = {
        '@autotests': (parts, name, loc) => {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(description));
            description = parts.slice(1).join(' ');
        },
        '@test': (parts, name, loc) => {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(test));
            if (test) {
                return;
            }
            test = {
                name: parts.slice(1).join(' '),
                cases: [],
                loc
            };
        },
        '@expected': (parts, name, loc) => {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(test));
            if (!test) {
                return;
            }
            let [expr, expectedString] = parts.slice(1).join(' ').trim().slice(1, -1).split('==').map(str => str.trim());
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(expr && expectedString);
            let expected = nativeFromString(expectedString);
            test.cases.push({ expr, expected, loc });
        }
    };
    let epilogue = () => {
        test = null;
    };
    let prologue = () => {
        if (test) {
            tests.push(test);
        }
    };
    (await (0,_lib_parser_helpers__WEBPACK_IMPORTED_MODULE_2__.exractComments)(textDocument)).forEach((0,_lib_parser_helpers__WEBPACK_IMPORTED_MODULE_2__.parseComment)(rules, epilogue, prologue));
    const document = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_3__.createFXSLDocument)(textDocument);
    return { description, document, tests };
}
async function runTest(test, document) {
    const { cases } = test;
    for (let exam of cases) {
        const { expr, expected } = exam;
        const result = await _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.evaluate(expr, document);
        exam.passed = result === expected;
        if (!exam.passed) {
            exam.note = `Test failed. Expected is '${expected}', but given is '${result}'`;
        }
    }
    test.passed = cases.reduce((acc, exam) => (acc && exam.passed), true);
}
async function run(autotests) {
    autotests.passed = true;
    for (const test of autotests.tests) {
        await runTest(test, autotests.document);
        autotests.passed = autotests.passed && test.passed;
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "BNML":
/*!**************************************!*\
  !*** ./src/lib/fx/bundles/Bundle.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PACKED": () => (/* binding */ PACKED),
/* harmony export */   "createBundle": () => (/* binding */ createBundle)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM/native */ "1fdM");
/* harmony import */ var _lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/SLASTDocument */ "s/Ev");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/translators/CodeConvolutionEmitter */ "jYc8");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");
/* harmony import */ var _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/translators/GlslEmitter */ "elBL");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils */ "GUxJ");
/* harmony import */ var _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/idl/bundles/auto/cbbundle */ "4mVy");
/* harmony import */ var _lib_idl_bundles_auto_fx_buffer_bundle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/buffer-bundle */ "IMqc");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-content */ "RA5N");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-meta */ "Q8lk");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_signature__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-signature */ "Xra2");
/* harmony import */ var _lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/epart-sim-routines */ "2IwD");
/* harmony import */ var _lib_idl_bundles_auto_fx_glslattribute__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/glslattribute */ "gp8H");
/* harmony import */ var _lib_idl_bundles_auto_fx_mat_bundle__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/mat-bundle */ "5RqF");
/* harmony import */ var _lib_idl_bundles_auto_fx_mat_render_pass__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/mat-render-pass */ "4U8C");
/* harmony import */ var _lib_idl_bundles_auto_fx_part_bundle__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/part-bundle */ "fPGG");
/* harmony import */ var _lib_idl_bundles_auto_fx_part_render_pass__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/part-render-pass */ "bJcc");
/* harmony import */ var _lib_idl_bundles_auto_fx_preset__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/preset */ "BmuJ");
/* harmony import */ var _lib_idl_bundles_auto_fx_preset_entry__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/preset-entry */ "zGvL");
/* harmony import */ var _lib_idl_bundles_auto_fx_render_state__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/render-state */ "2KDM");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-bundle */ "+VBS");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-bytecode-bundle */ "WhBg");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_bytecode_bundle_resources__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-bytecode-bundle-resources */ "ZbwE");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-glslsource-bundle */ "pOt9");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-hlslsource-bundle */ "Jpkv");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-shader-bundle */ "DrVX");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-source-bundle */ "KEtj");
/* harmony import */ var _lib_idl_bundles_auto_fx_texture_bundle__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/texture-bundle */ "dunc");
/* harmony import */ var _lib_idl_bundles_auto_fx_trimesh_bundle__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/trimesh-bundle */ "Rum1");
/* harmony import */ var _lib_idl_bundles_auto_fx_uavbundle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/uavbundle */ "r1qu");
/* harmony import */ var _lib_idl_bundles_auto_fx_uicontrol__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/uicontrol */ "E1+w");
/* harmony import */ var _lib_idl_bundles_auto_fx_view_type_property__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/view-type-property */ "TRYF");
/* harmony import */ var _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @lib/idl/bundles/auto/type-field */ "O/5E");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! flatbuffers */ "qm2M");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_1__]);
([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);









































const PACKED = true;
// global defines from webpack's config;
/// <reference path="../../webpack.d.ts" />
function createFxBundleSignature() {
    return new _lib_idl_bundles_auto_fx_bundle_signature__WEBPACK_IMPORTED_MODULE_17__.BundleSignatureT("development", "0.0.11.8b8be6a", "8b8be6a117aac880cbb0455eed6bbaa0bf71fd55", "develop", "Wed Mar 08 2023 02:32:03 GMT+0300 (Moscow Standard Time)");
}
function createFxBundle(name, type, data, meta = new _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_16__.BundleMetaT, controls, presets) {
    const signature = createFxBundleSignature();
    return new _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_14__.BundleT(name, signature, meta, type, data, controls, presets);
}
function createPartFxRenderPass(slDocument, reflection, opts = {}) {
    const scope = slDocument.root.scope;
    const { geometry, sorting, instanceCount, CSParticlesPrerenderRoutine, drawMode } = reflection;
    const prerender = drawMode == _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_9__.EPassDrawMode.k_Auto
        ? createFxRoutineBytecodeBundle(slDocument, CSParticlesPrerenderRoutine)
        : createFxRoutineNoBytecodeBundle(); // fill dummy routine for backward compartibility
    // create GLSL attribute based instance layout
    const partType = scope.findType(reflection.instance);
    const instance = createFxTypeLayout(partType);
    const vertex = createFxRoutineVsShaderBundle(slDocument, reflection.instance, reflection.VSParticleShader, opts);
    const pixel = createFxRoutinePsShaderBundle(slDocument, reflection.PSParticleShader, opts);
    const routineTypes = [_lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineBytecodeBundle, _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineShaderBundle, _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineShaderBundle];
    const routines = [prerender, vertex, pixel]; // must be aligned with EPartRenderRoutines
    const instanceType = scope.findType(reflection.instance);
    const stride = instanceType.size >> 2;
    const renderStates = Object.keys(reflection.renderStates).map(key => new _lib_idl_bundles_auto_fx_render_state__WEBPACK_IMPORTED_MODULE_26__.RenderStateT(Number(key), Number(reflection.renderStates[key])));
    return new _lib_idl_bundles_auto_fx_part_render_pass__WEBPACK_IMPORTED_MODULE_23__.PartRenderPassT(routineTypes, routines, geometry, sorting, instanceCount, stride, instance, renderStates);
}
function createMatFxRenderPass(slDocument, reflection, opts = {}, convPack = {}) {
    const scope = slDocument.root.scope;
    const vs = createFxRoutineVsShaderBundle(slDocument, reflection.instance, reflection.VSParticleShader, opts, convPack);
    const ps = createFxRoutinePsShaderBundle(slDocument, reflection.PSParticleShader, opts, convPack);
    const routineTypes = [_lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineShaderBundle, _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineShaderBundle];
    const routines = [vs, ps]; // must be aligned with EMatRenderRoutines
    const vertexType = scope.findType(reflection.instance);
    const instance = createFxTypeLayout(vertexType);
    const instanceType = scope.findType(reflection.instance);
    const stride = instanceType.size >> 2;
    const renderStates = Object.keys(reflection.renderStates).map(key => new _lib_idl_bundles_auto_fx_render_state__WEBPACK_IMPORTED_MODULE_26__.RenderStateT(Number(key), Number(reflection.renderStates[key])));
    return new _lib_idl_bundles_auto_fx_mat_render_pass__WEBPACK_IMPORTED_MODULE_21__.MatRenderPassT(routineTypes, routines, instance, stride, renderStates);
}
function createFxTypeLayout(type) {
    return (0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_1__.typeAstToTypeLayout)(type);
}
function createFxRoutineNoBytecodeBundle() {
    return new _lib_idl_bundles_auto_fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_28__.RoutineBytecodeBundleT();
}
function createFxRoutineBytecodeBundle(slDocument, reflection) {
    const entry = reflection.name;
    const numthreads = [...reflection.numthreads];
    const bcDocument = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__.translate(slDocument, entry);
    if (bcDocument.diagnosticReport.errors) {
        // const content = CodeEmitter.translateDocument(slDocument);
        // const step = (y, x) => x > y ? 1 : 0;
        // const pad = (x) => Array(step(x, 1000) + step(x, 100) + step(x, 10)).fill(' ').join('') + x;
        // console.log(content.split('\n').map((line, i) => `${pad(i + 1)}. ${line}`).join('\n'));
        console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_10__.Diagnostics.stringify(bcDocument.diagnosticReport));
        alert('could not generate bytecode, see console log for details');
    }
    const code = bcDocument.program?.code;
    if (!code) {
        return new _lib_idl_bundles_auto_fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_28__.RoutineBytecodeBundleT();
    }
    const uavs = reflection.uavs.map(({ name, register: slot, elementType }) => {
        const typeInstr = slDocument.root.scope.findType(elementType);
        const stride = typeInstr.size; // in bytes
        const type = createFxTypeLayout(typeInstr);
        return new _lib_idl_bundles_auto_fx_uavbundle__WEBPACK_IMPORTED_MODULE_36__.UAVBundleT(name, slot, stride, type);
    });
    const buffers = reflection.buffers.map(({ name, register: slot, elementType }) => {
        const typeInstr = slDocument.root.scope.findType(elementType);
        const stride = typeInstr.size; // in bytes
        const type = createFxTypeLayout(typeInstr);
        return new _lib_idl_bundles_auto_fx_buffer_bundle__WEBPACK_IMPORTED_MODULE_13__.BufferBundleT(name, slot, stride, type);
    });
    const textures = reflection.textures.map(({ name, register: slot, elementType }) => {
        const typeInstr = slDocument.root.scope.findType(elementType);
        const stride = typeInstr.size; // in bytes
        const type = createFxTypeLayout(typeInstr);
        return new _lib_idl_bundles_auto_fx_texture_bundle__WEBPACK_IMPORTED_MODULE_34__.TextureBundleT(name, slot, stride, type);
    });
    const trimeshes = reflection.trimeshes.map(({ name, vertexCountUName, faceCountUName, verticesName, facesName, indicesAdjName, faceAdjName }) => {
        return new _lib_idl_bundles_auto_fx_trimesh_bundle__WEBPACK_IMPORTED_MODULE_35__.TrimeshBundleT(name, vertexCountUName, faceCountUName, verticesName, facesName, indicesAdjName, faceAdjName);
    });
    return new _lib_idl_bundles_auto_fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_28__.RoutineBytecodeBundleT(Array.from(code), new _lib_idl_bundles_auto_fx_routine_bytecode_bundle_resources__WEBPACK_IMPORTED_MODULE_29__.RoutineBytecodeBundleResourcesT(uavs, buffers, textures, trimeshes), numthreads);
}
// function createFxPass11BytecodeBundle(pass11: IPass11Instruction): Pass11BytecodeBundleT {
//     // todo: translate pass
//     return new Pass11BytecodeBundleT();
// }
function createFxRoutineVsGLSLBundle(slDocument, interpolatorsType, entryName, { name } = {}) {
    const scope = slDocument.root.scope;
    const fn = scope.findFunction(entryName, null);
    if (!fn) {
        return new _lib_idl_bundles_auto_fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_30__.RoutineGLSLSourceBundleT();
    }
    const partType = scope.findType(interpolatorsType);
    const instance = createFxTypeLayout(partType);
    const attrsGLSL = instance.fields.map(field => {
        let size = field.size >> 2;
        let offset = field.padding >> 2;
        let attrName = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__.GLSLEmitter.$declToAttributeName(partType.getField(field.name));
        return new _lib_idl_bundles_auto_fx_glslattribute__WEBPACK_IMPORTED_MODULE_19__.GLSLAttributeT(size, offset, attrName);
    });
    const ctx = new _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__.GLSLContext({ mode: 'vs' });
    const codeGLSL = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__.GLSLEmitter.translate(fn, ctx); // raw hlsl
    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {
        const fields = scope.findCbuffer(name).type.fields.map(f => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_39__.TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));
        return new _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_12__.CBBundleT(name, register, size, fields);
    });
    return new _lib_idl_bundles_auto_fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_30__.RoutineGLSLSourceBundleT(codeGLSL, attrsGLSL, cbuffers);
}
function createFxRoutineVsHLSLBundle(slDocument, entryName, { name } = {}, { textDocument, slastDocument } = {}) {
    const scope = slDocument.root.scope;
    const fn = scope.findFunction(entryName, null);
    if (!fn) {
        return new _lib_idl_bundles_auto_fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_31__.RoutineHLSLSourceBundleT();
    }
    // set entry point name according with bundle name
    const ctx = new _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_5__.CodeConvolutionContext({ textDocument, slastDocument, mode: 'vs', entryName: name });
    const codeHLSL = _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_5__.CodeConvolutionEmitter.translate(fn, ctx); // raw hlsl
    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {
        const fields = scope.findCbuffer(name).type.fields.map(f => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_39__.TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));
        return new _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_12__.CBBundleT(name, register, size, fields);
    });
    return new _lib_idl_bundles_auto_fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_31__.RoutineHLSLSourceBundleT(codeHLSL, name, cbuffers);
}
function createFxRoutineVsShaderBundle(slDocument, interpolatorsType, entryName, opts = {}, convPack = {}) {
    const shaderType = [];
    const shaderBundles = [];
    if (!opts.omitGLSL) {
        shaderType.push(_lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_33__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        shaderBundles.push(createFxRoutineVsGLSLBundle(slDocument, interpolatorsType, entryName, opts));
    }
    if (!opts.omitHLSL) {
        shaderType.push(_lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_33__.RoutineSourceBundle.RoutineHLSLSourceBundle);
        shaderBundles.push(createFxRoutineVsHLSLBundle(slDocument, entryName, opts, convPack));
    }
    return new _lib_idl_bundles_auto_fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_32__.RoutineShaderBundleT(shaderType, shaderBundles);
}
function createFxRoutinePsGLSLBundle(slDocument, entryName, { name } = {}) {
    const scope = slDocument.root.scope;
    const fn = scope.findFunction(entryName, null);
    if (!fn) {
        return new _lib_idl_bundles_auto_fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_30__.RoutineGLSLSourceBundleT();
    }
    // set entry point name according with bundle name
    const ctx = new _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__.GLSLContext({ mode: 'ps' });
    const codeGLSL = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_7__.GLSLEmitter.translate(fn, ctx); // raw hlsl
    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {
        const fields = scope.findCbuffer(name).type.fields.map(f => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_39__.TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));
        return new _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_12__.CBBundleT(name, register, size, fields);
    });
    return new _lib_idl_bundles_auto_fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_30__.RoutineGLSLSourceBundleT(codeGLSL, [], cbuffers);
}
function createFxRoutinePsHLSLBundle(slDocument, entryName, { name } = {}, { textDocument, slastDocument } = {}) {
    const scope = slDocument.root.scope;
    const fn = scope.findFunction(entryName, null);
    if (!fn) {
        return new _lib_idl_bundles_auto_fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_31__.RoutineHLSLSourceBundleT();
    }
    // set entry point name according with bundle name
    const ctx = new _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_5__.CodeConvolutionContext({ textDocument, slastDocument, mode: 'ps', entryName: name });
    const codeHLSL = _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_5__.CodeConvolutionEmitter.translate(fn, ctx); // raw hlsl
    const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {
        const fields = scope.findCbuffer(name).type.fields.map(f => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_39__.TypeFieldT(createFxTypeLayout(f.type), f.name, f.semantic, f.type.size, f.type.padding));
        return new _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_12__.CBBundleT(name, register, size, fields);
    });
    return new _lib_idl_bundles_auto_fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_31__.RoutineHLSLSourceBundleT(codeHLSL, name, cbuffers);
}
function createFxRoutinePsShaderBundle(slDocument, entryName, opts = {}, convPack = {}) {
    const shaderType = [];
    const shaderBundles = [];
    if (!opts.omitGLSL) {
        shaderType.push(_lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_33__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        shaderBundles.push(createFxRoutinePsGLSLBundle(slDocument, entryName, opts));
    }
    if (!opts.omitHLSL) {
        shaderType.push(_lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_33__.RoutineSourceBundle.RoutineHLSLSourceBundle);
        shaderBundles.push(createFxRoutinePsHLSLBundle(slDocument, entryName, opts, convPack));
    }
    return new _lib_idl_bundles_auto_fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_32__.RoutineShaderBundleT(shaderType, shaderBundles);
}
function createFxControls(controls) {
    return controls.map(ctrl => {
        const props = ctrl.properties.map(prop => new _lib_idl_bundles_auto_fx_view_type_property__WEBPACK_IMPORTED_MODULE_38__.ViewTypePropertyT(prop.name, (0,_utils__WEBPACK_IMPORTED_MODULE_11__.propertyValueFromString)(prop.type), (0,_utils__WEBPACK_IMPORTED_MODULE_11__.encodePropertyValue)(prop.type, prop.value)));
        return new _lib_idl_bundles_auto_fx_uicontrol__WEBPACK_IMPORTED_MODULE_37__.UIControlT(ctrl.name, (0,_utils__WEBPACK_IMPORTED_MODULE_11__.controlValueFromString)(ctrl.type), (0,_utils__WEBPACK_IMPORTED_MODULE_11__.encodeControlValue)(ctrl.type, ctrl.value), props);
    });
}
function createFxPresets(presets) {
    return presets.map(({ name, desc, data }) => new _lib_idl_bundles_auto_fx_preset__WEBPACK_IMPORTED_MODULE_24__.PresetT(name, desc, data.map(({ name, type, value }) => new _lib_idl_bundles_auto_fx_preset_entry__WEBPACK_IMPORTED_MODULE_25__.PresetEntryT(name, (0,_utils__WEBPACK_IMPORTED_MODULE_11__.controlValueFromString)(type), (0,_utils__WEBPACK_IMPORTED_MODULE_11__.encodeControlValue)(type, value)))));
}
function finalizeBundle(bundle, opts = {}) {
    // get unpacked version
    // --------------------------------
    let { packed = PACKED } = opts;
    if (!packed)
        return bundle;
    // get packed version
    // --------------------------------
    let fbb = new flatbuffers__WEBPACK_IMPORTED_MODULE_40__.Builder();
    let end = bundle.pack(fbb);
    fbb.finish(end);
    return fbb.asUint8Array();
}
async function createPartFxBundle(fx, opts = {}) {
    const ctx = new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_6__.FxTranslatorContext({ ...opts.translator });
    const raw = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_6__.FxTranslator.translate(fx, ctx); // raw hlsl
    const reflection = ctx.techniques[0];
    const { name, capacity } = reflection;
    opts.name ||= name;
    const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__.createTextDocument)('://raw', raw);
    const slDocument = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__.createSLDocument)(textDocument);
    const scope = slDocument.root.scope;
    if (slDocument.diagnosticReport.errors) {
        console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_10__.Diagnostics.stringify(slDocument.diagnosticReport));
        return null;
    }
    const particle = createFxTypeLayout(scope.findType(reflection.particle));
    const routines = Array(_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Last);
    const routineTypes = Array(_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Last);
    routineTypes[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Reset] = _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineBytecodeBundle;
    routines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Reset] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesResetRoutine);
    routineTypes[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Spawn] = _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineBytecodeBundle;
    routines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Spawn] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesSpawnRoutine);
    routineTypes[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Init] = _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineBytecodeBundle;
    routines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Init] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesInitRoutine);
    routineTypes[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Update] = _lib_idl_bundles_auto_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_27__.RoutineBundle.RoutineBytecodeBundle;
    routines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_18__.EPartSimRoutines.k_Update] = createFxRoutineBytecodeBundle(slDocument, reflection.CSParticlesUpdateRoutine);
    const passes = reflection.passes.map(pass => createPartFxRenderPass(slDocument, pass, opts));
    const part = new _lib_idl_bundles_auto_fx_part_bundle__WEBPACK_IMPORTED_MODULE_22__.PartBundleT(capacity, routineTypes, routines, passes, particle);
    const controls = createFxControls(reflection.controls);
    const presets = createFxPresets(reflection.presets);
    const { meta } = opts;
    const bundle = createFxBundle(opts.name, _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_15__.BundleContent.PartBundle, part, new _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_16__.BundleMetaT(meta?.author, meta?.source), controls, presets);
    return finalizeBundle(bundle, opts);
}
/** @deprecated */
async function createMatFxBundle(tech, opts = {}, convPack = {}) {
    const { includeResolver, defines } = convPack;
    const { textDocument, slastDocument } = convPack;
    const ctx = new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_6__.FxTranslatorContext({ ...opts.translator, textDocument, slastDocument });
    const raw = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_6__.FxTranslator.translate(tech, ctx);
    const reflection = ctx.techniques[0];
    const { name } = reflection;
    opts.name ||= name;
    const textDocument3 = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__.createTextDocument)('file://foo.bar///mat.fx', raw);
    const slastDocument3 = await (0,_lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_2__.createSLASTDocument)(textDocument3, { includeResolver, defines });
    const slDocument = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__.createSLDocument)(slastDocument3);
    if (slDocument.diagnosticReport.errors) {
        console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_10__.Diagnostics.stringify(slDocument.diagnosticReport));
        return null;
    }
    const passes = reflection.passes.map(pass => createMatFxRenderPass(slDocument, pass, opts, new _utils__WEBPACK_IMPORTED_MODULE_11__.ConvolutionPackEx(textDocument3, slastDocument3, includeResolver, defines)));
    const mat = new _lib_idl_bundles_auto_fx_mat_bundle__WEBPACK_IMPORTED_MODULE_20__.MatBundleT(passes);
    const controls = createFxControls(reflection.controls);
    const presets = createFxPresets(reflection.presets);
    const { meta } = opts;
    const bundle = createFxBundle(opts.name, _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_15__.BundleContent.MatBundle, mat, new _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_16__.BundleMetaT(meta?.author, meta?.source), controls, presets);
    return finalizeBundle(bundle, opts);
}
async function createBundle(fx, options, convPack) {
    switch (fx.instructionType) {
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_PartFxDecl:
            return createPartFxBundle(fx, options);
        case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_TechniqueDecl:
            return createMatFxBundle(fx, options, convPack);
    }
    console.assert(false);
    return null;
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "uI6s":
/*!****************************************!*\
  !*** ./src/lib/fx/bundles/Bundle11.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createBundle": () => (/* binding */ createBundle)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM/native */ "1fdM");
/* harmony import */ var _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bundle */ "8VxU");
/* harmony import */ var _lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/SLASTDocument */ "s/Ev");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/translators/CodeConvolutionEmitter */ "jYc8");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");
/* harmony import */ var _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/bundles/auto/type-field */ "O/5E");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils */ "GUxJ");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @lib/idl/bundles/auto/cbbundle */ "4mVy");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-content */ "RA5N");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-meta */ "Q8lk");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_signature__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-signature */ "Xra2");
/* harmony import */ var _lib_idl_bundles_auto_fx_pixel_shader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/pixel-shader */ "23YT");
/* harmony import */ var _lib_idl_bundles_auto_fx_shader__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/shader */ "X2z1");
/* harmony import */ var _lib_idl_bundles_auto_fx_technique11bundle__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/technique11bundle */ "mGiJ");
/* harmony import */ var _lib_idl_bundles_auto_fx_technique11render_pass__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/technique11render-pass */ "s7GX");
/* harmony import */ var _lib_idl_bundles_auto_fx_uicontrol__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/uicontrol */ "E1+w");
/* harmony import */ var _lib_idl_bundles_auto_fx_vertex_shader__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/vertex-shader */ "Gw1M");
/* harmony import */ var _lib_idl_bundles_auto_fx_view_type_property__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/view-type-property */ "TRYF");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_3__]);
([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



























/** Create flatbuffers controls from native translator description. */
function createFxControls(controls) {
    return controls.map(ctrl => {
        const props = ctrl.properties.map(prop => new _lib_idl_bundles_auto_fx_view_type_property__WEBPACK_IMPORTED_MODULE_26__.ViewTypePropertyT(prop.name, (0,_utils__WEBPACK_IMPORTED_MODULE_13__.propertyValueFromString)(prop.type), (0,_utils__WEBPACK_IMPORTED_MODULE_13__.encodePropertyValue)(prop.type, prop.value)));
        return new _lib_idl_bundles_auto_fx_uicontrol__WEBPACK_IMPORTED_MODULE_24__.UIControlT(ctrl.name, (0,_utils__WEBPACK_IMPORTED_MODULE_13__.controlValueFromString)(ctrl.type), (0,_utils__WEBPACK_IMPORTED_MODULE_13__.encodeControlValue)(ctrl.type, ctrl.value), props);
    });
}
/// <reference path="../../webpack.d.ts" />
function createFxBundle(name, type, data, meta = new _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_18__.BundleMetaT, controls, presets) {
    const signature = new _lib_idl_bundles_auto_fx_bundle_signature__WEBPACK_IMPORTED_MODULE_19__.BundleSignatureT("development", "0.0.11.8b8be6a", "8b8be6a117aac880cbb0455eed6bbaa0bf71fd55", "develop", "Wed Mar 08 2023 02:32:03 GMT+0300 (Moscow Standard Time)");
    return new _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_16__.BundleT(name, signature, meta, type, data, controls, presets);
}
function finalizeBundle(bundle, opts = {}) {
    // get unpacked version
    // --------------------------------
    let { packed = true } = opts;
    if (!packed)
        return bundle;
    // get packed version
    // --------------------------------
    let fbb = new flatbuffers__WEBPACK_IMPORTED_MODULE_14__.Builder();
    let end = bundle.pack(fbb);
    fbb.finish(end);
    return fbb.asUint8Array();
}
/**
 * Pipeline:
 *  1. Translate the whole technique to raw hlsl
 *     in order to unwrap fx types (like trimeshes)
 *     and collect autogen buffers (like controls, global & local uniforms).
 *  2. Iterate over pass code to find all used shaders to print raw per
 *     shader hlsl code with precise reflections (used cbuffers).
 *  3. Wrap with flatbuffers.
 */
async function createTechnique11Bundle(tech, opts = {}, convPack = {}) {
    const ctx = new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_8__.FxTranslatorContext({ ...opts.translator, ...convPack });
    const codeRaw = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_8__.FxTranslator.translate(tech, ctx);
    const passes = [];
    for (const pass11 of tech.passes) {
        const { program } = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.translate(pass11);
        // depth, stencil, rasterizer and blend states are already serialized
        // as part of code binary
        const { code, cdl } = program;
        const chunks = _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_3__.decodeChunks(code);
        const shaderChunk = chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_10__.EChunkType.k_Shaders];
        const shaderTypes = [];
        const shaders = [];
        if ((0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_12__.isDef)(shaderChunk)) {
            const descs = _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_3__.decodeShadersChunk(shaderChunk);
            for (const desc of descs) {
                const { ver, args, name } = desc;
                console.warn(`compile shader <${name}> -v ${ver}`, args);
                // it's assumed that all the shaders places in the same scope for now
                // (near the technique it'self in other words - not imported)
                {
                    const scope = tech.scope;
                    const entryFn = scope.findFunction(name, null);
                    const params = entryFn.def.params;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.every((_, i) => [...params].reverse()[i].type.name === [...args].reverse()[i].type), 'entry function doesn\'t match uniform arguments');
                }
                const mode = ver.substring(0, 2);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(['vs', 'ps', 'gs'].includes(mode), `invalid mode: "${mode}"`);
                // translate per shader in order to extract precise reflection
                const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_6__.createTextDocument)(`file://${tech.name}///${name}.fx`, codeRaw);
                const slastDocument = await (0,_lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_4__.createSLASTDocument)(textDocument, convPack);
                const slDocument = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_5__.createSLDocument)(slastDocument);
                const convPackSh = new _utils__WEBPACK_IMPORTED_MODULE_13__.ConvolutionPackEx(textDocument, slastDocument, convPack.includeResolver, convPack.defines);
                if (slDocument.diagnosticReport.errors) {
                    console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_11__.Diagnostics.stringify(slDocument.diagnosticReport));
                    return null;
                }
                const scope = slDocument.root.scope;
                const entryFn = scope.findFunction(name, null);
                const ctx = new _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_7__.CodeConvolutionContext({ ...convPackSh, mode, constants: args });
                const sourceCode = _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_7__.CodeConvolutionEmitter.translate(entryFn, ctx);
                const cbuffers = ctx.cbuffers.map(({ name, register, size }) => {
                    const { type } = scope.findCbuffer(name);
                    const fields = type.fields.map(f => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_9__.TypeFieldT((0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__.typeAstToTypeLayout)(f.type), f.name, f.semantic, f.type.size, f.type.padding));
                    return new _lib_idl_bundles_auto_cbbundle__WEBPACK_IMPORTED_MODULE_15__.CBBundleT(name, register, size, fields);
                });
                let shaderType;
                let shader;
                switch (mode) {
                    case 'vs':
                        let input = (0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__.typeAstToTypeLayout)(entryFn.def.params[0].type);
                        shaderType = _lib_idl_bundles_auto_fx_shader__WEBPACK_IMPORTED_MODULE_21__.Shader.VertexShader;
                        shader = new _lib_idl_bundles_auto_fx_vertex_shader__WEBPACK_IMPORTED_MODULE_25__.VertexShaderT(sourceCode, name, input, cbuffers);
                        break;
                    case 'ps':
                        shaderType = _lib_idl_bundles_auto_fx_shader__WEBPACK_IMPORTED_MODULE_21__.Shader.PixelShader;
                        shader = new _lib_idl_bundles_auto_fx_pixel_shader__WEBPACK_IMPORTED_MODULE_20__.PixelShaderT(sourceCode, name, cbuffers);
                        break;
                    default:
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'not implemeted');
                }
                shaderTypes.push(shaderType);
                shaders.push(shader);
            }
        }
        passes.push(new _lib_idl_bundles_auto_fx_technique11render_pass__WEBPACK_IMPORTED_MODULE_23__.Technique11RenderPassT([...code], shaderTypes, shaders));
    }
    ;
    ///////////////////////////////////
    const { name } = tech;
    opts.name ||= name;
    const reflection = ctx.techniques11[0];
    const controls = createFxControls(reflection.controls);
    // todo: add presets support.
    // const presets = ...
    const tech11 = new _lib_idl_bundles_auto_fx_technique11bundle__WEBPACK_IMPORTED_MODULE_22__.Technique11BundleT(passes);
    const { meta } = opts;
    const bundle = createFxBundle(opts.name, _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_17__.BundleContent.Technique11Bundle, tech11, new _lib_idl_bundles_auto_fx_bundle_meta__WEBPACK_IMPORTED_MODULE_18__.BundleMetaT(meta?.author, meta?.source), controls);
    return finalizeBundle(bundle, opts);
}
async function createBundle(fx, options, convPack) {
    return createTechnique11Bundle(fx, options, convPack);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "GUxJ":
/*!*************************************!*\
  !*** ./src/lib/fx/bundles/utils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConvolutionPackEx": () => (/* binding */ ConvolutionPackEx),
/* harmony export */   "cloneValue": () => (/* binding */ cloneValue),
/* harmony export */   "colorToUint": () => (/* binding */ colorToUint),
/* harmony export */   "controlValueFromString": () => (/* binding */ controlValueFromString),
/* harmony export */   "controlValueToString": () => (/* binding */ controlValueToString),
/* harmony export */   "decodeBundleControls": () => (/* binding */ decodeBundleControls),
/* harmony export */   "decodeControlValue": () => (/* binding */ decodeControlValue),
/* harmony export */   "decodeControls": () => (/* binding */ decodeControls),
/* harmony export */   "decodePresets": () => (/* binding */ decodePresets),
/* harmony export */   "decodePropertyValue": () => (/* binding */ decodePropertyValue),
/* harmony export */   "decodeValues": () => (/* binding */ decodeValues),
/* harmony export */   "encodeControlValue": () => (/* binding */ encodeControlValue),
/* harmony export */   "encodePlaygroundControlsToString": () => (/* binding */ encodePlaygroundControlsToString),
/* harmony export */   "encodePropertyValue": () => (/* binding */ encodePropertyValue),
/* harmony export */   "propertyValueFromString": () => (/* binding */ propertyValueFromString),
/* harmony export */   "propertyValueToString": () => (/* binding */ propertyValueToString),
/* harmony export */   "uintToColor": () => (/* binding */ uintToColor)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _lib_idl_bundles_auto_fx_uint_value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/uint-value */ "1Yqr");
/* harmony import */ var _lib_idl_bundles_auto_fx_int_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/int-value */ "IJKq");
/* harmony import */ var _lib_idl_bundles_auto_fx_float_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/float-value */ "5CMk");
/* harmony import */ var _lib_idl_bundles_auto_fx_string_value__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/string-value */ "1Bqd");
/* harmony import */ var _lib_idl_bundles_auto_fx_float2value__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/float2value */ "cHyH");
/* harmony import */ var _lib_idl_bundles_auto_fx_float3value__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/float3value */ "Gjvx");
/* harmony import */ var _lib_idl_bundles_auto_fx_float4value__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/float4value */ "6wsJ");
/* harmony import */ var _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/control-value */ "Nk0z");
/* harmony import */ var _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/property-value */ "meSg");
/* harmony import */ var _lib_idl_bundles_auto_fx_color_value__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/color-value */ "Lmwj");
/* harmony import */ var _lib_idl_bundles_auto_fx_texture_value__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/texture-value */ "J5jW");
/* harmony import */ var _lib_idl_bundles_auto_fx_mesh_value__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/mesh-value */ "6gZf");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");















// -----------------------------------------------------------------------------------------
/** Get flatbuffers control value type from string constant. */
function controlValueFromString(type) {
    switch (type) {
        case 'int': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.IntValue;
        case 'uint': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.UintValue;
        case 'float': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.FloatValue;
        case 'float2': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float2Value;
        case 'float3': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float3Value;
        case 'float4': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float4Value;
        case 'color': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.ColorValue;
        case 'texture2d': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.TextureValue;
        case 'mesh': return _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.MeshValue;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported control type');
    return null;
}
/** Get flatbuffers property value type from string constant. */
function propertyValueFromString(type) {
    switch (type) {
        case 'int': return _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.IntValue;
        case 'uint': return _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.UintValue;
        case 'float': return _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.FloatValue;
        case 'string': return _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.StringValue;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported property type');
    return null;
}
/** Encode native JS data to flatbuffers value. */
function encodeControlValue(type, data) {
    switch (type) {
        case 'int': return new _lib_idl_bundles_auto_fx_int_value__WEBPACK_IMPORTED_MODULE_3__.IntValueT(data);
        case 'uint': return new _lib_idl_bundles_auto_fx_uint_value__WEBPACK_IMPORTED_MODULE_2__.UintValueT(data);
        case 'float': return new _lib_idl_bundles_auto_fx_float_value__WEBPACK_IMPORTED_MODULE_4__.FloatValueT(data);
        case 'float2':
            let v2 = data;
            return new _lib_idl_bundles_auto_fx_float2value__WEBPACK_IMPORTED_MODULE_6__.Float2ValueT(v2.x, v2.y);
        case 'float3':
            let v3 = data;
            return new _lib_idl_bundles_auto_fx_float3value__WEBPACK_IMPORTED_MODULE_7__.Float3ValueT(v3.x, v3.y, v3.z);
        case 'float4':
            let v4 = data;
            return new _lib_idl_bundles_auto_fx_float4value__WEBPACK_IMPORTED_MODULE_8__.Float4ValueT(v4.x, v4.y, v4.z, v4.w);
        case 'color':
            let color = data;
            let r = Math.max(0, Math.min(255, color.r * 255));
            let g = Math.max(0, Math.min(255, color.g * 255));
            let b = Math.max(0, Math.min(255, color.b * 255));
            let a = Math.max(0, Math.min(255, color.a * 255));
            return new _lib_idl_bundles_auto_fx_color_value__WEBPACK_IMPORTED_MODULE_11__.ColorValueT(r, g, b, a);
        case 'texture2d':
            return new _lib_idl_bundles_auto_fx_texture_value__WEBPACK_IMPORTED_MODULE_12__.TextureValueT(data);
        case 'mesh':
            return new _lib_idl_bundles_auto_fx_mesh_value__WEBPACK_IMPORTED_MODULE_13__.MeshValueT(data);
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported control type');
    return null;
}
/** Encode native JS data to flatbuffers value. */
function encodePropertyValue(type, data) {
    switch (type) {
        case 'int': return new _lib_idl_bundles_auto_fx_int_value__WEBPACK_IMPORTED_MODULE_3__.IntValueT(data);
        case 'uint': return new _lib_idl_bundles_auto_fx_uint_value__WEBPACK_IMPORTED_MODULE_2__.UintValueT(data);
        case 'float': return new _lib_idl_bundles_auto_fx_float_value__WEBPACK_IMPORTED_MODULE_4__.FloatValueT(data);
        case 'string': return new _lib_idl_bundles_auto_fx_string_value__WEBPACK_IMPORTED_MODULE_5__.StringValueT(data);
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported property type');
    return null;
}
function controlValueToString(type) {
    switch (type) {
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.IntValue: return 'int';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.UintValue: return 'uint';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.FloatValue: return 'float';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float2Value: return 'float2';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float3Value: return 'float3';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float4Value: return 'float4';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.ColorValue: return 'color';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.TextureValue: return 'texture2d';
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.MeshValue: return 'mesh';
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported control value type');
    return null;
}
function propertyValueToString(type) {
    switch (type) {
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.IntValue: return 'int';
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.UintValue: return 'uint';
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.FloatValue: return 'float';
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.StringValue: return 'string';
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported property value type');
    return null;
}
function decodeControlValue(type, data) {
    switch (type) {
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.IntValue: return data.value;
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.UintValue: return data.value;
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.FloatValue: return data.value;
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float2Value:
            let v2 = data;
            return { x: v2.x, y: v2.y };
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float3Value:
            let v3 = data;
            return { x: v3.x, y: v3.y, z: v3.z };
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.Float4Value:
            let v4 = data;
            return { x: v4.x, y: v4.y, z: v4.z, w: v4.w };
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.ColorValue:
            let color = data;
            return { r: color.r / 255, g: color.g / 255, b: color.b / 255, a: color.a / 255 };
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.TextureValue:
            return data.value;
        case _lib_idl_bundles_auto_fx_control_value__WEBPACK_IMPORTED_MODULE_9__.ControlValue.MeshValue:
            return data.value;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported control value type');
    return null;
}
function decodePropertyValue(type, data) {
    switch (type) {
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.IntValue: return data.value;
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.UintValue: return data.value;
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.FloatValue: return data.value;
        case _lib_idl_bundles_auto_fx_property_value__WEBPACK_IMPORTED_MODULE_10__.PropertyValue.StringValue: return data.value;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported property value type');
    return null;
}
// -----------------------------------------------------------------------------------------
/** Decode flatbufers control descriptions to native, playground ready, description. */
function decodeControls(controlsFx) {
    let controls = {};
    controlsFx.forEach(controlFx => {
        let properties = {};
        let controlName = controlFx.name;
        // controlFx.values an array of the same types
        // so valuesType contains the same values
        let controlType = controlValueToString(controlFx.valueType);
        controlFx.properties.forEach(propFx => {
            const name = propFx.name;
            const value = decodePropertyValue(propFx.valueType, propFx.value);
            properties[name] = value;
        });
        controls[controlName] = {
            name: controlName,
            type: controlType,
            properties: properties
        };
    });
    return controls;
}
/** Decode flatbufers control values to native values. */
function decodeValues(controls) {
    let values = {};
    controls.forEach(ctrl => values[ctrl.name] = decodeControlValue(ctrl.valueType, ctrl.value));
    return values;
}
/** Decode flatbufers presets to native, playground ready, presets. */
function decodePresets(presets) {
    // some kind of muddy and clumsy convert from flatbuffers to native TS :/
    return presets.map(({ name, desc, data }) => ({
        name: name,
        desc: desc,
        data: data.map(({ name, valueType, value }) => ({
            name: name,
            type: controlValueToString(valueType),
            value: decodeControlValue(valueType, value)
        }))
    }));
}
function decodeBundle(data) {
    let fx = null;
    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts
    if (data instanceof Uint8Array) {
        fx = new _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_14__.BundleT();
        _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_14__.Bundle.getRootAsBundle(new flatbuffers__WEBPACK_IMPORTED_MODULE_1__.ByteBuffer(data)).unpackTo(fx);
    }
    else {
        fx = data;
    }
    return fx;
}
function decodeBundleControls(data) {
    const fx = decodeBundle(data);
    const controls = decodeControls(fx.controls);
    const values = decodeValues(fx.controls);
    const presets = decodePresets(fx.presets);
    return { controls, values, presets };
}
function encodePlaygroundControlsToString(controls) {
    let data = [];
    for (let name in controls.values) {
        const value = controls.values[name];
        const elements = [];
        const args = [];
        switch (controls.controls[name].type) {
            case 'int':
            case 'uint':
                args.push(Math.round(Number(value)));
                break;
            case 'float':
                args.push(value);
                break;
            case 'float2':
                let v2 = value;
                args.push(v2.x, v2.y);
                break;
            case 'float3':
                let v3 = value;
                args.push(v3.x, v3.y, v3.z);
                break;
            case 'float4':
                let v4 = value;
                args.push(v4.x, v4.y, v4.z, v4.w);
                break;
            case 'color':
                let color = value;
                args.push(color.r, color.g, color.b, color.a);
                break;
        }
        data.push(`${name} = { ${args.join(', ')} }`);
    }
    return [...data, null].join(';\n');
    return "";
}
function cloneValue(type, value) {
    switch (type) {
        case 'int':
        case 'uint':
        case 'float':
            return value;
        case 'float2': return { ...value };
        case 'float3': return { ...value };
        case 'float4': return { ...value };
        case 'color': return { ...value };
        case 'texture2d': return value;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported control type');
    return null;
}
function colorToUint({ r, g, b, a }) {
    [r, g, b, a] = [r, g, b, a].map(x => Math.max(0, Math.min(255, x * 255)));
    return /*a << 24 | */ b << 0 | g << 8 | r << 16;
}
function uintToColor(src, dst) {
    dst.r = ((src >> 16) & 0xff) / 255.0;
    dst.g = ((src >> 8) & 0xff) / 255.0;
    dst.b = ((src >> 0) & 0xff) / 255.0;
}
// -----------------------------------------------------------------------------------------
class ConvolutionPackEx {
    constructor(textDocument, slastDocument, includeResolver, defines) {
        this.textDocument = textDocument;
        this.slastDocument = slastDocument;
        this.includeResolver = includeResolver;
        this.defines = defines?.map((name) => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? ({ name }) : name);
    }
}


/***/ }),

/***/ "dnVx":
/*!*****************************************!*\
  !*** ./src/lib/fx/bytecode/Bytecode.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CBUFFER0_REGISTER": () => (/* binding */ CBUFFER0_REGISTER),
/* harmony export */   "CBUFFER_TOTAL": () => (/* binding */ CBUFFER_TOTAL),
/* harmony export */   "INPUT0_REGISTER": () => (/* binding */ INPUT0_REGISTER),
/* harmony export */   "INPUT_TOTAL": () => (/* binding */ INPUT_TOTAL),
/* harmony export */   "SRV0_REGISTER": () => (/* binding */ SRV0_REGISTER),
/* harmony export */   "SRV_TOTAL": () => (/* binding */ SRV_TOTAL),
/* harmony export */   "UAV0_REGISTER": () => (/* binding */ UAV0_REGISTER),
/* harmony export */   "UAV_TOTAL": () => (/* binding */ UAV_TOTAL),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "translateExpression": () => (/* binding */ translateExpression)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "sg/z");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "/9BJ");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./common */ "4eqb");
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Context */ "PMu9");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PromisedAddress */ "ZrbQ");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sizeof */ "p8vA");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Context__WEBPACK_IMPORTED_MODULE_11__]);
_Context__WEBPACK_IMPORTED_MODULE_11__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];















// [00 - 01) cbs
// [01 - 17) inputs
// [17 - 33) uavs
// [33 - 64) srvs
const CBUFFER0_REGISTER = 0;
const INPUT0_REGISTER = 1;
const UAV0_REGISTER = 17;
const SRV0_REGISTER = 33;
const SRV_TOTAL = 64 - SRV0_REGISTER;
const UAV_TOTAL = SRV0_REGISTER - UAV0_REGISTER;
const INPUT_TOTAL = UAV_TOTAL - INPUT0_REGISTER;
const CBUFFER_TOTAL = INPUT0_REGISTER - CBUFFER0_REGISTER;
const UNRESOLVED_JUMP_LOCATION = -1;
function writeString(u8data, offset, value) {
    u8data.set((0,_common__WEBPACK_IMPORTED_MODULE_10__.i32ToU8Array)(value.length), offset);
    offset += 4;
    u8data.set(value.split('').map(c => c.charCodeAt(0)), offset);
    offset += value.length;
    return offset;
}
function writeInt(u8data, offset, value) {
    u8data.set((0,_common__WEBPACK_IMPORTED_MODULE_10__.i32ToU8Array)(value), offset);
    offset += 4;
    return offset;
}
function writeTypeField(u8data, offset, field) {
    offset = writeInt(u8data, offset, field.padding);
    offset = writeInt(u8data, offset, field.size);
    offset = writeString(u8data, offset, field.semantic);
    offset = writeString(u8data, offset, field.name);
    offset = writeTypeLayout(u8data, offset, field.type);
    return offset;
}
function writeTypeLayout(u8data, offset, layout) {
    offset = writeInt(u8data, offset, layout.size);
    offset = writeInt(u8data, offset, layout.length);
    offset = writeString(u8data, offset, layout.name);
    offset = writeInt(u8data, offset, layout.fields.length);
    for (let field of layout.fields) {
        offset = writeTypeField(u8data, offset, field);
    }
    return offset;
}
function externsChunk(ctx) {
    const { externs } = ctx;
    const reflection = externs.dump();
    const sizeofTypeField = (field) => {
        return 0 +
            4 /* padding */ +
            4 /* size */ +
            4 /* semantic */ + field.semantic.length +
            4 /* name */ + field.name.length +
            sizeofTypeLayout(field.type);
    };
    const sizeofTypeLayout = (layout) => {
        return 0 +
            4 /* size */ +
            4 /* length */ +
            4 /* sizeof(name) */ + layout.name.length +
            4 /* fields.length */ + layout.fields.reduce((a, tl) => a + sizeofTypeField(tl), 0);
    };
    const byteLength = 4 /* reflection.length */ +
        reflection.reduce((s, { name, ret, params }) => s +
            4 /* id */ +
            4 /* sizeof(name) */ + name.length +
            sizeofTypeLayout(ret) +
            4 /* params.length */ + params.reduce((s, p) => s + sizeofTypeLayout(p), 0), 0);
    const size = (byteLength + 4) >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_Externs, size];
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    const u8data = new Uint8Array(data.buffer, 8 /* int header type + int size */);
    let written = writeInt(u8data, 0, reflection.length);
    for (let i = 0; i < reflection.length; ++i) {
        const { id, name, ret, params } = reflection[i];
        written = writeInt(u8data, written, id);
        written = writeString(u8data, written, name);
        written = writeTypeLayout(u8data, written, ret);
        written = writeInt(u8data, written, params.length);
        for (let p of params) {
            written = writeTypeLayout(u8data, written, p);
        }
    }
    return data.buffer;
}
// TODO: rewrite with cleaner code
function constLayoutChunk(ctx) {
    const { constants } = ctx;
    const reflection = constants.dump();
    const byteLength = 4 /* names.length */ +
        reflection.map(entry => entry.name.length +
            entry.type.length +
            entry.semantic.length +
            4 + /* sizeof(name.length) */
            4 + /* sizeof(type.length) */
            4 + /* sizeof(semantic.length) */
            4 + /* sizeof(addr) */
            4 + /* sizeof(size) */
            4 /* sizeof(type.length) */).reduce((prev, curr) => prev + curr, 0);
    const size = (byteLength + 4) >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_Layout, size];
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    const u8data = new Uint8Array(data.buffer, 8 /* int header type + int size */);
    let written = writeInt(u8data, 0, reflection.length);
    for (let i = 0; i < reflection.length; ++i) {
        const { name, offset, type, size, semantic } = reflection[i];
        written = writeString(u8data, written, name);
        written = writeString(u8data, written, type);
        written = writeString(u8data, written, semantic || '');
        written = writeInt(u8data, written, offset);
        written = writeInt(u8data, written, size);
    }
    // console.log('after write', u8data.length, 'bytes', written);
    return data.buffer;
}
function constChunk(ctx) {
    const { constants } = ctx;
    const mem = constants.data;
    const size = mem.byteLength >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_Constants, size];
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((size << 2) == mem.byteLength);
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    data.set(new Uint32Array(mem.byteArray.buffer, 0, mem.byteLength >> 2), chunkHeader.length);
    return data.buffer;
}
function codeChunk(ctx) {
    const { instructions } = ctx;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_Code, instructions.length];
    const data = new Uint32Array(chunkHeader.length + instructions.length);
    data.set(chunkHeader);
    data.set(instructions.data, chunkHeader.length);
    return data.buffer;
}
const CHUNK_EMPTY = (new Uint8Array(0)).buffer;
function shadersChunk(ctx) {
    const { pipeline } = ctx;
    const shaders = pipeline.dumpShaders();
    if (shaders.length === 0) {
        return CHUNK_EMPTY;
    }
    const byteLength = 4 /* shaders.length */ +
        shaders.map(({ shader: sh }) => sh.name.length +
            sh.ver.length +
            4 + /* sizeof(name.length) */
            4 + /* sizeof(ver.length) */
            4 + /* args.length */
            sh.args.map(arg => 4 + /* sizeof(arg.type) */
                arg.type.length +
                4 /* constant value (number or bool) */).reduce((prev, curr) => prev + curr, 0)).reduce((prev, curr) => prev + curr, 0);
    const size = (byteLength + 4) >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_Shaders, size];
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    const u8data = new Uint8Array(data.buffer, 8 /* int header type + int size */);
    let written = writeInt(u8data, 0, shaders.length);
    for (let i = 0; i < shaders.length; ++i) {
        const { name, ver, args } = shaders[i].shader;
        written = writeString(u8data, written, name);
        written = writeString(u8data, written, ver);
        written = writeInt(u8data, written, args.length);
        for (let j = 0; j < args.length; ++j) {
            written = writeString(u8data, written, args[j].type);
            switch (args[j].type) {
                case 'int':
                case 'uint':
                case 'bool':
                    written = writeInt(u8data, written, +args[j].value);
                    break;
                default:
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported constant type "${args[j].type}"`);
                    written = writeInt(u8data, written, 0);
            }
        }
    }
    return data.buffer;
}
// depth stencil state
function dssChunk(ctx) {
    const { pipeline } = ctx;
    const depthStencilStates = pipeline.dumpDepthStencilStates();
    if (depthStencilStates.length === 0) {
        return CHUNK_EMPTY;
    }
    const byteLength = 4 /* depthStencilStates.length */ +
        depthStencilStates.map(dss => 4 + // DepthEnable
            4 + // DepthWriteMask
            4 + // DepthFunc
            4 + // StencilEnable
            4 + // StencilReadMask
            4 + // StencilWriteMask
            4 * 4 + // BackFace
            4 * 4 // FrontFace
        ).reduce((prev, curr) => prev + curr, 0);
    const size = (byteLength + 4) >> 2;
    const chunkHeader = [_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EChunkType.k_DepthStencilStates, size];
    const data = new Uint32Array(chunkHeader.length + size);
    data.set(chunkHeader);
    const u8data = new Uint8Array(data.buffer, 8 /* int header type + int size */);
    let written = writeInt(u8data, 0, depthStencilStates.length);
    for (let i = 0; i < depthStencilStates.length; ++i) {
        const dss = depthStencilStates[i];
        written = writeInt(u8data, written, +dss.DepthEnable);
        written = writeInt(u8data, written, +dss.DepthWriteMask);
        written = writeInt(u8data, written, +dss.DepthFunc);
        written = writeInt(u8data, written, +dss.StencilEnable);
        written = writeInt(u8data, written, +dss.StencilReadMask);
        written = writeInt(u8data, written, +dss.StencilWriteMask);
        written = writeInt(u8data, written, +dss.FrontFace.StencilFailOp);
        written = writeInt(u8data, written, +dss.FrontFace.StencilDepthFailOp);
        written = writeInt(u8data, written, +dss.FrontFace.StencilPassOp);
        written = writeInt(u8data, written, +dss.FrontFace.StencilFunc);
        written = writeInt(u8data, written, +dss.BackFace.StencilFailOp);
        written = writeInt(u8data, written, +dss.BackFace.StencilDepthFailOp);
        written = writeInt(u8data, written, +dss.BackFace.StencilPassOp);
        written = writeInt(u8data, written, +dss.BackFace.StencilFunc);
    }
    return data.buffer;
}
function binary(ctx) {
    const chunks = [
        constLayoutChunk(ctx),
        constChunk(ctx),
        codeChunk(ctx),
        externsChunk(ctx),
        shadersChunk(ctx),
        dssChunk(ctx)
    ].map(ch => new Uint8Array(ch));
    const byteLength = chunks.map(x => x.byteLength).reduce((a, b) => a + b);
    let data = new Uint8Array(byteLength);
    let offset = 0;
    chunks.forEach(ch => {
        data.set(ch, offset);
        offset += ch.byteLength;
    });
    return data;
}
function translateProgram(ctx, fn) {
    const { constants, debug, alloca, push, pop, addr, imove, ref, icode, instructions } = ctx;
    // NOTE: it does nothing at the momemt :/
    debug.beginCompilationUnit('[todo]', fn.def.returnType);
    // simulate function call()
    const fdef = fn.def;
    let ret = alloca(fdef.returnType.size);
    push(fn, ret);
    // TODO: use the same code as FunctionCall;
    // loading of all non-inpt parameters to registers
    for (let i = 0; i < fdef.params.length; ++i) {
        const param = fdef.params[i];
        if (param.type.usages.includes('out') || param.type.usages.includes('inout')) {
            continue;
        }
        const inputIndex = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.variable.parameterIndex(param) + INPUT0_REGISTER;
        const size = param.type.size;
        const src = addr.loc({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input, inputIndex, addr: 0, size });
        const dest = alloca(size);
        imove(dest, src);
        debug.map(fdef); // FIXME: is it ok?
        ref(param, dest);
    }
    translateUnknown(ctx, fn);
    pop();
    // always push ret as last instruction
    const [op,] = instructions.back();
    if (op != _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Ret)
        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Ret);
    debug.endCompilationUnit();
    let code = binary(ctx); // TODO: stay only binary view
    let cdl = debug.dump(); // code debug layout;
    return {
        code,
        cdl // same as PDB
    };
}
function translateUnknown(ctx, instr) {
    const { pc, error, critical, constants, pipeline, externs, uavs, srvs, alloca, addr, debug, push, pop, open, close, deref, ref, icode, imove, iop4, iop3, iop2, iop1, iload, iconst_i32, iconst_f32, ret, depth, instructions } = ctx;
    // NOTE: pc - number of written instructions
    // NOTE: rc - number of occupied registers
    const isEntryPoint = () => depth() === 1;
    const intrinsics = {
        /**
         * Float based arithmetics
         * vector [op] vector | vector [op] scalar | scalar [op] vector
         */
        arithf(opName, dest, left, right) {
            const size = Math.max(left.size, right.size);
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
            // handle case: scalar * vector => scalar.xxxx * vector
            if (left.size != right.size) {
                if (left.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()) {
                    left = addr.override(left, Array(n).fill(0));
                }
                else if (right.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()) {
                    right = addr.override(right, Array(n).fill(0));
                }
                else {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'vectors with differen length cannot be multipled');
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            }
            const opFloatMap = {
                '+': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Add,
                '-': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Sub,
                '*': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Mul,
                '/': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Div,
                '%': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Mod
            };
            const op = opFloatMap[opName];
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(op)) {
                // todo: emit correct source location
                error(null, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedArithmeticExpr, { tooltip: `operation: ${opName}` });
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
            }
            iop3(op, dest, left, right);
            return dest;
        },
        // TODO: merhe with function above
        arithi(opName, dest, left, right) {
            const size = Math.max(left.size, right.size);
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
            // handle case: scalar * vector => scalar.xxxx * vector
            if (left.size !== right.size) {
                if (left.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()) {
                    left = addr.override(left, Array(n).fill(0));
                }
                else if (right.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()) {
                    right = addr.override(right, Array(n).fill(0));
                }
                else {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'vectors with differen length cannot be multipled');
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            }
            const opIntMap = {
                '+': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Add,
                '-': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Sub,
                '*': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Mul,
                '/': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Div,
                '%': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Mod
            };
            const op = opIntMap[opName];
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(op)) {
                // todo: emit correct source location
                error(null, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedArithmeticExpr, { tooltip: `operation ${opName}` });
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
            }
            iop3(op, dest, left, right);
            return dest;
        },
        mulf: (dest, left, right) => intrinsics.arithf('*', dest, left, right),
        divf: (dest, left, right) => intrinsics.arithf('/', dest, left, right),
        addf: (dest, left, right) => intrinsics.arithf('+', dest, left, right),
        subf: (dest, left, right) => intrinsics.arithf('-', dest, left, right),
        modf: (dest, left, right) => intrinsics.arithf('%', dest, left, right),
        muli: (dest, left, right) => intrinsics.arithi('*', dest, left, right),
        divi: (dest, left, right) => intrinsics.arithi('/', dest, left, right),
        addi: (dest, left, right) => intrinsics.arithi('+', dest, left, right),
        subi: (dest, left, right) => intrinsics.arithi('-', dest, left, right),
        modi: (dest, left, right) => intrinsics.arithi('%', dest, left, right),
        dotf(dest, left, right) {
            let temp = alloca(Math.max(left.size, right.size));
            let mlr = intrinsics.mulf(temp, left, right);
            let n = mlr.size / _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
            // copy first element of 'mlr' to dest
            imove(dest, addr.shrink(mlr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()));
            for (let i = 1; i < n; ++i) {
                let padding = i * _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
                let size = _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
                intrinsics.addf(dest, dest, addr.sub(mlr, padding, size));
            }
            return dest;
        },
        distancef(dest, left, right) {
            let temp = alloca(left.size);
            intrinsics.subf(temp, left, right);
            intrinsics.lengthf(dest, temp);
            return dest;
        },
        /** dest = a + b * c */
        madi(dest, a, b, c) {
            iop4(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Mad, dest, a, b, c);
            return dest;
        },
        noti(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Not, dest, src);
            return dest;
        },
        mini(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Min, dest, left, right);
            return dest;
        },
        maxi(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Max, dest, left, right);
            return dest;
        },
        fracf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Frac, dest, src);
            return dest;
        },
        floorf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Floor, dest, src);
            return dest;
        },
        ceilf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Ceil, dest, src);
            return dest;
        },
        sinf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Sin, dest, src);
            return dest;
        },
        cosf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Cos, dest, src);
            return dest;
        },
        absf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Abs, dest, src);
            return dest;
        },
        sqrtf(dest, src) {
            iop2(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Sqrt, dest, src);
            return dest;
        },
        powf(dest, x, y) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Pow, dest, x, y);
            return dest;
        },
        minf(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Min, dest, left, right);
            return dest;
        },
        // a = max(b, c);
        maxf(dest, left, right) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Max, dest, left, right);
            return dest;
        },
        // ret step(y, x)
        // (x >= y) ? 1 : 0
        stepf(dest, y, x) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32GreaterThanEqual, dest, x, y);
            return dest;
        },
        clampf(dest, x, min, max) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Max, dest, x, min);
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Min, dest, dest, max);
            return dest;
        },
        saturatef(dest, x) {
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Max, dest, x, iconst_f32(0.0));
            iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32Min, dest, dest, iconst_f32(1.0));
            return dest;
        },
        lengthf(dest, src) {
            intrinsics.dotf(dest, src, src);
            intrinsics.sqrtf(dest, dest);
            return dest;
        },
        normalizef(dest, src) {
            const len = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32());
            intrinsics.lengthf(len, src);
            intrinsics.divf(dest, src, len);
            return dest;
        },
        lerpf(dest, from, to, k) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(from.size === to.size);
            const size = from.size;
            const n = size / _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
            const swizzle = Array(n).fill(0);
            let one = iconst_f32(1.0);
            // todo: fix bu with vectored koef.
            let kInv;
            if (k.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32()) {
                kInv = intrinsics.subf(one, one, k);
            }
            else {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(k.size === from.size);
                one = addr.override(one, swizzle);
                kInv = intrinsics.subf(alloca(dest.size), one, k);
            }
            let temp = alloca(size);
            intrinsics.mulf(temp, to, k);
            intrinsics.mulf(dest, from, kInv);
            intrinsics.addf(dest, dest, temp);
            return dest;
        },
        // hlsl supports float3 x float3 only
        cross(dest, left, right) {
            // .x = (m.y * n.z - m.z * n.y)
            // .y = (m.z * n.x - m.x * n.z)
            // .z = (m.x * n.y - m.y * n.x)
            let f32 = _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32();
            let t1 = alloca(f32);
            let t2 = alloca(f32);
            let temp = alloca(f32 * 3);
            let mx = addr.sub(left, 0 * f32, f32);
            let my = addr.sub(left, 1 * f32, f32);
            let mz = addr.sub(left, 2 * f32, f32);
            let nx = addr.sub(right, 0 * f32, f32);
            let ny = addr.sub(right, 1 * f32, f32);
            let nz = addr.sub(right, 2 * f32, f32);
            let tx = addr.sub(temp, 0 * f32, f32);
            let ty = addr.sub(temp, 1 * f32, f32);
            let tz = addr.sub(temp, 2 * f32, f32);
            intrinsics.mulf(t1, my, nz);
            intrinsics.mulf(t2, mz, ny);
            intrinsics.subf(tx, t1, t2); // .x
            intrinsics.mulf(t1, mz, nx);
            intrinsics.mulf(t2, mx, nz);
            intrinsics.subf(ty, t1, t2); // .y
            intrinsics.mulf(t1, mx, ny);
            intrinsics.mulf(t2, my, nx);
            intrinsics.subf(tz, t1, t2); // .z
            imove(dest, temp);
            return dest;
        }
    };
    // handle global variables like: const float VALUE = 10;
    // as hidden uniform constants
    function canBePlacedInUniforms(decl) {
        // Suitable:
        //  uniform float4x4 viewMatrix;
        //  float4 color = float4(1, 1, 1, 1);
        //  const float scale = 1;
        // Not suitable:
        //  const float;            // <= not uniform and doesn't have proper default value
        //  RTTexture2D dynamicTex; // <= uav
        //  Texture2D albedo;
        const isUniform = decl.type.isUniform();
        const isCbufferField = (decl.usageFlags & _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_2__.EVariableUsageFlags.k_Cbuffer) != 0;
        const isConstant = decl.initExpr && decl.initExpr.isConst();
        const isPipelineState = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isPipelineState(decl.type);
        return decl.isGlobal() && (isUniform || isCbufferField || isConstant) && !isPipelineState;
    }
    function resolveAddressType(decl) {
        if (decl.isParameter()) {
            if (decl.type.usages.includes('out') || decl.type.usages.includes('inout')) {
                // entry point function can refer to input memory, for ex. vertex shader
                return isEntryPoint() ? _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input : _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers;
            }
        }
        if (decl.isGlobal()) {
            // uniforms are placed in input 0/CBV0
            if (canBePlacedInUniforms(decl)) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input;
            }
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUAV(decl.type)) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input;
            }
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBuffer(decl.type)) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input;
            }
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isTexture(decl.type)) {
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input;
            }
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isPipelineState(decl.type)) {
                // all states are presented as integers
                return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_PipelineStates;
            }
            critical(decl.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_AddressCannotBeResolved, {
                tooltip: `could not resolve address type for '${decl.toCode()}'`
            });
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(decl.isLocal());
        return _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers;
    }
    const POSTFIX_COMPONENT_MAP = {
        'r': 0, 'x': 0, 's': 0,
        'g': 1, 'y': 1, 't': 1,
        'b': 2, 'z': 2, 'p': 2,
        'a': 3, 'w': 3, 'q': 3
    };
    const checkPostfixNameForSwizzling = (postfixName) => postfixName
        .split('')
        .map(c => POSTFIX_COMPONENT_MAP[c])
        .map(i => i >= 0 && i < 4)
        .reduce((accum, val) => accum && val);
    // xxwy => [0, 0, 3, 1]
    const swizzlePatternFromName = (postfixName) => postfixName.split('').map(c => POSTFIX_COMPONENT_MAP[c]);
    // const swizzlePatternFromPadding = (padding: number, size: number) => {
    //     assert(padding % sizeof.i32() === 0);
    //     assert(size % sizeof.i32() === 0);
    //     return [...Array(size / sizeof.i32()).keys()].map(i => i + padding / sizeof.i32());
    // };
    function preloadArguments(call, forceLoad) {
        const fdecl = call.decl;
        const fdef = fdecl.def;
        const args = [];
        for (let i = 0; i < fdef.params.length; ++i) {
            const arg = call.args[i];
            let argAddr = raddr(arg);
            if (argAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers && forceLoad) {
                argAddr = iload(argAddr);
            }
            args.push(argAddr);
        }
        return args;
    }
    function iextern(call) {
        const fdecl = call.decl;
        const fdef = fdecl.def;
        // const retType = fdef.returnType;
        // todo: do not preload all the arguemnts?
        // const args = preloadArguments(call, true);
        const dataSize = fdef.returnType.size + fdef.params.reduce((partialSum, param) => partialSum + param.type.size, 0);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dataSize >= 0 && dataSize <= 256);
        // calling convention layout
        // dest | is needed
        // arguments | if needed
        const ccLayout = alloca(dataSize);
        let ccParamAddr = addr.sub(ccLayout, fdef.returnType.size);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(fdef.params.length == call.args.length);
        for (let i = 0; i < fdef.params.length; ++i) {
            const arg = call.args[i];
            const param = fdef.params[i];
            const type = param.type;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(arg.type.size === param.type.size);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((arg.type.size % 4) == 0);
            const argAddr = raddr(arg);
            imove(addr.sub(ccParamAddr, 0, type.size), argAddr);
            if (i !== fdef.params.length - 1) // if to avoid zero sized address scalculation
                ccParamAddr = addr.sub(ccParamAddr, type.size);
        }
        const iExtern = externs.add(fdef);
        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32ExternCall, iExtern, ccLayout);
        return addr.sub(ccLayout, 0, fdef.returnType.size);
    }
    function iintrinsic(call) {
        const fdecl = call.decl;
        const fdef = fdecl.def;
        const retType = fdef.returnType;
        const dest = alloca(retType.size);
        let forceLoadArgumentsToRegisters;
        switch (fdecl.name) {
            case 'InterlockedAdd':
                // expected InterlockedAdd(UAV pointer [uint/int], any [uint/int], any [uint/int])
                forceLoadArgumentsToRegisters = false;
                break;
            default:
                forceLoadArgumentsToRegisters = true;
        }
        const args = preloadArguments(call, forceLoadArgumentsToRegisters);
        switch (fdecl.name) {
            case 'asuint':
            case 'asfloat':
            case 'asint':
                // NOTE: nothing todo
                return args[0];
            case 'mul':
                return intrinsics.mulf(dest, args[0], args[1]);
            case 'dot':
                return intrinsics.dotf(dest, args[0], args[1]);
            case 'frac':
                return intrinsics.fracf(dest, args[0]);
            case 'sin':
                return intrinsics.sinf(dest, args[0]);
            case 'cos':
                return intrinsics.cosf(dest, args[0]);
            case 'abs':
                return intrinsics.absf(dest, args[0]);
            case 'sqrt':
                return intrinsics.sqrtf(dest, args[0]);
            case 'pow':
                return intrinsics.powf(dest, args[0], args[1]);
            case 'normalize':
                return intrinsics.normalizef(dest, args[0]);
            case 'length':
                return intrinsics.lengthf(dest, args[0]);
            case 'floor':
                return intrinsics.floorf(dest, args[0]);
            case 'ceil':
                return intrinsics.ceilf(dest, args[0]);
            case 'distance':
                return intrinsics.distancef(dest, args[0], args[1]);
            case 'min':
                // TODO: separate INT/FLOAT intrisics
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type)) {
                    return intrinsics.minf(dest, args[0], args[1]);
                }
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(fdef.params[0].type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUintBasedType(fdef.params[1].type));
                // handle INT/UINT params as int intrinsic
                return intrinsics.mini(dest, args[0], args[1]);
            case 'max':
                // TODO: separate INT/FLOAT intrisics
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type)) {
                    return intrinsics.maxf(dest, args[0], args[1]);
                }
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(fdef.params[0].type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUintBasedType(fdef.params[0].type));
                // handle INT/UINT params as int intrinsic
                return intrinsics.maxi(dest, args[0], args[1]);
            case 'step':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type));
                return intrinsics.stepf(dest, args[0], args[1]);
            case 'clamp':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type));
                return intrinsics.clampf(dest, args[0], args[1], args[2]);
            case 'saturate':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type));
                return intrinsics.saturatef(dest, args[0]);
            case 'lerp':
                return intrinsics.lerpf(dest, args[0], args[1], args[2]);
            case 'cross':
                return intrinsics.cross(dest, args[0], args[1]);
            case 'mod':
                // TODO: separate INT/FLOAT intrisics
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(fdef.params[0].type)) {
                    return intrinsics.modf(dest, args[0], args[1]);
                }
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(fdef.params[0].type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUintBasedType(fdef.params[0].type));
                // handle INT/UINT params as int intrinsic
                return intrinsics.modi(dest, args[0], args[1]);
            case 'InterlockedAdd':
                {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(fdef.params.length === 3);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args[0].type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_PointerInput, 'destination must be UAV address');
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args[0].size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32(), 'only int/uint values are supported');
                    if (args[1].type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        args[1] = iload(args[1]);
                    }
                    let originalAddr = args[2];
                    if (args[2].type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        originalAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    }
                    imove(originalAddr, args[0]);
                    const changedAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32()), originalAddr, args[1]);
                    imove(args[0], changedAddr);
                    if (args[2] !== originalAddr) {
                        imove(args[2], originalAddr);
                    }
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            //
            // UAVs
            //
            /** @returns: The post-decremented counter value. */
            case 'DecrementCounter':
                {
                    const uav = call.callee;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    const valueAddr = iload(uavCounterAddr);
                    const nextValueAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32()), valueAddr, iconst_i32(-1));
                    imove(uavCounterAddr, nextValueAddr);
                    return nextValueAddr;
                }
            /** @returns: The pre-incremented counter value. */
            case 'IncrementCounter':
                {
                    const uav = call.callee;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    const valueAddr = iload(uavCounterAddr);
                    const nextValueAddr = intrinsics.addi(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32()), valueAddr, iconst_i32(+1));
                    imove(uavCounterAddr, nextValueAddr);
                    return valueAddr;
                }
            case 'Append':
                {
                    const { callee: uav, args } = call;
                    const uavAddr = raddr(uav);
                    const uavCounterAddr = addr.shrink(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length === 1);
                    const srcAddr = raddr(args[0]);
                    const valueAddr = iload(uavCounterAddr);
                    const arrayElementSize = args[0].type.size;
                    const uavDataAddr = addr.sub(uavAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    const elementPointer = addr.subPointer(uavDataAddr, valueAddr, arrayElementSize);
                    imove(elementPointer, srcAddr);
                    // TODO: replace with intrinsics.inc();
                    intrinsics.addi(valueAddr, valueAddr, iconst_i32(1));
                    imove(uavCounterAddr, valueAddr);
                    return elementPointer;
                }
            //
            // Textures
            //
            case 'GetDimensions':
                {
                    const { callee: tex } = call;
                    const texAddr = raddr(tex);
                    // GetDimensions(w, h) only supported
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(tex.type.name.includes('Texture2D'));
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length === 3);
                    const w = addr.sub(texAddr, 0, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    const h = addr.sub(texAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32(), _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                    // NOTE: always returns size of zero mip (!)
                    // const mip = args[0];
                    const wout = args[1];
                    const hout = args[2];
                    imove(wout, w);
                    imove(hout, h);
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            case 'Load':
                {
                    const { callee } = call;
                    const tex = raddr(callee);
                    // Load(int3) only supported
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(callee.type.name.includes('Texture2D'));
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length === 1);
                    let uvs = args[0];
                    if (uvs.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        uvs = iload(uvs);
                    }
                    //const u = addr.sub(uvs, 0, sizeof.i32());
                    // descriptor size if 64 bytes
                    // width  | 4 byte
                    // height | 4 byte
                    // format | 4 byte
                    // unused | 52 bytes
                    //const v = addr.sub(uvs, sizeof.i32(), sizeof.i32());
                    //const w = addr.sub(tex, 0, sizeof.i32());
                    // const h = addr.sub(texAddr, sizeof.i32(), sizeof.i32());
                    // const valueAddr = alloca(sizeof.i32());
                    // intrinsics.madi(valueAddr, u, w, v);
                    // const texelSize = callee.type.arrayElementType.size;
                    const dest = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32() * 4);
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32TextureLoad, dest, tex.inputIndex, uvs);
                    // const elementPointer = addr.subPointer(dest, valueAddr, texelSize);
                    // return elementPointer;
                    return dest;
                }
        }
        error(call.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedIntrinsic, { name: call.decl.name });
        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
    }
    /** resolve address => returns address of temprary result of expression */
    function raddr(expr) {
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_InitExpr:
                {
                    const init = expr;
                    if (init.isArray()) {
                        // todo: add support
                        error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedExprType, { tooltip: 'arrays are not yet supported' });
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                    }
                    let arg = init.args[0];
                    return raddr(arg);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_BoolExpr:
                {
                    const i32 = expr.value ? 1 : 0;
                    return iconst_i32(i32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_IntExpr:
                {
                    const i32 = expr.value;
                    return iconst_i32(i32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_FloatExpr:
                {
                    const f32 = expr.value;
                    return iconst_f32(f32);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_StringExpr:
                {
                    // remove quotes
                    const cstr = expr.value?.slice(1, -1);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(cstr.length > 0);
                    // input0, size = 4/* cstr.length */ + sizeof(cstr)
                    const constAddr = constants.derefCString(cstr);
                    return iconst_i32(constAddr.addr); // write to register addr of string in constant buffer 0. 
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_NullExpr:
                {
                    // it's assumed that all the types which can be converted 
                    // to NULL are pointers, so we can replace its address with 4 bytes
                    // value.
                    return iconst_i32(0);
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_IdExpr:
                {
                    let id = expr;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(id.decl === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.unwind(id));
                    const size = id.decl.type.size;
                    const decl = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.unwind(id);
                    const addrType = resolveAddressType(decl);
                    switch (addrType) {
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers:
                            {
                                return deref(id.decl);
                            }
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Input:
                            {
                                // CBUFFER0_REGISTER input is always being used for hidden constant buffer (uniform constants)
                                if (canBePlacedInUniforms(decl)) {
                                    return constants.deref(decl);
                                }
                                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUAV(decl.type)) {
                                    return uavs.deref(decl);
                                }
                                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBuffer(decl.type)) {
                                    return srvs.deref(decl);
                                }
                                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isTexture(decl.type)) {
                                    return srvs.deref(decl);
                                }
                                // implies that each parameter is loaded from its stream, so 
                                // the offset is always zero. 
                                // Otherwise use 'variable.getParameterOffset(decl);'
                                // in order to determ correct offset between parameters
                                const offset = 0;
                                const src = offset;
                                const inputIndex = _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.variable.parameterIndex(decl) + INPUT0_REGISTER;
                                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.variable.parameterIndex(decl) < INPUT_TOTAL);
                                return addr.loc({ inputIndex, addr: src, size, type: addrType });
                            }
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_PipelineStates:
                            {
                                // Resolve as registers (!)
                                // deref:
                                //  DepthStencilState
                                //  RasterizerState
                                //  BlendState
                                const id = pipeline.deref(decl);
                                return iconst_i32(id);
                            }
                    }
                    critical(id.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedAddressType, { tooltip: `type: ${addrType}` });
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ComplexExpr:
                return raddr(expr.expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ArithmeticExpr:
                {
                    const arithExpr = expr;
                    const dest = alloca(arithExpr.type.size);
                    const opName = arithExpr.operator;
                    const left = arithExpr.left;
                    const right = arithExpr.right;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isScalarType(left.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isVectorType(left.type));
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isScalarType(right.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isVectorType(right.type));
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(left.type)) {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(right.type));
                        intrinsics.arithf(opName, dest, leftAddr, rightAddr);
                    }
                    else if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(left.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUintBasedType(left.type)) {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(right.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUintBasedType(right.type));
                        intrinsics.arithi(opName, dest, leftAddr, rightAddr);
                    }
                    else {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                    }
                    debug.map(arithExpr);
                    return dest;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_AssignmentExpr:
                {
                    const assigment = expr;
                    const size = assigment.type.size;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(size % _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32() === 0);
                    // left address can be both from the registers and in the external memory
                    const leftAddr = raddr(assigment.left);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(assigment.right), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes[assigment.right.instructionType]);
                    // right address always from the registers
                    let rightAddr = raddr(assigment.right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(assigment.right);
                    }
                    const floatBased = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(expr.type);
                    switch (assigment.operator) {
                        case '=':
                            imove(leftAddr, rightAddr);
                            break;
                        case '+=':
                            floatBased
                                ? intrinsics.addf(leftAddr, leftAddr, rightAddr)
                                : intrinsics.addi(leftAddr, leftAddr, rightAddr);
                            break;
                        case '-=':
                            floatBased
                                ? intrinsics.subf(leftAddr, leftAddr, rightAddr)
                                : intrinsics.subi(leftAddr, leftAddr, rightAddr);
                            break;
                        case '*=':
                            floatBased
                                ? intrinsics.mulf(leftAddr, leftAddr, rightAddr)
                                : intrinsics.muli(leftAddr, leftAddr, rightAddr);
                            break;
                        case '/=':
                            floatBased
                                ? intrinsics.divf(leftAddr, leftAddr, rightAddr)
                                : intrinsics.divi(leftAddr, leftAddr, rightAddr);
                            break;
                        default:
                            error(null, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedAssigmentOperator, { tooltip: `operator: ${assigment.operator}` });
                    }
                    debug.map(assigment);
                    // breakpoint right after assingment
                    debug.ns();
                    return leftAddr;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_PostfixArithmeticExpr:
                {
                    const postfix = expr;
                    const operand = postfix.expr;
                    const op = postfix.operator;
                    const size = postfix.type.size;
                    let src = raddr(operand);
                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        src = iload(src);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(operand.type)) {
                        switch (op) {
                            case '++':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithi('+', src, src, iconst_i32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithi('-', src, src, iconst_i32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    else {
                        switch (op) {
                            case '++':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithf('+', src, src, iconst_f32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = imove(alloca(size), src);
                                    intrinsics.arithf('-', src, src, iconst_f32(1));
                                    debug.map(postfix);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    error(postfix.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedUnaryExpression, {
                        tooltip: `unsupported type of unary expression found: '${op}'(${postfix.toCode()})`
                    });
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_UnaryExpr:
                {
                    const unary = expr;
                    const operand = unary.expr;
                    const op = unary.operator;
                    const size = unary.type.size;
                    let src = raddr(operand);
                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        src = iload(src);
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBoolBasedType(operand.type)) {
                        if (op === '!') {
                            const dest = intrinsics.noti(alloca(size), src);
                            debug.map(unary);
                            return dest;
                        }
                    }
                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isIntBasedType(operand.type)) {
                        switch (op) {
                            case '-':
                                {
                                    const dest = intrinsics.arithi('*', alloca(size), src, iconst_i32(-1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '+':
                                // nothing todo
                                return src;
                            case '++':
                                {
                                    const dest = intrinsics.arithi('+', src, src, iconst_i32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = intrinsics.arithi('-', src, src, iconst_i32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    else {
                        switch (op) {
                            case '-':
                                {
                                    const dest = intrinsics.arithf('*', alloca(size), src, iconst_f32(-1.0));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '++':
                                {
                                    const dest = intrinsics.arithf('+', src, src, iconst_f32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            case '--':
                                {
                                    const dest = intrinsics.arithf('-', src, src, iconst_f32(1));
                                    debug.map(unary);
                                    return dest;
                                }
                            // fall to unsupported warning
                        }
                    }
                    error(unary.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedUnaryExpression, {
                        tooltip: `unsupported type of unary expression found: '${op}'(${unary.toCode()})`
                    });
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_LogicalExpr:
                {
                    const logicExpr = expr;
                    const opMap = {
                        '||': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32LogicalOr,
                        '&&': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32LogicalAnd
                    };
                    let op = opMap[logicExpr.operator];
                    ;
                    const { left, right } = logicExpr;
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    const size = logicExpr.type.size;
                    const dest = alloca(size);
                    iop3(op, dest, leftAddr, rightAddr);
                    debug.map(logicExpr);
                    return addr.loc({ addr: dest, size });
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_RelationalExpr:
                {
                    const relExpr = expr;
                    const opUintMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_U32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_U32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32NotEqual // << compare with I32 operator
                    };
                    const opIntMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32NotEqual // ne
                    };
                    const opFloatMap = {
                        '<': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32LessThan,
                        '>=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32GreaterThanEqual,
                        '==': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32Equal,
                        '!=': _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32NotEqual // << compare with I32 operator
                    };
                    let op;
                    let { left, right } = relExpr;
                    let operator = relExpr.operator;
                    // (left > right) => (right < left)
                    if (operator === '>') {
                        operator = '<';
                        [right, left] = [left, right];
                    }
                    // (left <= right) => (right >= left)
                    if (operator === '<=') {
                        operator = '>=';
                        [right, left] = [left, right];
                    }
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT)) {
                        op = opIntMap[operator];
                        // print warning if right type is UINT;
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT) && !_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT)) {
                            error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT)) {
                        op = opUintMap[operator];
                        // print warning if right type is INT;
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT) && !_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT)) {
                            error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT)) {
                        op = opFloatMap[operator];
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT)) {
                            error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_BOOL)) {
                        op = opIntMap[operator];
                        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(right.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_BOOL)) {
                            error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedRelationalExpr, {});
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    if (!op) {
                        error(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupportedRelationalExpr, {});
                        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                    }
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    const size = relExpr.type.size;
                    const dest = alloca(size);
                    iop3(op, dest, leftAddr, rightAddr);
                    debug.map(relExpr);
                    return addr.loc({ addr: dest, size });
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_CastExpr:
                {
                    const castExpr = expr;
                    if (castExpr.isUseless()) {
                        console.warn(`Useless cast found: ${castExpr.toCode()}`);
                        return raddr(castExpr.expr);
                    }
                    const srcType = castExpr.expr.type;
                    const dstType = castExpr.type;
                    let op;
                    // TODO: add support for vectors
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_BOOL)) {
                        const size = castExpr.type.size;
                        const dest = alloca(size);
                        let exprAddr = raddr(castExpr.expr);
                        if (exprAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                            exprAddr = iload(exprAddr);
                        }
                        iop3(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32NotEqual, dest, exprAddr, iconst_i32(0));
                        debug.map(castExpr);
                        return addr.loc({ addr: dest, size });
                    }
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(srcType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT)) {
                        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT)) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32ToI32;
                        }
                        else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT)) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32ToU32;
                        }
                        else {
                            error(castExpr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(srcType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT)) {
                        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT)) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32ToF32;
                        }
                        else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT)) {
                            // useless conversion
                            return raddr(castExpr.expr);
                        }
                        else {
                            error(castExpr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(srcType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT)) {
                        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT)) {
                            op = _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_U32ToF32;
                        }
                        else if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(dstType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT)) {
                            // useless conversion
                            return raddr(castExpr.expr);
                        }
                        else {
                            error(castExpr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_UnsupoortedTypeConversion, { info: castExpr.toCode() });
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                        }
                    }
                    const size = castExpr.type.size;
                    const dest = alloca(size);
                    let exprAddr = raddr(castExpr.expr);
                    if (exprAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        exprAddr = iload(exprAddr);
                    }
                    iop2(op, dest, exprAddr);
                    debug.map(castExpr);
                    return addr.loc({ addr: dest, size });
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_PostfixIndexExpr:
                {
                    const postfixIndex = expr;
                    // element[index]
                    const { element, index } = postfixIndex;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(index.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_INT) || _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(index.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_UINT));
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(element.type.arrayElementType));
                    if ( /*index.isConstExpr()*/false) {}
                    else {
                        let elementAddr = raddr(element);
                        // NOTE: element can be not loaded yet
                        //       we don't want to load all the array (all 'element' object)
                        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isUAV(element.type)) {
                            // some UAVs can have hidden counter at the beginning of the data
                            // in such cases we need to step forward before fetching the data
                            elementAddr = addr.sub(elementAddr, _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32());
                        }
                        // sizeof(element[i])
                        let arrayElementSize = element.type.arrayElementType.size;
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(arrayElementSize % _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32() === 0, `all sizes must be multiple of ${_sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32()}`);
                        // index => index of element in the array (element)
                        let indexAddr = raddr(index);
                        // NOTE: index can be unresolved yet
                        const dest = addr.subPointer(elementAddr, indexAddr, arrayElementSize);
                        debug.map(postfixIndex);
                        return dest;
                    }
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID; // << FIXME
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_PostfixPointExpr:
                {
                    const point = expr;
                    const { element, postfix } = point;
                    const elementAddr = raddr(element);
                    let { size, padding } = postfix.type;
                    let swizzle = null;
                    // Does expression have dynamic indexing?
                    // TODO: rename isConstExpr() method to something more suitable
                    if (point.isConstExpr()) {
                        // handle such types like float2, float3, int2, int3 etc.
                        // all system types except matrix and samplers support swizzling
                        const isSwizzlingSupported = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isVectorType(element.type) ||
                            _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isScalarType(element.type);
                        if (isSwizzlingSupported) {
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(checkPostfixNameForSwizzling(postfix.name));
                            swizzle = swizzlePatternFromName(postfix.name);
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(padding === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_PADDING, 'padding of swizzled components must be undefined');
                            // If loading not allowed then we are inside the recursive call to calculate the final address
                            // so in this case we just have to return address with padding added to it.
                            return addr.override(elementAddr, swizzle);
                        }
                        else {
                            return addr.sub(elementAddr, padding, size);
                        }
                    }
                    critical(expr.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_NotImplemented, {});
                    // todo: add support for move_reg_ptr, move_ptr_ptr, move_ptr_reg
                    return elementAddr;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_FunctionCallExpr:
                {
                    const call = expr;
                    const fdecl = call.decl;
                    const fdef = fdecl.def;
                    const retType = fdef.returnType;
                    // todo: use more precise check
                    // note: system functions also can present externs, for ex: SetVertexShader()
                    if (fdecl.attrs.find(({ name }) => name === 'extern')) {
                        debug.ns();
                        const dest = iextern(call);
                        debug.map(call);
                        return dest;
                    }
                    if (fdecl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_SystemFunctionDecl) {
                        // breakpoint before intrinsic call
                        // TODO: is it's breakpoint really usefull?
                        debug.ns();
                        const dest = iintrinsic(call);
                        debug.map(call);
                        return dest;
                    }
                    const ret = alloca(retType.size);
                    const params = fdef.params;
                    const args = params
                        .map((param, i) => i < call.args.length ? call.args[i] : param.initExpr);
                    const paramSources = args
                        .map(arg => raddr(arg))
                        .map(arg => arg.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers ? arg : iload(arg));
                    push(fdecl, ret);
                    for (let i = 0; i < fdef.params.length; ++i) {
                        const src = paramSources[i];
                        // by default all parameters are interpreted as 'in'
                        if (params[i].type.usages.includes('out') || params[i].type.usages.includes('inout')) {
                            ref(params[i], src);
                        }
                        else {
                            // todo: handle expressions like "float4 v = 5.0;"
                            const size = params[i].type.size;
                            const dest = alloca(size);
                            imove(dest, src);
                            debug.map(args[i]);
                            ref(params[i], dest);
                        }
                    }
                    translateUnknown(ctx, fdecl);
                    pop();
                    return ret;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ConditionalExpr:
                {
                    const { condition, left, right } = expr;
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, right.type));
                    let size = left.type.size;
                    let dest = alloca(size);
                    let condAddr = raddr(condition);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(condAddr.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].bool());
                    if (condAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        condAddr = iload(condAddr);
                        debug.map(condition);
                    }
                    iop1(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_JumpIf, condAddr);
                    let unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);
                    let leftAddr = raddr(left);
                    if (leftAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        leftAddr = iload(leftAddr);
                        debug.map(left);
                    }
                    imove(dest, leftAddr);
                    debug.map(left);
                    // jump co contrary or out of if
                    let jumpTo = pc() + 1;
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, [jumpTo]);
                    unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);
                    let rightAddr = raddr(right);
                    if (rightAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        rightAddr = iload(rightAddr);
                        debug.map(right);
                    }
                    imove(dest, rightAddr);
                    debug.map(right);
                    // jump to skip contrary
                    jumpTo = pc();
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, [jumpTo]);
                    return addr.loc({ addr: dest, size });
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ConstructorCallExpr:
                {
                    const ctorCall = expr;
                    // todo: add correct constructor call support for builtin type at the level of analyzer
                    const type = ctorCall.type;
                    const args = ctorCall.args;
                    const size = type.size;
                    const dest = alloca(size);
                    switch (type.name) {
                        case 'float':
                        case 'float1':
                        case 'float2':
                        case 'float3':
                        case 'float4':
                        case 'int':
                        case 'int1':
                        case 'int2':
                        case 'int3':
                        case 'int4':
                        case 'uint':
                        case 'uint1':
                        case 'uint2':
                        case 'uint3':
                        case 'uint4':
                        case 'bool':
                        case 'bool2':
                        case 'bool3':
                        case 'bool4':
                            switch (args.length) {
                                case 1:
                                    // TODO: convert float to int if necessary
                                    // handling for the case single same type argument and multiple floats
                                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(args[0]), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes[args[0].instructionType]);
                                    let src = raddr(args[0]);
                                    if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                                        src = iload(src);
                                        debug.map(args[0]);
                                    }
                                    // convert arguments from float to int and back
                                    if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(args[0].type) !== _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(type)) {
                                        const op = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(type) ? _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32ToF32 : _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32ToI32;
                                        // expected:
                                        //  float4(10), float3(10u), float3(true);
                                        //  float2(int2(10, 10)) etc.
                                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args[0].type.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32() || args[0].type.size === expr.type.size);
                                        // don't change initial location?
                                        let temp = alloca(src.size);
                                        iop2(op, temp, src);
                                        src = temp;
                                    }
                                    const elementSize = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(type) ? _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].f32() : _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32();
                                    // FIXME: use 'length' property
                                    let length = type.size / elementSize;
                                    let swizzle = null;
                                    if (src.size === elementSize) {
                                        swizzle = [...Array(length).fill(0)];
                                        src = addr.override(src, swizzle);
                                    }
                                    else {
                                        swizzle = [...Array(length).keys()];
                                        src = addr.override(src, swizzle);
                                    }
                                    imove(dest, src);
                                    debug.map(ctorCall);
                                    break;
                                default:
                                    let padding = 0;
                                    for (let i = 0; i < args.length; ++i) {
                                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(args[i]), _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes[args[i].instructionType]);
                                        let src = raddr(args[i]);
                                        if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                                            src = iload(src);
                                            debug.map(args[i]);
                                        }
                                        // convert arguments from float to int and back
                                        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(args[i].type) !== _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(type)) {
                                            const op = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isFloatBasedType(type) ? _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_I32ToF32 : _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_F32ToI32;
                                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args[i].type.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].i32()); // <= expected float4(10) or float3(10u) or float3(true);
                                            // don't change initial location?
                                            let temp = alloca(src.size);
                                            iop2(op, temp, src);
                                            src = temp;
                                        }
                                        imove(addr.sub(dest, padding, src.size), src);
                                        padding += args[i].type.size;
                                    }
                                    debug.map(ctorCall);
                                    break;
                            }
                            return addr.loc({ addr: dest, size });
                        default:
                    }
                    console.warn(`Unknown constructor found: ${ctorCall.toCode()}`);
                    return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
                }
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_CompileShader11Expr:
                {
                    // see builtin.ts for details, all the types of shaders: 
                    // VertexShader, PixelShader etc. are presented as integers. 
                    const sh11 = expr;
                    const id = pipeline.derefShader11(sh11);
                    return iconst_i32(id);
                }
                break;
            default:
                console.warn(`Unknown expression found: ${expr.instructionName} (${expr.toCode()})`);
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_12__["default"].INVALID;
        }
    }
    // 
    // Handle all instruction types
    //
    function translate(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_VariableDecl:
                {
                    let decl = instr;
                    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl.initExpr)) {
                        // There is no initial value, but allocation should be done anyway
                        // in order to assign register for this variable.
                        ref(decl, alloca(decl.type.size));
                        return;
                    }
                    /*
                    0: int a = 1;           | 0x00: load %a   #1        | NS 0
                    1: int b = 2;           | 0x01: load %b   #2        | NS 1
                    2: int c = a + b * 10;  | 0x02: load %t0  #10       |
                                            | 0x03: mul  $t1  %b %t0    |
                                            | 0x02: add  %c   %a %t1    | NS 2
                    3: return c;            | 0x03: move %rax %c        | NS 3
                                            | 0x04: ret                 |
                                            |
                    */
                    let dest = raddr(decl.initExpr);
                    if (dest.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        //breakpoint before variable initialization
                        debug.ns();
                        dest = iload(dest);
                        debug.map(decl.initExpr);
                        // breakpoint right after variable initialization
                        debug.ns();
                    }
                    ref(decl, dest);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_DeclStmt:
                {
                    let stmt = instr;
                    stmt.declList.forEach(translate);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_IfStmt:
                {
                    // [out of if code]
                    //  jif:
                    // jump: 'jump to end of if'    ---+
                    // ....                            |
                    // ....                            |
                    // ....                            |
                    // [out of if code]             <--+
                    // [out of if code]
                    //  jif:
                    // jump: 'jump to contrary'     ---+
                    // ....                            |
                    // ....                            |
                    // jump:  'jump to skip contraty'  |  ---+
                    // ....                         <--+     |
                    // ....                                  |
                    // [out of if code]                   <--+ 
                    let ifStmt = instr;
                    let { cond, conseq, contrary } = ifStmt;
                    let condAddr = raddr(cond);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(condAddr.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].bool());
                    if (condAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        condAddr = iload(condAddr);
                    }
                    iop1(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_JumpIf, condAddr);
                    let unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);
                    translate(conseq);
                    // jump co contrary or out of if
                    let jumpTo = pc() + (contrary ? 1 : 0);
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, [jumpTo]);
                    if (contrary) {
                        unresolvedJump = pc();
                        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);
                        translate(contrary);
                        // jump to skip contrary
                        jumpTo = pc();
                        instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, [jumpTo]);
                    }
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ReturnStmt:
                {
                    let retStmt = instr;
                    const expr = retStmt.expr;
                    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(expr)) {
                        let src = raddr(expr);
                        if (src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                            src = iload(src);
                            debug.map(expr);
                        }
                        const dest = ret();
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.size === ret().size);
                        imove(dest, src);
                        debug.map(expr);
                    }
                    // breakpoint before leaving function
                    debug.ns();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Ret);
                    debug.map(retStmt);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_StmtBlock:
                {
                    open(); // open block
                    let block = instr;
                    for (let stmt of block.stmtList) {
                        translate(stmt);
                    }
                    close(); // close block
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_FunctionDecl:
                {
                    let func = instr;
                    if (!func.impl) {
                        // resolve function's implementation
                        func = func.scope.findFunctionInScope(func);
                    }
                    let def = func.def; // todo: handle all arguments!!
                    let impl = func.impl;
                    translate(impl);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ExprStmt:
                {
                    let stmt = instr;
                    raddr(stmt.expr);
                    return;
                }
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_8__.EInstructionTypes.k_ForStmt:
                {
                    const loop = instr;
                    const { init, cond, step, body } = loop;
                    open(); // open block
                    // TODO: make the code more readable
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(init)) {
                        // translate as expression
                        raddr(init);
                    }
                    else {
                        // translate as varaible declaration
                        translate(init);
                    }
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(cond.type, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_BOOL));
                    // before cond:
                    let beforeCondPc = pc();
                    let condAddr = raddr(cond);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(condAddr.size === _sizeof__WEBPACK_IMPORTED_MODULE_13__["default"].bool());
                    if (condAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__.EAddrType.k_Registers) {
                        condAddr = iload(condAddr);
                    }
                    // TOOD: add support for break statement.
                    iop1(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_JumpIf, condAddr);
                    let unresolvedJump = pc();
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, UNRESOLVED_JUMP_LOCATION);
                    translate(body);
                    // step:
                    raddr(step);
                    // goto to before condition
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, beforeCondPc);
                    // out of loop:
                    let outofLoopPc = pc();
                    // resolve jump in case of invalid condition => go to out of loop
                    instructions.replace(unresolvedJump, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_7__.EOperation.k_Jump, [outofLoopPc]);
                    close(); // close block
                    return;
                }
            default:
                console.warn(`Unknown statement found: ${instr.instructionName} (${instr.toCode()})`);
        }
    }
    translate(instr);
}
const hex2 = (v) => `0x${v.toString(16).padStart(2, '0')}`;
const hex4 = (v) => `0x${v.toString(16).padStart(4, '0')}`;
function translate(a, b) {
    let uri;
    let entryFunc;
    switch (arguments.length) {
        case 2:
            {
                let [slDocument, entryName] = arguments;
                entryFunc = slDocument.root.scope.findFunction(entryName, null);
                uri = slDocument.uri;
            }
            break;
        case 1:
            {
                [entryFunc] = arguments;
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(entryFunc);
                uri = entryFunc.sourceNode?.loc?.start.file;
            }
            break;
        default:
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
    }
    const ctx = (0,_Context__WEBPACK_IMPORTED_MODULE_11__.ContextBuilder)(uri);
    let program = null;
    if (true) {
        console.time('[translate program]');
    }
    try {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(entryFunc)) {
            ctx.critical(entryFunc.sourceNode, _Context__WEBPACK_IMPORTED_MODULE_11__.EErrors.k_EntryPointNotFound, {});
        }
        program = translateProgram(ctx, entryFunc);
    }
    catch (e) {
        if (!(e instanceof _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_9__.DiagnosticException)) {
            throw e;
        }
    }
    if (true) {
        console.timeEnd('[translate program]');
        // console.log(`${entryFunc.def.name} translated as ${res.code.byteLength} bytes`);
    }
    const diagnosticReport = ctx.diag.resolve();
    return { uri, diagnosticReport, program };
}
async function translateExpression(expr, context) {
    const uri = `://expression`;
    const anonymousFuncName = `anonymous`;
    const source = `auto ${anonymousFuncName}() { return (${expr}); }`;
    const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__.createTextDocument)(uri, source);
    const documentEx = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_4__.createFXSLDocument)(textDocument, undefined, context);
    if (!documentEx.diagnosticReport.errors) {
        return translate(documentEx, anonymousFuncName);
    }
    console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_9__.Diagnostics.stringify(documentEx.diagnosticReport));
    return null;
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "qOq6":
/*!*********************************************!*\
  !*** ./src/lib/fx/bytecode/ConstantPool.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstanPool": () => (/* binding */ ConstanPool),
/* harmony export */   "ConstantPoolMemory": () => (/* binding */ ConstantPoolMemory),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytecode */ "dnVx");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "4eqb");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PromisedAddress */ "ZrbQ");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Bytecode__WEBPACK_IMPORTED_MODULE_4__]);
_Bytecode__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







class ConstantPoolMemory {
    constructor() {
        this.byteArray = new Uint8Array(4);
        this.byteLength = 0;
    }
    get byteCapacity() {
        return this.byteArray.byteLength;
    }
    /** Check capacity and make realloc if needed. */
    check(byteSize) {
        let expected = this.byteLength + byteSize;
        if (expected <= this.byteCapacity) {
            return;
        }
        var oldBuffer = this.byteArray;
        var newBuffer = new Uint8Array(Math.max(expected, this.byteCapacity * 2));
        newBuffer.set(oldBuffer);
        this.byteArray = newBuffer;
    }
    /**
     *
     * @param size Size in bytes.
     */
    addUniform(size, name, defaultValue = null) {
        this.check(size);
        if (defaultValue) {
            this.byteArray.set(defaultValue, this.byteLength);
        }
        this.byteLength += size;
    }
}
class ConstanPool {
    constructor() {
        this._data = new ConstantPoolMemory;
        this._knownConstants = [];
    }
    deref(decl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(decl.isGlobal() && (decl.type.isUniform() || decl.isConstant()));
        const { name, semantic, initExpr, type: { size } } = decl;
        let reflection = this._knownConstants.find(c => c.name === name);
        if (!reflection) {
            let addr = null;
            let defaultValue = null;
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(initExpr)) {
                if (decl.type.isNotBaseArray()) {
                    // todo: add support
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'arrays are not yet supported (!)');
                }
                else {
                    switch (initExpr.type.name) {
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_FLOAT.name:
                            defaultValue = new Float32Array([initExpr.value]);
                            break;
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_UINT.name:
                            defaultValue = new Uint32Array([initExpr.value]);
                            break;
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_BOOL.name:
                            const value = initExpr.value;
                            defaultValue = new Int32Array([value ? 1 : 0]);
                            break;
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_INT.name:
                            defaultValue = new Int32Array([initExpr.value]);
                            break;
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_FLOAT2.name:
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_FLOAT3.name:
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_FLOAT4.name:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr);
                            defaultValue = new Float32Array(initExpr.args.map(arg => arg.value));
                            break;
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_INT2.name:
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_INT3.name:
                        case _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_INT4.name:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr);
                            defaultValue = new Int32Array(initExpr.args.map(arg => arg.value));
                            break;
                        default:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported');
                            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_6__["default"].INVALID;
                    }
                }
            }
            addr = this.addUniform(size, `${name}${semantic ? `:${semantic}` : ''}`, defaultValue);
            const { addr: offset } = addr;
            const type = decl.type.name; // TODO: use signature?
            reflection = {
                name,
                semantic,
                offset,
                size,
                type
            };
            this._knownConstants.push(reflection);
        }
        // NOTE: we return copy because adress will be loaded
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_6__["default"]({
            type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__.EAddrType.k_Input,
            inputIndex: _Bytecode__WEBPACK_IMPORTED_MODULE_4__.CBUFFER0_REGISTER,
            addr: reflection.offset,
            size
        });
    }
    // todo: merge with general deref
    derefCString(value) {
        const align4 = (x) => ((x + 3) >> 2) << 2;
        let name = `"${value}"`;
        let size = align4(4 /* sizeof(value) */ + value.length + 1 /* trailing zero */);
        let reflection = this._knownConstants.find(c => c.name === name);
        let semantic = "";
        if (!reflection) {
            let u8Data = new Uint8Array(size);
            u8Data.set([...(0,_common__WEBPACK_IMPORTED_MODULE_5__.i32ToU8Array)(value.length), ...value.split('').map(c => c.charCodeAt(0)), 0]);
            let addr = this.addUniform(size, `"${value}"`, u8Data);
            const { addr: offset } = addr;
            const type = `string`;
            reflection = {
                name,
                offset,
                size,
                type,
                semantic
            };
            this._knownConstants.push(reflection);
        }
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_6__["default"]({
            type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__.EAddrType.k_Input,
            inputIndex: _Bytecode__WEBPACK_IMPORTED_MODULE_4__.CBUFFER0_REGISTER,
            addr: reflection.offset,
            size
        });
    }
    addUniform(size, desc, defaultValue = null) {
        const addr = this._data.byteLength;
        this._data.addUniform(size, desc, defaultValue ? new Uint8Array(defaultValue.buffer, defaultValue.byteOffset, defaultValue.byteLength) : null);
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_6__["default"]({
            type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_2__.EAddrType.k_Input,
            inputIndex: _Bytecode__WEBPACK_IMPORTED_MODULE_4__.CBUFFER0_REGISTER,
            addr,
            size
        });
    }
    get data() {
        return this._data;
    }
    get size() {
        return this._data.byteLength;
    }
    dump() {
        return this._knownConstants;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConstanPool);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "PMu9":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/Context.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextBuilder": () => (/* binding */ ContextBuilder),
/* harmony export */   "EErrors": () => (/* binding */ EErrors),
/* harmony export */   "EWarnings": () => (/* binding */ EWarnings),
/* harmony export */   "TranslatorDiagnostics": () => (/* binding */ TranslatorDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "/9BJ");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "4eqb");
/* harmony import */ var _ConstantPool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ConstantPool */ "qOq6");
/* harmony import */ var _DebugLayout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DebugLayout */ "prdm");
/* harmony import */ var _InstructionList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InstructionList */ "MjXi");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PromisedAddress */ "ZrbQ");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sizeof */ "p8vA");
/* harmony import */ var _SymbolTable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SymbolTable */ "+nD5");
/* harmony import */ var _SRVPool__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SRVPool */ "LvtK");
/* harmony import */ var _UAVPool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./UAVPool */ "c1OO");
/* harmony import */ var _Externs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Externs */ "iHBS");
/* harmony import */ var _PipelineStates__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./PipelineStates */ "EYeK");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ConstantPool__WEBPACK_IMPORTED_MODULE_6__, _SRVPool__WEBPACK_IMPORTED_MODULE_12__, _UAVPool__WEBPACK_IMPORTED_MODULE_13__, _Externs__WEBPACK_IMPORTED_MODULE_14__]);
([_ConstantPool__WEBPACK_IMPORTED_MODULE_6__, _SRVPool__WEBPACK_IMPORTED_MODULE_12__, _UAVPool__WEBPACK_IMPORTED_MODULE_13__, _Externs__WEBPACK_IMPORTED_MODULE_14__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
















var EErrors;
(function (EErrors) {
    EErrors[EErrors["k_UnsupportedConstantType"] = 0] = "k_UnsupportedConstantType";
    EErrors[EErrors["k_UnsupportedExprType"] = 1] = "k_UnsupportedExprType";
    EErrors[EErrors["k_UnsupoortedTypeConversion"] = 2] = "k_UnsupoortedTypeConversion";
    EErrors[EErrors["k_UnsupportedArithmeticExpr"] = 3] = "k_UnsupportedArithmeticExpr";
    EErrors[EErrors["k_UnsupportedRelationalExpr"] = 4] = "k_UnsupportedRelationalExpr";
    EErrors[EErrors["k_UnsupportedIntrinsic"] = 5] = "k_UnsupportedIntrinsic";
    EErrors[EErrors["k_UnsupportedUnaryExpression"] = 6] = "k_UnsupportedUnaryExpression";
    EErrors[EErrors["k_UnsupportedAssigmentOperator"] = 7] = "k_UnsupportedAssigmentOperator";
    EErrors[EErrors["k_UnsupportedAddressType"] = 8] = "k_UnsupportedAddressType";
    EErrors[EErrors["k_AddressCannotBeResolved"] = 9] = "k_AddressCannotBeResolved";
    EErrors[EErrors["k_EntryPointNotFound"] = 10] = "k_EntryPointNotFound";
    EErrors[EErrors["k_NotImplemented"] = 11] = "k_NotImplemented";
})(EErrors || (EErrors = {}));
var EWarnings;
(function (EWarnings) {
})(EWarnings || (EWarnings = {}));
class TranslatorDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics {
    constructor() {
        super("Translator Diagnostics", 'T');
    }
    resolveFilename(category, code, desc) {
        return '[unknown]'; // FIXME: return correct filename
    }
    resolveRange(category, code, desc) {
        return { start: { line: 0, column: 0, file: null }, end: { line: 0, column: 0, file: null } }; // todo: fixme
    }
    diagnosticMessages() {
        // TODO: fill all errors.
        // TODO: add support for warnings
        return {};
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            return `${EWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${EErrors[code]}:${loc?.start.line}:${loc?.start.column}: ${JSON.stringify(data)}`;
    }
}
function ContextBuilder(uri = null) {
    console.assert(uri, 'no debug info?!');
    // occupied registers count 
    // same as stack pointer; 
    // counter grows forward;
    let rc = 0;
    // stack of functions and logical blocks for ex: braces.
    const stack = [];
    const instructions = new _InstructionList__WEBPACK_IMPORTED_MODULE_8__["default"];
    const constants = new _ConstantPool__WEBPACK_IMPORTED_MODULE_6__["default"];
    const pipeline = new _PipelineStates__WEBPACK_IMPORTED_MODULE_15__.PipelineStates;
    const uavs = new _UAVPool__WEBPACK_IMPORTED_MODULE_13__.UAVPool;
    const srvs = new _SRVPool__WEBPACK_IMPORTED_MODULE_12__.SRVPool;
    const externs = new _Externs__WEBPACK_IMPORTED_MODULE_14__.Externs;
    const diag = new TranslatorDiagnostics; // todo: remove it?
    // type IWarningInfo = IMap<any>;
    const resolveNodeSourceLocation = (sourceNode) => {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(sourceNode))
            return null;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(sourceNode.loc))
            return sourceNode.loc;
        return resolveNodeSourceLocation(sourceNode.children[sourceNode.children.length - 1]);
    };
    const error = (sourceNode, code, info = {}) => {
        const loc = resolveNodeSourceLocation(sourceNode);
        const file = uri;
        diag.error(code, { file, loc, info });
    };
    const critical = (sourceNode, code, info = {}) => {
        const loc = resolveNodeSourceLocation(sourceNode);
        const file = uri;
        diag.critical(code, { file, loc, info });
    };
    //
    // ====================
    //
    /** @returns Description of the top of the callstack */
    const top = () => stack[stack.length - 1];
    const depth = () => stack.length;
    const ret = () => top().ret;
    const pc = () => instructions.pc;
    const debug = (0,_DebugLayout__WEBPACK_IMPORTED_MODULE_7__["default"])(pc);
    /* (assuming that all registers for all types are placed in the same memory) */
    function alloca(size) {
        if (size === 0) {
            return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
        }
        const dest = Addr.loc({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers, addr: rc, size });
        rc += size;
        return dest;
    }
    /** insert code */
    function icode(code, ...args) {
        if (code === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_Ret) {
            // add the instruction address to the description of the
            // function on the top of the colstack; when the code
            // generation for this function is completed, all return
            // instructions must receive the correct addresses for
            // jumping to the end of the function
            addReturn();
        }
        // add this instruction to debug layout;
        debug.step();
        instructions.add(code, args.map(Number));
    }
    /**
     * Apply per component operation between two register-based adresses
     * op(a[i])
     */
    function iop1(op, dest) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * a[i] = op(b[i])
     */
    function iop2(op, dest, a) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === a.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * dest[i] = op(a[i], b[i])
     */
    function iop3(op, dest, a, b) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(b.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === a.length);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === b.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), b.addr + (b.swizzle ? b.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Apply per component operation between two register-based adresses
     * dest[i] = op(a[i], b[i], c[i])
     */
    function iop4(op, dest, a, b, c) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(b.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(c.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === a.length);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === b.length);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.length === c.length);
        for (let i = 0; i < dest.length; ++i) {
            icode(op, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), a.addr + (a.swizzle ? a.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), b.addr + (b.swizzle ? b.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), c.addr + (c.swizzle ? c.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
        }
    }
    /**
     * Write something to this location/address
     * @param src Source address.
     * @param size Size of the source location.
     */
    function imove(dest, src) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.length === dest.length, `source size is ${src.size} and less then the requested size ${dest.size}.`);
        switch (dest.type) {
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers:
                {
                    switch (src.type) {
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32LoadRegister, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Input:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32LoadInput, src.inputIndex, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32LoadRegistersPointer, 
                                // destination register
                                dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                                // source pointer
                                src.addr, 
                                // pointer offset
                                (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerInput:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                            for (let i = 0; i < dest.length; ++i) {
                                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32LoadInputPointer, src.inputIndex, 
                                // destination register
                                dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                                // source pointer
                                src.addr, 
                                // pointer offset
                                (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                            }
                            break;
                        default:
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported memory type found.');
                    }
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Input:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32StoreInput, dest.inputIndex, dest.addr + (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerInput:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32StoreInputPointer, dest.inputIndex, 
                    // destination pointer
                    dest.addr, 
                    // source register
                    src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                    // destination offset
                    (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
                for (let i = 0; i < dest.length; ++i) {
                    icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32StoreRegisterPointer, 
                    // destination pointer
                    dest.addr, 
                    // source register
                    src.addr + (src.swizzle ? src.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), 
                    // destination offset
                    (dest.swizzle ? dest.swizzle[i] : i) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
                }
                break;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported memory type found.');
        }
        return dest;
    }
    /**
     * Resolve/move this address/region to registers
     */
    function iload(src) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        return imove(alloca(src.size), src);
    }
    const I32_HINT = 0;
    const F32_HINT = 1;
    // hint: 0 -> i32, 1 -> f32 (hints for bytecode viewer only)
    function iset(dest, i32, i32Hint) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dest.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32SetConst, dest.addr + (dest.swizzle ? dest.swizzle[0] : 0) * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32(), i32, i32Hint);
        return dest;
    }
    function iconst_i32(i32) {
        return iset(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32()), i32, I32_HINT);
    }
    function iconst_f32(f32) {
        return iset(alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].f32()), (0,_common__WEBPACK_IMPORTED_MODULE_5__.f32Asi32)(f32), F32_HINT);
    }
    /**
     * Add referene of the local variable.
     * @param decl Variable declaration.
     * @param src Register number.
     */
    function ref(decl, src) {
        const name = _common__WEBPACK_IMPORTED_MODULE_5__.sname["var"](decl);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(src.type === _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers);
        const scopes = top().scopes;
        const symbols = scopes[scopes.length - 1].symbols;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(symbols[name]));
        symbols[name] = src;
    }
    /**
     * @returns Register address of variable/constant or REG_INVALID.
     * @param decl
     */
    function deref(decl) {
        const name = _common__WEBPACK_IMPORTED_MODULE_5__.sname["var"](decl);
        // is zero register available?
        for (let iFn = stack.length - 1; iFn >= 0; --iFn) {
            const scopes = stack[iFn].scopes;
            for (let iScope = scopes.length - 1; iScope >= 0; --iScope) {
                const symbols = scopes[iScope].symbols;
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(symbols[name])) {
                    return symbols[name];
                }
            }
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `cannot dereference varaible ${name} (${decl.toCode()})`);
        return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
    }
    /** @returns Address of the return value. */
    function push(fn, ret) {
        const pc = instructions.pc;
        const retRequests = [];
        const scopes = [];
        stack.push({ fn, scopes, ret, pc, retRequests });
        open();
    }
    function pop() {
        // check that there are no non-closed blocks left inside the function
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(top().scopes.length === 1);
        close();
        const entry = stack.pop();
        const entryPoint = stack.length === 0;
        // updating all return adresses to correct values
        if (!entryPoint) {
            entry.retRequests.forEach(pc => instructions.replace(pc, _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_Jump, [instructions.pc]));
            //                                                                          ^^^^^^^^^^^^^^^^^
            //                                                     instruction immediately after function
        }
    }
    /** Open new block */
    function open() {
        const symbols = new _SymbolTable__WEBPACK_IMPORTED_MODULE_11__["default"]();
        top().scopes.push({ symbols, rc });
    }
    /** CLose last block */
    function close() {
        const scope = top().scopes.pop();
        rc = scope.rc;
    }
    // next operation will be 'k_Ret'
    function addReturn() {
        top()?.retRequests.push(pc());
    }
    const Addr = {
        loc({ type = _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers, addr, inputIndex, size, swizzle }) {
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr, inputIndex, size, swizzle });
        },
        // override layout
        override(src, swizzle) {
            let offset = 0;
            let size = 0;
            swizzle = swizzle.map(i => src.swizzle ? src.swizzle[i] : i);
            // NOTE: 
            // All this optimizations are need only for debug purposes.
            if (!src.isPointer()) {
                // removment of the unary swizzles
                if (swizzle.length === 1) {
                    offset = swizzle[0] * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    size = _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = null;
                    return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ ...src, addr: src.addr + offset, size, swizzle });
                }
                const ordered = [...swizzle].sort((a, b) => a - b);
                // removment of the gap
                // example: v.zw => (&v + 2).xy
                if (ordered[0] !== 0) {
                    offset = ordered[0] * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = swizzle.map(si => si - ordered[0]);
                }
                // removment of the useless swizzles
                // example: v.xy => v
                const useless = swizzle.every((si, i) => si === i);
                if (useless) {
                    size = swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32();
                    swizzle = null;
                }
            }
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ ...src, addr: src.addr + offset, size, swizzle });
        },
        subPointer(src, indexAddr, arrayElementSize) {
            const { type, addr, size, inputIndex, swizzle } = src;
            if (indexAddr.type !== _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers) {
                indexAddr = iload(indexAddr);
            }
            //
            // no swizzling (pointers & non-pointers)
            //
            if (!swizzle) {
                // convert byte offset to register index (cause VM uses registers not byte offsets)
                const sizeAddr = iconst_i32(arrayElementSize >> 2);
                // convert byte offset to register index
                const baseAddr = !src.isPointer() ? iconst_i32(addr >> 2) : addr;
                const pointerType = !src.isPointer() ? _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].castToPointer(type) : type;
                const pointerAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].addr()); // addr <=> i32
                icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32Mad, pointerAddr, baseAddr, indexAddr, sizeAddr);
                return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });
            }
            //
            // swizzling (pointers & non-pointers)
            //
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(arrayElementSize === _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(swizzle.length <= 4);
            const swBaseRegister = rc;
            swizzle.forEach(si => iconst_i32(si));
            // ----- sw base rigister
            // [z]
            // [x]
            // [y]
            // -----
            const swAddr = iconst_i32(swBaseRegister >> 2);
            // swAddr ==> [ sw base rigister ]
            icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32Add, swAddr, swAddr, indexAddr);
            // swAddr ==> [ sw base rigister + offset ]
            // pointer to value of the swizzle for given offset
            const offsetPointer = new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters, addr: swAddr, size: _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() });
            const pointerAddr = iload(offsetPointer);
            // destAddr ==> [ swizzles[offset] ]
            const baseAddr = !src.isPointer() ? iconst_i32(addr >> 2) : addr;
            const pointerType = !src.isPointer() ? _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].castToPointer(type) : type;
            // add given swizzle to base pointer (all pointers already aligned in registers, so 'mad' isn't not needed here)
            icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32Add, pointerAddr, baseAddr, pointerAddr);
            return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type: pointerType, addr: pointerAddr, size: arrayElementSize, inputIndex });
        },
        sub(src, offset, range) {
            const { type, addr, size, inputIndex, swizzle } = src;
            range = range || (size - offset);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(range % _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() === 0);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(offset % _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32() === 0);
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(size >= offset + range);
            if (src.isPointer()) {
                if (!swizzle) {
                    if (offset !== 0) {
                        // calc the summ of the original addr and given offset
                        const newAddr = alloca(_sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].addr());
                        const offsetAddr = iconst_i32(offset >> 2);
                        icode(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_2__.EOperation.k_I32Add, newAddr, addr, offsetAddr);
                        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr: newAddr, size: range, inputIndex });
                    }
                    // nothing todo, just shrink the size
                    return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr, size: range, inputIndex });
                }
                // offsets from the swizzled pointers are unsupported
                // ex: uav[i].xyz.field
                //                ^^^^^
                //                there are not such case can be! 
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported branch');
                return _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"].INVALID;
            }
            // just shift the address
            if (!swizzle) {
                return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_9__["default"]({ type, addr: addr + offset, size: range, inputIndex });
            }
            // implicitly move padding inside swizzles
            const ordered = [...Array(range / _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32()).keys()].map(i => i + offset / _sizeof__WEBPACK_IMPORTED_MODULE_10__["default"].i32());
            return Addr.override(src, ordered);
        },
        shrink(src, size) {
            return Addr.sub(src, 0, size);
        }
    };
    const addr = Addr;
    return {
        pc,
        addr,
        instructions,
        debug,
        deref,
        ref,
        alloca,
        icode,
        imove,
        iload,
        iconst_i32,
        iconst_f32,
        iop4,
        iop3,
        iop2,
        iop1,
        push,
        pop,
        open,
        close,
        ret,
        constants,
        pipeline,
        externs,
        uavs,
        srvs,
        depth,
        diag,
        error,
        critical
    };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "prdm":
/*!********************************************!*\
  !*** ./src/lib/fx/bytecode/DebugLayout.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugLineRecord": () => (/* binding */ DebugLineRecord),
/* harmony export */   "cdlview": () => (/* binding */ cdlview),
/* harmony export */   "debug": () => (/* binding */ debug),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/util/DistinctColor */ "aBMm");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "E9s6");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);




var EDebugLineFlags;
(function (EDebugLineFlags) {
    EDebugLineFlags[EDebugLineFlags["k_NewStatement"] = 1] = "k_NewStatement";
})(EDebugLineFlags || (EDebugLineFlags = {}));
;
class DebugLineRecord {
}
function debugLine(pc) {
    const files = [];
    const layout = [];
    const lastRecord = () => layout[layout.length - 1] || null;
    // mark last record as 'new statement';
    function ns() {
        let rec = lastRecord();
        // TOOD: allow breakpoints in case of no instructions have already beed added
        if (rec) {
            rec.flags |= EDebugLineFlags.k_NewStatement;
        }
    }
    // add last instruction to record table;
    function step() {
        layout.push({ pc: pc(), flags: 0 });
    }
    // add filename to source files table and return index;
    function fileToIndex(file) {
        let idx = files.indexOf(file);
        if (idx == -1) {
            idx = files.length;
            files.push(file);
        }
        return idx;
    }
    function map(inst) {
        const loc = (inst && inst.sourceNode && inst.sourceNode.loc) || null;
        if ((0,util__WEBPACK_IMPORTED_MODULE_3__.isNull)(loc)) {
            return;
        }
        const pos = loc.start;
        const rec = lastRecord();
        if (rec) {
            rec.line = pos.line || 0;
            rec.column = pos.column || 0;
            rec.file = fileToIndex(`${pos.file}`);
        }
    }
    function dump() {
        let line = undefined;
        let color = new _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_1__["default"];
        let cache = {};
        for (let i = layout.length - 1; i >= 0; i--) {
            let entry = layout[i];
            if (line != entry.line)
                color.pickNext();
            line = (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(entry.line) ? entry.line : line;
            entry.line = line;
            cache[line] = (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(cache[line]) ? cache[line] : color.value();
            entry.color = cache[line];
        }
        return { files, layout };
    }
    return {
        ns,
        step,
        map,
        dump
    };
}
var ETagType;
(function (ETagType) {
    ETagType[ETagType["k_CompilationUnit"] = 0] = "k_CompilationUnit";
    ETagType[ETagType["k_SubProgram"] = 1] = "k_SubProgram";
})(ETagType || (ETagType = {}));
function debugInfo(pc) {
    let unitLayout;
    function locate(decl, reg) {
    }
    function beginCompilationUnit(name = null, layout) {
        unitLayout = layout;
    }
    function endCompilationUnit() { }
    ;
    function beginSubProgram(func) { }
    function endSubProgram() { }
    function dump() {
        return {
            layout: unitLayout
        };
    }
    return {
        beginCompilationUnit,
        endCompilationUnit,
        beginSubProgram,
        endSubProgram,
        locate,
        dump
    };
}
function debug(pc) {
    const line = debugLine(pc);
    const info = debugInfo(pc);
    function dump() {
        return {
            line: line.dump(),
            info: info.dump()
        };
    }
    // const { ns } = line;
    // const { beginCompilationUnit, endCompilationUnit, beginSubProgram, endSubProgram } = info;
    return { ...line, ...info, dump }; // todo: export only required;
}
/**
 * Code Debug Layout View.
 */
function cdlview(cdlRaw) {
    if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_2__.isDefAndNotNull)(cdlRaw)) {
        return null;
    }
    const { line, info } = cdlRaw;
    /**
     * @param pc Number of instruction.
     */
    function resolveFileLocation(pc) {
        let rec = line.layout[pc];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(rec.pc == pc);
        return {
            file: (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(rec.file) ? line.files[rec.file] : null,
            line: rec.line,
            column: rec.column
        };
    }
    /**
     * @returns Valid breakpoint position from arbitrary line.
     */
    function resolveBreakpointLocation(ln) {
        // todo: optimize it;
        let rec = line.layout.find(r => r.line >= ln && (r.flags & EDebugLineFlags.k_NewStatement) != 0);
        return (rec && rec.line) || -1;
    }
    function resolvePcColor(pc) {
        return line.layout[pc] ? line.layout[pc].color : 0xffffff;
    }
    function resolveLineColor(ln, file) {
        let rec = line.layout.find(r => r.line === ln && r.file === line.files.indexOf(file));
        return rec ? rec.color : -1;
    }
    return {
        resolveFileLocation,
        resolveBreakpointLocation,
        resolvePcColor,
        resolveLineColor
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debug);


/***/ }),

/***/ "iHBS":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/Externs.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Externs": () => (/* binding */ Externs)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _VM_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VM/native */ "1fdM");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_VM_native__WEBPACK_IMPORTED_MODULE_1__]);
_VM_native__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


class Externs {
    constructor() {
        this.funcs = [];
    }
    add(fdef) {
        let id = this.funcs.indexOf(fdef);
        if (id === -1) {
            id = this.funcs.length;
            this.funcs.push(fdef);
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.funcs[id].instructionID === fdef.instructionID);
        return id;
    }
    dump() {
        return this.funcs.map((fdef, id) => {
            const ret = (0,_VM_native__WEBPACK_IMPORTED_MODULE_1__.typeAstToTypeLayout)(fdef.returnType);
            const params = fdef.params.map(({ type }) => (0,_VM_native__WEBPACK_IMPORTED_MODULE_1__.typeAstToTypeLayout)(type));
            const name = fdef.name;
            return { id, name, ret, params };
        });
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "MjXi":
/*!************************************************!*\
  !*** ./src/lib/fx/bytecode/InstructionList.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "/9BJ");


// todo: use more compact format than 4 x int32
class InstructionList {
    constructor() {
        this._data = new Uint32Array(8);
        this._length = 0;
    }
    get capacity() {
        return this._data.length;
    }
    get data() {
        return this._data.subarray(0, this._length);
    }
    get length() {
        return this._length;
    }
    get pc() {
        return this.length / InstructionList.STRIDE;
    }
    // convert bytes adresses to register numbers
    // validate number of arguments
    // premultiply jump counters with instructions stride
    static prepareInstruction(op, args) {
        // NOTE: keep order as it is done in the VM.ts
        switch (op) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32SetConst:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2;
                // args[1] => constant itself
                // args[2] => hint about what type lies in the constant
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LoadRegister:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LoadRegistersPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32StoreRegisterPointer:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2; // byte offset => register offset
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LoadInput:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32StoreInput:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                // args[0] => input index    
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LoadInputPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32StoreInputPointer:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 4);
                // args[0] => input index
                args[1] >>= 2;
                args[2] >>= 2;
                args[3] >>= 2; // byte offset => register offset
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32TextureLoad:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2; // float4 sized destination address
                args[1]; // is input index of texture
                args[2] >>= 2; // address of arguments
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32ExternCall:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                args[0]; // id of external routine
                args[1] >>= 2; // cc layout
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Not:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Mul:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Mod:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Mul:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Mod:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_U32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_U32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Equal:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32NotEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32GreaterThanEqual:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Mad:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 4);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                args[3] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LogicalOr:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32LogicalAnd:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Frac:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Floor:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Ceil:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Sin:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Cos:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Abs:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Sqrt:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32Max:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Max:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32Pow:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 3);
                args[0] >>= 2;
                args[1] >>= 2;
                args[2] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32ToI32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_I32ToF32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_F32ToU32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_U32ToF32:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                args[0] >>= 2;
                args[1] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Jump:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length === 1);
                // don't multiply jump in order to facilitate the operation of the VM
                // see bundle.cpp/bundle.ts for more details.
                args[0] *= 1; // InstructionList.STRIDE;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_JumpIf:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length === 1);
                args[0] >>= 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Ret:
                // nothing todo
                break;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unknown operation found: ${op} (${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation[op]})`);
        }
    }
    add(op, args) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length <= 4);
        this.check(InstructionList.STRIDE);
        InstructionList.prepareInstruction(op, args);
        this.push(op);
        args.forEach((v) => this.push(v));
        this._length += 4 - args.length;
    }
    /**
     * Replace specified instruction with new one;
     * @param pc number of instruction to be replaced
     * @param op new operation
     * @param args new arguments
     */
    replace(pc, op, args) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(pc < this.pc);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length <= 4);
        const pc5 = pc * InstructionList.STRIDE; // stride is 5
        // FIXME: remove this assert
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.data[pc5] === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Ret || this.data[pc5] === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Jump, `expected ${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Ret}/${_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_1__.EOperation.k_Jump}, but given is ${this.data[pc5]} for pc = ${pc}`);
        InstructionList.prepareInstruction(op, args);
        // replace op
        this.data[pc5] = op;
        // replace arguments
        args.forEach((v, i) => { this.data[pc5 + 1 + i] = v; });
    }
    // [ op, a, b, c, d ]
    back() {
        return this.data.slice(-InstructionList.STRIDE);
    }
    push(val) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.capacity - this._length >= 1);
        this._data[this._length++] = val;
    }
    check(count) {
        let expected = this._length + count;
        if (expected <= this.capacity) {
            return;
        }
        var oldData = this._data;
        var newData = new Uint32Array(Math.max(expected, this.capacity * 2));
        newData.set(oldData);
        this._data = newData;
    }
}
InstructionList.STRIDE = 5;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InstructionList);


/***/ }),

/***/ "EYeK":
/*!***********************************************!*\
  !*** ./src/lib/fx/bytecode/PipelineStates.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PipelineStates": () => (/* binding */ PipelineStates),
/* harmony export */   "createDepthStencilState": () => (/* binding */ createDepthStencilState),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");





function hash(csh) {
    return `${csh.ver}-${csh.func.name}.${csh.func.instructionID}-${csh.args.map(a => _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.evalConst(a)).join(':')}`;
}
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
function createDepthStencilState() {
    return {
        DepthEnable: true,
        DepthWriteMask: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EDepthWriteMask.k_All,
        DepthFunc: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc.k_Less,
        StencilEnable: false,
        StencilReadMask: 0xff,
        StencilWriteMask: 0xff,
        FrontFace: {
            StencilFailOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilDepthFailOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilPassOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilFunc: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc.k_Always
        },
        BackFace: {
            StencilFailOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilDepthFailOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilPassOp: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp.k_Keep,
            StencilFunc: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc.k_Always
        }
    };
}
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
const camelToSnakeCase = str => str?.length > 1
    ? (str[0] + str.substring(1).replace(/[A-Z]/g, letter => `_${letter}`)).toLowerCase()
    : str;
function evalPropEnum(props, key, enumObj, defaultVal) {
    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(props[key])) {
        return defaultVal;
    }
    const knownKeys = Object.keys(enumObj);
    const keyIndex = knownKeys.map(k => camelToSnakeCase(k.substring(2)).toUpperCase()).indexOf(props[key].toUpperCase());
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(keyIndex !== -1);
    if (keyIndex == -1) {
        return defaultVal;
    }
    const keyName = knownKeys[keyIndex];
    const enumVal = enumObj[keyName];
    return enumVal;
}
function evalPropBool(props, key, defaultVal) {
    let EBool;
    (function (EBool) {
        EBool[EBool["k_False"] = 0] = "k_False";
        EBool[EBool["k_True"] = 1] = "k_True";
    })(EBool || (EBool = {}));
    return !!evalPropEnum(props, key, EBool, +defaultVal);
}
function evalNumber(props, key, defaultVal) {
    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(props[key])) {
        return defaultVal;
    }
    return Number(props[key]);
}
class PipelineStates {
    constructor() {
        this._knownShaders = {};
        this._knownDepthStencilStates = [];
    }
    dumpShaders() {
        return Object.values(this._knownShaders).sort((a, b) => a.id - b.id);
    }
    dumpDepthStencilStates() {
        return this._knownDepthStencilStates.map(entry => entry.state);
    }
    derefShader11(csh) {
        const { func, ver } = csh;
        const { name } = func;
        const key = hash(csh);
        const shaders = this._knownShaders;
        if (shaders[key]) {
            return shaders[key].id;
        }
        const id = Object.keys(shaders).length + 1; // '0' is reserved id for NULL shaders
        // todo: add support for complex constants/expressions like float4(1,2,3,4), complex types etc.
        const args = csh.args.map(arg => ({ type: arg.type.name, value: _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.expression.evalConst(arg) }));
        shaders[key] = { id, shader: { name, ver, args } };
        return id;
    }
    deref(decl) {
        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isDepthStencilState(decl.type)) {
            return this.derefDethStencilState(decl);
        }
        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isBlendState(decl.type)) {
            console.assert(false, 'blend state is not yet supported');
            return this.derefBlendState(decl);
        }
        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isRasterizerState(decl.type)) {
            console.assert(false, 'raserizer state is not yet supported');
            return this.derefRasterizerState(decl);
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unknown pipeline state "${decl.type.name}" found`);
        return -1;
    }
    derefDethStencilState(decl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!decl.type.isNotBaseArray(), 'DSS arrays are not yet unsupported (!)');
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(decl.isGlobal());
        const { name, type, initExpr } = decl;
        const entries = this._knownDepthStencilStates;
        const entryIndex = entries.findIndex(s => s.name === name);
        if (entryIndex !== -1) {
            return entryIndex;
        }
        const state = createDepthStencilState();
        const id = entries.length;
        entries.push({ name, state });
        if (initExpr) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_StateBlockExpr);
            const props = initExpr.props;
            state.DepthEnable = evalPropBool(props, 'DepthEnable', state.DepthEnable);
            state.DepthWriteMask = evalPropEnum(props, 'DepthWriteMask', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EDepthWriteMask, state.DepthWriteMask);
            state.DepthFunc = evalPropEnum(props, 'DepthFunc', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc, state.DepthFunc);
            state.StencilEnable = evalPropBool(props, 'StencilEnable', state.StencilEnable);
            state.StencilReadMask = evalNumber(props, 'StencilReadMask', state.StencilReadMask);
            state.StencilWriteMask = evalNumber(props, 'StencilWriteMask', state.StencilWriteMask);
            state.FrontFace.StencilFailOp = evalPropEnum(props, 'FrontFaceStencilFailOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.FrontFace.StencilFailOp);
            state.FrontFace.StencilDepthFailOp = evalPropEnum(props, 'FrontFaceStencilDepthFailOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.FrontFace.StencilDepthFailOp);
            state.FrontFace.StencilPassOp = evalPropEnum(props, 'FrontFaceStencilPassOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.FrontFace.StencilPassOp);
            state.FrontFace.StencilFunc = evalPropEnum(props, 'FrontFaceStencilFunc', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc, state.FrontFace.StencilFunc);
            state.BackFace.StencilFailOp = evalPropEnum(props, 'BackFaceStencilFailOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.BackFace.StencilFailOp);
            state.BackFace.StencilDepthFailOp = evalPropEnum(props, 'BackFaceStencilDepthFailOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.BackFace.StencilDepthFailOp);
            state.BackFace.StencilPassOp = evalPropEnum(props, 'BackFaceStencilPassOp', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EStencilOp, state.BackFace.StencilPassOp);
            state.BackFace.StencilFunc = evalPropEnum(props, 'BackFaceStencilFunc', _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EComparisonFunc, state.BackFace.StencilFunc);
        }
        return id;
    }
    derefBlendState(decl) {
        return 0;
    }
    derefRasterizerState(decl) {
        return 0;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PipelineStates);


/***/ }),

/***/ "ZrbQ":
/*!************************************************!*\
  !*** ./src/lib/fx/bytecode/PromisedAddress.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "4eqb");
/* harmony import */ var _sizeof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sizeof */ "p8vA");




class PromisedAddress {
    constructor({ type, addr, size = 0, inputIndex = -1, swizzle = null }) {
        this.type = type;
        this.addr = Number(addr);
        this.inputIndex = inputIndex;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!swizzle || !size || swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32() === size, 'size and swizzling are not compatible');
        if (swizzle) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(swizzle.length > 1, 'unary swizzles must be removed in favor of offsetted adress');
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(swizzle.length <= 4, 'only xyzw/rgba swizzles are supported');
            size = swizzle.length * _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32();
        }
        this.size = size;
        this.swizzle = swizzle;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(addr === _common__WEBPACK_IMPORTED_MODULE_2__.REG_INVALID || size > 0, 'invalid address size found');
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(size % _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32() === 0, 'invalid address alignment found');
    }
    get length() {
        return this.size / _sizeof__WEBPACK_IMPORTED_MODULE_3__["default"].i32();
    }
    valueOf() {
        // guard of implicit loading
        if (this.type != _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `address has implicitly moved to ${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers]} from ${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType[this.type]}`);
            return _common__WEBPACK_IMPORTED_MODULE_2__.REG_INVALID;
        }
        return this.addr;
    }
    isPointer() {
        return this.type >= _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters;
    }
    isInput() {
        return this.type == _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Input || this.type == _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerInput;
    }
    toNumber() {
        return this.addr;
    }
    toString() {
        const { type, inputIndex, addr, swizzle, size } = this;
        const isPointer = this.isPointer();
        const isInput = this.isInput();
        return `${_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType[type]} [${isPointer ? '%' : isInput ? '' : 'r'}${addr / 4} ${isInput ? `input(${inputIndex})` : ``}, ${size} bytes, [${(swizzle || []).join(', ')}]]`;
    }
    // non-pointer address type => pointer
    static castToPointer(type) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type < _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters);
        return (type + _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_PointerRegisters);
    }
}
PromisedAddress.INVALID = new PromisedAddress({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Registers, addr: _common__WEBPACK_IMPORTED_MODULE_2__.REG_INVALID, size: 0 });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromisedAddress);


/***/ }),

/***/ "LvtK":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/SRVPool.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SRVPool": () => (/* binding */ SRVPool)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytecode */ "dnVx");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PromisedAddress */ "ZrbQ");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Bytecode__WEBPACK_IMPORTED_MODULE_3__]);
_Bytecode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





class SRVPool {
    constructor() {
        this._knownSRVs = Array(_Bytecode__WEBPACK_IMPORTED_MODULE_3__.SRV_TOTAL).fill(null);
    }
    deref(decl) {
        const knownSRVs = this._knownSRVs;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!decl.type.isNotBaseArray());
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isBuffer(decl.type) || _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isTexture(decl.type));
        let { index, type } = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.resolveRegister(decl);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === 't');
        const knownIndex = knownSRVs.indexOf(decl);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(knownIndex === -1 || knownIndex === index);
        if (index === -1) {
            index = knownSRVs.findIndex(decl => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl));
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index !== -1, `uav limit is reached (uav total: ${_Bytecode__WEBPACK_IMPORTED_MODULE_3__.SRV_TOTAL})`);
            knownSRVs[index] = decl;
        }
        knownSRVs[index] = decl;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index !== -1);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index < _Bytecode__WEBPACK_IMPORTED_MODULE_3__.SRV_TOTAL);
        const inputIndex = _Bytecode__WEBPACK_IMPORTED_MODULE_3__.SRV0_REGISTER + index;
        const addr = 0;
        // NOTE: UAV's size is unknown in advance
        // so we use maximum aligned int as possible
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__["default"]({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Input, addr, size: 1 << 30, inputIndex });
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "+nD5":
/*!********************************************!*\
  !*** ./src/lib/fx/bytecode/SymbolTable.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A simplified symbol table containing the correspondence of unique
 * hashes of symbols and their addresses in registers.
 * The table is global and does not depend on the stack of functions,
 * because hashes are built on the basis of identifiers of instructions
 * unique to each function and context.
 */
class SymbolTable {
    *[Symbol.iterator]() {
        for (let i in this) {
            yield this[i];
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymbolTable);


/***/ }),

/***/ "c1OO":
/*!****************************************!*\
  !*** ./src/lib/fx/bytecode/UAVPool.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UAVPool": () => (/* binding */ UAVPool)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytecode */ "dnVx");
/* harmony import */ var _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PromisedAddress */ "ZrbQ");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Bytecode__WEBPACK_IMPORTED_MODULE_3__]);
_Bytecode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





class UAVPool {
    constructor() {
        this._knownUAVs = Array(_Bytecode__WEBPACK_IMPORTED_MODULE_3__.UAV_TOTAL).fill(null);
    }
    deref(decl) {
        const knownUAVs = this._knownUAVs;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!decl.type.isNotBaseArray());
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isUAV(decl.type));
        let { index, type } = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.resolveRegister(decl);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type === 'u');
        const knownIndex = knownUAVs.indexOf(decl);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(knownIndex === -1 || knownIndex === index);
        if (index === -1) {
            index = knownUAVs.findIndex(decl => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl));
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index !== -1, `uav limit is reached (uav total: ${_Bytecode__WEBPACK_IMPORTED_MODULE_3__.UAV_TOTAL})`);
            knownUAVs[index] = decl;
        }
        knownUAVs[index] = decl;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index !== -1);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(index < _Bytecode__WEBPACK_IMPORTED_MODULE_3__.UAV_TOTAL);
        const inputIndex = _Bytecode__WEBPACK_IMPORTED_MODULE_3__.UAV0_REGISTER + index;
        const addr = 0;
        // NOTE: UAV's size is unknown in advance
        // so we use maximum aligned int as possible
        return new _PromisedAddress__WEBPACK_IMPORTED_MODULE_4__["default"]({ type: _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_1__.EAddrType.k_Input, addr, size: 1 << 30, inputIndex });
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "Xxmt":
/*!**********************************************!*\
  !*** ./src/lib/fx/bytecode/VM/cpp/bridge.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createUAV": () => (/* binding */ createUAV),
/* harmony export */   "debugResetRegisters": () => (/* binding */ debugResetRegisters),
/* harmony export */   "destroyUAV": () => (/* binding */ destroyUAV),
/* harmony export */   "make": () => (/* binding */ make),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory)
/* harmony export */ });
/* harmony import */ var _module_cpp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.cpp */ "xmIN");
///////////////////////////////////
///////////////////////////////////
///////////////////////////////////
function transferU8ToHeap(module, u8Array) {
    const heap = module._malloc(u8Array.length * u8Array.BYTES_PER_ELEMENT);
    const size = u8Array.length >> 2;
    module.HEAPU8.set(u8Array, heap);
    return { heap, size };
}
function freeHeap(module, { heap }) {
    module._free(heap);
}
///////////////////////////////////
///////////////////////////////////
///////////////////////////////////

const BundleModule = await (0,_module_cpp__WEBPACK_IMPORTED_MODULE_0__["default"])();
const WASMBundle = BundleModule?.Bundle;
function make(name, code) {
    let bundleWasm = null;
    let mem = transferU8ToHeap(BundleModule, code);
    try {
        bundleWasm = new BundleModule.Bundle(name, mem);
    }
    catch (e) {
        // console.error(e);
    }
    finally {
        BundleModule._free(mem.heap);
    }
    return bundleWasm;
}
function memoryToU8Array(input) {
    const { heap, size } = input;
    return BundleModule.HEAPU8.subarray(heap, (heap + (size << 2)));
}
function memoryToI32Array(input) {
    const { heap, size } = input;
    console.assert(heap % 4 == 0, "unsupported heap address!");
    return BundleModule.HEAP32.subarray(heap >> 2, ((heap >> 2) + size));
}
function memoryToF32Array(input) {
    const { heap, size } = input;
    console.assert(heap % 4 == 0, "unsupported heap address!");
    return BundleModule.HEAPF32.subarray(heap >> 2, ((heap >> 2) + size));
}
function createUAV(name, elementSize, length, register) {
    return WASMBundle.createUAV(name, elementSize, length, register);
}
function destroyUAV(uav) {
    WASMBundle.destroyUAV(uav);
}
function copyViewToMemory(input) {
    return transferU8ToHeap(BundleModule, new Uint8Array(input.buffer, input.byteOffset, input.byteLength));
}
function releaseMemory(mem) {
    freeHeap(BundleModule, mem);
}
// cleanup shared registers memory
function debugResetRegisters() {
    // unsupported
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "ZLcK":
/*!*****************************************!*\
  !*** ./src/lib/fx/bytecode/VM/index.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asNative": () => (/* reexport safe */ _native__WEBPACK_IMPORTED_MODULE_2__.asNative),
/* harmony export */   "asNativeRaw": () => (/* reexport safe */ _native__WEBPACK_IMPORTED_MODULE_2__.asNativeRaw),
/* harmony export */   "asNativeViaAST": () => (/* reexport safe */ _native__WEBPACK_IMPORTED_MODULE_2__.asNativeViaAST),
/* harmony export */   "asNativeViaCDL": () => (/* reexport safe */ _native__WEBPACK_IMPORTED_MODULE_2__.asNativeViaCDL),
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createUAV": () => (/* binding */ createUAV),
/* harmony export */   "destroyUAV": () => (/* binding */ destroyUAV),
/* harmony export */   "evaluate": () => (/* binding */ evaluate),
/* harmony export */   "isWASM": () => (/* binding */ isWASM),
/* harmony export */   "make": () => (/* binding */ make),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory),
/* harmony export */   "switchRuntime": () => (/* binding */ switchRuntime)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "0jsi");
/* harmony import */ var _native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./native */ "1fdM");
/* harmony import */ var _cpp_bridge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cpp/bridge */ "Xxmt");
/* harmony import */ var _ts_bridge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ts/bridge */ "vVoC");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__, _native__WEBPACK_IMPORTED_MODULE_2__, _cpp_bridge__WEBPACK_IMPORTED_MODULE_3__, _ts_bridge__WEBPACK_IMPORTED_MODULE_4__]);
([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__, _native__WEBPACK_IMPORTED_MODULE_2__, _cpp_bridge__WEBPACK_IMPORTED_MODULE_3__, _ts_bridge__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);






/////////////////////////////////////////////////////////////////////
/// Common API
/////////////////////////////////////////////////////////////////////
/// <reference path="./webpack.d.ts" />
// check shell.js for more details
// electron hack to support option --disable-wasm
const forceNoWasm = () => (new URLSearchParams(window.location.search)).get('disable-wasm') === 'true';
let useWASM =  true && !forceNoWasm();
function VMBundle() {
    return (useWASM ? _cpp_bridge__WEBPACK_IMPORTED_MODULE_3__ : _ts_bridge__WEBPACK_IMPORTED_MODULE_4__);
}
function isWASM() {
    return useWASM;
}
function switchRuntime(runtime) {
    useWASM = (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(runtime) ? runtime === 'wasm' : !useWASM;
    console.log(`%c VM runtime has been switched to "${(useWASM ? "WASM" : "JS")}".`, 'font-weight: bold; background: #6f0000; color: #fff');
}
function make(debugName, code) {
    return VMBundle().make(debugName, new Uint8Array(code));
}
/**
 * Interpret memory as typed array.
 * NOTE: no copying occurs (!)
 * @returns Same data interpreted as typed array.
 */
function memoryToU8Array(input) {
    return VMBundle().memoryToU8Array(input);
}
/**
 * Interpret memory as typed array.
 * NOTE: no copying occurs (!)
 * @returns Same data interpreted as typed array.
 */
function memoryToI32Array(input) {
    return VMBundle().memoryToI32Array(input);
}
/**
 * Interpret memory as typed array.
 * NOTE: no copying occurs (!)
 * @returns Same data interpreted as typed array.
 */
function memoryToF32Array(input) {
    return VMBundle().memoryToF32Array(input);
}
/**
 * NOTE: copy view to NEW memory (!)
 * @returns New array containing input data.
 */
function copyViewToMemory(input) {
    return VMBundle().copyViewToMemory(input);
}
function releaseMemory(mem) {
    VMBundle().releaseMemory(mem);
}
function createUAV(name, elementSize, length, register) {
    return VMBundle().createUAV(name, elementSize, length, register);
}
function destroyUAV(uav) {
    VMBundle().destroyUAV(uav);
}
/////////////////////////////////////////////////////////////////////
function debugResetRegisters() {
    VMBundle().debugResetRegisters();
}
/** @deprecated */
async function evaluate(param, param2) {
    if (true) {
        debugResetRegisters();
    }
    let code;
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(arguments[0])) {
        const expr = arguments[0];
        const slDocument = arguments[1];
        const { program } = await _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__.translateExpression(expr, slDocument);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(program)) {
            return null;
        }
        const { code, cdl } = program;
        const bundle = make("[evaluate]", code);
        return (0,_native__WEBPACK_IMPORTED_MODULE_2__.asNativeViaCDL)(bundle.play(), cdl);
    }
    else {
        code = arguments[0];
    }
    const bundle = make("[evaluate]", code);
    return bundle.play();
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "1fdM":
/*!******************************************!*\
  !*** ./src/lib/fx/bytecode/VM/native.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asNative": () => (/* binding */ asNative),
/* harmony export */   "asNativeFunction": () => (/* binding */ asNativeFunction),
/* harmony export */   "asNativeRaw": () => (/* binding */ asNativeRaw),
/* harmony export */   "asNativeViaAST": () => (/* binding */ asNativeViaAST),
/* harmony export */   "asNativeViaCDL": () => (/* binding */ asNativeViaCDL),
/* harmony export */   "fromNativeRaw": () => (/* binding */ fromNativeRaw),
/* harmony export */   "typeAstToTypeLayout": () => (/* binding */ typeAstToTypeLayout)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "4eqb");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_bundles_auto_type_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bundles/auto/type-layout */ "KUuy");
/* harmony import */ var _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bundles/auto/type-field */ "O/5E");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__]);
_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];






function asNativeVector(elementDecoder, value, length, stride = 4) {
    const vector = [];
    for (let i = 0; i < length; ++i) {
        vector.push(elementDecoder(value.subarray(stride * i, stride * i + stride)));
    }
    return vector;
}
function fromNativeVector(elementDecoder, arr) {
    let byteLength = arr.reduce((s, val) => s + elementDecoder(val).byteLength, 0);
    let u8Array = new Uint8Array(byteLength);
    let offset = 0;
    for (let val of arr) {
        let u8 = elementDecoder(val);
        u8Array.set(u8, offset);
        offset += u8.byteLength;
    }
    return u8Array;
}
const asInt = _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.u8ArrayAsI32;
const asUint = u8a => (asInt(u8a) >>> 0);
const asFloat = _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.u8ArrayAsF32;
const asBool = u8a => asInt(u8a) !== 0;
const fromInt = i32 => new Uint8Array((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.i32ToU8Array)(i32));
const fromUint = u32 => new Uint8Array((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.i32ToU8Array)(u32));
const fromFloat = f32 => new Uint8Array((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.i32ToU8Array)((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.f32Asi32)(f32)));
const fromBool = b32 => new Uint8Array((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.i32ToU8Array)(+(b32)));
function typeLayoutArrayToBaseType({ fields, length, name, size }) {
    return new _lib_idl_bundles_auto_type_layout__WEBPACK_IMPORTED_MODULE_4__.TypeLayoutT(fields, undefined, name, size);
}
function typeAstToTypeLayout(type) {
    const isNotComplexOrSystem = (type) => !type.isComplex() ||
        type.instructionType == _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_SystemType;
    let name = type.name;
    let size = type.size;
    let fields = undefined;
    let length = -1;
    if (type.isNotBaseArray()) {
        length = type.length;
        const elementType = typeAstToTypeLayout(type.arrayElementType);
        fields = elementType.fields;
    }
    else if (!isNotComplexOrSystem(type)) {
        fields = type.fields.map(({ name, type, semantic }) => new _lib_idl_bundles_auto_type_field__WEBPACK_IMPORTED_MODULE_5__.TypeFieldT(typeAstToTypeLayout(type), name, semantic, type.size, type.padding));
    }
    return new _lib_idl_bundles_auto_type_layout__WEBPACK_IMPORTED_MODULE_4__.TypeLayoutT(fields, length, name, size);
}
function fromNativeRaw(data, layout) {
    switch (layout.name) {
        case 'bool':
            return fromBool(data);
        case 'int':
            return fromInt(data);
        case 'float':
            return fromFloat(data);
        case 'uint':
            return fromUint(data);
        case 'uint2':
        case 'uint3':
        case 'uint4':
            return fromNativeVector(fromUint, data);
        case 'int2':
        case 'int3':
        case 'int4':
            return fromNativeVector(fromInt, data);
        case 'float2':
        case 'float3':
        case 'float4':
            return fromNativeVector(fromFloat, data);
    }
    // parse as array
    if (layout.length && layout.length >= 0) {
        const elementType = typeLayoutArrayToBaseType(layout);
        return fromNativeVector(val => fromNativeRaw(val, elementType), data);
    }
    // parse as structure
    if (layout.fields) {
        let byteLength = layout.fields.reduce((s, field) => {
            const { padding, size, type, name } = field;
            return Math.max(s, padding + size);
        }, 0);
        let complex = new Uint8Array(byteLength);
        layout.fields.forEach(field => {
            const { padding, size, type, name } = field;
            const u8 = fromNativeRaw(data[name], type);
            complex.set(u8, padding);
        });
        return complex;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `not implemented`, layout);
    return null;
}
function asNative(result, layout) {
    return asNativeRaw(_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.memoryToU8Array(result), layout);
}
function asNativeRaw(result, layout) {
    switch (layout.name) {
        case 'bool':
            return asBool(result);
        case 'int':
            return asInt(result);
        case 'float':
            return asFloat(result);
        case 'uint':
            return asUint(result);
        case 'uint2':
        case 'uint3':
        case 'uint4':
            return asNativeVector(asUint, result, layout.size / 4, 4);
        case 'int2':
        case 'int3':
        case 'int4':
            return asNativeVector(asInt, result, layout.size / 4, 4);
        case 'float2':
        case 'float3':
        case 'float4':
            return asNativeVector(asFloat, result, layout.size / 4, 4);
    }
    // parse as array
    if (layout.length && layout.length >= 0) {
        const elementType = typeLayoutArrayToBaseType(layout);
        return asNativeVector(u8a => asNativeRaw(u8a, elementType), result, layout.length, elementType.size);
    }
    // parse as structure
    if (layout.fields) {
        let complex = {};
        layout.fields.forEach(field => {
            const { padding, size, type } = field;
            complex[field.name] = asNativeRaw(result.subarray(padding, padding + size), type);
        });
        return complex;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `not implemented`, layout);
    return null;
}
function asNativeViaAST(result, type) {
    return asNativeRaw(result, typeAstToTypeLayout(type));
}
function asNativeViaCDL(result, cdl) {
    return asNativeRaw(result, typeAstToTypeLayout(cdl.info.layout));
}
function asNativeFunction(bcDocument) {
    const { code, cdl } = bcDocument.program;
    const bundle = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.make(`[as-native-function]`, code);
    return (...args) => {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!args || args.length === 0, 'arguments not supported');
        return asNativeViaCDL(bundle.play(), cdl);
    };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "vVoC":
/*!*********************************************!*\
  !*** ./src/lib/fx/bytecode/VM/ts/bridge.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createUAV": () => (/* binding */ createUAV),
/* harmony export */   "debugResetRegisters": () => (/* binding */ debugResetRegisters),
/* harmony export */   "destroyUAV": () => (/* binding */ destroyUAV),
/* harmony export */   "make": () => (/* binding */ make),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bundle */ "8VxU");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__]);
_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

function make(name, code) {
    return new _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.TSBundle(name, code);
}
function memoryToU8Array(input) {
    const buffer = (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
function memoryToF32Array(input) {
    const buffer = (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
    return new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length);
}
function memoryToI32Array(input) {
    return (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
}
function copy(src) {
    const dst = new Uint8Array(src.byteLength);
    dst.set(new Uint8Array(src.buffer, src.byteOffset, src.byteLength));
    return dst;
}
function copyViewToMemory(input) {
    return (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.asBundleMemory)(copy(input));
}
function releaseMemory(mem) {
    // noting todo, memory is just usual typed view
}
function createUAV(name, elementSize, length, register) {
    return _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.TSBundle.createUAV(name, elementSize, length, register);
}
function destroyUAV(uav) {
    // nothing todo
}
// cleanup shared registers memory
function debugResetRegisters() {
    _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.TSBundle.resetRegisters();
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "8VxU":
/*!*********************************************!*\
  !*** ./src/lib/fx/bytecode/VM/ts/bundle.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TSBundle": () => (/* binding */ TSBundle),
/* harmony export */   "asBundleMemory": () => (/* binding */ asBundleMemory),
/* harmony export */   "decodeChunks": () => (/* binding */ decodeChunks),
/* harmony export */   "decodeCodeChunk": () => (/* binding */ decodeCodeChunk),
/* harmony export */   "decodeConstChunk": () => (/* binding */ decodeConstChunk),
/* harmony export */   "decodeDepthStencilStates": () => (/* binding */ decodeDepthStencilStates),
/* harmony export */   "decodeExternsChunk": () => (/* binding */ decodeExternsChunk),
/* harmony export */   "decodeLayoutChunk": () => (/* binding */ decodeLayoutChunk),
/* harmony export */   "decodeShadersChunk": () => (/* binding */ decodeShadersChunk),
/* harmony export */   "fromBundleMemory": () => (/* binding */ fromBundleMemory)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "4eqb");
/* harmony import */ var _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/InstructionList */ "MjXi");
/* harmony import */ var _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/bytecode/sizeof */ "p8vA");
/* harmony import */ var _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/bytecode/VM/native */ "1fdM");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_5__]);
([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);








let { EChunkType, EOperation } = _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_6__;
function asBundleMemory(data) {
    const buffer = data instanceof Int32Array
        ? data
        : new Int32Array(data.buffer, data.byteOffset, data.byteLength >> 2);
    return { buffer };
}
function fromBundleMemory(mem) {
    return mem.buffer;
}
function slotToShaderLikeRegister(slot) {
    if (slot >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER && slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER_TOTAL)
        return `b${slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER}`;
    if (slot >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.SRV0_REGISTER && slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.SRV0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.SRV_TOTAL)
        return `t${slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.SRV0_REGISTER}`;
    if (slot >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.UAV0_REGISTER && slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.UAV0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.UAV_TOTAL)
        return `u${slot - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.UAV0_REGISTER}`;
    return `[ invalid slot | ${slot} ]`;
}
function exposeInvalidInputError(iinput, slot) {
    const reg = slotToShaderLikeRegister(slot);
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(iinput[slot]))
        return `resource usage out of range, register: ${reg}`;
    return `missing resource is found, register: ${reg}`;
}
class TSBundle {
    constructor(debugName, data) {
        this.debugName = debugName;
        this.load(data);
    }
    load(code) {
        const chunks = decodeChunks(code);
        const codeChunk = chunks[EChunkType.k_Code];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(codeChunk) && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(chunks[EChunkType.k_Constants]));
        const constants = decodeConstChunk(chunks[EChunkType.k_Constants]);
        this.instructions = decodeCodeChunk(codeChunk);
        this.layout = decodeLayoutChunk(chunks[EChunkType.k_Layout]);
        this.depthStencilStates = decodeDepthStencilStates(chunks[EChunkType.k_DepthStencilStates]);
        this.shaders = decodeShadersChunk(chunks[EChunkType.k_Shaders]);
        this.externs = decodeExternsChunk(chunks[EChunkType.k_Externs]);
        this.inputs = Array(64).fill(null);
        this.inputs[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER] = new Int32Array(constants.buffer, constants.byteOffset, constants.length >> 2);
        const undefFn = (extern) => (a, b, c, d, e, f) => {
            console.error(`[native call <${extern.name}> was not provided]`, [a, b, c, d, e, f].filter(x => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(x)));
        };
        const traceFn = (a, b, c, d, e, f, g, h, i, j, k) => {
            console.log(...[a, b, c, d, e, f, g, h, i, j, k].filter(x => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(x)));
        };
        this.ncalls = Array(this.externs.length).fill(null).map((fn, id) => (this.externs[id].name === 'trace' ? traceFn : undefFn(this.externs[id])));
    }
    asNative(u8, layout) {
        switch (layout.name) {
            // IP: experimental way to resolve string (useful for debug purposes like trace())
            case 'string': {
                let byteOffset = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(u8);
                let i32a = this.inputs[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER];
                let len = i32a[byteOffset >> 2];
                let u8a = new Uint8Array(i32a.buffer, i32a.byteOffset + byteOffset + 4, len);
                return String.fromCharCode(...u8a);
            }
            case 'DepthStencilState': {
                let id = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(u8);
                return this.depthStencilStates[id];
            }
            case 'VertexShader':
            case 'PixelShader':
            case 'GeometryShader': {
                let id = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(u8);
                if (id == 0) // NULL was passed as shader
                    return null;
                return this.shaders[id - 1];
            }
        }
        return (0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_5__.asNativeRaw)(u8, layout);
    }
    play() {
        const ilist = this.instructions;
        const iregs = TSBundle.iregs;
        const fregs = TSBundle.fregs;
        const regs = TSBundle.regs;
        const iinput = this.inputs;
        let i5 = 0; // current instruction;
        end: while (1) {
            let op = ilist[i5];
            let a = ilist[i5 + 1];
            let b = ilist[i5 + 2];
            let c = ilist[i5 + 3];
            let d = ilist[i5 + 4];
            switch (op) {
                // registers
                case EOperation.k_I32SetConst:
                    // assert(iregs.length > a, `[iregs.length > a] where iregs.length = ${iregs.length}, a = ${a}`);
                    iregs[a] = b;
                    break;
                case EOperation.k_I32LoadRegister:
                    // assert(iregs.length > b, `[iregs.length > b] where iregs.length = ${iregs.length}, b = ${b}`);
                    // assert(iregs.length > a, `[iregs.length > a] where iregs.length = ${iregs.length}, a = ${a}`);
                    iregs[a] = iregs[b];
                    break;
                // inputs
                case EOperation.k_I32LoadInput:
                    // assert(iinput[a], exposeInvalidInputError(iinput, a));
                    // assert(iinput[a].length > c);
                    // assert(iregs.length > b);
                    iregs[b] = iinput[a][c];
                    break;
                case EOperation.k_I32StoreInput:
                    // assert(iinput[a], exposeInvalidInputError(iinput, a));    
                    // assert(iinput[a].length > b);
                    // assert(iregs.length > c);
                    iinput[a][b] = iregs[c];
                    break;
                // registers pointers    
                // a => dest
                // b => source pointer
                // c => offset
                case EOperation.k_I32LoadRegistersPointer:
                    // assert(iregs.length > (iregs[b] + c), `[iregs.length > (iregs[b] + c)] where iregs.length = ${iregs.length}, iregs[b] = ${iregs[b]}, b = ${b}, c = ${c}`);
                    // assert(iregs.length > a);
                    iregs[a] = iregs[iregs[b] + c];
                    break;
                case EOperation.k_I32StoreRegisterPointer:
                    // assert(iregs.length > (iregs[a] + c));
                    // assert(iregs.length > b);
                    iregs[iregs[a] + c] = iregs[b];
                    break;
                // input pointers
                // a => input index
                // b => dest
                // c => source pointer
                // d => offset
                case EOperation.k_I32LoadInputPointer:
                    // assert(iinput[a], exposeInvalidInputError(iinput, a));  
                    // assert(iinput[a].length > (iregs[c] + d));
                    // assert(iregs.length > b);
                    iregs[b] = iinput[a][iregs[c] + d];
                    break;
                case EOperation.k_I32StoreInputPointer:
                    // assert(iinput[a], exposeInvalidInputError(iinput, a));  
                    // assert(iinput[a].length > (iregs[b] + d));
                    // assert(iregs.length > c);
                    iinput[a][iregs[b] + d] = iregs[c];
                    break;
                case EOperation.k_I32TextureLoad:
                    // a - destination  (always float4)
                    // b - texture      (input index)
                    // c - arguments    (int3 uv)
                    {
                        const layout = iinput[b];
                        const u = iregs[c];
                        const v = iregs[c + 1];
                        const w = layout[0];
                        const h = layout[1];
                        // assert(u >= 0 && u < w, `u(${u}) is out of borders [0, ${w})`);
                        // assert(v >= 0 && v < h, `u(${v}) is out of borders [0, ${h})`);
                        // const fmt = layout[2];
                        const texel = layout.subarray(/*desc(64) >> 2*/ 16)[w * v + u] >>> 0; // todo: use unsigned inputs
                        const iR = (texel) & 0xFF;
                        const iG = (texel >> 8) & 0xFF;
                        const iB = (texel >> 16) & 0xFF;
                        const iA = (texel >> 24) & 0xFF;
                        fregs.set([iR / 255.0, iG / 255.0, iB / 255.0, iA / 255.0], a);
                    }
                    break;
                case EOperation.k_I32ExternCall:
                    {
                        const id = a;
                        const { params, ret } = this.externs[id];
                        const retOffset = (b << 2);
                        // todo: support out arguments
                        let paramOffset = retOffset + ret.size;
                        let args = new Array(params.length);
                        for (let i = 0; i < params.length; ++i) {
                            let p = params[i];
                            let u8 = regs.subarray(paramOffset, paramOffset + p.size);
                            args[i] = this.asNative(u8, p);
                            paramOffset += p.size;
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(p.size % 4 === 0);
                        }
                        const res = this.ncalls[a].apply(null, args);
                        if (ret.size) {
                            regs.set((0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_5__.fromNativeRaw)(res, ret), retOffset);
                        }
                    }
                    break;
                //
                // Arithmetic operations
                //
                case EOperation.k_I32Add:
                    iregs[a] = iregs[b] + iregs[c];
                    break;
                case EOperation.k_I32Sub:
                    iregs[a] = iregs[b] - iregs[c];
                    break;
                case EOperation.k_I32Mul:
                    iregs[a] = iregs[b] * iregs[c];
                    break;
                case EOperation.k_I32Div:
                    iregs[a] = iregs[b] / iregs[c];
                    break;
                case EOperation.k_I32Mod:
                    iregs[a] = iregs[b] % iregs[c];
                    break;
                case EOperation.k_I32Mad:
                    iregs[a] = iregs[b] + iregs[c] * iregs[d];
                    break;
                case EOperation.k_I32Min:
                    iregs[a] = Math.min(iregs[b], iregs[c]);
                    break;
                case EOperation.k_I32Max:
                    iregs[a] = Math.max(iregs[b], iregs[c]);
                    break;
                case EOperation.k_F32Add:
                    fregs[a] = fregs[b] + fregs[c];
                    break;
                case EOperation.k_F32Sub:
                    fregs[a] = fregs[b] - fregs[c];
                    break;
                case EOperation.k_F32Mul:
                    fregs[a] = fregs[b] * fregs[c];
                    break;
                case EOperation.k_F32Div:
                    fregs[a] = fregs[b] / fregs[c];
                    break;
                case EOperation.k_F32Mod:
                    fregs[a] = fregs[b] % fregs[c];
                    break;
                //
                // Relational operations
                //
                case EOperation.k_U32LessThan:
                    iregs[a] = +((iregs[b] >>> 0) < (iregs[c] >>> 0));
                    break;
                case EOperation.k_U32GreaterThanEqual:
                    iregs[a] = +((iregs[b] >>> 0) >= (iregs[c] >>> 0));
                    break;
                case EOperation.k_I32LessThan:
                    iregs[a] = +(iregs[b] < iregs[c]);
                    break;
                case EOperation.k_I32GreaterThanEqual:
                    iregs[a] = +(iregs[b] >= iregs[c]);
                    break;
                case EOperation.k_I32Equal:
                    iregs[a] = +(iregs[b] === iregs[c]);
                    break;
                case EOperation.k_I32NotEqual:
                    iregs[a] = +(iregs[b] !== iregs[c]);
                    break;
                case EOperation.k_I32Not:
                    iregs[a] = +(!iregs[b]);
                    break;
                case EOperation.k_F32LessThan:
                    fregs[a] = +(fregs[b] < fregs[c]);
                    break;
                case EOperation.k_F32GreaterThanEqual:
                    fregs[a] = +(fregs[b] >= fregs[c]);
                    break;
                //
                // Logical operations
                //
                case EOperation.k_I32LogicalOr:
                    iregs[a] = +(iregs[b] || iregs[c]);
                    break;
                case EOperation.k_I32LogicalAnd:
                    iregs[a] = +(iregs[b] && iregs[c]);
                    break;
                //
                // intrinsics
                //
                case EOperation.k_F32Frac:
                    // same as frac() in HLSL
                    fregs[a] = fregs[b] - Math.floor(fregs[b]);
                    break;
                case EOperation.k_F32Floor:
                    fregs[a] = Math.floor(fregs[b]);
                    break;
                case EOperation.k_F32Ceil:
                    fregs[a] = Math.ceil(fregs[b]);
                    break;
                case EOperation.k_F32Sin:
                    fregs[a] = Math.sin(fregs[b]);
                    break;
                case EOperation.k_F32Cos:
                    fregs[a] = Math.cos(fregs[b]);
                    break;
                case EOperation.k_F32Abs:
                    fregs[a] = Math.abs(fregs[b]);
                    break;
                case EOperation.k_F32Sqrt:
                    fregs[a] = Math.sqrt(fregs[b]);
                    break;
                case EOperation.k_F32Max:
                    fregs[a] = Math.max(fregs[b], fregs[c]);
                    break;
                case EOperation.k_F32Min:
                    fregs[a] = Math.min(fregs[b], fregs[c]);
                    break;
                case EOperation.k_F32Pow:
                    fregs[a] = Math.pow(fregs[b], fregs[c]);
                    break;
                //
                // Cast
                //
                case EOperation.k_U32ToF32:
                    fregs[a] = iregs[b] >>> 0;
                    break;
                case EOperation.k_I32ToF32:
                    fregs[a] = iregs[b];
                    break;
                case EOperation.k_F32ToU32: // TODO: remove it?
                case EOperation.k_F32ToI32:
                    iregs[a] = Math.trunc(fregs[b]);
                    break;
                //
                // Flow controls
                //
                case EOperation.k_JumpIf:
                    i5 = iregs[a] !== 0
                        ? i5 + _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__["default"].STRIDE /* skip one instruction */
                        : i5; /* do nothing (cause next instruction must always be Jump) */
                    break;
                case EOperation.k_Jump:
                    // TODO: don't use multiplication here
                    i5 = a * _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__["default"].STRIDE;
                    continue;
                case EOperation.k_Ret:
                    {
                        break end;
                    }
                    break;
                default:
                    console.error(`${this.debugName} | unknown operation found: ${op}`);
            }
            i5 += _lib_fx_bytecode_InstructionList__WEBPACK_IMPORTED_MODULE_3__["default"].STRIDE;
        }
        return TSBundle.regs;
    }
    dispatch(numgroups, numthreads) {
        const { x: nGroupX, y: nGroupY, z: nGroupZ } = numgroups;
        const { x: nThreadX, y: nThreadY, z: nThreadZ } = numthreads;
        // TODO: get order from bundle
        const SV_GroupID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.INPUT0_REGISTER + 0;
        const SV_GroupIndex = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.INPUT0_REGISTER + 1;
        const SV_GroupThreadID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.INPUT0_REGISTER + 2;
        const SV_DispatchThreadID = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.INPUT0_REGISTER + 3;
        this.inputs[SV_GroupID] = TSBundle.Gid;
        this.inputs[SV_GroupIndex] = TSBundle.Gi;
        this.inputs[SV_GroupThreadID] = TSBundle.GTid;
        this.inputs[SV_DispatchThreadID] = TSBundle.DTid;
        for (let iGroupZ = 0; iGroupZ < nGroupZ; ++iGroupZ) {
            for (let iGroupY = 0; iGroupY < nGroupY; ++iGroupY) {
                for (let iGroupX = 0; iGroupX < nGroupX; ++iGroupX) {
                    TSBundle.Gid[0] = iGroupX;
                    TSBundle.Gid[1] = iGroupY;
                    TSBundle.Gid[2] = iGroupZ;
                    for (let iThreadZ = 0; iThreadZ < nThreadZ; ++iThreadZ) {
                        for (let iThreadY = 0; iThreadY < nThreadY; ++iThreadY) {
                            for (let iThreadX = 0; iThreadX < nThreadX; ++iThreadX) {
                                TSBundle.GTid[0] = iThreadX;
                                TSBundle.GTid[1] = iThreadY;
                                TSBundle.GTid[2] = iThreadZ;
                                TSBundle.DTid[0] = iGroupX * nThreadX + iThreadX;
                                TSBundle.DTid[1] = iGroupY * nThreadY + iThreadY;
                                TSBundle.DTid[2] = iGroupZ * nThreadZ + iThreadZ;
                                TSBundle.Gi[0] = iThreadZ * nThreadX * nThreadY + iThreadY * nThreadX + iThreadX;
                                this.play();
                            }
                        }
                    }
                }
            }
        }
    }
    setInput(slot, input) {
        this.inputs[slot] = input.buffer;
    }
    getInput(slot) {
        return asBundleMemory(this.inputs[slot]);
    }
    setConstant(name, value) {
        const layout = this.layout;
        const reflection = layout.find(entry => entry.name === name);
        const constants = this.inputs[_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.CBUFFER0_REGISTER];
        if (!reflection) {
            return false;
        }
        const dst = new DataView(constants.buffer, constants.byteOffset + reflection.offset);
        const src = new DataView(value.buffer, value.byteOffset);
        // TODO: validate layout / constant type in memory / size
        switch (reflection.type) {
            case 'float':
                dst.setFloat32(0, src.getFloat32(0, true), true);
                break;
            case 'int':
                dst.setInt32(0, src.getInt32(0, true), true);
                break;
            case 'uint':
                dst.setUint32(0, src.getUint32(0, true), true);
                break;
            case 'float2':
                dst.setFloat32(0, src.getFloat32(0, true), true);
                dst.setFloat32(4, src.getFloat32(4, true), true);
                break;
            case 'float3':
                dst.setFloat32(0, src.getFloat32(0, true), true);
                dst.setFloat32(4, src.getFloat32(4, true), true);
                dst.setFloat32(8, src.getFloat32(8, true), true);
                break;
            case 'float4':
                dst.setFloat32(0, src.getFloat32(0, true), true);
                dst.setFloat32(4, src.getFloat32(4, true), true);
                dst.setFloat32(8, src.getFloat32(8, true), true);
                dst.setFloat32(12, src.getFloat32(12, true), true);
                break;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported');
        }
        return true;
    }
    getLayout() {
        return this.layout;
    }
    getExterns() {
        return this.externs;
    }
    setExtern(id, extern) {
        this.ncalls[id] = extern;
    }
    static resetRegisters() {
        TSBundle.regs.fill(0);
    }
    static createUAV(name, elementSize, length, register) {
        const counterSize = _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"].i32();
        const size = counterSize + length * elementSize; // in bytes
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(size % _lib_fx_bytecode_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"].i32() === 0);
        const index = _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_1__.UAV0_REGISTER + register;
        const memory = asBundleMemory(new Int32Array(size >> 2));
        const data = asBundleMemory(memory.buffer.subarray(counterSize >> 2));
        const counter = memory.buffer.subarray(0, 1);
        counter[0] = 0; // reset counter
        return {
            name,
            // byte length of a single element
            elementSize,
            // number of elements
            length,
            // register specified in the shader
            register,
            // [ elements ]
            data,
            // raw data [ counter, ...elements ]
            buffer: memory,
            // input index for VM
            index
        };
    }
}
TSBundle.$regs = new ArrayBuffer(512 * 16);
TSBundle.iregs = new Int32Array(TSBundle.$regs);
TSBundle.fregs = new Float32Array(TSBundle.$regs);
TSBundle.regs = new Uint8Array(TSBundle.$regs);
TSBundle.Gid = new Int32Array([0, 0, 0]); // uint3 Gid: SV_GroupID    
TSBundle.Gi = new Int32Array([0]); // uint GI: SV_GroupIndex
TSBundle.GTid = new Int32Array([0, 0, 0]); // uint3 GTid: SV_GroupThreadID
TSBundle.DTid = new Int32Array([0, 0, 0]); // uint3 DTid: SV_DispatchThreadID
function decodeChunks(code, chunks) {
    if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(chunks)) {
        chunks = {};
    }
    const view = new DataView(code.buffer, code.byteOffset, code.byteLength);
    const type = view.getUint32(0, true);
    const byteLength = view.getUint32(4, true) << 2;
    let content = null;
    try {
        content = new Uint8Array(code.buffer, code.byteOffset + 8, byteLength);
    }
    catch (e) {
        console.log(e);
    }
    chunks[type] = content;
    const nextChunkOffset = content.byteOffset + content.byteLength;
    if (nextChunkOffset < code.buffer.byteLength) {
        decodeChunks(new Uint8Array(content.buffer, nextChunkOffset), chunks);
    }
    return chunks;
}
function decodeCodeChunk(codeChunk) {
    return new Uint32Array(codeChunk.buffer, codeChunk.byteOffset, codeChunk.byteLength >> 2);
}
function decodeConstChunk(constChunk) {
    return constChunk;
}
// TODO: rewrite with cleaner code
function decodeLayoutChunk(layoutChunk) {
    let readed = 0;
    let count = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
    readed += 4;
    let layout = [];
    for (let i = 0; i < count; ++i) {
        const nameLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const name = String.fromCharCode(...layoutChunk.subarray(readed, readed + nameLength));
        readed += nameLength;
        const typeLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const type = String.fromCharCode(...layoutChunk.subarray(readed, readed + typeLength));
        readed += typeLength;
        const semanticLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const semantic = String.fromCharCode(...layoutChunk.subarray(readed, readed + semanticLength));
        readed += semanticLength;
        const offset = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        const size = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(layoutChunk.subarray(readed, readed + 4));
        readed += 4;
        layout.push({ name, type, offset, size, semantic });
    }
    return layout;
}
function decodeShadersChunk(shadersChunk) {
    if (!shadersChunk) {
        return null;
    }
    let readed = 0;
    let shadersCount = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
    readed += 4;
    let shaders = [];
    for (let i = 0; i < shadersCount; ++i) {
        const nameLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
        readed += 4;
        const name = String.fromCharCode(...shadersChunk.subarray(readed, readed + nameLength));
        readed += nameLength;
        const verLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
        readed += 4;
        const ver = String.fromCharCode(...shadersChunk.subarray(readed, readed + verLength));
        readed += verLength;
        const argsCount = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
        readed += 4;
        const args = [];
        for (let j = 0; j < argsCount; ++j) {
            const typeLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
            readed += 4;
            const type = String.fromCharCode(...shadersChunk.subarray(readed, readed + typeLength));
            readed += typeLength;
            let value;
            switch (type) {
                case 'int':
                case 'uint':
                    value = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
                    readed += 4;
                    break;
                case 'bool':
                    value = !!(0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(shadersChunk.subarray(readed, readed + 4));
                    readed += 4;
                    break;
                default:
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported constant type "${type}"`);
            }
            args.push({ type, value });
        }
        shaders.push({ name, ver, args });
    }
    return shaders;
}
function decodeDepthStencilStates(dssChunk) {
    if (!dssChunk) {
        return null;
    }
    let readed = 0;
    let shadersCount = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
    readed += 4;
    let states = [];
    for (let i = 0; i < shadersCount; ++i) {
        const DepthEnable = !!(0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const DepthWriteMask = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const DepthFunc = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const StencilEnable = !!(0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const StencilReadMask = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const StencilWriteMask = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const FrontFaceStencilFailOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const FrontFaceStencilDepthFailOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const FrontFaceStencilPassOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const FrontFaceStencilFunc = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const BackFaceStencilFailOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const BackFaceStencilDepthFailOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const BackFaceStencilPassOp = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        const BackFaceStencilFunc = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(dssChunk.subarray(readed, readed + 4));
        readed += 4;
        states.push({
            DepthEnable,
            DepthWriteMask,
            DepthFunc,
            StencilEnable,
            StencilReadMask,
            StencilWriteMask,
            FrontFace: {
                StencilFailOp: FrontFaceStencilFailOp,
                StencilDepthFailOp: FrontFaceStencilDepthFailOp,
                StencilPassOp: FrontFaceStencilPassOp,
                StencilFunc: FrontFaceStencilFunc
            },
            BackFace: {
                StencilFailOp: BackFaceStencilFailOp,
                StencilDepthFailOp: BackFaceStencilDepthFailOp,
                StencilPassOp: BackFaceStencilPassOp,
                StencilFunc: BackFaceStencilFunc
            },
        });
    }
    return states;
}
function decodeTypeField(data, field) {
    let readed = 0;
    field.padding = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    field.size = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    const semanticLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    field.semantic = String.fromCharCode(...data.subarray(readed, readed + semanticLength));
    readed += semanticLength;
    const nameLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    field.name = String.fromCharCode(...data.subarray(readed, readed + nameLength));
    readed += nameLength;
    let type = {};
    readed += decodeTypeLayout(data.subarray(readed), type);
    field.type = type;
    return readed;
}
function decodeTypeLayout(data, layout) {
    let readed = 0;
    layout.size = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    layout.length = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    const nameLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    layout.name = String.fromCharCode(...data.subarray(readed, readed + nameLength));
    readed += nameLength;
    let count = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(data.subarray(readed, readed + 4));
    readed += 4;
    for (let i = 0; i < count; ++i) {
        let fiedl = {};
        readed += decodeTypeField(data.subarray(readed), fiedl);
        layout.fields ||= [];
        layout.fields.push(fiedl);
    }
    return readed;
}
function decodeExternsChunk(externsChunk) {
    let readed = 0;
    let externCount = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(externsChunk.subarray(readed, readed + 4));
    readed += 4;
    let externs = [];
    for (let i = 0; i < externCount; ++i) {
        const id = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(externsChunk.subarray(readed, readed + 4));
        readed += 4;
        const nameLength = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(externsChunk.subarray(readed, readed + 4));
        readed += 4;
        const name = String.fromCharCode(...externsChunk.subarray(readed, readed + nameLength));
        readed += nameLength;
        const ret = {}; // hack
        readed += decodeTypeLayout(externsChunk.subarray(readed), ret);
        let paramCount = (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_2__.u8ArrayToI32)(externsChunk.subarray(readed, readed + 4));
        readed += 4;
        const params = [];
        for (let j = 0; j < paramCount; ++j) {
            const param = {}; // hack
            readed += decodeTypeLayout(externsChunk.subarray(readed), param);
            params.push(param);
        }
        externs.push({ id, name, ret, params });
    }
    return externs;
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "4eqb":
/*!***************************************!*\
  !*** ./src/lib/fx/bytecode/common.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_ENTRY_POINT_NAME": () => (/* binding */ DEFAULT_ENTRY_POINT_NAME),
/* harmony export */   "REG_INVALID": () => (/* binding */ REG_INVALID),
/* harmony export */   "f32Asi32": () => (/* binding */ f32Asi32),
/* harmony export */   "i32Asf32": () => (/* binding */ i32Asf32),
/* harmony export */   "i32Asu32": () => (/* binding */ i32Asu32),
/* harmony export */   "i32ToU8Array": () => (/* binding */ i32ToU8Array),
/* harmony export */   "sname": () => (/* binding */ sname),
/* harmony export */   "u32Asf32": () => (/* binding */ u32Asf32),
/* harmony export */   "u32Asi32": () => (/* binding */ u32Asi32),
/* harmony export */   "u8ArrayAsF32": () => (/* binding */ u8ArrayAsF32),
/* harmony export */   "u8ArrayAsI32": () => (/* binding */ u8ArrayAsI32),
/* harmony export */   "u8ArrayToI32": () => (/* binding */ u8ArrayToI32)
/* harmony export */ });
const REG_INVALID = (-1 >>> 0);
const DEFAULT_ENTRY_POINT_NAME = 'main';
// symbol name id generation;
const sname = {
    i32: (i32) => `%i32:${i32}`,
    f32: (f32) => `%f32:${f32}`,
    var: (vdecl) => `${vdecl.name}:${vdecl.instructionID}`,
    fun: (fdecl) => `${fdecl.name}:${fdecl.instructionID}`,
    // addr: (addr: number) => sname.i32(addr)
};
// aux functions for packing routines
const i32ToU8Array = (i32) => Array(4).fill(0).map((u8, i, self) => (i32 >> (i) * 8) & (0xff));
const u8ArrayToI32 = (arr) => arr.reduce((acc, cv, i, self) => acc | (cv << (i) * 8), 0);
// Uint8Array => Int32Array conversion
const u8ArrayAsI32 = (arr) => ((arr[0]) | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24));
const u8ArrayAsF32 = (arr) => new Float32Array(arr.buffer, arr.byteOffset)[0];
const ab = new ArrayBuffer(4);
const f32a = new Float32Array(ab);
const i32a = new Int32Array(ab);
const u32a = new Uint32Array(ab);
function f32Asi32(f32) {
    f32a[0] = f32;
    return i32a[0];
}
function i32Asf32(i32) {
    i32a[0] = i32;
    return f32a[0];
}
function u32Asf32(u32) {
    u32a[0] = u32;
    return f32a[0];
}
function i32Asu32(i32) {
    i32a[0] = i32;
    return u32a[0];
}
function u32Asi32(u32) {
    u32a[0] = u32;
    return i32a[0];
}


/***/ }),

/***/ "0jsi":
/*!**************************************!*\
  !*** ./src/lib/fx/bytecode/index.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_ENTRY_POINT_NAME": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ENTRY_POINT_NAME),
/* harmony export */   "REG_INVALID": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.REG_INVALID),
/* harmony export */   "cdlview": () => (/* reexport safe */ _DebugLayout__WEBPACK_IMPORTED_MODULE_2__.cdlview),
/* harmony export */   "translate": () => (/* reexport safe */ _Bytecode__WEBPACK_IMPORTED_MODULE_0__.translate),
/* harmony export */   "translateExpression": () => (/* reexport safe */ _Bytecode__WEBPACK_IMPORTED_MODULE_0__.translateExpression)
/* harmony export */ });
/* harmony import */ var _Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytecode */ "dnVx");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "4eqb");
/* harmony import */ var _DebugLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DebugLayout */ "prdm");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Bytecode__WEBPACK_IMPORTED_MODULE_0__]);
_Bytecode__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "p8vA":
/*!***************************************!*\
  !*** ./src/lib/fx/bytecode/sizeof.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const sizeof = {
    u32: () => 4,
    i32: () => 4,
    f32: () => 4,
    bool: () => sizeof.i32(),
    addr: () => sizeof.i32()
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sizeof);


/***/ }),

/***/ "k9Bk":
/*!*********************************************!*\
  !*** ./src/lib/fx/techniques/cpp/bridge.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTechnique": () => (/* binding */ copyTechnique),
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createTechnique": () => (/* binding */ createTechnique),
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "createTrimesh": () => (/* binding */ createTrimesh),
/* harmony export */   "destroyTechnique": () => (/* binding */ destroyTechnique),
/* harmony export */   "destroyTexture": () => (/* binding */ destroyTexture),
/* harmony export */   "destroyTrimesh": () => (/* binding */ destroyTrimesh),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory)
/* harmony export */ });
/* harmony import */ var _module_cpp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.cpp */ "3fZ9");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-content */ "RA5N");




const Module = await (0,_module_cpp__WEBPACK_IMPORTED_MODULE_0__["default"])();
const isEmitter = tech => tech?.getType() === 'emitter';
const isMat = tech => tech?.getType() === 'material';
/**
 * Allocate new heap memory. (!)
 */
function transferU8ToHeap(module, view) {
    const u8Array = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
    const heap = module._malloc(u8Array.length * u8Array.BYTES_PER_ELEMENT);
    const size = u8Array.length >> 2;
    module.HEAPU8.set(u8Array, heap);
    return { heap, size };
}
function freeHeap(module, { heap }) {
    module._free(heap);
}
function createFromBundle(content) {
    let pipelineWasm = null;
    let mem = transferU8ToHeap(Module, content);
    try {
        pipelineWasm = Module.createFromBundle(mem);
    }
    finally {
        Module._free(mem.heap);
    }
    return pipelineWasm;
}
function destroyTechnique(tech) {
    if (isEmitter(tech)) {
        Module.destroyEmitter(tech);
    }
}
function decodeBundleData(data) {
    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts
    if (data instanceof Uint8Array) {
        let fx = new _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_2__.BundleT();
        let buf = new flatbuffers__WEBPACK_IMPORTED_MODULE_1__.ByteBuffer(data);
        _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_2__.Bundle.getRootAsBundle(buf).unpackTo(fx);
        return fx;
    }
    return data;
}
function decodeBundleType(data) {
    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts
    if (data instanceof Uint8Array) {
        let buf = new flatbuffers__WEBPACK_IMPORTED_MODULE_1__.ByteBuffer(data);
        return _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_2__.Bundle.getRootAsBundle(buf).contentType();
    }
    return data.contentType;
}
function createTechnique(data) {
    console.assert(data instanceof Uint8Array, "only packed bundle are supported");
    const type = decodeBundleType(data);
    if (type === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_3__.BundleContent.PartBundle) {
        // ! cpp module supports only particles bundles for now !
        const tech = createFromBundle(data);
        tech.reset();
        return tech;
    }
    // fixme: remove dummy code
    return { getName() { return decodeBundleData(data).name; }, getType() { return 'material'; }, getPassCount() { return 0; }, getPass(i) { return null; }, };
}
function copyTechnique(dst, src) {
    if (isEmitter(dst) && isEmitter(src)) {
        return Module.copyEmitter(dst, src);
    }
    return false;
}
function createTexture(desc, initData) {
    let textureWasm = null;
    let mem = transferU8ToHeap(Module, initData);
    try {
        textureWasm = Module.createTexture(desc, mem);
    }
    finally {
        Module._free(mem.heap);
    }
    return textureWasm;
}
function destroyTexture(texture) {
    if (texture) {
        try {
            Module.destroyTexture(texture);
        }
        finally { }
        ;
    }
}
function createTrimesh(desc, vertices, faces, indicesAdj, facesAdj) {
    let trimeshWasm = null;
    let vertMem = transferU8ToHeap(Module, vertices);
    let faceMem = transferU8ToHeap(Module, faces);
    let indMem = transferU8ToHeap(Module, indicesAdj);
    let adjMem = transferU8ToHeap(Module, facesAdj);
    try {
        trimeshWasm = Module.createTrimesh(desc, vertMem, faceMem, indMem, adjMem);
    }
    finally {
        Module._free(vertMem.heap);
        Module._free(faceMem.heap);
        Module._free(indMem.heap);
    }
    return trimeshWasm;
}
function destroyTrimesh(mesh) {
    if (mesh) {
        try {
            Module.destroyTrimesh(mesh);
        }
        finally { }
        ;
    }
}
//
//
//
function memoryToU8Array(input) {
    const { heap, size } = input;
    return Module.HEAPU8.subarray(heap, (heap + (size << 2)));
}
function memoryToI32Array(input) {
    const { heap, size } = input;
    console.assert(heap % 4 == 0, "unsupported heap address!");
    return Module.HEAP32.subarray(heap >> 2, ((heap >> 2) + size));
}
function memoryToF32Array(input) {
    const { heap, size } = input;
    console.assert(heap % 4 == 0, "unsupported heap address!");
    return Module.HEAPF32.subarray(heap >> 2, ((heap >> 2) + size));
}
/**
 * NOTE: copy view to NEW memory (!)
 * @returns New array containing input data.
 */
function copyViewToMemory(input) {
    return transferU8ToHeap(Module, new Uint8Array(input.buffer, input.byteOffset, input.byteLength));
}
function releaseMemory(mem) {
    freeHeap(Module, mem);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "LvoO":
/*!****************************************!*\
  !*** ./src/lib/fx/techniques/index.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTechnique": () => (/* binding */ copyTechnique),
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createTechnique": () => (/* binding */ createTechnique),
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "createTrimesh": () => (/* binding */ createTrimesh),
/* harmony export */   "destroyTechnique": () => (/* binding */ destroyTechnique),
/* harmony export */   "destroyTexture": () => (/* binding */ destroyTexture),
/* harmony export */   "destroyTrimesh": () => (/* binding */ destroyTrimesh),
/* harmony export */   "isWASM": () => (/* binding */ isWASM),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory),
/* harmony export */   "switchRuntime": () => (/* binding */ switchRuntime)
/* harmony export */ });
/* harmony import */ var _cpp_bridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cpp/bridge */ "k9Bk");
/* harmony import */ var _ts_bridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ts/bridge */ "vZ19");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-content */ "RA5N");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_cpp_bridge__WEBPACK_IMPORTED_MODULE_0__, _ts_bridge__WEBPACK_IMPORTED_MODULE_1__]);
([_cpp_bridge__WEBPACK_IMPORTED_MODULE_0__, _ts_bridge__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



/// <reference path="./webpack.d.ts" />
// check shell.js for more details
// electron hack to support option --disable-wasm
const forceNoWasm = () => (new URLSearchParams(window.location.search)).get('disable-wasm') === 'true';
let useWASM =  true && !forceNoWasm();
function Pipe() {
    return useWASM ? _cpp_bridge__WEBPACK_IMPORTED_MODULE_0__ : _ts_bridge__WEBPACK_IMPORTED_MODULE_1__;
}
function isWASM() {
    return useWASM;
}
function switchRuntime(runtime) {
    useWASM = (0,_lib_common__WEBPACK_IMPORTED_MODULE_2__.isDef)(runtime) ? runtime === 'wasm' : !useWASM;
    console.log(`%c Technique runtime has been switched to "${(useWASM ? "WASM" : "JS")}".`, 'font-weight: bold; background: #6f0000; color: #fff');
}
// hack



function HACK_GetBundleType(data) {
    if (data instanceof Uint8Array) {
        let buf = new flatbuffers__WEBPACK_IMPORTED_MODULE_3__.ByteBuffer(data);
        return _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_4__.Bundle.getRootAsBundle(buf).contentType();
    }
    return data.contentType;
}
// end of hack
function createTechnique(data) {
    // hack:
    // cpp module doesn't support material/technique11 bundles
    // so redirect them to TS only solution
    if (isWASM()) {
        if (HACK_GetBundleType(data) === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_5__.BundleContent.MatBundle || HACK_GetBundleType(data) === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_5__.BundleContent.Technique11Bundle) {
            console.warn(`${_lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_5__.BundleContent[HACK_GetBundleType(data)]} bundle was created using TS module while WASM is on.`);
            return _ts_bridge__WEBPACK_IMPORTED_MODULE_1__.createTechnique(data);
        }
    }
    // end of hack
    return Pipe().createTechnique(data);
}
function destroyTechnique(tech) {
    Pipe().destroyTechnique(tech);
}
function copyTechnique(dst, src) {
    return Pipe().copyTechnique(dst, src);
}
function createTexture(desc, initData) {
    return Pipe().createTexture(desc, initData);
}
function destroyTexture(texture) {
    Pipe().destroyTexture(texture);
}
function createTrimesh(desc, vertices, faces, indicesAdj, facesAdj) {
    return Pipe().createTrimesh(desc, vertices, faces, indicesAdj, facesAdj);
}
function destroyTrimesh(mesh) {
    Pipe().destroyTrimesh(mesh);
}
//
//
//
function memoryToU8Array(input) {
    return Pipe().memoryToU8Array(input);
}
function memoryToI32Array(input) {
    return Pipe().memoryToI32Array(input);
}
function memoryToF32Array(input) {
    return Pipe().memoryToF32Array(input);
}
/**
 * NOTE: copy view to NEW memory if WASM bundle is used (!)
 * @returns New array containing input data.
 */
function copyViewToMemory(input) {
    return Pipe().copyViewToMemory(input);
}
function releaseMemory(mem) {
    Pipe().releaseMemory(mem);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "vZ19":
/*!********************************************!*\
  !*** ./src/lib/fx/techniques/ts/bridge.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTechnique": () => (/* binding */ copyTechnique),
/* harmony export */   "copyViewToMemory": () => (/* binding */ copyViewToMemory),
/* harmony export */   "createTechnique": () => (/* binding */ createTechnique),
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "createTrimesh": () => (/* binding */ createTrimesh),
/* harmony export */   "destroyTechnique": () => (/* binding */ destroyTechnique),
/* harmony export */   "destroyTexture": () => (/* binding */ destroyTexture),
/* harmony export */   "destroyTrimesh": () => (/* binding */ destroyTrimesh),
/* harmony export */   "memoryToF32Array": () => (/* binding */ memoryToF32Array),
/* harmony export */   "memoryToI32Array": () => (/* binding */ memoryToI32Array),
/* harmony export */   "memoryToU8Array": () => (/* binding */ memoryToU8Array),
/* harmony export */   "releaseMemory": () => (/* binding */ releaseMemory)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bundle */ "8VxU");
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emitter */ "dua5");
/* harmony import */ var _mat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat */ "eYFc");
/* harmony import */ var _technique11__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./technique11 */ "moL5");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle */ "AVkT");
/* harmony import */ var _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/bundle-content */ "RA5N");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__, _emitter__WEBPACK_IMPORTED_MODULE_2__, _technique11__WEBPACK_IMPORTED_MODULE_4__]);
([_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__, _emitter__WEBPACK_IMPORTED_MODULE_2__, _technique11__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);








function decodeBundleData(data) {
    // load from packed version, see PACKED in @lib/fx/bundles/Bundle.ts
    if (data instanceof Uint8Array) {
        let fx = new _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_6__.BundleT();
        let buf = new flatbuffers__WEBPACK_IMPORTED_MODULE_1__.ByteBuffer(data);
        _lib_idl_bundles_auto_fx_bundle__WEBPACK_IMPORTED_MODULE_6__.Bundle.getRootAsBundle(buf).unpackTo(fx);
        return fx;
    }
    return data;
}
function createTexture(desc, initData) {
    return (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.createTsTexture)(desc, initData);
}
function destroyTexture(texture) {
    (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.destroyTsTexture)(texture);
}
function createTrimesh(desc, vertices, faces, indicesAdj, facesAdj) {
    return (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.createTsTrimesh)(desc, vertices, faces, indicesAdj, facesAdj);
}
function destroyTrimesh(mesh) {
    (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.destroyTsTrimesh)(mesh);
}
//
//
//
function createTechnique(data) {
    const bundle = decodeBundleData(data);
    if (bundle.contentType === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_7__.BundleContent.PartBundle) {
        const emitter = (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.createTsEmitter)(bundle);
        emitter.reset();
        return emitter;
    }
    if (bundle.contentType === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_7__.BundleContent.MatBundle) {
        return (0,_mat__WEBPACK_IMPORTED_MODULE_3__.createTsMaterial)(bundle);
    }
    if (bundle.contentType === _lib_idl_bundles_auto_fx_bundle_content__WEBPACK_IMPORTED_MODULE_7__.BundleContent.Technique11Bundle) {
        return (0,_technique11__WEBPACK_IMPORTED_MODULE_4__.createTsTechnique11)(bundle);
    }
    return null;
}
function destroyTechnique(tech) {
    switch (tech?.getType()) {
        case 'emitter': return (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.destroyTsEmitter)(tech); // partFx
        case 'material': return (0,_mat__WEBPACK_IMPORTED_MODULE_3__.destroyTsMaterial)(tech); // basically it's technique9
        case 'technique11': return (0,_technique11__WEBPACK_IMPORTED_MODULE_4__.destroyTsTechnique11)(tech);
    }
}
function copyTechnique(dst, src) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_5__.assert)(dst.getType() === src.getType());
    switch (dst.getType()) {
        case 'emitter': return (0,_emitter__WEBPACK_IMPORTED_MODULE_2__.copyTsEmitter)(dst, src); // partFx
        case 'material': return (0,_mat__WEBPACK_IMPORTED_MODULE_3__.copyTsMaterial)(dst, src); // basically it's technique9
        case 'technique11': return (0,_technique11__WEBPACK_IMPORTED_MODULE_4__.copyTsTechnique11)(dst, src);
    }
    console.assert(false);
    return false;
}
//
//
//
function memoryToU8Array(input) {
    const buffer = (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
function memoryToF32Array(input) {
    const buffer = (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
    return new Float32Array(buffer.buffer, buffer.byteOffset, buffer.length);
}
function memoryToI32Array(input) {
    return (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.fromBundleMemory)(input);
}
function copy(src) {
    const dst = new Uint8Array(src.byteLength);
    dst.set(new Uint8Array(src.buffer, src.byteOffset, src.byteLength));
    return dst;
}
function copyViewToMemory(input) {
    return (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_0__.asBundleMemory)(copy(input));
}
function releaseMemory(mem) {
    console.error('NOT IMPLEMENTED!!!');
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "dua5":
/*!*********************************************!*\
  !*** ./src/lib/fx/techniques/ts/emitter.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTsEmitter": () => (/* binding */ copyTsEmitter),
/* harmony export */   "createTsEmitter": () => (/* binding */ createTsEmitter),
/* harmony export */   "createTsTexture": () => (/* binding */ createTsTexture),
/* harmony export */   "createTsTrimesh": () => (/* binding */ createTsTrimesh),
/* harmony export */   "destroyTsEmitter": () => (/* binding */ destroyTsEmitter),
/* harmony export */   "destroyTsTexture": () => (/* binding */ destroyTsTexture),
/* harmony export */   "destroyTsTrimesh": () => (/* binding */ destroyTsTrimesh)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bundle */ "8VxU");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/ITechnique9 */ "UHT2");
/* harmony import */ var _lib_idl_bundles_auto_fx_uavbundle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/uavbundle */ "r1qu");
/* harmony import */ var _lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/epart-sim-routines */ "2IwD");
/* harmony import */ var _lib_idl_bundles_auto_fx_epart_render_routines__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/epart-render-routines */ "wC6P");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-source-bundle */ "KEtj");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_4__]);
([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);










function createUAVEx(bundle, capacity) {
    const uav = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.createUAV(bundle.name, bundle.stride, capacity, bundle.slot);
    // console.log(`UAV '${uav.name}' (counter value: ${UAV.readCounter(uav)}, size: ${uav.length}) has been created.`);
    return uav;
}
// tslint:disable-next-line:max-line-length
// !attention! updtae shared list if needed
function createUAVsEx(bundles, capacity, sharedUAVs = []) {
    return bundles.map(uavBundle => {
        const sharedUAV = sharedUAVs.find(uav => uav.name === uavBundle.name);
        if (sharedUAV)
            return sharedUAV;
        const uav = createUAVEx(uavBundle, capacity);
        sharedUAVs.push(uav);
        return uav;
    });
}
const CTEMP_U8 = new Uint8Array(8);
const CTEMP_DV = new DataView(CTEMP_U8.buffer);
function createParticleDebugViewer(layout, capacity, uavDeadIndices, uavStates, uavParticles) {
    const dataU8 = new Uint8Array(layout.size * capacity);
    const dataIds = new Array(capacity);
    function dump() {
        const npart = getParticleCount();
        // verbose(`particles total: ${npart} ( ${UAV.readCounter(uavDeadIndices)}/${capacity} )`);
        const uavStatesI32 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uavStates.data);
        const uavParticlesU8 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(uavParticles.data);
        let iCopy = 0;
        uavStatesI32.forEach((alive, iPart) => {
            if (alive) {
                const src = new Uint8Array(uavParticlesU8.buffer, uavParticlesU8.byteOffset + iPart * layout.size, layout.size);
                const dst = new Uint8Array(dataU8.buffer, dataU8.byteOffset + iCopy * layout.size, layout.size);
                dst.set(src);
                dataIds[iCopy] = iPart;
                iCopy++;
            }
        });
    }
    const getParticleCount = () => capacity - UAV.readCounter(uavDeadIndices);
    const isDumpReady = () => true;
    // const getLayout = () => layout;
    function readParticleJSON(iPart) {
        const src = new Uint8Array(dataU8.buffer, dataU8.byteOffset + iPart * layout.size, layout.size);
        return _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.asNativeRaw(src, layout);
    }
    function readParticlesJSON() {
        let dst = [];
        for (let i = 0; i < getParticleCount(); ++i) {
            dst.push({ ...readParticleJSON(i), [`#id`]: dataIds[i] });
        }
        return dst;
    }
    return {
        dump,
        isDumpReady,
        getParticleCount,
        readParticleJSON,
        readParticlesJSON
    };
}
function setupFxRoutineBytecodeBundle(debugName, routineBundle, capacity, sharedUAVs) {
    const codeLength = routineBundle.code.length;
    if (codeLength == 0) {
        // it's dummy bundle
        return null;
    }
    const vmBundle = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.make(debugName, routineBundle.code);
    const uavs = createUAVsEx(routineBundle.resources.uavs, capacity, sharedUAVs);
    const numthreads = routineBundle.numthreads;
    uavs.forEach(uav => { vmBundle.setInput(uav.index, uav.buffer); });
    const { buffers, textures, trimeshes } = routineBundle.resources;
    function setConstant(name, value) {
        vmBundle.setConstant(name, value);
    }
    function setInt32Constant(name, value) {
        CTEMP_DV.setInt32(0, value, true);
        setConstant(name, CTEMP_U8);
    }
    function setUint32Constant(name, value) {
        CTEMP_DV.setUint32(0, value, true);
        setConstant(name, CTEMP_U8);
    }
    function setConstants(constants) {
        Object.keys(constants)
            .forEach(name => setConstant(name, constants[name]));
    }
    function setBuffer(name, data) {
        const buf = buffers.find(buf => buf.name === name);
        if (!buf)
            return;
        vmBundle.setInput(buf.slot + _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_4__.SRV0_REGISTER, data);
    }
    // content consist of Float32Array(...f3 pos, f3 normal, f2 uv)
    function setTrimesh(name, trimesh) {
        const { vertCount, faceCount, vertices, faces, indicesAdj, faceAdj } = trimesh;
        const mesh = trimeshes.find(mesh => mesh.name === name);
        if (!mesh)
            return;
        setBuffer(mesh.verticesName, vertices);
        setBuffer(mesh.facesName, faces);
        setBuffer(mesh.gsAdjecencyName, indicesAdj);
        setBuffer(mesh.faceAdjacencyName, faceAdj);
        setUint32Constant(mesh.vertexCountUName, vertCount);
        setUint32Constant(mesh.faceCountUName, faceCount);
    }
    function setTexture(name, tex) {
        const { layout } = tex;
        const texture = textures.find(tex => tex.name === name);
        if (!texture)
            return;
        vmBundle.setInput(texture.slot + _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_4__.SRV0_REGISTER, layout);
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(numthreads[0] >= 1 && numthreads[1] === 1 && numthreads[2] === 1);
    function run(numgroups) {
        vmBundle.dispatch({ x: numgroups, y: 1, z: 1 }, { x: numthreads[0], y: numthreads[1], z: numthreads[2] });
    }
    return {
        uavs,
        bundle: vmBundle,
        run,
        setConstants,
        setInt32Constant,
        setUint32Constant,
        setTrimesh,
        setTexture,
        groupsizex: numthreads[0]
    };
}
const UAV = {
    overwriteCounter(uav, value) {
        _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uav.buffer)[0] = value;
    },
    readCounter(uav) {
        return _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uav.buffer)[0];
    },
    readElement({ data, elementSize }, iElement) {
        const u8a = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(data);
        return new Uint8Array(u8a.buffer, u8a.byteOffset + iElement * elementSize, elementSize);
    },
    minidump(uav) {
        const { name, length, elementSize, register, data } = uav;
        // std::cout << "--------------------------------------" << std::endl;
        console.log(` uav ${name}[${length}x${elementSize}:r${register}:cnt(${UAV.readCounter(uav)})]`);
        const u8a = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(data);
        let n = Math.min(64, length * elementSize);
        let sout = '';
        for (let i = 0; i < n; ++i) {
            sout += `${u8a[i].toString(16)} `;
        }
        sout += '...';
        console.log(sout);
        // std::cout << "--------------------------------------" << std::endl;
    }
};
// tslint:disable-next-line:max-func-body-length
function createEmiterFromBundle(bundle, uavResources) {
    const { name, content } = bundle;
    const { capacity, particle, simulationRoutines, renderPasses } = content;
    const resetBundle = setupFxRoutineBytecodeBundle(`${name}/reset`, simulationRoutines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__.EPartSimRoutines.k_Reset], capacity, uavResources);
    const initBundle = setupFxRoutineBytecodeBundle(`${name}/init`, simulationRoutines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__.EPartSimRoutines.k_Init], capacity, uavResources);
    const updateBundle = setupFxRoutineBytecodeBundle(`${name}/update`, simulationRoutines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__.EPartSimRoutines.k_Update], capacity, uavResources);
    const spawnBundle = setupFxRoutineBytecodeBundle(`${name}/spawn`, simulationRoutines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__.EPartSimRoutines.k_Spawn], 4, uavResources);
    const uavDeadIndices = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_DEAD_INDICES);
    const uavParticles = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_PARTICLES);
    const uavStates = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_STATES);
    const uavInitArguments = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS);
    const uavCreationRequests = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_CREATION_REQUESTS);
    const uavSpawnEmitter = uavResources.find(uav => uav.name === _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_SPAWN_EMITTER);
    function preparePrerender() {
        passes.forEach((p, i) => {
            p.preparePrerender();
        });
    }
    const passes = renderPasses.map((pass, i) => {
        const { routines, geometry, sorting, instanceCount, instance, stride, renderStates } = pass;
        const UAV_PRERENDERED = `${_lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_PRERENDERED}${i}`;
        const UAV_SERIALS = `${_lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.UAV_SERIALS}${i}`;
        const prerenderBundle = routines[_lib_idl_bundles_auto_fx_epart_render_routines__WEBPACK_IMPORTED_MODULE_8__.EPartRenderRoutines.k_Prerender];
        const bundle = setupFxRoutineBytecodeBundle(`${name}/prerender`, prerenderBundle, capacity * instanceCount, uavResources);
        const uavPrerendered = uavResources.find(uav => uav.name === UAV_PRERENDERED);
        const uavSerials = uavResources.find(uav => uav.name === UAV_SERIALS);
        const vertexBundle = routines[_lib_idl_bundles_auto_fx_epart_render_routines__WEBPACK_IMPORTED_MODULE_8__.EPartRenderRoutines.k_Vertex];
        const vertexGLSLBundle = vertexBundle.shaders.find((shader, i) => vertexBundle.shadersType[i] === _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_9__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        const pixelBundle = routines[_lib_idl_bundles_auto_fx_epart_render_routines__WEBPACK_IMPORTED_MODULE_8__.EPartRenderRoutines.k_Pixel];
        const pixelGLSLBundle = pixelBundle.shaders.find((shader, i) => pixelBundle.shadersType[i] === _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_9__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        const vertexShader = vertexGLSLBundle.code;
        const pixelShader = pixelGLSLBundle.code;
        const instanceLayout = vertexGLSLBundle.attributes;
        const getNumRenderedParticles = () => UAV.readCounter(uavPrerendered) * instanceCount;
        // if no prerender bundle then all particles must be prerendered within update stage
        // looking for prerendered reflection among prerender or update routine uavs
        const uavPrerendReflect = (bundle ? routines[_lib_idl_bundles_auto_fx_epart_render_routines__WEBPACK_IMPORTED_MODULE_8__.EPartRenderRoutines.k_Prerender] : simulationRoutines[_lib_idl_bundles_auto_fx_epart_sim_routines__WEBPACK_IMPORTED_MODULE_7__.EPartSimRoutines.k_Update])
            .resources.uavs.find(uavReflection => uavReflection.name === UAV_PRERENDERED);
        const cbufs = {};
        const scanCbuffer = (sharedCbufs, bundle, usage) => {
            for (let { name, slot, size, fields } of bundle.cbuffers) {
                // skip same name buffers
                const cbuf = sharedCbufs[`${name}`] ||= {
                    name: `${name}`,
                    slot,
                    size,
                    usage,
                    fields: fields.map(({ name, semantic, size, padding, type: { length } }) => ({
                        name: `${name}`,
                        semantic: `${semantic || name}`,
                        size,
                        padding,
                        length
                    }))
                };
                cbuf.usage |= usage;
            }
        };
        // merge VS & PS constant buffer into shared list 
        // it's guaranteed by translator that buffers with the same name are the same
        scanCbuffer(cbufs, vertexGLSLBundle, _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__.EUsage.k_Vertex);
        scanCbuffer(cbufs, pixelGLSLBundle, _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__.EUsage.k_Pixel);
        const cbuffers = Object.values(cbufs);
        //
        // Sorting
        //
        const uavNonSorted = uavPrerendered;
        // share memory with WASM bundle if used
        const uavNonSortedU8 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(uavNonSorted.data);
        let uavPrerendReflectSorted = null;
        let uavSorted = null;
        let uavSortedU8 = null;
        let uavSerialsI32 = null;
        if (sorting) {
            uavPrerendReflectSorted = new _lib_idl_bundles_auto_fx_uavbundle__WEBPACK_IMPORTED_MODULE_6__.UAVBundleT(`${uavPrerendReflect.name}Sorted`, uavPrerendReflect.slot, uavPrerendReflect.stride, uavPrerendReflect.type);
            uavSorted = createUAVsEx([uavPrerendReflectSorted], capacity * instanceCount, uavResources)[0];
            uavSortedU8 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(uavSorted.data);
            uavSerialsI32 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uavSerials.data);
        }
        // dump prerendered particles
        const dump = () => {
            let nPart = getNumRenderedParticles();
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`dump ${nPart}/${capacity} prerendred particles: `);
            for (let iElement = 0; iElement < nPart; ++iElement) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.asNativeRaw(UAV.readElement(uavNonSorted, iElement), instance));
            }
        };
        function serialize() {
            if (!sorting) {
                return;
            }
            const nStrideF32 = stride * instanceCount; // stride in floats
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(uavSortedU8.byteLength >> 2 === nStrideF32 * capacity);
            const srcF32 = new Float32Array(uavNonSortedU8.buffer, uavNonSortedU8.byteOffset, uavNonSortedU8.byteLength >> 2);
            const dstF32 = new Float32Array(uavSortedU8.buffer, uavSortedU8.byteOffset, uavSortedU8.byteLength >> 2);
            const indicies = [];
            // todo: sort inplace using serials pairs
            for (let iPart = 0; iPart < UAV.readCounter(uavPrerendered); ++iPart) {
                const sortIndex = uavSerialsI32[iPart * 2 + 0];
                const partIndex = uavSerialsI32[iPart * 2 + 1];
                indicies.push([partIndex, sortIndex]);
            }
            ;
            indicies.sort((a, b) => -a[1] + b[1]);
            for (let i = 0; i < indicies.length; ++i) {
                const iFrom = indicies[i][0] * nStrideF32;
                const iTo = i * nStrideF32;
                const from = srcF32.subarray(iFrom, iFrom + nStrideF32);
                const copyTo = dstF32.subarray(iTo, iTo + nStrideF32);
                copyTo.set(from);
            }
        }
        function getData() { return (0,_lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_2__.asBundleMemory)(sorting ? uavSortedU8 : uavNonSortedU8); }
        function getDesc() {
            const states = {};
            renderStates.forEach(({ type, value }) => { states[type] = value; });
            return {
                instanceName: instance.name,
                instanceLayout: instanceLayout.map(({ name, offset, size }) => ({ name: name, offset, size })),
                stride,
                geometry: geometry,
                sorting,
                vertexShader,
                pixelShader,
                renderStates: states,
                cbuffers
            };
        }
        function preparePrerender() {
            if (uavPrerendered) {
                UAV.overwriteCounter(uavPrerendered, 0);
            }
            if (uavSerials) {
                UAV.overwriteCounter(uavSerials, 0);
            }
        }
        function prerender(uniforms) {
            if (!bundle) {
                // manual prerender is used
                return;
            }
            // simulation could be omitted (effect is paused for ex.) 
            // but prerender counters still have to be dropped
            // if we want to continue prerender every frame
            preparePrerender();
            bundle.setConstants(uniforms);
            bundle.run(Math.ceil(capacity / bundle.groupsizex));
        }
        function setTexture(name, tex) {
            bundle?.setTexture(name, tex);
        }
        function setTrimesh(name, mesh) {
            bundle?.setTrimesh(name, mesh);
        }
        return {
            getDesc,
            getData,
            getNumRenderedParticles,
            setTexture,
            setTrimesh,
            serialize,
            preparePrerender,
            prerender,
            dump
        };
    });
    const getNumParticles = () => capacity - UAV.readCounter(uavDeadIndices);
    const getName = () => name;
    const getType = () => 'emitter';
    const getPassCount = () => passes.length;
    const getPass = (i) => passes[i];
    const getCapacity = () => capacity;
    function setTrimesh(name, mesh) {
        spawnBundle.setTrimesh(name, mesh);
        initBundle.setTrimesh(name, mesh);
        updateBundle.setTrimesh(name, mesh);
        passes.forEach(pass => pass.setTrimesh(name, mesh));
    }
    function setTexture(name, tex) {
        spawnBundle.setTexture(name, tex);
        initBundle.setTexture(name, tex);
        updateBundle.setTexture(name, tex);
        passes.forEach(pass => pass.setTexture(name, tex));
    }
    function reset() {
        // reset all available particles
        resetBundle.run(Math.ceil(capacity / resetBundle.groupsizex));
        UAV.overwriteCounter(uavDeadIndices, capacity);
    }
    function update(uniforms) {
        // drop prerender counters all the time before update
        // because some effects may use "draw" operator
        // which means that simulation and preprender are mixed
        preparePrerender();
        updateBundle.setConstants(uniforms);
        updateBundle.run(Math.ceil(capacity / updateBundle.groupsizex));
    }
    function prerender(uniforms) {
        passes.forEach(pass => pass.prerender(uniforms));
    }
    function serialize() {
        passes.forEach(pass => pass.serialize());
    }
    function emit(uniforms) {
        initBundle.setConstants(uniforms);
        initBundle.run(_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uavInitArguments.data)[0]);
        spawnBundle.setConstants(uniforms);
        spawnBundle.run(1);
    }
    function simulate(uniforms) {
        update(uniforms);
        emit(uniforms);
    }
    /** @deprecated */
    function dump() {
        const npart = getNumParticles();
        const partSize = particle.size;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`particles total: ${npart} ( ${UAV.readCounter(uavDeadIndices)}/${capacity} )`);
        const uavStatesI32 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToI32Array(uavStates.data);
        const uavParticlesU8 = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(uavParticles.data);
        uavStatesI32.forEach((alive, iPart) => {
            if (alive) {
                const partRaw = new Uint8Array(uavParticlesU8.buffer, uavParticlesU8.byteOffset + iPart * partSize, partSize);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(iPart, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.asNativeRaw(partRaw, particle));
            }
        });
    }
    function createDebugViewer() {
        return createParticleDebugViewer(particle, capacity, uavDeadIndices, uavStates, uavParticles);
    }
    return {
        // abstract interface
        getType,
        getName,
        getCapacity,
        getPassCount,
        getPass,
        getNumParticles,
        reset,
        simulate,
        prerender,
        serialize,
        setTrimesh,
        setTexture,
        dump,
        createDebugViewer
    };
}
function compareFxTypeLayouts(left, right) {
    return JSON.stringify(left) == JSON.stringify(right);
}
// function compareFxControls(left: UIControlT[], right: UIControlT[]) {
//     return JSON.stringify(left) == JSON.stringify(right);
// }
// todo: rework comparisson to be more readable and compact
function comparePartFxBundles(left, right) {
    if (left.capacity != right.capacity)
        return false;
    if (left.renderPasses.length != right.renderPasses.length)
        return false;
    if (!compareFxTypeLayouts(left.particle, right.particle))
        return false;
    for (let i = 0; i < left.renderPasses.length; ++i) {
        if (left.renderPasses[i].geometry != right.renderPasses[i].geometry)
            return false;
        if (left.renderPasses[i].sorting != right.renderPasses[i].sorting)
            return false;
        if (left.renderPasses[i].instanceCount != right.renderPasses[i].instanceCount)
            return false;
        if (!compareFxTypeLayouts(left.renderPasses[i].instance, right.renderPasses[i].instance))
            return false;
    }
    return true;
}
function copyTsEmitter(dst, src) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(dst.getType() === 'emitter' && src.getType() === 'emitter');
    if (comparePartFxBundles(dst.bundle.content, src.bundle.content)) {
        dst.uavResources.forEach((uav, i) => _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(uav.buffer).set(_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.memoryToU8Array(src.uavResources[i].buffer)));
        return true;
    }
    return false;
}
function destroyTsEmitter(tech) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(tech.getType() === 'emitter');
    let emitter = tech;
    let { uavResources } = emitter;
    uavResources.forEach(uav => {
        _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.destroyUAV(uav);
        // verbose(`UAV '${uav.name}' has been destroyed.`);
    });
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`emitter '${emitter.getName()}' has been dropped.`);
}
function createTsEmitter(bundle) {
    let uavResources = [];
    let newly = createEmiterFromBundle(bundle, uavResources);
    return { bundle, uavResources, ...newly };
}
function createTsTexture({ width, height }, data) {
    const DESCRIPTOR_SIZE = 64;
    const bytesPerPixel = 4;
    const size = bytesPerPixel * width * height;
    const layout = new Uint8Array(DESCRIPTOR_SIZE + size);
    const dest = layout.subarray(DESCRIPTOR_SIZE);
    if (data) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(data.byteLength === size);
        const src = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        dest.set(src);
    }
    else {
        dest.fill(0);
    }
    const desc = new DataView(layout.buffer, 0, DESCRIPTOR_SIZE);
    desc.setInt32(0, width, true);
    desc.setInt32(4, height, true);
    // set format R8G8B8A8 == 0
    desc.setInt32(8, 0, true);
    return { layout: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.copyViewToMemory(layout) };
}
function destroyTsTexture(texture) {
    const { layout } = texture;
    _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.releaseMemory(layout);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`texture has been dropped.`);
}
function createTsTrimesh(desc, vertices, faces, indicesAdj, faceAdj) {
    const { vertCount, faceCount } = desc;
    return {
        vertCount,
        faceCount,
        vertices: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.copyViewToMemory(vertices),
        faces: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.copyViewToMemory(faces),
        indicesAdj: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.copyViewToMemory(indicesAdj),
        faceAdj: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.copyViewToMemory(faceAdj)
    };
}
function destroyTsTrimesh(mesh) {
    const { vertices, faces, indicesAdj, faceAdj } = mesh;
    _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.releaseMemory(vertices);
    _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.releaseMemory(faces);
    _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.releaseMemory(indicesAdj);
    _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_1__.releaseMemory(faceAdj);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "eYFc":
/*!*****************************************!*\
  !*** ./src/lib/fx/techniques/ts/mat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTsMaterial": () => (/* binding */ copyTsMaterial),
/* harmony export */   "createTsMaterial": () => (/* binding */ createTsMaterial),
/* harmony export */   "destroyTsMaterial": () => (/* binding */ destroyTsMaterial)
/* harmony export */ });
/* harmony import */ var _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/ITechnique9 */ "UHT2");
/* harmony import */ var _lib_idl_bundles_auto_fx_emat_render_routines__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/emat-render-routines */ "Eive");
/* harmony import */ var _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/bundles/auto/fx/routine-source-bundle */ "KEtj");



/** @deprecated */
function createMaterialFromBundle(bundle) {
    const { name, content } = bundle;
    const { renderPasses } = content;
    const passes = renderPasses.map((pass, i) => {
        const { routines, instance, stride, renderStates } = pass;
        const vertexBundle = routines[_lib_idl_bundles_auto_fx_emat_render_routines__WEBPACK_IMPORTED_MODULE_1__.EMatRenderRoutines.k_Vertex];
        const vertexGLSLBundle = vertexBundle.shaders.find((shader, i) => vertexBundle.shadersType[i] === _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        const pixelBundle = routines[_lib_idl_bundles_auto_fx_emat_render_routines__WEBPACK_IMPORTED_MODULE_1__.EMatRenderRoutines.k_Pixel];
        const pixelGLSLBundle = pixelBundle.shaders.find((shader, i) => pixelBundle.shadersType[i] === _lib_idl_bundles_auto_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineSourceBundle.RoutineGLSLSourceBundle);
        const vertexShader = vertexGLSLBundle.code;
        const pixelShader = pixelGLSLBundle.code;
        const instanceLayout = vertexGLSLBundle.attributes;
        const states = {};
        renderStates.forEach(({ type, value }) => { states[type] = value; });
        const cbufs = {};
        const scanCbuffer = (sharedCbufs, bundle, usage) => {
            for (let { name, slot, size, fields } of bundle.cbuffers) {
                // skip same name buffers
                const cbuf = sharedCbufs[`${name}`] ||= {
                    name: `${name}`,
                    slot,
                    size,
                    usage,
                    fields: fields.map(({ name, semantic, size, padding, type: { length } }) => ({
                        name: `${name}`,
                        semantic: `${semantic || name}`,
                        size,
                        padding,
                        length
                    }))
                };
                cbuf.usage |= usage;
            }
        };
        // merge VS & PS constant buffer into shared list 
        // it's guaranteed by translator that buffers with the same name are the same
        scanCbuffer(cbufs, vertexGLSLBundle, _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_0__.EUsage.k_Vertex);
        scanCbuffer(cbufs, pixelGLSLBundle, _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_0__.EUsage.k_Pixel);
        const cbuffers = Object.values(cbufs);
        function getDesc() {
            return {
                instanceName: instance.name,
                instanceLayout: instanceLayout.map(({ name, offset, size }) => ({ name: name, offset, size })),
                stride,
                vertexShader,
                pixelShader,
                renderStates: states,
                cbuffers
            };
        }
        return {
            getDesc
        };
    });
    const getName = () => name;
    const getType = () => 'material';
    const getPassCount = () => passes.length;
    const getPass = (i) => passes[i];
    return {
        // abstract interface
        getType,
        getName,
        getPassCount,
        getPass
    };
}
/** @deprecated */
function copyTsMaterial(dst, src) {
    return false;
}
/** @deprecated */
function destroyTsMaterial(tech) {
    // nothing todo
}
/** @deprecated */
function createTsMaterial(bundle) {
    let newly = createMaterialFromBundle(bundle);
    return { bundle, ...newly };
}


/***/ }),

/***/ "moL5":
/*!*************************************************!*\
  !*** ./src/lib/fx/techniques/ts/technique11.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyTsTechnique11": () => (/* binding */ copyTsTechnique11),
/* harmony export */   "createTsTechnique11": () => (/* binding */ createTsTechnique11),
/* harmony export */   "destroyTsTechnique11": () => (/* binding */ destroyTsTechnique11)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode_VM_ts_bridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bridge */ "vVoC");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM_ts_bridge__WEBPACK_IMPORTED_MODULE_0__]);
_lib_fx_bytecode_VM_ts_bridge__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// import * as VM from '@lib/fx/bytecode/VM';

function createTechnique11FromBundle(bundle) {
    const { name, content } = bundle;
    const tech11 = content;
    const passes = tech11.passes.map(({ code, shaders, shadersType }, i) => {
        // const render = VM.make(`pass-${i}`, code);
        // todo: add WASM support 
        const render = _lib_fx_bytecode_VM_ts_bridge__WEBPACK_IMPORTED_MODULE_0__.make(`pass-${i}`, new Uint8Array(code));
        return {
            render,
            shaders
        };
    });
    const getName = () => name;
    const getType = () => 'technique11';
    const getPassCount = () => passes.length;
    const getPass = (i) => passes[i];
    // const vmBundle = VM.make(debugName, routineBundle.code);
    return {
        getType,
        getName,
        getPassCount,
        getPass
    };
}
////////////////////////////////////////////////
function copyTsTechnique11(dst, src) {
    return false;
}
function destroyTsTechnique11(tech) {
    // nothing todo
}
function createTsTechnique11(bundle) {
    let newly = createTechnique11FromBundle(bundle);
    return { bundle, ...newly };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "QlGU":
/*!********************************!*\
  !*** ./src/lib/fx/timeline.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "make": () => (/* binding */ make)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");

function make() {
    let pauseTime;
    let pauseDelay;
    let startTime;
    let elapsedTimeLevel;
    let active;
    let paused;
    let frameNumber;
    const constants = {
        elapsedTime: 0,
        elapsedTimeLevel: 0,
        frameNumber: 0
    };
    function stop() {
        active = false;
        paused = 0;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)('timeline stopped');
    }
    function start() {
        constants.elapsedTime = 0;
        constants.elapsedTimeLevel = 0;
        constants.frameNumber = 0;
        paused = 0;
        pauseDelay = 0;
        pauseTime = 0;
        frameNumber = 0;
        startTime = Date.now();
        elapsedTimeLevel = 0;
        active = true;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)('timeline started');
    }
    function tick() {
        if (isStopped() || isPaused()) {
            return;
        }
        const dt = Date.now() - startTime - pauseDelay;
        constants.elapsedTime = (dt - elapsedTimeLevel) / 1000;
        constants.elapsedTimeLevel = elapsedTimeLevel / 1000;
        constants.frameNumber = ++frameNumber;
        elapsedTimeLevel = dt;
        // frameNumber++;
    }
    function isStopped() {
        return !active;
    }
    function isPaused() {
        return !!paused;
    }
    function pause() {
        if (isStopped())
            return;
        if (!isPaused()) {
            pauseTime = Date.now();
        }
        paused++;
    }
    function unpause() {
        if (isStopped() || !isPaused())
            return;
        paused--;
        if (!isPaused()) {
            pauseDelay += Date.now() - pauseTime;
        }
    }
    function getConstants() {
        return constants;
    }
    return {
        getConstants,
        start,
        stop,
        tick,
        isStopped,
        pause,
        unpause,
        isPaused
    };
}


/***/ }),

/***/ "EekG":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/BaseEmitter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseEmitter": () => (/* binding */ BaseEmitter)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _Output__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Output */ "/pDr");


class BaseEmitter {
    constructor() {
        this.blocks = [];
        this.stack = [];
    }
    top() { return this.stack[this.depth() - 1]; }
    findOrCreateOutput(name) {
        const i = this.blocks.findIndex(block => name && block.name === name);
        const block = i !== -1
            ? this.blocks.splice(i, 1)[0]
            : (0,_Output__WEBPACK_IMPORTED_MODULE_1__.createOutput)({ name });
        return block;
    }
    depth() {
        return this.stack.length;
    }
    begin(block) {
        this.stack.push(this.findOrCreateOutput(block));
    }
    /**
     * @param prologue Move block to the beginning.
     */
    end(prologue = false) {
        const block = this.stack.pop();
        if (block.isEmpty()) {
            return;
        }
        if (!prologue) {
            this.blocks.push(block);
        }
        else {
            this.blocks = [block, ...this.blocks];
        }
    }
    push(pad) {
        this.top().push(pad);
    }
    pop() {
        this.top().pop();
    }
    emitNewline(n = 1) { Array(n).fill(0).forEach(i => this.top()?.newline()); }
    emitKeyword(kw) { this.top()?.keyword(kw); }
    emitNoSpace() { this.top()?.ignoreNextSpace(); }
    emitSpace() { this.emitChar(' '); this.emitNoSpace(); }
    emitChar(char) { this.top()?.add(char); }
    emitLine(line) {
        this.emitChar(line);
        this.emitNewline();
    }
    clear() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.stack.length == 0);
        this.blocks = [];
    }
    toString() {
        const res = this.blocks
            .map(block => block.toString())
            .filter(code => !!code)
            .join('\n\n');
        this.clear();
        return res;
    }
    valueOf() {
        return this.toString();
    }
}


/***/ }),

/***/ "jYc8":
/*!**********************************************************!*\
  !*** ./src/lib/fx/translators/CodeConvolutionEmitter.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CodeConvolutionContext": () => (/* binding */ CodeConvolutionContext),
/* harmony export */   "CodeConvolutionEmitter": () => (/* binding */ CodeConvolutionEmitter)
/* harmony export */ });
/* harmony import */ var _CodeEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CodeEmitter */ "GU3W");

class CodeConvolutionContext extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_0__.CodeContext {
    constructor(opts) {
        super(opts);
        // list of convolute includes
        this.includeDeps = [];
    }
    get textDocument() { return this.opts.textDocument; }
    get slastDocument() { return this.opts.slastDocument; }
}
class CodeConvolutionEmitter extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_0__.CodeEmitter {
    // todo: add caching
    convoluteToInclude(ctx, decl) {
        if (!decl) {
            return false;
        }
        if (!ctx.slastDocument || !ctx.textDocument) {
            return false;
        }
        if (!decl.sourceNode) {
            return false;
        }
        const src = decl.sourceNode.loc;
        const includes = ctx.slastDocument.includes;
        let dst = src;
        while (dst && String(ctx.textDocument.uri) !== String(dst.start.file)) {
            dst = includes.get(String(dst.start.file));
        }
        // no includes are found
        if (dst == src) {
            return false;
        }
        // extract original include expression
        const { start, end } = dst;
        const include = ctx.textDocument.source.substring(start.offset, end.offset);
        // TODO: remove temp hack!
        if (include.includes('lib.hlsl')) {
            return false;
        }
        if (ctx.includeDeps.includes(include)) {
            return true;
        }
        ctx.includeDeps.push(include);
        return true;
    }
    emitComplexTypeDecl(ctx, ctype) {
        if (!this.convoluteToInclude(ctx, ctype))
            super.emitComplexTypeDecl(ctx, ctype);
    }
    emitFunction(ctx, fn) {
        if (!this.convoluteToInclude(ctx, fn))
            super.emitFunction(ctx, fn);
    }
    emitTypeDecl(ctx, decl) {
        if (!this.convoluteToInclude(ctx, decl))
            super.emitTypeDecl(ctx, decl);
    }
    emitTypedef(ctx, def) {
        if (!this.convoluteToInclude(ctx, def))
            super.emitTypedef(ctx, def);
    }
    emitGlobalVariable(ctx, decl) {
        if (!this.convoluteToInclude(ctx, decl))
            super.emitGlobalVariable(ctx, decl);
    }
    emitCbuffer(ctx, cbuf) {
        if (!this.convoluteToInclude(ctx, cbuf))
            super.emitCbuffer(ctx, cbuf);
    }
    emitTexture(ctx, decl) {
        if (!this.convoluteToInclude(ctx, decl))
            super.emitTexture(ctx, decl);
    }
    toString(ctx) {
        const code = super.toString();
        if (!ctx) {
            return code;
        }
        if (!ctx.includeDeps.length) {
            return code;
        }
        const includes = ctx.includeDeps.join('\n');
        return `${includes}\n\n${code}`;
    }
    emit(ctx, instr) {
        super.emit(ctx, instr);
        return this;
    }
    static translate(instr, ctx = new CodeConvolutionContext) {
        return CodeConvolutionEmitter.ccEmitter.emit(ctx, instr).toString(ctx);
    }
}
CodeConvolutionEmitter.ccEmitter = new CodeConvolutionEmitter({ omitEmptyParams: true });


/***/ }),

/***/ "GU3W":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/CodeEmitter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CodeContext": () => (/* binding */ CodeContext),
/* harmony export */   "CodeEmitter": () => (/* binding */ CodeEmitter),
/* harmony export */   "EUsages": () => (/* binding */ EUsages)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_helpers_fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/helpers/fn */ "zoki");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _BaseEmitter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BaseEmitter */ "EekG");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");










var EUsages;
(function (EUsages) {
    EUsages[EUsages["k_Vertex"] = 1] = "k_Vertex";
    EUsages[EUsages["k_Pixel"] = 2] = "k_Pixel";
    EUsages[EUsages["k_Compute"] = 4] = "k_Compute";
})(EUsages || (EUsages = {}));
;
;
function pushUniq(arr, elem) {
    if (arr.indexOf(elem) == -1)
        arr.push(elem);
}
class CodeContext {
    constructor(opts = {}) {
        // known globals like: functions, types, uniforms etc.
        this.knownSignatures = new Set();
        this.uavs = [];
        this.textures = [];
        this.buffers = [];
        this.cbuffers = [];
        this.CSShaders = [];
        this.opts = opts;
        this.opts.mode ||= 'raw';
        console.assert(['vs', 'ps', 'ds', 'hs', 'gs', 'cs', 'raw'].includes(this.opts.mode));
    }
    get entryName() { return this.opts.entryName; }
    get mode() { return this.opts.mode; }
    isPixel() { return this.mode === 'ps'; }
    isVertex() { return this.mode === 'vs'; }
    isRaw() { return this.mode === 'raw'; }
    has(signature) {
        return this.knownSignatures.has(signature);
    }
    add(signature) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(signature));
        this.knownSignatures.add(signature);
    }
    // note: cbuffers without predefined register are not supported yet (!)
    addCbuffer(cbuf) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(cbuf.name));
        this.add(cbuf.name);
        const { name, type: { size } } = cbuf;
        const register = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.resolveRegister(cbuf).index;
        const buf = { name, size, register };
        this.cbuffers.push(buf);
        return buf;
    }
    addTexture(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.buffers.length + this.textures.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp) || [`${type}<float4>`, `${type}`, `float4`];
        const texture = {
            name,
            type,
            texType: match[1],
            elementType: match[2],
            register
        };
        this.textures.push(texture);
        return texture;
    }
    addUav(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.uavs.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match);
        const uav = {
            name,
            type,
            uavType: match[1],
            elementType: match[2],
            register
        };
        this.uavs.push(uav);
        return uav;
    }
    addBuffer(type, name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(name));
        this.add(name);
        const register = this.buffers.length + this.textures.length;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.match(regexp);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match);
        const buf = {
            name,
            type,
            bufType: match[1],
            elementType: match[2],
            register
        };
        this.buffers.push(buf);
        return buf;
    }
    beginCsShader(name, numthreads) {
        const uavs = [];
        const buffers = [];
        const textures = [];
        this.CSShader = { name, numthreads, uavs, buffers, textures };
    }
    endCsShader() {
        const sh = this.CSShader;
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(sh);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(sh.name));
        this.add(sh.name);
        this.CSShaders.push(sh);
        this.CSShader = null;
    }
    linkBuffer(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.buffers, this.buffers.find(b => b.name == name));
        }
    }
    linkCbuffer(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            // pushUniq(sh.cbuffers, this.cbuffers.find(b => b.name == name));
        }
    }
    linkUav(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.uavs, this.uavs.find(u => u.name == name));
        }
    }
    linkTexture(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.textures, this.textures.find(t => t.name == name));
        }
    }
}
class CodeEmitter extends _BaseEmitter__WEBPACK_IMPORTED_MODULE_8__.BaseEmitter {
    constructor(options = {}) {
        super();
        this.options = options;
    }
    isMain() {
        return this.depth() === 1;
    }
    resolveTypeName(type) {
        return type.name;
    }
    resolveType(ctx, type) {
        if (!type) {
            return null;
        }
        let complex = type.isComplex();
        let length;
        let typeName;
        let usages;
        let usage;
        if (!complex) {
            typeName = this.resolveTypeName(type);
        }
        else {
            typeName = type.name;
            // find original type instead of VariableType wrapper. 
            const originalType = type.scope.findType(type.name);
            this.emit(ctx, originalType);
        }
        if (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType) {
            const vtype = type;
            usages = vtype.usages;
        }
        if (type.isNotBaseArray()) {
            length = type.length;
        }
        if (usages && usages.length) {
            usage = usages.filter(u => !this.options.omitInUsage || u != 'in').join(' ');
        }
        return { typeName, length, usage };
    }
    emitBuffer(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const buf = ctx.addBuffer(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(t${buf.register});`);
            }
            this.end();
        }
        ctx.linkBuffer(name);
    }
    emitUav(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const uav = ctx.addUav(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(u${uav.register});`);
            }
            this.end();
        }
        ctx.linkUav(name);
    }
    emitTexture(ctx, decl) {
        const { name, type } = decl;
        this.emitTextureRaw(ctx, type.name, name);
    }
    emitTextureRaw(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const tex = ctx.addTexture(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`${type} ${name}: register(t${tex.register});`);
            }
            this.end();
        }
        ctx.linkTexture(name);
    }
    emitLine(line, comment) {
        this.emitChar(line);
        comment && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(comment.split('\n').length === 1);
        comment && (this.emitChar('\t'), this.emitComment(comment));
        this.emitNewline();
    }
    emitComment(comment) {
        //
        if (comment.indexOf('\n') === -1) {
            this.emitLine(`// ${comment}`);
            return;
        }
        /**
         *
         */
        this.emitLine('/**');
        this.push(' * ');
        comment.split('\n').forEach(line => this.emitLine(line));
        this.pop();
        this.emitLine(' */');
    }
    emitComplexType(ctx, type) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type.isComplex());
        this.emitKeyword('struct');
        this.emitKeyword(type.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        type.fields.map(field => (this.emitComplexField(ctx, field), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitComplexTypeDecl(ctx, ctype) {
        if (ctx.has(ctype.name)) {
            return;
        }
        ctx.add(ctype.name);
        this.begin();
        this.emitComplexType(ctx, ctype);
        this.emitChar(';');
        this.end();
    }
    // todo: remove hack with rename mutator
    emitVariableNoInit(ctx, decl, rename) {
        const { typeName, length, usage } = this.resolveType(ctx, decl.type);
        const name = rename ? rename(decl) : decl.name;
        usage && this.emitKeyword(usage);
        this.emitKeyword(typeName);
        this.emitKeyword(name);
        length && this.emitChar(`[${length}]`);
        decl.semantic && this.emitSemantic(ctx, decl.semantic);
        decl.annotation && this.emitAnnotation(ctx, decl.annotation);
    }
    // todo: remove hack with rename mutator
    emitVariable(ctx, src, rename) {
        this.emitVariableNoInit(ctx, src, rename);
        if (src.initExpr) {
            // blocks are valid for blend/raster/depth state initialization.
            const isBlock = src.initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StateBlockExpr;
            if (!isBlock) {
                this.emitKeyword('=');
                this.emitSpace();
            }
            this.emitExpression(ctx, src.initExpr);
        }
    }
    emitIfStmt(ctx, stmt) {
        this.emitKeyword('if');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, stmt.cond);
        this.emitChar(')');
        this.emitNewline();
        if (stmt.conseq) {
            this.emitStmt(ctx, stmt.conseq);
        }
        else {
            this.emitChar(';');
        }
        if (stmt.contrary) {
            this.emitNewline();
            this.emitKeyword('else');
            this.emitStmt(ctx, stmt.contrary);
        }
    }
    emitSemantic(ctx, semantic) {
        this.emitChar(':');
        this.emitKeyword(semantic);
    }
    emitAnnotation(ctx, anno) {
        // TODO: add annotation emission.
    }
    /** @deprecated */
    emitCompile(ctx, compile) {
        this.emitFunction(ctx, compile.function);
        this.emitKeyword('compile');
        this.emitKeyword(compile.function.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, compile.args);
        this.emitChar(')');
    }
    evaluateEntryName(ctx, fn) {
        const fnName = fn.name;
        const entryName = ctx.entryName;
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_7__.isString)(entryName))
            return fnName;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(fn.scope.functions[entryName]))
            // todo: emit correct error
            console.error('entry point already exists');
        return entryName;
    }
    emitEntryParams(ctx, params) {
        // emit constants instead of uniforms arguments if provided
        const constants = ctx.opts.constants;
        if (constants) {
            params.filter(p => p.type.isUniform()).forEach((param, i) => {
                const c = constants[i];
                const name = param.name;
                if (ctx.has(name)) {
                    // global variable with the same name as argument already exists
                    console.assert(false, '?!');
                    return;
                }
                ctx.add(name);
                this.begin();
                this.emitLine(`static const ${c.type} ${name} = ${String(c.value)};`);
                this.end();
            });
        }
        // skip uniform arguments if constant substitution were passed
        params
            .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && (!p.type.isUniform() || !constants))
            .forEach((param, i, list) => {
            this.emitParam(ctx, param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    // todo: add compute entry support
    emitEntryFunction(ctx, fn) {
        const { def } = fn;
        const { typeName } = this.resolveType(ctx, def.returnType);
        this.begin();
        {
            // in case of hlsl materials it's typical to swap arbitrary name for bundle name
            // to simplify further compilation
            let fnName = this.evaluateEntryName(ctx, fn);
            this.emitKeyword(typeName);
            this.emitKeyword(fnName);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitEntryParams(ctx, def.params);
            this.emitChar(')');
            // todo: validate complex type sematics
            // all the output parameters of entry function must have valid semantics
            if (!def.returnType.isComplex()) {
                if (ctx.isPixel()) {
                    this.emitChar(':');
                    this.emitKeyword(fn.semantic || 'SV_Target0');
                }
            }
            this.emitNewline();
            this.emitBlock(ctx, fn.impl);
        }
        this.end();
    }
    emitAttributes(ctx, attrs) {
        attrs?.forEach(attr => {
            this.emitChar(`[`);
            this.emitNoSpace();
            this.emitKeyword(attr.name);
            this.emitNoSpace();
            if (attr.args) {
                this.emitChar('(');
                this.emitNoSpace();
                this.emitExpressionList(ctx, attr.args);
                this.emitChar(')');
                this.emitNoSpace();
            }
            this.emitChar(`]`);
            this.emitNewline();
        });
    }
    emitRegularFunction(ctx, fn) {
        if (!fn) {
            return;
        }
        const { def } = fn;
        const { typeName } = this.resolveType(ctx, def.returnType);
        this.begin();
        {
            this.emitAttributes(ctx, fn.attrs);
            this.emitKeyword(typeName);
            this.emitKeyword(fn.name);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitParams(ctx, def.params);
            this.emitChar(')');
            this.emitNewline();
            if (fn.impl)
                this.emitBlock(ctx, fn.impl);
            else
                this.emitChar(';');
        }
        this.end();
    }
    emitFunction(ctx, decl) {
        if (!decl) {
            return;
        }
        const sign = _lib_fx_analisys_helpers_fn__WEBPACK_IMPORTED_MODULE_3__.fn.signature(decl.def);
        if (ctx.has(sign)) {
            return;
        }
        ctx.add(sign);
        const isEntry = (this.depth() == 0) && !ctx.isRaw();
        if (isEntry)
            this.emitEntryFunction(ctx, decl);
        else
            this.emitRegularFunction(ctx, decl);
    }
    emitCollector(ctx, collector) {
        this.begin();
        for (let instr of collector.instructions) {
            this.emit(ctx, instr);
        }
        this.end();
    }
    emitTypeDecl(ctx, decl) {
        this.resolveType(ctx, decl.type);
    }
    emitTypedef(ctx, def) {
        // nothing todo because current implementation implies
        // immediate target type substitution 
        return;
        /*
            this.emitKeyword('typedef');
            // todo: add support for typedefs like:
            //  typedef const float4 T;
            //          ^^^^^^^^^^^^
            this.emitKeyword(def.type.name);
            this.emitKeyword(def.alias);
            this.emitChar(';');
            this.emitNewline();
        */
    }
    emitForInit(ctx, init) {
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(init)) {
            this.emitExpression(ctx, init);
        }
        else {
            this.emitVariable(ctx, init);
        }
    }
    emitForStmt(ctx, stmt) {
        //for(int i = 0;i < 4;++ i)
        //{
        //  ...
        //}
        this.emitKeyword('for');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitForInit(ctx, stmt.init);
        this.emitChar(';');
        this.emitExpression(ctx, stmt.cond);
        this.emitChar(';');
        this.emitExpression(ctx, stmt.step);
        this.emitChar(')');
        if (stmt.body.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StmtBlock)
            this.emitNewline();
        this.emitStmt(ctx, stmt.body);
    }
    emitExpression(ctx, expr) {
        if (!expr) {
            return;
        }
        /*
        | ICastExprInstruction
        | ILogicalExprInstruction
        | IPostfixIndexInstruction
        | ISamplerStateBlockInstruction
        */
        switch (expr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ArithmeticExpr:
                return this.emitArithmetic(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_AssignmentExpr:
                return this.emitAssigment(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixPointExpr:
                return this.emitPostfixPoint(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IdExpr:
                return this.emitIdentifier(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionCallExpr:
                return this.emitFCall(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ConstructorCallExpr:
                return this.emitCCall(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FloatExpr:
                return this.emitFloat(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IntExpr:
                return this.emitInteger(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BoolExpr:
                return this.emitBool(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StringExpr:
                return this.emitString(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexExpr:
                return this.emitComplexExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CompileExpr:
                return this.emitCompile(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ConditionalExpr:
                return this.emitConditionalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_RelationalExpr:
                return this.emitRelationalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_LogicalExpr:
                return this.emitLogicalExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_UnaryExpr:
                return this.emitUnaryExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixArithmeticExpr:
                return this.emitPostfixArithmetic(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_InitExpr:
                return this.emitInitExpr(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CastExpr:
                return this.emitCast(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BitwiseExpr:
                return this.emitBitwise(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixIndexExpr:
                return this.emitPostfixIndex(ctx, expr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StateBlockExpr:
                return this.emitStateBlockExpr(ctx, expr);
            default:
                this.emitLine(`/* ... unsupported expression '${expr.instructionName}' ... */`);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported instruction found: ${expr.instructionName}`);
        }
    }
    emitFloat(ctx, lit) {
        const sval = String(lit.value);
        this.emitKeyword(sval);
        (sval.indexOf('.') === -1) && this.emitChar('.');
        this.emitChar('f');
    }
    emitBool(ctx, lit) {
        this.emitKeyword(lit.value ? 'true' : 'false');
    }
    emitString(ctx, lit) {
        this.emitKeyword(lit.value);
    }
    emitComplexExpr(ctx, complex) {
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, complex.expr);
        this.emitChar(')');
    }
    emitConditionalExpr(ctx, cond) {
        this.emitExpression(ctx, cond.condition);
        this.emitKeyword('?');
        this.emitExpression(ctx, cond.left);
        this.emitKeyword(':');
        this.emitExpression(ctx, cond.right);
    }
    emitInteger(ctx, lit) {
        const int = lit;
        this.emitKeyword(`${int.heximal ? '0x' + int.value.toString(16).toUpperCase() : int.value.toFixed(0)}${!int.signed ? 'u' : ''}`);
    }
    emitRelationalExpr(ctx, rel) {
        this.emitExpression(ctx, rel.left);
        this.emitKeyword(rel.operator);
        this.emitExpression(ctx, rel.right);
    }
    emitLogicalExpr(ctx, rel) {
        this.emitExpression(ctx, rel.left);
        this.emitKeyword(rel.operator);
        this.emitExpression(ctx, rel.right);
    }
    emitUnaryExpr(ctx, unary) {
        this.emitChar(unary.operator);
        this.emitExpression(ctx, unary.expr);
    }
    emitPostfixArithmetic(ctx, par) {
        this.emitExpression(ctx, par.expr);
        this.emitChar(par.operator);
    }
    emitPostfixIndex(ctx, pfidx) {
        this.emitExpression(ctx, pfidx.element);
        this.emitChar('[');
        this.emitNoSpace();
        this.emitExpression(ctx, pfidx.index);
        this.emitChar(']');
    }
    emitStateBlockExpr(ctx, stblk) {
        if (ctx.mode !== 'raw') {
            // no need to emit state blocks in plain hlsl shaders
            return;
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)('not implemented');
    }
    emitBreakStmt(ctx, brk) {
        this.emitLine(`${brk.operator};`);
    }
    emitExpressionList(ctx, list) {
        list?.forEach((expr, i) => {
            this.emitExpression(ctx, expr);
            (i != list.length - 1) && this.emitChar(',');
        });
    }
    emitParam(ctx, param) {
        this.emitVariable(ctx, param);
    }
    emitParams(ctx, params) {
        params.filter(p => !this.options.omitEmptyParams || p.type.size !== 0).forEach((param, i, list) => {
            this.emitParam(ctx, param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    emitInitExpr(ctx, init) {
        if (init.args.length > 1) {
            this.emitChar('{');
            this.emitNoSpace();
            this.emitExpressionList(ctx, init.args);
            this.emitChar('}');
            return;
        }
        this.emitExpression(ctx, init.args[0]);
    }
    emitCast(ctx, cast) {
        if (cast.isUseless()) {
            return;
        }
        this.emitChar('(');
        this.emitNoSpace();
        const { typeName } = this.resolveType(ctx, cast.type);
        this.emitKeyword(typeName);
        this.emitChar(')');
        this.emitNoSpace();
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, cast.expr);
        this.emitChar(')');
    }
    emitBitwise(ctx, bwise) {
        this.emitExpression(ctx, bwise.left);
        this.emitKeyword(bwise.operator);
        this.emitSpace();
        this.emitExpression(ctx, bwise.right);
    }
    emitArithmetic(ctx, arthm) {
        this.emitExpression(ctx, arthm.left);
        this.emitKeyword(arthm.operator);
        this.emitSpace();
        this.emitExpression(ctx, arthm.right);
    }
    emitAssigment(ctx, asgm) {
        this.emitExpression(ctx, asgm.left);
        this.emitKeyword(asgm.operator);
        this.emitSpace();
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(asgm.right));
        this.emitExpression(ctx, asgm.right);
    }
    emitPostfixPoint(ctx, pfxp) {
        // todo: skip brackets wherever possible to avoid exprs like (a).x;
        if (pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IdExpr ||
            pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PostfixPointExpr) {
            this.emitExpression(ctx, pfxp.element);
        }
        else {
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, pfxp.element);
            this.emitChar(')');
        }
        this.emitChar('.');
        this.emitChar(pfxp.postfix.name);
    }
    emitCbufferField(ctx, field) {
        this.emitVariable(ctx, field);
        this.emitChar(';');
        this.emitChar('\t');
        this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);
    }
    emitCbuffer(ctx, cbuf) {
        if (!ctx.has(cbuf.name)) {
            ctx.addCbuffer(cbuf);
            this.begin();
            this.emitComment(`size: ${cbuf.type.size}`);
            this.emitKeyword('cbuffer');
            if (cbuf.id) {
                this.emitKeyword(cbuf.name);
            }
            const reg = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.resolveRegister(cbuf);
            if (reg.index !== -1) {
                this.emitChar(':');
                this.emitKeyword('register');
                this.emitChar('(');
                this.emitNoSpace();
                this.emitKeyword(`${reg.type}${reg.index}`);
                this.emitNoSpace();
                this.emitChar(')');
            }
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                cbuf.type.fields.forEach(field => {
                    this.emitCbufferField(ctx, field);
                });
            }
            this.pop();
            this.emitChar('}');
            this.emitChar(';');
            // emit annotation?
            this.end();
        }
        ctx.linkCbuffer(cbuf.name);
    }
    // request global declaration for local identifier
    emitGlobal(ctx, decl) {
        const { name, type } = decl;
        const isUniformArg = this.isMain() && decl.isParameter() && type.isUniform();
        if (decl.isGlobal() /* || isUniformArg*/) {
            if (decl.usageFlags & _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_4__.EVariableUsageFlags.k_Cbuffer) {
                const cbufType = decl.parent;
                const cbuf = cbufType.parent;
                this.begin();
                this.emitCbuffer(ctx, cbuf);
                this.end();
            }
            else if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_9__.isTexture(type)) {
                this.begin();
                this.emitTexture(ctx, decl);
                this.end();
            }
            else {
                this.begin();
                this.emitGlobalVariable(ctx, decl);
                this.end();
            }
        }
    }
    emitIdentifier(ctx, id) {
        const { decl, name } = id;
        this.emitGlobal(ctx, decl);
        this.emitKeyword(name);
    }
    emitCCall(ctx, call) {
        const args = call.args;
        const { typeName } = this.resolveType(ctx, call.ctor);
        this.emitKeyword(typeName);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, args);
        this.emitChar(')');
    }
    // todo: remove hack with rename mutator
    emitFCall(ctx, call, rename = decl => decl.name) {
        const { decl, args, callee } = call;
        if (decl.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemFunctionDecl) {
            this.emitFunction(ctx, decl);
        }
        if (callee) {
            this.emitExpression(ctx, callee);
            this.emitChar('.');
            this.emitNoSpace();
        }
        this.emitKeyword(rename(decl));
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionList(ctx, args);
        this.emitChar(')');
    }
    emitReturnStmt(ctx, stmt) {
        this.emitKeyword('return');
        this.emitSpace();
        this.emitExpression(ctx, stmt.expr);
        this.emitChar(';');
    }
    emitExpressionStmt(ctx, stmt) {
        this.emitExpression(ctx, stmt.expr);
        this.emitChar(';');
    }
    emitLocalVariable(ctx, stmt) {
        this.emitVariable(ctx, stmt);
        this.emitChar(';');
    }
    emitGlobalVariable(ctx, decl) {
        if (ctx.has(decl.name)) {
            return;
        }
        ctx.add(decl.name);
        this.begin();
        this.emitVariable(ctx, decl);
        this.emitChar(';');
        this.end();
    }
    emitComplexField(ctx, instr) {
        console.assert(instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl);
        this.emitVariable(ctx, instr);
        this.emitChar(';');
    }
    emitDeclStmt(ctx, stmt) {
        stmt.declList.forEach(decl => {
            console.assert(decl.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl);
            this.emitLocalVariable(ctx, decl);
        });
    }
    /*
        | IStmtBlockInstruction
        | IWhileStmtInstruction
        | IForStmtInstruction;
    */
    emitStmt(ctx, stmt) {
        switch (stmt.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_DeclStmt:
                this.emitDeclStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ExprStmt:
                this.emitExpressionStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ReturnStmt:
                this.emitReturnStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SemicolonStmt:
                this.emitChar(';');
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IfStmt:
                this.emitIfStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_StmtBlock:
                this.emitBlock(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ForStmt:
                this.emitForStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_BreakStmt:
                this.emitBreakStmt(ctx, stmt);
                break;
            default:
                this.emitLine(`/* ... unsupported stmt '${stmt.instructionName}' .... */`);
                console.warn(`unknown stmt found: '${stmt.instructionName}'`);
        }
    }
    emitBlock(ctx, blk) {
        // if (!blk.stmtList.length)
        // {
        //     this.emitChar(';');
        //     return;
        // }
        this.emitChar('{');
        this.push();
        blk.stmtList.forEach(stmt => (this.emitStmt(ctx, stmt), this.emitNewline()));
        this.pop();
        this.emitChar('}');
    }
    emitPass(ctx, pass) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        this.emitPassBody(ctx, pass);
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitPassBody(ctx, pass) {
        // TODO: replace with emitCompile();
        if (pass.vertexShader) {
            this.emitFunction(ctx, pass.vertexShader);
            this.emitKeyword('VertexShader');
            this.emitKeyword('=');
            this.emitKeyword('compile');
            this.emitKeyword(pass.vertexShader.name);
            this.emitChar('()');
            this.emitChar(';');
            this.emitNewline();
        }
        if (pass.pixelShader) {
            this.emitFunction(ctx, pass.pixelShader);
            this.emitKeyword('PixelShader');
            this.emitKeyword('=');
            this.emitKeyword('compile');
            this.emitKeyword(pass.pixelShader.name);
            this.emitChar('()');
            this.emitChar(';');
            this.emitNewline();
        }
        if (pass.renderStates) {
            for (let key in pass.renderStates) {
                const state = pass.renderStates[key];
                if (state != _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__.ERenderStateValues.UNDEF) {
                    this.emitKeyword(_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_5__.ERenderStates[Number(key)]);
                    this.emitChar('=');
                    this.emitKeyword(_lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_6__.ERenderStateValues[state]);
                    this.emitChar(';');
                    this.emitNewline();
                }
            }
        }
        this.emitNewline();
        // mwalk(pass.renderStates, (val, key) => {
        //     console.log(ERenderStates[key], ERenderStateValues[val]);
        // });
    }
    emit(ctx, instr) {
        if (!instr) {
            // TODO: emit error.
            this.emitLine('/* ... empty instruction .... */');
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(instr)) {
            this.emitExpression(ctx, instr);
            return this;
        }
        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isStatement(instr)) {
            this.emitStmt(ctx, instr);
            return this;
        }
        //
        // Other types
        //
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_FunctionDecl:
                this.emitFunction(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_CbufferDecl:
                this.emitCbuffer(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableDecl:
                this.emitGlobalVariable(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_Collector:
                this.emitCollector(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_TypeDecl:
                this.emitTypeDecl(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_TypedefDecl:
                this.emitTypedef(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_ComplexType:
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_VariableType:
                // todo: addComplexType ?
                this.emitComplexTypeDecl(ctx, instr);
                break;
            default:
                this.emitLine(`/* ... unsupported instruction '${instr.instructionName}' .... */`);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported instruction found: ${instr.instructionName}`);
        }
        return this;
    }
    static translate(instr, ctx = new CodeContext) {
        return CodeEmitter.cEmitter.emit(ctx, instr).toString();
    }
    static translateDocument(document, ctx = new CodeContext) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return '';
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document.root)) {
            return '';
        }
        return CodeEmitter.translate(document.root, ctx);
    }
}
CodeEmitter.cEmitter = new CodeEmitter({ omitEmptyParams: true });
// export function emit(instr: IInstruction): string {
//     return CodeEmitter.translate(instr);
// }


/***/ }),

/***/ "h9Zj":
/*!*********************************************!*\
  !*** ./src/lib/fx/translators/FxEmitter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FxConvolutionContext": () => (/* binding */ FxConvolutionContext),
/* harmony export */   "FxEmitter": () => (/* binding */ FxEmitter)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CodeConvolutionEmitter */ "jYc8");




class FxConvolutionContext extends _CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_3__.CodeConvolutionContext {
    constructor() {
        super(...arguments);
        this.technique = null;
    }
    tech() {
        return this.technique;
    }
    beginTechnique(tech) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(this.technique));
        this.technique = tech;
    }
    endTechnique() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(this.technique));
        this.technique = null;
    }
}
class FxEmitter extends _CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_3__.CodeConvolutionEmitter {
    emitRoutineProperty(ctx, name, routine) {
        this.emitKeyword(name);
        this.emitKeyword('=');
        this.emitSpace();
        this.emitCompile(ctx, routine);
        this.emitChar(';');
        this.emitNewline();
    }
    emitStringProperty(ctx, name, id) {
        this.emitKeyword(name),
            this.emitKeyword('='),
            this.emitKeyword(id),
            this.emitChar(';'),
            this.emitNewline();
    }
    emitSpawnStmt(ctx, stmt) {
        const fx = ctx.tech();
        const init = stmt.scope.findFunction(stmt.name, [fx.particle, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_1__.T_INT, ...stmt.args.map(a => a.type)]);
        this.emitFunction(ctx, init);
        this.emitKeyword(`spawn(${stmt.count})`);
        this.emitKeyword(stmt.name);
        this.emitChar('(');
        this.emitNoSpace();
        stmt.args.forEach((arg, i, list) => {
            this.emitExpression(ctx, arg);
            (i + 1 != list.length) && this.emitChar(',');
        });
        this.emitChar(')');
        this.emitChar(';');
    }
    emitDrawStmt(ctx, stmt) {
        this.emitKeyword(`draw`);
        this.emitKeyword(stmt.name);
        this.emitChar('(');
        this.emitNoSpace();
        stmt.args.forEach((arg, i, list) => {
            this.emitExpression(ctx, arg);
            (i + 1 != list.length) && this.emitChar(',');
        });
        this.emitChar(')');
        this.emitChar(';');
    }
    emitPartFxDecl(ctx, fx) {
        ctx.beginTechnique(fx);
        this.begin();
        {
            this.emitKeyword('partFx');
            fx.name && this.emitKeyword(fx.name);
            fx.semantic && this.emitSemantic(ctx, fx.semantic);
            fx.annotation && this.emitAnnotation(ctx, fx.annotation);
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                fx.capacity && this.emitStringProperty(ctx, 'Capacity', String(fx.capacity));
                fx.spawnRoutine && this.emitRoutineProperty(ctx, 'SpawnRoutine', fx.spawnRoutine);
                fx.initRoutine && this.emitRoutineProperty(ctx, 'InitRoutine', fx.initRoutine);
                fx.updateRoutine && this.emitRoutineProperty(ctx, 'UpdateRoutine', fx.updateRoutine);
                this.emitNewline();
                fx.passes.forEach((pass, i) => (this.emitPartFxPass(ctx, pass),
                    i !== fx.passes.length - 1 && this.emitNewline()));
                this.emitNewline();
                fx.presets.forEach((preset, i) => (this.emitPresetDecl(ctx, preset),
                    i !== fx.presets.length - 1 && this.emitNewline()));
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endTechnique();
    }
    /** @deprecated */
    emitTechniqueDecl(ctx, fx) {
        ctx.beginTechnique(fx);
        this.begin();
        {
            this.emitKeyword('technique');
            fx.name && this.emitKeyword(fx.name);
            fx.semantic && this.emitSemantic(ctx, fx.semantic);
            fx.annotation && this.emitAnnotation(ctx, fx.annotation);
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                this.emitNewline();
                fx.passes.forEach((pass, i) => (this.emitPass(ctx, pass),
                    i !== fx.passes.length - 1 && this.emitNewline()));
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endTechnique();
    }
    emitTechnique11Decl(ctx, fx) {
        console.warn(`emitTechnique11Decl() not implemented`);
    }
    emitPartFxPass(ctx, pass) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        {
            pass.prerenderRoutine && this.emitRoutineProperty(ctx, 'PrerenderRoutine', pass.prerenderRoutine);
            pass.sorting && this.emitStringProperty(ctx, 'Sorting', String(pass.sorting));
            this.emitStringProperty(ctx, 'Geometry', `"${pass.geometry}"`);
            pass.instanceCount !== 1 && this.emitStringProperty(ctx, 'InstanceCount', String(pass.instanceCount));
            super.emitPassBody(ctx, pass);
        }
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitPresetDecl(ctx, preset) {
        this.emitKeyword('preset');
        preset.name && this.emitKeyword(preset.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        {
            preset.props.forEach(prop => {
                this.emitKeyword(prop.id.name);
                this.emitKeyword('=');
                this.emitKeyword('{');
                this.emitExpressionList(ctx, prop.args);
                this.emitKeyword('}');
                this.emitChar(';');
                this.emitNewline();
            });
        }
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }
    emitStmt(ctx, stmt) {
        switch (stmt.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SpawnStmt:
                this.emitSpawnStmt(ctx, stmt);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_DrawStmt:
                this.emitDrawStmt(ctx, stmt);
                break;
            default:
                super.emitStmt(ctx, stmt);
        }
    }
    emit(ctx, instr) {
        if (!instr) {
            return this;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_PartFxDecl:
                this.emitPartFxDecl(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_TechniqueDecl:
                this.emitTechniqueDecl(ctx, instr);
                break;
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_Technique11Decl:
                this.emitTechnique11Decl(ctx, instr);
                break;
            default:
                super.emit(ctx, instr);
        }
        return this;
    }
    static translate(instr, ctx = new FxConvolutionContext) {
        return FxEmitter.fxEmitter.emit(ctx, instr).toString(ctx);
    }
    static translateDocument(document, ctx = new FxConvolutionContext) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return '';
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document.root)) {
            return '';
        }
        return FxEmitter.translate(document.root, ctx);
    }
    static translateTechnique(document, techName, ctx = new FxConvolutionContext) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document)) {
            return '';
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document.root)) {
            return '';
        }
        return FxEmitter.translate(document.root.scope.findTechnique(techName), ctx);
    }
}
FxEmitter.fxEmitter = new FxEmitter({ omitEmptyParams: true });


/***/ }),

/***/ "3KVU":
/*!************************************************!*\
  !*** ./src/lib/fx/translators/FxTranslator.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AUTOGEN_CONTROLS": () => (/* binding */ AUTOGEN_CONTROLS),
/* harmony export */   "AUTOGEN_GLOBALS": () => (/* binding */ AUTOGEN_GLOBALS),
/* harmony export */   "FxTranslator": () => (/* binding */ FxTranslator),
/* harmony export */   "FxTranslatorContext": () => (/* binding */ FxTranslatorContext)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/part/IPartFx */ "j3Uf");
/* harmony import */ var _FxEmitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FxEmitter */ "h9Zj");
/* harmony import */ var _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/Visitors */ "q04y");
/* harmony import */ var _analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../analisys/instructions/VariableDeclInstruction */ "k9uP");









// returns hlsl system type name corresponding to ui type
function typeNameOfUIControl(ctrl) {
    const type = ctrl.type;
    switch (type) {
        case 'color':
            return 'float4';
        case 'int':
        case 'uint':
        case 'float':
        case 'float2':
        case 'float3':
        case 'float4':
            return type;
        default:
            console.assert(false, `unsupported UI type: ${type}`);
    }
    return null;
}
function pushUniq(arr, elem) {
    if (arr.indexOf(elem) == -1)
        arr.push(elem);
}
const camelToSnakeCase = str => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
const isPartId = (p) => (p.semantic === 'PART_ID' || p.name == 'partId') && _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(/u?int/, p.type);
const isSpawnId = (p) => (p.semantic === 'SPAWN_ID' || p.name == 'spawnId') && _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(/u?int/, p.type);
function resolveOptIndices(params, def) {
    return params.map(({ checker }) => def.params.findIndex(checker));
}
function resolveOptArguments(params, def) {
    const indices = resolveOptIndices(params, def);
    const n = indices.filter(i => i !== -1).length;
    const res = new Array(n);
    for (let i = 0; i < indices.length; ++i) {
        const pos = indices[i];
        if (pos !== -1) {
            res[pos] = params[i].name;
        }
    }
    return res;
}
const AUTOGEN_GLOBALS = `AUTOGEN_GLOBALS`;
const AUTOGEN_CONTROLS = `AUTOGEN_CONTROLS`;
class FxTranslatorContext extends _FxEmitter__WEBPACK_IMPORTED_MODULE_5__.FxConvolutionContext {
    constructor() {
        super(...arguments);
        this.techniques = [];
        this.techniques11 = [];
        this.controls = [];
        this.trimeshes = [];
        // todo: use reflection
        this.uniforms = [];
        // todo: use reflection
        this.spawners = [];
    }
    // specific reflection, signature has been already added during global variable processing
    addControl(ctrl) {
        this.controls.push(ctrl);
        return ctrl;
    }
    addTechnique(refl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(refl.name));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.techniques[0]));
        this.add(refl.name);
        this.techniques[0] = refl;
        return refl;
    }
    addTechnique11(refl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(refl.name));
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(this.techniques[0]));
        this.add(refl.name);
        this.techniques11[0] = refl;
        return refl;
    }
    addUniform(uniform) {
        this.uniforms.push(uniform);
        return uniform;
    }
    addTrimesh(mesh) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(mesh.name));
        this.add(mesh.name);
        this.trimeshes.push(mesh);
        return mesh;
    }
    addSpawnCtor(decl) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.has(decl.name));
        this.add(decl.name);
        this.spawners.push(decl);
        return decl;
    }
    linkTrimesh(name) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.has(name));
        // push if not exists
        let sh = this.CSShader;
        if (sh) {
            pushUniq(sh.trimeshes, this.trimeshes.find(t => t.name == name));
        }
    }
    // override CodeEmitterContext::beginCsShader()
    beginCsShader(name, numthreads) {
        const uavs = [];
        const buffers = [];
        const textures = [];
        const trimeshes = [];
        this.CSShader = { name, numthreads, uavs, buffers, textures, trimeshes };
    }
}
class FxTranslator extends _FxEmitter__WEBPACK_IMPORTED_MODULE_5__.FxEmitter {
    /*
        https://help.autodesk.com/view/MAXDEV/2023/ENU/?guid=shader_semantics_and_annotations
        https://help.autodesk.com/view/MAXDEV/2022/ENU/?guid=Max_Developer_Help_3ds_max_sdk_features_rendering_programming_hardware_shaders_shader_semantics_and_annotations_supported_hlsl_shader_annotation_html
    */
    addControl(ctx, src) {
        const { id, type, initExpr, annotation } = src;
        if (!annotation) {
            return false; //TODO: controls without annotations
        }
        if (!src.isGlobal()) {
            return false;
        }
        let length = type.isNotBaseArray() ? type.length : -1;
        for (let i = 0; i < Math.abs(length); ++i) {
            const postfix = `${length > 0 ? `[${i}]` : ``}`;
            const ctrl = {
                name: id.name + postfix,
                type: type.name,
                value: null,
                properties: []
            };
            if (annotation) {
                annotation.decls.forEach(decl => {
                    let propertyName = decl.name;
                    let propertyType = decl.type.name;
                    switch (propertyName) {
                        case 'UIType':
                            propertyName = '__type';
                            break;
                        case 'UIName':
                            propertyName = '__caption';
                            break;
                        case 'UIMin':
                            propertyName = '__min';
                            break;
                        case 'UIMax':
                            propertyName = '__max';
                            break;
                        case 'UIStep':
                            propertyName = '__step';
                            break;
                    }
                    let propertyValue = getPropertyValue(propertyType, decl.initExpr);
                    if (['__min', '__max', '__step'].indexOf(propertyName) !== -1) {
                        if (propertyType === 'float' && ctrl.type === 'float' ||
                            propertyType === 'int' && ctrl.type === 'int' ||
                            propertyType === 'uint' && ctrl.type === 'uint') {
                            ctrl.properties.push({ name: propertyName, type: propertyType, value: propertyValue });
                        }
                    }
                    else {
                        if (propertyName === '__type' && propertyType !== 'string') {
                            return;
                        }
                        if (propertyName === '__type' && propertyValue === 'color') {
                            ctrl.type = 'color';
                            return;
                        }
                        ctrl.properties.push({ name: propertyName, type: propertyType, value: propertyValue });
                    }
                });
            }
            const caption = ctrl.properties.find(prop => prop.name === "__caption");
            if (caption) {
                caption.value += postfix;
            }
            const encodeCtrlExpr = (type, initExpr) => {
                if (initExpr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr) {
                    return encodeInitExprToControlValue(type, initExpr?.args);
                }
                else {
                    return encodeInitExprToControlValue(type, [initExpr]);
                }
            };
            if (length == -1) {
                ctrl.value = encodeCtrlExpr(ctrl.type, src.initExpr);
            }
            else {
                let args = src.initExpr?.args;
                ctrl.value = encodeCtrlExpr(ctrl.type, args[i]);
            }
            ctx.addControl(ctrl);
        }
        return true;
    }
    trimeshBaseName(name) {
        return `trim${name[0].toUpperCase()}${name.slice(1)}`;
    }
    isTrimesh(type) {
        const TRIMESH_NAME = 'TriMesh';
        return !!type?.name.includes(TRIMESH_NAME);
    }
    emitTrimeshDecl(ctx, decl) {
        const type = decl.type;
        const regexp = /^([\w]+)<([\w0-9_]+)>$/;
        const match = type.name.match(regexp);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(match);
        // uavType: match[1],
        // elementType: match[2],
        const elementType = decl.scope.findType(match[2]);
        const name = decl.name;
        const baseName = this.trimeshBaseName(name);
        // todo: check that such a variable doesn't exists
        const vertexCountUName = `${baseName}VertexCount`;
        const faceCountUName = `${baseName}FaceCount`;
        const verticesName = `${baseName}Vertices`;
        const facesName = `${baseName}Faces`;
        const indicesAdjName = `${baseName}GsAdjacency`;
        const faceAdjName = `${baseName}FaceAdjacency`;
        const { typeName: elementTypeName } = this.resolveType(ctx, elementType);
        const vertices = this.emitBuffer(ctx, `StructuredBuffer<${elementTypeName}>`, verticesName, "vertices");
        const faces = this.emitBuffer(ctx, `Buffer<uint3>`, facesName, "faces");
        const indicesAdj = this.emitBuffer(ctx, `Buffer<uint>`, indicesAdjName, "gs like adjacency");
        const faceAdj = this.emitBuffer(ctx, `Buffer<uint>`, faceAdjName, "face adjacency");
        if (!ctx.has(name)) {
            // uniform uint trimesh0_vert_count;
            // uniform uint trimesh0_face_count;
            // StructuredBuffer<Vert> trimesh0_vert;
            // Buffer<uint3> trimesh0_faces;
            // Buffer<uint> trimesh0_faces_adj;
            if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer) {
                ctx.addUniform({ name: vertexCountUName, typeName: 'uint' });
            }
            else {
                this.emitGlobalRaw(ctx, vertexCountUName, `uniform uint ${vertexCountUName}`);
            }
            if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer) {
                ctx.addUniform({ name: faceCountUName, typeName: 'uint' });
            }
            else {
                this.emitGlobalRaw(ctx, faceCountUName, `uniform uint ${faceCountUName}`);
            }
            this.begin();
            this.emitLine(`void ${baseName}_GetDimensions(out uint vertCount, out uint faceCount)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`vertCount = ${vertexCountUName};`);
                this.emitLine(`faceCount = ${faceCountUName};`);
            }
            this.pop();
            this.emitChar('}');
            this.emitNewline();
            this.emitNewline();
            this.emitLine(`${elementTypeName} ${baseName}_LoadVertex(uint vert)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`return ${verticesName}[vert];`);
            }
            this.pop();
            this.emitChar('}');
            this.emitNewline();
            this.emitNewline();
            this.emitLine(`uint3 ${baseName}_LoadFace(uint face)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`return ${facesName}[face];`);
            }
            this.pop();
            this.emitChar('}');
            this.emitNewline();
            this.emitNewline();
            this.emitLine(`void ${baseName}_LoadGSAdjacency(uint face, out uint vertices[6])`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint offset = face * 6u;`);
                this.emitLine(`vertices[0] = ${indicesAdjName}[offset];`);
                this.emitLine(`vertices[1] = ${indicesAdjName}[offset + 1];`);
                this.emitLine(`vertices[2] = ${indicesAdjName}[offset + 2];`);
                this.emitLine(`vertices[3] = ${indicesAdjName}[offset + 3];`);
                this.emitLine(`vertices[4] = ${indicesAdjName}[offset + 4];`);
                this.emitLine(`vertices[5] = ${indicesAdjName}[offset + 5];`);
            }
            this.pop();
            this.emitChar('}');
            this.emitLine(`void ${baseName}_LoadFaceAdjacency(uint face, out uint faces[3])`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint offset = face * 3u;`);
                this.emitLine(`faces[0] = ${faceAdjName}[offset];`);
                this.emitLine(`faces[1] = ${faceAdjName}[offset + 1];`);
                this.emitLine(`faces[2] = ${faceAdjName}[offset + 2];`);
            }
            this.pop();
            this.emitChar('}');
            this.end();
            // let resourcePath = null;
            // let resource = decl.annotation.decls.find(({ name }) => name == 'resource');
            // if (resource && resource.type.name == 'string') {
            //     // '<this>' resource value means "this" resource
            //     resourcePath = (resource.initExpr.args[0] as StringInstruction).value.slice(1, -1); // remove quotes
            // }
            const mesh = {
                name,
                vertexCountUName,
                faceCountUName,
                verticesName,
                facesName,
                indicesAdjName,
                faceAdjName
            };
            ctx.addTrimesh(mesh);
            let value = decl.annotation.decls.find(({ name }) => (name == 'name' || name == 'ResourceName'))
                ?.initExpr?.value;
            value = value?.slice(1, -1) || null;
            const control = { name, type: 'mesh', value, properties: [] };
            ctx.addControl(control);
        }
        ctx.linkTrimesh(name);
    }
    emitTriMeshCall(ctx, call) {
        switch (call.decl.name) {
            case 'LoadFace':
            case 'LoadVertex':
            case 'LoadGSAdjacency':
            case 'LoadFaceAdjacency':
            case 'GetDimensions':
                {
                    // note: it makes imporsible to pass tri meshes as function arguments
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(call.callee.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_IdExpr);
                    const id = call.callee;
                    this.emitGlobalVariable(ctx, id.decl);
                    this.emitKeyword(`${this.trimeshBaseName(id.name)}_${call.decl.name}`);
                    this.emitNoSpace();
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitExpressionList(ctx, call.args);
                    this.emitChar(')');
                }
                break;
            default:
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
        }
    }
    emitFCall(ctx, call, rename) {
        if (this.isTrimesh(call.callee?.type)) {
            this.emitTriMeshCall(ctx, call);
            return;
        }
        super.emitFCall(ctx, call, rename);
    }
    emitGlobalVariable(ctx, decl) {
        // same convolution as in CodeConvolutionEmitter::emitGlobalVariable()
        // convolute here in order to no print variables from includes
        if (this.convoluteToInclude(ctx, decl)) {
            return;
        }
        const { type } = decl;
        // trimesh use builtin check of context existance
        // note: must be counted as ctx.addTrimesh() (not just ctx.add())
        if (this.isTrimesh(decl.type)) {
            this.emitTrimeshDecl(ctx, decl);
            return;
        }
        // same check as in CodeEmitter::emitGlobalVariable();
        if (ctx.has(decl.name)) {
            return;
        }
        if (this.addControl(ctx, decl)) {
            this.emitControlVariable(ctx, decl);
            ctx.add(decl.name);
            return;
        }
        const isUniform = type.isUniform() ||
            (!type.isStatic() && decl.isGlobal() &&
                !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isSamplerState(type) &&
                !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isBuffer(type) &&
                !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isUAV(type) &&
                !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isTexture(type));
        if (isUniform) {
            this.emitUniformVariable(ctx, decl);
            ctx.add(decl.name);
            return;
        }
        // fallback to stanalone printing
        super.emitGlobalVariable(ctx, decl);
    }
    emitControlVariable(ctx, decl, rename) {
        if (!ctx.opts.uiControlsGatherToDedicatedConstantBuffer) {
            // quick way to promote uniform qualifier to GLSL code
            this.emitKeyword('uniform');
            this.emitVariableNoInit(ctx, decl, rename);
            this.emitChar(';');
        }
    }
    emitUniformVariable(ctx, decl) {
        const KNOWN_EXTERNAL_GLOBALS = [
            'ELAPSED_TIME',
            'ELAPSED_TIME_LEVEL',
            'FRAME_NUMBER',
            'PARENT_POSITION',
            'MODEL_MATRIX',
            'MODEL_VIEW_PROJECTION_MATRIX',
            'CAMERA_POSITION',
            'VIEW_MATRIX',
            'VIEW_PROJECTION_MATRIX',
            'PROJECTION_MATRIX',
        ];
        const semantic = decl.semantic || camelToSnakeCase(decl.name).toUpperCase();
        if (!!(decl.usageFlags & _analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_7__.EVariableUsageFlags.k_Argument)) {
            // todo: set TRUE by default (!)
            if (ctx.opts.argUniformsToDedicatedConstantBuffer || true) {
            }
        }
        if (!KNOWN_EXTERNAL_GLOBALS.includes(semantic)) {
            // super.emitVariable(ctx, decl);
            console.warn(`Unsupported uniform has been used: ${decl.toCode()} (${decl.usageFlags}).`);
            // return;
        }
        const isGlobal = true; // global update required
        const isLocal = false; // per object update required
        if (!ctx.opts.globalUniformsGatherToDedicatedConstantBuffer && isGlobal) {
            super.emitVariable(ctx, decl);
            this.emitChar(';');
            return;
        }
        if (isGlobal) {
            let { name, semantic, type: { name: typeName, length } } = decl;
            if (!decl.type.isNotBaseArray())
                length = -1;
            const uniform = { name, semantic, typeName, length };
            ctx.addUniform(uniform);
        }
    }
    // todo: remove hack with rename mutator
    // emitVariable(ctx: ContextT, decl: IVariableDeclInstruction, rename?: (decl: IVariableDeclInstruction) => string) {
    //     const { type } = decl;
    //     super.emitVariable(ctx, decl, rename);
    // }
    emitTexture(ctx, decl) {
        const { name, type } = decl;
        if (!ctx.has(name)) {
            let value = decl.annotation?.decls.find(({ name }) => (name == 'name' || name == 'ResourceName'))
                ?.initExpr?.value;
            value = value?.slice(1, -1) || null;
            const control = { name, type: 'texture2d', value, properties: [] };
            ctx.addControl(control);
        }
        super.emitTexture(ctx, decl);
    }
    emitSpawnStmt(ctx, stmt) {
        const fx = ctx.tech();
        // looking for:
        // Init(out Part part, int partId: PART_ID, int spawnId: SPAWN_ID, ...parameters)
        // Init(out Part part, int partId: PART_ID, ...parameters)
        // Init(out Part part, ...parameters)
        let argsList = [[/u?int/, /u?int/], [/u?int/], []]
            .map(v => [fx.particle, ...v, ...stmt.args.map(a => a.type)]);
        let init = null;
        for (const args of argsList) {
            init = stmt.scope.findFunction(stmt.name, args);
            if (init) {
                break;
            }
        }
        if (!init) {
            for (const args of argsList) {
                console.error(`could not find spawn inititalizer: ${stmt.name}(${args.map(a => `${a}`).join(', ')})`);
            }
            return;
        }
        if (!ctx.has(init.name)) {
            ctx.addSpawnCtor(init);
            const guid = ctx.spawners.indexOf(init) + 1;
            this.emitSpawnOperator(ctx, guid, init);
        }
        const guid = ctx.spawners.indexOf(init) + 1;
        this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitKeyword(`(uint)`);
        this.emitNoSpace();
        this.emitChar('(');
        this.emitExpression(ctx, stmt.count);
        this.emitChar(')');
        if (stmt.args.length) {
            this.emitChar(',');
            this.emitExpressionList(ctx, stmt.args);
        }
        this.emitChar(')');
        this.emitChar(';');
        this.emitNewline();
        // super.emitSpawnStmt(stmt);
    }
    emitDrawStmt(ctx, { name, args }) {
        const fx = ctx.tech(); //<IPartFxInstruction>pass.parent;
        const pass = fx.passes.find(pass => pass.name == name);
        if (!pass) {
            console.warn(`pass<${name}> for draw operator has not been found.`);
            return;
        }
        const i = fx.passes.indexOf(pass);
        if (!ctx.has(name)) {
            ctx.add(name);
            const prerenderFn = pass.prerenderRoutine.function;
            this.emitFunction(ctx, prerenderFn);
            this.emitPrerenderRoutune(ctx, pass, i);
        }
        this.emitKeyword(`${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}`);
        this.emitChar(`(`);
        this.emitNoSpace();
        this.emitExpressionList(ctx, args);
        this.emitChar(`)`);
        this.emitChar(';');
        this.emitNewline();
    }
    emitResetShader(ctx) {
        const name = FxTranslator.CS_PARTICLE_RESET_ROUTINE;
        const numthreads = [64, 1, 1];
        const fx = ctx.tech();
        const capacity = fx.capacity;
        ctx.beginCsShader(name, numthreads);
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint tid = DTid.x;`);
                this.emitLine(`if (tid >= ${capacity}) return;`);
                this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);
                this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[tid] = tid;`);
                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);
                this.emitLine(`${FxTranslator.UAV_STATES}[tid] = 0;`);
                const { typeName: partType } = this.resolveType(ctx, fx.particle);
                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);
                this.emitLine(`${partType} Particle;`);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(fx.particle.isComplex());
                fx.particle.fields.forEach(({ name, type }) => {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(type.length >= 1);
                    let zero = (0,_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isFloatBasedType)(type) ? '0.f' : (0,_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isBoolBasedType)(type) ? 'false' : '0';
                    if (type.length === 1) {
                        this.emitLine(`Particle.${name} = ${zero};`);
                    }
                    else {
                        this.emitLine(`Particle.${name} = ${type.name}(${Array(type.length).fill(zero).join(', ')});`);
                    }
                });
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[tid] = Particle;`);
                // reset emitter if required
                const spawnFn = fx.spawnRoutine.function;
                if (spawnFn.def.params.length > 0) {
                    const p0 = spawnFn.def.params[0];
                    this.emitLine(`if (tid == 0)`);
                    this.emitChar('{');
                    this.push();
                    {
                        this.emitUav(ctx, `RWStructuredBuffer<${p0.type.name}>`, `${FxTranslator.UAV_SPAWN_EMITTER}`, FxTranslator.UAV_SPAWN_EMITTER_DESCRIPTION);
                        this.emitLine(`${p0.type.name} ${p0.name};`);
                        if (p0.type.isComplex()) {
                            for (const field of p0.type.fields) {
                                if (field.type.isComplex()) {
                                    // todo: add support
                                    continue;
                                }
                                if (field.initExpr) {
                                    this.emitKeyword(`${p0.name}.${field.name} =`);
                                    this.emitExpression(ctx, field.initExpr);
                                    this.emitChar(';');
                                    this.emitNewline();
                                }
                                else {
                                    this.emitKeyword(`${p0.name}.${field.name} =`);
                                    this.emitKeyword(`(${field.type.name})0`);
                                    this.emitChar(';');
                                    this.emitNewline();
                                }
                            }
                        }
                        else {
                            // todo: add support of system types
                        }
                        this.emitLine(`${FxTranslator.UAV_SPAWN_EMITTER}[0] = ${p0.name};`);
                    }
                    this.pop();
                    this.emitChar('}');
                }
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endCsShader();
    }
    // TOOD: sync groupSize with value used inside the emitInitShader();
    emitSpawnOperator(ctx, guid, ctor, groupSize = 64) {
        this.begin();
        {
            this.emitKeyword('void');
            this.emitKeyword(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}${guid}__`);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitKeyword(`uint nPart`);
            const optParams = [
                { name: `Particle`, checker: () => true },
                { name: `PartId`, checker: isPartId },
                { name: `SpawnId`, checker: isSpawnId }
            ];
            let optArgs = [];
            if (ctor) {
                optArgs = resolveOptArguments(optParams, ctor.def);
                if (ctor.def.params.length > optArgs.length) {
                    this.emitChar(',');
                    this.emitParams(ctx, ctor.def.params.slice(optArgs.length));
                }
            }
            this.emitChar(')');
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);
                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);
                this.emitLine(`int nGroups = (int)ceil((float)nPart / ${groupSize}.f);`);
                this.emitLine(`uint RequestId;`);
                this.emitLine(`// layout: [ uint GroupCountX, uint GroupCountY, uint GroupCountZ ]`);
                this.emitLine(`InterlockedAdd(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0], nGroups, RequestId);`);
                this.emitLine(`for (int i = 0; i < nGroups; ++i)`);
                this.emitChar(`{`);
                this.push();
                {
                    // params
                    const request = `${FxTranslator.UAV_CREATION_REQUESTS}[RequestId]`;
                    this.emitLine(`${request}.count = min(nPart, ${groupSize}u);`);
                    this.emitLine(`${request}.offset = ${groupSize}u * i;`);
                    this.emitLine(`${request}.type = ${guid}u;`);
                    if (ctor) {
                        const params = ctor.def.params;
                        let nfloat = 0;
                        // skip first two arguments
                        params.slice(optArgs.length).forEach(param => {
                            let type = param.type;
                            if (type.isComplex()) {
                                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported', type.toCode());
                            }
                            let n = type.size / _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT.size;
                            for (let i = 0; i < n; ++i) {
                                this.emitLine(`${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}] = asfloat(${param.name}${type.isArray() ? `[${i % 4}]` : ``});`);
                                nfloat++;
                            }
                        });
                    }
                    this.emitLine(`nPart -= ${groupSize}u;`);
                    this.emitLine(`RequestId += 1;`);
                }
                this.pop();
                this.emitChar(`}`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
    }
    emitGlobalRaw(ctx, name, content) {
        if (ctx.has(name)) {
            return;
        }
        ctx.add(name);
        this.begin();
        this.emitChar(`${content};`);
        this.end();
    }
    emitSpawnShader(ctx) {
        const fx = ctx.tech();
        if (!fx.spawnRoutine) {
            return null;
        }
        const spawnFn = fx.spawnRoutine.function;
        const elapsedTime = fx.scope.findVariable('elapsedTime');
        const name = FxTranslator.CS_PARTICLE_SPAWN_ROUTINE;
        const numthreads = [1, 1, 1];
        ctx.beginCsShader(name, numthreads);
        this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);
        this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);
        if (fx.initRoutine) {
            // default spawn op needed only if regulat emission is used
            this.emitSpawnOperator(ctx, 0, null);
        }
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`if (DTid.x != 0u) return;`);
                this.emitNewline();
                this.emitLine(`// usage of 4th element of ${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS} as temp value of number of particles`);
                this.emitFunction(ctx, spawnFn);
                if (elapsedTime) {
                    this.emitGlobal(ctx, elapsedTime);
                }
                else {
                    // IP: remove this hack
                    this.emitGlobalRaw(ctx, 'elapsedTime', 'uniform float elapsedTime');
                }
                // todo: move to dispatch arguments reset routine
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[0] = 0u;`);
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[1] = 1u;`);
                this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[2] = 1u;`);
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(spawnFn.def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_VOID)) {
                    if (spawnFn.def.params.length == 1) {
                        const p0 = spawnFn.def.params[0];
                        this.emitUav(ctx, `RWStructuredBuffer<${p0.type.name}>`, `${FxTranslator.UAV_SPAWN_EMITTER}`, FxTranslator.UAV_SPAWN_EMITTER_DESCRIPTION);
                        this.emitChar('{');
                        this.push();
                        this.emitLine(`${p0.type.name} ${p0.name} = ${FxTranslator.UAV_SPAWN_EMITTER}[0];`);
                        this.emitLine(`${spawnFn.name}(${p0.name});`);
                        this.emitLine(`${FxTranslator.UAV_SPAWN_EMITTER}[0] = ${p0.name};`);
                        this.pop();
                        this.emitChar('}');
                    }
                    else {
                        this.emitLine(`${spawnFn.name}();`);
                    }
                }
                else {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(spawnFn.def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT));
                    this.emitLine(`float nPartAddFloat = asfloat(${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3]) + (float)${spawnFn.name}() * elapsedTime;`);
                    this.emitLine(`float nPartAdd = floor(nPartAddFloat);`);
                    // TODO: replace with InterlockedExchange()
                    this.emitLine(`${FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS}[3] = asuint(nPartAddFloat - nPartAdd);`);
                    this.emitLine(`${FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME}0__((uint)nPartAdd);`);
                }
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endCsShader();
    }
    emitEntryParams(ctx, params) {
        // all uniform parameters will be printed as global variables through their id
        params
            // .filter(p => (!this.options.omitEmptyParams || p.type.size !== 0) && !p.type.isUniform())
            .forEach((param, i, list) => {
            this.emitParam(ctx, param);
            (i + 1 != list.length) && this.emitChar(',');
        });
    }
    emitInitShader(ctx) {
        const fx = ctx.tech();
        const initFn = fx.initRoutine?.function;
        const name = FxTranslator.CS_PARTICLE_INIT_ROUTINE;
        const numthreads = [64, 1, 1];
        ctx.beginCsShader(name, numthreads);
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint GroupId = Gid.x;`);
                this.emitLine(`uint ThreadId = GTid.x;`);
                // TODO: emit operator instead!
                this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);
                this.emitLine(`uint nPart = ${FxTranslator.UAV_CREATION_REQUESTS}[GroupId].count;`);
                this.emitNewline();
                this.emitLine(`if (ThreadId >= nPart) return;`);
                this.emitNewline();
                this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);
                this.emitLine(`int n = (int)${FxTranslator.UAV_DEAD_INDICES}.DecrementCounter();`);
                this.emitComment(`a bit confusing way to check for particles running out`);
                this.emitLine(`if (n <= 0)`);
                this.emitChar('{');
                this.push();
                {
                    this.emitComment(`not very beautiful, but a cheap way not to`);
                    this.emitComment(`think about the correctness of this counter`);
                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);
                    this.emitLine('return;');
                }
                this.pop();
                this.emitChar('}');
                this.emitNewline();
                this.emitNewline();
                this.emitLine(`uint PartId = ${FxTranslator.UAV_DEAD_INDICES}[n];`);
                const { typeName: partType } = this.resolveType(ctx, fx.particle);
                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);
                this.emitLine(`${partType} Particle;`);
                // it's ok if here is no init function found
                // it means that generic spawner is used
                if (initFn) {
                    this.emitFunction(ctx, initFn);
                }
                const request = `${FxTranslator.UAV_CREATION_REQUESTS}[GroupId]`;
                this.emitLine(`uint Type = ${request}.type;`);
                this.emitLine(`uint SpawnId = ${request}.offset + ThreadId;`);
                const optParams = [
                    { name: `Particle`, checker: () => true },
                    { name: `PartId`, checker: isPartId },
                    { name: `SpawnId`, checker: isSpawnId }
                ];
                if (initFn) {
                    const optArgs = resolveOptArguments(optParams, initFn.def);
                    this.emitLine(`if (Type == 0u)`);
                    this.emitChar('{');
                    this.push();
                    {
                        this.emitLine(`${initFn.name}(${optArgs.join(', ')});`);
                    }
                    this.pop();
                    this.emitChar('}');
                    this.emitNewline();
                }
                ctx.spawners.forEach((ctor, i) => {
                    this.emitFunction(ctx, ctor);
                    if (initFn || i > 0) {
                        this.emitKeyword(`else`);
                        this.emitSpace();
                    }
                    this.emitLine(`if (Type == ${i + 1}u)`);
                    this.emitChar('{');
                    this.push();
                    {
                        const optArgs = resolveOptArguments(optParams, ctor.def);
                        // TODO: move param unpacking to separate function
                        // unpack arguments
                        let nfloat = 0;
                        let params = ctor.def.params.slice(optArgs.length);
                        params.forEach(param => {
                            this.emitVariable(ctx, param);
                            this.emitChar(';');
                            this.emitNewline();
                            const type = param.type;
                            if (type.isComplex()) {
                                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported', type.toCode());
                            }
                            let interpreter = 'asfloat';
                            if ((0,_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isFloatBasedType)(type)) {
                                interpreter = 'asfloat';
                            }
                            if ((0,_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isIntBasedType)(type)) {
                                interpreter = 'asint';
                            }
                            if ((0,_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.isUintBasedType)(type)) {
                                interpreter = 'asuint';
                            }
                            let n = type.size / _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT.size;
                            for (let i = 0; i < n; ++i) {
                                this.emitLine(`${param.name}${type.isArray() ? `[${i % 4}]` : ``} = ${interpreter}(${request}.payload[${Math.floor(nfloat / 4)}][${nfloat % 4}]);`);
                                nfloat++;
                            }
                            this.emitNewline();
                        });
                        this.emitKeyword(ctor.name);
                        this.emitChar('(');
                        this.emitNoSpace();
                        this.emitKeyword(optArgs.join(', '));
                        if (params.length > 0) {
                            this.emitChar(',');
                            params.forEach((param, i, list) => {
                                this.emitKeyword(param.name);
                                (i + 1 != list.length) && this.emitChar(', ');
                            });
                        }
                        this.emitChar(')');
                        this.emitChar(';');
                        this.emitNewline();
                    }
                    this.pop();
                    this.emitChar('}');
                    this.emitNewline();
                });
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);
                this.emitComment('set particles\'s state as \'Alive\'');
                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);
                this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 1;`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endCsShader();
    }
    emitUpdateShader(ctx) {
        const fx = ctx.tech();
        const updateFn = fx.updateRoutine.function;
        const name = FxTranslator.CS_PARTICLE_UPDATE_ROUTINE;
        const numthreads = [64, 1, 1];
        ctx.beginCsShader(name, numthreads);
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint PartId = DTid.x;`);
                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);
                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);
                this.emitNewline();
                this.emitLine(`[branch]`);
                this.emitLine(`if(!Alive) return;`);
                this.emitNewline();
                const { typeName: partType } = this.resolveType(ctx, fx.particle);
                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);
                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);
                this.emitNewline();
                this.emitFunction(ctx, updateFn);
                this.emitLine(`[branch]`);
                this.emitLine(`if (!${updateFn.name}(Particle${updateFn.def.params.length > 1 ? ', PartId' : ''}))`);
                this.emitChar('{');
                this.push();
                {
                    this.emitUav(ctx, `RWStructuredBuffer<uint>`, FxTranslator.UAV_DEAD_INDICES, FxTranslator.UAV_DEAD_INDICES_DESCRIPTION);
                    this.emitComment('returning the particle index to the list of the dead');
                    this.emitLine(`uint n = ${FxTranslator.UAV_DEAD_INDICES}.IncrementCounter();`);
                    this.emitLine(`${FxTranslator.UAV_DEAD_INDICES}[n] = PartId;`);
                    this.emitNewline();
                    this.emitComment('set particles\'s state as \'dead\'');
                    this.emitLine(`${FxTranslator.UAV_STATES}[PartId] = 0;`);
                    this.emitLine('return;');
                }
                this.pop();
                this.emitChar('}');
                this.emitNewline();
                this.emitNewline();
                this.emitLine(`${FxTranslator.UAV_PARTICLES}[PartId] = Particle;`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        this.emitUav(ctx, `RWStructuredBuffer<${FxTranslator.SPAWN_OPERATOR_TYPE}>`, FxTranslator.UAV_CREATION_REQUESTS, FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION);
        this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS, FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION);
        ctx.endCsShader();
    }
    emitPrerenderRoutune(ctx, pass, i) {
        const fx = ctx.tech();
        const prerenderFn = pass.prerenderRoutine.function;
        const { typeName: prerenderedType } = this.resolveType(ctx, prerenderFn.def.params[1].type);
        const { typeName: partType } = this.resolveType(ctx, fx.particle);
        this.begin();
        {
            this.emitLine(`void ${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}(${partType} Particle)`);
            this.emitChar('{');
            this.push();
            /*
                void __draw_op0(Part Particle)
                {
                    uint PrerenderId = uavPrerendered0.IncrementCounter();
                    uint SerialId = uavSerials0.IncrementCounter();
                    DefaultShaderInput Prerendered;
                    int SortIndex = prerender(Particle, Prerendered);
                    uavSerials0[SerialId] = int2(SortIndex, PrerenderId);
                    uavPrerendered0[PrerenderId] = Prerendered;
                }

                void __draw_op0(Part Particle)
                {
                    uint PrerenderId = uavPrerendered0.IncrementCounter();
                    uint SerialId = uavSerials0.IncrementCounter();
                    for (int InstanceId = 0; InstanceId < 5; ++ InstanceId) {
                        DefaultShaderInput Prerendered;
                        int SortIndex = prerender(Particle, Prerendered, InstanceId);
                        if (InstanceId == 0) {
                            uavSerials0[SerialId] = int2(SortIndex, PrerenderId);
                        }
                        uavPrerendered0[PrerenderId * 5 + InstanceId] = Prerendered;
                    }
                }
            */
            {
                this.emitUav(ctx, `RWStructuredBuffer<${prerenderedType}>`, `${FxTranslator.UAV_PRERENDERED}${i}`);
                if (pass.sorting) {
                    this.emitUav(ctx, `RWStructuredBuffer<int2>`, `${FxTranslator.UAV_SERIALS}${i}`, FxTranslator.UAV_SERIALS_DESCRIPTION);
                }
                this.emitLine(`uint PrerenderId = ${FxTranslator.UAV_PRERENDERED}${i}.IncrementCounter();`);
                if (pass.sorting) {
                    this.emitLine(`uint SerialId = ${FxTranslator.UAV_SERIALS}${i}.IncrementCounter();`);
                }
                if (pass.instanceCount > 1) {
                    this.emitLine(`for(int InstanceId = 0; InstanceId < ${pass.instanceCount}; InstanceId++)`);
                    this.emitChar('{');
                    this.push();
                }
                {
                    this.emitLine(`${prerenderedType} Prerendered;`);
                    const inputIndex = prerenderFn.def.params.findIndex(p => p.type.name === prerenderedType);
                    const partndex = prerenderFn.def.params.findIndex(p => p.type.name === partType);
                    const insidIndex = prerenderFn.def.params.findIndex(p => p.type.name === _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_INT.name); // first int arg index
                    const args = [];
                    args[inputIndex] = `Prerendered`;
                    args[partndex] = `Particle`;
                    if (insidIndex !== -1) {
                        args[insidIndex] = `InstanceId`;
                    }
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(prerenderFn.def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_VOID)) {
                        this.emitLine(`int SortIndex = 0;`);
                        this.emitLine(`${prerenderFn.name}(${args.join(', ')});`);
                    }
                    else {
                        this.emitLine(`int SortIndex = ${prerenderFn.name}(${args.join(', ')});`);
                    }
                    if (pass.sorting) {
                        if (pass.instanceCount > 1) {
                            this.emitLine(`if (InstanceId == 0)`);
                            this.push();
                            this.emitLine(`${FxTranslator.UAV_SERIALS}${i}[SerialId] = int2(SortIndex, PrerenderId);`);
                            this.pop();
                        }
                        else {
                            this.emitLine(`${FxTranslator.UAV_SERIALS}${i}[SerialId] = int2(SortIndex, PrerenderId);`);
                        }
                    }
                    if (pass.instanceCount > 1) {
                        this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}[PrerenderId * ${pass.instanceCount} + InstanceId] = Prerendered;`);
                    }
                    else {
                        this.emitLine(`${FxTranslator.UAV_PRERENDERED}${i}[PrerenderId] = Prerendered;`);
                    }
                }
                if (pass.instanceCount > 1) {
                    this.pop();
                    this.emitChar('}');
                    this.emitNewline();
                }
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
    }
    emitPrerenderShader(ctx, pass, i) {
        const prerenderFn = pass.prerenderRoutine.function;
        const name = `${FxTranslator.CS_PARTICLE_PRERENDER_SHADER}${i}`;
        const numthreads = [64, 1, 1];
        const fx = ctx.tech();
        ctx.beginCsShader(name, numthreads);
        this.begin();
        {
            this.emitLine(`[numthreads(${numthreads.join(', ')})]`);
            this.emitLine(`void ${name}(uint3 Gid: SV_GroupID, uint GI: SV_GroupIndex, uint3 GTid: SV_GroupThreadID, uint3 DTid: SV_DispatchThreadID)`);
            this.emitChar('{');
            this.push();
            {
                this.emitLine(`uint PartId = DTid.x;`);
                this.emitUav(ctx, `RWBuffer<uint>`, FxTranslator.UAV_STATES, FxTranslator.UAV_STATES_DESCRIPTION);
                this.emitLine(`bool Alive = (bool)${FxTranslator.UAV_STATES}[PartId];`);
                this.emitNewline();
                this.emitLine(`[branch]`);
                this.emitLine(`if(!Alive) return;`);
                this.emitNewline();
                this.emitFunction(ctx, prerenderFn);
                const { typeName: partType } = this.resolveType(ctx, fx.particle);
                this.emitUav(ctx, `RWStructuredBuffer<${partType}>`, FxTranslator.UAV_PARTICLES, FxTranslator.UAV_PARTICLES_DESCRIPTION);
                this.emitLine(`${partType} Particle = ${FxTranslator.UAV_PARTICLES}[PartId];`);
                this.emitPrerenderRoutune(ctx, pass, i);
                this.emitLine(`${FxTranslator.DRAW_OPERATOR_POLYFILL_NAME}${i}(Particle);`);
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
        ctx.endCsShader();
    }
    emitSpawnOpContainer(ctx) {
        const payloadSize = ctx.spawners.map(
        // slice 1 or 2 depending on necessity of partID
        ctor => ctor.def.params.slice(2).map(param => param.type.size).reduce((size, summ) => summ + size, 0))
            .reduce((size, summ) => summ + size, 0);
        const alignment = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT4.size;
        const numF4 = Math.ceil(payloadSize / alignment);
        this.begin();
        {
            this.emitLine(`struct ${FxTranslator.SPAWN_OPERATOR_TYPE}`);
            this.emitChar(`{`);
            this.push();
            {
                this.emitLine(`uint count;      // number of particles inside group`);
                this.emitLine(`uint offset;     // number of particles prior this group (to determ spawn id)`);
                this.emitLine(`uint type;       // type of spawner (type of function to init)`);
                // this.emitLine(`uint _pad[2];`);
                // emit padding?
                if (numF4 > 0) {
                    this.emitNewline();
                    this.emitLine(`float4 payload[${numF4}];`);
                }
            }
            this.pop();
            this.emitChar(`}`);
            this.emitChar(';');
        }
        // NOTE: emit as prologue!
        this.end(true);
    }
    finalizeTechnique(ctx) {
        if (ctx.opts.globalUniformsGatherToDedicatedConstantBuffer && ctx.uniforms.length > 0) {
            const index = ctx.opts.globalUniformsConstantBufferRegister || -1;
            // check that no one uses the same register
            for (let name in ctx.tech()?.scope.cbuffers) {
                let cbuf = ctx.tech().scope.cbuffers[name];
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.resolveRegister(cbuf).index === index) {
                    console.error(`register ${index} is already used by cbuffer '${cbuf.name}'`);
                }
            }
            const name = ctx.opts.globalUniformsConstantBufferName || AUTOGEN_GLOBALS;
            this.begin();
            {
                this.emitKeyword('cbuffer');
                this.emitKeyword(name);
                if (index !== -1) {
                    this.emitChar(':');
                    this.emitKeyword('register');
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitKeyword(`b${index}`);
                    this.emitNoSpace();
                    this.emitChar(')');
                }
                this.emitNewline();
                this.emitChar('{');
                this.push();
                {
                    ctx.uniforms.forEach(({ name, typeName, semantic, length }) => {
                        this.emitKeyword(typeName);
                        this.emitKeyword(name);
                        if (length > 0) {
                            this.emitChar(`[${length}]`);
                        }
                        if (semantic) {
                            this.emitSemantic(ctx, semantic);
                        }
                        else {
                            this.emitSemantic(ctx, camelToSnakeCase(name).toUpperCase());
                        }
                        this.emitChar(';');
                        this.emitNewline();
                    });
                }
                this.pop();
                this.emitChar('}');
                this.emitChar(';');
            }
            this.end(true); // move to prologue
        }
        const uiControls = ctx.controls.filter(ctrl => !['texture2d', 'mesh'].includes(ctrl.type));
        if (ctx.opts.uiControlsGatherToDedicatedConstantBuffer && uiControls.length > 0) {
            const index = ctx.opts.uiControlsConstantBufferRegister || -1;
            // check that no one uses the same register
            for (let name in ctx.tech()?.scope.cbuffers) {
                let cbuf = ctx.tech().scope.cbuffers[name];
                if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_2__.resolveRegister(cbuf).index === index) {
                    console.error(`register ${index} is already used by cbuffer '${cbuf.name}'`);
                }
            }
            const name = ctx.opts.uiControlsConstantBufferName || AUTOGEN_CONTROLS;
            this.begin();
            {
                this.emitKeyword('cbuffer');
                this.emitKeyword(name);
                if (index !== -1) {
                    this.emitChar(':');
                    this.emitKeyword('register');
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitKeyword(`b${index}`);
                    this.emitNoSpace();
                    this.emitChar(')');
                }
                this.emitNewline();
                this.emitChar('{');
                this.push();
                {
                    // collect all array elements (color[2]) into array "color"
                    const nameRexp = /([\w_][\w\d]+)(\[([\d]+)\])?/;
                    const fields = {};
                    uiControls.forEach(ctrl => {
                        const name = ctrl.name;
                        const match = name.match(nameRexp);
                        const type = typeNameOfUIControl(ctrl);
                        fields[match[1]] ||= { name, type };
                        fields[match[1]].name = match[3] ? `${match[1]}[${Number(match[3]) + 1}]` : match[1];
                    });
                    Object.values(fields).forEach(ctrl => {
                        this.emitKeyword(ctrl.type);
                        this.emitKeyword(ctrl.name);
                        this.emitChar(';');
                        this.emitNewline();
                    });
                }
                this.pop();
                this.emitChar('}');
                this.emitChar(';');
            }
            this.end(true); // move to prologue
        }
    }
    emitPartFxDecl(ctx, fx) {
        if (!fx.particle) {
            return;
        }
        // note: only one effect can be translated at a time 
        ctx.beginTechnique(fx);
        this.emitSpawnShader(ctx);
        this.emitResetShader(ctx);
        if (fx.updateRoutine) {
            this.emitUpdateShader(ctx);
        }
        this.emitInitShader(ctx);
        const passes = fx.passes.map((pass, i) => {
            const { prerenderRoutine, vertexShader: vs, pixelShader: ps, drawMode } = pass;
            let { sorting, geometry, instanceCount } = pass;
            let VSParticleShader = null;
            let PSParticleShader = null;
            let renderStates = pass.renderStates;
            if (prerenderRoutine && drawMode === _lib_idl_part_IPartFx__WEBPACK_IMPORTED_MODULE_4__.EPassDrawMode.k_Auto) {
                this.emitPrerenderShader(ctx, pass, i);
            }
            if (vs) {
                this.emitFunction(ctx, vs);
                VSParticleShader = vs.name;
            }
            if (ps) {
                this.emitFunction(ctx, ps);
                PSParticleShader = ps.name;
            }
            const { typeName: instance } = this.resolveType(ctx, pass.particleInstance);
            const CSParticlesPrerenderRoutine = ctx.CSShaders.find(sh => sh.name == `${FxTranslator.CS_PARTICLE_PRERENDER_SHADER}${i}`);
            return {
                instance,
                sorting,
                geometry,
                instanceCount,
                VSParticleShader,
                PSParticleShader,
                renderStates,
                CSParticlesPrerenderRoutine,
                drawMode
            };
        });
        this.emitSpawnOpContainer(ctx);
        this.finalizeTechnique(ctx);
        const { name, capacity } = fx;
        const particle = this.resolveType(ctx, fx.particle).typeName;
        const CSParticlesSpawnRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_SPAWN_ROUTINE);
        const CSParticlesResetRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_RESET_ROUTINE);
        const CSParticlesUpdateRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_UPDATE_ROUTINE);
        ;
        const CSParticlesInitRoutine = ctx.CSShaders.find(sh => sh.name == FxTranslator.CS_PARTICLE_INIT_ROUTINE);
        ;
        const controls = [...ctx.controls];
        const presets = FxTranslator.parsePresets(fx);
        const pfx = {
            name,
            capacity,
            particle,
            passes,
            CSParticlesSpawnRoutine,
            CSParticlesResetRoutine,
            CSParticlesInitRoutine,
            CSParticlesUpdateRoutine,
            controls,
            presets
        };
        ctx.addTechnique(pfx);
        ctx.endTechnique();
    }
    emitTechniqueDecl(ctx, tech) {
        // note: only one effect can be tranclated at a time 
        ctx.beginTechnique(tech);
        const { name } = tech;
        tech.passes.forEach((pass, i) => {
            const { vertexShader: vs, pixelShader: ps } = pass;
            if (vs) {
                this.emitFunction(ctx, vs);
            }
            if (ps) {
                this.emitFunction(ctx, ps);
            }
        });
        const passes = tech.passes.map((pass, i) => {
            const { vertexShader, pixelShader } = pass;
            let VSParticleShader = null;
            let PSParticleShader = null;
            if (vertexShader) {
                VSParticleShader = vertexShader.name;
            }
            if (pixelShader) {
                PSParticleShader = pixelShader.name;
            }
            // todo: 
            const matInstance = vertexShader?.def.params[0].type;
            const { typeName: instance } = this.resolveType(ctx, matInstance);
            const renderStates = pass.renderStates;
            return {
                instance,
                VSParticleShader,
                PSParticleShader,
                renderStates
            };
        });
        // emit global uniforms and so on.
        this.finalizeTechnique(ctx);
        const controls = [...ctx.controls];
        const presets = FxTranslator.parsePresets(tech);
        const refl = {
            name,
            passes,
            controls,
            presets
        };
        ctx.addTechnique(refl);
        ctx.endTechnique();
    }
    emitTechnique11Decl(ctx, tech) {
        // note: only one effect can be tranclated at a time 
        ctx.beginTechnique(tech);
        const { name } = tech;
        for (const pass of tech.passes) {
            (0,_lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_6__.visitor)(pass, (instr, owner) => {
                if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_CompileShader11Expr) {
                    const cmpl = instr;
                    // const SH_TYPE = {
                    //     'vs': 'VertexShader',
                    //     'ps': 'PixelShader',
                    //     'cs': 'ComputeShader',
                    //     'gs': 'GeometryShader'
                    // };
                    // const ext = cmpl.ver.substring(0, 2);
                    // const type = SH_TYPE[ext];
                    // assert(isString(type), 'unknown type found');
                    this.emitEntryFunction(ctx, cmpl.func);
                }
                // todo: add support of global defined shaders
            });
        }
        // emit global uniforms and so on.
        this.finalizeTechnique(ctx);
        const controls = [...ctx.controls];
        const refl = {
            name,
            controls
        };
        ctx.addTechnique11(refl);
        ctx.endTechnique();
    }
    static parsePresets(fx) {
        return fx.presets.map((preset, i) => {
            const name = preset.name;
            const desc = null; // todo
            let data = [];
            preset.props.forEach(control => {
                if (!control) {
                    //FIX: In a case when the set of controls has changed, but the preset has remained the same.
                    return;
                }
                const src = control.resolveDeclaration();
                let controlType = src.type.name.toLowerCase(); // Texture2D => texture2d
                if (src.annotation) {
                    src.annotation.decls.forEach(prop => {
                        const propertyName = prop.name;
                        const propertyType = prop.type.name;
                        const propertyValue = getPropertyValue(propertyType, prop.initExpr);
                        if ((propertyName === '__type' || propertyName === 'UIType') &&
                            propertyType === 'string' && propertyValue === 'color') {
                            controlType = 'color';
                            return;
                        }
                    });
                }
                const value = encodeInitExprToControlValue(controlType, control.args);
                data.push({ name: src.name, type: controlType, value });
            });
            return { name, desc, data };
        });
    }
    static translate(instr, ctx = new FxTranslatorContext) {
        FxTranslator.fxtTranslator.emit(ctx, instr);
        // hack to print gathered buffers
        if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_FunctionDecl) {
            FxTranslator.fxtTranslator.finalizeTechnique(ctx);
        }
        return FxTranslator.fxtTranslator.toString(ctx);
    }
}
FxTranslator.UAV_PARTICLES = 'uavParticles';
FxTranslator.UAV_STATES = 'uavStates';
FxTranslator.UAV_DEAD_INDICES = 'uavDeadIndices';
FxTranslator.UAV_CREATION_REQUESTS = 'uavCreationRequests';
FxTranslator.UAV_PRERENDERED = 'uavPrerendered';
FxTranslator.UAV_SERIALS = 'uavSerials';
FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS = 'uavSpawnDispatchArguments';
FxTranslator.UAV_SPAWN_EMITTER = `uavEmitter`;
FxTranslator.UAV_PARTICLES_DESCRIPTION = `The buffer contains user-defined particle data.`;
FxTranslator.UAV_STATES_DESCRIPTION = `The buffer contains the state of the particles, Alive or dead.`;
FxTranslator.UAV_DEAD_INDICES_DESCRIPTION = `The buffer contains indicies of dead particles.`;
FxTranslator.UAV_CREATION_REQUESTS_DESCRIPTION = 'The buffer contatins information about the number and type of particles to be created';
FxTranslator.UAV_SERIALS_DESCRIPTION = 'The buffer contains hashes are required for correct sorting during render buffer filling.';
FxTranslator.UAV_SPAWN_DISPATCH_ARGUMENTS_DESCRIPTION = 'The buffer contains arguments of dispatch required to run initialization of new particles.';
FxTranslator.UAV_SPAWN_EMITTER_DESCRIPTION = 'The buffer containts constant data avaialble across frames.';
FxTranslator.SPAWN_OPERATOR_POLYFILL_NAME = '__spawn_op';
FxTranslator.SPAWN_OPERATOR_TYPE = '__SPAWN_T__';
FxTranslator.DRAW_OPERATOR_POLYFILL_NAME = '__draw_op';
FxTranslator.CS_PARTICLE_RESET_ROUTINE = 'CSParticlesResetRoutine';
FxTranslator.CS_PARTICLE_SPAWN_ROUTINE = 'CSParticlesSpawnRoutine';
FxTranslator.CS_PARTICLE_INIT_ROUTINE = 'CSParticlesInitRoutine';
FxTranslator.CS_PARTICLE_UPDATE_ROUTINE = 'CSParticlesUpdateRoutine';
FxTranslator.CS_PARTICLE_PRERENDER_SHADER = 'CSParticlesPrerenderShader';
FxTranslator.fxtTranslator = new FxTranslator({ omitEmptyParams: true });
function getPropertyValue(type, instr) {
    instr = getExpr(instr);
    switch (type) {
        case 'int': return instr.value;
        case 'uint': return instr.value;
        case 'float': return instr.value;
        // hack to remove quotes (should have been fixed during analyze stage)
        case 'string': return instr.value.split('"').join('');
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'Unsupported type');
    return null;
}
function encodeInitExprToControlValue(type, args) {
    switch (type) {
        case 'int': return getExpr(args[0]).value;
        case 'uint': return getExpr(args[0]).value;
        case 'float': return getExpr(args[0]).value;
        case 'float2': {
            let x = getExpr(args[0]).value;
            let y = getExpr(args[1]).value;
            return { x: x, y: y };
        }
        case 'float3': {
            let x = getExpr(args[0]).value;
            let y = getExpr(args[1]).value;
            let z = getExpr(args[2]).value;
            return { x: x, y: y, z: z };
        }
        case 'float4': {
            let x = getExpr(args[0]).value;
            let y = getExpr(args[1]).value;
            let z = getExpr(args[2]).value;
            let w = getExpr(args[3]).value;
            return { x: x, y: y, z: z, w: w };
        }
        case 'color': {
            let r = getExpr(args[0]).value;
            let g = getExpr(args[1]).value;
            let b = getExpr(args[2]).value;
            let a = getExpr(args[3]).value;
            return { r: r, g: g, b: b, a: a };
        }
        case 'texture2d': {
            // remove quotes
            return getExpr(args[0]).value?.slice(1, -1) || null;
        }
    }
    return null;
}
function getExpr(expr) {
    return expr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_3__.EInstructionTypes.k_InitExpr
        ? (expr.args[0])
        : expr;
}


/***/ }),

/***/ "elBL":
/*!***********************************************!*\
  !*** ./src/lib/fx/translators/GlslEmitter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLSLContext": () => (/* binding */ GLSLContext),
/* harmony export */   "GLSLEmitter": () => (/* binding */ GLSLEmitter)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _CodeEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CodeEmitter */ "GU3W");





const GlslTypeNames = {
    'void': 'void',
    'uint': 'uint',
    'uint2': 'uvec2',
    'uint3': 'uvec3',
    'uint4': 'uvec4',
    'bool': 'bool',
    'bool2': 'bvec2',
    'bool3': 'bvec3',
    'bool4': 'bvec4',
    'int': 'int',
    'int2': 'ivec2',
    'int3': 'ivec3',
    'int4': 'ivec4',
    'float': 'float',
    'float2': 'vec2',
    'float3': 'vec3',
    'float4': 'vec4',
    'float4x4': 'mat4',
    'float3x3': 'mat3x3',
    'float3x4': 'mat3x4'
};
// const HlslTypeNames = Object.fromEntries(Object.entries(GlslTypeNames).map(([k, v]) => [v, k]));
const sname = {
    attr: (decl) => decl.semantic ?
        `a_${decl.semantic.toLowerCase()}` :
        `a_${decl.name}_${decl.instructionID}`,
    varying: (decl) => decl.semantic ?
        `v_${decl.semantic.toLowerCase()}` :
        `v_${decl.name}_${decl.instructionID}`,
    // uniform: (decl: IVariableDeclInstruction) => `u_${decl.name}`
};
const IS_POSITION = (semantic) => ['POSITION', 'SV_POSITION'].indexOf(semantic.toUpperCase()) !== -1;
const IS_INSTANCEID = (semantic) => ['INSTANCE_ID', 'SV_INSTANCEID'].indexOf(semantic.toUpperCase()) !== -1;
const IS_VERTEXID = (semantic) => ['VERTEX_ID', 'SV_VERTEXID'].indexOf(semantic.toUpperCase()) !== -1;
function determMostPreciseBaseType(left, right) {
    const length = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isScalarType(left)
        ? right.length
        : _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isScalarType(right)
            ? left.length
            : Math.min(left.length, right.length);
    const mpbt = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.determMostPreciseBaseType(left, right);
    const mpt = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.findType(`${mpbt.name}${length === 1 ? '' : length}`);
    return mpt;
}
class GLSLContext extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_4__.CodeContext {
    constructor() {
        super(...arguments);
        this.location = 0;
    }
    has(signature) {
        // nothing todo - built in GLSL function
        const SYSTEM_FUNCS = ['unpackHalf2x16(uint)'];
        if (SYSTEM_FUNCS.includes(signature)) {
            return true;
        }
        return super.has(signature);
    }
}
class GLSLEmitter extends _CodeEmitter__WEBPACK_IMPORTED_MODULE_4__.CodeEmitter {
    resolveTypeName(type) {
        const typeName = GlslTypeNames[type.name];
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(typeName)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unknown built in type found '${type.name}'`);
            return type.name;
        }
        return typeName;
    }
    // GLSL doesn't support static keyword
    resolveType(ctx, type) {
        let info = super.resolveType(ctx, type);
        if (info) {
            info.usage = info.usage?.split(' ').filter(kw => kw !== 'static').join(' ');
        }
        return info;
    }
    isVaryingOrAttributeAlias(ctx, pfxp) {
        if (this.isMain() && !ctx.isRaw()) {
            if (pfxp.element.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_IdExpr) {
                const id = pfxp.element;
                if (id.decl.isParameter() && !id.decl.type.isUniform()) {
                    return true;
                }
            }
        }
        return false;
    }
    emitExpressionWithCast(ctx, expr, type) {
        const { typeName } = this.resolveType(ctx, type);
        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(type, expr.type)) {
            this.emitKeyword(typeName);
            this.emitNoSpace();
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, expr);
            this.emitChar(')');
        }
        else {
            this.emitExpression(ctx, expr);
        }
    }
    emitExpressionListWithCast(ctx, list, types) {
        list?.forEach((expr, i) => {
            this.emitExpressionWithCast(ctx, list[i], types[i]);
            (i != list.length - 1) && this.emitChar(',');
        });
    }
    emitArithmetic(ctx, arthm) {
        let { left, right, operator } = arthm;
        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, right.type)) {
            const mpt = determMostPreciseBaseType(left.type, right.type);
            this.emitExpressionWithCast(ctx, left, mpt);
            this.emitKeyword(operator);
            this.emitSpace();
            this.emitExpressionWithCast(ctx, right, mpt);
            return;
        }
        super.emitArithmetic(ctx, arthm);
    }
    emitAssigment(ctx, asgm) {
        let { left, right, operator } = asgm;
        if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(left.type, right.type)) {
            const mpt = determMostPreciseBaseType(left.type, right.type);
            this.emitExpressionWithCast(ctx, left, mpt);
            this.emitKeyword(operator);
            this.emitSpace();
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.isExpression(right));
            this.emitExpressionWithCast(ctx, right, mpt);
            return;
        }
        super.emitAssigment(ctx, asgm);
    }
    emitSemantic(ctx, semantic) {
        // disabling of semantics emission.
    }
    emitPostfixIndex(ctx, pfidx) {
        if (/^Buffer(<[a-zA-Z0-9_]+>)?$/.test(pfidx.element.type.name)) {
            // TODO: fixme
            this.emitKeyword(`${this.resolveType(ctx, pfidx.type).typeName}(0.0, 0.0, 0.0, 0.0)`);
            return;
            // this.emitLine(`texelFetch(`, texelCoord, 0).x`);
            this.emitKeyword('texelFetch');
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, pfidx.element);
            this.emitChar(',');
            this.emitKeyword(`ivec2`);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, pfidx.index);
            this.emitChar(',');
            this.emitKeyword('0');
            this.emitChar(')');
            this.emitChar(',');
            this.emitKeyword('0');
            this.emitChar(')');
            return;
        }
        super.emitPostfixIndex(ctx, pfidx);
    }
    emitVariableNoInit(ctx, src, rename) {
        const { type } = src;
        if (src.isGlobal()) {
            // IP: hack for fake compartibility with GLSL 3.00 ES
            // convert buffers to samplers
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBuffer(type)) {
                const { typeName } = this.resolveType(ctx, type.arrayElementType);
                this.emitKeyword('uniform highp');
                if (['ivec4'].includes(typeName)) {
                    this.emitKeyword('isampler2D');
                }
                else if (['uvec4'].includes(typeName)) {
                    this.emitKeyword('usampler2D');
                }
                else {
                    this.emitKeyword('sampler2D');
                }
                this.emitKeyword(src.name);
                return;
            }
        }
        // todo: add support not only for 2D textures
        if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isTexture(type)) {
            this.emitKeyword('sampler2D');
            this.emitKeyword(src.name);
            return;
        }
        super.emitVariableNoInit(ctx, src, rename);
    }
    emitVariable(ctx, src, rename) {
        this.emitVariableNoInit(ctx, src, rename);
        if (src.initExpr) {
            this.emitKeyword('=');
            this.emitSpace();
            if (!_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(src.type, src.initExpr.type)) {
                const { typeName } = this.resolveType(ctx, src.type);
                this.emitKeyword(`${typeName}`);
                this.emitChar('(');
                this.emitNoSpace();
                this.emitExpression(ctx, src.initExpr);
                this.emitChar(')');
            }
            else {
                this.emitExpression(ctx, src.initExpr);
            }
        }
    }
    emitPrologue(ctx, def) {
        this.begin();
        {
            this.emitLine(`#version 300 es`);
            this.emitLine(`precision highp float;`);
            this.emitLine(`precision highp int;`);
            // this.emitLine(`precision highp unsigned int;`);
        }
        this.end();
        this.begin();
        {
            for (const param of def.params) {
                if (param.type.isUniform()) {
                    continue;
                }
                const type = param.type;
                // this.emitComment(param.toCode());
                // this.emitNewline();
                if (!type.isComplex()) {
                    this.emitVaryingOrAttribute(ctx, param);
                    continue;
                }
                type.fields.forEach(field => {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!field.type.isNotBaseArray() && !field.type.isComplex());
                    this.emitVaryingOrAttribute(ctx, field);
                });
            }
        }
        this.end();
        this.begin();
        {
            // for (const param of def.params) {
            //     if (!param.type.isUniform()) {
            //         continue;
            //     }
            //     this.emitVariable(ctx, param);
            //     this.emitChar(`;`);
            //     this.emitNewline();
            // }
        }
        this.end();
        if (ctx.mode === 'vs') {
            this.begin();
            {
                const retType = def.returnType;
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(retType.isComplex(), 'basic types unsupported yet');
                retType.fields.forEach(field => this.emitVarying(ctx, field));
            }
            this.end();
        }
        if (ctx.mode === 'ps') {
            // layout(location = 0) out vec3 color;
            this.begin();
            if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT4)) {
                this.emitLine(`layout(location = 0) out vec4 out_color;`);
            }
            else if (def.returnType.isComplex()) {
                const ctype = def.returnType;
                ctype.fields.forEach((field, i) => {
                    const { typeName } = this.resolveType(ctx, field.type);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!field.type.isComplex() && !field.type.isNotBaseArray());
                    this.emitLine(`layout(location = ${i}) out ${typeName} out_${field.name};`);
                });
            }
            else {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported pixel shader output format');
            }
            this.end();
        }
    }
    emitKeyword(kw) {
        // IP: temp fix for reserved GLSL keyword
        if (kw === 'input')
            kw = 'input1';
        super.emitKeyword(kw);
    }
    emitTextureRaw(ctx, type, name, comment) {
        if (!ctx.has(name)) {
            const tex = ctx.addTexture(type, name);
            this.begin();
            {
                comment && this.emitComment(comment);
                this.emitKeyword(`uniform sampler2D ${name};`);
            }
            this.end();
        }
        ctx.linkTexture(name);
    }
    emitAttribute(ctx, decl) {
        // skip specific semantics like SV_InstanceID in favor of gl_InstanceID 
        if (IS_INSTANCEID(decl.semantic))
            return;
        if (IS_VERTEXID(decl.semantic))
            return;
        (this.emitKeyword(`layout(location = ${ctx.location++}) in`), this.emitVariable(ctx, decl, sname.attr), this.emitChar(';'), this.emitNewline());
    }
    emitVarying(ctx, decl) {
        const { type } = decl;
        if (type.isComplex()) {
            type.fields.forEach(field => this.emitVarying(ctx, field));
            return;
        }
        const usage = {
            vs: 'out',
            ps: 'in'
        };
        (this.emitKeyword(usage[ctx.mode]), this.emitVariable(ctx, decl, sname.varying), this.emitChar(';'), this.emitNewline());
    }
    emitVaryingOrAttribute(ctx, decl) {
        switch (ctx.mode) {
            case 'vs':
                return this.emitAttribute(ctx, decl);
            case 'ps':
                return this.emitVarying(ctx, decl);
        }
    }
    emitCbuffer(ctx, cbuf) {
        if (!ctx.has(cbuf.name)) {
            ctx.addCbuffer(cbuf);
            this.begin();
            this.emitComment(`size: ${cbuf.type.size}`);
            this.emitKeyword('uniform');
            if (cbuf.id) {
                this.emitKeyword(cbuf.name);
            }
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                cbuf.type.fields.forEach(field => {
                    this.emitVariable(ctx, field);
                    this.emitChar(';');
                    this.emitChar('\t');
                    this.emitComment(`padding ${field.type.padding}, size ${field.type.size}`);
                });
            }
            this.pop();
            this.emitChar('}');
            this.emitChar(';');
            this.end();
        }
        ctx.linkCbuffer(cbuf.name);
    }
    emitFloat(ctx, lit) {
        const sval = String(lit.value);
        this.emitKeyword(sval);
        (sval.indexOf('.') === -1) && this.emitChar('.0');
    }
    attr(ctx, decl) {
        return ctx.isVertex() ? sname.attr(decl) : sname.varying(decl);
    }
    emitPostfixPoint(ctx, pfxp) {
        // if (IS_INSTANCEID(pfxp.postfix.decl.semantic)) {
        //     this.emitKeyword(`gl_InstanceID`);
        //     return;
        // }
        super.emitPostfixPoint(ctx, pfxp);
    }
    emitFCall(ctx, call) {
        const { decl, args, callee } = call;
        switch (decl.name) {
            case 'mul':
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(args.length == 2);
                this.emitMulIntrinsic(ctx, args[0], args[1]);
                return;
            case 'lerp':
                super.emitFCall(ctx, call, (decl) => 'mix');
                return;
            case 'frac':
                super.emitFCall(ctx, call, (decl) => 'fract');
                return;
            case 'asuint':
                // call.decl.def.params[0].type.name === 'float' ? 'floatBitsToUint' : 'floatBitsToUint'
                super.emitFCall(ctx, call, (decl) => 'floatBitsToUint');
                return;
            case 'asfloat':
                super.emitFCall(ctx, call, (decl) => 'uintBitsToFloat');
                return;
            case 'fmod':
                super.emitFCall(ctx, call, (decl) => 'mod');
                return;
            case 'clip':
                this.emitClipIntrinsic(ctx, args[0]);
                return;
        }
        // todo: add correct samplers support (!)
        if (callee) {
            const type = callee.type;
            if (_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isTexture(type)) {
                const id = callee;
                this.emitGlobal(ctx, id.decl);
                if (decl.name == 'Sample') {
                    this.emitKeyword(`texture`);
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitKeyword(id.name);
                    this.emitChar(`,`);
                    this.emitExpressionList(ctx, args.slice(1)); // remove sampler argument
                    this.emitChar(')');
                }
                if (decl.name == 'GetDimensions') {
                    this.emitChar('{');
                    this.push();
                    this.emitKeyword(`ivec2`);
                    this.emitKeyword(`temp`);
                    this.emitSpace();
                    this.emitChar(`=`);
                    this.emitKeyword('textureSize');
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitKeyword(id.name);
                    this.emitChar(`,`);
                    this.emitKeyword('int');
                    this.emitChar('(');
                    this.emitNoSpace();
                    this.emitExpression(ctx, args[0]);
                    this.emitChar(')');
                    this.emitChar(')');
                    this.emitChar(';');
                    this.emitNewline();
                    this.emitExpression(ctx, args[1]);
                    this.emitSpace();
                    this.emitChar(`=`);
                    this.emitKeyword('uint(temp.x)');
                    this.emitChar(';');
                    this.emitNewline();
                    this.emitExpression(ctx, args[2]);
                    this.emitSpace();
                    this.emitChar(`=`);
                    this.emitKeyword('uint(temp.y)');
                    this.emitChar(';');
                    this.emitNewline();
                    this.pop();
                    this.emitChar('}');
                }
                return;
            }
        }
        // super.emitFCall(ctx, call);
        if (decl.instructionType !== _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_2__.EInstructionTypes.k_SystemFunctionDecl) {
            this.emitFunction(ctx, decl);
        }
        if (callee) {
            this.emitExpression(ctx, callee);
            this.emitChar('.');
            this.emitNoSpace();
        }
        this.emitKeyword(decl.name);
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpressionListWithCast(ctx, args, decl.def.params.map(p => p.type));
        this.emitChar(')');
    }
    emitCast(ctx, cast) {
        if (cast.isUseless()) {
            return;
        }
        // replace '(vec3)value' to 'vec3(value)'
        if (GlslTypeNames[cast.type.name]) {
            const { typeName } = this.resolveType(ctx, cast.type);
            this.emitKeyword(typeName);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpression(ctx, cast.expr);
            this.emitChar(')');
            return;
        }
        super.emitCast(ctx, cast);
    }
    emitInitExpr(ctx, init) {
        // replaced '{1, 2, 3}' to 'ivec3(1, 2, 3)'
        if (GlslTypeNames[init.type.name]) {
            const { typeName } = this.resolveType(ctx, init.type);
            this.emitKeyword(typeName);
            this.emitChar('(');
            this.emitNoSpace();
            this.emitExpressionList(ctx, init.args);
            this.emitChar(')');
            return;
        }
        super.emitInitExpr(ctx, init);
    }
    // todo: use emitEntryFunction instead
    emitFunction(ctx, fn) {
        const def = fn.def;
        const retType = def.returnType;
        const isSupported = ctx.isVertex() || ctx.isPixel();
        if (this.depth() === 0 && isSupported) {
            this.emitPrologue(ctx, fn.def);
            const { typeName } = this.resolveType(ctx, def.returnType);
            super.emitRegularFunction(ctx, fn);
            // emit main()
            this.begin();
            {
                this.emitChar('void main(void)');
                this.emitNewline();
                this.emitChar('{');
                this.push();
                const params = fn.def.params.filter(p => p.type.size !== 0);
                {
                    for (let p of params) {
                        const pname = p.name;
                        const { typeName } = this.resolveType(ctx, p.type);
                        this.emitKeyword(typeName);
                        this.emitKeyword(pname);
                        this.emitChar(';');
                        this.emitNewline();
                        const fline = (decl, ids) => {
                            if (decl.type.isComplex() && !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBase(decl.type)) {
                                decl.type.fields.forEach(field => fline(field, [...ids, decl.name]));
                                return;
                            }
                            for (let id of ids) {
                                this.emitKeyword(id);
                                this.emitChar('.');
                                this.emitNoSpace();
                            }
                            this.emitKeyword(decl.name);
                            this.emitSpace();
                            this.emitChar('=');
                            if (IS_INSTANCEID(decl.semantic)) {
                                this.emitKeyword('uint(gl_InstanceID)');
                            }
                            else if (IS_VERTEXID(decl.semantic)) {
                                this.emitKeyword('uint(gl_VertexID)');
                            }
                            else {
                                this.emitKeyword(this.attr(ctx, decl));
                            }
                            this.emitChar(';');
                            this.emitNewline();
                        };
                        fline(p, []);
                    }
                    const tempName = 'temp';
                    this.emitKeyword(typeName);
                    this.emitKeyword(tempName);
                    this.emitKeyword('=');
                    this.emitKeyword(fn.name);
                    this.emitChar('(');
                    this.emitNoSpace();
                    params.forEach((param, i, list) => {
                        this.emitKeyword(param.name);
                        (i + 1 != list.length) && this.emitChar(',');
                    });
                    this.emitChar(')');
                    this.emitChar(';');
                    this.emitNewline();
                    if (ctx.isVertex()) {
                        // emit prologue like:
                        // v_name = temp.name;
                        {
                            let fline; // emit field line
                            let cdown; // breakdown and emit complex decl
                            fline = (decl, ids) => {
                                if (decl.type.isComplex() && !_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.isBase(decl.type)) {
                                    cdown(decl.type, [...ids, decl.name]);
                                    return;
                                }
                                this.emitKeyword(sname.varying(decl));
                                this.emitSpace();
                                this.emitChar('=');
                                for (let id of ids) {
                                    this.emitKeyword(id);
                                    this.emitChar('.');
                                    this.emitNoSpace();
                                }
                                this.emitKeyword(decl.name);
                                this.emitChar(';');
                                this.emitNewline();
                            };
                            cdown = (type, ids) => type.fields.forEach(field => fline(field, ids));
                            cdown(retType, [tempName]);
                        }
                        const fieldPos = retType.fields.filter(field => (IS_POSITION(field.semantic)))[0];
                        this.emitKeyword('gl_Position');
                        this.emitKeyword('=');
                        this.emitKeyword(tempName);
                        this.emitChar('.');
                        this.emitChar(fieldPos?.name);
                        this.emitChar(';');
                        this.emitNewline();
                    }
                    else { // ps
                        if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.equals(def.returnType, _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.T_FLOAT4)) {
                            this.emitKeyword('out_color');
                            this.emitKeyword('=');
                            this.emitKeyword(tempName);
                            this.emitChar(';');
                            this.emitNewline();
                        }
                        else if (def.returnType.isComplex()) {
                            const ctype = def.returnType;
                            for (const field of ctype.fields) {
                                this.emitKeyword(`out_${field.name}`);
                                this.emitKeyword('=');
                                this.emitKeyword(`${tempName}.${field.name}`);
                                this.emitChar(';');
                                this.emitNewline();
                            }
                        }
                    }
                }
                this.pop();
                this.emitChar('}');
            }
            this.end();
            return;
        }
        super.emitFunction(ctx, fn);
    }
    //
    // intrinsics
    //
    emitMulIntrinsic(ctx, left, right) {
        this.emitChar('(');
        this.emitExpression(ctx, left);
        this.emitKeyword('*');
        this.emitExpression(ctx, right);
        this.emitChar(')');
    }
    // todo: call autogen function?
    emitClipIntrinsic(ctx, x) {
        this.emitKeyword('if');
        this.emitChar('(');
        this.emitNoSpace();
        this.emitChar('(');
        this.emitNoSpace();
        this.emitExpression(ctx, x);
        this.emitChar(')');
        this.emitKeyword(`<`);
        this.emitKeyword(`0.0`);
        this.emitChar(')');
        this.emitKeyword(`discard`);
    }
    // is used in Bundle.ts
    static $declToAttributeName(decl) {
        return sname.attr(decl);
    }
    static translate(instr, ctx = new GLSLContext) {
        return GLSLEmitter.glslEmitter.emit(ctx, instr).toString();
    }
}
GLSLEmitter.glslEmitter = new GLSLEmitter({ omitEmptyParams: true, omitInUsage: true });


/***/ }),

/***/ "/pDr":
/*!******************************************!*\
  !*** ./src/lib/fx/translators/Output.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createOutput": () => (/* binding */ createOutput)
/* harmony export */ });
function createOutput({ tab = '\t', nl = '\n', name = null } = {}) {
    let data = [''];
    let nesting = [];
    let count = 0;
    let noNextSpace = false;
    const push = (pad = tab) => (nesting.push(pad), count && newline());
    const pop = () => (nesting.pop(), count && newline());
    const toString = () => data.join(nl);
    const ignoreNextSpace = () => noNextSpace = true;
    function add(val) {
        if (!count) {
            for (let i = 0; i < nesting.length; ++i)
                val = nesting[i] + val;
        }
        data[data.length - 1] += val;
        count++;
        noNextSpace = false;
    }
    function keyword(token) {
        !noNextSpace && count && add(' ');
        add(token);
    }
    function newline() {
        data.push('');
        count = 0;
    }
    function isEmpty() {
        return data.length == 1 &&
            data[0].length == 0;
    }
    return {
        isEmpty,
        keyword,
        ignoreNextSpace,
        push,
        pop,
        newline,
        add,
        toString,
        name
    };
}


/***/ }),

/***/ "jeW/":
/*!****************************************!*\
  !*** ./src/lib/idl/EAnalyzerErrors.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EAnalyzerErrors": () => (/* binding */ EAnalyzerErrors)
/* harmony export */ });
var EAnalyzerErrors;
(function (EAnalyzerErrors) {
    EAnalyzerErrors[EAnalyzerErrors["SystemTypeRedefinition"] = 2202] = "SystemTypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["TypeRedefinition"] = 2203] = "TypeRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["VariableRedefinition"] = 2204] = "VariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemVariableRedefinition"] = 2205] = "SystemVariableRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedifinition"] = 2206] = "FunctionRedifinition";
    EAnalyzerErrors[EAnalyzerErrors["CbufferRedefinition"] = 2207] = "CbufferRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["SystemFunctionRedefinition"] = 2208] = "SystemFunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedTypeDecl"] = 2209] = "UnsupportedTypeDecl";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedExpr"] = 2210] = "UnsupportedExpr";
    EAnalyzerErrors[EAnalyzerErrors["UnknownVarName"] = 2211] = "UnknownVarName";
    EAnalyzerErrors[EAnalyzerErrors["UnknownInstruction"] = 2212] = "UnknownInstruction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticOperation"] = 2213] = "InvalidArithmeticOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidArithmeticAssigmentOperation"] = 2214] = "InvalidArithmeticAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidAssigmentOperation"] = 2215] = "InvalidAssigmentOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidBitwiseOperation"] = 2216] = "InvalidBitwiseOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLeftHandSideInAssignment"] = 2217] = "InvalidLeftHandSideInAssignment";
    EAnalyzerErrors[EAnalyzerErrors["InvalidRelationalOperation"] = 2218] = "InvalidRelationalOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidLogicOperation"] = 2219] = "InvalidLogicOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditionType"] = 2220] = "InvalidConditionType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidConditonValueTypes"] = 2221] = "InvalidConditonValueTypes";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeUsage"] = 2222] = "InvalidCastTypeUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastTypeNotBase"] = 2223] = "InvalidCastTypeNotBase";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCastUnknownType"] = 2224] = "InvalidCastUnknownType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidUnaryOperation"] = 2225] = "InvalidUnaryOperation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotArray"] = 2226] = "InvalidPostfixNotArray";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotIntIndex"] = 2227] = "InvalidPostfixNotIntIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixNotField"] = 2228] = "InvalidPostfixNotField";
    EAnalyzerErrors[EAnalyzerErrors["InvalidPostfixArithmetic"] = 2229] = "InvalidPostfixArithmetic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotFunction"] = 2230] = "InvalidComplexNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotType"] = 2231] = "InvalidComplexNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidComplexNotConstructor"] = 2232] = "InvalidComplexNotConstructor";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileNotFunction"] = 2233] = "InvalidCompileNotFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidCompileFunctionNotValid"] = 2234] = "InvalidCompileFunctionNotValid";
    EAnalyzerErrors[EAnalyzerErrors["FunctionRedefinition"] = 2235] = "FunctionRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidWhileCondition"] = 2236] = "InvalidWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidDoWhileCondition"] = 2237] = "InvalidDoWhileCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidIfCondition"] = 2238] = "InvalidIfCondition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitExpr"] = 2239] = "InvalidForInitExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForInitEmptyIterator"] = 2240] = "InvalidForInitEmptyIterator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionEmpty"] = 2241] = "InvalidForConditionEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForConditionRelation"] = 2242] = "InvalidForConditionRelation";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepEmpty"] = 2243] = "InvalidForStepEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepOperator"] = 2244] = "InvalidForStepOperator";
    EAnalyzerErrors[EAnalyzerErrors["InvalidForStepExpr"] = 2245] = "InvalidForStepExpr";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructName"] = 2246] = "InvalidNewFieldForStructName";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewFieldForStructSematic"] = 2247] = "InvalidNewFieldForStructSematic";
    EAnalyzerErrors[EAnalyzerErrors["InvalidNewAnnotationVar"] = 2248] = "InvalidNewAnnotationVar";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterDefenitionDefaultNeeded"] = 2249] = "InvalidFunctionParameterDefenitionDefaultNeeded";
    EAnalyzerErrors[EAnalyzerErrors["CannotChooseFunction"] = 2250] = "CannotChooseFunction";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFuncDefenitionReturnType"] = 2251] = "InvalidFuncDefenitionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSystemFunctionReturnType"] = 2252] = "InvalidSystemFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameNotType"] = 2253] = "InvalidTypeNameNotType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeNameTemplateNotFound"] = 2254] = "InvalidTypeNameTemplateNotFound";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeScope"] = 2255] = "InvalidTypeScope";
    EAnalyzerErrors[EAnalyzerErrors["CannotProduceType"] = 2256] = "CannotProduceType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeVectorMatrix"] = 2257] = "InvalidTypeVectorMatrix";
    EAnalyzerErrors[EAnalyzerErrors["TechniqueNameRedefinition"] = 2258] = "TechniqueNameRedefinition";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionRecursionNotAllowed"] = 2259] = "InvalidFunctionRecursionNotAllowed";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionImplementationNotFound"] = 2260] = "InvalidFunctionImplementationNotFound";
    // InvalidFunctionUsageVertex,
    // InvalidFunctionUsagePixel,
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithVertexShader"] = 2261] = "FunctionIsNotCompatibleWithVertexShader";
    EAnalyzerErrors[EAnalyzerErrors["FunctionIsNotCompatibleWithPixelShader"] = 2262] = "FunctionIsNotCompatibleWithPixelShader";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtVoid"] = 2263] = "InvalidReturnStmtVoid";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtEmpty"] = 2264] = "InvalidReturnStmtEmpty";
    EAnalyzerErrors[EAnalyzerErrors["InvalidReturnStmtTypesNotEqual"] = 2265] = "InvalidReturnStmtTypesNotEqual";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnType"] = 2266] = "InvalidFunctionReturnType";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionParameterUsage"] = 2267] = "InvalidFunctionParameterUsage";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForWriting"] = 2268] = "InvalidTypeForWriting";
    EAnalyzerErrors[EAnalyzerErrors["InvalidTypeForReading"] = 2269] = "InvalidTypeForReading";
    EAnalyzerErrors[EAnalyzerErrors["InvalidExprIsNotLValue"] = 2270] = "InvalidExprIsNotLValue";
    EAnalyzerErrors[EAnalyzerErrors["InvalidVariableInitializing"] = 2271] = "InvalidVariableInitializing";
    EAnalyzerErrors[EAnalyzerErrors["InvalidVariableInitializingEx"] = 2272] = "InvalidVariableInitializingEx";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedStateIndex"] = 2273] = "UnsupportedStateIndex";
    EAnalyzerErrors[EAnalyzerErrors["InvalidSamplerTexture"] = 2274] = "InvalidSamplerTexture";
    EAnalyzerErrors[EAnalyzerErrors["CannotCalcPadding"] = 2275] = "CannotCalcPadding";
    EAnalyzerErrors[EAnalyzerErrors["ImportedComponentNotExists"] = 2276] = "ImportedComponentNotExists";
    EAnalyzerErrors[EAnalyzerErrors["InvalidFunctionReturnStmtNotFound"] = 2277] = "InvalidFunctionReturnStmtNotFound";
    EAnalyzerErrors[EAnalyzerErrors["UnsupportedProvideAs"] = 2278] = "UnsupportedProvideAs";
    EAnalyzerErrors[EAnalyzerErrors["UnreachableCode"] = 2279] = "UnreachableCode";
    EAnalyzerErrors[EAnalyzerErrors["OperatorCannotBeUsedWithGivenLValue"] = 2280] = "OperatorCannotBeUsedWithGivenLValue";
    //
    //
    //
    EAnalyzerErrors[EAnalyzerErrors["PartFx_VertexShaderParametersMismatch"] = 2281] = "PartFx_VertexShaderParametersMismatch";
    EAnalyzerErrors[EAnalyzerErrors["PartFx_InvalidSpawnStmtInitializerNotFound"] = 2282] = "PartFx_InvalidSpawnStmtInitializerNotFound";
    // PartFx_RenderPassWasNotFound, // << moved to warnings
    EAnalyzerErrors[EAnalyzerErrors["PartFx_DrawOpOnlyAllowedWithinUpdateRoutine"] = 2283] = "PartFx_DrawOpOnlyAllowedWithinUpdateRoutine";
})(EAnalyzerErrors || (EAnalyzerErrors = {}));
;


/***/ }),

/***/ "AW2x":
/*!******************************************!*\
  !*** ./src/lib/idl/EAnalyzerWarnings.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EAnalyzerWarnings": () => (/* binding */ EAnalyzerWarnings)
/* harmony export */ });
var EAnalyzerWarnings;
(function (EAnalyzerWarnings) {
    EAnalyzerWarnings[EAnalyzerWarnings["UnsupportedRenderStateTypeUsed"] = 3000] = "UnsupportedRenderStateTypeUsed";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompleteTechnique"] = 3001] = "IncompleteTechnique";
    EAnalyzerWarnings[EAnalyzerWarnings["IncompletePass"] = 3002] = "IncompletePass";
    EAnalyzerWarnings[EAnalyzerWarnings["UselessPassState"] = 3003] = "UselessPassState";
    EAnalyzerWarnings[EAnalyzerWarnings["EmptySemicolon"] = 3004] = "EmptySemicolon";
    EAnalyzerWarnings[EAnalyzerWarnings["InvalidCbufferRegister"] = 3005] = "InvalidCbufferRegister";
    EAnalyzerWarnings[EAnalyzerWarnings["ImplicitTypeConversion"] = 3006] = "ImplicitTypeConversion";
    EAnalyzerWarnings[EAnalyzerWarnings["ImplicitTypeTruncation"] = 3007] = "ImplicitTypeTruncation";
    EAnalyzerWarnings[EAnalyzerWarnings["Deprecated"] = 3008] = "Deprecated";
    // part fx
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_SortingCannotBeApplied"] = 3009] = "PartFx_SortingCannotBeApplied";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_PresetPropertyHasNotBeenFound"] = 3010] = "PartFx_PresetPropertyHasNotBeenFound";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_RenderPassWasNotFound"] = 3011] = "PartFx_RenderPassWasNotFound";
    EAnalyzerWarnings[EAnalyzerWarnings["PartFx_EmitterPersistentDataMustBeMarkedAsInout"] = 3012] = "PartFx_EmitterPersistentDataMustBeMarkedAsInout";
    EAnalyzerWarnings[EAnalyzerWarnings["ExternCall"] = 3013] = "ExternCall";
})(EAnalyzerWarnings || (EAnalyzerWarnings = {}));


/***/ }),

/***/ "HS1/":
/*!*******************************************!*\
  !*** ./src/lib/idl/ERenderStateValues.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERenderStateValues": () => (/* binding */ ERenderStateValues)
/* harmony export */ });
/** @deprecated */
var ERenderStateValues;
(function (ERenderStateValues) {
    ERenderStateValues[ERenderStateValues["UNDEF"] = 0] = "UNDEF";
    ERenderStateValues[ERenderStateValues["TRUE"] = 1] = "TRUE";
    ERenderStateValues[ERenderStateValues["FALSE"] = 2] = "FALSE";
    ERenderStateValues[ERenderStateValues["ZERO"] = 3] = "ZERO";
    ERenderStateValues[ERenderStateValues["ONE"] = 4] = "ONE";
    ERenderStateValues[ERenderStateValues["SRCCOLOR"] = 5] = "SRCCOLOR";
    ERenderStateValues[ERenderStateValues["INVSRCCOLOR"] = 6] = "INVSRCCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHA"] = 7] = "SRCALPHA";
    ERenderStateValues[ERenderStateValues["INVSRCALPHA"] = 8] = "INVSRCALPHA";
    ERenderStateValues[ERenderStateValues["DESTALPHA"] = 9] = "DESTALPHA";
    ERenderStateValues[ERenderStateValues["INVDESTALPHA"] = 10] = "INVDESTALPHA";
    ERenderStateValues[ERenderStateValues["DESTCOLOR"] = 11] = "DESTCOLOR";
    ERenderStateValues[ERenderStateValues["INVDESTCOLOR"] = 12] = "INVDESTCOLOR";
    ERenderStateValues[ERenderStateValues["SRCALPHASAT"] = 13] = "SRCALPHASAT";
    ERenderStateValues[ERenderStateValues["NONE"] = 14] = "NONE";
    ERenderStateValues[ERenderStateValues["CW"] = 15] = "CW";
    ERenderStateValues[ERenderStateValues["CCW"] = 16] = "CCW";
    ERenderStateValues[ERenderStateValues["FRONT"] = 17] = "FRONT";
    ERenderStateValues[ERenderStateValues["BACK"] = 18] = "BACK";
    ERenderStateValues[ERenderStateValues["FRONT_AND_BACK"] = 19] = "FRONT_AND_BACK";
    ERenderStateValues[ERenderStateValues["NEVER"] = 20] = "NEVER";
    ERenderStateValues[ERenderStateValues["LESS"] = 21] = "LESS";
    ERenderStateValues[ERenderStateValues["EQUAL"] = 22] = "EQUAL";
    ERenderStateValues[ERenderStateValues["LESSEQUAL"] = 23] = "LESSEQUAL";
    ERenderStateValues[ERenderStateValues["GREATER"] = 24] = "GREATER";
    ERenderStateValues[ERenderStateValues["NOTEQUAL"] = 25] = "NOTEQUAL";
    ERenderStateValues[ERenderStateValues["GREATEREQUAL"] = 26] = "GREATEREQUAL";
    ERenderStateValues[ERenderStateValues["ALWAYS"] = 27] = "ALWAYS";
    ERenderStateValues[ERenderStateValues["FUNCADD"] = 28] = "FUNCADD";
    ERenderStateValues[ERenderStateValues["FUNCSUBTRACT"] = 29] = "FUNCSUBTRACT";
    ERenderStateValues[ERenderStateValues["FUNCREVERSESUBTRACT"] = 30] = "FUNCREVERSESUBTRACT";
    // HACK: temp hack
    ERenderStateValues[ERenderStateValues["LINELIST"] = 31] = "LINELIST";
    ERenderStateValues[ERenderStateValues["LINESTRIP"] = 32] = "LINESTRIP";
    ERenderStateValues[ERenderStateValues["TRIANGLELIST"] = 33] = "TRIANGLELIST";
    ERenderStateValues[ERenderStateValues["TRAINGLESTRIP"] = 34] = "TRAINGLESTRIP";
    ERenderStateValues[ERenderStateValues["POINTLIST"] = 35] = "POINTLIST";
})(ERenderStateValues || (ERenderStateValues = {}));
/*
//
//
//

export enum BLEND {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    INV_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    INV_SRC_ALPHA = 6,
    DEST_ALPHA = 7,
    INV_DEST_ALPHA = 8,
    DEST_COLOR = 9,
    INV_DEST_COLOR = 10,
    SRC_ALPHA_SAT = 11,
    BLEND_FACTOR = 14,
    INV_BLEND_FACTOR = 15,
    SRC1_COLOR = 16,
    INV_SRC1_COLOR = 17,
    SRC1_ALPHA = 18,
    INV_SRC1_ALPHA = 19
};


export enum BLEND_OP {
    ADD = 1,
    SUBTRACT = 2,
    REV_SUBTRACT = 3,
    MIN = 4,
    MAX = 5
};


export class RENDER_TARGET_BLEND_DESC {
    BlendEnable: boolean;
    SrcBlend: BLEND;
    DestBlend: BLEND;
    BlendOp: BLEND_OP;
    SrcBlendAlpha: BLEND;
    DestBlendAlpha: BLEND;
    BlendOpAlpha: BLEND_OP;
    RenderTargetWriteMask: number;
};


//
//
//

export enum DEPTH_WRITE_MASK {
    ZERO = 0,
    ALL = 1
};


export enum COMPARISON_FUNC {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8
};


export enum STENCIL_OP {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_SAT = 4,
    DECR_SAT = 5,
    INVERT = 6,
    INCR = 7,
    DECR = 8
};


export class DEPTH_STENCILOP_DESC {
    StencilFailOp: STENCIL_OP;
    StencilDepthFailOp: STENCIL_OP;
    StencilPassOp: STENCIL_OP;
    StencilFunc: COMPARISON_FUNC;
};

//
//
//

export enum PRIMITIVE_TOPOLOGY {
    UNDEFINED = 0,
    POINTLIST = 1,
    LINELIST = 2,
    LINESTRIP = 3,
    TRIANGLELIST = 4,
    TRIANGLESTRIP = 5,
    LINELIST_ADJ = 10,
    LINESTRIP_ADJ = 11,
    TRIANGLELIST_ADJ = 12,
    TRIANGLESTRIP_ADJ = 13
};

//
//
//

enum CULL_MODE {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
    // ?
    FRONT_AND_BACK = 4
};


enum FILL_MODE {
    WIREFRAME = 2,
    SOLID = 3
};


class RASTERIZER_DESC {
    FillMode: FILL_MODE;
    CullMode: CULL_MODE;
    FrontCounterClockwise: boolean;
    DepthBias: number;
    DepthBiasClamp: number;
    SlopeScaledDepthBias: number;
    DepthClipEnable: boolean;
    ScissorEnable: boolean;
    MultisampleEnable: boolean;
    AntialiasedLineEnable: boolean;
}
*/


/***/ }),

/***/ "Y4FD":
/*!**************************************!*\
  !*** ./src/lib/idl/ERenderStates.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERenderStates": () => (/* binding */ ERenderStates)
/* harmony export */ });
/** @deprecated */
var ERenderStates;
(function (ERenderStates) {
    ERenderStates[ERenderStates["BLENDENABLE"] = 0] = "BLENDENABLE";
    ERenderStates[ERenderStates["CULLFACEENABLE"] = 1] = "CULLFACEENABLE";
    ERenderStates[ERenderStates["ZENABLE"] = 2] = "ZENABLE";
    ERenderStates[ERenderStates["ZWRITEENABLE"] = 3] = "ZWRITEENABLE";
    ERenderStates[ERenderStates["DITHERENABLE"] = 4] = "DITHERENABLE";
    ERenderStates[ERenderStates["SCISSORTESTENABLE"] = 5] = "SCISSORTESTENABLE";
    ERenderStates[ERenderStates["STENCILTESTENABLE"] = 6] = "STENCILTESTENABLE";
    ERenderStates[ERenderStates["POLYGONOFFSETFILLENABLE"] = 7] = "POLYGONOFFSETFILLENABLE";
    ERenderStates[ERenderStates["CULLFACE"] = 8] = "CULLFACE";
    ERenderStates[ERenderStates["FRONTFACE"] = 9] = "FRONTFACE";
    ERenderStates[ERenderStates["SRCBLENDCOLOR"] = 10] = "SRCBLENDCOLOR";
    ERenderStates[ERenderStates["DESTBLENDCOLOR"] = 11] = "DESTBLENDCOLOR";
    ERenderStates[ERenderStates["SRCBLENDALPHA"] = 12] = "SRCBLENDALPHA";
    ERenderStates[ERenderStates["DESTBLENDALPHA"] = 13] = "DESTBLENDALPHA";
    ERenderStates[ERenderStates["BLENDEQUATIONCOLOR"] = 14] = "BLENDEQUATIONCOLOR";
    ERenderStates[ERenderStates["BLENDEQUATIONALPHA"] = 15] = "BLENDEQUATIONALPHA";
    ERenderStates[ERenderStates["ZFUNC"] = 16] = "ZFUNC";
    ERenderStates[ERenderStates["ALPHABLENDENABLE"] = 17] = "ALPHABLENDENABLE";
    ERenderStates[ERenderStates["ALPHATESTENABLE"] = 18] = "ALPHATESTENABLE";
    ERenderStates[ERenderStates["SRCBLEND"] = 19] = "SRCBLEND";
    ERenderStates[ERenderStates["DESTBLEND"] = 20] = "DESTBLEND";
    ERenderStates[ERenderStates["BLENDFUNC"] = 21] = "BLENDFUNC";
    ERenderStates[ERenderStates["BLENDFUNCSEPARATE"] = 22] = "BLENDFUNCSEPARATE";
    ERenderStates[ERenderStates["BLENDEQUATION"] = 23] = "BLENDEQUATION";
    ERenderStates[ERenderStates["BLENDEQUATIONSEPARATE"] = 24] = "BLENDEQUATIONSEPARATE";
    // HACK:
    ERenderStates[ERenderStates["PRIMITIVETOPOLOGY"] = 25] = "PRIMITIVETOPOLOGY";
})(ERenderStates || (ERenderStates = {}));


/***/ }),

/***/ "DIkA":
/*!*************************************!*\
  !*** ./src/lib/idl/IDiagnostics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EDiagnosticCategory": () => (/* binding */ EDiagnosticCategory)
/* harmony export */ });
var EDiagnosticCategory;
(function (EDiagnosticCategory) {
    EDiagnosticCategory[EDiagnosticCategory["k_Warning"] = 0] = "k_Warning";
    EDiagnosticCategory[EDiagnosticCategory["k_Error"] = 1] = "k_Error";
})(EDiagnosticCategory || (EDiagnosticCategory = {}));


/***/ }),

/***/ "vIQR":
/*!*************************************!*\
  !*** ./src/lib/idl/IInstruction.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ECheckStage": () => (/* binding */ ECheckStage),
/* harmony export */   "EExtractExprType": () => (/* binding */ EExtractExprType),
/* harmony export */   "EInstructionTypes": () => (/* binding */ EInstructionTypes),
/* harmony export */   "EScopeType": () => (/* binding */ EScopeType),
/* harmony export */   "ETechniqueType": () => (/* binding */ ETechniqueType),
/* harmony export */   "EVarUsedMode": () => (/* binding */ EVarUsedMode)
/* harmony export */ });
var EInstructionTypes;
(function (EInstructionTypes) {
    EInstructionTypes[EInstructionTypes["k_Instruction"] = 0] = "k_Instruction";
    EInstructionTypes[EInstructionTypes["k_Id"] = 1] = "k_Id";
    EInstructionTypes[EInstructionTypes["k_Provide"] = 2] = "k_Provide";
    EInstructionTypes[EInstructionTypes["k_Collector"] = 3] = "k_Collector";
    EInstructionTypes[EInstructionTypes["k_Keyword"] = 4] = "k_Keyword";
    EInstructionTypes[EInstructionTypes["k_Simple"] = 5] = "k_Simple";
    EInstructionTypes[EInstructionTypes["k_SamplerState"] = 6] = "k_SamplerState";
    EInstructionTypes[EInstructionTypes["k_Attribute"] = 7] = "k_Attribute";
    EInstructionTypes[EInstructionTypes["k_Annotation"] = 8] = "k_Annotation";
    EInstructionTypes[EInstructionTypes["k_UsageType"] = 9] = "k_UsageType";
    EInstructionTypes[EInstructionTypes["k_Typed"] = 10] = "k_Typed";
    EInstructionTypes[EInstructionTypes["k_VariableType"] = 11] = "k_VariableType";
    EInstructionTypes[EInstructionTypes["k_SystemType"] = 12] = "k_SystemType";
    EInstructionTypes[EInstructionTypes["k_ComplexType"] = 13] = "k_ComplexType";
    EInstructionTypes[EInstructionTypes["k_ProxyType"] = 14] = "k_ProxyType";
    EInstructionTypes[EInstructionTypes["k_Expr"] = 15] = "k_Expr";
    EInstructionTypes[EInstructionTypes["k_IdExpr"] = 16] = "k_IdExpr";
    EInstructionTypes[EInstructionTypes["k_IntExpr"] = 17] = "k_IntExpr";
    EInstructionTypes[EInstructionTypes["k_FloatExpr"] = 18] = "k_FloatExpr";
    EInstructionTypes[EInstructionTypes["k_BoolExpr"] = 19] = "k_BoolExpr";
    EInstructionTypes[EInstructionTypes["k_StringExpr"] = 20] = "k_StringExpr";
    EInstructionTypes[EInstructionTypes["k_NullExpr"] = 21] = "k_NullExpr";
    EInstructionTypes[EInstructionTypes["k_ArithmeticExpr"] = 22] = "k_ArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_AssignmentExpr"] = 23] = "k_AssignmentExpr";
    EInstructionTypes[EInstructionTypes["k_BitwiseExpr"] = 24] = "k_BitwiseExpr";
    EInstructionTypes[EInstructionTypes["k_RelationalExpr"] = 25] = "k_RelationalExpr";
    EInstructionTypes[EInstructionTypes["k_LogicalExpr"] = 26] = "k_LogicalExpr";
    EInstructionTypes[EInstructionTypes["k_ConditionalExpr"] = 27] = "k_ConditionalExpr";
    EInstructionTypes[EInstructionTypes["k_CastExpr"] = 28] = "k_CastExpr";
    EInstructionTypes[EInstructionTypes["k_UnaryExpr"] = 29] = "k_UnaryExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixIndexExpr"] = 30] = "k_PostfixIndexExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixPointExpr"] = 31] = "k_PostfixPointExpr";
    EInstructionTypes[EInstructionTypes["k_PostfixArithmeticExpr"] = 32] = "k_PostfixArithmeticExpr";
    EInstructionTypes[EInstructionTypes["k_ComplexExpr"] = 33] = "k_ComplexExpr";
    EInstructionTypes[EInstructionTypes["k_FunctionCallExpr"] = 34] = "k_FunctionCallExpr";
    EInstructionTypes[EInstructionTypes["k_ConstructorCallExpr"] = 35] = "k_ConstructorCallExpr";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_CompileExpr"] = 36] = "k_CompileExpr";
    EInstructionTypes[EInstructionTypes["k_CompileShader11Expr"] = 37] = "k_CompileShader11Expr";
    EInstructionTypes[EInstructionTypes["k_InitExpr"] = 38] = "k_InitExpr";
    EInstructionTypes[EInstructionTypes["k_StateBlockExpr"] = 39] = "k_StateBlockExpr";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_SamplerStateBlockExpr"] = 40] = "k_SamplerStateBlockExpr";
    EInstructionTypes[EInstructionTypes["k_Decl"] = 41] = "k_Decl";
    EInstructionTypes[EInstructionTypes["k_TypeDecl"] = 42] = "k_TypeDecl";
    EInstructionTypes[EInstructionTypes["k_TypedefDecl"] = 43] = "k_TypedefDecl";
    EInstructionTypes[EInstructionTypes["k_VariableDecl"] = 44] = "k_VariableDecl";
    EInstructionTypes[EInstructionTypes["k_StructDecl"] = 45] = "k_StructDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDecl"] = 46] = "k_FunctionDecl";
    EInstructionTypes[EInstructionTypes["k_SystemFunctionDecl"] = 47] = "k_SystemFunctionDecl";
    EInstructionTypes[EInstructionTypes["k_FunctionDef"] = 48] = "k_FunctionDef";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_PassDecl"] = 49] = "k_PassDecl";
    /** @deprecated */
    EInstructionTypes[EInstructionTypes["k_TechniqueDecl"] = 50] = "k_TechniqueDecl";
    EInstructionTypes[EInstructionTypes["k_Technique11Decl"] = 51] = "k_Technique11Decl";
    EInstructionTypes[EInstructionTypes["k_CbufferDecl"] = 52] = "k_CbufferDecl";
    EInstructionTypes[EInstructionTypes["k_Stmt"] = 53] = "k_Stmt";
    EInstructionTypes[EInstructionTypes["k_ExprStmt"] = 54] = "k_ExprStmt";
    EInstructionTypes[EInstructionTypes["k_BreakStmt"] = 55] = "k_BreakStmt";
    EInstructionTypes[EInstructionTypes["k_WhileStmt"] = 56] = "k_WhileStmt";
    EInstructionTypes[EInstructionTypes["k_ForStmt"] = 57] = "k_ForStmt";
    EInstructionTypes[EInstructionTypes["k_IfStmt"] = 58] = "k_IfStmt";
    EInstructionTypes[EInstructionTypes["k_DeclStmt"] = 59] = "k_DeclStmt";
    EInstructionTypes[EInstructionTypes["k_ReturnStmt"] = 60] = "k_ReturnStmt";
    EInstructionTypes[EInstructionTypes["k_SemicolonStmt"] = 61] = "k_SemicolonStmt";
    EInstructionTypes[EInstructionTypes["k_StmtBlock"] = 62] = "k_StmtBlock";
    // part fx
    EInstructionTypes[EInstructionTypes["k_PartFxDecl"] = 63] = "k_PartFxDecl";
    EInstructionTypes[EInstructionTypes["k_PartFxPass"] = 64] = "k_PartFxPass";
    EInstructionTypes[EInstructionTypes["k_SpawnStmt"] = 65] = "k_SpawnStmt";
    EInstructionTypes[EInstructionTypes["k_DrawStmt"] = 66] = "k_DrawStmt";
    EInstructionTypes[EInstructionTypes["k_PresetDecl"] = 67] = "k_PresetDecl";
    EInstructionTypes[EInstructionTypes["k_PresetProperty"] = 68] = "k_PresetProperty";
})(EInstructionTypes || (EInstructionTypes = {}));
var ECheckStage;
(function (ECheckStage) {
    ECheckStage[ECheckStage["CODE_TARGET_SUPPORT"] = 0] = "CODE_TARGET_SUPPORT";
    ECheckStage[ECheckStage["SELF_CONTAINED"] = 1] = "SELF_CONTAINED"; /*  ,    , , .   . */
    // VALIDATION  /*      ,     */ 
})(ECheckStage || (ECheckStage = {}));
var EVarUsedMode;
(function (EVarUsedMode) {
    EVarUsedMode[EVarUsedMode["k_Read"] = 0] = "k_Read";
    EVarUsedMode[EVarUsedMode["k_Write"] = 1] = "k_Write";
    EVarUsedMode[EVarUsedMode["k_ReadWrite"] = 2] = "k_ReadWrite";
    EVarUsedMode[EVarUsedMode["k_Undefined"] = 3] = "k_Undefined";
    EVarUsedMode[EVarUsedMode["k_Default"] = 2] = "k_Default";
})(EVarUsedMode || (EVarUsedMode = {}));
var EExtractExprType;
(function (EExtractExprType) {
    EExtractExprType[EExtractExprType["k_Header"] = 0] = "k_Header";
    EExtractExprType[EExtractExprType["k_Float"] = 1] = "k_Float";
    EExtractExprType[EExtractExprType["k_Int"] = 2] = "k_Int";
    EExtractExprType[EExtractExprType["k_Bool"] = 3] = "k_Bool";
    EExtractExprType[EExtractExprType["k_Float2"] = 4] = "k_Float2";
    EExtractExprType[EExtractExprType["k_Int2"] = 5] = "k_Int2";
    EExtractExprType[EExtractExprType["k_Bool2"] = 6] = "k_Bool2";
    EExtractExprType[EExtractExprType["k_Float3"] = 7] = "k_Float3";
    EExtractExprType[EExtractExprType["k_Int3"] = 8] = "k_Int3";
    EExtractExprType[EExtractExprType["k_Bool3"] = 9] = "k_Bool3";
    EExtractExprType[EExtractExprType["k_Float4"] = 10] = "k_Float4";
    EExtractExprType[EExtractExprType["k_Int4"] = 11] = "k_Int4";
    EExtractExprType[EExtractExprType["k_Bool4"] = 12] = "k_Bool4";
    EExtractExprType[EExtractExprType["k_Float4x4"] = 13] = "k_Float4x4";
})(EExtractExprType || (EExtractExprType = {}));
var EScopeType;
(function (EScopeType) {
    EScopeType[EScopeType["k_System"] = 0] = "k_System";
    EScopeType[EScopeType["k_Global"] = 1] = "k_Global";
    EScopeType[EScopeType["k_Default"] = 2] = "k_Default";
    EScopeType[EScopeType["k_Struct"] = 3] = "k_Struct";
    EScopeType[EScopeType["k_Cbuffer"] = 4] = "k_Cbuffer";
    EScopeType[EScopeType["k_Annotation"] = 5] = "k_Annotation";
})(EScopeType || (EScopeType = {}));
;
var ETechniqueType;
(function (ETechniqueType) {
    ETechniqueType[ETechniqueType["k_BasicFx"] = 0] = "k_BasicFx";
    ETechniqueType[ETechniqueType["k_PartFx"] = 1] = "k_PartFx";
    ETechniqueType[ETechniqueType["k_Unknown"] = 2] = "k_Unknown";
})(ETechniqueType || (ETechniqueType = {}));


/***/ }),

/***/ "UHT2":
/*!************************************!*\
  !*** ./src/lib/idl/ITechnique9.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EUsage": () => (/* binding */ EUsage)
/* harmony export */ });
var EUsage;
(function (EUsage) {
    EUsage[EUsage["k_Vertex"] = 1] = "k_Vertex";
    EUsage[EUsage["k_Pixel"] = 2] = "k_Pixel";
    EUsage[EUsage["k_Compute"] = 4] = "k_Compute";
})(EUsage || (EUsage = {}));
;


/***/ }),

/***/ "4mVy":
/*!**********************************************!*\
  !*** ./src/lib/idl/bundles/auto/cbbundle.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CBBundle": () => (/* binding */ CBBundle),
/* harmony export */   "CBBundleT": () => (/* binding */ CBBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-field */ "O/5E");
// automatically generated by the FlatBuffers compiler, do not modify


class CBBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCBBundle(bb, obj) {
        return (obj || new CBBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCBBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new CBBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    slot() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    size() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _type_field__WEBPACK_IMPORTED_MODULE_1__.TypeField()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startCBBundle(builder) {
        builder.startObject(4);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addSlot(builder, slot) {
        builder.addFieldInt32(1, slot, 0);
    }
    static addSize(builder, size) {
        builder.addFieldInt32(2, size, 0);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(3, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endCBBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createCBBundle(builder, nameOffset, slot, size, fieldsOffset) {
        CBBundle.startCBBundle(builder);
        CBBundle.addName(builder, nameOffset);
        CBBundle.addSlot(builder, slot);
        CBBundle.addSize(builder, size);
        CBBundle.addFields(builder, fieldsOffset);
        return CBBundle.endCBBundle(builder);
    }
    unpack() {
        return new CBBundleT(this.name(), this.slot(), this.size(), this.bb.createObjList(this.fields.bind(this), this.fieldsLength()));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.slot = this.slot();
        _o.size = this.size();
        _o.fields = this.bb.createObjList(this.fields.bind(this), this.fieldsLength());
    }
}
class CBBundleT {
    constructor(name = null, slot = 0, size = 0, fields = []) {
        this.name = name;
        this.slot = slot;
        this.size = size;
        this.fields = fields;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const fields = CBBundle.createFieldsVector(builder, builder.createObjectOffsetList(this.fields));
        return CBBundle.createCBBundle(builder, name, this.slot, this.size, fields);
    }
}


/***/ }),

/***/ "IMqc":
/*!******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/buffer-bundle.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BufferBundle": () => (/* binding */ BufferBundle),
/* harmony export */   "BufferBundleT": () => (/* binding */ BufferBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify


class BufferBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBufferBundle(bb, obj) {
        return (obj || new BufferBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBufferBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new BufferBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    slot() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    stride() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_1__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startBufferBundle(builder) {
        builder.startObject(4);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addSlot(builder, slot) {
        builder.addFieldInt32(1, slot, 0);
    }
    static addStride(builder, stride) {
        builder.addFieldInt32(2, stride, 0);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static endBufferBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new BufferBundleT(this.name(), this.slot(), this.stride(), (this.type() !== null ? this.type().unpack() : null));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.slot = this.slot();
        _o.stride = this.stride();
        _o.type = (this.type() !== null ? this.type().unpack() : null);
    }
}
class BufferBundleT {
    constructor(name = null, slot = 0, stride = 0, type = null) {
        this.name = name;
        this.slot = slot;
        this.stride = stride;
        this.type = type;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const type = (this.type !== null ? this.type.pack(builder) : 0);
        BufferBundle.startBufferBundle(builder);
        BufferBundle.addName(builder, name);
        BufferBundle.addSlot(builder, this.slot);
        BufferBundle.addStride(builder, this.stride);
        BufferBundle.addType(builder, type);
        return BufferBundle.endBufferBundle(builder);
    }
}


/***/ }),

/***/ "RA5N":
/*!*******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/bundle-content.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BundleContent": () => (/* binding */ BundleContent),
/* harmony export */   "unionListToBundleContent": () => (/* binding */ unionListToBundleContent),
/* harmony export */   "unionToBundleContent": () => (/* binding */ unionToBundleContent)
/* harmony export */ });
/* harmony import */ var _fx_mat_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/mat-bundle */ "5RqF");
/* harmony import */ var _fx_part_bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/part-bundle */ "fPGG");
/* harmony import */ var _fx_technique11bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/technique11bundle */ "mGiJ");
// automatically generated by the FlatBuffers compiler, do not modify



var BundleContent;
(function (BundleContent) {
    BundleContent[BundleContent["NONE"] = 0] = "NONE";
    BundleContent[BundleContent["PartBundle"] = 1] = "PartBundle";
    BundleContent[BundleContent["MatBundle"] = 2] = "MatBundle";
    BundleContent[BundleContent["Technique11Bundle"] = 3] = "Technique11Bundle";
})(BundleContent || (BundleContent = {}));
function unionToBundleContent(type, accessor) {
    switch (BundleContent[type]) {
        case 'NONE': return null;
        case 'PartBundle': return accessor(new _fx_part_bundle__WEBPACK_IMPORTED_MODULE_1__.PartBundle());
        case 'MatBundle': return accessor(new _fx_mat_bundle__WEBPACK_IMPORTED_MODULE_0__.MatBundle());
        case 'Technique11Bundle': return accessor(new _fx_technique11bundle__WEBPACK_IMPORTED_MODULE_2__.Technique11Bundle());
        default: return null;
    }
}
function unionListToBundleContent(type, accessor, index) {
    switch (BundleContent[type]) {
        case 'NONE': return null;
        case 'PartBundle': return accessor(index, new _fx_part_bundle__WEBPACK_IMPORTED_MODULE_1__.PartBundle());
        case 'MatBundle': return accessor(index, new _fx_mat_bundle__WEBPACK_IMPORTED_MODULE_0__.MatBundle());
        case 'Technique11Bundle': return accessor(index, new _fx_technique11bundle__WEBPACK_IMPORTED_MODULE_2__.Technique11Bundle());
        default: return null;
    }
}


/***/ }),

/***/ "Q8lk":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/bundle-meta.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BundleMeta": () => (/* binding */ BundleMeta),
/* harmony export */   "BundleMetaT": () => (/* binding */ BundleMetaT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class BundleMeta {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBundleMeta(bb, obj) {
        return (obj || new BundleMeta()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBundleMeta(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new BundleMeta()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    author(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    source(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startBundleMeta(builder) {
        builder.startObject(2);
    }
    static addAuthor(builder, authorOffset) {
        builder.addFieldOffset(0, authorOffset, 0);
    }
    static addSource(builder, sourceOffset) {
        builder.addFieldOffset(1, sourceOffset, 0);
    }
    static endBundleMeta(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBundleMeta(builder, authorOffset, sourceOffset) {
        BundleMeta.startBundleMeta(builder);
        BundleMeta.addAuthor(builder, authorOffset);
        BundleMeta.addSource(builder, sourceOffset);
        return BundleMeta.endBundleMeta(builder);
    }
    unpack() {
        return new BundleMetaT(this.author(), this.source());
    }
    unpackTo(_o) {
        _o.author = this.author();
        _o.source = this.source();
    }
}
class BundleMetaT {
    constructor(author = null, source = null) {
        this.author = author;
        this.source = source;
    }
    pack(builder) {
        const author = (this.author !== null ? builder.createString(this.author) : 0);
        const source = (this.source !== null ? builder.createString(this.source) : 0);
        return BundleMeta.createBundleMeta(builder, author, source);
    }
}


/***/ }),

/***/ "Xra2":
/*!*********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/bundle-signature.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BundleSignature": () => (/* binding */ BundleSignature),
/* harmony export */   "BundleSignatureT": () => (/* binding */ BundleSignatureT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class BundleSignature {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBundleSignature(bb, obj) {
        return (obj || new BundleSignature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBundleSignature(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new BundleSignature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    version(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    commithash(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    branch(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    timestamp(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startBundleSignature(builder) {
        builder.startObject(5);
    }
    static addMode(builder, modeOffset) {
        builder.addFieldOffset(0, modeOffset, 0);
    }
    static addVersion(builder, versionOffset) {
        builder.addFieldOffset(1, versionOffset, 0);
    }
    static addCommithash(builder, commithashOffset) {
        builder.addFieldOffset(2, commithashOffset, 0);
    }
    static addBranch(builder, branchOffset) {
        builder.addFieldOffset(3, branchOffset, 0);
    }
    static addTimestamp(builder, timestampOffset) {
        builder.addFieldOffset(4, timestampOffset, 0);
    }
    static endBundleSignature(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBundleSignature(builder, modeOffset, versionOffset, commithashOffset, branchOffset, timestampOffset) {
        BundleSignature.startBundleSignature(builder);
        BundleSignature.addMode(builder, modeOffset);
        BundleSignature.addVersion(builder, versionOffset);
        BundleSignature.addCommithash(builder, commithashOffset);
        BundleSignature.addBranch(builder, branchOffset);
        BundleSignature.addTimestamp(builder, timestampOffset);
        return BundleSignature.endBundleSignature(builder);
    }
    unpack() {
        return new BundleSignatureT(this.mode(), this.version(), this.commithash(), this.branch(), this.timestamp());
    }
    unpackTo(_o) {
        _o.mode = this.mode();
        _o.version = this.version();
        _o.commithash = this.commithash();
        _o.branch = this.branch();
        _o.timestamp = this.timestamp();
    }
}
class BundleSignatureT {
    constructor(mode = null, version = null, commithash = null, branch = null, timestamp = null) {
        this.mode = mode;
        this.version = version;
        this.commithash = commithash;
        this.branch = branch;
        this.timestamp = timestamp;
    }
    pack(builder) {
        const mode = (this.mode !== null ? builder.createString(this.mode) : 0);
        const version = (this.version !== null ? builder.createString(this.version) : 0);
        const commithash = (this.commithash !== null ? builder.createString(this.commithash) : 0);
        const branch = (this.branch !== null ? builder.createString(this.branch) : 0);
        const timestamp = (this.timestamp !== null ? builder.createString(this.timestamp) : 0);
        return BundleSignature.createBundleSignature(builder, mode, version, commithash, branch, timestamp);
    }
}


/***/ }),

/***/ "AVkT":
/*!***********************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/bundle.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bundle": () => (/* binding */ Bundle),
/* harmony export */   "BundleT": () => (/* binding */ BundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/bundle-content */ "RA5N");
/* harmony import */ var _fx_bundle_meta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/bundle-meta */ "Q8lk");
/* harmony import */ var _fx_bundle_signature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fx/bundle-signature */ "Xra2");
/* harmony import */ var _fx_preset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fx/preset */ "BmuJ");
/* harmony import */ var _fx_uicontrol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../fx/uicontrol */ "E1+w");
// automatically generated by the FlatBuffers compiler, do not modify






class Bundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBundle(bb, obj) {
        return (obj || new Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    signature(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new _fx_bundle_signature__WEBPACK_IMPORTED_MODULE_3__.BundleSignature()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    meta(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _fx_bundle_meta__WEBPACK_IMPORTED_MODULE_2__.BundleMeta()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    contentType() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : _fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__.BundleContent.NONE;
    }
    content(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    controls(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new _fx_uicontrol__WEBPACK_IMPORTED_MODULE_5__.UIControl()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    controlsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    presets(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new _fx_preset__WEBPACK_IMPORTED_MODULE_4__.Preset()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    presetsLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startBundle(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addSignature(builder, signatureOffset) {
        builder.addFieldOffset(1, signatureOffset, 0);
    }
    static addMeta(builder, metaOffset) {
        builder.addFieldOffset(2, metaOffset, 0);
    }
    static addContentType(builder, contentType) {
        builder.addFieldInt8(3, contentType, _fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__.BundleContent.NONE);
    }
    static addContent(builder, contentOffset) {
        builder.addFieldOffset(4, contentOffset, 0);
    }
    static addControls(builder, controlsOffset) {
        builder.addFieldOffset(5, controlsOffset, 0);
    }
    static createControlsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startControlsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPresets(builder, presetsOffset) {
        builder.addFieldOffset(6, presetsOffset, 0);
    }
    static createPresetsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startPresetsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishBundleBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedBundleBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    unpack() {
        return new BundleT(this.name(), (this.signature() !== null ? this.signature().unpack() : null), (this.meta() !== null ? this.meta().unpack() : null), this.contentType(), (() => {
            let temp = (0,_fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__.unionToBundleContent)(this.contentType(), this.content.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.bb.createObjList(this.controls.bind(this), this.controlsLength()), this.bb.createObjList(this.presets.bind(this), this.presetsLength()));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.signature = (this.signature() !== null ? this.signature().unpack() : null);
        _o.meta = (this.meta() !== null ? this.meta().unpack() : null);
        _o.contentType = this.contentType();
        _o.content = (() => {
            let temp = (0,_fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__.unionToBundleContent)(this.contentType(), this.content.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.controls = this.bb.createObjList(this.controls.bind(this), this.controlsLength());
        _o.presets = this.bb.createObjList(this.presets.bind(this), this.presetsLength());
    }
}
class BundleT {
    constructor(name = null, signature = null, meta = null, contentType = _fx_bundle_content__WEBPACK_IMPORTED_MODULE_1__.BundleContent.NONE, content = null, controls = [], presets = []) {
        this.name = name;
        this.signature = signature;
        this.meta = meta;
        this.contentType = contentType;
        this.content = content;
        this.controls = controls;
        this.presets = presets;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const signature = (this.signature !== null ? this.signature.pack(builder) : 0);
        const meta = (this.meta !== null ? this.meta.pack(builder) : 0);
        const content = builder.createObjectOffset(this.content);
        const controls = Bundle.createControlsVector(builder, builder.createObjectOffsetList(this.controls));
        const presets = Bundle.createPresetsVector(builder, builder.createObjectOffsetList(this.presets));
        Bundle.startBundle(builder);
        Bundle.addName(builder, name);
        Bundle.addSignature(builder, signature);
        Bundle.addMeta(builder, meta);
        Bundle.addContentType(builder, this.contentType);
        Bundle.addContent(builder, content);
        Bundle.addControls(builder, controls);
        Bundle.addPresets(builder, presets);
        return Bundle.endBundle(builder);
    }
}


/***/ }),

/***/ "Lmwj":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/color-value.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorValue": () => (/* binding */ ColorValue),
/* harmony export */   "ColorValueT": () => (/* binding */ ColorValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class ColorValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    r() {
        return this.bb.readUint8(this.bb_pos);
    }
    g() {
        return this.bb.readUint8(this.bb_pos + 1);
    }
    b() {
        return this.bb.readUint8(this.bb_pos + 2);
    }
    a() {
        return this.bb.readUint8(this.bb_pos + 3);
    }
    static sizeOf() {
        return 4;
    }
    static createColorValue(builder, r, g, b, a) {
        builder.prep(1, 4);
        builder.writeInt8(a);
        builder.writeInt8(b);
        builder.writeInt8(g);
        builder.writeInt8(r);
        return builder.offset();
    }
    unpack() {
        return new ColorValueT(this.r(), this.g(), this.b(), this.a());
    }
    unpackTo(_o) {
        _o.r = this.r();
        _o.g = this.g();
        _o.b = this.b();
        _o.a = this.a();
    }
}
class ColorValueT {
    constructor(r = 0, g = 0, b = 0, a = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    pack(builder) {
        return ColorValue.createColorValue(builder, this.r, this.g, this.b, this.a);
    }
}


/***/ }),

/***/ "Nk0z":
/*!******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/control-value.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControlValue": () => (/* binding */ ControlValue),
/* harmony export */   "unionListToControlValue": () => (/* binding */ unionListToControlValue),
/* harmony export */   "unionToControlValue": () => (/* binding */ unionToControlValue)
/* harmony export */ });
/* harmony import */ var _fx_color_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/color-value */ "Lmwj");
/* harmony import */ var _fx_float2value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/float2value */ "cHyH");
/* harmony import */ var _fx_float3value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/float3value */ "Gjvx");
/* harmony import */ var _fx_float4value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fx/float4value */ "6wsJ");
/* harmony import */ var _fx_float_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fx/float-value */ "5CMk");
/* harmony import */ var _fx_int_value__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../fx/int-value */ "IJKq");
/* harmony import */ var _fx_mesh_value__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../fx/mesh-value */ "6gZf");
/* harmony import */ var _fx_texture_value__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../fx/texture-value */ "J5jW");
/* harmony import */ var _fx_uint_value__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../fx/uint-value */ "1Yqr");
// automatically generated by the FlatBuffers compiler, do not modify









var ControlValue;
(function (ControlValue) {
    ControlValue[ControlValue["NONE"] = 0] = "NONE";
    ControlValue[ControlValue["UintValue"] = 1] = "UintValue";
    ControlValue[ControlValue["IntValue"] = 2] = "IntValue";
    ControlValue[ControlValue["FloatValue"] = 3] = "FloatValue";
    ControlValue[ControlValue["Float2Value"] = 4] = "Float2Value";
    ControlValue[ControlValue["Float3Value"] = 5] = "Float3Value";
    ControlValue[ControlValue["Float4Value"] = 6] = "Float4Value";
    ControlValue[ControlValue["ColorValue"] = 7] = "ColorValue";
    ControlValue[ControlValue["TextureValue"] = 8] = "TextureValue";
    ControlValue[ControlValue["MeshValue"] = 9] = "MeshValue";
})(ControlValue || (ControlValue = {}));
function unionToControlValue(type, accessor) {
    switch (ControlValue[type]) {
        case 'NONE': return null;
        case 'UintValue': return accessor(new _fx_uint_value__WEBPACK_IMPORTED_MODULE_8__.UintValue());
        case 'IntValue': return accessor(new _fx_int_value__WEBPACK_IMPORTED_MODULE_5__.IntValue());
        case 'FloatValue': return accessor(new _fx_float_value__WEBPACK_IMPORTED_MODULE_4__.FloatValue());
        case 'Float2Value': return accessor(new _fx_float2value__WEBPACK_IMPORTED_MODULE_1__.Float2Value());
        case 'Float3Value': return accessor(new _fx_float3value__WEBPACK_IMPORTED_MODULE_2__.Float3Value());
        case 'Float4Value': return accessor(new _fx_float4value__WEBPACK_IMPORTED_MODULE_3__.Float4Value());
        case 'ColorValue': return accessor(new _fx_color_value__WEBPACK_IMPORTED_MODULE_0__.ColorValue());
        case 'TextureValue': return accessor(new _fx_texture_value__WEBPACK_IMPORTED_MODULE_7__.TextureValue());
        case 'MeshValue': return accessor(new _fx_mesh_value__WEBPACK_IMPORTED_MODULE_6__.MeshValue());
        default: return null;
    }
}
function unionListToControlValue(type, accessor, index) {
    switch (ControlValue[type]) {
        case 'NONE': return null;
        case 'UintValue': return accessor(index, new _fx_uint_value__WEBPACK_IMPORTED_MODULE_8__.UintValue());
        case 'IntValue': return accessor(index, new _fx_int_value__WEBPACK_IMPORTED_MODULE_5__.IntValue());
        case 'FloatValue': return accessor(index, new _fx_float_value__WEBPACK_IMPORTED_MODULE_4__.FloatValue());
        case 'Float2Value': return accessor(index, new _fx_float2value__WEBPACK_IMPORTED_MODULE_1__.Float2Value());
        case 'Float3Value': return accessor(index, new _fx_float3value__WEBPACK_IMPORTED_MODULE_2__.Float3Value());
        case 'Float4Value': return accessor(index, new _fx_float4value__WEBPACK_IMPORTED_MODULE_3__.Float4Value());
        case 'ColorValue': return accessor(index, new _fx_color_value__WEBPACK_IMPORTED_MODULE_0__.ColorValue());
        case 'TextureValue': return accessor(index, new _fx_texture_value__WEBPACK_IMPORTED_MODULE_7__.TextureValue());
        case 'MeshValue': return accessor(index, new _fx_mesh_value__WEBPACK_IMPORTED_MODULE_6__.MeshValue());
        default: return null;
    }
}


/***/ }),

/***/ "Eive":
/*!*************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/emat-render-routines.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMatRenderRoutines": () => (/* binding */ EMatRenderRoutines)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
var EMatRenderRoutines;
(function (EMatRenderRoutines) {
    EMatRenderRoutines[EMatRenderRoutines["k_Vertex"] = 0] = "k_Vertex";
    EMatRenderRoutines[EMatRenderRoutines["k_Pixel"] = 1] = "k_Pixel";
    EMatRenderRoutines[EMatRenderRoutines["k_Last"] = 2] = "k_Last";
})(EMatRenderRoutines || (EMatRenderRoutines = {}));


/***/ }),

/***/ "wC6P":
/*!**************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/epart-render-routines.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPartRenderRoutines": () => (/* binding */ EPartRenderRoutines)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
var EPartRenderRoutines;
(function (EPartRenderRoutines) {
    EPartRenderRoutines[EPartRenderRoutines["k_Prerender"] = 0] = "k_Prerender";
    EPartRenderRoutines[EPartRenderRoutines["k_Vertex"] = 1] = "k_Vertex";
    EPartRenderRoutines[EPartRenderRoutines["k_Pixel"] = 2] = "k_Pixel";
    EPartRenderRoutines[EPartRenderRoutines["k_Last"] = 3] = "k_Last";
})(EPartRenderRoutines || (EPartRenderRoutines = {}));


/***/ }),

/***/ "2IwD":
/*!***********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/epart-sim-routines.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPartSimRoutines": () => (/* binding */ EPartSimRoutines)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
var EPartSimRoutines;
(function (EPartSimRoutines) {
    EPartSimRoutines[EPartSimRoutines["k_Reset"] = 0] = "k_Reset";
    EPartSimRoutines[EPartSimRoutines["k_Spawn"] = 1] = "k_Spawn";
    EPartSimRoutines[EPartSimRoutines["k_Init"] = 2] = "k_Init";
    EPartSimRoutines[EPartSimRoutines["k_Update"] = 3] = "k_Update";
    EPartSimRoutines[EPartSimRoutines["k_Last"] = 4] = "k_Last";
})(EPartSimRoutines || (EPartSimRoutines = {}));


/***/ }),

/***/ "5CMk":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/float-value.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FloatValue": () => (/* binding */ FloatValue),
/* harmony export */   "FloatValueT": () => (/* binding */ FloatValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class FloatValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    value() {
        return this.bb.readFloat32(this.bb_pos);
    }
    static sizeOf() {
        return 4;
    }
    static createFloatValue(builder, value) {
        builder.prep(4, 4);
        builder.writeFloat32(value);
        return builder.offset();
    }
    unpack() {
        return new FloatValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class FloatValueT {
    constructor(value = 0.0) {
        this.value = value;
    }
    pack(builder) {
        return FloatValue.createFloatValue(builder, this.value);
    }
}


/***/ }),

/***/ "cHyH":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/float2value.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Float2Value": () => (/* binding */ Float2Value),
/* harmony export */   "Float2ValueT": () => (/* binding */ Float2ValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class Float2Value {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    x() {
        return this.bb.readFloat32(this.bb_pos);
    }
    y() {
        return this.bb.readFloat32(this.bb_pos + 4);
    }
    static sizeOf() {
        return 8;
    }
    static createFloat2Value(builder, x, y) {
        builder.prep(4, 8);
        builder.writeFloat32(y);
        builder.writeFloat32(x);
        return builder.offset();
    }
    unpack() {
        return new Float2ValueT(this.x(), this.y());
    }
    unpackTo(_o) {
        _o.x = this.x();
        _o.y = this.y();
    }
}
class Float2ValueT {
    constructor(x = 0.0, y = 0.0) {
        this.x = x;
        this.y = y;
    }
    pack(builder) {
        return Float2Value.createFloat2Value(builder, this.x, this.y);
    }
}


/***/ }),

/***/ "Gjvx":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/float3value.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Float3Value": () => (/* binding */ Float3Value),
/* harmony export */   "Float3ValueT": () => (/* binding */ Float3ValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class Float3Value {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    x() {
        return this.bb.readFloat32(this.bb_pos);
    }
    y() {
        return this.bb.readFloat32(this.bb_pos + 4);
    }
    z() {
        return this.bb.readFloat32(this.bb_pos + 8);
    }
    static sizeOf() {
        return 12;
    }
    static createFloat3Value(builder, x, y, z) {
        builder.prep(4, 12);
        builder.writeFloat32(z);
        builder.writeFloat32(y);
        builder.writeFloat32(x);
        return builder.offset();
    }
    unpack() {
        return new Float3ValueT(this.x(), this.y(), this.z());
    }
    unpackTo(_o) {
        _o.x = this.x();
        _o.y = this.y();
        _o.z = this.z();
    }
}
class Float3ValueT {
    constructor(x = 0.0, y = 0.0, z = 0.0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    pack(builder) {
        return Float3Value.createFloat3Value(builder, this.x, this.y, this.z);
    }
}


/***/ }),

/***/ "6wsJ":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/float4value.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Float4Value": () => (/* binding */ Float4Value),
/* harmony export */   "Float4ValueT": () => (/* binding */ Float4ValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class Float4Value {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    x() {
        return this.bb.readFloat32(this.bb_pos);
    }
    y() {
        return this.bb.readFloat32(this.bb_pos + 4);
    }
    z() {
        return this.bb.readFloat32(this.bb_pos + 8);
    }
    w() {
        return this.bb.readFloat32(this.bb_pos + 12);
    }
    static sizeOf() {
        return 16;
    }
    static createFloat4Value(builder, x, y, z, w) {
        builder.prep(4, 16);
        builder.writeFloat32(w);
        builder.writeFloat32(z);
        builder.writeFloat32(y);
        builder.writeFloat32(x);
        return builder.offset();
    }
    unpack() {
        return new Float4ValueT(this.x(), this.y(), this.z(), this.w());
    }
    unpackTo(_o) {
        _o.x = this.x();
        _o.y = this.y();
        _o.z = this.z();
        _o.w = this.w();
    }
}
class Float4ValueT {
    constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    pack(builder) {
        return Float4Value.createFloat4Value(builder, this.x, this.y, this.z, this.w);
    }
}


/***/ }),

/***/ "gp8H":
/*!******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/glslattribute.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLSLAttribute": () => (/* binding */ GLSLAttribute),
/* harmony export */   "GLSLAttributeT": () => (/* binding */ GLSLAttributeT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class GLSLAttribute {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGLSLAttribute(bb, obj) {
        return (obj || new GLSLAttribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGLSLAttribute(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new GLSLAttribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    offset() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startGLSLAttribute(builder) {
        builder.startObject(3);
    }
    static addSize(builder, size) {
        builder.addFieldInt32(0, size, 0);
    }
    static addOffset(builder, offset) {
        builder.addFieldInt32(1, offset, 0);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(2, nameOffset, 0);
    }
    static endGLSLAttribute(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createGLSLAttribute(builder, size, offset, nameOffset) {
        GLSLAttribute.startGLSLAttribute(builder);
        GLSLAttribute.addSize(builder, size);
        GLSLAttribute.addOffset(builder, offset);
        GLSLAttribute.addName(builder, nameOffset);
        return GLSLAttribute.endGLSLAttribute(builder);
    }
    unpack() {
        return new GLSLAttributeT(this.size(), this.offset(), this.name());
    }
    unpackTo(_o) {
        _o.size = this.size();
        _o.offset = this.offset();
        _o.name = this.name();
    }
}
class GLSLAttributeT {
    constructor(size = 0, offset = 0, name = null) {
        this.size = size;
        this.offset = offset;
        this.name = name;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        return GLSLAttribute.createGLSLAttribute(builder, this.size, this.offset, name);
    }
}


/***/ }),

/***/ "IJKq":
/*!**************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/int-value.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntValue": () => (/* binding */ IntValue),
/* harmony export */   "IntValueT": () => (/* binding */ IntValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class IntValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    value() {
        return this.bb.readInt32(this.bb_pos);
    }
    static sizeOf() {
        return 4;
    }
    static createIntValue(builder, value) {
        builder.prep(4, 4);
        builder.writeInt32(value);
        return builder.offset();
    }
    unpack() {
        return new IntValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class IntValueT {
    constructor(value = 0) {
        this.value = value;
    }
    pack(builder) {
        return IntValue.createIntValue(builder, this.value);
    }
}


/***/ }),

/***/ "5RqF":
/*!***************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/mat-bundle.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MatBundle": () => (/* binding */ MatBundle),
/* harmony export */   "MatBundleT": () => (/* binding */ MatBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_mat_render_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/mat-render-pass */ "4U8C");
// automatically generated by the FlatBuffers compiler, do not modify


class MatBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMatBundle(bb, obj) {
        return (obj || new MatBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMatBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new MatBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    renderPasses(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new _fx_mat_render_pass__WEBPACK_IMPORTED_MODULE_1__.MatRenderPass()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    renderPassesLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMatBundle(builder) {
        builder.startObject(1);
    }
    static addRenderPasses(builder, renderPassesOffset) {
        builder.addFieldOffset(0, renderPassesOffset, 0);
    }
    static createRenderPassesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRenderPassesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMatBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createMatBundle(builder, renderPassesOffset) {
        MatBundle.startMatBundle(builder);
        MatBundle.addRenderPasses(builder, renderPassesOffset);
        return MatBundle.endMatBundle(builder);
    }
    unpack() {
        return new MatBundleT(this.bb.createObjList(this.renderPasses.bind(this), this.renderPassesLength()));
    }
    unpackTo(_o) {
        _o.renderPasses = this.bb.createObjList(this.renderPasses.bind(this), this.renderPassesLength());
    }
}
class MatBundleT {
    constructor(renderPasses = []) {
        this.renderPasses = renderPasses;
    }
    pack(builder) {
        const renderPasses = MatBundle.createRenderPassesVector(builder, builder.createObjectOffsetList(this.renderPasses));
        return MatBundle.createMatBundle(builder, renderPasses);
    }
}


/***/ }),

/***/ "4U8C":
/*!********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/mat-render-pass.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MatRenderPass": () => (/* binding */ MatRenderPass),
/* harmony export */   "MatRenderPassT": () => (/* binding */ MatRenderPassT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_render_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/render-state */ "2KDM");
/* harmony import */ var _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/routine-bundle */ "+VBS");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify




class MatRenderPass {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMatRenderPass(bb, obj) {
        return (obj || new MatRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMatRenderPass(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new MatRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    routinesType(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    routinesTypeLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    routinesTypeArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    routines(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    routinesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    instance(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_3__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    stride() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    renderStates(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new _fx_render_state__WEBPACK_IMPORTED_MODULE_1__.RenderState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    renderStatesLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMatRenderPass(builder) {
        builder.startObject(5);
    }
    static addRoutinesType(builder, routinesTypeOffset) {
        builder.addFieldOffset(0, routinesTypeOffset, 0);
    }
    static createRoutinesTypeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startRoutinesTypeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addRoutines(builder, routinesOffset) {
        builder.addFieldOffset(1, routinesOffset, 0);
    }
    static createRoutinesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRoutinesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addInstance(builder, instanceOffset) {
        builder.addFieldOffset(2, instanceOffset, 0);
    }
    static addStride(builder, stride) {
        builder.addFieldInt32(3, stride, 0);
    }
    static addRenderStates(builder, renderStatesOffset) {
        builder.addFieldOffset(4, renderStatesOffset, 0);
    }
    static createRenderStatesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRenderStatesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMatRenderPass(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new MatRenderPassT(this.bb.createScalarList(this.routinesType.bind(this), this.routinesTypeLength()), (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.routinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.routines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })(), (this.instance() !== null ? this.instance().unpack() : null), this.stride(), this.bb.createObjList(this.renderStates.bind(this), this.renderStatesLength()));
    }
    unpackTo(_o) {
        _o.routinesType = this.bb.createScalarList(this.routinesType.bind(this), this.routinesTypeLength());
        _o.routines = (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.routinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.routines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
        _o.instance = (this.instance() !== null ? this.instance().unpack() : null);
        _o.stride = this.stride();
        _o.renderStates = this.bb.createObjList(this.renderStates.bind(this), this.renderStatesLength());
    }
}
class MatRenderPassT {
    constructor(routinesType = [], routines = [], instance = null, stride = 0, renderStates = []) {
        this.routinesType = routinesType;
        this.routines = routines;
        this.instance = instance;
        this.stride = stride;
        this.renderStates = renderStates;
    }
    pack(builder) {
        const routinesType = MatRenderPass.createRoutinesTypeVector(builder, this.routinesType);
        const routines = MatRenderPass.createRoutinesVector(builder, builder.createObjectOffsetList(this.routines));
        const instance = (this.instance !== null ? this.instance.pack(builder) : 0);
        const renderStates = MatRenderPass.createRenderStatesVector(builder, builder.createObjectOffsetList(this.renderStates));
        MatRenderPass.startMatRenderPass(builder);
        MatRenderPass.addRoutinesType(builder, routinesType);
        MatRenderPass.addRoutines(builder, routines);
        MatRenderPass.addInstance(builder, instance);
        MatRenderPass.addStride(builder, this.stride);
        MatRenderPass.addRenderStates(builder, renderStates);
        return MatRenderPass.endMatRenderPass(builder);
    }
}


/***/ }),

/***/ "6gZf":
/*!***************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/mesh-value.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshValue": () => (/* binding */ MeshValue),
/* harmony export */   "MeshValueT": () => (/* binding */ MeshValueT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class MeshValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMeshValue(bb, obj) {
        return (obj || new MeshValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMeshValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new MeshValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startMeshValue(builder) {
        builder.startObject(1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(0, valueOffset, 0);
    }
    static endMeshValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createMeshValue(builder, valueOffset) {
        MeshValue.startMeshValue(builder);
        MeshValue.addValue(builder, valueOffset);
        return MeshValue.endMeshValue(builder);
    }
    unpack() {
        return new MeshValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class MeshValueT {
    constructor(value = null) {
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return MeshValue.createMeshValue(builder, value);
    }
}


/***/ }),

/***/ "fPGG":
/*!****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/part-bundle.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartBundle": () => (/* binding */ PartBundle),
/* harmony export */   "PartBundleT": () => (/* binding */ PartBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_part_render_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/part-render-pass */ "bJcc");
/* harmony import */ var _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/routine-bundle */ "+VBS");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify




class PartBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPartBundle(bb, obj) {
        return (obj || new PartBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPartBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new PartBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    capacity() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    simulationRoutinesType(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    simulationRoutinesTypeLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    simulationRoutinesTypeArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    simulationRoutines(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    simulationRoutinesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    renderPasses(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _fx_part_render_pass__WEBPACK_IMPORTED_MODULE_1__.PartRenderPass()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    renderPassesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    particle(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_3__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startPartBundle(builder) {
        builder.startObject(5);
    }
    static addCapacity(builder, capacity) {
        builder.addFieldInt32(0, capacity, 0);
    }
    static addSimulationRoutinesType(builder, simulationRoutinesTypeOffset) {
        builder.addFieldOffset(1, simulationRoutinesTypeOffset, 0);
    }
    static createSimulationRoutinesTypeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startSimulationRoutinesTypeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addSimulationRoutines(builder, simulationRoutinesOffset) {
        builder.addFieldOffset(2, simulationRoutinesOffset, 0);
    }
    static createSimulationRoutinesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSimulationRoutinesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRenderPasses(builder, renderPassesOffset) {
        builder.addFieldOffset(3, renderPassesOffset, 0);
    }
    static createRenderPassesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRenderPassesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addParticle(builder, particleOffset) {
        builder.addFieldOffset(4, particleOffset, 0);
    }
    static endPartBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new PartBundleT(this.capacity(), this.bb.createScalarList(this.simulationRoutinesType.bind(this), this.simulationRoutinesTypeLength()), (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.simulationRoutinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.simulationRoutinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.simulationRoutines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })(), this.bb.createObjList(this.renderPasses.bind(this), this.renderPassesLength()), (this.particle() !== null ? this.particle().unpack() : null));
    }
    unpackTo(_o) {
        _o.capacity = this.capacity();
        _o.simulationRoutinesType = this.bb.createScalarList(this.simulationRoutinesType.bind(this), this.simulationRoutinesTypeLength());
        _o.simulationRoutines = (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.simulationRoutinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.simulationRoutinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.simulationRoutines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
        _o.renderPasses = this.bb.createObjList(this.renderPasses.bind(this), this.renderPassesLength());
        _o.particle = (this.particle() !== null ? this.particle().unpack() : null);
    }
}
class PartBundleT {
    constructor(capacity = 0, simulationRoutinesType = [], simulationRoutines = [], renderPasses = [], particle = null) {
        this.capacity = capacity;
        this.simulationRoutinesType = simulationRoutinesType;
        this.simulationRoutines = simulationRoutines;
        this.renderPasses = renderPasses;
        this.particle = particle;
    }
    pack(builder) {
        const simulationRoutinesType = PartBundle.createSimulationRoutinesTypeVector(builder, this.simulationRoutinesType);
        const simulationRoutines = PartBundle.createSimulationRoutinesVector(builder, builder.createObjectOffsetList(this.simulationRoutines));
        const renderPasses = PartBundle.createRenderPassesVector(builder, builder.createObjectOffsetList(this.renderPasses));
        const particle = (this.particle !== null ? this.particle.pack(builder) : 0);
        PartBundle.startPartBundle(builder);
        PartBundle.addCapacity(builder, this.capacity);
        PartBundle.addSimulationRoutinesType(builder, simulationRoutinesType);
        PartBundle.addSimulationRoutines(builder, simulationRoutines);
        PartBundle.addRenderPasses(builder, renderPasses);
        PartBundle.addParticle(builder, particle);
        return PartBundle.endPartBundle(builder);
    }
}


/***/ }),

/***/ "bJcc":
/*!*********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/part-render-pass.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PartRenderPass": () => (/* binding */ PartRenderPass),
/* harmony export */   "PartRenderPassT": () => (/* binding */ PartRenderPassT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_render_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/render-state */ "2KDM");
/* harmony import */ var _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/routine-bundle */ "+VBS");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify




class PartRenderPass {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPartRenderPass(bb, obj) {
        return (obj || new PartRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPartRenderPass(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new PartRenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    routinesType(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    routinesTypeLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    routinesTypeArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    routines(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    routinesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    geometry(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    sorting() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    instanceCount() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    stride() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    instance(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_3__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    renderStates(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? (obj || new _fx_render_state__WEBPACK_IMPORTED_MODULE_1__.RenderState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    renderStatesLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startPartRenderPass(builder) {
        builder.startObject(8);
    }
    static addRoutinesType(builder, routinesTypeOffset) {
        builder.addFieldOffset(0, routinesTypeOffset, 0);
    }
    static createRoutinesTypeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startRoutinesTypeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addRoutines(builder, routinesOffset) {
        builder.addFieldOffset(1, routinesOffset, 0);
    }
    static createRoutinesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRoutinesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addGeometry(builder, geometryOffset) {
        builder.addFieldOffset(2, geometryOffset, 0);
    }
    static addSorting(builder, sorting) {
        builder.addFieldInt8(3, +sorting, +false);
    }
    static addInstanceCount(builder, instanceCount) {
        builder.addFieldInt32(4, instanceCount, 0);
    }
    static addStride(builder, stride) {
        builder.addFieldInt32(5, stride, 0);
    }
    static addInstance(builder, instanceOffset) {
        builder.addFieldOffset(6, instanceOffset, 0);
    }
    static addRenderStates(builder, renderStatesOffset) {
        builder.addFieldOffset(7, renderStatesOffset, 0);
    }
    static createRenderStatesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRenderStatesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endPartRenderPass(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new PartRenderPassT(this.bb.createScalarList(this.routinesType.bind(this), this.routinesTypeLength()), (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.routinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.routines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })(), this.geometry(), this.sorting(), this.instanceCount(), this.stride(), (this.instance() !== null ? this.instance().unpack() : null), this.bb.createObjList(this.renderStates.bind(this), this.renderStatesLength()));
    }
    unpackTo(_o) {
        _o.routinesType = this.bb.createScalarList(this.routinesType.bind(this), this.routinesTypeLength());
        _o.routines = (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.routinesTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.routinesType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.RoutineBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_bundle__WEBPACK_IMPORTED_MODULE_2__.unionListToRoutineBundle)(targetEnum, this.routines.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
        _o.geometry = this.geometry();
        _o.sorting = this.sorting();
        _o.instanceCount = this.instanceCount();
        _o.stride = this.stride();
        _o.instance = (this.instance() !== null ? this.instance().unpack() : null);
        _o.renderStates = this.bb.createObjList(this.renderStates.bind(this), this.renderStatesLength());
    }
}
class PartRenderPassT {
    constructor(routinesType = [], routines = [], geometry = null, sorting = false, instanceCount = 0, stride = 0, instance = null, renderStates = []) {
        this.routinesType = routinesType;
        this.routines = routines;
        this.geometry = geometry;
        this.sorting = sorting;
        this.instanceCount = instanceCount;
        this.stride = stride;
        this.instance = instance;
        this.renderStates = renderStates;
    }
    pack(builder) {
        const routinesType = PartRenderPass.createRoutinesTypeVector(builder, this.routinesType);
        const routines = PartRenderPass.createRoutinesVector(builder, builder.createObjectOffsetList(this.routines));
        const geometry = (this.geometry !== null ? builder.createString(this.geometry) : 0);
        const instance = (this.instance !== null ? this.instance.pack(builder) : 0);
        const renderStates = PartRenderPass.createRenderStatesVector(builder, builder.createObjectOffsetList(this.renderStates));
        PartRenderPass.startPartRenderPass(builder);
        PartRenderPass.addRoutinesType(builder, routinesType);
        PartRenderPass.addRoutines(builder, routines);
        PartRenderPass.addGeometry(builder, geometry);
        PartRenderPass.addSorting(builder, this.sorting);
        PartRenderPass.addInstanceCount(builder, this.instanceCount);
        PartRenderPass.addStride(builder, this.stride);
        PartRenderPass.addInstance(builder, instance);
        PartRenderPass.addRenderStates(builder, renderStates);
        return PartRenderPass.endPartRenderPass(builder);
    }
}


/***/ }),

/***/ "23YT":
/*!*****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/pixel-shader.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelShader": () => (/* binding */ PixelShader),
/* harmony export */   "PixelShaderT": () => (/* binding */ PixelShaderT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _cbbundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cbbundle */ "4mVy");
// automatically generated by the FlatBuffers compiler, do not modify


class PixelShader {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPixelShader(bb, obj) {
        return (obj || new PixelShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPixelShader(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new PixelShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    entryName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    cbuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _cbbundle__WEBPACK_IMPORTED_MODULE_1__.CBBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    cbuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startPixelShader(builder) {
        builder.startObject(3);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static addEntryName(builder, entryNameOffset) {
        builder.addFieldOffset(1, entryNameOffset, 0);
    }
    static addCbuffers(builder, cbuffersOffset) {
        builder.addFieldOffset(2, cbuffersOffset, 0);
    }
    static createCbuffersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCbuffersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endPixelShader(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createPixelShader(builder, codeOffset, entryNameOffset, cbuffersOffset) {
        PixelShader.startPixelShader(builder);
        PixelShader.addCode(builder, codeOffset);
        PixelShader.addEntryName(builder, entryNameOffset);
        PixelShader.addCbuffers(builder, cbuffersOffset);
        return PixelShader.endPixelShader(builder);
    }
    unpack() {
        return new PixelShaderT(this.code(), this.entryName(), this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength()));
    }
    unpackTo(_o) {
        _o.code = this.code();
        _o.entryName = this.entryName();
        _o.cbuffers = this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength());
    }
}
class PixelShaderT {
    constructor(code = null, entryName = null, cbuffers = []) {
        this.code = code;
        this.entryName = entryName;
        this.cbuffers = cbuffers;
    }
    pack(builder) {
        const code = (this.code !== null ? builder.createString(this.code) : 0);
        const entryName = (this.entryName !== null ? builder.createString(this.entryName) : 0);
        const cbuffers = PixelShader.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));
        return PixelShader.createPixelShader(builder, code, entryName, cbuffers);
    }
}


/***/ }),

/***/ "zGvL":
/*!*****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/preset-entry.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PresetEntry": () => (/* binding */ PresetEntry),
/* harmony export */   "PresetEntryT": () => (/* binding */ PresetEntryT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_control_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/control-value */ "Nk0z");
// automatically generated by the FlatBuffers compiler, do not modify


class PresetEntry {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPresetEntry(bb, obj) {
        return (obj || new PresetEntry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPresetEntry(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new PresetEntry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    valueType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE;
    }
    value(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startPresetEntry(builder) {
        builder.startObject(3);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addValueType(builder, valueType) {
        builder.addFieldInt8(1, valueType, _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(2, valueOffset, 0);
    }
    static endPresetEntry(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createPresetEntry(builder, nameOffset, valueType, valueOffset) {
        PresetEntry.startPresetEntry(builder);
        PresetEntry.addName(builder, nameOffset);
        PresetEntry.addValueType(builder, valueType);
        PresetEntry.addValue(builder, valueOffset);
        return PresetEntry.endPresetEntry(builder);
    }
    unpack() {
        return new PresetEntryT(this.name(), this.valueType(), (() => {
            let temp = (0,_fx_control_value__WEBPACK_IMPORTED_MODULE_1__.unionToControlValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.valueType = this.valueType();
        _o.value = (() => {
            let temp = (0,_fx_control_value__WEBPACK_IMPORTED_MODULE_1__.unionToControlValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
class PresetEntryT {
    constructor(name = null, valueType = _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE, value = null) {
        this.name = name;
        this.valueType = valueType;
        this.value = value;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const value = builder.createObjectOffset(this.value);
        return PresetEntry.createPresetEntry(builder, name, this.valueType, value);
    }
}


/***/ }),

/***/ "BmuJ":
/*!***********************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/preset.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Preset": () => (/* binding */ Preset),
/* harmony export */   "PresetT": () => (/* binding */ PresetT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_preset_entry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/preset-entry */ "zGvL");
// automatically generated by the FlatBuffers compiler, do not modify


class Preset {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPreset(bb, obj) {
        return (obj || new Preset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPreset(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new Preset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    desc(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    data(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _fx_preset_entry__WEBPACK_IMPORTED_MODULE_1__.PresetEntry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startPreset(builder) {
        builder.startObject(3);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addDesc(builder, descOffset) {
        builder.addFieldOffset(1, descOffset, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(2, dataOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endPreset(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createPreset(builder, nameOffset, descOffset, dataOffset) {
        Preset.startPreset(builder);
        Preset.addName(builder, nameOffset);
        Preset.addDesc(builder, descOffset);
        Preset.addData(builder, dataOffset);
        return Preset.endPreset(builder);
    }
    unpack() {
        return new PresetT(this.name(), this.desc(), this.bb.createObjList(this.data.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.desc = this.desc();
        _o.data = this.bb.createObjList(this.data.bind(this), this.dataLength());
    }
}
class PresetT {
    constructor(name = null, desc = null, data = []) {
        this.name = name;
        this.desc = desc;
        this.data = data;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const desc = (this.desc !== null ? builder.createString(this.desc) : 0);
        const data = Preset.createDataVector(builder, builder.createObjectOffsetList(this.data));
        return Preset.createPreset(builder, name, desc, data);
    }
}


/***/ }),

/***/ "meSg":
/*!*******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/property-value.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyValue": () => (/* binding */ PropertyValue),
/* harmony export */   "unionListToPropertyValue": () => (/* binding */ unionListToPropertyValue),
/* harmony export */   "unionToPropertyValue": () => (/* binding */ unionToPropertyValue)
/* harmony export */ });
/* harmony import */ var _fx_float_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/float-value */ "5CMk");
/* harmony import */ var _fx_int_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/int-value */ "IJKq");
/* harmony import */ var _fx_string_value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/string-value */ "1Bqd");
/* harmony import */ var _fx_uint_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fx/uint-value */ "1Yqr");
// automatically generated by the FlatBuffers compiler, do not modify




var PropertyValue;
(function (PropertyValue) {
    PropertyValue[PropertyValue["NONE"] = 0] = "NONE";
    PropertyValue[PropertyValue["UintValue"] = 1] = "UintValue";
    PropertyValue[PropertyValue["IntValue"] = 2] = "IntValue";
    PropertyValue[PropertyValue["FloatValue"] = 3] = "FloatValue";
    PropertyValue[PropertyValue["StringValue"] = 4] = "StringValue";
})(PropertyValue || (PropertyValue = {}));
function unionToPropertyValue(type, accessor) {
    switch (PropertyValue[type]) {
        case 'NONE': return null;
        case 'UintValue': return accessor(new _fx_uint_value__WEBPACK_IMPORTED_MODULE_3__.UintValue());
        case 'IntValue': return accessor(new _fx_int_value__WEBPACK_IMPORTED_MODULE_1__.IntValue());
        case 'FloatValue': return accessor(new _fx_float_value__WEBPACK_IMPORTED_MODULE_0__.FloatValue());
        case 'StringValue': return accessor(new _fx_string_value__WEBPACK_IMPORTED_MODULE_2__.StringValue());
        default: return null;
    }
}
function unionListToPropertyValue(type, accessor, index) {
    switch (PropertyValue[type]) {
        case 'NONE': return null;
        case 'UintValue': return accessor(index, new _fx_uint_value__WEBPACK_IMPORTED_MODULE_3__.UintValue());
        case 'IntValue': return accessor(index, new _fx_int_value__WEBPACK_IMPORTED_MODULE_1__.IntValue());
        case 'FloatValue': return accessor(index, new _fx_float_value__WEBPACK_IMPORTED_MODULE_0__.FloatValue());
        case 'StringValue': return accessor(index, new _fx_string_value__WEBPACK_IMPORTED_MODULE_2__.StringValue());
        default: return null;
    }
}


/***/ }),

/***/ "2KDM":
/*!*****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/render-state.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderState": () => (/* binding */ RenderState),
/* harmony export */   "RenderStateT": () => (/* binding */ RenderStateT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class RenderState {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRenderState(bb, obj) {
        return (obj || new RenderState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRenderState(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RenderState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startRenderState(builder) {
        builder.startObject(2);
    }
    static addType(builder, type) {
        builder.addFieldInt32(0, type, 0);
    }
    static addValue(builder, value) {
        builder.addFieldInt32(1, value, 0);
    }
    static endRenderState(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRenderState(builder, type, value) {
        RenderState.startRenderState(builder);
        RenderState.addType(builder, type);
        RenderState.addValue(builder, value);
        return RenderState.endRenderState(builder);
    }
    unpack() {
        return new RenderStateT(this.type(), this.value());
    }
    unpackTo(_o) {
        _o.type = this.type();
        _o.value = this.value();
    }
}
class RenderStateT {
    constructor(type = 0, value = 0) {
        this.type = type;
        this.value = value;
    }
    pack(builder) {
        return RenderState.createRenderState(builder, this.type, this.value);
    }
}


/***/ }),

/***/ "+VBS":
/*!*******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-bundle.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineBundle": () => (/* binding */ RoutineBundle),
/* harmony export */   "unionListToRoutineBundle": () => (/* binding */ unionListToRoutineBundle),
/* harmony export */   "unionToRoutineBundle": () => (/* binding */ unionToRoutineBundle)
/* harmony export */ });
/* harmony import */ var _fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/routine-bytecode-bundle */ "WhBg");
/* harmony import */ var _fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/routine-shader-bundle */ "DrVX");
// automatically generated by the FlatBuffers compiler, do not modify


var RoutineBundle;
(function (RoutineBundle) {
    RoutineBundle[RoutineBundle["NONE"] = 0] = "NONE";
    RoutineBundle[RoutineBundle["RoutineBytecodeBundle"] = 1] = "RoutineBytecodeBundle";
    RoutineBundle[RoutineBundle["RoutineShaderBundle"] = 2] = "RoutineShaderBundle";
})(RoutineBundle || (RoutineBundle = {}));
function unionToRoutineBundle(type, accessor) {
    switch (RoutineBundle[type]) {
        case 'NONE': return null;
        case 'RoutineBytecodeBundle': return accessor(new _fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_0__.RoutineBytecodeBundle());
        case 'RoutineShaderBundle': return accessor(new _fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineShaderBundle());
        default: return null;
    }
}
function unionListToRoutineBundle(type, accessor, index) {
    switch (RoutineBundle[type]) {
        case 'NONE': return null;
        case 'RoutineBytecodeBundle': return accessor(index, new _fx_routine_bytecode_bundle__WEBPACK_IMPORTED_MODULE_0__.RoutineBytecodeBundle());
        case 'RoutineShaderBundle': return accessor(index, new _fx_routine_shader_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineShaderBundle());
        default: return null;
    }
}


/***/ }),

/***/ "ZbwE":
/*!**************************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-bytecode-bundle-resources.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineBytecodeBundleResources": () => (/* binding */ RoutineBytecodeBundleResources),
/* harmony export */   "RoutineBytecodeBundleResourcesT": () => (/* binding */ RoutineBytecodeBundleResourcesT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_buffer_bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/buffer-bundle */ "IMqc");
/* harmony import */ var _fx_texture_bundle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/texture-bundle */ "dunc");
/* harmony import */ var _fx_trimesh_bundle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fx/trimesh-bundle */ "Rum1");
/* harmony import */ var _fx_uavbundle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fx/uavbundle */ "r1qu");
// automatically generated by the FlatBuffers compiler, do not modify





class RoutineBytecodeBundleResources {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRoutineBytecodeBundleResources(bb, obj) {
        return (obj || new RoutineBytecodeBundleResources()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRoutineBytecodeBundleResources(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RoutineBytecodeBundleResources()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    uavs(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new _fx_uavbundle__WEBPACK_IMPORTED_MODULE_4__.UAVBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    uavsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new _fx_buffer_bundle__WEBPACK_IMPORTED_MODULE_1__.BufferBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    textures(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _fx_texture_bundle__WEBPACK_IMPORTED_MODULE_2__.TextureBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    texturesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    trimeshes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _fx_trimesh_bundle__WEBPACK_IMPORTED_MODULE_3__.TrimeshBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    trimeshesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRoutineBytecodeBundleResources(builder) {
        builder.startObject(4);
    }
    static addUavs(builder, uavsOffset) {
        builder.addFieldOffset(0, uavsOffset, 0);
    }
    static createUavsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startUavsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(1, buffersOffset, 0);
    }
    static createBuffersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBuffersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTextures(builder, texturesOffset) {
        builder.addFieldOffset(2, texturesOffset, 0);
    }
    static createTexturesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTexturesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTrimeshes(builder, trimeshesOffset) {
        builder.addFieldOffset(3, trimeshesOffset, 0);
    }
    static createTrimeshesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTrimeshesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRoutineBytecodeBundleResources(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRoutineBytecodeBundleResources(builder, uavsOffset, buffersOffset, texturesOffset, trimeshesOffset) {
        RoutineBytecodeBundleResources.startRoutineBytecodeBundleResources(builder);
        RoutineBytecodeBundleResources.addUavs(builder, uavsOffset);
        RoutineBytecodeBundleResources.addBuffers(builder, buffersOffset);
        RoutineBytecodeBundleResources.addTextures(builder, texturesOffset);
        RoutineBytecodeBundleResources.addTrimeshes(builder, trimeshesOffset);
        return RoutineBytecodeBundleResources.endRoutineBytecodeBundleResources(builder);
    }
    unpack() {
        return new RoutineBytecodeBundleResourcesT(this.bb.createObjList(this.uavs.bind(this), this.uavsLength()), this.bb.createObjList(this.buffers.bind(this), this.buffersLength()), this.bb.createObjList(this.textures.bind(this), this.texturesLength()), this.bb.createObjList(this.trimeshes.bind(this), this.trimeshesLength()));
    }
    unpackTo(_o) {
        _o.uavs = this.bb.createObjList(this.uavs.bind(this), this.uavsLength());
        _o.buffers = this.bb.createObjList(this.buffers.bind(this), this.buffersLength());
        _o.textures = this.bb.createObjList(this.textures.bind(this), this.texturesLength());
        _o.trimeshes = this.bb.createObjList(this.trimeshes.bind(this), this.trimeshesLength());
    }
}
class RoutineBytecodeBundleResourcesT {
    constructor(uavs = [], buffers = [], textures = [], trimeshes = []) {
        this.uavs = uavs;
        this.buffers = buffers;
        this.textures = textures;
        this.trimeshes = trimeshes;
    }
    pack(builder) {
        const uavs = RoutineBytecodeBundleResources.createUavsVector(builder, builder.createObjectOffsetList(this.uavs));
        const buffers = RoutineBytecodeBundleResources.createBuffersVector(builder, builder.createObjectOffsetList(this.buffers));
        const textures = RoutineBytecodeBundleResources.createTexturesVector(builder, builder.createObjectOffsetList(this.textures));
        const trimeshes = RoutineBytecodeBundleResources.createTrimeshesVector(builder, builder.createObjectOffsetList(this.trimeshes));
        return RoutineBytecodeBundleResources.createRoutineBytecodeBundleResources(builder, uavs, buffers, textures, trimeshes);
    }
}


/***/ }),

/***/ "WhBg":
/*!****************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-bytecode-bundle.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineBytecodeBundle": () => (/* binding */ RoutineBytecodeBundle),
/* harmony export */   "RoutineBytecodeBundleT": () => (/* binding */ RoutineBytecodeBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_routine_bytecode_bundle_resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/routine-bytecode-bundle-resources */ "ZbwE");
// automatically generated by the FlatBuffers compiler, do not modify


class RoutineBytecodeBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRoutineBytecodeBundle(bb, obj) {
        return (obj || new RoutineBytecodeBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRoutineBytecodeBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RoutineBytecodeBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    codeLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    codeArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    resources(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new _fx_routine_bytecode_bundle_resources__WEBPACK_IMPORTED_MODULE_1__.RoutineBytecodeBundleResources()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    numthreads(index) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    numthreadsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    numthreadsArray() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startRoutineBytecodeBundle(builder) {
        builder.startObject(3);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static createCodeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startCodeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addResources(builder, resourcesOffset) {
        builder.addFieldOffset(1, resourcesOffset, 0);
    }
    static addNumthreads(builder, numthreadsOffset) {
        builder.addFieldOffset(2, numthreadsOffset, 0);
    }
    static createNumthreadsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startNumthreadsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRoutineBytecodeBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new RoutineBytecodeBundleT(this.bb.createScalarList(this.code.bind(this), this.codeLength()), (this.resources() !== null ? this.resources().unpack() : null), this.bb.createScalarList(this.numthreads.bind(this), this.numthreadsLength()));
    }
    unpackTo(_o) {
        _o.code = this.bb.createScalarList(this.code.bind(this), this.codeLength());
        _o.resources = (this.resources() !== null ? this.resources().unpack() : null);
        _o.numthreads = this.bb.createScalarList(this.numthreads.bind(this), this.numthreadsLength());
    }
}
class RoutineBytecodeBundleT {
    constructor(code = [], resources = null, numthreads = []) {
        this.code = code;
        this.resources = resources;
        this.numthreads = numthreads;
    }
    pack(builder) {
        const code = RoutineBytecodeBundle.createCodeVector(builder, this.code);
        const resources = (this.resources !== null ? this.resources.pack(builder) : 0);
        const numthreads = RoutineBytecodeBundle.createNumthreadsVector(builder, this.numthreads);
        RoutineBytecodeBundle.startRoutineBytecodeBundle(builder);
        RoutineBytecodeBundle.addCode(builder, code);
        RoutineBytecodeBundle.addResources(builder, resources);
        RoutineBytecodeBundle.addNumthreads(builder, numthreads);
        return RoutineBytecodeBundle.endRoutineBytecodeBundle(builder);
    }
}


/***/ }),

/***/ "pOt9":
/*!******************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-glslsource-bundle.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineGLSLSourceBundle": () => (/* binding */ RoutineGLSLSourceBundle),
/* harmony export */   "RoutineGLSLSourceBundleT": () => (/* binding */ RoutineGLSLSourceBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _cbbundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cbbundle */ "4mVy");
/* harmony import */ var _fx_glslattribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/glslattribute */ "gp8H");
// automatically generated by the FlatBuffers compiler, do not modify



class RoutineGLSLSourceBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRoutineGLSLSourceBundle(bb, obj) {
        return (obj || new RoutineGLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRoutineGLSLSourceBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RoutineGLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    attributes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new _fx_glslattribute__WEBPACK_IMPORTED_MODULE_2__.GLSLAttribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    attributesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    cbuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _cbbundle__WEBPACK_IMPORTED_MODULE_1__.CBBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    cbuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRoutineGLSLSourceBundle(builder) {
        builder.startObject(3);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static addAttributes(builder, attributesOffset) {
        builder.addFieldOffset(1, attributesOffset, 0);
    }
    static createAttributesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startAttributesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCbuffers(builder, cbuffersOffset) {
        builder.addFieldOffset(2, cbuffersOffset, 0);
    }
    static createCbuffersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCbuffersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRoutineGLSLSourceBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRoutineGLSLSourceBundle(builder, codeOffset, attributesOffset, cbuffersOffset) {
        RoutineGLSLSourceBundle.startRoutineGLSLSourceBundle(builder);
        RoutineGLSLSourceBundle.addCode(builder, codeOffset);
        RoutineGLSLSourceBundle.addAttributes(builder, attributesOffset);
        RoutineGLSLSourceBundle.addCbuffers(builder, cbuffersOffset);
        return RoutineGLSLSourceBundle.endRoutineGLSLSourceBundle(builder);
    }
    unpack() {
        return new RoutineGLSLSourceBundleT(this.code(), this.bb.createObjList(this.attributes.bind(this), this.attributesLength()), this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength()));
    }
    unpackTo(_o) {
        _o.code = this.code();
        _o.attributes = this.bb.createObjList(this.attributes.bind(this), this.attributesLength());
        _o.cbuffers = this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength());
    }
}
class RoutineGLSLSourceBundleT {
    constructor(code = null, attributes = [], cbuffers = []) {
        this.code = code;
        this.attributes = attributes;
        this.cbuffers = cbuffers;
    }
    pack(builder) {
        const code = (this.code !== null ? builder.createString(this.code) : 0);
        const attributes = RoutineGLSLSourceBundle.createAttributesVector(builder, builder.createObjectOffsetList(this.attributes));
        const cbuffers = RoutineGLSLSourceBundle.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));
        return RoutineGLSLSourceBundle.createRoutineGLSLSourceBundle(builder, code, attributes, cbuffers);
    }
}


/***/ }),

/***/ "Jpkv":
/*!******************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-hlslsource-bundle.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineHLSLSourceBundle": () => (/* binding */ RoutineHLSLSourceBundle),
/* harmony export */   "RoutineHLSLSourceBundleT": () => (/* binding */ RoutineHLSLSourceBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _cbbundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cbbundle */ "4mVy");
// automatically generated by the FlatBuffers compiler, do not modify


class RoutineHLSLSourceBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRoutineHLSLSourceBundle(bb, obj) {
        return (obj || new RoutineHLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRoutineHLSLSourceBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RoutineHLSLSourceBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    entryName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    cbuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _cbbundle__WEBPACK_IMPORTED_MODULE_1__.CBBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    cbuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRoutineHLSLSourceBundle(builder) {
        builder.startObject(3);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static addEntryName(builder, entryNameOffset) {
        builder.addFieldOffset(1, entryNameOffset, 0);
    }
    static addCbuffers(builder, cbuffersOffset) {
        builder.addFieldOffset(2, cbuffersOffset, 0);
    }
    static createCbuffersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCbuffersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRoutineHLSLSourceBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRoutineHLSLSourceBundle(builder, codeOffset, entryNameOffset, cbuffersOffset) {
        RoutineHLSLSourceBundle.startRoutineHLSLSourceBundle(builder);
        RoutineHLSLSourceBundle.addCode(builder, codeOffset);
        RoutineHLSLSourceBundle.addEntryName(builder, entryNameOffset);
        RoutineHLSLSourceBundle.addCbuffers(builder, cbuffersOffset);
        return RoutineHLSLSourceBundle.endRoutineHLSLSourceBundle(builder);
    }
    unpack() {
        return new RoutineHLSLSourceBundleT(this.code(), this.entryName(), this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength()));
    }
    unpackTo(_o) {
        _o.code = this.code();
        _o.entryName = this.entryName();
        _o.cbuffers = this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength());
    }
}
class RoutineHLSLSourceBundleT {
    constructor(code = null, entryName = null, cbuffers = []) {
        this.code = code;
        this.entryName = entryName;
        this.cbuffers = cbuffers;
    }
    pack(builder) {
        const code = (this.code !== null ? builder.createString(this.code) : 0);
        const entryName = (this.entryName !== null ? builder.createString(this.entryName) : 0);
        const cbuffers = RoutineHLSLSourceBundle.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));
        return RoutineHLSLSourceBundle.createRoutineHLSLSourceBundle(builder, code, entryName, cbuffers);
    }
}


/***/ }),

/***/ "DrVX":
/*!**************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-shader-bundle.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineShaderBundle": () => (/* binding */ RoutineShaderBundle),
/* harmony export */   "RoutineShaderBundleT": () => (/* binding */ RoutineShaderBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/routine-source-bundle */ "KEtj");
// automatically generated by the FlatBuffers compiler, do not modify


class RoutineShaderBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRoutineShaderBundle(bb, obj) {
        return (obj || new RoutineShaderBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRoutineShaderBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new RoutineShaderBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    shadersType(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    shadersTypeLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    shadersTypeArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    shaders(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    shadersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startRoutineShaderBundle(builder) {
        builder.startObject(2);
    }
    static addShadersType(builder, shadersTypeOffset) {
        builder.addFieldOffset(0, shadersTypeOffset, 0);
    }
    static createShadersTypeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startShadersTypeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addShaders(builder, shadersOffset) {
        builder.addFieldOffset(1, shadersOffset, 0);
    }
    static createShadersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShadersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endRoutineShaderBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRoutineShaderBundle(builder, shadersTypeOffset, shadersOffset) {
        RoutineShaderBundle.startRoutineShaderBundle(builder);
        RoutineShaderBundle.addShadersType(builder, shadersTypeOffset);
        RoutineShaderBundle.addShaders(builder, shadersOffset);
        return RoutineShaderBundle.endRoutineShaderBundle(builder);
    }
    unpack() {
        return new RoutineShaderBundleT(this.bb.createScalarList(this.shadersType.bind(this), this.shadersTypeLength()), (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.shadersType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineSourceBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_1__.unionListToRoutineSourceBundle)(targetEnum, this.shaders.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })());
    }
    unpackTo(_o) {
        _o.shadersType = this.bb.createScalarList(this.shadersType.bind(this), this.shadersTypeLength());
        _o.shaders = (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.shadersType(targetEnumIndex);
                if (targetEnum === null || _fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineSourceBundle[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_routine_source_bundle__WEBPACK_IMPORTED_MODULE_1__.unionListToRoutineSourceBundle)(targetEnum, this.shaders.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
    }
}
class RoutineShaderBundleT {
    constructor(shadersType = [], shaders = []) {
        this.shadersType = shadersType;
        this.shaders = shaders;
    }
    pack(builder) {
        const shadersType = RoutineShaderBundle.createShadersTypeVector(builder, this.shadersType);
        const shaders = RoutineShaderBundle.createShadersVector(builder, builder.createObjectOffsetList(this.shaders));
        return RoutineShaderBundle.createRoutineShaderBundle(builder, shadersType, shaders);
    }
}


/***/ }),

/***/ "KEtj":
/*!**************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/routine-source-bundle.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutineSourceBundle": () => (/* binding */ RoutineSourceBundle),
/* harmony export */   "unionListToRoutineSourceBundle": () => (/* binding */ unionListToRoutineSourceBundle),
/* harmony export */   "unionToRoutineSourceBundle": () => (/* binding */ unionToRoutineSourceBundle)
/* harmony export */ });
/* harmony import */ var _fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/routine-glslsource-bundle */ "pOt9");
/* harmony import */ var _fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/routine-hlslsource-bundle */ "Jpkv");
// automatically generated by the FlatBuffers compiler, do not modify


var RoutineSourceBundle;
(function (RoutineSourceBundle) {
    RoutineSourceBundle[RoutineSourceBundle["NONE"] = 0] = "NONE";
    RoutineSourceBundle[RoutineSourceBundle["RoutineGLSLSourceBundle"] = 1] = "RoutineGLSLSourceBundle";
    RoutineSourceBundle[RoutineSourceBundle["RoutineHLSLSourceBundle"] = 2] = "RoutineHLSLSourceBundle";
})(RoutineSourceBundle || (RoutineSourceBundle = {}));
function unionToRoutineSourceBundle(type, accessor) {
    switch (RoutineSourceBundle[type]) {
        case 'NONE': return null;
        case 'RoutineGLSLSourceBundle': return accessor(new _fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_0__.RoutineGLSLSourceBundle());
        case 'RoutineHLSLSourceBundle': return accessor(new _fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineHLSLSourceBundle());
        default: return null;
    }
}
function unionListToRoutineSourceBundle(type, accessor, index) {
    switch (RoutineSourceBundle[type]) {
        case 'NONE': return null;
        case 'RoutineGLSLSourceBundle': return accessor(index, new _fx_routine_glslsource_bundle__WEBPACK_IMPORTED_MODULE_0__.RoutineGLSLSourceBundle());
        case 'RoutineHLSLSourceBundle': return accessor(index, new _fx_routine_hlslsource_bundle__WEBPACK_IMPORTED_MODULE_1__.RoutineHLSLSourceBundle());
        default: return null;
    }
}


/***/ }),

/***/ "X2z1":
/*!***********************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/shader.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shader": () => (/* binding */ Shader),
/* harmony export */   "unionListToShader": () => (/* binding */ unionListToShader),
/* harmony export */   "unionToShader": () => (/* binding */ unionToShader)
/* harmony export */ });
/* harmony import */ var _fx_pixel_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fx/pixel-shader */ "23YT");
/* harmony import */ var _fx_vertex_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/vertex-shader */ "Gw1M");
// automatically generated by the FlatBuffers compiler, do not modify


var Shader;
(function (Shader) {
    Shader[Shader["NONE"] = 0] = "NONE";
    Shader[Shader["VertexShader"] = 1] = "VertexShader";
    Shader[Shader["PixelShader"] = 2] = "PixelShader";
})(Shader || (Shader = {}));
function unionToShader(type, accessor) {
    switch (Shader[type]) {
        case 'NONE': return null;
        case 'VertexShader': return accessor(new _fx_vertex_shader__WEBPACK_IMPORTED_MODULE_1__.VertexShader());
        case 'PixelShader': return accessor(new _fx_pixel_shader__WEBPACK_IMPORTED_MODULE_0__.PixelShader());
        default: return null;
    }
}
function unionListToShader(type, accessor, index) {
    switch (Shader[type]) {
        case 'NONE': return null;
        case 'VertexShader': return accessor(index, new _fx_vertex_shader__WEBPACK_IMPORTED_MODULE_1__.VertexShader());
        case 'PixelShader': return accessor(index, new _fx_pixel_shader__WEBPACK_IMPORTED_MODULE_0__.PixelShader());
        default: return null;
    }
}


/***/ }),

/***/ "1Bqd":
/*!*****************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/string-value.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringValue": () => (/* binding */ StringValue),
/* harmony export */   "StringValueT": () => (/* binding */ StringValueT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class StringValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStringValue(bb, obj) {
        return (obj || new StringValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStringValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new StringValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startStringValue(builder) {
        builder.startObject(1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(0, valueOffset, 0);
    }
    static endStringValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createStringValue(builder, valueOffset) {
        StringValue.startStringValue(builder);
        StringValue.addValue(builder, valueOffset);
        return StringValue.endStringValue(builder);
    }
    unpack() {
        return new StringValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class StringValueT {
    constructor(value = null) {
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return StringValue.createStringValue(builder, value);
    }
}


/***/ }),

/***/ "mGiJ":
/*!**********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/technique11bundle.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Technique11Bundle": () => (/* binding */ Technique11Bundle),
/* harmony export */   "Technique11BundleT": () => (/* binding */ Technique11BundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_technique11render_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/technique11render-pass */ "s7GX");
// automatically generated by the FlatBuffers compiler, do not modify


class Technique11Bundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTechnique11Bundle(bb, obj) {
        return (obj || new Technique11Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTechnique11Bundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new Technique11Bundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    passes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new _fx_technique11render_pass__WEBPACK_IMPORTED_MODULE_1__.Technique11RenderPass()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    passesLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startTechnique11Bundle(builder) {
        builder.startObject(1);
    }
    static addPasses(builder, passesOffset) {
        builder.addFieldOffset(0, passesOffset, 0);
    }
    static createPassesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startPassesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endTechnique11Bundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTechnique11Bundle(builder, passesOffset) {
        Technique11Bundle.startTechnique11Bundle(builder);
        Technique11Bundle.addPasses(builder, passesOffset);
        return Technique11Bundle.endTechnique11Bundle(builder);
    }
    unpack() {
        return new Technique11BundleT(this.bb.createObjList(this.passes.bind(this), this.passesLength()));
    }
    unpackTo(_o) {
        _o.passes = this.bb.createObjList(this.passes.bind(this), this.passesLength());
    }
}
class Technique11BundleT {
    constructor(passes = []) {
        this.passes = passes;
    }
    pack(builder) {
        const passes = Technique11Bundle.createPassesVector(builder, builder.createObjectOffsetList(this.passes));
        return Technique11Bundle.createTechnique11Bundle(builder, passes);
    }
}


/***/ }),

/***/ "s7GX":
/*!***************************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/technique11render-pass.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Technique11RenderPass": () => (/* binding */ Technique11RenderPass),
/* harmony export */   "Technique11RenderPassT": () => (/* binding */ Technique11RenderPassT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/shader */ "X2z1");
// automatically generated by the FlatBuffers compiler, do not modify


class Technique11RenderPass {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTechnique11RenderPass(bb, obj) {
        return (obj || new Technique11RenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTechnique11RenderPass(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new Technique11RenderPass()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    codeLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    codeArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    shadersType(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    shadersTypeLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    shadersTypeArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    shaders(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    shadersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startTechnique11RenderPass(builder) {
        builder.startObject(3);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static createCodeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startCodeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addShadersType(builder, shadersTypeOffset) {
        builder.addFieldOffset(1, shadersTypeOffset, 0);
    }
    static createShadersTypeVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startShadersTypeVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addShaders(builder, shadersOffset) {
        builder.addFieldOffset(2, shadersOffset, 0);
    }
    static createShadersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShadersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endTechnique11RenderPass(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTechnique11RenderPass(builder, codeOffset, shadersTypeOffset, shadersOffset) {
        Technique11RenderPass.startTechnique11RenderPass(builder);
        Technique11RenderPass.addCode(builder, codeOffset);
        Technique11RenderPass.addShadersType(builder, shadersTypeOffset);
        Technique11RenderPass.addShaders(builder, shadersOffset);
        return Technique11RenderPass.endTechnique11RenderPass(builder);
    }
    unpack() {
        return new Technique11RenderPassT(this.bb.createScalarList(this.code.bind(this), this.codeLength()), this.bb.createScalarList(this.shadersType.bind(this), this.shadersTypeLength()), (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.shadersType(targetEnumIndex);
                if (targetEnum === null || _fx_shader__WEBPACK_IMPORTED_MODULE_1__.Shader[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_shader__WEBPACK_IMPORTED_MODULE_1__.unionListToShader)(targetEnum, this.shaders.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })());
    }
    unpackTo(_o) {
        _o.code = this.bb.createScalarList(this.code.bind(this), this.codeLength());
        _o.shadersType = this.bb.createScalarList(this.shadersType.bind(this), this.shadersTypeLength());
        _o.shaders = (() => {
            let ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.shadersTypeLength(); ++targetEnumIndex) {
                let targetEnum = this.shadersType(targetEnumIndex);
                if (targetEnum === null || _fx_shader__WEBPACK_IMPORTED_MODULE_1__.Shader[targetEnum] === 'NONE') {
                    continue;
                }
                let temp = (0,_fx_shader__WEBPACK_IMPORTED_MODULE_1__.unionListToShader)(targetEnum, this.shaders.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
    }
}
class Technique11RenderPassT {
    constructor(code = [], shadersType = [], shaders = []) {
        this.code = code;
        this.shadersType = shadersType;
        this.shaders = shaders;
    }
    pack(builder) {
        const code = Technique11RenderPass.createCodeVector(builder, this.code);
        const shadersType = Technique11RenderPass.createShadersTypeVector(builder, this.shadersType);
        const shaders = Technique11RenderPass.createShadersVector(builder, builder.createObjectOffsetList(this.shaders));
        return Technique11RenderPass.createTechnique11RenderPass(builder, code, shadersType, shaders);
    }
}


/***/ }),

/***/ "dunc":
/*!*******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/texture-bundle.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureBundle": () => (/* binding */ TextureBundle),
/* harmony export */   "TextureBundleT": () => (/* binding */ TextureBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify


class TextureBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTextureBundle(bb, obj) {
        return (obj || new TextureBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTextureBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new TextureBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    slot() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    stride() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_1__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startTextureBundle(builder) {
        builder.startObject(4);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addSlot(builder, slot) {
        builder.addFieldInt32(1, slot, 0);
    }
    static addStride(builder, stride) {
        builder.addFieldInt32(2, stride, 0);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static endTextureBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new TextureBundleT(this.name(), this.slot(), this.stride(), (this.type() !== null ? this.type().unpack() : null));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.slot = this.slot();
        _o.stride = this.stride();
        _o.type = (this.type() !== null ? this.type().unpack() : null);
    }
}
class TextureBundleT {
    constructor(name = null, slot = 0, stride = 0, type = null) {
        this.name = name;
        this.slot = slot;
        this.stride = stride;
        this.type = type;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const type = (this.type !== null ? this.type.pack(builder) : 0);
        TextureBundle.startTextureBundle(builder);
        TextureBundle.addName(builder, name);
        TextureBundle.addSlot(builder, this.slot);
        TextureBundle.addStride(builder, this.stride);
        TextureBundle.addType(builder, type);
        return TextureBundle.endTextureBundle(builder);
    }
}


/***/ }),

/***/ "J5jW":
/*!******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/texture-value.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureValue": () => (/* binding */ TextureValue),
/* harmony export */   "TextureValueT": () => (/* binding */ TextureValueT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class TextureValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTextureValue(bb, obj) {
        return (obj || new TextureValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTextureValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new TextureValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTextureValue(builder) {
        builder.startObject(1);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(0, valueOffset, 0);
    }
    static endTextureValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTextureValue(builder, valueOffset) {
        TextureValue.startTextureValue(builder);
        TextureValue.addValue(builder, valueOffset);
        return TextureValue.endTextureValue(builder);
    }
    unpack() {
        return new TextureValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class TextureValueT {
    constructor(value = null) {
        this.value = value;
    }
    pack(builder) {
        const value = (this.value !== null ? builder.createString(this.value) : 0);
        return TextureValue.createTextureValue(builder, value);
    }
}


/***/ }),

/***/ "Rum1":
/*!*******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/trimesh-bundle.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrimeshBundle": () => (/* binding */ TrimeshBundle),
/* harmony export */   "TrimeshBundleT": () => (/* binding */ TrimeshBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
// automatically generated by the FlatBuffers compiler, do not modify

class TrimeshBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTrimeshBundle(bb, obj) {
        return (obj || new TrimeshBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTrimeshBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new TrimeshBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    vertexCountUName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    faceCountUName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    verticesName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    facesName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    gsAdjecencyName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    faceAdjacencyName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTrimeshBundle(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addVertexCountUName(builder, vertexCountUNameOffset) {
        builder.addFieldOffset(1, vertexCountUNameOffset, 0);
    }
    static addFaceCountUName(builder, faceCountUNameOffset) {
        builder.addFieldOffset(2, faceCountUNameOffset, 0);
    }
    static addVerticesName(builder, verticesNameOffset) {
        builder.addFieldOffset(3, verticesNameOffset, 0);
    }
    static addFacesName(builder, facesNameOffset) {
        builder.addFieldOffset(4, facesNameOffset, 0);
    }
    static addGsAdjecencyName(builder, gsAdjecencyNameOffset) {
        builder.addFieldOffset(5, gsAdjecencyNameOffset, 0);
    }
    static addFaceAdjacencyName(builder, faceAdjacencyNameOffset) {
        builder.addFieldOffset(6, faceAdjacencyNameOffset, 0);
    }
    static endTrimeshBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTrimeshBundle(builder, nameOffset, vertexCountUNameOffset, faceCountUNameOffset, verticesNameOffset, facesNameOffset, gsAdjecencyNameOffset, faceAdjacencyNameOffset) {
        TrimeshBundle.startTrimeshBundle(builder);
        TrimeshBundle.addName(builder, nameOffset);
        TrimeshBundle.addVertexCountUName(builder, vertexCountUNameOffset);
        TrimeshBundle.addFaceCountUName(builder, faceCountUNameOffset);
        TrimeshBundle.addVerticesName(builder, verticesNameOffset);
        TrimeshBundle.addFacesName(builder, facesNameOffset);
        TrimeshBundle.addGsAdjecencyName(builder, gsAdjecencyNameOffset);
        TrimeshBundle.addFaceAdjacencyName(builder, faceAdjacencyNameOffset);
        return TrimeshBundle.endTrimeshBundle(builder);
    }
    unpack() {
        return new TrimeshBundleT(this.name(), this.vertexCountUName(), this.faceCountUName(), this.verticesName(), this.facesName(), this.gsAdjecencyName(), this.faceAdjacencyName());
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.vertexCountUName = this.vertexCountUName();
        _o.faceCountUName = this.faceCountUName();
        _o.verticesName = this.verticesName();
        _o.facesName = this.facesName();
        _o.gsAdjecencyName = this.gsAdjecencyName();
        _o.faceAdjacencyName = this.faceAdjacencyName();
    }
}
class TrimeshBundleT {
    constructor(name = null, vertexCountUName = null, faceCountUName = null, verticesName = null, facesName = null, gsAdjecencyName = null, faceAdjacencyName = null) {
        this.name = name;
        this.vertexCountUName = vertexCountUName;
        this.faceCountUName = faceCountUName;
        this.verticesName = verticesName;
        this.facesName = facesName;
        this.gsAdjecencyName = gsAdjecencyName;
        this.faceAdjacencyName = faceAdjacencyName;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const vertexCountUName = (this.vertexCountUName !== null ? builder.createString(this.vertexCountUName) : 0);
        const faceCountUName = (this.faceCountUName !== null ? builder.createString(this.faceCountUName) : 0);
        const verticesName = (this.verticesName !== null ? builder.createString(this.verticesName) : 0);
        const facesName = (this.facesName !== null ? builder.createString(this.facesName) : 0);
        const gsAdjecencyName = (this.gsAdjecencyName !== null ? builder.createString(this.gsAdjecencyName) : 0);
        const faceAdjacencyName = (this.faceAdjacencyName !== null ? builder.createString(this.faceAdjacencyName) : 0);
        return TrimeshBundle.createTrimeshBundle(builder, name, vertexCountUName, faceCountUName, verticesName, facesName, gsAdjecencyName, faceAdjacencyName);
    }
}


/***/ }),

/***/ "r1qu":
/*!**************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/uavbundle.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UAVBundle": () => (/* binding */ UAVBundle),
/* harmony export */   "UAVBundleT": () => (/* binding */ UAVBundleT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify


class UAVBundle {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUAVBundle(bb, obj) {
        return (obj || new UAVBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUAVBundle(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new UAVBundle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    slot() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    stride() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_1__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startUAVBundle(builder) {
        builder.startObject(4);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addSlot(builder, slot) {
        builder.addFieldInt32(1, slot, 0);
    }
    static addStride(builder, stride) {
        builder.addFieldInt32(2, stride, 0);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static endUAVBundle(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new UAVBundleT(this.name(), this.slot(), this.stride(), (this.type() !== null ? this.type().unpack() : null));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.slot = this.slot();
        _o.stride = this.stride();
        _o.type = (this.type() !== null ? this.type().unpack() : null);
    }
}
class UAVBundleT {
    constructor(name = null, slot = 0, stride = 0, type = null) {
        this.name = name;
        this.slot = slot;
        this.stride = stride;
        this.type = type;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const type = (this.type !== null ? this.type.pack(builder) : 0);
        UAVBundle.startUAVBundle(builder);
        UAVBundle.addName(builder, name);
        UAVBundle.addSlot(builder, this.slot);
        UAVBundle.addStride(builder, this.stride);
        UAVBundle.addType(builder, type);
        return UAVBundle.endUAVBundle(builder);
    }
}


/***/ }),

/***/ "E1+w":
/*!**************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/uicontrol.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIControl": () => (/* binding */ UIControl),
/* harmony export */   "UIControlT": () => (/* binding */ UIControlT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_control_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/control-value */ "Nk0z");
/* harmony import */ var _fx_view_type_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fx/view-type-property */ "TRYF");
// automatically generated by the FlatBuffers compiler, do not modify



class UIControl {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUIControl(bb, obj) {
        return (obj || new UIControl()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUIControl(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new UIControl()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    valueType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE;
    }
    value(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    properties(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _fx_view_type_property__WEBPACK_IMPORTED_MODULE_2__.ViewTypeProperty()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    propertiesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startUIControl(builder) {
        builder.startObject(4);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addValueType(builder, valueType) {
        builder.addFieldInt8(1, valueType, _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(2, valueOffset, 0);
    }
    static addProperties(builder, propertiesOffset) {
        builder.addFieldOffset(3, propertiesOffset, 0);
    }
    static createPropertiesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startPropertiesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endUIControl(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUIControl(builder, nameOffset, valueType, valueOffset, propertiesOffset) {
        UIControl.startUIControl(builder);
        UIControl.addName(builder, nameOffset);
        UIControl.addValueType(builder, valueType);
        UIControl.addValue(builder, valueOffset);
        UIControl.addProperties(builder, propertiesOffset);
        return UIControl.endUIControl(builder);
    }
    unpack() {
        return new UIControlT(this.name(), this.valueType(), (() => {
            let temp = (0,_fx_control_value__WEBPACK_IMPORTED_MODULE_1__.unionToControlValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.bb.createObjList(this.properties.bind(this), this.propertiesLength()));
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.valueType = this.valueType();
        _o.value = (() => {
            let temp = (0,_fx_control_value__WEBPACK_IMPORTED_MODULE_1__.unionToControlValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.properties = this.bb.createObjList(this.properties.bind(this), this.propertiesLength());
    }
}
class UIControlT {
    constructor(name = null, valueType = _fx_control_value__WEBPACK_IMPORTED_MODULE_1__.ControlValue.NONE, value = null, properties = []) {
        this.name = name;
        this.valueType = valueType;
        this.value = value;
        this.properties = properties;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const value = builder.createObjectOffset(this.value);
        const properties = UIControl.createPropertiesVector(builder, builder.createObjectOffsetList(this.properties));
        return UIControl.createUIControl(builder, name, this.valueType, value, properties);
    }
}


/***/ }),

/***/ "1Yqr":
/*!***************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/uint-value.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UintValue": () => (/* binding */ UintValue),
/* harmony export */   "UintValueT": () => (/* binding */ UintValueT)
/* harmony export */ });
// automatically generated by the FlatBuffers compiler, do not modify
class UintValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    value() {
        return this.bb.readUint32(this.bb_pos);
    }
    static sizeOf() {
        return 4;
    }
    static createUintValue(builder, value) {
        builder.prep(4, 4);
        builder.writeInt32(value);
        return builder.offset();
    }
    unpack() {
        return new UintValueT(this.value());
    }
    unpackTo(_o) {
        _o.value = this.value();
    }
}
class UintValueT {
    constructor(value = 0) {
        this.value = value;
    }
    pack(builder) {
        return UintValue.createUintValue(builder, this.value);
    }
}


/***/ }),

/***/ "Gw1M":
/*!******************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/vertex-shader.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VertexShader": () => (/* binding */ VertexShader),
/* harmony export */   "VertexShaderT": () => (/* binding */ VertexShaderT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _cbbundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cbbundle */ "4mVy");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify



class VertexShader {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVertexShader(bb, obj) {
        return (obj || new VertexShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVertexShader(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new VertexShader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    code(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    entryName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    input(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_2__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    cbuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new _cbbundle__WEBPACK_IMPORTED_MODULE_1__.CBBundle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    cbuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startVertexShader(builder) {
        builder.startObject(4);
    }
    static addCode(builder, codeOffset) {
        builder.addFieldOffset(0, codeOffset, 0);
    }
    static addEntryName(builder, entryNameOffset) {
        builder.addFieldOffset(1, entryNameOffset, 0);
    }
    static addInput(builder, inputOffset) {
        builder.addFieldOffset(2, inputOffset, 0);
    }
    static addCbuffers(builder, cbuffersOffset) {
        builder.addFieldOffset(3, cbuffersOffset, 0);
    }
    static createCbuffersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCbuffersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endVertexShader(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new VertexShaderT(this.code(), this.entryName(), (this.input() !== null ? this.input().unpack() : null), this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength()));
    }
    unpackTo(_o) {
        _o.code = this.code();
        _o.entryName = this.entryName();
        _o.input = (this.input() !== null ? this.input().unpack() : null);
        _o.cbuffers = this.bb.createObjList(this.cbuffers.bind(this), this.cbuffersLength());
    }
}
class VertexShaderT {
    constructor(code = null, entryName = null, input = null, cbuffers = []) {
        this.code = code;
        this.entryName = entryName;
        this.input = input;
        this.cbuffers = cbuffers;
    }
    pack(builder) {
        const code = (this.code !== null ? builder.createString(this.code) : 0);
        const entryName = (this.entryName !== null ? builder.createString(this.entryName) : 0);
        const input = (this.input !== null ? this.input.pack(builder) : 0);
        const cbuffers = VertexShader.createCbuffersVector(builder, builder.createObjectOffsetList(this.cbuffers));
        VertexShader.startVertexShader(builder);
        VertexShader.addCode(builder, code);
        VertexShader.addEntryName(builder, entryName);
        VertexShader.addInput(builder, input);
        VertexShader.addCbuffers(builder, cbuffers);
        return VertexShader.endVertexShader(builder);
    }
}


/***/ }),

/***/ "TRYF":
/*!***********************************************************!*\
  !*** ./src/lib/idl/bundles/auto/fx/view-type-property.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewTypeProperty": () => (/* binding */ ViewTypeProperty),
/* harmony export */   "ViewTypePropertyT": () => (/* binding */ ViewTypePropertyT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _fx_property_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fx/property-value */ "meSg");
// automatically generated by the FlatBuffers compiler, do not modify


class ViewTypeProperty {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsViewTypeProperty(bb, obj) {
        return (obj || new ViewTypeProperty()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsViewTypeProperty(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new ViewTypeProperty()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    valueType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : _fx_property_value__WEBPACK_IMPORTED_MODULE_1__.PropertyValue.NONE;
    }
    value(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    static startViewTypeProperty(builder) {
        builder.startObject(3);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addValueType(builder, valueType) {
        builder.addFieldInt8(1, valueType, _fx_property_value__WEBPACK_IMPORTED_MODULE_1__.PropertyValue.NONE);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(2, valueOffset, 0);
    }
    static endViewTypeProperty(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createViewTypeProperty(builder, nameOffset, valueType, valueOffset) {
        ViewTypeProperty.startViewTypeProperty(builder);
        ViewTypeProperty.addName(builder, nameOffset);
        ViewTypeProperty.addValueType(builder, valueType);
        ViewTypeProperty.addValue(builder, valueOffset);
        return ViewTypeProperty.endViewTypeProperty(builder);
    }
    unpack() {
        return new ViewTypePropertyT(this.name(), this.valueType(), (() => {
            let temp = (0,_fx_property_value__WEBPACK_IMPORTED_MODULE_1__.unionToPropertyValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })());
    }
    unpackTo(_o) {
        _o.name = this.name();
        _o.valueType = this.valueType();
        _o.value = (() => {
            let temp = (0,_fx_property_value__WEBPACK_IMPORTED_MODULE_1__.unionToPropertyValue)(this.valueType(), this.value.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
    }
}
class ViewTypePropertyT {
    constructor(name = null, valueType = _fx_property_value__WEBPACK_IMPORTED_MODULE_1__.PropertyValue.NONE, value = null) {
        this.name = name;
        this.valueType = valueType;
        this.value = value;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const value = builder.createObjectOffset(this.value);
        return ViewTypeProperty.createViewTypeProperty(builder, name, this.valueType, value);
    }
}


/***/ }),

/***/ "O/5E":
/*!************************************************!*\
  !*** ./src/lib/idl/bundles/auto/type-field.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeField": () => (/* binding */ TypeField),
/* harmony export */   "TypeFieldT": () => (/* binding */ TypeFieldT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-layout */ "KUuy");
// automatically generated by the FlatBuffers compiler, do not modify


class TypeField {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTypeField(bb, obj) {
        return (obj || new TypeField()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTypeField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new TypeField()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new _type_layout__WEBPACK_IMPORTED_MODULE_1__.TypeLayout()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    semantic(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    size() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    padding() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startTypeField(builder) {
        builder.startObject(5);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(0, typeOffset, 0);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static addSemantic(builder, semanticOffset) {
        builder.addFieldOffset(2, semanticOffset, 0);
    }
    static addSize(builder, size) {
        builder.addFieldInt32(3, size, 0);
    }
    static addPadding(builder, padding) {
        builder.addFieldInt32(4, padding, 0);
    }
    static endTypeField(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTypeField(builder, typeOffset, nameOffset, semanticOffset, size, padding) {
        TypeField.startTypeField(builder);
        TypeField.addType(builder, typeOffset);
        TypeField.addName(builder, nameOffset);
        TypeField.addSemantic(builder, semanticOffset);
        TypeField.addSize(builder, size);
        TypeField.addPadding(builder, padding);
        return TypeField.endTypeField(builder);
    }
    unpack() {
        return new TypeFieldT((this.type() !== null ? this.type().unpack() : null), this.name(), this.semantic(), this.size(), this.padding());
    }
    unpackTo(_o) {
        _o.type = (this.type() !== null ? this.type().unpack() : null);
        _o.name = this.name();
        _o.semantic = this.semantic();
        _o.size = this.size();
        _o.padding = this.padding();
    }
}
class TypeFieldT {
    constructor(type = null, name = null, semantic = null, size = 0, padding = 0) {
        this.type = type;
        this.name = name;
        this.semantic = semantic;
        this.size = size;
        this.padding = padding;
    }
    pack(builder) {
        const type = (this.type !== null ? this.type.pack(builder) : 0);
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const semantic = (this.semantic !== null ? builder.createString(this.semantic) : 0);
        return TypeField.createTypeField(builder, type, name, semantic, this.size, this.padding);
    }
}


/***/ }),

/***/ "KUuy":
/*!*************************************************!*\
  !*** ./src/lib/idl/bundles/auto/type-layout.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeLayout": () => (/* binding */ TypeLayout),
/* harmony export */   "TypeLayoutT": () => (/* binding */ TypeLayoutT)
/* harmony export */ });
/* harmony import */ var flatbuffers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatbuffers */ "qm2M");
/* harmony import */ var _type_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-field */ "O/5E");
// automatically generated by the FlatBuffers compiler, do not modify


class TypeLayout {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTypeLayout(bb, obj) {
        return (obj || new TypeLayout()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTypeLayout(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH);
        return (obj || new TypeLayout()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new _type_field__WEBPACK_IMPORTED_MODULE_1__.TypeField()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    length() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    size() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startTypeLayout(builder) {
        builder.startObject(4);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(0, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addLength(builder, length) {
        builder.addFieldInt32(1, length, 0);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(2, nameOffset, 0);
    }
    static addSize(builder, size) {
        builder.addFieldInt32(3, size, 0);
    }
    static endTypeLayout(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTypeLayout(builder, fieldsOffset, length, nameOffset, size) {
        TypeLayout.startTypeLayout(builder);
        TypeLayout.addFields(builder, fieldsOffset);
        TypeLayout.addLength(builder, length);
        TypeLayout.addName(builder, nameOffset);
        TypeLayout.addSize(builder, size);
        return TypeLayout.endTypeLayout(builder);
    }
    unpack() {
        return new TypeLayoutT(this.bb.createObjList(this.fields.bind(this), this.fieldsLength()), this.length(), this.name(), this.size());
    }
    unpackTo(_o) {
        _o.fields = this.bb.createObjList(this.fields.bind(this), this.fieldsLength());
        _o.length = this.length();
        _o.name = this.name();
        _o.size = this.size();
    }
}
class TypeLayoutT {
    constructor(fields = [], length = 0, name = null, size = 0) {
        this.fields = fields;
        this.length = length;
        this.name = name;
        this.size = size;
    }
    pack(builder) {
        const fields = TypeLayout.createFieldsVector(builder, builder.createObjectOffsetList(this.fields));
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        return TypeLayout.createTypeLayout(builder, fields, this.length, name, this.size);
    }
}


/***/ }),

/***/ "/9BJ":
/*!*********************************************!*\
  !*** ./src/lib/idl/bytecode/EOperations.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EOperation": () => (/* binding */ EOperation)
/* harmony export */ });
var EOperation;
(function (EOperation) {
    // note: assuming that Load is 32bit and Move is 32bit too
    EOperation[EOperation["k_I32LoadRegister"] = 0] = "k_I32LoadRegister";
    EOperation[EOperation["k_I32LoadInput"] = 1] = "k_I32LoadInput";
    EOperation[EOperation["k_I32LoadInputPointer"] = 2] = "k_I32LoadInputPointer";
    EOperation[EOperation["k_I32LoadRegistersPointer"] = 3] = "k_I32LoadRegistersPointer";
    EOperation[EOperation["k_I32StoreRegisterPointer"] = 4] = "k_I32StoreRegisterPointer";
    EOperation[EOperation["k_I32StoreInput"] = 5] = "k_I32StoreInput";
    EOperation[EOperation["k_I32StoreInputPointer"] = 6] = "k_I32StoreInputPointer";
    EOperation[EOperation["k_I32SetConst"] = 7] = "k_I32SetConst";
    EOperation[EOperation["k_I32TextureLoad"] = 8] = "k_I32TextureLoad";
    EOperation[EOperation["k_I32ExternCall"] = 9] = "k_I32ExternCall";
    //
    // Arithemtic operations
    //
    EOperation[EOperation["k_I32Add"] = 10] = "k_I32Add";
    EOperation[EOperation["k_I32Sub"] = 11] = "k_I32Sub";
    EOperation[EOperation["k_I32Mul"] = 12] = "k_I32Mul";
    EOperation[EOperation["k_I32Div"] = 13] = "k_I32Div";
    EOperation[EOperation["k_I32Mod"] = 14] = "k_I32Mod";
    EOperation[EOperation["k_F32Add"] = 15] = "k_F32Add";
    EOperation[EOperation["k_F32Sub"] = 16] = "k_F32Sub";
    EOperation[EOperation["k_F32Mul"] = 17] = "k_F32Mul";
    EOperation[EOperation["k_F32Div"] = 18] = "k_F32Div";
    EOperation[EOperation["k_F32Mod"] = 19] = "k_F32Mod";
    //
    // Relational operations
    //
    EOperation[EOperation["k_U32LessThan"] = 20] = "k_U32LessThan";
    EOperation[EOperation["k_U32GreaterThanEqual"] = 21] = "k_U32GreaterThanEqual";
    EOperation[EOperation["k_I32LessThan"] = 22] = "k_I32LessThan";
    EOperation[EOperation["k_I32GreaterThanEqual"] = 23] = "k_I32GreaterThanEqual";
    EOperation[EOperation["k_I32Equal"] = 24] = "k_I32Equal";
    EOperation[EOperation["k_I32NotEqual"] = 25] = "k_I32NotEqual";
    EOperation[EOperation["k_I32Not"] = 26] = "k_I32Not";
    EOperation[EOperation["k_F32LessThan"] = 27] = "k_F32LessThan";
    EOperation[EOperation["k_F32GreaterThanEqual"] = 28] = "k_F32GreaterThanEqual";
    //
    // Logical operations
    //
    EOperation[EOperation["k_I32LogicalOr"] = 29] = "k_I32LogicalOr";
    EOperation[EOperation["k_I32LogicalAnd"] = 30] = "k_I32LogicalAnd";
    //
    // intrinsics
    //
    EOperation[EOperation["k_F32Frac"] = 31] = "k_F32Frac";
    EOperation[EOperation["k_F32Floor"] = 32] = "k_F32Floor";
    EOperation[EOperation["k_F32Ceil"] = 33] = "k_F32Ceil";
    EOperation[EOperation["k_F32Sin"] = 34] = "k_F32Sin";
    EOperation[EOperation["k_F32Cos"] = 35] = "k_F32Cos";
    EOperation[EOperation["k_F32Abs"] = 36] = "k_F32Abs";
    EOperation[EOperation["k_F32Sqrt"] = 37] = "k_F32Sqrt";
    EOperation[EOperation["k_F32Max"] = 38] = "k_F32Max";
    EOperation[EOperation["k_F32Min"] = 39] = "k_F32Min";
    EOperation[EOperation["k_F32Pow"] = 40] = "k_F32Pow";
    EOperation[EOperation["k_I32Mad"] = 41] = "k_I32Mad";
    EOperation[EOperation["k_I32Min"] = 42] = "k_I32Min";
    EOperation[EOperation["k_I32Max"] = 43] = "k_I32Max";
    // 
    // Cast operations
    //
    EOperation[EOperation["k_F32ToU32"] = 44] = "k_F32ToU32";
    EOperation[EOperation["k_F32ToI32"] = 45] = "k_F32ToI32";
    EOperation[EOperation["k_U32ToF32"] = 46] = "k_U32ToF32";
    EOperation[EOperation["k_I32ToF32"] = 47] = "k_I32ToF32";
    //
    // Flow control
    //
    EOperation[EOperation["k_JumpIf"] = 48] = "k_JumpIf";
    EOperation[EOperation["k_Jump"] = 49] = "k_Jump";
    // the operation is only necessary to maintain the purity of the code, 
    // when generating the code will be replaced by a jump for all 
    // functions except entry point;
    EOperation[EOperation["k_Ret"] = 50] = "k_Ret";
})(EOperation || (EOperation = {}));
;


/***/ }),

/***/ "djKl":
/*!****************************************************!*\
  !*** ./src/lib/idl/bytecode/IDepthStencilState.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EComparisonFunc": () => (/* binding */ EComparisonFunc),
/* harmony export */   "EDepthWriteMask": () => (/* binding */ EDepthWriteMask),
/* harmony export */   "EStencilOp": () => (/* binding */ EStencilOp)
/* harmony export */ });
var EDepthWriteMask;
(function (EDepthWriteMask) {
    EDepthWriteMask[EDepthWriteMask["k_Zero"] = 0] = "k_Zero";
    EDepthWriteMask[EDepthWriteMask["k_All"] = 1] = "k_All";
})(EDepthWriteMask || (EDepthWriteMask = {}));
var EComparisonFunc;
(function (EComparisonFunc) {
    EComparisonFunc[EComparisonFunc["k_Never"] = 1] = "k_Never";
    EComparisonFunc[EComparisonFunc["k_Less"] = 2] = "k_Less";
    EComparisonFunc[EComparisonFunc["k_Equal"] = 3] = "k_Equal";
    EComparisonFunc[EComparisonFunc["k_LessEqual"] = 4] = "k_LessEqual";
    EComparisonFunc[EComparisonFunc["k_Greater"] = 5] = "k_Greater";
    EComparisonFunc[EComparisonFunc["k_NotEqual"] = 6] = "k_NotEqual";
    EComparisonFunc[EComparisonFunc["k_GreaterEqual"] = 7] = "k_GreaterEqual";
    EComparisonFunc[EComparisonFunc["k_Always"] = 8] = "k_Always";
})(EComparisonFunc || (EComparisonFunc = {}));
var EStencilOp;
(function (EStencilOp) {
    EStencilOp[EStencilOp["k_Keep"] = 1] = "k_Keep";
    EStencilOp[EStencilOp["K_zero"] = 2] = "K_zero";
    EStencilOp[EStencilOp["k_Replace"] = 3] = "k_Replace";
    EStencilOp[EStencilOp["k_IncrSat"] = 4] = "k_IncrSat";
    EStencilOp[EStencilOp["k_DecrSat"] = 5] = "k_DecrSat";
    EStencilOp[EStencilOp["k_Invert"] = 6] = "k_Invert";
    EStencilOp[EStencilOp["k_Incr"] = 7] = "k_Incr";
    EStencilOp[EStencilOp["k_Decr"] = 8] = "k_Decr";
})(EStencilOp || (EStencilOp = {}));


/***/ }),

/***/ "Evaj":
/*!***************************************!*\
  !*** ./src/lib/idl/bytecode/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EAddrType": () => (/* binding */ EAddrType),
/* harmony export */   "EChunkType": () => (/* binding */ EChunkType),
/* harmony export */   "EComparisonFunc": () => (/* reexport safe */ _IDepthStencilState__WEBPACK_IMPORTED_MODULE_1__.EComparisonFunc),
/* harmony export */   "EDepthWriteMask": () => (/* reexport safe */ _IDepthStencilState__WEBPACK_IMPORTED_MODULE_1__.EDepthWriteMask),
/* harmony export */   "EOperation": () => (/* reexport safe */ _EOperations__WEBPACK_IMPORTED_MODULE_0__.EOperation),
/* harmony export */   "EStencilOp": () => (/* reexport safe */ _IDepthStencilState__WEBPACK_IMPORTED_MODULE_1__.EStencilOp)
/* harmony export */ });
/* harmony import */ var _EOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EOperations */ "/9BJ");
/* harmony import */ var _IDepthStencilState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IDepthStencilState */ "djKl");


var EAddrType;
(function (EAddrType) {
    EAddrType[EAddrType["k_Registers"] = 0] = "k_Registers";
    EAddrType[EAddrType["k_Input"] = 1] = "k_Input";
    EAddrType[EAddrType["k_PointerRegisters"] = 2] = "k_PointerRegisters";
    EAddrType[EAddrType["k_PointerInput"] = 3] = "k_PointerInput";
    EAddrType[EAddrType["k_PipelineStates"] = 4] = "k_PipelineStates";
})(EAddrType || (EAddrType = {}));
;
var EChunkType;
(function (EChunkType) {
    EChunkType[EChunkType["k_Constants"] = 0] = "k_Constants";
    EChunkType[EChunkType["k_Layout"] = 1] = "k_Layout";
    EChunkType[EChunkType["k_Code"] = 2] = "k_Code";
    EChunkType[EChunkType["k_Externs"] = 3] = "k_Externs";
    EChunkType[EChunkType["k_Shaders"] = 4] = "k_Shaders";
    EChunkType[EChunkType["k_DepthStencilStates"] = 5] = "k_DepthStencilStates";
})(EChunkType || (EChunkType = {}));
;
;
;


/***/ }),

/***/ "Y0AG":
/*!***************************************!*\
  !*** ./src/lib/idl/parser/IParser.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ENodeCreateMode": () => (/* binding */ ENodeCreateMode),
/* harmony export */   "EOperationType": () => (/* binding */ EOperationType),
/* harmony export */   "EParserCode": () => (/* binding */ EParserCode),
/* harmony export */   "EParserFlags": () => (/* binding */ EParserFlags),
/* harmony export */   "EParserType": () => (/* binding */ EParserType),
/* harmony export */   "ETokenType": () => (/* binding */ ETokenType),
/* harmony export */   "IASTDocumentFlags": () => (/* binding */ IASTDocumentFlags)
/* harmony export */ });
var ENodeCreateMode;
(function (ENodeCreateMode) {
    ENodeCreateMode[ENodeCreateMode["k_Default"] = 0] = "k_Default";
    ENodeCreateMode[ENodeCreateMode["k_Necessary"] = 1] = "k_Necessary";
    ENodeCreateMode[ENodeCreateMode["k_Expose"] = 2] = "k_Expose";
    ENodeCreateMode[ENodeCreateMode["k_Skip"] = 3] = "k_Skip";
})(ENodeCreateMode || (ENodeCreateMode = {}));
var EParserCode;
(function (EParserCode) {
    // k_Pause,
    EParserCode[EParserCode["k_Ok"] = 0] = "k_Ok";
    EParserCode[EParserCode["k_Error"] = 1] = "k_Error";
})(EParserCode || (EParserCode = {}));
var EParserType;
(function (EParserType) {
    EParserType[EParserType["k_LR0"] = 0] = "k_LR0";
    EParserType[EParserType["k_LR1"] = 1] = "k_LR1";
    EParserType[EParserType["k_LALR"] = 2] = "k_LALR";
})(EParserType || (EParserType = {}));
var IASTDocumentFlags;
(function (IASTDocumentFlags) {
    IASTDocumentFlags[IASTDocumentFlags["k_Optimize"] = 8] = "k_Optimize";
    IASTDocumentFlags[IASTDocumentFlags["k_DeveloperMode"] = 16] = "k_DeveloperMode";
})(IASTDocumentFlags || (IASTDocumentFlags = {}));
var EParserFlags;
(function (EParserFlags) {
    EParserFlags[EParserFlags["k_ForceAppendAll"] = 1] = "k_ForceAppendAll";
    EParserFlags[EParserFlags["k_AllowExposeMode"] = 2] = "k_AllowExposeMode";
    EParserFlags[EParserFlags["k_AllowAddMode"] = 4] = "k_AllowAddMode";
    EParserFlags[EParserFlags["k_AllowSkipMode"] = 8] = "k_AllowSkipMode";
    EParserFlags[EParserFlags["k_Default"] = 14] = "k_Default";
    EParserFlags[EParserFlags["k_Debug"] = 16] = "k_Debug";
})(EParserFlags || (EParserFlags = {}));
var ETokenType;
(function (ETokenType) {
    ETokenType[ETokenType["k_NumericLiteral"] = 1] = "k_NumericLiteral";
    ETokenType[ETokenType["k_SinglelineCommentLiteral"] = 2] = "k_SinglelineCommentLiteral";
    ETokenType[ETokenType["k_MultilineCommentLiteral"] = 3] = "k_MultilineCommentLiteral";
    ETokenType[ETokenType["k_StringLiteral"] = 4] = "k_StringLiteral";
    ETokenType[ETokenType["k_PunctuatorLiteral"] = 5] = "k_PunctuatorLiteral";
    ETokenType[ETokenType["k_WhitespaceLiteral"] = 6] = "k_WhitespaceLiteral";
    ETokenType[ETokenType["k_EscapeSequence"] = 7] = "k_EscapeSequence";
    ETokenType[ETokenType["k_NewlineLiteral"] = 8] = "k_NewlineLiteral";
    ETokenType[ETokenType["k_IdentifierLiteral"] = 9] = "k_IdentifierLiteral";
    ETokenType[ETokenType["k_KeywordLiteral"] = 10] = "k_KeywordLiteral";
    ETokenType[ETokenType["K_MacroLiteral"] = 11] = "K_MacroLiteral";
    ETokenType[ETokenType["k_Unknown"] = 12] = "k_Unknown";
    ETokenType[ETokenType["k_End"] = 13] = "k_End";
})(ETokenType || (ETokenType = {}));
var EOperationType;
(function (EOperationType) {
    EOperationType[EOperationType["k_Error"] = 100] = "k_Error";
    EOperationType[EOperationType["k_Shift"] = 101] = "k_Shift";
    EOperationType[EOperationType["k_Reduce"] = 102] = "k_Reduce";
    EOperationType[EOperationType["k_Success"] = 103] = "k_Success";
    EOperationType[EOperationType["k_Ok"] = 104] = "k_Ok";
})(EOperationType || (EOperationType = {}));


/***/ }),

/***/ "j3Uf":
/*!*************************************!*\
  !*** ./src/lib/idl/part/IPartFx.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPassDrawMode": () => (/* binding */ EPassDrawMode)
/* harmony export */ });
// import { EPartFxInstructionTypes } from "./IPartFxInstruction";
var EPassDrawMode;
(function (EPassDrawMode) {
    EPassDrawMode[EPassDrawMode["k_Auto"] = 0] = "k_Auto";
    EPassDrawMode[EPassDrawMode["k_Manual"] = 1] = "k_Manual";
})(EPassDrawMode || (EPassDrawMode = {}));
;


/***/ }),

/***/ "7GK7":
/*!***************************************!*\
  !*** ./src/lib/parser/ASTDocument.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTDocument": () => (/* binding */ ASTDocument),
/* harmony export */   "EParsingErrors": () => (/* binding */ EParsingErrors),
/* harmony export */   "EParsingWarnings": () => (/* binding */ EParsingWarnings),
/* harmony export */   "ParsingDiagnostics": () => (/* binding */ ParsingDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "SSye");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_ParseTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/ParseTree */ "Eumm");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");









var EParsingErrors;
(function (EParsingErrors) {
    EParsingErrors[EParsingErrors["SyntaxUnknownError"] = 2051] = "SyntaxUnknownError";
    EParsingErrors[EParsingErrors["SyntaxUnexpectedEOF"] = 2052] = "SyntaxUnexpectedEOF";
    EParsingErrors[EParsingErrors["SyntaxRecoverableStateNotFound"] = 2053] = "SyntaxRecoverableStateNotFound";
    EParsingErrors[EParsingErrors["GeneralParsingLimitIsReached"] = 2054] = "GeneralParsingLimitIsReached";
})(EParsingErrors || (EParsingErrors = {}));
;
var EParsingWarnings;
(function (EParsingWarnings) {
    EParsingWarnings[EParsingWarnings["MacroUnknownWarning"] = 3000] = "MacroUnknownWarning";
    EParsingWarnings[EParsingWarnings["ReserveWordUsing"] = 3001] = "ReserveWordUsing";
})(EParsingWarnings || (EParsingWarnings = {}));
class ParsingDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.Diagnostics {
    constructor() {
        super("Parsing diagnostics", 'P');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        if (category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__.EDiagnosticCategory.k_Warning) {
            switch (code) {
                case EParsingWarnings.MacroUnknownWarning:
                    return desc.loc;
            }
        }
        //
        // errors
        //
        switch (code) {
            case EParsingErrors.SyntaxUnknownError:
            case EParsingErrors.SyntaxUnexpectedEOF:
                return desc.token.loc;
        }
        return null;
    }
    //
    // NODE: position is being resolved only in case of failed range resolving
    //
    resolvePosition(category, code, desc) {
        console.assert(code != EParsingErrors.SyntaxUnknownError);
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParsingErrors.SyntaxUnknownError]: "Syntax error during parsing. Token: '{token.value}'\n" +
                "{token.loc.start.file}:{token.loc.start.line}:{token.loc.start.column}.",
            [EParsingErrors.SyntaxUnexpectedEOF]: "Syntax error. Unexpected EOF.",
            [EParsingErrors.GeneralParsingLimitIsReached]: "Parsing limit is reached.",
            [EParsingErrors.SyntaxRecoverableStateNotFound]: "Recoverable state not found."
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_2__.EDiagnosticCategory.k_Warning) {
            return `${EParsingWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${EParsingErrors[code]}: ${JSON.stringify(data)}`;
    }
}
function cloneToken(token) {
    return {
        ...token,
        loc: {
            start: { ...token.loc.start },
            end: { ...token.loc.end }
        }
    };
}
// class Context {
//     allowErrorRecoverty: boolean = true;
//     developerMode: boolean = false;
//     lexer: Lexer;
//     diagnostics: ParsingDiagnostics;
//     knownTypes: Set<string>;
//     ruleFunctions: Map<string, IRuleFunction>;
//     stack: number[] = [0];
//     constructor() {
//         this.diagnostics = new ParsingDiagnostics;
//     }
//     readToken() {
//         return this.lexer.getNextToken();
//     }
//     private error(code: number, token: IToken) {
//         this.diagnostics.error(code, { ...this.lexer.getLocation(), token });
//     }
//     private critical(code: number, token: IToken = null) {
//         this.diagnostics.critical(code, { ...this.lexer.getLocation(), token });
//     }
// }
class ASTDocument {
    constructor(config) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(config.parser, 'parser engine is not defined');
        this.init(config);
    }
    init({ parser, knownTypes = new Set(), ruleFunctions = new Map }) {
        this.parser = parser;
        this.knownTypes = knownTypes;
        this.ruleFunctions = ruleFunctions;
    }
    get uri() {
        // TODO: use uri from original textDocument
        return this.lexer.document.uri;
    }
    get diagnosticReport() {
        let lexerReport = this.lexer.getDiagnosticReport();
        let parserReport = this.diag.resolve();
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.Diagnostics.mergeReports([lexerReport, parserReport]);
    }
    get root() {
        return this.tree.root;
    }
    async parse(textDocument, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_Optimize) {
        const developerMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_DeveloperMode);
        const allowErrorRecoverty = true;
        const optimizeTree = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.IASTDocumentFlags.k_Optimize);
        this.diag = new ParsingDiagnostics;
        this.tree = new _lib_parser_ParseTree__WEBPACK_IMPORTED_MODULE_5__.ParseTree(optimizeTree);
        this.stack = [0];
        this.setTextDocument(textDocument);
        this.token = await this.readToken();
        if (this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Ok;
        }
        await this.run({ developerMode, allowErrorRecoverty });
        // clear context
        // this.stack = null;
        // this.lexer = null;
        // this.token = null;
        // diag
        // tree
        // end of clear
        if (this.diag.hasErrors()) {
            console.error('parsing was ended with errors.');
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Error;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EParserCode.k_Ok;
    }
    setTextDocument(textDocument) {
        this.lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__.Lexer({
            engine: this.parser.lexerEngine,
            knownTypes: this.knownTypes
        });
        this.lexer.setTextDocument(textDocument);
    }
    async readToken() {
        return this.lexer.getNextToken();
    }
    emitWarning(code, token) {
        this.diag.warning(code, { token });
    }
    emitError(code, token) {
        this.diag.error(code, { token });
    }
    emitCritical(code, token = null) {
        this.diag.critical(code, { token });
    }
    async restoreState(syntaxTable, parseTree, stack, causingErrorToken, errorToken) {
        while (true) {
            let recoverableState = -1;
            for (let i = stack.length - 1; i >= 0; --i) {
                const errorOp = syntaxTable[stack[i]][_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR];
                const isRecoverableState = ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(errorOp) &&
                    errorOp.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift &&
                    syntaxTable[errorOp.stateIndex][causingErrorToken.name]);
                if (isRecoverableState) {
                    recoverableState = i;
                    break;
                }
            }
            if (recoverableState !== -1) {
                const recoveredStateIndex = stack[recoverableState];
                // current op will be: syntaxTable[recoveredStateIndex][ERROR];
                let stackDiff = stack.length - 1 - recoverableState;
                while (stackDiff != 0) {
                    // extend error token location with the already processed tokens
                    parseTree.$pop(errorToken.loc);
                    stack.pop();
                    stackDiff--;
                }
                // recoverable state found so continue normal processing as it would be before the error
                return recoveredStateIndex;
            }
            // TODO: optimize this call!
            (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_7__.extendRange)(errorToken.loc, causingErrorToken.loc);
            if (causingErrorToken.value === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
                // state cant be recovered
                break;
            }
            // try to restore from the next token
            // FIXME: 
            const nextToken = await this.readToken();
            Object.keys(nextToken).forEach(key => causingErrorToken[key] = nextToken[key]);
        }
        return -1;
    }
    operationAdditionalAction(stateIndex, grammarSymbol) {
        const funcName = this.parser.findFunctionByState(stateIndex, grammarSymbol);
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(funcName)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(!!this.ruleFunctions.has(funcName));
            return this.ruleFunctions.get(funcName)();
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Ok;
    }
    async run({ developerMode = false, allowErrorRecoverty = true }) {
        const { syntaxTable } = this.parser;
        const { stack, tree } = this;
        const undefinedToken = { index: -1, name: null, value: null };
        let causingErrorToken = undefinedToken;
        // debug mode
        const opLimit = 64e5;
        let opCounter = 0;
        try {
            breakProcessing: while (true) {
                // global recursion prevention in debug mode
                if (developerMode) {
                    if (opCounter > opLimit) {
                        this.emitCritical(EParsingErrors.GeneralParsingLimitIsReached);
                    }
                    opCounter++;
                }
                let currStateIndex = stack[stack.length - 1];
                let op = syntaxTable[currStateIndex][this.token.name];
                if (allowErrorRecoverty) {
                    if (!op) {
                        const ID_REGEXP = /^[_a-zA-Z][_a-zA-Z0-9]{0,30}$/;
                        const isLikeID = this.token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID && ID_REGEXP.test(this.token.value);
                        const canContinueAsID = isLikeID && syntaxTable[currStateIndex][_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID];
                        // recursion prevention
                        if (causingErrorToken.index !== this.token.index) {
                            if (this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL) {
                                this.emitError(EParsingErrors.SyntaxUnexpectedEOF, this.token);
                            }
                            else {
                                // a special case to bypass tokens of the same name with keywords
                                if (canContinueAsID) {
                                    // todo: emit warning(!)
                                    // this.emitWarning(EParsingWarnings.ReserveWordUsing, this.token);
                                }
                                else {
                                    this.emitError(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                            }
                        }
                        else {
                            // one more attempt to recover but from the next token
                            this.token = await this.readToken();
                            if (this.token.index === -1)
                                debugger;
                            // NOTE: in order to prevent recusrion on END_SYMBOL
                            causingErrorToken = undefinedToken;
                            continue;
                        }
                        causingErrorToken = cloneToken(this.token);
                        if (canContinueAsID) {
                            this.token = { ...cloneToken(this.token), name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_NON_TYPE_ID };
                        }
                        else {
                            // token = { ...token, name: ERROR };
                            this.token = { ...cloneToken(this.token), name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR };
                        }
                    }
                    op = syntaxTable[currStateIndex][this.token.name];
                    const errorProcessing = this.token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.ERROR;
                    const errorReductionEnded = !op || (errorProcessing && (op.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift));
                    // state must be recovered if operation is undefined or error reduction was ended. 
                    if (errorReductionEnded) {
                        // NOTE: recoveryToken, token, stack and parseTree will be update imlicitly inside the state restore routine. 
                        let recoveryToken = cloneToken(causingErrorToken);
                        while (recoveryToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNKNOWN_TOKEN) {
                            recoveryToken = await this.readToken();
                            if (recoveryToken.index === -1)
                                debugger;
                        }
                        currStateIndex = await this.restoreState(syntaxTable, tree, stack, recoveryToken, this.token /* error token */);
                        if (currStateIndex === -1) {
                            this.emitCritical(EParsingErrors.SyntaxRecoverableStateNotFound);
                        }
                        // perform error shift op.
                        op = syntaxTable[currStateIndex][this.token.name]; // token.name === 'ERROR'
                        stack.push(op.stateIndex);
                        tree.addToken(this.token /* error token */);
                        this.token = recoveryToken;
                        // const nextOp = syntaxTable[op.stateIndex][token.name];
                        // if (nextOp.type === EOperationType.k_Reduce) {
                        //     tokenBuffer.push(rec);
                        // }
                        // return to normal precesing loop
                        continue;
                    }
                }
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(op)) {
                    switch (op.type) {
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Success:
                            break breakProcessing;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Shift:
                            {
                                const stateIndex = op.stateIndex;
                                stack.push(stateIndex);
                                tree.addToken(this.token);
                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, this.token.name);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                                else if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Ok) {
                                    this.token = await this.readToken();
                                    if (this.token.index === -1)
                                        debugger;
                                }
                            }
                            break;
                        case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Reduce:
                            {
                                const ruleLength = op.rule.right.length;
                                stack.length -= ruleLength;
                                const stateIndex = syntaxTable[stack[stack.length - 1]][op.rule.left].stateIndex;
                                stack.push(stateIndex);
                                tree.reduceByRule(op.rule, this.parser.getRuleCreationMode(op.rule.left));
                                const additionalOperationCode = this.operationAdditionalAction(stateIndex, op.rule.left);
                                if (additionalOperationCode === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_3__.EOperationType.k_Error) {
                                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                                }
                            }
                            break;
                    }
                }
                else {
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(!allowErrorRecoverty, `unexpected end, something went wrong :/`);
                    this.emitCritical(EParsingErrors.SyntaxUnknownError, this.token);
                }
            }
            tree.finishTree();
        }
        catch (e) {
            if (!(e instanceof _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_8__.DiagnosticException)) {
                throw e;
            }
        }
    }
}


/***/ }),

/***/ "BF0t":
/*!******************************************!*\
  !*** ./src/lib/parser/AbstractParser.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractParser": () => (/* binding */ AbstractParser),
/* harmony export */   "EParserErrors": () => (/* binding */ EParserErrors),
/* harmony export */   "GrammarDiagnostics": () => (/* binding */ GrammarDiagnostics)
/* harmony export */ });
/* harmony import */ var _lib_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf */ "SSye");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/Item */ "gO55");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/State */ "Xd2f");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");








var EParserErrors;
(function (EParserErrors) {
    EParserErrors[EParserErrors["GrammarAddOperation"] = 2001] = "GrammarAddOperation";
    EParserErrors[EParserErrors["GrammarAddStateLink"] = 2002] = "GrammarAddStateLink";
    EParserErrors[EParserErrors["GrammarUnexpectedSymbol"] = 2003] = "GrammarUnexpectedSymbol";
    EParserErrors[EParserErrors["GrammarInvalidAdditionalFuncName"] = 2004] = "GrammarInvalidAdditionalFuncName";
    EParserErrors[EParserErrors["GrammarInvalidKeyword"] = 2005] = "GrammarInvalidKeyword";
})(EParserErrors || (EParserErrors = {}));
;
class GrammarDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics {
    constructor() {
        super("Grammar diagnostics", 'G');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        return null;
    }
    resolvePosition(category, code, desc) {
        return { line: desc.line, column: 0, file: null };
    }
    diagnosticMessages() {
        return {
            [EParserErrors.GrammarAddOperation]: "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old operation: {oldOperation}\n" +
                "New operation: {newOperation}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states." +
                `\n\n{stateDesc}`,
            [EParserErrors.GrammarAddStateLink]: "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" +
                "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                "Old next state: {oldNextStateIndex}\n" +
                "New next state: {newNextStateIndex}\n" +
                "For more info init parser in debug-mode and see syntax table and list of states.",
            [EParserErrors.GrammarUnexpectedSymbol]: "Grammar error. Can`t generate rules from grammar\n" +
                "Unexpected symbol: {unexpectedSymbol}\n" +
                "Expected: {expectedSymbol}",
            [EParserErrors.GrammarInvalidAdditionalFuncName]: "Grammar error. Empty additional function name.",
            [EParserErrors.GrammarInvalidKeyword]: "Grammar error. Bad keyword: {badKeyword}\n" +
                "All keyword must be define in lexer rule block."
        };
    }
}
class AbstractParser {
    // grammar: string, flags: number = EParserFlags.k_AllNode, type: EParserType = EParserType.k_LALR
    constructor({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR }) {
        this._syntaxTable = null;
        this._productions = null;
        this._baseItems = null;
        this._states = null;
        this._additionalFuncInfoList = null;
        this._adidtionalFunctByStateDMap = null;
        this._ruleCreationModeMap = null;
        this._firstTerminalsCache = null;
        // this._followTerminalsCache = null;
        this._closureForItemsCache = null;
        this._expectedExtensionDMap = null;
        this._diag = new GrammarDiagnostics;
        this.init({ grammar, flags, type });
    }
    get syntaxTable() {
        return this._syntaxTable;
    }
    findFunctionByState(stateIndex, grammarSymbol) {
        const funcDMap = this._adidtionalFunctByStateDMap;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(funcDMap) &&
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(funcDMap[stateIndex]) &&
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(funcDMap[stateIndex][grammarSymbol])) {
            return funcDMap[stateIndex][grammarSymbol];
        }
        return null;
    }
    getRuleCreationMode(nonTerminal) {
        return this._ruleCreationModeMap[nonTerminal];
    }
    getGrammarSymbols() {
        return this._grammarSymbols;
    }
    init({ grammar, flags = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Default, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR }) {
        this.lexerEngine = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_4__.LexerEngine();
        this.generateRules(grammar, flags);
        this.buildSyntaxTable(type);
        this.generateFunctionByStateMap();
        if (!_lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_Debug)) {
            this.clearMem();
        }
    }
    printStates(isBaseOnly = true) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._states)) {
            console.warn("It`s impossible to print states. You must init parser in debug-mode");
            return;
        }
        const mesg = "\n" + this.statesToString(isBaseOnly);
        console.log(mesg);
    }
    printState(stateIndex, isBaseOnly = true) {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._states)) {
            console.log("It`s impossible to print states. You must init parser in debug-mode.");
            return;
        }
        var state = this._states[stateIndex];
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(state)) {
            console.log("Can not print stete with index: " + stateIndex.toString());
            return;
        }
        console.log(`\n${state.toString(isBaseOnly, this.getGrammarSymbols())}`);
    }
    critical(code, desc) {
        this._diag.critical(code, desc);
    }
    grammarError(code, desc) {
        let file = "grammar";
        switch (code) {
            case EParserErrors.GrammarAddOperation:
                {
                    const { stateIndex, grammarSymbol, oldOperation, newOperation } = desc;
                    this.critical(code, {
                        file, line: 0, stateIndex, grammarSymbol,
                        oldOperation: AbstractParser.operationToString(oldOperation),
                        newOperation: AbstractParser.operationToString(newOperation),
                        stateDesc: this._states[stateIndex].toString()
                    });
                }
                break;
            case EParserErrors.GrammarAddStateLink:
                {
                    const { stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex } = desc;
                    this.critical(code, { file, line: 0, stateIndex, grammarSymbol, oldNextStateIndex, newNextStateIndex });
                }
                break;
            case EParserErrors.GrammarUnexpectedSymbol:
                {
                    const { grammarLine, expectedSymbol, unexpectedSymbol } = desc;
                    this.critical(code, { file, line: grammarLine, expectedSymbol, unexpectedSymbol });
                }
                break;
            case EParserErrors.GrammarInvalidAdditionalFuncName:
                {
                    const { grammarLine } = desc;
                    this.critical(code, { file, line: grammarLine });
                }
                break;
            case EParserErrors.GrammarInvalidKeyword:
                {
                    const { grammarLine, badKeyword } = desc;
                    this.critical(code, { file, line: grammarLine, badKeyword });
                }
                break;
            default:
                throw "invalid case!!!!";
        }
    }
    clearMem() {
        delete this._states;
        delete this._productions;
        delete this._baseItems;
        // delete this._followTerminalsCache;
        delete this._firstTerminalsCache;
        delete this._closureForItemsCache;
        delete this._expectedExtensionDMap;
    }
    /**
     * Check for the state's dublicate.
     */
    hasState(state, type) {
        return this._states.find(stateIth => stateIth.isEqual(state, type)) || null;
    }
    nonTerminals() {
        return Object.keys(this._productions);
    }
    rules(nonTerminal) {
        const prods = this._productions[nonTerminal];
        return prods ? Object.keys(prods).map(ruleIndex => prods[ruleIndex]) : null;
    }
    ruleCreationMode(symbol) {
        return this._ruleCreationModeMap[symbol];
    }
    /**
     * terminals & non-terminals;
     */
    symbols() {
        return [...this._grammarSymbols.keys()];
    }
    isTerminal(symbol) {
        return !(this._productions[symbol]);
    }
    /**
     * Add item to 'stateList' and set item's index in it.
     */
    pushState(state) {
        state.index = this._states.length;
        this._states.push(state);
    }
    /**
     * Add item to 'baseItemList' and set item's index in it.
     */
    pushBaseItem(item) {
        item.index = this._baseItems.length;
        this._baseItems.push(item);
    }
    tryAddState(state, type) {
        let res = this.hasState(state, type);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(res)) {
            if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
                state.eachItem(item => this.pushBaseItem(item));
            }
            this.pushState(state);
            this.closure(state, type);
            return state;
        }
        return res;
    }
    hasEmptyRule(symbol) {
        if (this.isTerminal(symbol)) {
            return false;
        }
        return !!this.rules(symbol).find(rule => rule.right.length === 0);
    }
    pushInSyntaxTable(syntaxTable, stateIndex, symbol, operation) {
        syntaxTable[stateIndex] = syntaxTable[stateIndex] || {};
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(syntaxTable[stateIndex][symbol])) {
            this.grammarError(EParserErrors.GrammarAddOperation, {
                stateIndex: stateIndex,
                grammarSymbol: this.convertGrammarSymbol(symbol),
                oldOperation: this._syntaxTable[stateIndex][symbol],
                newOperation: operation
            });
        }
        syntaxTable[stateIndex][symbol] = operation;
    }
    addStateLink(state, nextState, symbol) {
        let isAddState = state.addNextState(symbol, nextState);
        if (!isAddState) {
            this.grammarError(EParserErrors.GrammarAddStateLink, {
                stateIndex: state.index,
                oldNextStateIndex: state.nextStates[symbol] || null,
                newNextStateIndex: nextState.index,
                grammarSymbol: this.convertGrammarSymbol(symbol)
            });
        }
    }
    firstTerminals(symbol) {
        if (this.isTerminal(symbol)) {
            return null;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._firstTerminalsCache[symbol])) {
            return this._firstTerminalsCache[symbol];
        }
        const rules = this.rules(symbol);
        const res = this._firstTerminalsCache[symbol] = new Set();
        if (this.hasEmptyRule(symbol)) {
            res.add(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY);
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(rules)) {
            return res;
        }
        for (let i = 0; i < rules.length; ++i) {
            const rule = rules[i];
            const right = rule.right;
            let isFinish = false;
            for (let j = 0; j < right.length; j++) {
                if (right[j] === symbol) {
                    if (res.has(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY)) {
                        continue;
                    }
                    isFinish = true;
                    break;
                }
                const terminals = this.firstTerminals(right[j]);
                if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(terminals)) {
                    res.add(right[j]);
                }
                else {
                    for (const terminal of terminals) {
                        res.add(terminal);
                    }
                }
                if (!this.hasEmptyRule(right[j])) {
                    isFinish = true;
                    break;
                }
            }
            if (!isFinish) {
                res.add(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY);
            }
        }
        return res;
    }
    // private followTerminal(symbolVal: string): IMap<boolean> {
    //     if (isDef(this._followTerminalsCache[symbolVal])) {
    //         return this._followTerminalsCache[symbolVal];
    //     }
    //     var i: number = 0, j: number = 0, k: number = 0, l: number = 0, m: number = 0;
    //     var pRulesDMap: IRuleDMap = this._rulesDMap;
    //     var rulesDMapKeys: string[], pRulesMapKeys: string[];
    //     var rule: IRule;
    //     var pTempRes: IMap<boolean>;
    //     var pTempKeys: string[];
    //     var res: IMap<boolean>;
    //     var right: string[];
    //     var isFinish: boolean;
    //     var sFirstKey: string;
    //     var sSecondKey: string;
    //     res = this._followTerminalsCache[symbolVal] = <IMap<boolean>>{};
    //     if (isNull(pRulesDMap)) {
    //         return res;
    //     }
    //     rulesDMapKeys = Object.keys(pRulesDMap);
    //     for (i = 0; i < rulesDMapKeys.length; i++) {
    //         sFirstKey = rulesDMapKeys[i];
    //         if (isNull(pRulesDMap[sFirstKey])) {
    //             continue;
    //         }
    //         pRulesMapKeys = Object.keys(pRulesDMap[sFirstKey]);
    //         for (j = 0; j < pRulesMapKeys.length; j++) {
    //             rule = pRulesDMap[sFirstKey][sSecondKey];
    //             right = rule.right;
    //             for (k = 0; k < right.length; k++) {
    //                 if (right[k] === symbolVal) {
    //                     if (k === right.length - 1) {
    //                         pTempRes = this.followTerminal(rule.left);
    //                         pTempKeys = Object.keys(pTempRes);
    //                         for (m = 0; m < pTempKeys.length; i++) {
    //                             res[pTempKeys[m]] = true;
    //                         }
    //                     }
    //                     else {
    //                         isFinish = false;
    //                         for (l = k + 1; l < right.length; l++) {
    //                             pTempRes = this.firstTerminal(right[l]);
    //                             if (isNull(pTempRes)) {
    //                                 res[right[l]] = true;
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                             else {
    //                                 pTempKeys = Object.keys(pTempRes);
    //                                 for (m = 0; m < pTempKeys.length; i++) {
    //                                     res[pTempKeys[m]] = true;
    //                                 }
    //                             }
    //                             if (!pTempRes[T_EMPTY]) {
    //                                 isFinish = true;
    //                                 break;
    //                             }
    //                         }
    //                         if (!isFinish) {
    //                             pTempRes = this.followTerminal(rule.left);
    //                             pTempKeys = Object.keys(pTempRes);
    //                             for (m = 0; m < pTempKeys.length; i++) {
    //                                 res[pTempKeys[m]] = true;
    //                             }
    //                         }
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return res;
    // }
    firstTerminalsForSet(symbolList, expectedSymbols) {
        const res = new Set();
        for (let i = 0; i < symbolList.length; i++) {
            const terminals = this.firstTerminals(symbolList[i]);
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(terminals)) {
                res.add(symbolList[i]);
                return res;
            }
            let isEmpty = false;
            for (const symbol of terminals) {
                if (symbol === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.T_EMPTY) {
                    isEmpty = true;
                    continue;
                }
                res.add(symbol);
            }
            if (!isEmpty) {
                return res;
            }
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(expectedSymbols)) {
            expectedSymbols.forEach(expectedSymbol => res.add(expectedSymbol));
        }
        return res;
    }
    generateRules(grammarSource, flags) {
        let allRuleList = grammarSource.split(/\r?\n/);
        let tempRule;
        let rule;
        let isLexerBlock = false;
        this._productions = {};
        this._additionalFuncInfoList = [];
        this._ruleCreationModeMap = {};
        this._grammarSymbols = new Map([['END_SYMBOL', _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL]]);
        let i = 0, j = 0;
        // append all nodes ignoring any flags
        const forceAppendAllMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_ForceAppendAll);
        // force unwind node if it is marked as '--expose'
        const allowExposeMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowExposeMode);
        // force add node if it is marked as '--add'
        const allowAddMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowAddMode);
        // remove node from parsing tree if it is marked as '--skip'
        const allowSkipMode = _lib_bf__WEBPACK_IMPORTED_MODULE_0__["default"].testAll(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserFlags.k_AllowSkipMode);
        let symbolsWithNodeMap = this._ruleCreationModeMap;
        let name;
        let nRules = 0;
        for (i = 0; i < allRuleList.length; i++) {
            if (allRuleList[i] === "" || allRuleList[i] === "\r") {
                continue;
            }
            // split rule like 'S : Program'
            tempRule = allRuleList[i].trim().split(/\s* \s*/);
            // ignore rules starting with '#'
            if (tempRule[0][0] == _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.INLINE_COMMENT_SYMBOL) {
                continue;
            }
            if (isLexerBlock) {
                if ((tempRule.length === 3 || (tempRule.length === 4 && tempRule[3] === "")) &&
                    ((tempRule[2][0] === "\"" || tempRule[2][0] === "'") && tempRule[2].length > 3)) {
                    //TERMINALS
                    if (tempRule[2][0] !== tempRule[2][tempRule[2].length - 1]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[2][tempRule[2].length - 1],
                            expectedSymbol: tempRule[2][0],
                            grammarLine: i
                        });
                    }
                    tempRule[2] = tempRule[2].slice(1, tempRule[2].length - 1);
                    var ch = tempRule[2][0];
                    if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                        name = this.lexerEngine.addKeyword(tempRule[2], tempRule[0]);
                    }
                    else {
                        name = this.lexerEngine.addPunctuator(tempRule[2], tempRule[0]);
                    }
                    this._grammarSymbols.set(name, tempRule[2]);
                }
                continue;
            }
            // looking for '--LEXER--' keyword
            if (tempRule[0] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.LEXER_RULES) {
                isLexerBlock = true;
                continue;
            }
            //NON TERMNINAL RULES
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._productions[tempRule[0]])) {
                this._productions[tempRule[0]] = {};
            }
            rule = {
                left: tempRule[0],
                right: [],
                index: 0
            };
            this._grammarSymbols.set(tempRule[0], tempRule[0]);
            if (forceAppendAllMode) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Default;
            }
            else if (allowExposeMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Default;
            }
            else if (allowAddMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Expose;
            }
            else if (allowSkipMode && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(symbolsWithNodeMap[tempRule[0]])) {
                symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Skip;
            }
            for (j = 2; j < tempRule.length; j++) {
                if (tempRule[j] === "") {
                    continue;
                }
                // handle flag '--add'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_CREATE_NODE) {
                    if (allowAddMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Necessary;
                    }
                    continue;
                }
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_SKIP_NODE) {
                    if (allowSkipMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Skip;
                    }
                    continue;
                }
                // handle flag '--expose'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_EXPOSE_NODE) {
                    if (allowExposeMode && !forceAppendAllMode) {
                        symbolsWithNodeMap[tempRule[0]] = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.ENodeCreateMode.k_Expose;
                    }
                    continue;
                }
                // looking for additional user functions like '--F includeCode'
                if (tempRule[j] === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.FLAG_RULE_FUNCTION) {
                    if ((!tempRule[j + 1] || tempRule[j + 1].length === 0)) {
                        this.grammarError(EParserErrors.GrammarInvalidAdditionalFuncName, { grammarLine: i });
                    }
                    const funcInfo = {
                        name: tempRule[j + 1],
                        position: rule.right.length,
                        rule: rule
                    };
                    this._additionalFuncInfoList.push(funcInfo);
                    j++;
                    continue;
                }
                // handle string literlas
                if (tempRule[j][0] === "'" || tempRule[j][0] === "\"") {
                    if (tempRule[j].length !== 3) {
                        this.grammarError(EParserErrors.GrammarInvalidKeyword, {
                            badKeyword: tempRule[j],
                            grammarLine: i
                        });
                    }
                    if (tempRule[j][0] !== tempRule[j][2]) {
                        this.grammarError(EParserErrors.GrammarUnexpectedSymbol, {
                            unexpectedSymbol: tempRule[j][2],
                            expectedSymbol: tempRule[j][0],
                            grammarLine: i
                        });
                    }
                    name = this.lexerEngine.addPunctuator(tempRule[j][1]);
                    rule.right.push(name);
                    this._grammarSymbols.set(name, tempRule[j][1]);
                }
                else {
                    rule.right.push(tempRule[j]);
                    this._grammarSymbols.set(tempRule[j], tempRule[j]);
                }
            }
            rule.index = nRules;
            this._productions[tempRule[0]][rule.index] = rule;
            nRules++;
            // TODO: emit diagnostics error instead.
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.assert)(nRules != 1 || (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0]));
        }
    }
    generateFunctionByStateMap() {
        const stateList = this._states;
        const funcInfoList = this._additionalFuncInfoList;
        const funcByStateDMap = this._adidtionalFunctByStateDMap = {};
        for (let i = 0; i < funcInfoList.length; i++) {
            const funcInfo = funcInfoList[i];
            const rule = funcInfo.rule;
            const pos = funcInfo.position;
            const grammarSymbol = rule.right[pos - 1];
            for (let j = 0; j < stateList.length; j++) {
                if (stateList[j].hasRule(rule, pos)) {
                    funcByStateDMap[stateList[j].index] = funcByStateDMap[stateList[j].index] || {};
                    funcByStateDMap[stateList[j].index][grammarSymbol] = funcInfo.name;
                }
            }
        }
    }
    generateFirstState_LR0() {
        const state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        // START_SYMBOL should be always defined at the beginning of grammar
        const firstRule = this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0];
        const item = new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(firstRule, 0);
        this.pushBaseItem(item);
        state.push(item);
        this.closure_LR0(state);
        this.pushState(state);
    }
    generateFirstState_LR() {
        const state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        const firstRule = this._productions[_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL][0];
        state.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(firstRule, 0, [_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL]));
        this.closure_LR(state);
        this.pushState(state);
    }
    closure(state, type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
            this.closure_LR0(state);
        }
        else {
            this.closure_LR(state);
        }
    }
    closure_LR0(state) {
        // NOTE: loop grows implicitly inside state.tryPush() function.
        //       do not change this loop.
        state.eachItem(item => {
            const symbol = item.symbolName();
            if (symbol !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION && !this.isTerminal(symbol)) {
                this.rules(symbol).forEach(rule => state.tryPush_LR0(rule, 0));
            }
        });
    }
    closure_LR(state) {
        let isNewExpected;
        do {
            isNewExpected = false;
            state.eachItem(item => {
                const symbol = item.symbolName();
                if (symbol !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION && !this.isTerminal(symbol)) {
                    const nextSymbols = item.rule.right.slice(item.pos + 1);
                    const expectedTerminals = this.firstTerminalsForSet(nextSymbols, item.expectedSymbols);
                    this.rules(symbol).forEach(rule => {
                        expectedTerminals.forEach(expectedTerminal => {
                            if (state.tryPush_LR(rule, 0, expectedTerminal)) {
                                isNewExpected = true;
                            }
                        });
                    });
                }
            });
        } while (isNewExpected);
    }
    static nextState_LR0(state, symbol) {
        const nextState = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                nextState.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(item.rule, item.pos + 1));
            }
        });
        return nextState;
    }
    static nextState_LR(state, symbol) {
        const nextState = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.eachItem(item => {
            if (item.symbolName() === symbol) {
                const expectedSymbols = Array.from(item.expectedSymbols);
                nextState.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(item.rule, item.pos + 1, expectedSymbols));
            }
        });
        return nextState;
    }
    deleteNotBaseItems() {
        this._states.forEach(state => state.deleteNotBase());
    }
    closureForItem({ rule, pos }) {
        const indexVal = rule.index + "_" + pos;
        let state = this._closureForItemsCache[indexVal];
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDef)(state)) {
            return state;
        }
        state = new _lib_parser_State__WEBPACK_IMPORTED_MODULE_5__.State();
        state.push(new _lib_parser_Item__WEBPACK_IMPORTED_MODULE_3__.Item(rule, pos, [_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNUSED_SYMBOL]));
        this.closure_LR(state);
        this._closureForItemsCache[indexVal] = state;
        return state;
    }
    addLinkExpected(item, itemX) {
        let table = this._expectedExtensionDMap;
        let index = item.index;
        table[index] = table[index] || {};
        table[index][itemX.index] = true;
    }
    determineExpected(testState, symbol) {
        const stateNext = testState.nextStates[symbol] || null;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isNull)(stateNext)) {
            return;
        }
        // at this moment all items already 'base' because of
        // deleteNotBase() call before.
        testState.eachBaseItem(baseItem => {
            const state = this.closureForItem(baseItem);
            stateNext.eachBaseItem(baseItemNext => {
                const item = state.hasChildItem(baseItemNext);
                if (item) {
                    item.expectedSymbols.forEach(symbol => {
                        if (symbol === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.UNUSED_SYMBOL) {
                            this.addLinkExpected(baseItem, baseItemNext);
                        }
                        else {
                            baseItemNext.addExpected(symbol);
                        }
                    });
                }
            });
        });
    }
    generateLinksExpected() {
        const states = this._states;
        const symbols = this.symbols();
        states.forEach(state => symbols.forEach(symbol => this.determineExpected(state, symbol)));
    }
    expandExpected() {
        const baseItems = this._baseItems;
        const itemExpected = baseItems.map(item => true);
        const table = this._expectedExtensionDMap;
        baseItems[0].addExpected(_lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL);
        itemExpected[0] = (true);
        let isNewExpected;
        do {
            isNewExpected = false;
            baseItems.forEach((baseItem) => {
                if (itemExpected[baseItem.index] && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isDefAndNotNull)(table[baseItem.index])) {
                    let indexesOfExpectedItems = Object.keys(table[baseItem.index]).map(idx => Number(idx));
                    baseItem.expectedSymbols.forEach(expectedSymbol => {
                        indexesOfExpectedItems.forEach(expectedIndex => {
                            const baseItemExpected = baseItems[expectedIndex];
                            if (baseItemExpected.addExpected(expectedSymbol)) {
                                itemExpected[expectedIndex] = true;
                                isNewExpected = true;
                            }
                        });
                    });
                }
                itemExpected[baseItem.index] = false;
            });
        } while (isNewExpected);
    }
    generateStates(type) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0) {
            this.generateStates_LR0();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR1) {
            this.generateStates_LR();
        }
        else if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LALR) {
            this.generateStates_LALR();
        }
    }
    generateStates_LR0() {
        this.generateFirstState_LR0();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                const symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR0(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR0);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LR() {
        this._firstTerminalsCache = {};
        this.generateFirstState_LR();
        const stateList = this._states;
        const symbols = this.symbols();
        // NOTE: do not change this loop!
        for (let i = 0; i < stateList.length; i++) {
            const state = stateList[i];
            for (let j = 0; j < symbols.length; j++) {
                let symbol = symbols[j];
                let stateNext = AbstractParser.nextState_LR(state, symbol);
                if (!stateNext.isEmpty()) {
                    stateNext = this.tryAddState(stateNext, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EParserType.k_LR1);
                    this.addStateLink(state, stateNext, symbol);
                }
            }
        }
    }
    generateStates_LALR() {
        this._baseItems = [];
        this._expectedExtensionDMap = {};
        this._closureForItemsCache = {};
        this._firstTerminalsCache = {};
        this.generateStates_LR0();
        this.deleteNotBaseItems();
        this.generateLinksExpected();
        this.expandExpected();
        this._states.forEach(state => this.closure_LR(state));
    }
    addReducing(syntaxTable, state, reduceOperationsMap) {
        state.eachItem(item => {
            if (item.symbolName() === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_POSITION) {
                if (item.rule.left === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.START_SYMBOL) {
                    this.pushInSyntaxTable(syntaxTable, state.index, _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_6__.END_SYMBOL, { type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Success });
                }
                else {
                    for (const expectedSymbol of item.expectedSymbols) {
                        this.pushInSyntaxTable(syntaxTable, state.index, expectedSymbol, reduceOperationsMap[item.rule.index]);
                    }
                }
            }
        });
    }
    addShift(syntaxTable, state, shiftOperationsMap) {
        const nextStates = state.nextStates;
        const nextSymbols = Object.keys(nextStates);
        for (let i = 0; i < nextSymbols.length; i++) {
            const nextState = nextStates[nextSymbols[i]];
            this.pushInSyntaxTable(syntaxTable, state.index, nextSymbols[i], shiftOperationsMap[nextState.index]);
        }
    }
    buildSyntaxTable(type) {
        this._states = [];
        this._syntaxTable = {};
        const stateList = this._states;
        const syntaxTable = this._syntaxTable;
        this.generateStates(type);
        const reduceOperationsMap = {};
        const shiftOperationsMap = {};
        stateList.forEach(state => {
            shiftOperationsMap[state.index] = {
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Shift,
                stateIndex: state.index
            };
        });
        const nonTerminals = this.nonTerminals();
        nonTerminals.forEach(nonTerminal => {
            this.rules(nonTerminal).forEach(rule => {
                reduceOperationsMap[rule.index] = {
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Reduce,
                    rule: rule
                };
            });
        });
        //Build syntax table
        stateList.forEach(state => {
            this.addReducing(syntaxTable, state, reduceOperationsMap);
            this.addShift(syntaxTable, state, shiftOperationsMap);
        });
    }
    statesToString(isBaseOnly = true) {
        if (!this._states) {
            return "";
        }
        let msg = "";
        for (let i = 0; i < this._states.length; i++) {
            msg += this._states[i].toString(isBaseOnly, this._grammarSymbols);
            msg += " ";
        }
        return msg;
    }
    static operationToString(operation) {
        let opVal = "";
        switch (operation.type) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Shift:
                opVal = "SHIFT to state " + operation.stateIndex.toString();
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Reduce:
                opVal = "REDUCE by rule { " + AbstractParser.ruleToString(operation.rule) + " }";
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_2__.EOperationType.k_Success:
                opVal = "SUCCESS";
                break;
        }
        return opVal;
    }
    static ruleToString(rule) {
        let ruleVal;
        ruleVal = rule.left + " : " + rule.right.join(" ");
        return ruleVal;
    }
    convertGrammarSymbol(symbol) {
        if (!this.isTerminal(symbol)) {
            return symbol;
        }
        return this.lexerEngine.getTerminalValueByName(symbol);
    }
}
AbstractParser.$parserEngine = null;
AbstractParser.$parserParams = null;


/***/ }),

/***/ "tr/y":
/*!****************************************!*\
  !*** ./src/lib/parser/CachingLexer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CachingLexer": () => (/* binding */ CachingLexer)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");


class CachingLexer {
    constructor(tokens) {
        this.tokens = tokens || [];
        this.pos = 0;
    }
    /**
     * Dummy api
     */
    get document() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    get config() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    setTextDocument(textDocument) { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return this; }
    getNextLine() { (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false); return null; }
    /** end */
    getPosition() {
        return this.pos;
    }
    setPosition(pos) {
        this.pos = pos;
    }
    getDiagnosticReport() {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
        return null;
    }
    getNextToken() {
        return this.tokens[this.pos++] || CachingLexer.END_TOKEN;
    }
}
CachingLexer.END_TOKEN = {
    index: -1,
    name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_SYMBOL,
    value: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_SYMBOL,
    loc: null
};


/***/ }),

/***/ "gO55":
/*!********************************!*\
  !*** ./src/lib/parser/Item.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Item": () => (/* binding */ Item)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");


class Item {
    constructor(rule, pos, expectedSymbols) {
        this.rule = rule;
        this.pos = pos;
        this.index = 0;
        this.expectedSymbols = new Set();
        if (expectedSymbols) {
            expectedSymbols.forEach(symbol => this.addExpected(symbol));
        }
    }
    isEqual(item, type = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR0) {
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR0) {
            return (this.rule === item.rule && this.pos === item.pos);
        }
        if (type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LR1) {
            if (!(this.rule === item.rule && this.pos === item.pos && this.expectedSymbols.size === item.expectedSymbols.size)) {
                return false;
            }
            for (const symbol of this.expectedSymbols) {
                if (!item.isExpected(symbol)) {
                    return false;
                }
            }
            return true;
        }
        //We never must be here, for LALR(1) we work with LR0 items. This 'else'-stmt only for closure-compliler.
        return false;
    }
    isParentItem(item) {
        return (this.rule === item.rule && this.pos === item.pos + 1);
    }
    isChildItem(item) {
        return (this.rule === item.rule && this.pos === item.pos - 1);
    }
    symbolName() {
        const right = this.rule.right;
        if (this.pos === right.length) {
            return _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_1__.END_POSITION;
        }
        return right[this.pos];
    }
    // lastSymbolName(): string {
    //     return this.rule.right[this.rule.right.length - 1] || T_EMPTY;
    // }
    // // get next symbol name
    // nextSymbolName(): string {
    //     return this.rule.right[this.pos + 1] || END_POSITION;
    // }
    isExpected(symbol) {
        return this.expectedSymbols.has(symbol);
    }
    addExpected(symbol) {
        if (this.isExpected(symbol)) {
            return false;
        }
        this.expectedSymbols.add(symbol);
        return true;
    }
    toString(grammarSymbols = null) {
        const { left, right } = this.rule;
        let msg = `${left} -> `;
        msg += right
            .map(s => Item.decodeSymbol(s, grammarSymbols))
            .map((s, k) => (k === this.pos ? `. ${s}` : `${s}`))
            .join(' ');
        if (this.pos === right.length) {
            msg += " . ";
        }
        if (this.expectedSymbols) {
            const expectedTokens = Array.from(this.expectedSymbols).map(k => Item.decodeSymbol(k, grammarSymbols));
            if (expectedTokens.length) {
                msg += ", " + expectedTokens.join(' ');
            }
        }
        return msg;
    }
    static decodeSymbol(s, grammarSymbols) {
        return (grammarSymbols ? ((grammarSymbols.get(s) && s !== grammarSymbols.get(s)) ? `'${grammarSymbols.get(s)}'` : s) : s);
    }
}


/***/ }),

/***/ "sesj":
/*!*********************************!*\
  !*** ./src/lib/parser/Lexer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lexer": () => (/* binding */ Lexer),
/* harmony export */   "LexerEngine": () => (/* binding */ LexerEngine)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");





var ELexerErrors;
(function (ELexerErrors) {
    ELexerErrors[ELexerErrors["UnknownToken"] = 2101] = "UnknownToken";
    ELexerErrors[ELexerErrors["InvalidToken"] = 2102] = "InvalidToken";
})(ELexerErrors || (ELexerErrors = {}));
;
class LexerDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics {
    constructor() {
        super("Lexer Diagnostics", 'L');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        return desc.token.loc;
    }
    diagnosticMessages() {
        return {
            [ELexerErrors.UnknownToken]: "Unknown token: {token.value}.",
            [ELexerErrors.InvalidToken]: "Invalid token: {token.value}."
        };
    }
}
class LexerEngine {
    constructor() {
        this.keywords = {};
        this.punctuators = {};
        this.punctuatorsFirstSymbols = {};
    }
    addPunctuator(value, name = LexerEngine.getPunctuatorName(value)) {
        this.punctuators[value] = name;
        this.punctuatorsFirstSymbols[value[0]] = true;
        return name;
    }
    addKeyword(value, name) {
        this.keywords[value] = name;
        return name;
    }
    getTerminalValueByName(name) {
        let value = "";
        for (value in this.punctuators) {
            if (this.punctuators[value] === name) {
                return value;
            }
        }
        for (value in this.keywords) {
            if (this.keywords[value] === name) {
                return value;
            }
        }
        return name;
    }
    isLineTerminator(symbol) {
        return (symbol === "\n" || symbol === "\r" || symbol === "\u2028" || symbol === "\u2029");
    }
    isKeyword(value) {
        return !!(this.keywords[value]);
    }
    isPunctuator(value) {
        return !!(this.punctuators[value]);
    }
    isNumberStart(ch, ch1) {
        if ((ch >= "0") && (ch <= "9")) {
            return true;
        }
        if (ch === "." && (ch1 >= "0") && (ch1 <= "9")) {
            return true;
        }
        return false;
    }
    isCommentStart(ch, ch1) {
        if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
            return true;
        }
        return false;
    }
    isStringStart(ch) {
        if (ch === "\"" || ch === "'") {
            return true;
        }
        return false;
    }
    isPunctuatorStart(ch) {
        if (this.punctuatorsFirstSymbols[ch]) {
            return true;
        }
        return false;
    }
    isWhiteSpaceStart(ch) {
        if (ch === " " || ch === "\t") {
            return true;
        }
        return false;
    }
    isNewlineStart(ch) {
        if (ch === "\n" || ch === "\r") {
            return true;
        }
        return false;
    }
    isEscapeSequenceStart(ch) {
        return ch === '\\';
    }
    isIdentifierStart(ch) {
        if ((ch === "_") || (ch === "$") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
            return true;
        }
        return false;
    }
    static getPunctuatorName(value) {
        return "T_PUNCTUATOR_" + value.charCodeAt(0);
    }
}
class Lexer {
    constructor({ engine = new LexerEngine, knownTypes = new Set(), skipComments = true, allowLineTerminators = false, } = {}) {
        this.diagnostics = new LexerDiagnostics;
        this.knownTypes = knownTypes;
        this.engine = engine;
        this.config = { skipComments, allowLineTerminators };
    }
    getPosition() {
        return this.pos();
    }
    setPosition(pos) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.document.uri === pos.file);
        this.index = pos.offset;
        this.lineNumber = pos.line;
        this.columnNumber = pos.column;
    }
    setTextDocument(textDocument) {
        this.columnNumber = 0;
        this.lineNumber = 0;
        this.index = 0;
        this.document = textDocument;
        return this;
    }
    getDiagnosticReport() {
        return this.diagnostics.resolve();
    }
    getNextToken() {
        const token = this.scanToken();
        _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__.offset(token.loc, this.document.offset);
        return token;
    }
    getNextLine() {
        const token = this.scanThisLine();
        _lib_parser_util__WEBPACK_IMPORTED_MODULE_3__.offset(token.loc, this.document.offset);
        return token;
    }
    scanToken() {
        const ch = this.currentChar();
        if (!ch) {
            const pos = this.pos();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.END_SYMBOL,
                value: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.END_SYMBOL,
                loc: {
                    start: pos,
                    end: { ...pos }
                }
            };
        }
        switch (this.identityTokenType()) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral:
                return this.scanNumber();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral:
                if (this.config.skipComments) {
                    this.scanComment();
                    return this.scanToken();
                }
                return this.scanComment();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral:
                return this.scanString();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_PunctuatorLiteral:
                return this.scanPunctuator();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral:
                return this.scanIdentifier();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_EscapeSequence:
                return this.scanEscapeSequence();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NewlineLiteral:
                if (!this.config.allowLineTerminators) {
                    this.scanLineTerminators();
                    return this.scanToken();
                }
                return this.scanLineTerminators();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_WhitespaceLiteral:
                this.scanWhiteSpace();
                return this.scanToken();
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.K_MacroLiteral:
                return this.scanMacro();
            default:
                return this.scanInvalid();
        }
    }
    scanThisLine() {
        let start = this.pos();
        let value = '';
        let ch = this.currentChar();
        while (ch) {
            if (ch === '\\') {
                let chNext = this.readNextChar();
                if (chNext === '\r') {
                    chNext = this.readNextChar();
                }
                switch (chNext) {
                    case '\n':
                        ch = this.readNextChar();
                        this.lineNumber++;
                        this.columnNumber = 0;
                        value += '\\\n';
                        continue;
                    case 'n':
                        ch = '\n';
                        break;
                    case 't':
                        ch = '\t';
                        break;
                    default:
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, 'unsupported character sequence found');
                }
            }
            else if (ch === '\n') {
                break;
            }
            value += ch;
            ch = this.readNextChar();
        }
        return {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value,
            loc: { start, end: this.pos() }
        };
    }
    pos(n = 0) {
        return {
            file: this.document.uri,
            line: this.lineNumber,
            column: this.columnNumber + n,
            offset: this.index + n
        };
    }
    emitError(code, token) {
        this.diagnostics.error(code, { file: `${this.document.uri}`, token });
    }
    identityTokenType() {
        if (this.isIdentifierStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral;
        }
        if (this.isWhiteSpaceStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_WhitespaceLiteral;
        }
        if (this.isNewlineStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NewlineLiteral;
        }
        if (this.isEscapeSequenceStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_EscapeSequence;
        }
        if (this.isStringStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral;
        }
        if (this.isCommentStart()) {
            // TODO: return exact type (separate multiline/singleline comment parsings)
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral;
        }
        if (this.isNumberStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral;
        }
        if (this.isPunctuatorStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_PunctuatorLiteral;
        }
        if (this.isMacroStart()) {
            return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.K_MacroLiteral;
        }
        return _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_Unknown;
    }
    isNumberStart() {
        return this.engine.isNumberStart(this.currentChar(), this.nextChar());
    }
    isCommentStart() {
        return this.engine.isCommentStart(this.currentChar(), this.nextChar());
    }
    isStringStart() {
        return this.engine.isStringStart(this.currentChar());
    }
    isPunctuatorStart() {
        return this.engine.isPunctuatorStart(this.currentChar());
    }
    isWhiteSpaceStart() {
        return this.engine.isWhiteSpaceStart(this.currentChar());
    }
    isNewlineStart() {
        return this.engine.isNewlineStart(this.currentChar());
    }
    isEscapeSequenceStart() {
        return this.engine.isEscapeSequenceStart(this.currentChar());
    }
    isMacroStart() {
        return this.currentChar() === '#';
    }
    isIdentifierStart() {
        return this.engine.isIdentifierStart(this.currentChar());
    }
    nextChar() {
        return this.document.source[this.index + 1];
    }
    currentChar() {
        return this.document.source[this.index];
    }
    readNextChar() {
        this.index++;
        this.columnNumber++;
        return this.document.source[this.index];
    }
    scanEscapeSequence() {
        let ch = this.readNextChar();
        if (ch === '\r') {
            ch = this.readNextChar();
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(ch === '\n', 'unsupported escape sequence found');
        this.lineNumber++;
        this.columnNumber = 0;
        this.readNextChar();
        return this.scanToken();
    }
    scanString() {
        let chFirst = this.currentChar();
        let value = chFirst;
        let ch = "";
        let chPrevious = chFirst;
        let isGoodFinish = false;
        let start = this.pos();
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                break;
            }
            value += ch;
            if (ch === chFirst && chPrevious !== "\\") {
                isGoodFinish = true;
                this.readNextChar();
                break;
            }
            chPrevious = ch;
        }
        if (isGoodFinish) {
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_STRING,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_StringLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanInvalid() {
        const start = this.pos();
        let value = '';
        while (this.identityTokenType() === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_Unknown && this.index < this.document.source.length) {
            value += this.currentChar();
            this.readNextChar();
        }
        const token = {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value,
            loc: { start, end: this.pos() }
        };
        this.emitError(ELexerErrors.UnknownToken, token);
        return token;
    }
    scanPunctuator() {
        let value = this.currentChar();
        let start = this.pos();
        let ch;
        while (true) {
            ch = this.readNextChar();
            if (ch) {
                value += ch;
                if (!this.engine.isPunctuator(value)) {
                    value = value.slice(0, value.length - 1);
                    break;
                }
            }
            else {
                break;
            }
        }
        return {
            index: this.index,
            name: this.engine.punctuators[value],
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanNumber() {
        let ch = this.currentChar();
        let value = "";
        let isFloat = false;
        let isHex = false;
        let isL = false;
        let chPrevious = ch;
        let isGoodFinish = false;
        let isE = false; // exponential
        let isU = false; // unsigned
        let start = this.pos();
        if (ch === ".") {
            value += 0;
            isFloat = true;
        }
        value += ch;
        while (true) {
            ch = this.readNextChar();
            if (ch === ".") {
                if (isFloat || isU || isL || isHex) {
                    break;
                }
                isFloat = true;
            }
            else if (ch === "e") {
                if (isE || isU || isL) { // "0x100e2" is valid
                    break;
                }
                isE = true;
            }
            else if (ch === "u" || ch === "U") {
                if (isFloat || isU) { // "0x02u" or "0x100e2u" are valid
                    break;
                }
                isU = true;
            }
            else if (ch === "l" || ch === "L") {
                if (isFloat || isL) {
                    break;
                }
                isL = true;
            }
            else if (ch === "x") {
                if (isU || isL || isE || isFloat) {
                    break;
                }
                isHex = true;
            }
            else if (((ch === "+" || ch === "-") && chPrevious === "e")) {
                // nothing todo, valid case
            }
            else if (ch === "f" && (isFloat || isE)) {
                isFloat = true;
                ch = this.readNextChar();
                // redundant check?
                if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                    break;
                }
                isGoodFinish = true;
                break;
            }
            // break on any unused alphabetic character
            else if ((ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                if (!isHex) {
                    break;
                }
            }
            // Handle the case when a character is read not a number (end of numeric seq.)
            else if (!((ch >= "0") && (ch <= "9")) || !ch || isU || isL) {
                // check that the exponent completely read
                if ((isE && chPrevious !== "+" && chPrevious !== "-" && chPrevious !== "e") || !isE) {
                    isGoodFinish = true;
                }
                break;
            }
            value += ch;
            chPrevious = ch;
        }
        if (isGoodFinish) {
            let name = isFloat ? _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_FLOAT : _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_UINT;
            return {
                index: this.index,
                name,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_NumericLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanMacro() {
        // TODO: add option config.allowMacro 
        const start = this.pos();
        const chNext = this.nextChar();
        if ((chNext >= "a" && chNext <= "z") || (chNext >= "A" && chNext <= "Z")) {
            this.readNextChar();
            const id = this.scanIdentifier();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_MACRO,
                value: `#${id.value}`,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else if (chNext === '#') {
            this.readNextChar();
            this.readNextChar();
            return {
                index: this.index,
                name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_MACRO_CONCAT,
                value: '##',
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `unsupported macro found: ${this.document.source.substr(this.index, 20)}...`);
        this.readNextChar();
        return {
            index: this.index,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            value: '#',
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanIdentifier() {
        let ch = this.currentChar();
        let value = ch;
        let start = this.pos();
        let isGoodFinish = false;
        while (true) {
            ch = this.readNextChar();
            if (!ch) {
                isGoodFinish = true;
                break;
            }
            if (!((ch === "_") || (ch === "$") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") || (ch >= "0" && ch <= "9"))) {
                isGoodFinish = true;
                break;
            }
            value += ch;
        }
        if (isGoodFinish) {
            if (this.engine.isKeyword(value)) {
                return {
                    index: this.index,
                    name: this.engine.keywords[value],
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                let name = this.knownTypes.has(value) ? _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_TYPE_ID : _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_NON_TYPE_ID;
                return {
                    index: this.index,
                    name,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
        }
        else {
            if (!ch) {
                ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
            }
            value += ch;
            const token = {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_IdentifierLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
            this.emitError(ELexerErrors.InvalidToken, token);
            return Lexer.makeUnknownToken(token);
        }
    }
    scanLineTerminators() {
        let ch = this.currentChar();
        let value = '';
        let start = this.pos();
        while (true) {
            if (!ch) {
                break;
            }
            if (this.engine.isLineTerminator(ch)) {
                value += ch;
                if (ch === "\r" && this.nextChar() === "\n") {
                    this.lineNumber--;
                }
                this.lineNumber++;
                ch = this.readNextChar();
                this.columnNumber = 0;
                continue;
            }
            break;
        }
        let name = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.T_LINE_TERMINATOR;
        return {
            index: this.index,
            name,
            value,
            loc: {
                start,
                end: this.pos()
            }
        };
    }
    scanWhiteSpace() {
        let ch = this.currentChar();
        while (true) {
            if (!ch) {
                break;
            }
            else if (ch === "\t") {
                // possible way to convert tab to multiple spaces
                this.columnNumber += 0;
            }
            else if (ch !== " ") {
                break;
            }
            ch = this.readNextChar();
        }
        return true;
    }
    scanComment() {
        let value = this.currentChar();
        let ch = this.readNextChar();
        let start = this.pos();
        value += ch;
        if (ch === "/") {
            //Line Comment
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.readNextChar();
                    this.columnNumber = 0;
                    break;
                }
                value += ch;
            }
            return {
                index: this.index,
                type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_SinglelineCommentLiteral,
                value,
                loc: {
                    start,
                    end: this.pos()
                }
            };
        }
        else {
            //Multiline Comment
            let chPrevious = ch;
            let isGoodFinish = false;
            let start = this.pos();
            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                value += ch;
                if (ch === "/" && chPrevious === "*") {
                    isGoodFinish = true;
                    this.readNextChar();
                    break;
                }
                if (this.engine.isLineTerminator(ch)) {
                    if (ch === "\r" && this.nextChar() === "\n") {
                        this.lineNumber--;
                    }
                    this.lineNumber++;
                    this.columnNumber = -1;
                }
                chPrevious = ch;
            }
            if (isGoodFinish) {
                return {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
            }
            else {
                if (!ch) {
                    ch = _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.EOF;
                }
                value += ch;
                const token = {
                    index: this.index,
                    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ETokenType.k_MultilineCommentLiteral,
                    value,
                    loc: {
                        start,
                        end: this.pos()
                    }
                };
                this.emitError(ELexerErrors.InvalidToken, token);
                return Lexer.makeUnknownToken(token);
            }
        }
    }
    /** @deprecated */
    static makeUnknownToken(token) {
        return {
            ...token,
            type: undefined,
            name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_2__.UNKNOWN_TOKEN,
            loc: {
                start: { ...token.loc.start },
                end: { ...token.loc.end }
            }
        };
    }
}


/***/ }),

/***/ "wlKN":
/*!**********************************!*\
  !*** ./src/lib/parser/Macros.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Macros": () => (/* binding */ Macros)
/* harmony export */ });
class Macros {
    constructor() {
        this.stack = [{ root: null, macros: {} }];
    }
    get depth() {
        return this.stack.length;
    }
    get root() {
        return this.stack[this.depth - 1].root;
    }
    push(source) {
        this.stack.push({ root: source, macros: {} });
    }
    pop() {
        this.stack.pop();
    }
    set(macro) {
        this.stack[this.depth - 1].macros[macro.name] = macro;
    }
    unset(name) {
        delete this.stack[this.depth - 1].macros[name];
    }
    get(name) {
        let i = this.depth - 1;
        while (true) {
            const { macros, root } = this.stack[i];
            // avoidance of recursive substitution
            if (root?.name === name && !root.bFunction) {
                return null;
            }
            const macro = macros[name];
            if (macro) {
                return macro;
            }
            if (i == 0)
                break;
            i = 0;
        }
        ;
        return null;
    }
    has(name) {
        return this.get(name) !== null;
    }
    forEach(cb) {
        let overrides = new Set;
        for (let i = this.depth - 1; i >= 0; --i) {
            const macros = this.stack[i].macros;
            for (const macro of Object.values(macros)) {
                if (!overrides.has(macro.name)) {
                    overrides.add(macro.name);
                    cb(macro);
                }
            }
        }
    }
    *[Symbol.iterator]() {
        let overrides = new Set;
        for (let i = this.depth - 1; i >= 0; --i) {
            const macros = this.stack[i].macros;
            for (const macro of Object.values(macros)) {
                if (!overrides.has(macro.name)) {
                    overrides.add(macro.name);
                    yield macro;
                }
            }
        }
    }
}


/***/ }),

/***/ "Eumm":
/*!*************************************!*\
  !*** ./src/lib/parser/ParseTree.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParseTree": () => (/* binding */ ParseTree)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "5ZRz");



class ParseTree {
    constructor(optimized, root = null) {
        this.root = root;
        this.nodes = [];
        this.optimized = optimized;
        this.nodesCountStack = [];
    }
    get lastNode() {
        return this.nodes[this.nodes.length - 1];
    }
    finishTree() {
        this.root = this.nodes.pop() || null;
    }
    addToken({ name, value, loc }) {
        const children = null;
        const parent = null;
        this.addNode({ name, value, loc, children, parent });
    }
    reduceByRule(rule, eCreate = _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Default) {
        let iReduceCount = 0;
        let nodesCountStack = this.nodesCountStack;
        let ruleLength = rule.right.length;
        let nodes = this.nodes;
        let optimize = this.optimized ? 1 : 0;
        while (ruleLength) {
            iReduceCount += nodesCountStack.pop();
            ruleLength--;
        }
        if ((eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Skip && iReduceCount > optimize) || iReduceCount === 0) {
            nodes.length -= iReduceCount;
            nodesCountStack.push(0);
        }
        else if ((eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Default && iReduceCount > optimize) ||
            (eCreate === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.ENodeCreateMode.k_Necessary)) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(iReduceCount > 0);
            let temp = nodes.pop();
            iReduceCount--;
            const name = rule.left;
            // TODO: use correct location in case of include macro. 
            const loc = { ...temp.loc };
            const node = { name, children: null, parent: null, value: '', loc };
            this.addLink(node, temp);
            while (iReduceCount) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(nodes.length > 0);
                this.addLink(node, nodes.pop());
                iReduceCount--;
            }
            nodes.push(node);
            nodesCountStack.push(1);
        }
        else {
            nodesCountStack.push(iReduceCount);
        }
    }
    addNode(node) {
        this.nodes.push(node);
        this.nodesCountStack.push(1);
    }
    $pop(loc = null) {
        let count = this.nodesCountStack.pop();
        while (count) {
            let node = this.nodes.pop();
            if (loc) {
                (0,_util__WEBPACK_IMPORTED_MODULE_2__.extendRange)(loc, node.loc);
            }
            count--;
        }
    }
    addLink(parent, child) {
        parent.children = parent.children || [];
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.extendRange)(parent.loc, child.loc);
        parent.children.push(child);
        child.parent = parent;
    }
    /** @deprecated */
    clone() {
        return new ParseTree(this.optimized, this.cloneNode(this.root));
    }
    /** @deprecated */
    // FIXME: location should be clonned too
    cloneNode({ name, value, children }) {
        const clone = { name, value, children: null, parent: null };
        if (children) {
            children.forEach(child => this.addLink(clone, this.cloneNode(child)));
        }
        return clone;
    }
    /** @deprecated */
    toString() {
        if (this.root) {
            return this.toStringNode(this.root);
        }
        return '';
    }
    /** @deprecated */
    toStringNode(node, padding = "") {
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "name : \"" + node.name + "\"" + ",\n";
            res += padding + "value : \"" + node.value + "\"" + "\n";
        }
        else {
            res += padding + "name : \"" + node.name + "\"" + "\n";
            res += padding + "children : [";
            let children = node.children;
            if (children) {
                res += "\n";
                padding += defaultPadding;
                for (let i = children.length - 1; i >= 0; i--) {
                    res += this.toStringNode(children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
    /** @deprecated */
    toHTMLString(node, padding = "") {
        node = node || this.root;
        let res = padding + "{\n";
        let oldPadding = padding;
        let defaultPadding = "  ";
        padding += defaultPadding;
        if (node.value) {
            res += padding + "<b style=\"color: #458383;\">name</b>: \"" + node.name + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">value</b>: \"" + node.value + "\"" + ",\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
        }
        else {
            let i;
            res += padding + "<i style=\"color: #8A2BE2;\">name</i>: \"" + node.name + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">line</b>: \"" + node.loc.start.line + "\" - \"" + node.loc.end.line + "\"" + "\n";
            res += padding + "<b style=\"color: #458383;\">column</b>: \"" + node.loc.start.column + "\" - \"" + node.loc.end.column + "\"" + "\n";
            // sRes += sPadding + "<b style=\"color: #458383;\">position</b>: \"" + pNode.position + "\"" + "\n";
            res += padding + "<i style=\"color: #8A2BE2;\">children</i>: [";
            if (node.children) {
                res += "\n";
                padding += defaultPadding;
                for (i = node.children.length - 1; i >= 0; i--) {
                    res += this.toHTMLString(node.children[i], padding);
                    res += ",\n";
                }
                res = res.slice(0, res.length - 2);
                res += "\n";
                res += oldPadding + defaultPadding + "]\n";
            }
            else {
                res += " ]\n";
            }
        }
        res += oldPadding + "}";
        return res;
    }
}


/***/ }),

/***/ "nYIV":
/*!****************************************!*\
  !*** ./src/lib/parser/Preprocessor.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPreprocessorErrors": () => (/* binding */ EPreprocessorErrors),
/* harmony export */   "EPreprocessorWarnings": () => (/* binding */ EPreprocessorWarnings),
/* harmony export */   "Preprocessor": () => (/* binding */ Preprocessor),
/* harmony export */   "PreprocessorDiagnostics": () => (/* binding */ PreprocessorDiagnostics),
/* harmony export */   "createPPDocument": () => (/* binding */ createPPDocument)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/SLParser */ "/oCY");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_parser_CachingLexer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/parser/CachingLexer */ "tr/y");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_Macros__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/parser/Macros */ "wlKN");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");













let DEBUG_MACRO = false;
var EMacroState;
(function (EMacroState) {
    EMacroState[EMacroState["k_AllowElse"] = 0] = "k_AllowElse";
    EMacroState[EMacroState["k_ForbidElse"] = 1] = "k_ForbidElse";
})(EMacroState || (EMacroState = {}));
;
var EPreprocessorErrors;
(function (EPreprocessorErrors) {
    EPreprocessorErrors[EPreprocessorErrors["SyntaxUnknownError"] = 7051] = "SyntaxUnknownError";
    EPreprocessorErrors[EPreprocessorErrors["GeneralCouldNotReadFile"] = 7200] = "GeneralCouldNotReadFile";
    EPreprocessorErrors[EPreprocessorErrors["MacroUnknownError"] = 7201] = "MacroUnknownError";
})(EPreprocessorErrors || (EPreprocessorErrors = {}));
;
var EPreprocessorWarnings;
(function (EPreprocessorWarnings) {
    EPreprocessorWarnings[EPreprocessorWarnings["MacroUnknownWarning"] = 3000] = "MacroUnknownWarning";
})(EPreprocessorWarnings || (EPreprocessorWarnings = {}));
class PreprocessorDiagnostics extends _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics {
    constructor() {
        super("Preprocessor diagnostics", 'M');
    }
    resolveFilename(category, code, desc) {
        return desc.file;
    }
    resolveRange(category, code, desc) {
        if (category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            switch (code) {
                case EPreprocessorWarnings.MacroUnknownWarning:
                    return desc.loc;
            }
        }
        //
        // errors
        //
        switch (code) {
            case EPreprocessorErrors.SyntaxUnknownError:
                return desc.token.loc;
            case EPreprocessorErrors.GeneralCouldNotReadFile:
                return desc.loc;
            case EPreprocessorErrors.MacroUnknownError:
                return desc.loc;
        }
        return null;
    }
    diagnosticMessages() {
        return {
            [EPreprocessorErrors.SyntaxUnknownError]: "Syntax error during parsing. Token: '{token.value}'\n" +
                "Line: {token.loc.start.line}. Column: {token.loc.start.column}.",
            [EPreprocessorErrors.GeneralCouldNotReadFile]: "Could not read file '{target}'.",
        };
    }
    resolveDescription(code, category, desc) {
        let descList = this.diagnosticMessages();
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(descList[code])) {
            return super.resolveDescription(code, category, desc);
        }
        let { file, loc, ...data } = desc;
        if (category == _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_3__.EDiagnosticCategory.k_Warning) {
            return `${EPreprocessorWarnings[code]}: ${JSON.stringify(data)}`;
        }
        return `${EPreprocessorErrors[code]}: ${JSON.stringify(data)}`;
    }
}
// as macro token
/** @deprecated */
function createMacroToken(value, loc) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(value), value);
    return { index: -1, type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__.ETokenType.k_Unknown, name: _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO, value, loc };
}
function asMacroFunc(fn) {
    return {
        op: (...args) => {
            const value = String(fn(...args));
            const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(...args.map(arg => arg.loc));
            // TODO: use typed token like: T_BOOL, T_UINT etc.
            return createMacroToken(value, loc);
        },
        length: fn.length
    };
}
function tokenToNative(token, fallback = () => NaN) {
    const value = token.value;
    if (String(value) === 'true') {
        return 1;
    }
    if (String(value) === 'false') {
        return 0;
    }
    // TODO: replace this check
    if (String(Number(value)) === String(value)) {
        return Number(value);
    }
    return fallback(token);
}
class MacroState {
    constructor() {
        this.states = [];
    }
    is(state) {
        return this.states[this.states.length - 1] === state;
    }
    isEmpty() {
        return this.states.length === 0;
    }
    push(state) {
        this.states.push(state);
    }
    pop() {
        return this.states.pop();
    }
    replace(state) {
        this.pop();
        this.push(state);
    }
}
var EPPDocumentFlags;
(function (EPPDocumentFlags) {
    EPPDocumentFlags[EPPDocumentFlags["k_None"] = 0] = "k_None";
    EPPDocumentFlags[EPPDocumentFlags["k_Macro"] = 1] = "k_Macro";
    EPPDocumentFlags[EPPDocumentFlags["k_Include"] = 2] = "k_Include";
})(EPPDocumentFlags || (EPPDocumentFlags = {}));
class Preprocessor {
    constructor(lexerEngine, { knownTypes = new Set(), macros = new _lib_parser_Macros__WEBPACK_IMPORTED_MODULE_10__.Macros, diag = new PreprocessorDiagnostics, skipComments = true, includeResolver = null, defines = null } = {}) {
        this.macros = macros;
        if (defines) {
            // set as boolean macro
            defines
                .forEach(({ name }) => this.macros.set({ name, tokens: [], bFunction: false, params: null, bRegionExpr: false }));
        }
        this.macroState = new MacroState;
        this.includeMap = new Map;
        this.unreachableCodeList = [];
        this.unresolvedMacros = [];
        this.knownTypes = knownTypes;
        this.lexerEngine = lexerEngine;
        this.diagnostics = diag;
        this.includeResolver = includeResolver;
        this.lexerReport = null;
        this.lexerOptions = { skipComments };
        // TODO: add initital document to includeList !!!
        this.stack = [];
        this.includes = [];
    }
    get lexer() {
        return this.stack[this.stack.length - 1].lexer;
    }
    get tokens() {
        return this.stack[this.stack.length - 1].tokens;
    }
    get uri() {
        return this.document.uri;
    }
    /** Current location stack (each location contains ".source" property inside.) */
    // get location(): IRange {
    //     return this.stack[this.stack.length - 1].loc;
    // }
    /** Top location of the macro if presented or null otherwise. */
    macroLocation() {
        // return first macro location in the current document
        const latestInclude = this.includes[this.includes.length - 1];
        if (latestInclude < this.stack.length - 1) {
            return this.stack[latestInclude + 1].loc;
        }
        // return null (we are alrady in the current document)
        return null;
    }
    currentMacro() {
        return this.macros.root;
    }
    getDiagnosticReport() {
        return _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics.mergeReports([this.lexerReport, this.diagnostics.resolve()]);
    }
    readLine() {
        return this.lexer.getNextLine();
    }
    setTextDocument(textDocument) {
        this.document = textDocument;
        this.pushDocument(this.documentToLexer(textDocument), null, EPPDocumentFlags.k_Include);
        return this;
    }
    pushDocument(lexer, loc, flags, macro = null) {
        const tokens = [];
        /// link location into chain
        // if (loc) {
        //     loc.source = this.stack[this.stack.length - 1].loc;
        // }
        if (flags & EPPDocumentFlags.k_Macro) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(macro));
            this.macros.push(macro);
        }
        if (flags & EPPDocumentFlags.k_Include) {
            this.includes.push(this.stack.length);
            // assert(!this.includeMap.has(`${textDocument.uri}`));
            this.includeMap.set(`${lexer.document.uri}`, loc);
        }
        this.stack.push({ lexer, tokens, flags, loc });
    }
    pop() {
        const { flags, lexer } = this.stack.pop();
        // FIXME: do not Lexer type
        const diag = lexer.diagnostics;
        if (diag && !diag.isEmpty()) {
            this.lexerReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_7__.Diagnostics.mergeReports([this.lexerReport, lexer.getDiagnosticReport()]);
        }
        if (flags & EPPDocumentFlags.k_Macro) {
            this.macros.pop();
        }
        if (flags & EPPDocumentFlags.k_Include) {
            this.includes.pop();
        }
    }
    pushToken(...tokens) {
        this.tokens.push(...tokens);
    }
    popToken() {
        return this.tokens.shift() || null;
    }
    async readToken(allowMacro = true, allowStateChanging = true) {
        const token = this.popToken() || this.lexer.getNextToken();
        switch (token.name) {
            case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO:
                if (allowMacro) {
                    return this.readMacro(token);
                }
                break;
            case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL:
                if (allowStateChanging) {
                    if (this.stack.length > 1) {
                        this.pop();
                        return this.readToken(allowMacro);
                    }
                    if (!this.macroState.isEmpty()) {
                        // TODO: highlight open tag too.
                        this.emitMacroError(`'endif' not found :/`, token.loc);
                    }
                }
                break;
            default:
                if (allowMacro) {
                    return this.examMacro(token);
                }
        }
        return token;
    }
    async readMacro(token) {
        switch (token.value) {
            case '#define': return this.processDefineMacro(token);
            case '#ifdef': return this.processIfdefMacro(token);
            case '#ifndef': return this.processIfndefMacro(token);
            case '#endif': return this.processEndifMacro(token);
            case '#else': return this.processElseMacro(token);
            case '#elif': return this.processElifMacro(token);
            case '#if': return this.processIfMacro(token);
            case '#error': return this.processErrorMacro(token);
            case '#include': return this.processIncludeMacro(token);
            case '#undef': return this.processUndefMacro(token);
            case '#pragma': {
                this.readLine();
                return this.readToken();
            }
        }
        this.emitMacroWarning(`unsupported macro type found: ${token.value}`, token.loc);
        return this.readToken();
    }
    async processUndefMacro(token) {
        const name = await this.readToken(false);
        const text = this.readLine();
        if (name.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
            // TODO: emit error
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(name.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID);
            return this.readToken();
        }
        if (!this.macros.has(name.value)) {
            this.emitMacroWarning(`target macro not found: ${name.value}`, name.loc);
        }
        else {
            this.macros.unset(name.value);
        }
        return this.readToken();
    }
    async processDefineMacro(token) {
        const name = await this.readToken(false);
        const text = this.readLine();
        if (name.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
            // TODO: emit error
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(name.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID);
            return this.readToken();
        }
        if (this.macros.has(name.value)) {
            this.emitMacroWarning(`macro redefinition found: ${name.value}`, name.loc);
        }
        const macro = await this.processMacro(name, text);
        if (macro) {
            const unresolvedMacro = this.unresolvedMacros.find(macro => macro.name === name.value);
            if (unresolvedMacro) {
                macro.bRegionExpr = unresolvedMacro.bRegionExpr;
                // TODO: remove this hack
                this.unresolvedMacros = this.unresolvedMacros.filter(macro => macro.name !== name.value);
            }
            this.macros.set(macro);
        }
        return this.readToken();
    }
    async processMacro(name, lineToken) {
        let bFunction = false;
        let bRegionExpr = false;
        let params = null;
        let tokens = [];
        if (!/^\s*$/.test(lineToken.value)) {
            //
            // process macro params
            //
            const lexer = await this.tokenToLexer(lineToken);
            let token = lexer.getNextToken();
            const bOpenBracket = token.value === '(';
            const bSameLine = token.loc.start.line === name.loc.end.line;
            const bNoSpace = token.loc.start.column === name.loc.end.column;
            // A bit tricky way to separate macro like:
            // >  #define NAME(A, B)
            // from the macro:
            // >  #define NAME (A, B)
            // and macro like:
            // >  #define NAME\
            // >              (A, B)
            // note: only macro like 'NAME(a, b)' is a valid function-like macro (no spaces allowed)
            if (bOpenBracket && bSameLine && bNoSpace) {
                params = [];
                bFunction = true;
                let bExpectComma = false;
                token = lexer.getNextToken();
                while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL && token.value !== ')') {
                    if (bExpectComma) {
                        if (token.value !== ',') {
                            this.emitMacroError(`invalid macro, comma expected`, token.loc);
                            return null;
                        }
                    }
                    else {
                        if (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID) {
                            this.emitMacroError('invalid token found. only identifiers allowed as param names', token.loc);
                            return null;
                        }
                        params.push(token.value);
                    }
                    bExpectComma = !bExpectComma;
                    token = lexer.getNextToken();
                }
                if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
                    this.emitMacroError(`comma mismatch`, token.loc);
                    return null;
                }
                token = lexer.getNextToken();
            }
            while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
                tokens.push(token);
                token = lexer.getNextToken();
            }
        }
        tokens.forEach(t => { t.synthetic = true; });
        return { name: name.value, tokens, bFunction, params, bRegionExpr };
    }
    async processIfdefMacro(token) {
        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));
        if (exprValue) {
            this.macroState.push(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        this.macroState.push(EMacroState.k_AllowElse);
        return this.skipUnreachableCode(token);
    }
    async processIfndefMacro(token) {
        const exprValue = this.resolveDefMacro(await this.lineToLexer(this.readLine()));
        if (exprValue) {
            this.macroState.push(EMacroState.k_AllowElse);
            return this.skipUnreachableCode(token);
        }
        this.macroState.push(EMacroState.k_ForbidElse);
        return this.readToken();
    }
    async processIfMacro(token) {
        if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {
            this.macroState.push(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        this.macroState.push(EMacroState.k_AllowElse);
        return this.skipUnreachableCode(token);
    }
    async processElifMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        if (this.macroState.is(EMacroState.k_AllowElse)) {
            if (this.resolveMacroInner(await this.lineToLexer(this.readLine()))) {
                this.macroState.replace(EMacroState.k_ForbidElse);
                return this.readToken();
            }
        }
        return this.skipUnreachableCode(token);
    }
    async processElseMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        if (this.macroState.is(EMacroState.k_AllowElse)) {
            this.macroState.replace(EMacroState.k_ForbidElse);
            return this.readToken();
        }
        return this.skipUnreachableCode(token);
    }
    async processEndifMacro(token) {
        if (!this.macroState.is(EMacroState.k_AllowElse) && !this.macroState.is(EMacroState.k_ForbidElse)) {
            this.emitMacroError(`inappropriate control instruction found`, token.loc);
            return this.readToken();
        }
        this.macroState.pop();
        return this.readToken();
    }
    resolveDefMacro(lexer) {
        const macros = this.macros;
        const asRaw = (token) => tokenToNative(token, ({ value }) => {
            const macro = macros.get(value);
            if (macro) {
                // mark macro as a part of ifdef/else expression
                macro.bRegionExpr = true;
                return 1;
            }
            this.addUnresolvedMacro(value);
            return 0;
        });
        const asFn = asMacroFunc;
        const asValue = asFn(asRaw);
        const opPriors = {
            '(': 1, ')': 1,
            '&&': 2,
            '||': 3,
            '!': 8
        };
        const opLogic = {
            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),
            '||': asFn((a, b) => asRaw(a) || asRaw(b)),
            '!': asFn((a) => !asRaw(a)),
            'asValue': asValue
        };
        const exprValue = this.evaluateMacroExpr(lexer, opPriors, opLogic, {});
        return exprValue;
    }
    resolveMacroInner(lexer) {
        const macros = this.macros;
        const asRaw = (token) => this.resolveMacro(token);
        const asFn = asMacroFunc;
        const asValue = asFn(asRaw);
        const opPriors = {
            '(': 1, ')': 1,
            '||': 2,
            '&&': 3,
            '<': 4, '>': 4, '<=': 4, '>=': 4,
            '==': 5, '!=': 5,
            '+': 6, '-': 6,
            '*': 7, '/': 7,
            '!': 8,
            'defined': 9
        };
        // TODO: add conditional operator
        // TODO: add unary '+' and unary '-' operators
        const opLogic = {
            '&&': asFn((a, b) => asRaw(a) && asRaw(b)),
            '||': asFn((a, b) => asRaw(a) || asRaw(b)),
            '!': asFn((a) => !asRaw(a)),
            '+': asFn((a, b) => asRaw(a) + asRaw(b)),
            '-': asFn((a, b) => asRaw(a) - asRaw(b)),
            '*': asFn((a, b) => asRaw(a) * asRaw(b)),
            '/': asFn((a, b) => asRaw(a) / asRaw(b)),
            '<': asFn((a, b) => asRaw(a) < asRaw(b)),
            '>': asFn((a, b) => asRaw(a) > asRaw(b)),
            '<=': asFn((a, b) => asRaw(a) <= asRaw(b)),
            '>=': asFn((a, b) => asRaw(a) >= asRaw(b)),
            '==': asFn((a, b) => asRaw(a) === asRaw(b)),
            '!=': asFn((a, b) => asRaw(a) !== asRaw(b)),
            'asValue': asValue
        };
        //
        // Wrap all macro functions to native 
        //
        const macroFuncs = {
            'defined': asFn((a) => {
                const macro = macros.get(a.value);
                if (macro) {
                    macro.bRegionExpr = true;
                    return 1;
                }
                this.addUnresolvedMacro(a.value);
                return 0;
            }),
        };
        // TODO: move list construction to preprocess
        macros.forEach((macro) => {
            if (macro.bFunction) {
                opPriors[macro.name] = 10;
                macroFuncs[macro.name] = {
                    op: (...args) => {
                        macros.push(macro);
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(macro.params.length === args.length);
                        const params = macro.params;
                        for (let i = 0; i < params.length; ++i) {
                            if (DEBUG_MACRO) {
                                console.log(`${macro.name}.${params[i]} => ${args[i].value}`, (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(args[i].value));
                            }
                            macros.set({
                                name: params[i],
                                tokens: [args[i]],
                                bFunction: false,
                                params: null,
                                bRegionExpr: false
                            });
                        }
                        const value = String(this.resolveMacroInner(this.macroToLexer(macro)));
                        macros.pop();
                        // TODO: use min/max instead?
                        const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(...args.map(arg => arg.loc));
                        return { index: -1, type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_4__.ETokenType.k_NumericLiteral, name: 'T_UINT', value, loc };
                    },
                    length: macro.params.length
                };
            }
        });
        return this.evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs);
    }
    resolveMacro(textToken) {
        return tokenToNative(textToken, (token) => {
            const macro = this.macros.get(token.value);
            if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(macro) && !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(macro.tokens)) {
                const exprValue = this.resolveMacroInner(this.macroToLexer(macro));
                if (DEBUG_MACRO) {
                    console.log(`macro '${token.value}:${macro.tokens.map(tk => tk.value).join(' ')}' resolved to '${exprValue}''`);
                }
                return exprValue;
            }
            this.emitMacroWarning(`cannot resolve macro '${token.value}'`, textToken.loc);
            this.addUnresolvedMacro(token.value);
            return NaN;
        });
    }
    addUnresolvedMacro(name) {
        if (this.unresolvedMacros.find(macro => macro.name === name)) {
            return;
        }
        this.unresolvedMacros.push({
            bFunction: false,
            name,
            params: null,
            tokens: null,
            bRegionExpr: true
        });
    }
    evaluateMacroExpr(lexer, opPriors, opLogic, macroFuncs = {}) {
        const values = [];
        const opStack = [];
        let token = lexer.getNextToken();
        //
        // Transform input sequence to reverse Polish notation
        //
        exit: while (true) {
            switch (token.name) {
                case 'T_TYPE_ID':
                case 'T_NON_TYPE_ID':
                    // process functional macros as operators
                    if (macroFuncs[token.value]) {
                        opStack.push(token);
                        break;
                    }
                    values.push(token);
                    break;
                case 'T_UINT':
                case 'T_KW_TRUE':
                case 'T_KW_FALSE':
                    values.push(token);
                    break;
                case 'T_PUNCTUATOR_40': // '('
                    opStack.push(token);
                    break;
                case 'T_PUNCTUATOR_41': // ')'
                    {
                        let op = opStack.pop();
                        while (op.value !== '(') {
                            values.push(op);
                            op = opStack.pop();
                        }
                    }
                    break;
                case 'T_PUNCTUATOR_44': // ','
                    // ignoring of all commas
                    break;
                case _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL:
                    break exit;
                default:
                    if (opPriors[token.value]) {
                        if (opStack.length) {
                            const thisOp = token.value;
                            const prevOp = opStack[opStack.length - 1].value;
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(opPriors[prevOp] && opPriors[thisOp], prevOp, thisOp);
                            if (opPriors[prevOp] >= opPriors[thisOp]) {
                                values.push(opStack.pop());
                            }
                        }
                        opStack.push(token);
                        break;
                    }
                    this.emitMacroError(`unsupported macro operator found: '${token.value}'`, token.loc);
                    return NaN;
            }
            token = lexer.getNextToken();
        }
        while (opStack.length) {
            values.push(opStack.pop());
        }
        //
        // Evaluate reverse Polish notation
        //
        // FIXME: remove debug log
        const $input = `[${values.map(token => token.value).join(', ')}]`;
        const isOp = (op) => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(opLogic[op.value]);
        const asOp = (op) => opLogic[op.value];
        const isFn = (op) => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(macroFuncs[op.value]);
        const asFn = (op) => macroFuncs[op.value];
        const stack = [];
        values.forEach(token => {
            if (isOp(token)) {
                const { op, length } = asOp(token);
                stack.push(op(...stack.splice(-(length))));
                return;
            }
            if (isFn(token)) {
                const { op, length } = asFn(token);
                stack.push(op(...stack.splice(-(length))));
                return;
            }
            stack.push(token);
        });
        if (values.length === 1) {
            stack[0] = opLogic.asValue.op(stack[0]);
        }
        if (DEBUG_MACRO)
            console.log(`${$input} => {${stack[0].value}}`);
        // assert(asMacroNative(stack[0]) !== NaN, stack);
        return tokenToNative(stack[0]);
    }
    async processErrorMacro(token) {
        const text = this.readLine();
        const msg = text.value.trim();
        this.emitMacroError(`erroneous macro reached: "${msg}"`, _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(token.loc, text.loc));
        return this.readToken();
    }
    async skipUnreachableCode(startToken) {
        let token = await this.readToken(false);
        let nesting = 0;
        while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO) {
                switch (token.value) {
                    case '#if':
                    case '#ifdef':
                    case '#ifndef':
                        nesting++;
                        this.readLine();
                        break;
                    case '#elif':
                    case '#else':
                        if (nesting !== 0) {
                            this.readLine();
                            break;
                        }
                    /* fall throught */
                    case '#endif':
                        if (nesting > 0) {
                            nesting--;
                            this.readLine();
                            break;
                        }
                        this.addUnreachableCode(startToken, token);
                        return this.readMacro(token);
                    case '#error':
                        this.readLine();
                }
            }
            token = await this.readToken(false);
        }
        // TODO: highlight open tag
        this.emitMacroError(`'endif' non found :/`, token.loc);
        return token;
    }
    addUnreachableCode(start, end) {
        const block = { start: { ...start.loc.end, column: 0 }, end: { ...end.loc.end, column: 0 } };
        block.start.line++;
        if (block.end.line - block.start.line > 0) {
            if (DEBUG_MACRO) {
                console.log(`unreachable code: [${block.start.line}, ${block.end.line})`);
            }
            this.unreachableCodeList.push(block);
        }
    }
    async processIncludeMacro(token) {
        const file = this.readLine();
        //cuttin qoutes
        const includeURL = file.value.trim().slice(1, -1);
        const resolvedURI = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.resolve(includeURL, `${token.loc.start.file}`);
        const loc = _lib_parser_util__WEBPACK_IMPORTED_MODULE_5__.commonRange(token.loc, file.loc);
        if (this.includeMap.has(resolvedURI)) {
            if (DEBUG_MACRO) {
                const chain = this.includes.map(i => this.stack[i].lexer.document.uri.toString()).map(name => `\t> ${name}`).join('\n');
                console.warn(`'${resolvedURI}' file has already been included previously at "${this.includeMap.get(resolvedURI).start.file}":\n${chain}`);
            }
            // TODO: prevent recursion!
            // // TODO: emit warning
            // return this.readToken();
        }
        const textDocumentRaw = await this.includeResolver(resolvedURI);
        if (!textDocumentRaw) {
            this.emitFileNotFound(resolvedURI, loc);
            return this.readToken();
        }
        // rebuild text document in order to avoid problems if include handler was called through worker
        const { uri, source } = textDocumentRaw;
        const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(uri, source);
        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_Include);
        return this.readToken();
    }
    emitMacroWarning(msg, loc) {
        this.diagnostics.warning(EPreprocessorWarnings.MacroUnknownWarning, { ...loc.start /* << FIXME: remove this */, loc, msg });
    }
    emitMacroError(msg, loc) {
        this.diagnostics.error(EPreprocessorErrors.MacroUnknownError, { ...loc.start /* << FIXME: remove this */, loc, msg });
    }
    emitFileNotFound(file, loc) {
        this.diagnostics.error(EPreprocessorErrors.GeneralCouldNotReadFile, { ...loc.start /* << FIXME: remove this */, loc, target: file });
    }
    async applyMacro(token) {
        const macros = this.macros;
        const macro = macros.get(token.value);
        if (!macro) {
            return null;
        }
        if (macro.bFunction) {
            const $lexer = this.lexer;
            const pos = this.lexer.getPosition();
            const nextToken = await this.readToken();
            if (nextToken.value !== '(') {
                this.emitMacroWarning(`for macro '${macro.name} function call signature is expected'`, token.loc);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)($lexer === this.lexer, 'something went wrong');
                this.lexer.setPosition(pos);
                return null;
            }
            let readTokens = [nextToken];
            let argRanges = [];
            let argToken = await this.readToken();
            let bracketDepth = 0;
            let startPos = 1;
            let endPos = 1;
            readTokens.push(argToken);
            while (argToken.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL && !(argToken.value === ')' && bracketDepth == 0)) {
                switch (argToken.value) {
                    case '(':
                        bracketDepth++;
                        break;
                    case ')':
                        bracketDepth--;
                        break;
                    case ',':
                        if (bracketDepth === 0) {
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(endPos - startPos > 0);
                            // TODO: emit error
                            if ((endPos - startPos) > 0) {
                                argRanges.push(startPos, endPos);
                            }
                            startPos = endPos + 1;
                        }
                        break;
                }
                endPos++;
                argToken = await this.readToken();
                readTokens.push(argToken);
            }
            if (endPos > startPos) {
                argRanges.push(startPos, endPos);
            }
            const nArgs = argRanges.length / 2;
            if (nArgs !== macro.params.length) {
                this.emitMacroError(`macro '${macro.name}' arguments mismatch, expected count is ${macro.params.length} but recived ${nArgs}`, token.loc);
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)($lexer === this.lexer, 'something went wrong');
                this.lexer.setPosition(pos);
                return null;
            }
            {
                const { loc: { start } } = token;
                const { loc: { end } } = argToken;
                this.pushDocument(this.macroToLexer(macro), { start, end }, EPPDocumentFlags.k_Macro, macro);
            }
            const params = macro.params;
            for (let i = 0; i < params.length; ++i) {
                const i2 = i * 2;
                const startPos = argRanges[i2];
                const endPos = argRanges[i2 + 1];
                const start = readTokens[startPos].loc.start;
                const end = readTokens[endPos - 1].loc.end;
                const tokens = readTokens.slice(startPos, endPos);
                if (DEBUG_MACRO) {
                    console.log(`${macro.name}.${params[i]} => ${tokens.map(tk => tk.value).join(' ')}`);
                }
                macros.set({
                    name: params[i],
                    tokens,
                    bFunction: false,
                    params: null,
                    bRegionExpr: false
                });
            }
        }
        else {
            if (DEBUG_MACRO) {
                console.log(`${macro.name} => ${macro.tokens.map(tk => tk.value).join(' ')}`);
            }
            this.pushDocument(this.macroToLexer(macro), token.loc, EPPDocumentFlags.k_Macro, macro);
        }
        return macro;
    }
    async preprocessToString(value, includeResolver) {
        if (DEBUG_MACRO) {
            console.info('preprocess to string', value);
        }
        const { knownTypes, macros, diagnostics: diag } = this;
        const pp = new Preprocessor(this.lexerEngine, { knownTypes, macros, diag, includeResolver });
        pp.setTextDocument(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)('://macro', value));
        let token = await pp.readToken();
        let raw = null;
        while (token.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            raw = (raw ? raw + ' ' : '') + token.value;
            token = await pp.readToken();
        }
        if (DEBUG_MACRO) {
            console.info(`>> "${raw}"`);
        }
        return raw;
    }
    // apply "left'##'right" operator to value and next token
    async applyConcatMacro(left) {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!this.macros.get(left.value) || !this.macros.get(left.value).bFunction);
        const right = await this.readToken(false, false);
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(right.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL);
        if (DEBUG_MACRO) {
            console.info(`concat strings: "${left.value}##${right.value}"`);
        }
        const leftRaw = await this.preprocessToString(left.value, this.includeResolver);
        const rightRaw = await this.preprocessToString(right.value, this.includeResolver);
        const raw = `${leftRaw}${rightRaw}`;
        if (DEBUG_MACRO) {
            console.info(`=> "${leftRaw}${rightRaw}"`);
        }
        const loc = { start: left.loc.start, end: right.loc.end };
        // multiple concatenation processing: A ## B ## C ##  etc.
        const nextToken = await this.readToken(false, false);
        if (nextToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO_CONCAT) {
            return this.applyConcatMacro(createMacroToken(raw, loc));
        }
        this.pushToken(nextToken);
        // we handle it as text document, because all possible macros inside are already resolved
        const pos = left.loc.start;
        const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(pos.file, raw, pos);
        this.pushDocument(this.documentToLexer(textDocument), loc, EPPDocumentFlags.k_None);
        return this.readToken();
    }
    async examMacro(token) {
        const macroProcessing = this.stack[this.stack.length - 1].flags & EPPDocumentFlags.k_Macro;
        if (macroProcessing) {
            const nextToken = await this.readToken(false, false);
            if (nextToken.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_MACRO_CONCAT) {
                return this.applyConcatMacro(token);
            }
            this.pushToken(nextToken);
        }
        if (token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_NON_TYPE_ID || token.name === _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.T_TYPE_ID) {
            const macro = await this.applyMacro(token);
            if (macro) {
                return this.readToken();
            }
        }
        return token;
    }
    //
    //
    //
    documentToLexer(textDocument) {
        const { lexerEngine: engine, knownTypes, lexerOptions: { skipComments } } = this;
        const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__.Lexer({ engine, knownTypes, skipComments });
        lexer.setTextDocument(textDocument);
        return lexer;
    }
    tokensToLexer(tokens) {
        return new _lib_parser_CachingLexer__WEBPACK_IMPORTED_MODULE_8__.CachingLexer(tokens);
    }
    macroToLexer(macro) {
        return this.tokensToLexer(macro.tokens);
    }
    async tokenToLexer(token) {
        const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_9__.Lexer({ engine: this.lexerEngine, knownTypes: this.knownTypes });
        const uri = token.loc.start.file;
        const source = token.value;
        const offset = token.loc.start;
        lexer.setTextDocument(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(uri, source, offset));
        return lexer;
    }
    async lineToTokens(lineToken) {
        const lexer = await this.tokenToLexer(lineToken);
        let tokens = [];
        let tk = lexer.getNextToken();
        while (tk.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
            tokens.push(tk);
            tk = lexer.getNextToken();
        }
        return tokens;
    }
    async lineToLexer(lineToken) {
        return this.tokensToLexer(await this.lineToTokens(lineToken));
    }
}
// create preprocessed document
async function createPPDocument(textDocument, options = {}) {
    // TODO: try to use default lexer: new LexerEngine()
    const parser = (0,_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__.defaultSLParser)();
    const { skipComments = true, includeResolver, defines } = options;
    const pp = new Preprocessor(parser.lexerEngine, { skipComments, includeResolver, defines });
    pp.setTextDocument(textDocument);
    const newline = (from, to) => Array(Math.min(to - from, 4)).fill('\n').join('');
    const padding = (length) => Array(length).fill(' ').join('');
    let content = '';
    let tokenThis = await pp.readToken();
    while (tokenThis.name !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_11__.END_SYMBOL) {
        const doPadding = !content || content.substr(-1) === '\n';
        const locThis = pp.macroLocation() || tokenThis.loc;
        const macroThis = pp.currentMacro();
        // padding
        if (doPadding) {
            content += padding(locThis.start.column); // + padding(tokenThis.loc.start.column);
            // note: paddings inside multiline macro are not supported
        }
        // place content
        content = `${content}${!doPadding ? ' ' : ''}${tokenThis.value}`;
        const tokenNext = await pp.readToken();
        const locNext = pp.macroLocation() || tokenNext.loc;
        // newline if new file
        if (locThis.end.file !== locNext.start.file) {
            content += '\n\n';
        }
        // newline if new global macro (or just diff lines) on a new line
        else if (locThis.end.line < locNext.start.line) {
            content += newline(locThis.end.line, locNext.start.line);
        }
        // new line if it is a multiline macro
        else if (tokenThis.loc.end.line < tokenNext.loc.start.line && macroThis === pp.currentMacro()) {
            content += newline(tokenThis.loc.end.line, tokenNext.loc.start.line);
        }
        tokenThis = tokenNext;
    }
    return (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(textDocument.uri, content);
}


/***/ }),

/***/ "Xd2f":
/*!*********************************!*\
  !*** ./src/lib/parser/State.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "State": () => (/* binding */ State)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _Item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Item */ "gO55");


class State {
    constructor() {
        this.nextStates = {};
        this.index = 0;
        this.items = [];
        this.numBaseItems = 0;
        this.numOtherItems = 0;
    }
    eachItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.items.length; ++i) {
            cb(this.items[i], i);
        }
    }
    eachBaseItem(cb) {
        // NOTE: do not try to change this for loop
        for (let i = 0; i < this.numBaseItems; ++i) {
            cb(this.items[i], i);
        }
    }
    isExpected(symbol) {
        return !!this.items.find(item => item.isExpected(symbol));
    }
    hasItem(value, type) {
        return this.items.find(item => item.isEqual(value, type)) || null;
    }
    hasParentItem(value) {
        return this.items.find(item => item.isParentItem(value)) || null;
    }
    hasChildItem(value) {
        return this.items.find(item => item.isChildItem(value)) || null;
    }
    hasRule(rule, pos) {
        for (let i = 0; i < this.numBaseItems; ++i) {
            const item = this.items[i];
            if (item.rule === rule && item.pos === pos) {
                return true;
            }
        }
        return false;
    }
    isEmpty() {
        return !(this.items.length);
    }
    isEqual(state, type) {
        if (this.numBaseItems !== state.numBaseItems) {
            return false;
        }
        for (let i = 0; i < this.numBaseItems; ++i) {
            const baseItemA = this.items[i];
            let isEqual = false;
            for (let i = 0; i < state.numBaseItems; ++i) {
                const baseItemB = state.items[i];
                if (baseItemA.isEqual(baseItemB, type)) {
                    isEqual = true;
                    break;
                }
            }
            if (!isEqual) {
                return false;
            }
        }
        return true;
    }
    push(item) {
        if (this.items.length === 0 || item.pos > 0) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(this.numOtherItems === 0);
            this.numBaseItems++;
        }
        else {
            this.numOtherItems++;
        }
        this.items.push(item);
    }
    tryPush_LR0(rule, pos) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return false;
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__.Item(rule, pos);
        this.push(item);
        return true;
    }
    tryPush_LR(rule, pos, expectedSymbol) {
        const sameItem = this.items.find(item => (item.rule === rule && item.pos === pos));
        if (sameItem) {
            return sameItem.addExpected(expectedSymbol);
        }
        const item = new _Item__WEBPACK_IMPORTED_MODULE_1__.Item(rule, pos, [expectedSymbol]);
        this.push(item);
        return true;
    }
    addNextState(symbol, state) {
        if (this.nextStates[symbol]) {
            return false;
        }
        this.nextStates[symbol] = state;
        return true;
    }
    deleteNotBase() {
        this.items.length = this.numBaseItems;
    }
    toString(isBase = true, grammarSymbols = null) {
        const items = isBase ? this.items.slice(0, this.numBaseItems) : this.items;
        return `State ${this.index}:\n` +
            items.map(item => `\t\t${item.toString(grammarSymbols)}\n`).join();
    }
}


/***/ }),

/***/ "wKf3":
/*!***********************************!*\
  !*** ./src/lib/parser/helpers.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommentExtractor": () => (/* binding */ CommentExtractor),
/* harmony export */   "exractComments": () => (/* binding */ exractComments),
/* harmony export */   "parseComment": () => (/* binding */ parseComment)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/parser/Lexer */ "sesj");
/* harmony import */ var _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/parser/Preprocessor */ "nYIV");
/* harmony import */ var _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/parser/symbols */ "yMDx");
/* harmony import */ var _lib_parser_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/parser/util */ "5ZRz");





/** @deprecated Use CommentExtractor instead. */
async function exractComments(document, includeResolver) {
    const lexer = new _lib_parser_Lexer__WEBPACK_IMPORTED_MODULE_1__.Lexer({ skipComments: false });
    const ppdoc = await (0,_lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_2__.createPPDocument)(document, { skipComments: false, includeResolver });
    lexer.setTextDocument(ppdoc);
    let comments = [];
    let token;
    while ((token = lexer.getNextToken()).value !== _lib_parser_symbols__WEBPACK_IMPORTED_MODULE_3__.END_SYMBOL) {
        if (token.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.ETokenType.k_MultilineCommentLiteral) {
            comments.push(token);
        }
    }
    return comments;
}
/** @deprecated Use CommentExtractor instead. */
function parseComment(handlers, epilogue, prologue) {
    return (commentToken) => {
        let comment = commentToken.value.slice(2, -2);
        let list = comment
            .split('\n')
            .map(str => str.replace(/^\s*\*{1,2}\s*|\s*$/g, ''));
        let accum = [];
        let lastRule = null;
        let content;
        let rules = [];
        let line = -1;
        while (list.length) {
            line++;
            [content, list] = [list[0], list.slice(1)];
            if (content.match(/^\s*$/g)) {
                continue;
            }
            if (!content.match(/^@[\w]+/g)) {
                accum.push(content);
                continue;
            }
            if (lastRule) {
                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
            }
            lastRule = { content, line };
        }
        ;
        if (lastRule && lastRule.content) {
            rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
        }
        epilogue && epilogue();
        for (let rule of rules) {
            const { line, content } = rule;
            const parts = content.split(' ');
            const ruleName = parts[0].trim().toLowerCase();
            const loc = (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_4__.cloneRange)(commentToken.loc);
            // FIXME: dirty hack in order to make the range correct
            loc.start.line += line;
            // loc.start.offset = -1;
            loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '
            loc.end.line = loc.start.line;
            // loc.end.offset = loc.start.offset;
            loc.end.column = loc.start.column + parts.join(' ').length;
            handlers[ruleName](parts, ruleName, loc);
        }
        ;
        prologue && prologue();
    };
}
// TODO: temp helper
class CommentExtractor {
    async parse(document, includeResolver) {
        const tokens = await exractComments(document, includeResolver);
        tokens.forEach((commentToken) => {
            let comment = commentToken.value.slice(2, -2);
            let list = comment
                .split('\n')
                .map(str => str.replace(/^\s*\*{1,2}\s*|\s*$/g, ''));
            let accum = [];
            let lastRule = null;
            let content;
            let rules = [];
            let line = -1;
            while (list.length) {
                line++;
                [content, list] = [list[0], list.slice(1)];
                if (content.match(/^\s*$/g)) {
                    continue;
                }
                if (!content.match(/^@[\w]+/g)) {
                    accum.push(content);
                    continue;
                }
                if (lastRule) {
                    rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
                }
                lastRule = { content, line };
            }
            ;
            if (lastRule && lastRule.content) {
                rules.push({ content: [lastRule.content, ...accum.splice(0)].join(' '), line: lastRule.line });
            }
            this.beginComment(content);
            for (let rule of rules) {
                const { line, content } = rule;
                const parts = content.split(' ');
                const ruleName = parts[0].trim().toLowerCase();
                const loc = (0,_lib_parser_util__WEBPACK_IMPORTED_MODULE_4__.cloneRange)(commentToken.loc);
                // FIXME: dirty hack in order to make the range correct
                loc.start.line += line;
                // loc.start.offset = -1;
                loc.start.column = 3; // hack in order to simulate offset of beginning of the comment line => ' * '
                loc.end.line = loc.start.line;
                // loc.end.offset = loc.start.offset;
                loc.end.column = loc.start.column + parts.join(' ').length;
                this.applyRule(ruleName, parts, loc);
            }
            ;
            this.endComment();
        });
    }
    beginComment(content) {
    }
    applyRule(rule, parts, loc) {
    }
    endComment() {
    }
}


/***/ }),

/***/ "yMDx":
/*!***********************************!*\
  !*** ./src/lib/parser/symbols.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "END_POSITION": () => (/* binding */ END_POSITION),
/* harmony export */   "END_SYMBOL": () => (/* binding */ END_SYMBOL),
/* harmony export */   "EOF": () => (/* binding */ EOF),
/* harmony export */   "ERROR": () => (/* binding */ ERROR),
/* harmony export */   "FLAG_RULE_CREATE_NODE": () => (/* binding */ FLAG_RULE_CREATE_NODE),
/* harmony export */   "FLAG_RULE_EXPOSE_NODE": () => (/* binding */ FLAG_RULE_EXPOSE_NODE),
/* harmony export */   "FLAG_RULE_FUNCTION": () => (/* binding */ FLAG_RULE_FUNCTION),
/* harmony export */   "FLAG_RULE_SKIP_NODE": () => (/* binding */ FLAG_RULE_SKIP_NODE),
/* harmony export */   "INLINE_COMMENT_SYMBOL": () => (/* binding */ INLINE_COMMENT_SYMBOL),
/* harmony export */   "LEXER_RULES": () => (/* binding */ LEXER_RULES),
/* harmony export */   "START_SYMBOL": () => (/* binding */ START_SYMBOL),
/* harmony export */   "T_EMPTY": () => (/* binding */ T_EMPTY),
/* harmony export */   "T_FLOAT": () => (/* binding */ T_FLOAT),
/* harmony export */   "T_LINE_TERMINATOR": () => (/* binding */ T_LINE_TERMINATOR),
/* harmony export */   "T_MACRO": () => (/* binding */ T_MACRO),
/* harmony export */   "T_MACRO_CONCAT": () => (/* binding */ T_MACRO_CONCAT),
/* harmony export */   "T_NON_TYPE_ID": () => (/* binding */ T_NON_TYPE_ID),
/* harmony export */   "T_STRING": () => (/* binding */ T_STRING),
/* harmony export */   "T_TYPE_ID": () => (/* binding */ T_TYPE_ID),
/* harmony export */   "T_UINT": () => (/* binding */ T_UINT),
/* harmony export */   "UNKNOWN_TOKEN": () => (/* binding */ UNKNOWN_TOKEN),
/* harmony export */   "UNUSED_SYMBOL": () => (/* binding */ UNUSED_SYMBOL)
/* harmony export */ });
const END_POSITION = 'END'; // item, parser
const T_EMPTY = 'EMPTY'; // item, parser
const UNKNOWN_TOKEN = 'UNKNOWN'; // lexer
const START_SYMBOL = 'S'; // parser
const UNUSED_SYMBOL = '##'; // parser
const INLINE_COMMENT_SYMBOL = '#'; // parser
// TODO: do not use ambigious name 'ERROR'
const ERROR = 'ERROR'; // parser
const END_SYMBOL = '$'; // lexer, parser
const LEXER_RULES = '--LEXER--'; // parser
const FLAG_RULE_CREATE_NODE = '--add'; // parser
const FLAG_RULE_SKIP_NODE = '--skip'; // parser
const FLAG_RULE_EXPOSE_NODE = '--expose'; // parser
const FLAG_RULE_FUNCTION = '--F'; // parser
const EOF = 'EOF'; // lexer
const T_STRING = 'T_STRING'; // lexer
const T_FLOAT = 'T_FLOAT'; // lexer
const T_UINT = 'T_UINT'; // lexer
const T_TYPE_ID = 'T_TYPE_ID'; // lexer
const T_NON_TYPE_ID = 'T_NON_TYPE_ID'; // lexer
const T_LINE_TERMINATOR = 'T_LINE_TERMINATOR'; // lexer
const T_MACRO = 'T_MACRO'; // lexer '#define', '#ifdef' etc.
const T_MACRO_CONCAT = 'T_MACRO_CONCAT'; // lexer '##'


/***/ }),

/***/ "5ZRz":
/*!********************************!*\
  !*** ./src/lib/parser/util.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkRange": () => (/* binding */ checkRange),
/* harmony export */   "cloneRange": () => (/* binding */ cloneRange),
/* harmony export */   "commonRange": () => (/* binding */ commonRange),
/* harmony export */   "extendRange": () => (/* binding */ extendRange),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "positionMax": () => (/* binding */ positionMax),
/* harmony export */   "positionMin": () => (/* binding */ positionMin)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");

function positionMin(a, b) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.file === b.file);
    return {
        offset: Math.min(a.offset, b.offset),
        line: Math.min(a.line, b.line),
        column: Math.min(a.column, b.column),
        file: a.file
    };
}
function positionMax(a, b) {
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(a.file === b.file);
    return {
        offset: Math.max(a.offset, b.offset),
        line: Math.max(a.line, b.line),
        column: Math.max(a.column, b.column),
        file: a.file
    };
}
function cloneRange(range) {
    return { start: { ...range.start }, end: { ...range.end } };
}
// export function extendRange(parent: IRange, child: IRange): IRange {
//     if (child.start.file !== parent.start.file) {
//         return parent;
//     }
//     assert(parent.end.file === child.end.file);
//     if (child.start.line < parent.start.line) {
//         parent.start.column = child.start.column;
//         parent.start.line = child.start.line;
//         parent.start.file = child.start.file;
//         parent.start.offset = child.start.offset;
//     } else if (child.start.line === parent.start.line) {
//         // parent.start = positionMin(child.start, parent.start);
//         parent.start.column = Math.min(child.start.column, parent.start.column);
//         parent.start.line = Math.min(child.start.line, parent.start.line);
//         parent.start.offset = Math.min(child.start.offset, parent.start.offset);
//     }
//     if (child.end.line > parent.end.line) {
//         parent.end.column = child.end.column;
//         parent.end.line = child.end.line;
//         parent.end.file = child.end.file;
//         parent.end.offset = child.end.offset;
//     } else if (child.end.line === parent.end.line) {
//         // parent.end = positionMax(child.end, parent.end);
//         parent.end.column = Math.max(child.end.column, parent.end.column);
//         parent.end.line = Math.max(child.end.line, parent.end.line);
//         parent.end.offset = Math.max(child.end.offset, parent.end.offset);
//     }
//     return parent;
// }
function extendRange(parent, child) {
    if (child.start.file !== parent.start.file) {
        return parent;
    }
    if (child.start.line < parent.start.line) {
        parent.start = { ...child.start };
    }
    else if (child.start.line === parent.start.line) {
        parent.start = positionMin(child.start, parent.start);
    }
    if (child.end.line > parent.end.line) {
        parent.end = { ...child.end };
    }
    else if (child.end.line === parent.end.line) {
        parent.end = positionMax(child.end, parent.end);
    }
    return parent;
}
function commonRange(...rangeList) {
    const MAX_I32 = Number.MAX_SAFE_INTEGER;
    const MIN_I32 = Number.MIN_SAFE_INTEGER;
    const file = rangeList[0].start.file;
    let start = { offset: MAX_I32, column: MAX_I32, line: MAX_I32, file };
    let end = { offset: MIN_I32, column: MIN_I32, line: MIN_I32, file };
    rangeList.forEach(range => start = positionMin(start, range.start));
    rangeList.forEach(range => end = positionMax(end, range.end));
    return { start, end };
}
function offset(source, offset) {
    if (offset) {
        // TODO: check that URIs the same
        const { start, end } = source;
        if (start.line === 0) {
            start.column += offset.column;
        }
        if (end.line === 0) {
            end.column += offset.column;
        }
        start.line += offset.line;
        end.line += offset.line;
    }
    return source;
}
const checkRange = (range, offset) => range.start.offset <= offset && range.end.offset > offset;
// export function stringifyRange(range: IRange, depth = 0) {
//     if (!range) {
//         return '';
//     }
//     const offset = Array(depth).fill('---').join('') + (depth? ' ' : '');
//     const { start, end, source } = range;
//     const filename = String(start.file).split('/').reverse()[0];
//     return `${offset}${filename}:${start.line}:${start.column}-${end.line}:${end.column}\n${stringifyRange(source, depth + 1)}`;
// } 


/***/ }),

/***/ "U50j":
/*!******************************!*\
  !*** ./src/lib/path/path.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "ext": () => (/* binding */ ext),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "parse": () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "cOQ3");

class Pathinfo {
    constructor(path) {
        this._dirname = null;
        this._extension = null;
        this._filename = null;
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(path)) {
            this.set(path);
        }
    }
    get path() {
        return this.toString();
    }
    set path(path) {
        this.set(path);
    }
    get dirname() {
        return this._dirname;
    }
    set dirname(dirname) {
        this._dirname = dirname;
    }
    get filename() {
        return this._filename;
    }
    set filename(filename) {
        this._filename = filename;
    }
    get ext() {
        return this._extension;
    }
    set ext(extension) {
        this._extension = extension;
    }
    get basename() {
        return (this._filename ? this._filename + (this._extension ? "." + this._extension : "") : "");
    }
    set basename(basename) {
        var nPos = basename.lastIndexOf(".");
        if (nPos < 0) {
            this._filename = basename.substr(0);
            this._extension = null;
        }
        else {
            this._filename = basename.substr(0, nPos);
            this._extension = basename.substr(nPos + 1);
        }
    }
    set(path) {
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(path)) {
            var pParts = path.replace('\\', '/').split('/');
            this.basename = (pParts.pop());
            this._dirname = pParts.join('/');
        }
        else if (path instanceof Pathinfo) {
            this._dirname = path.dirname;
            this._filename = path.filename;
            this._extension = path.ext;
        }
        else if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(path)) {
            return null;
        }
        else {
            //critical_error
            throw new Error(`Unexpected data type was used: ${path}`);
        }
    }
    replaceExt(ext) {
        this.ext = ext;
        return this;
    }
    isAbsolute() { return !!(this._dirname?.[0] === "/"); }
    toString() {
        return (this._dirname ? this._dirname + "/" : "") + (this.basename);
    }
}
function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === "..") {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
        for (; up--;) {
            parts.unshift("..");
        }
    }
    return parts;
}
function normalize(path) {
    var info = parse(path);
    var isAbsolute = info.isAbsolute();
    var tail = info.dirname;
    var trailingSlash = /[\\\/]$/.test(tail);
    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
        return !!p;
    }), !isAbsolute).join("/");
    if (tail && trailingSlash) {
        tail += "/";
    }
    info.dirname = ((isAbsolute ? "/" : "") + tail);
    return info.toString();
}
function parse(path) {
    return new Pathinfo(path);
}
function dirname(path) {
    return parse(path).dirname;
}
function ext(path) {
    return parse(path).ext;
}


/***/ }),

/***/ "CWQE":
/*!****************************!*\
  !*** ./src/lib/uri/uri.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "currentPath": () => (/* binding */ currentPath),
/* harmony export */   "currentScript": () => (/* binding */ currentScript),
/* harmony export */   "fromLocalPath": () => (/* binding */ fromLocalPath),
/* harmony export */   "here": () => (/* binding */ here),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseDataURI": () => (/* binding */ parseDataURI),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "toLocalPath": () => (/* binding */ toLocalPath)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "cOQ3");
/* harmony import */ var _path_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/path */ "U50j");


class URI {
    constructor(uri) {
        this._scheme = null;
        this._userinfo = null;
        this._host = null;
        this._port = 0;
        this._path = null;
        this._query = null;
        this._fragment = null;
        if (uri) {
            this.set(uri);
        }
    }
    get urn() {
        return (this._path ? this._path : "") +
            (this._query ? '?' + this._query : "") +
            (this._fragment ? '#' + this._fragment : "");
    }
    get url() {
        return (this._scheme ? this._scheme + '//' : "") + this.authority;
    }
    get authority() {
        return (this._host ? (this._userinfo ? this._userinfo + '@' : "") +
            this._host + (this._port ? ':' + this._port : "") : "");
    }
    get scheme() {
        return this._scheme;
    }
    get protocol() {
        if (!this._scheme) {
            return this._scheme;
        }
        return (this._scheme.substr(0, this._scheme.lastIndexOf(':')));
    }
    get userInfo() {
        return this._userinfo;
    }
    get host() {
        return this._host;
    }
    set host(sHost) {
        //TODO: check host format
        this._host = sHost;
    }
    get port() {
        return this._port;
    }
    set port(iPort) {
        this._port = iPort;
    }
    get path() {
        return this._path;
    }
    set path(sPath) {
        // debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))), 
        //     "invalid path used: " + sPath);
        //TODO: check path format
        this._path = sPath;
    }
    get query() {
        //TODO: check query format
        return this._query;
    }
    set query(sQuery) {
        this._query = sQuery;
    }
    get fragment() {
        return this._fragment;
    }
    set(data) {
        if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(data)) {
            var uri = URI.uriExp.exec(data);
            console.assert(uri !== null, 'Invalid URI format used.\nused uri: ' + data);
            if (!uri) {
                return null;
            }
            this._scheme = uri[1] || null;
            this._userinfo = uri[2] || null;
            this._host = uri[3] || null;
            this._port = parseInt(uri[4]) || null;
            this._path = uri[5] || uri[6] || null;
            this._query = uri[7] || null;
            this._fragment = uri[8] || null;
            return this;
        }
        else if (data instanceof URI) {
            return this.set(data.toString());
        }
        console.error('Unexpected data type was used.');
        return null;
    }
    toString() {
        return this.url + this.urn;
    }
}
//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment
URI.uriExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");
function normalizeURIPath(file) {
    if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.path)) {
        if (file.scheme === "filesystem:") {
            var uri = parse(file.path);
            uri.path = _path_path__WEBPACK_IMPORTED_MODULE_1__.normalize(uri.path);
            file.path = uri.toString();
        }
        else {
            file.path = _path_path__WEBPACK_IMPORTED_MODULE_1__.normalize(file.path);
        }
    }
    return file;
}
function resolve(from, to = document.location.href) {
    var currentPath = parse(to);
    var file = parse(from);
    var dirname;
    normalizeURIPath(file);
    normalizeURIPath(currentPath);
    if (!(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.scheme) || !(0,_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.host) || _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(file.path).isAbsolute()) {
        //another server or absolute path
        return from;
    }
    dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(currentPath.path).dirname;
    currentPath.path = dirname ? (dirname + "/" + from) : from;
    return normalizeURIPath(currentPath).toString();
}
function parseDataURI(uri) {
    var re = /^data:([\w\d\-\/]+)?(;charset=[\w\d\-]*)?(;base64)?,(.*)$/;
    var m = uri.match(re);
    return {
        //like [text/plain]
        mediatype: m[1] || null,
        //like [;charset=windows-1251]
        charset: (0,_common__WEBPACK_IMPORTED_MODULE_0__.isString)(m[2]) ? m[2].substr(9) : null,
        //like [;base64]
        base64: (0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(m[3]),
        data: m[4] || null
    };
}
function parse(uri) {
    return new URI(String(uri));
}
function currentScript() {
    if ((0,_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(document['currentScript'])) {
        return document['currentScript'];
    }
    var scripts = document.getElementsByTagName("script");
    return scripts[scripts.length - 1];
}
function currentPath() {
    var uri = parse(currentScript().src);
    let dirname = _path_path__WEBPACK_IMPORTED_MODULE_1__.parse(uri.path).dirname;
    return uri.url + dirname + "/";
}
function here() {
    return new URI(document.location.href);
}
function fromLocalPath(filepath) {
    return `file:///${String(filepath).replaceAll('\\', '/')}`;
}
function toLocalPath(uri) {
    return parse(uri).path?.substring(1) || '';
}


/***/ }),

/***/ "0mZ+":
/*!*************************************!*\
  !*** ./src/lib/util/Diagnostics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiagnosticException": () => (/* binding */ DiagnosticException),
/* harmony export */   "Diagnostics": () => (/* binding */ Diagnostics)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/IDiagnostics */ "DIkA");


function locToString(loc) {
    return `${loc.line},${loc.column}`;
}
function rangeToString(range) {
    return `${locToString(range.start)}:${locToString(range.end)}`;
}
function readKey(desc, key) {
    let keyParts = key.split('.');
    if (keyParts.length > 1) {
        return readKey(desc[keyParts[0]], keyParts.splice(1).join('.'));
    }
    return desc[keyParts[0]];
}
function fillPattern(pattern, desc) {
    return pattern.replace(/{([a-zA-Z.]+)}/g, (match, key) => {
        return readKey(desc, key);
    });
}
class DiagnosticException extends Error {
    constructor(host, mesg) {
        super(mesg.content);
        Error.captureStackTrace(this, DiagnosticException);
    }
}
class Diagnostics {
    constructor(name, codePrefix) {
        this._name = name;
        this._codePrefix = (codePrefix || '').toUpperCase();
        this.reset();
    }
    emitException() {
        throw new DiagnosticException(this, this.getLastError());
    }
    reset() {
        this._entries = [];
    }
    resolve() {
        let report = { errors: 0, warnings: 0, messages: [] };
        for (let entry of this._entries) {
            let message = this.resolveEntry(entry);
            switch (message.category) {
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Warning:
                    report.warnings++;
                    break;
                case _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error:
                    report.errors++;
                    break;
            }
            report.messages.push(message);
        }
        return report;
    }
    resolveEntry(entry) {
        // let { category, desc } = entry;
        // let categoryName = (EDiagnosticCategory[category]).toLowerCase();
        let loc = null;
        let range;
        let start;
        let end;
        let file = this.resolveFilename(entry.category, entry.code, entry.desc);
        if (range = this.resolveRange(entry.category, entry.code, entry.desc)) {
            ({ start, end } = range);
            loc = rangeToString(range);
        }
        else {
            start = this.resolvePosition(entry.category, entry.code, entry.desc);
            loc = locToString(start);
        }
        let content = `${this.resolveDescription(entry.code, entry.category, entry.desc)}`;
        let code = `${this._codePrefix}${entry.code}`;
        let category = entry.category;
        return { code, category, content, file, start, end };
    }
    resolveFilename(category, code, desc) {
        return '[unknown]';
    }
    resolvePosition(category, code, desc) {
        return { file: null, line: 0, column: 0 };
    }
    resolveRange(category, code, desc) {
        return null;
    }
    resolveDescription(code, category, desc) {
        let diagMesgs = this.diagnosticMessages();
        if (!diagMesgs) {
            console.error(`Diagnostic messages of '${this._name}' not found.`);
            return '[no description found]';
        }
        if (!diagMesgs[code]) {
            return `[no description found for code '${code}']`;
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(diagMesgs[code])) {
            return fillPattern(diagMesgs[code], desc);
        }
        return diagMesgs[code](desc);
    }
    diagnosticMessages() {
        return null;
    }
    error(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error, code, desc });
    }
    warning(code, desc) {
        this._entries.push({ category: _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Warning, code, desc });
    }
    // add error and emit an exception in order to interrupt processing
    critical(code, desc) {
        this.error(code, desc);
        this.emitException();
    }
    prettyPrint() {
        return null; //JSON.stringify(this._errors, null, '\t');
    }
    hasErrors() {
        return this._entries.filter(entry => entry.category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error).length > 0;
    }
    getLastError() {
        for (let i = this._entries.length - 1; i >= 0; --i) {
            if (this._entries[i].category === _lib_idl_IDiagnostics__WEBPACK_IMPORTED_MODULE_1__.EDiagnosticCategory.k_Error) {
                return this.resolveEntry(this._entries[i]);
            }
        }
        return null;
    }
    isEmpty() {
        return this._entries.length === 0;
    }
    static mergeReports(reportList) {
        let result = { errors: 0, warnings: 0, messages: [] };
        reportList.forEach((report) => {
            if (!report)
                return;
            result.errors += report.errors;
            result.warnings += report.warnings;
            result.messages = result.messages.concat(report.messages);
        });
        return result;
    }
    static stringify(report) {
        return report.messages.map(mesg => mesg.content).join('\n');
    }
    static asRange(mesg) {
        let range = { start: mesg.start, end: mesg.end };
        if (!range.end) {
            range.end = { ...range.start };
        }
        const { start, end } = range;
        if (end.line == start.line && end.column == start.column) {
            end.column += 1;
        }
        return range;
    }
}


/***/ }),

/***/ "aBMm":
/*!***************************************!*\
  !*** ./src/lib/util/DistinctColor.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class DistinctColor {
    constructor(idx = 0) {
        this._curIdx = idx;
    }
    value() {
        return this._curIdx;
    }
    pickNext() {
        this._curIdx = (this._curIdx + 1) % DistinctColor.list.length;
        return this.value();
    }
    toRGBAString() {
        return DistinctColor.toRGBAString(DistinctColor.resolveColor(this.value()));
    }
    static resolveColor(idx) {
        return DistinctColor.list[idx % DistinctColor.list.length];
    }
    static toRGBAString(val) {
        let r = ((val >> 16) & 0xff);
        let g = ((val >> 8) & 0xff);
        let b = ((val >> 0) & 0xff);
        return `rgb(${r}, ${g}, ${b})`;
    }
    static make(idx) {
        return new DistinctColor(idx);
    }
    static buildVariousClasses(prefix = 'dc') {
        return DistinctColor.list.reduce((styles, color) => (styles[`${prefix}_${color}`] = {
            opacity: 0.3,
            backgroundColor: `${DistinctColor.toRGBAString(color)}`
        }, styles), {});
        // [`dc_${0xe6194b}`]: { opacity: 0.3, backgroundColor: '#e6194b' },
        // [`dc_${0x3cb44b}`]: { opacity: 0.3, backgroundColor: '#3cb44b' },
        // ...
        // ...
        // [`dc_${0x000075}`]: { opacity: 0.3, backgroundColor: '#000075' },
        // [`dc_${0x808080}`]: { opacity: 0.3, backgroundColor: '#808080' }
    }
}
DistinctColor.list = [
    0xe6194b, 0x3cb44b, 0xffe119, 0x4363d8, 0xf58231, 0x911eb4,
    0x46f0f0, 0xf032e6, 0xbcf60c, 0xfabebe, 0x008080, 0xe6beff,
    0x9a6324, 0xfffac8, 0x800000, 0xaaffc3, 0x808000, 0xffd8b1,
    0x000075, 0x808080 //, 0xffffff, 0x000000
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DistinctColor);


/***/ }),

/***/ "Cx6u":
/*!***********************************!*\
  !*** ./src/lib/util/StringRef.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringRef": () => (/* binding */ StringRef)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");

// helper class to always pass strings by pointer and not by value;
class StringRef {
    constructor(content) {
        this.content = content;
    }
    valueOf() {
        return this.content;
    }
    toString() {
        return this.content;
    }
    toSource() {
        return this.content;
    }
    static make(val) {
        if (!val) {
            return null;
        }
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(val)) {
            if (val instanceof StringRef)
                return val;
            // IP: sometimes it can be useful to restore string ref after worker transfer and so on
            if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(val['content']))
                return StringRef.make(val['content']);
        }
        const sval = val;
        let ref = StringRef.storage[sval];
        if (ref) {
            return ref;
        }
        ref = new StringRef(sval);
        StringRef.storage[sval] = ref;
        return ref;
    }
}
StringRef.storage = {};


/***/ }),

/***/ "kVxP":
/*!********************************!*\
  !*** ./src/lib/util/p4/p4.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "createChangelist": () => (/* binding */ createChangelist),
/* harmony export */   "edit": () => (/* binding */ edit),
/* harmony export */   "revert": () => (/* binding */ revert),
/* harmony export */   "run": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ "//+9");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var node_perforce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-perforce */ "+YAm");
/* harmony import */ var node_perforce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_perforce__WEBPACK_IMPORTED_MODULE_1__);

// import { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';

function run(command, args, done) {
    if (typeof args === "function") {
        done = args;
        args = "";
    }
    let p4cmd = '"C:\\Program Files\\Perforce\\p4.exe"';
    done = done || ((e, stdout) => { });
    return new Promise((resolve, reject) => {
        // console.log(p4cmd + " " + command + " " + (args || ""));
        (0,child_process__WEBPACK_IMPORTED_MODULE_0__.exec)(p4cmd + " " + command + " " + (args || ""), (err, stdOut, stdErr) => {
            if (err) {
                reject(err);
                return done(err);
            }
            if (stdErr) {
                // reject(new Error(stdErr));
                // return done(new Error(stdErr));
                console.warn(stdErr);
                // IP: handle properly
            }
            resolve(stdOut);
            done(null, stdOut);
        });
    });
}
function edit(changelist, file, cb) {
    if (changelist < 0)
        return cb();
    node_perforce__WEBPACK_IMPORTED_MODULE_1___default().edit({ changelist: changelist, files: [file] }, function (err) {
        if (err) {
            // MessageBox('Error:: Could not add files to p4 changelist. See console for details.', { type: 'warning' });
            return console.error(err);
        }
        cb();
    });
}
function add(changelist, file, cb) {
    node_perforce__WEBPACK_IMPORTED_MODULE_1___default().add({ changelist: changelist, files: [file] }, function (err) {
        if (err) {
            // MessageBox('Error:: Could not add files to p4 changelist. See console for details.', { type: 'warning' });
            return console.error(err);
        }
        cb();
    });
}
function createChangelist(description, cb) {
    node_perforce__WEBPACK_IMPORTED_MODULE_1___default().changelist.create({ description: description }, (e, changelist) => {
        if (e) {
            // MessageBox('Error:: Could not create p4 changelist. See console for details.', { type: 'warning' });
            cb(-1);
            console.error(e);
            return;
        }
        cb(changelist);
    });
}
function revert(file, cb) {
    node_perforce__WEBPACK_IMPORTED_MODULE_1___default().revert({ files: [file] }, function (err) {
        if (err)
            return console.log(err);
        cb();
    });
}


/***/ }),

/***/ "Ia0v":
/*!************************************!*\
  !*** ./src/lib/util/s3d/prjenv.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectEnv": () => (/* binding */ ProjectEnv)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "Q/He");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/common */ "cOQ3");



function ReadFile(filename) {
    return fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(filename, 'utf8');
}
function IsFileExists(filename) {
    return fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filename);
}
function IsDirectory(filename) {
    return fs__WEBPACK_IMPORTED_MODULE_0__.lstatSync(filename).isDirectory();
}
class ProjectEnv {
    constructor(projectPath) {
        this.props = {};
        this.Load(projectPath);
    }
    Load(projectPath) {
        this.LoadPrjenv(path__WEBPACK_IMPORTED_MODULE_1__.join(projectPath, ProjectEnv.DefaultProjectName));
    }
    static IsLocal(filename) {
        return filename.substr(-ProjectEnv.LocalProjectSuffix.length) == ProjectEnv.LocalProjectSuffix;
    }
    static IsDefault(filename) {
        return filename.substr(-ProjectEnv.DefaultProjectName.length) == ProjectEnv.DefaultProjectName;
    }
    LoadPrjenv(filename) {
        if (!IsFileExists(filename)) {
            if (!ProjectEnv.IsLocal(filename)) {
                console.error(`could not find project env file '${path__WEBPACK_IMPORTED_MODULE_1__.normalize(filename)}'`);
            }
            return;
        }
        if (IsDirectory(filename)) {
            return this.LoadPrjenv(path__WEBPACK_IMPORTED_MODULE_1__.join(filename, ProjectEnv.DefaultSubprojectName));
        }
        if (ProjectEnv.IsDefault(filename)) {
            this.props[`project-dir`] = path__WEBPACK_IMPORTED_MODULE_1__.dirname(filename);
            this.props[`project-name`] = path__WEBPACK_IMPORTED_MODULE_1__.basename(this.props[`project-dir`]);
        }
        let prjenv = (__webpack_require__(/*! js-yaml */ "8mqI").load)(ReadFile(filename));
        if (!prjenv) {
            console.error(`could not read prjenv: ${filename}`);
            return;
        }
        this.ReadProperties(prjenv, this.props, filename);
        if (!ProjectEnv.IsLocal(filename)) {
            this.LoadPrjenv(filename + ProjectEnv.LocalProjectSuffix);
        }
    }
    ReadProperties(prjenv, dest, filename) {
        if (!prjenv) {
            return;
        }
        Object.keys(prjenv).forEach((propName) => {
            if (propName == 'references') {
                return;
            }
            let prop = prjenv[propName];
            if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isString(prop) || _lib_common__WEBPACK_IMPORTED_MODULE_2__.isNumber(prop) || _lib_common__WEBPACK_IMPORTED_MODULE_2__.isBoolean(prop)) {
                dest[propName] = prop;
            }
            else if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isArray(prop)) {
                dest[propName] = dest[propName] || [];
                prop.forEach((val) => {
                    dest[propName].push(val);
                });
            }
            else {
                // TODO: remove this workaround for scopes
                if (propName == 'scope' && dest[propName]) {
                    return;
                }
                dest[propName] = dest[propName] || {};
                this.ReadProperties(prop, dest[propName], filename);
            }
        });
        this.LoadReferences(prjenv, path__WEBPACK_IMPORTED_MODULE_1__.dirname(filename));
    }
    LoadReferences(prjenv, cwd) {
        let references = prjenv['references'];
        if (references) {
            references.forEach((ref) => {
                if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isString(ref)) {
                    this.LoadPrjenv(path__WEBPACK_IMPORTED_MODULE_1__.join(cwd, ref));
                }
                else if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isObject(ref)) {
                    Object.keys(ref).forEach((refName) => {
                        if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isString(ref[refName])) {
                            let prjenvPath = path__WEBPACK_IMPORTED_MODULE_1__.join(cwd, ref[refName]);
                            if (IsFileExists(prjenvPath)) {
                                // creating inner reference dir name
                                this.props[`${refName}-dir`] = IsDirectory(prjenvPath) ? path__WEBPACK_IMPORTED_MODULE_1__.normalize(prjenvPath) : path__WEBPACK_IMPORTED_MODULE_1__.dirname(prjenvPath);
                                this.LoadPrjenv(path__WEBPACK_IMPORTED_MODULE_1__.join(cwd, ref[refName]));
                            }
                            else {
                                console.warn(`Reference '${prjenvPath}' is not found.`);
                            }
                        }
                    });
                }
            });
        }
    }
    Get(propName) {
        // convert from 'root/subdir/path' to '$(root)/subdir/path'
        let parts = propName.split(/[\\\/]/);
        parts[0] = `$(${parts[0]})`;
        return this.Resolve(parts.join('/'));
    }
    Resolve(val) {
        if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isArray(val)) {
            val = val.map((v) => {
                return this.Resolve(v);
            });
            return val;
        }
        if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isObject(val)) {
            Object.keys(val).forEach((key) => {
                val[key] = this.Resolve(val[key]);
            });
            return val;
        }
        if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isNumber(val)) {
            return val;
        }
        let parts = val.split(/[\\\/]/);
        // handle as path
        if (parts.length > 1) {
            let prop = this.ResolveObject(parts[0]);
            // assemble as string path
            if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isString(prop)) {
                for (let i = 1; i < parts.length; ++i) {
                    prop = path__WEBPACK_IMPORTED_MODULE_1__.join(prop, this.ResolveString(parts[i]));
                }
                return path__WEBPACK_IMPORTED_MODULE_1__.normalize(prop);
            }
            if (!prop) {
                console.error(`could not resolve '${parts[0]}'`);
                return val;
            }
            // load from object
            for (let i = 1; i < parts.length; ++i) {
                prop = prop[this.ResolveString(parts[i])];
            }
            return prop;
        }
        return this.ResolveObject(val);
    }
    ResolveString(val) {
        try {
            return val.replace(/\$\(([\w\d\-\_]+)\)/g, (match, propName) => {
                let pices = propName.split('/');
                let prop = this.props;
                while (pices.length) {
                    prop = prop[pices.shift()];
                }
                if (_lib_common__WEBPACK_IMPORTED_MODULE_2__.isString(prop) || _lib_common__WEBPACK_IMPORTED_MODULE_2__.isNumber(prop)) {
                    return prop;
                }
                console.error(`could not resolve '${propName}' property`);
                throw null;
            });
        }
        catch (e) { }
        return val;
    }
    ResolveObject(val) {
        try {
            let m = val.match(/^\$\(([\w\d\-\_]+)\)$/);
            if (m) {
                return this.Resolve(this.props[m[1]]);
            }
            return this.ResolveString(val);
        }
        catch (e) { }
        return val;
    }
}
// static ApplicationSettingsTpl = "scope/{0}";
ProjectEnv.DefaultProjectName = ".project";
ProjectEnv.DefaultSubprojectName = ".subproject";
ProjectEnv.LocalProjectSuffix = "-local";


/***/ }),

/***/ "z3nI":
/*!**********************************!*\
  !*** ./src/lib/util/s3d/type.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDef": () => (/* binding */ isDef),
/* harmony export */   "isDefAndNotNull": () => (/* binding */ isDefAndNotNull),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNull": () => (/* binding */ isNull),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString)
/* harmony export */ });
function isNull(x) { return x === null; }
function isDef(x) { return x !== undefined; }
function isDefAndNotNull(x) { return x != null; }
function isString(x) { return typeof x === 'string'; }
function isFunction(fn) { return typeof fn === "function"; }
function isBoolean(x) { return x === !!x; }
function isArray(x) { return typeof x === "object" && x instanceof Array; }
function isObject(x) { return typeof x === "object" && x !== null && !isArray(x); }
function isNumber(x) { return typeof x === "number"; }
function isEmpty(x) {
    if (x == null) {
        return true;
    }
    if (typeof x !== "object") {
        return false;
    }
    for (let key in x) {
        if (x.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
function clone(obj) {
    var copy;
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj)
        return obj;
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr))
                copy[attr] = clone(obj[attr]);
        }
        return copy;
    }
    throw new Error("Unable to copy obj! Its type isn't supported.");
}


/***/ }),

/***/ "ceAs":
/*!***********************************************!*\
  !*** ./src/sandbox/actions/ActionTypeKeys.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEBUGGER_COLORIZE": () => (/* binding */ DEBUGGER_COLORIZE),
/* harmony export */   "DEBUGGER_COMPILE": () => (/* binding */ DEBUGGER_COMPILE),
/* harmony export */   "DEBUGGER_OPTIONS_CHANGED": () => (/* binding */ DEBUGGER_OPTIONS_CHANGED),
/* harmony export */   "DEBUGGER_RESET": () => (/* binding */ DEBUGGER_RESET),
/* harmony export */   "DEBUGGER_START_DEBUG": () => (/* binding */ DEBUGGER_START_DEBUG),
/* harmony export */   "DEPOT_UPDATE_COMPLETE": () => (/* binding */ DEPOT_UPDATE_COMPLETE),
/* harmony export */   "DEPOT_UPDATE_REQUEST": () => (/* binding */ DEPOT_UPDATE_REQUEST),
/* harmony export */   "GRAMMAR_CONTENT_SPECIFIED": () => (/* binding */ GRAMMAR_CONTENT_SPECIFIED),
/* harmony export */   "GRAPH_ADD_CONSTANT": () => (/* binding */ GRAPH_ADD_CONSTANT),
/* harmony export */   "GRAPH_CHANGE_LAYOUT": () => (/* binding */ GRAPH_CHANGE_LAYOUT),
/* harmony export */   "GRAPH_COMPILE": () => (/* binding */ GRAPH_COMPILE),
/* harmony export */   "GRAPH_LOADED": () => (/* binding */ GRAPH_LOADED),
/* harmony export */   "GRAPH_MODIFIED": () => (/* binding */ GRAPH_MODIFIED),
/* harmony export */   "GRAPH_NODE_DOCS_PROVIDED": () => (/* binding */ GRAPH_NODE_DOCS_PROVIDED),
/* harmony export */   "GRAPH_REMOVE_CONSTANT": () => (/* binding */ GRAPH_REMOVE_CONSTANT),
/* harmony export */   "GRAPH_RESET": () => (/* binding */ GRAPH_RESET),
/* harmony export */   "GRAPH_SET_CAPACITY": () => (/* binding */ GRAPH_SET_CAPACITY),
/* harmony export */   "GRAPH_SET_CONSTANT": () => (/* binding */ GRAPH_SET_CONSTANT),
/* harmony export */   "PARSER_PARAMS_CHANGED": () => (/* binding */ PARSER_PARAMS_CHANGED),
/* harmony export */   "PARSING_PARAMS_CHANGED": () => (/* binding */ PARSING_PARAMS_CHANGED),
/* harmony export */   "PLAYGROUND_EFFECT_AUTOSAVE_REQUEST": () => (/* binding */ PLAYGROUND_EFFECT_AUTOSAVE_REQUEST),
/* harmony export */   "PLAYGROUND_EFFECT_HAS_BEEN_DROPPED": () => (/* binding */ PLAYGROUND_EFFECT_HAS_BEEN_DROPPED),
/* harmony export */   "PLAYGROUND_EFFECT_HAS_BEEN_SAVED": () => (/* binding */ PLAYGROUND_EFFECT_HAS_BEEN_SAVED),
/* harmony export */   "PLAYGROUND_EFFECT_SAVE_REQUEST": () => (/* binding */ PLAYGROUND_EFFECT_SAVE_REQUEST),
/* harmony export */   "PLAYGROUND_SELECT_EFFECT": () => (/* binding */ PLAYGROUND_SELECT_EFFECT),
/* harmony export */   "PLAYGROUND_SET_OPTION_AUTOSAVE": () => (/* binding */ PLAYGROUND_SET_OPTION_AUTOSAVE),
/* harmony export */   "PLAYGROUND_SET_SHADER_FORMAT": () => (/* binding */ PLAYGROUND_SET_SHADER_FORMAT),
/* harmony export */   "PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME": () => (/* binding */ PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME),
/* harmony export */   "PLAYGROUND_SWITCH_VM_RUNTIME": () => (/* binding */ PLAYGROUND_SWITCH_VM_RUNTIME),
/* harmony export */   "PLAYGROUND_TECHNIQUE_UPDATE": () => (/* binding */ PLAYGROUND_TECHNIQUE_UPDATE),
/* harmony export */   "S3D_CONNECT_P4": () => (/* binding */ S3D_CONNECT_P4),
/* harmony export */   "S3D_CONNECT_P4_SUCCESSED": () => (/* binding */ S3D_CONNECT_P4_SUCCESSED),
/* harmony export */   "S3D_INIT_ENV": () => (/* binding */ S3D_INIT_ENV),
/* harmony export */   "S3D_INIT_ENV_FAILED": () => (/* binding */ S3D_INIT_ENV_FAILED),
/* harmony export */   "S3D_INIT_ENV_SUCCESSED": () => (/* binding */ S3D_INIT_ENV_SUCCESSED),
/* harmony export */   "SOURCE_CODE_ADD_BREAKPOINT": () => (/* binding */ SOURCE_CODE_ADD_BREAKPOINT),
/* harmony export */   "SOURCE_CODE_ADD_MARKER": () => (/* binding */ SOURCE_CODE_ADD_MARKER),
/* harmony export */   "SOURCE_CODE_ADD_MARKER_BATCH": () => (/* binding */ SOURCE_CODE_ADD_MARKER_BATCH),
/* harmony export */   "SOURCE_CODE_ANALYSIS_COMPLETE": () => (/* binding */ SOURCE_CODE_ANALYSIS_COMPLETE),
/* harmony export */   "SOURCE_CODE_MODIFED": () => (/* binding */ SOURCE_CODE_MODIFED),
/* harmony export */   "SOURCE_CODE_PARSING_COMPLETE": () => (/* binding */ SOURCE_CODE_PARSING_COMPLETE),
/* harmony export */   "SOURCE_CODE_PREPROCESSING_COMPLETE": () => (/* binding */ SOURCE_CODE_PREPROCESSING_COMPLETE),
/* harmony export */   "SOURCE_CODE_REMOVE_BREAKPOINT": () => (/* binding */ SOURCE_CODE_REMOVE_BREAKPOINT),
/* harmony export */   "SOURCE_CODE_REMOVE_DEFINE": () => (/* binding */ SOURCE_CODE_REMOVE_DEFINE),
/* harmony export */   "SOURCE_CODE_REMOVE_MARKER": () => (/* binding */ SOURCE_CODE_REMOVE_MARKER),
/* harmony export */   "SOURCE_CODE_REMOVE_MARKER_BATCH": () => (/* binding */ SOURCE_CODE_REMOVE_MARKER_BATCH),
/* harmony export */   "SOURCE_CODE_SET_DEFINE": () => (/* binding */ SOURCE_CODE_SET_DEFINE),
/* harmony export */   "SOURCE_FILE_DROP_STATE": () => (/* binding */ SOURCE_FILE_DROP_STATE),
/* harmony export */   "SOURCE_FILE_LOADED": () => (/* binding */ SOURCE_FILE_LOADED),
/* harmony export */   "SOURCE_FILE_LOADING_FAILED": () => (/* binding */ SOURCE_FILE_LOADING_FAILED),
/* harmony export */   "SOURCE_FILE_REQUEST": () => (/* binding */ SOURCE_FILE_REQUEST)
/* harmony export */ });
const SOURCE_FILE_REQUEST = 'source-file-request';
const SOURCE_FILE_LOADED = 'source-file-loaded';
const SOURCE_FILE_LOADING_FAILED = 'source-file-loading-failed';
const SOURCE_FILE_DROP_STATE = 'source-file-drop-state';
const GRAMMAR_CONTENT_SPECIFIED = 'grammar-content-specified';
const PARSER_PARAMS_CHANGED = 'parser-params-changed';
const PARSING_PARAMS_CHANGED = 'parsing-params-changed';
const SOURCE_CODE_MODIFED = 'source-code-modified';
const SOURCE_CODE_PARSING_COMPLETE = 'source-code-parsing-complete';
const SOURCE_CODE_ANALYSIS_COMPLETE = 'source-code-analysis-complete';
const SOURCE_CODE_ADD_MARKER = 'source-code-add-marker';
const SOURCE_CODE_ADD_MARKER_BATCH = 'source-code-add-marker-batch';
const SOURCE_CODE_REMOVE_MARKER = 'source-code-remove-marker';
const SOURCE_CODE_REMOVE_MARKER_BATCH = 'source-code-remove-marker-batch';
const SOURCE_CODE_ADD_BREAKPOINT = 'source-code-add-breakpoint';
const SOURCE_CODE_REMOVE_BREAKPOINT = 'source-code-remove-breakpoint';
const SOURCE_CODE_SET_DEFINE = 'source-code-set-define';
const SOURCE_CODE_REMOVE_DEFINE = 'source-code-remove-define';
const SOURCE_CODE_PREPROCESSING_COMPLETE = 'source-code-preprocessing-complete';
const DEBUGGER_COMPILE = 'debugger-compile';
const DEBUGGER_START_DEBUG = 'debugger-start-debug';
// cancel compilation or jut clean up all previous results from store
const DEBUGGER_RESET = 'debugger-reset';
const DEBUGGER_COLORIZE = 'debugger-colorize';
const DEBUGGER_OPTIONS_CHANGED = 'debugger-options-changed';
const PLAYGROUND_TECHNIQUE_UPDATE = 'playground-technique-update';
const PLAYGROUND_SELECT_EFFECT = 'playground-select-effect';
const PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME = 'playground-force-destroy-and-switch-technique-runtime-type';
const PLAYGROUND_SWITCH_VM_RUNTIME = 'playground-force-destroy-and-switch-vm-runtime';
const PLAYGROUND_EFFECT_SAVE_REQUEST = 'playground-effect-save-request';
const PLAYGROUND_EFFECT_AUTOSAVE_REQUEST = 'playground-effect-autosave-request';
const PLAYGROUND_EFFECT_HAS_BEEN_SAVED = 'playground-effect-has-been-saved';
const PLAYGROUND_EFFECT_HAS_BEEN_DROPPED = 'playground-effect-has-been-dropped';
const PLAYGROUND_SET_OPTION_AUTOSAVE = 'playground-set-option-autosave';
const PLAYGROUND_SET_SHADER_FORMAT = 'playground-set-shader-format';
const GRAPH_LOADED = 'graph-loaded'; // serialized content of graph has been provided
const GRAPH_RESET = 'graph-reset'; // nothing 
const GRAPH_COMPILE = 'graph-compile'; // requst to generate and recompile (via default pipline with source content) code from graph
const GRAPH_MODIFIED = 'graph-modified';
const GRAPH_NODE_DOCS_PROVIDED = 'graph-node-docs-provided'; // update floating docs of selected graph node
const GRAPH_CHANGE_LAYOUT = 'graph-change-layout'; // update 'Part' structure
const GRAPH_ADD_CONSTANT = 'graph-add-constant';
const GRAPH_REMOVE_CONSTANT = 'graph-remove-constant';
const GRAPH_SET_CONSTANT = 'graph-set-constant';
const GRAPH_SET_CAPACITY = 'graph-set-capacity';
const S3D_INIT_ENV = 's3d-init-env';
const S3D_INIT_ENV_SUCCESSED = 's3d-init-env-successed';
const S3D_INIT_ENV_FAILED = 's3d-init-env-failed';
const S3D_CONNECT_P4 = 's3d-connect-p4';
const S3D_CONNECT_P4_SUCCESSED = 's3d-connect-p4-successed';
const DEPOT_UPDATE_REQUEST = 'depot-update-request';
const DEPOT_UPDATE_COMPLETE = 'depot-update-complete';


/***/ }),

/***/ "b/L/":
/*!**************************************!*\
  !*** ./src/sandbox/actions/index.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "depot": () => (/* binding */ depot),
/* harmony export */   "mapActions": () => (/* binding */ mapActions),
/* harmony export */   "nodes": () => (/* binding */ nodes),
/* harmony export */   "nodesForceRecompile": () => (/* binding */ nodesForceRecompile),
/* harmony export */   "nodesProvideDocs": () => (/* binding */ nodesProvideDocs),
/* harmony export */   "parser": () => (/* binding */ parser),
/* harmony export */   "playground": () => (/* binding */ playground),
/* harmony export */   "s3d": () => (/* binding */ s3d),
/* harmony export */   "sourceCode": () => (/* binding */ sourceCode)
/* harmony export */ });
/* harmony import */ var _sandbox_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/store */ "t4A9");
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! redux */ "n6ze");
/* harmony import */ var _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ActionTypeKeys */ "ceAs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_store__WEBPACK_IMPORTED_MODULE_0__]);
_sandbox_store__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



const parser = {
    setGrammar(content) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAMMAR_CONTENT_SPECIFIED, payload: { content } };
    },
    setParams(type, flags) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PARSER_PARAMS_CHANGED, payload: { type, flags } };
    },
    setParsingParams(flags) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PARSING_PARAMS_CHANGED, payload: { flags } };
    }
};
const sourceCode = {
    openFile(filename) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_FILE_REQUEST, payload: { filename } };
    },
    setContent(content, filename) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_MODIFED, payload: { content, filename } };
    },
    // setContent (content): IActionCreator {
    //     return async (dispatch: IDispatch, getState) => {
    //         await dispatch({ type: evt.SOURCE_CODE_MODIFED, payload: { content } });
    //         return getState();
    //     };
    // },
    // IP: Just an incredible example of a AC power!!
    // someRoutine (...argv): IActionCreator {
    //     return async (dispatch: IDispatch, getState) => {
    //         await dispatch({ type: 'some routine', payload: argv });
    //         return getState();
    //     };
    // },
    //
    // markers api
    //
    addMarker(marker) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_ADD_MARKER, payload: marker };
    },
    removeMarker(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_REMOVE_MARKER, payload: { name } };
    },
    //
    //
    //
    addBreakpoint(line) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_ADD_BREAKPOINT, payload: { line } };
    },
    removeBreakpoint(line) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_REMOVE_BREAKPOINT, payload: { line } };
    },
    //
    //
    //
    compile(query, type = 'expression') {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.DEBUGGER_COMPILE, payload: { query, type } };
    },
    specifyOptions(options) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.DEBUGGER_OPTIONS_CHANGED, payload: { options } };
    },
    //
    //
    //
    resetDebugger() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.DEBUGGER_RESET };
    },
    //
    //
    //
    setDefine(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_SET_DEFINE, payload: { name } };
    },
    removeDefine(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.SOURCE_CODE_REMOVE_DEFINE, payload: { name } };
    }
};
const playground = {
    selectEffect(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PLAYGROUND_SELECT_EFFECT, payload: { name } };
    },
    switchRuntime() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME };
    },
    saveFileAs() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PLAYGROUND_EFFECT_SAVE_REQUEST, payload: {} };
    },
    setAutosave(enabled) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PLAYGROUND_SET_OPTION_AUTOSAVE, payload: { enabled } };
    },
    setShaderFormat(format) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PLAYGROUND_SET_SHADER_FORMAT, payload: { format } };
    }
};
const nodes = {
    // is not being used at the moment
    reset() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_RESET, payload: {} };
    },
    // request full recompilationIGraph
    recompile() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_COMPILE, payload: {} };
    },
    changed() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_MODIFIED, payload: {} };
    },
    load(content) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_LOADED, payload: { content } };
    },
    provideNodeDocs(docs) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_NODE_DOCS_PROVIDED, payload: { docs } };
    },
    changeLayout(layout) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_CHANGE_LAYOUT, payload: { layout } };
    },
    addConstant(value) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_ADD_CONSTANT, payload: { value } };
    },
    removeConstant(name) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_REMOVE_CONSTANT, payload: { name } };
    },
    setConstant(name, value) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_SET_CONSTANT, payload: { name, value } };
    },
    setCapacity(value) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAPH_SET_CAPACITY, payload: { value } };
    }
};
const s3d = {
    initEnv(projectRoot) {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.S3D_INIT_ENV, payload: { projectRoot } };
    }
};
const depot = {
    rescan() {
        return { type: _ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.DEPOT_UPDATE_REQUEST, payload: {} };
    }
};
// hack to avoid looped imports
function nodesProvideDocs(docs) {
    _sandbox_store__WEBPACK_IMPORTED_MODULE_0__.store.dispatch(nodes.provideNodeDocs(docs));
}
// hack to avoid looped imports
function nodesForceRecompile() {
    _sandbox_store__WEBPACK_IMPORTED_MODULE_0__.store.dispatch(nodes.recompile());
}
function mapActions(actions) {
    return (dispatch) => {
        return {
            actions: (0,redux__WEBPACK_IMPORTED_MODULE_2__.bindActionCreators)(actions, dispatch),
            // debug functionality
            $dispatch: dispatch,
            $rowActions: actions
        };
    };
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "7071":
/*!********************************************!*\
  !*** ./src/sandbox/components/ASTView.tsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! copy-to-clipboard */ "Krap");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "hML2");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__]);
_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





class ASTView extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
    constructor(props) {
        super(props);
        this.state = {
            nodeStats: {}
        };
        this.rootRef = react__WEBPACK_IMPORTED_MODULE_2__.createRef();
    }
    componentDidUpdate() {
        // const rect = this.rootRef.current.getBoundingClientRect();
        // just a rude hack
        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;
    }
    shouldComponentUpdate(nextProps, nextState) {
        // TODO: implement it
        return true;
    }
    // tslint:disable-next-line:typedef
    render() {
        const slastDocument = this.props.sourceFile.slastDocument;
        const style = {
            height: 'calc(100vh - 205px)',
            overflowY: 'auto'
        };
        return (react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", { ref: this.rootRef },
            react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"], { style: style, selection: true, size: 'small', className: 'astlist' }, this.renderASTNode(slastDocument ? slastDocument.root : null))));
    }
    renderASTNode(node, idx = '0') {
        if (!node) {
            return null;
        }
        const { nodeStats } = this.state;
        const forceShow = idx.split('.').length < 2;
        const show = forceShow || (nodeStats[idx] || { opened: false, selected: false }).opened;
        const selected = (nodeStats[idx] || { opened: false, selected: false }).selected;
        if (node.value || node.children === null) {
            return (react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Item, { key: idx, onClick: this.handleNodeClick.bind(this, idx, node), onMouseOver: this.handleNodeOver.bind(this, idx, node), onMouseOut: this.handleNodeOut.bind(this, idx, node), className: 'astnode' },
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Icon, { style: { minWidth: '12px' } }),
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Header, null, node.name),
                    react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Description, null, node.value))));
        }
        else {
            let children = null;
            if (show) {
                children = (react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].List, { className: 'astlist' }, node.children.map((node, i) => this.renderASTNode(node, `${idx}.${i}`)).reverse()));
            }
            return (react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Item, { key: idx, onClick: this.handleNodeClick.bind(this, idx, node), onMouseOver: this.handleNodeOver.bind(this, idx, node), onMouseOut: this.handleNodeOut.bind(this, idx, node), className: 'astnode' },
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Icon, { name: (show ? `chevron down` : `chevron right`) }),
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Header, null,
                        node.name,
                        "\u00A0",
                        react__WEBPACK_IMPORTED_MODULE_2__.createElement("a", { href: '/', style: ({ display: (selected ? 'inline' : 'none') }), onClick: this.handleCopyClick.bind(this, idx, node) }, "Copy")),
                    children)));
        }
    }
    async handleCopyClick(idx, node, e) {
        e.preventDefault();
        e.stopPropagation();
        let out = [];
        out.push(`/**`);
        out.push(` * AST example:`);
        out.push(` *    ${node.name}`);
        out = out
            .concat(node.children.slice()
            .map(node => ` *       ${node.children ? '+' : ' '} ${node.name} ${node.value ? `= \'${node.value}\'` : ''}`));
        out.push(` */`);
        copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1___default()(out.join('\n'), { debug: true });
    }
    async handleNodeOver(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        let val = { opened: false, selected: false, ...nodeStats[idx] };
        val.selected = !val.selected;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
        this.props.onNodeOver(idx, node);
    }
    async handleNodeOut(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        const val = { opened: false, selected: false, ...nodeStats[idx] };
        val.selected = !val.selected;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
        this.props.onNodeOut(idx);
    }
    handleNodeClick(idx, node, e) {
        e.stopPropagation();
        let { nodeStats } = this.state;
        const val = { opened: false, selected: false, ...nodeStats[idx] };
        val.opened = !val.opened;
        nodeStats = { ...nodeStats, [idx]: val };
        this.setState({ nodeStats });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_0__.getCommon), {})(ASTView));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "/Qnb":
/*!*********************************************!*\
  !*** ./src/sandbox/components/CodeView.tsx ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");


const monacoOptions = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: true,
    theme: 'vs-dark',
    language: 'hlsl',
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: true,
    fontLigatures: true,
    readOnly: true
};
class CodeView extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
    render() {
        const content = this.props.content;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_1__["default"], { ref: 'monaco', value: content, width: '100%', height: 'calc(100vh - 63px)' // todo: fixme
            , options: monacoOptions }));
    }
}
// export const CodeView: React.FunctionComponent<ICodeViewProps> = ({ content }) =>
//     <MonacoEditor
//         ref='monaco'
//         value={ content }
//         width='100%'
//         height='calc(100vh - 67px)' // todo: fixme
//         options={ monacoOptions }
//     />;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodeView);


/***/ }),

/***/ "BJah":
/*!*************************************************!*\
  !*** ./src/sandbox/components/FileListView.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semantic-ui-react */ "hML2");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semantic-ui-react */ "21rH");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "35Nk");
/* tslint:disable:typedef */



const FileDirectoryIcon = 'file directory';
const FileCodeIcon = 'file code';
class FileListView extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(props) {
        super(props);
    }
    renderFolder(folder) {
        if (!folder || !folder.path || !folder.totalFiles) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Item, { key: folder.path },
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Icon, { className: FileDirectoryIcon }),
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Header, null, path__WEBPACK_IMPORTED_MODULE_0__.basename(folder.path)),
                react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].List, null,
                    (folder.folders || []).map(folder => this.renderFolder(folder)),
                    (folder.files || []).map(file => this.renderFile(file))))));
    }
    renderFile(file) {
        if (!file) {
            return null;
        }
        const { filters, search } = this.props;
        if (filters?.indexOf(path__WEBPACK_IMPORTED_MODULE_0__.extname(file)) == -1 || (search && file.indexOf(search) == -1)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Item, { as: 'a', onClick: () => this.props.onFileClick(file), key: file },
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Icon, { name: FileCodeIcon }),
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"].Header, null, path__WEBPACK_IMPORTED_MODULE_0__.basename(file)))));
    }
    render() {
        const props = this.props;
        const { root } = props;
        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", null,
            props.desc &&
                react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"], { as: 'h4', block: true },
                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"], { name: 'inbox' }),
                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Content, null, props.desc)),
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_2__["default"], { divided: true, celled: true }, this.renderFolder(root))));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileListView);


/***/ }),

/***/ "B87d":
/*!****************************************************!*\
  !*** ./src/sandbox/components/GraphConfigView.tsx ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "styles": () => (/* binding */ styles)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semantic-ui-react */ "21rH");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! semantic-ui-react */ "5+SC");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var _graphEx_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphEx/common */ "sVSU");
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "GU3W");
/* harmony import */ var _GraphConstants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GraphConstants */ "nRbc");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_3__, _GraphConstants__WEBPACK_IMPORTED_MODULE_8__]);
([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_3__, _GraphConstants__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












const styles = {};
const monacoOptions = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: { enabled: false },
    automaticLayout: true,
    glyphMargin: true,
    theme: 'vs',
    language: 'hlsl',
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: true,
    fontLigatures: true,
    readOnly: false,
    scrollbar: { vertical: 'auto' }
};
function Capacity({ value, onChange }) {
    const [ref, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(value);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: 'ui' },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { size: 'small', action: { basic: true, content: 'Set', color: 'green', onClick: e => onChange(ref) }, onChange: e => setValue(e.target.value), value: ref })));
}
class GraphConfigView extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
    async onChange(content, e) {
        // this.validate(content);
    }
    getEditor() {
        // don't know better way :/
        return this.refs.monaco.editor;
    }
    applyLayout() {
        const layout = this.getEditor().getValue();
        this.props.actions.changeLayout(layout);
    }
    setCapacity(value) {
        this.props.actions.setCapacity(Number(value) || 4096);
    }
    render() {
        const { nodes } = this.props;
        const { docs, env } = nodes;
        const type = env?.root.scope.findType(_graphEx_common__WEBPACK_IMPORTED_MODULE_6__.PART_TYPE);
        const tech = this.props.playground.technique;
        const emitter = tech;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { as: 'h5', attached: 'top' }, "Particle Layout"),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], { attached: true },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_1__["default"], { ref: 'monaco', value: _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_7__.CodeEmitter.translate(type), width: '100%', height: 'calc(150px)' // todo: fixme
                    , options: monacoOptions, onChange: this.onChange }),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__["default"], { onClick: this.applyLayout }, "Apply")),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { as: 'h5', attached: 'top' }, "User Constants"),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], { attached: true },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_GraphConstants__WEBPACK_IMPORTED_MODULE_8__["default"], null)),
            tech?.getType() === 'emitter' &&
                react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null,
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { as: 'h5', attached: 'top' }, "Emitter Properties"),
                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], { attached: 'bottom' },
                        "Emitter's capacity is ",
                        (emitter || { getCapacity() { return 0; } }).getCapacity(),
                        ".",
                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(Capacity, { value: (emitter || { getCapacity() { return 0; } }).getCapacity(), onChange: this.setCapacity })))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], GraphConfigView.prototype, "onChange", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], GraphConfigView.prototype, "applyLayout", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], GraphConfigView.prototype, "setCapacity", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_4__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__.mapActions)({ ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_3__.nodes }))((0,react_jss__WEBPACK_IMPORTED_MODULE_13__["default"])(styles)(GraphConfigView)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "nRbc":
/*!***************************************************!*\
  !*** ./src/sandbox/components/GraphConstants.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "styles": () => (/* binding */ styles)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! semantic-ui-react */ "ajfJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! semantic-ui-react */ "wi9p");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "f0+Q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semantic-ui-react */ "/d6T");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__]);
([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








const styles = {};
const types = [
    { key: 'float', value: 'float', text: 'float' },
    { key: 'int', value: 'int', text: 'int' },
    { key: 'uint', value: 'uint', text: 'uint' },
    { key: 'bool', value: 'bool', text: 'bool' },
];
function Constant({ desc, index, removeConst, setConst }) {
    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(desc.value);
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"], { raised: true },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"].Content, null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"].Header, null, desc.name),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"].Meta, null, desc.type)),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"].Content, { extra: true },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: 'ui' },
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["default"], { size: 'small', basic: true, color: 'red', onClick: () => removeConst(desc.name) }, "\u2715"),
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_7__["default"], { size: 'small', action: { basic: true, content: 'Set', color: 'green', onClick: e => setConst(desc.name, value) }, onChange: e => setValue(e.target.value), placeholder: desc.type, value: value })))));
}
function FormConstants({ addConstant }) {
    const [name, setName] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
    const [type, setType] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
    const handleSubmit = e => {
        e.preventDefault();
        if (!value || !name || !type)
            return;
        addConstant(name, type, value);
        setName("");
        setType("");
        setValue("");
    };
    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"], { size: 'tiny', key: 'tiny', onSubmit: handleSubmit },
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"].Group, { widths: 'equal' },
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"].Field, null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { placeholder: 'Select type', options: types, onChange: (e, data) => setType(data.value) })),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"].Field, null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_7__["default"], { placeholder: 'Name', value: name, onChange: e => setName(e.target.value) })),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"].Field, null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_7__["default"], { placeholder: 'Value', value: value, onChange: e => setValue(e.target.value) }))),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["default"], { type: 'submit' }, "Add"),
        react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], null)));
}
class Constants extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
    addConstant(name, type, value) {
        const desc = { name, type, value };
        this.props.actions.addConstant(desc);
    }
    ;
    removeConst(name) {
        this.props.actions.removeConstant(name);
    }
    ;
    setConst(name, value) {
        console.log(name, value);
        this.props.actions.setConstant(name, value);
    }
    ;
    render() {
        const { constants } = this.props.nodes;
        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormConstants, { addConstant: this.addConstant }),
            react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null,
                react__WEBPACK_IMPORTED_MODULE_0__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"].Group, { itemsPerRow: 2 }, constants.map((desc, index) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(Constant, { key: index, index: index, desc: desc, removeConst: this.removeConst, setConst: this.setConst })))))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_4__["default"]
], Constants.prototype, "addConstant", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_4__["default"]
], Constants.prototype, "removeConst", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_4__["default"]
], Constants.prototype, "setConst", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_1__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.mapActions)({ ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.nodes }))((0,react_jss__WEBPACK_IMPORTED_MODULE_11__["default"])(styles)(Constants)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "h7kT":
/*!**********************************************!*\
  !*** ./src/sandbox/components/GraphView.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var litegraph_js_css_litegraph_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! litegraph.js/css/litegraph.css */ "fDfE");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router */ "vpSu");
/* harmony import */ var _sandbox_styles_custom_fonts_OpenSans_stylesheet_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/styles/custom/fonts/OpenSans/stylesheet.css */ "N9h6");
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







// IP: same as `static title_mode = LiteGraph.AUTOHIDE_TITLE`;
// var title_mode = node.constructor.title_mode;
// (LGraphNode as any).title_mode = LiteGraph.AUTOHIDE_TITLE;
// (LGraphNode as any).title_mode = LiteGraph.TRANSPARENT_TITLE;
// (LGraphNode as any).title_mode = LiteGraph.NO_TITLE;
// var shape = node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;
// (LGraphNode as any).shape = LiteGraph.BOX_SHAPE;
// LiteGraph.debug = true;
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.catch_exceptions = true;
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.throw_errors = true;
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.allow_scripts = false; //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration); which could lead to exploits
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_TITLE_HEIGHT = 26;
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_TITLE_TEXT_Y = 18;
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_DEFAULT_COLOR = 'rgba(72, 201, 176, 0.5)';
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_DEFAULT_BGCOLOR = 'rgba(112, 123, 124, 0.5)';
litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.NODE_DEFAULT_BOXCOLOR = 'rgba(255, 0, 0, 0.0)';
// LiteGraph.NODE_TEXT_COLOR = 'rgba(255,255,255,0.75)';
// LiteGraph.LINK_COLOR = 'red';
// LiteGraph.EVENT_LINK_COLOR = 'red';
// LiteGraph.CONNECTING_LINK_COLOR = 'red';
// typescript bindding looks incomplete
let LiteGraphA = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph;
LiteGraphA.searchbox_extras = {}; //used to add extra features to the search box
LiteGraphA.auto_sort_node_types = true; // [true!] If set to true; will automatically sort node types / categories in the context menus
LiteGraphA.node_box_coloured_when_on = true; // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action); visual feedback
LiteGraphA.node_box_coloured_by_mode = true; // [true!] nodebox based on node mode; visual feedback
LiteGraphA.dialog_close_on_mouse_leave = true; // [false on mobile] better true if not touch device;
LiteGraphA.dialog_close_on_mouse_leave_delay = 500;
LiteGraphA.shift_click_do_break_link_from = false; // [false!] prefer false if results too easy to break links
LiteGraphA.click_do_break_link_to = false; // [false!]prefer false; way too easy to break links
LiteGraphA.search_hide_on_mouse_leave = true; // [false on mobile] better true if not touch device;
LiteGraphA.search_filter_enabled = true; // [true!] enable filtering slots type in the search widget; !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
LiteGraphA.search_show_all_on_open = true; // [true!] opens the results list when opening the search widget
LiteGraphA.auto_load_slot_types = true; // [if want false; use true; run; get vars values to be statically set; than disable] nodes types and nodeclass association with node types need to be calculated; if dont want this; calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
/*
// set these values if not using auto_load_slot_types
LiteGraphA.registered_slot_in_types = {};                   // slot types for nodeclass
LiteGraphA.registered_slot_out_types = {};                  // slot types for nodeclass
LiteGraphA.slot_types_in = [];                              // slot types IN
LiteGraphA.slot_types_out = [];                             // slot types OUT
*/
LiteGraphA.alt_drag_do_clone_nodes = true; // [true!] very handy; ALT click to clone and drag the new node
LiteGraphA.do_add_triggers_slots = true; // [true!] will create and connect event slots when using action/events connections; !WILL CHANGE node mode when using onTrigger (enable mode colors); onExecuted does not need this
LiteGraphA.allow_multi_output_for_events = true; // [false!] being events; it is strongly reccomended to use them sequentually; one by one
LiteGraphA.middle_click_slot_add_default_node = true; // [true!] allows to create and connect a ndoe clicking with the third button (wheel)
LiteGraphA.release_link_on_empty_shows_menu = true; // [true!] dragging a link to empty space will open a menu, add from list, search or defaults
LiteGraphA.pointerevents_method = "mouse"; // "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now)
LiteGraphA.middle_click_canvas_dragging = true;
// LiteGraph.draw_invisible_connections = true;
const styles = {
    sizing: {
        width: '100%',
        height: 'calc(100vh - 63px)',
        background: '#333'
    }
};
let GraphView = class GraphView extends react__WEBPACK_IMPORTED_MODULE_3__.Component {
    constructor(props) {
        super(props);
        this.canvasRef = react__WEBPACK_IMPORTED_MODULE_3__.createRef();
        this.divRef = react__WEBPACK_IMPORTED_MODULE_3__.createRef();
    }
    get graph() {
        return this.props.graph;
    }
    setupCanvas() {
        this.canvas = new litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LGraphCanvas("#node-graph-canvas", this.graph);
        this.canvas.show_info = true;
        // this.canvas.use_gradients = true;
        this.canvas.allow_reconnect_links = true;
        this.canvas.links_render_mode = litegraph_js__WEBPACK_IMPORTED_MODULE_1__.LiteGraph.LINEAR_LINK;
        this.canvas.round_radius = 4;
        this.canvas.render_link_tooltip = false;
        this.canvas.render_link_center = false;
        this.canvas.over_link_center = null;
        this.canvas.title_text_font = "13px 'Open Sans'";
        this.canvas.inner_text_font = "13px 'Open Sans'";
        this.canvas.node_title_color = 'rgba(255,255,255,0.75)';
        this.canvas.title_shadow_blur = 4;
        this.canvas.title_shadow_offset_x = 1;
        this.canvas.title_shadow_offset_y = 1;
        this.canvas.title_shadow_color = '#111';
        this.canvas.render_collapsed_slots = true;
        // this.canvas.render_connection_arrows = true;
        // (this.canvas as any).align_to_grid = true;
    }
    setupTypesColoring() {
        // const palette = { 
        //     "Cadet Blue": "#51a3a3", 
        //     "Steel Teal": "#5A8D92",
        //     "Slate Gray": "#637681", 
        //     "Old Lavender": "#6c5f70", 
        //     "Eggplant": "#75485e", 
        //     "Blast Off Bronze": "#a06c56",
        //     "Persian Orange": "#cb904d", 
        //     "Sunray": "#d5ae61", 
        //     "Arylide Yellow": "#dfcc74", 
        //     "Yellow Green Crayola": "#c3e991" 
        // };
        // (this.canvas as any).default_connection_color_byType = {
        //     uint: palette["Cadet Blue"],
        //     int: palette["Steel Teal"],
        //     int2: palette["Slate Gray"],
        //     bool: palette["Old Lavender"],
        //     float: palette["Eggplant"],
        //     float2: palette["Blast Off Bronze"],
        //     float3: palette["Sunray"],
        //     float4: palette["Arylide Yellow"]
        // };
    }
    setupListeners() {
        // (this.canvas as any).onAfterChange = () => { console.log('canvas change detected!'); }
        // (this.graph as any).onAfterChange = () => { console.log('graph change detected!'); }
        // (this.canvas as any).onNodeConnectionChange = () => { console.log('canvas connection change detected!'); }
        // (this.graph as any).onNodeConnectionChange = () => { console.log('graph connection change detected!'); }
        // (this.canvas as any).onBeforeChange = () => { console.log('canvas b change detected!'); }
        // (this.graph as any).onBeforeChange = () => { console.log('graph b change detected!'); }
        // todo: move to redux logic
        // notify store that graph have to be update
        // (this.graph as any).onNodeConnectionChange = () => { this.execute(); }
        this.graph.onAfterChange = this.props.onChange;
    }
    componentDidMount() {
        this.setupCanvas();
        this.setupTypesColoring();
        this.setupListeners();
        // execute graph on ctrl+enter
        document.addEventListener('keypress', this.onKeypress);
        // draw graph of correct size
        window.addEventListener('resize', this.onWindowResize, false);
        this.onWindowResize();
        // trick to force redraw when font is loaded
        document.fonts.onloadingdone = () => {
            if (document.fonts.check("13px 'Open Sans'")) {
                this.canvas.draw(true, true);
            }
        };
        // IP: fix of unknown problem with keydown event which doen't work without this magic.
        this.canvasRef.current.setAttribute("tabindex", '0');
    }
    shouldComponentUpdate(nextProps, nextState, nextContext) {
        return this.divRef.current.clientHeight != this.canvasRef.current.height;
    }
    componentDidUpdate(prevProps, prevState, snapshot) {
        this.canvas.resize();
    }
    onKeypress(e) {
        // ctrl+enter
        if (e.ctrlKey && e.keyCode == 10) {
            e.preventDefault();
            this.props.onExecute();
        }
    }
    onWindowResize() {
        this.canvas.resize();
    }
    componentWillUnmount() {
        window.removeEventListener('resize', this.onWindowResize, false);
        document.removeEventListener('keypress', this.onKeypress);
    }
    render() {
        return (react__WEBPACK_IMPORTED_MODULE_3__.createElement("div", { ref: this.divRef, className: `litegraph  ${this.props.classes.sizing}` },
            react__WEBPACK_IMPORTED_MODULE_3__.createElement("canvas", { ref: this.canvasRef, id: 'node-graph-canvas' })));
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_0__["default"]
], GraphView.prototype, "onKeypress", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_0__["default"]
], GraphView.prototype, "onWindowResize", null);
GraphView = __decorate([
    react_router__WEBPACK_IMPORTED_MODULE_5__.withRouter
], GraphView);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_jss__WEBPACK_IMPORTED_MODULE_6__["default"])(styles)(GraphView));


/***/ }),

/***/ "87NW":
/*!***********************************************!*\
  !*** ./src/sandbox/components/MemoryView.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "styles": () => (/* binding */ styles)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "OXt0");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__]);
([_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);





const styles = {
    memoryVal: {
        display: `inline-block`,
        textAlign: `center`,
        zoom: 1
    }
};
class MemoryView extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    render() {
        if (!this.props.bcDocumnet.program) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"], { unstackable: true, fixed: true, style: { fontFamily: 'consolas, monospace', border: '0' } },
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Body, null, this.renderContent())));
    }
    renderContent() {
        const { props } = this;
        const bundle = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.make(`[memory-view]`, props.bcDocumnet.program.code);
        if (!bundle) {
            console.error(`could not create bundle`);
            return null;
        }
        // temp hack to fix problem with unset CBUFFER0_REGISTER input if wasm bundle is used
        // without it bundle.getInput(CBUFFER0_REGISTER) return no input
        bundle.setConstant("[dummy]", new Uint8Array());
        const binaryData = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.memoryToU8Array(bundle.getInput(_lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_0__.CBUFFER0_REGISTER));
        const layout = bundle.getLayout();
        const WIDTH_MAX = 12;
        const u8view = new Uint8Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        // const f32view = new Float32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        // const i32view = new Int32Array(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
        let n = 0;
        let rows = [];
        let columns = [];
        let colLen = 0;
        let bLeftClosed;
        let bRightClosed;
        layout.map((constant, i) => {
            let written = 0;
            bLeftClosed = columns.length === 0;
            do {
                const segWidth = Math.min(constant.size - written, WIDTH_MAX - colLen);
                const n4 = n >> 2;
                const content = [];
                for (let i = 0; i < segWidth; ++i) {
                    content.push(react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { key: `mvk-d-${n}`, className: `${props.classes.memoryVal}`, style: { width: `${100 / segWidth}%` } }, `${u8view[n] < 16 ? '0' : ''}${u8view[n++].toString(16).toUpperCase()}`));
                    written++;
                }
                bRightClosed = written >= constant.size;
                const style = {
                    padding: 0,
                    borderLeft: `1px solid ${bLeftClosed ? '#ccc' : 'transparent'}`,
                    borderRight: `1px solid ${bRightClosed ? '#ccc' : 'transparent'}`,
                    borderTop: `${rows.length === 0 ? 1 : 0}px solid #ccc`,
                    borderBottom: `1px solid #ccc`,
                };
                columns.push(react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Cell, { key: `mvk-tc-${colLen}`, textAlign: "center", colSpan: segWidth, style: style },
                    react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"], { inverted: true, content: react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { style: { fontFamily: 'consolas, monospace' } }, constant.name), trigger: react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", { style: { opacity: 0.5 } }, content) })));
                colLen += segWidth;
                bLeftClosed = false;
                if (n % WIDTH_MAX === 0) {
                    rows.push(react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Row, { key: `mvk-tc-${rows.length}` }, columns));
                    columns = [];
                    colLen = 0;
                }
            } while (written < constant.size);
        });
        if (columns.length > 0) {
            const csRest = WIDTH_MAX - n % WIDTH_MAX;
            if (csRest !== WIDTH_MAX) {
                columns.push(react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Cell, { key: `mvk-tc-${colLen}`, textAlign: "center", colSpan: csRest, style: { padding: 0 } }));
            }
            rows.push(react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Row, { key: `mvk-tc-${rows.length}` }, columns));
        }
        return rows;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_jss__WEBPACK_IMPORTED_MODULE_5__["default"])(styles)(MemoryView));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "qjqD":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/PreprocessorView.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/path/path */ "U50j");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! copy-to-clipboard */ "Krap");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "3GrG");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! semantic-ui-react */ "hML2");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! semantic-ui-react */ "OXt0");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_1__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_1__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










const styles = {
    checkboxTiny: {
        fontSize: '0.92857143em !important',
        lineHeight: '15px !important',
        minWidth: '17px !important',
        transform: 'scale(0.85) !important',
        transformOrigin: 'left !important',
        minHeight: 'auto !important'
    },
    // checkboxTinyChanged: {
    //     fontSize: '0.92857143em !important',
    //     lineHeight: '15px !important',
    //     minWidth: '17px !important',
    //     transform: 'scale(0.85) !important',
    //     transformOrigin: 'left !important',
    //     minHeight: 'auto !important',
    //     fontWeight: 'bold'
    // }
    tipFix: {
        transform: 'scale(0.85) !important',
        display: 'inline-block',
        position: 'relative',
        left: '-11%'
    }
};
class PPView extends react__WEBPACK_IMPORTED_MODULE_5__.Component {
    constructor(props) {
        super(props);
        this.state = {
            showIncludes: false,
            showMacros: true,
            showMacrosOther: false,
            showUnreachableCode: false,
            filter: null,
            custom: false,
            showCopy: false
        };
        this.rootRef = react__WEBPACK_IMPORTED_MODULE_5__.createRef();
    }
    autosetDefines() {
        const { content } = this.props.sourceFile;
        const kw = `// defines:`;
        const start = content.indexOf(kw);
        if (start == -1)
            return;
        let pos = start + kw.length;
        let defs = [];
        let def = '';
        while (true) {
            let c = content[pos++];
            if (c == ' ')
                continue;
            if (c == ',') {
                defs.push(def);
                def = '';
                continue;
            }
            ;
            if (c == '\n' || c == '\r' || !c) {
                defs.push(def);
                break;
            }
            ;
            def += c;
        }
        defs.forEach(name => name && this.props.actions.setDefine(name));
    }
    render() {
        const slastDocument = this.props.sourceFile.slastDocument;
        if (!slastDocument) {
            return null;
        }
        const includes = slastDocument.includes;
        const macros = slastDocument.macros;
        const unresolvedMacros = slastDocument.unresolvedMacros;
        const unreachableCode = slastDocument.unreachableCode;
        const { showIncludes, showMacros, showUnreachableCode } = this.state;
        const style = {
            height: 'calc(100vh - 205px)',
            overflowY: 'auto'
        };
        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement("div", { ref: this.rootRef },
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_8__["default"], { size: 'small', iconPosition: 'left', placeholder: 'Filter...', onChange: (e) => { this.setState({ filter: e.target.value }); } }),
            "\u00A0",
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { label: 'Customs', onClick: (e, { checked }) => this.setState({ custom: checked }) }),
            " \u00A0\u00A0",
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { basic: true, onClick: () => this.autosetDefines() }, "scan"),
            " \u00A0\u00A0",
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], { style: style, selection: true, size: 'small', className: 'astlist' },
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-include-list`, className: 'astnode', onClick: this.handleIncludesClick },
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Icon, { name: (showIncludes ? `chevron down` : `chevron right`) }),
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Header, null, 'Include list'),
                        this.renderIncludes(includes))),
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-macros`, className: 'astnode', onClick: this.handleMacrosClick, onMouseOver: e => this.setState({ showCopy: true }), onMouseOut: e => this.setState({ showCopy: false }) },
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Icon, { name: (showMacros ? `chevron down` : `chevron right`) }),
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Header, null,
                            'Macro list',
                            "\u00A0",
                            (this.state.showCopy || 1) && react__WEBPACK_IMPORTED_MODULE_5__.createElement("a", { onClick: this.handleMacroListCopyClick }, "[copy customs]")),
                        this.renderMacros(macros.concat(unresolvedMacros).sort((a, b) => a.name.localeCompare(b.name))))),
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-unreachable-code`, className: 'astnode', onClick: this.handleUnreachableCodeClick },
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Icon, { name: (showUnreachableCode ? `chevron down` : `chevron right`) }),
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Header, null, 'Unreachable regions'),
                        this.renderUnreachableRegions(unreachableCode))))));
    }
    renderIncludes(includes) {
        if (!this.state.showIncludes) {
            return null;
        }
        const items = [...includes.keys()].map((filename, i) => (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-include-${i}`, 
            // onClick={ this.handleNodeClick.bind(this, idx, node) }
            // onMouseOver={ this.handleNodeOver.bind(this, idx, node) }
            // onMouseOut={ this.handleNodeOut.bind(this, idx, node) }
            className: 'astnode' },
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Description, null, _lib_path_path__WEBPACK_IMPORTED_MODULE_0__.normalize(filename))))));
        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].List, { className: 'astlist' }, items));
    }
    handleMacroListCopyClick(e) {
        e.preventDefault();
        e.stopPropagation();
        const { sourceFile } = this.props;
        const slastDocument = sourceFile.slastDocument;
        if (!slastDocument) {
            return;
        }
        const doFilter = (value) => sourceFile.defines.find(def => def === value);
        const macros = slastDocument.macros.filter(macro => macro.bRegionExpr && doFilter(macro.name));
        if (!macros.length) {
            console.warn('No custom macros were defined.');
            return;
        }
        const value = macros.map(macros => macros.name).join('\n');
        copy_to_clipboard__WEBPACK_IMPORTED_MODULE_4___default()(value, { debug: true });
        console.log(value);
        // console.log(macros.filter(macro => macro.bRegionExpr && doFilter(macro.name)));
        (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_7__.toast)({
            size: 'tiny',
            type: 'info',
            title: `Macro list copied.`,
            animation: 'bounce',
            time: 1000
        });
    }
    handleBoolMacroClick(macro, checked) {
        if (checked)
            this.props.actions.setDefine(macro.name);
        else
            this.props.actions.removeDefine(macro.name);
    }
    renderMacros(macros) {
        if (!this.state.showMacros) {
            return null;
        }
        if (macros.length === 0) {
            return null;
        }
        const { showMacrosOther } = this.state;
        const { sourceFile } = this.props;
        const filter = this.state.filter?.toLowerCase();
        const custom = this.state.custom;
        const doFilter = (value) => (!custom || sourceFile.defines.find(def => def === value)) &&
            (!filter || (value.toLowerCase()).indexOf(filter) !== -1);
        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].List, { className: 'astlist' },
            macros.filter(macro => macro.bRegionExpr && doFilter(macro.name)).map((macro, i) => (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-macro-${i}`, 
                // onClick={ this.handleNodeClick.bind(this, idx, node) }
                // onMouseOver={ this.handleNodeOver.bind(this, idx, node) }
                // onMouseOut={ this.handleNodeOut.bind(this, idx, node) }
                className: 'astnode' },
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Description, null,
                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { label: macro.name, checked: !!macro.tokens, disabled: !!macro.tokens && !sourceFile.defines.find(def => def === macro.name), onClick: e => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.handleBoolMacroClick(macro, !macro.tokens);
                            }, className: this.props.classes.checkboxTiny }),
                        (macro.tokens?.length > 0) &&
                            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__["default"], { inverted: true, content: react__WEBPACK_IMPORTED_MODULE_5__.createElement("span", null, `${macro.name}${macro.params ? `(${macro.params.join(' ,')})` : ``} ${(macro.tokens || []).map(tk => tk.value).join(' ')}`), trigger: react__WEBPACK_IMPORTED_MODULE_5__.createElement("span", { className: this.props.classes.tipFix }, `(?)`) })))))),
            !custom &&
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-macros-other`, className: 'astnode', onClick: this.handleMacrosOtherClick },
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Icon, { name: (showMacrosOther ? `chevron down` : `chevron right`) }),
                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Header, null, 'other...'),
                        showMacrosOther &&
                            macros.filter(macro => !macro.bRegionExpr && doFilter(macro.name)).map((macro, i) => (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-macro-${i}`, 
                                // onClick={ this.handleNodeClick.bind(this, idx, node) }
                                // onMouseOver={ this.handleNodeOver.bind(this, idx, node) }
                                // onMouseOut={ this.handleNodeOut.bind(this, idx, node) }
                                className: 'astnode' },
                                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                                    react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Description, null,
                                        react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__["default"], { inverted: true, content: react__WEBPACK_IMPORTED_MODULE_5__.createElement("span", null, `${macro.name}${macro.params ? `(${macro.params.join(' ,')})` : ``} ${(macro.tokens || []).map(tk => tk.value).join(' ')}`), trigger: react__WEBPACK_IMPORTED_MODULE_5__.createElement("span", null, `${macro.name}`) }))))))))));
    }
    renderUnreachableRegions(regions) {
        if (!this.state.showUnreachableCode) {
            return null;
        }
        const items = regions.map(({ start, end }, i) => (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Item, { key: `pp-include-${i}`, 
            // onClick={ this.handleNodeClick.bind(this, idx, node) }
            // onMouseOver={ this.handleNodeOver.bind(this, idx, node) }
            // onMouseOut={ this.handleNodeOut.bind(this, idx, node) }
            className: 'astnode' },
            react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Content, null,
                react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Description, null,
                    _lib_path_path__WEBPACK_IMPORTED_MODULE_0__.parse(start.file.toString()).filename,
                    ` (${start.line} - ${end.line})`)))));
        return (react__WEBPACK_IMPORTED_MODULE_5__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].List, { className: 'astlist' }, items));
    }
    handleIncludesClick(e) {
        e.stopPropagation();
        const { showIncludes } = this.state;
        this.setState({ showIncludes: !showIncludes });
    }
    handleUnreachableCodeClick(e) {
        e.stopPropagation();
        const { showUnreachableCode } = this.state;
        this.setState({ showUnreachableCode: !showUnreachableCode });
    }
    handleMacrosOtherClick(e) {
        e.stopPropagation();
        const { showMacrosOther } = this.state;
        this.setState({ showMacrosOther: !showMacrosOther });
    }
    handleMacrosClick(e) {
        e.stopPropagation();
        const { showMacros } = this.state;
        this.setState({ showMacros: !showMacros });
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleMacroListCopyClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleBoolMacroClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleIncludesClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleUnreachableCodeClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleMacrosOtherClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_3__["default"]
], PPView.prototype, "handleMacrosClick", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_1__.mapActions)(_sandbox_actions__WEBPACK_IMPORTED_MODULE_1__.sourceCode))((0,react_jss__WEBPACK_IMPORTED_MODULE_13__["default"])(styles)(PPView)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "/g6V":
/*!************************************************!*\
  !*** ./src/sandbox/components/ProgramView.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "hML2");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semantic-ui-react */ "35Nk");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! semantic-ui-react */ "3GrG");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! semantic-ui-react */ "g3Zx");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__]);
([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:typedef */
/* tslint:disable:use-simple-attributes */
/* tslint:disable:react-a11y-event-has-role */
/* tslint:disable:no-for-in */
/* tslint:disable:cyclomatic-complexity */











const styles = {
    parentIcon: {
        '&:hover': {
            textShadow: '1px 1px 1px #ccc'
        }
    }
};
const PropertyStyles = {
    selected: {
    // backgroundColor: `rgba(128, 128, 128, 0.125)`,
    // boxShadow: `0 0 3px rgba(55, 55, 55, 0.33)`,
    // borderRadius: `2px`
    },
    system: {
    // opacity: '0.75'
    }
};
function PropertyStyle(names) {
    let styles = {};
    for (let k in names) {
        if (names[k] && PropertyStyles[k]) {
            styles = { ...styles, ...PropertyStyles[k] };
        }
    }
    return styles;
}
function prettifyEName(econstName) {
    let m;
    return (m = /k_([a-zA-Z]+)/g.exec(econstName), (m && m[1]) || econstName);
}
const Property = ({ name, value, children, onMouseOver, onMouseOut, onClick, selected, opened, system, parent, onParentMouseDown, onParentMouseUp, classes }) => {
    let iconName = system ? `code` : ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(children) ? `chevron down` : `code`);
    const isHelper = !onClick;
    const simpleProperty = (value && !children); // && !parent;
    const helperProperty = (!value && children) && isHelper;
    const showIcon = !simpleProperty && !helperProperty;
    if (!children) {
        opened = true;
    }
    if (opened === false) {
        iconName = 'chevron right';
        children = null;
    }
    return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Item, { className: 'astnode', onMouseOver: onMouseOver, onMouseOut: onMouseOut, onClick: onClick, style: { ...PropertyStyle({ selected, system }), ...(simpleProperty ? { fontSize: '85%' } : {}) } },
        showIcon &&
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Icon, { className: iconName }),
        react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Content, null,
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(name) &&
                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Header, { style: helperProperty ? { fontSize: '85%', color: '#ccc' } : {} },
                    parent &&
                        react__WEBPACK_IMPORTED_MODULE_7__.createElement("span", null,
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement("a", { style: { color: 'rgba(0,0,0,0.3)' }, onMouseOver: onParentMouseDown, onMouseOut: onParentMouseUp },
                                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { className: `git pull request ${classes.parentIcon}`, size: 'small' }))),
                    helperProperty ? `[${name}]` : name),
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(value) &&
                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Description, null, value),
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(children) &&
                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].List, { className: 'astlist' }, children))));
};
const isNotEmptyArray = (arr) => (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isArray)(arr) || (arr).length > 0);
const PropertyOpt = (props) => {
    const { value, children } = props;
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(value) || ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(children) && isNotEmptyArray(children))) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...props }));
    }
    return null;
};
const SystemProperty = (props) => {
    return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { ...props, system: true }, props.children));
};
class ProgramView extends react__WEBPACK_IMPORTED_MODULE_7__.Component {
    constructor(props) {
        super(props);
        this.documentCache = null;
        this.state = {
            instrList: {},
            fns: true,
            vars: true,
            types: true,
            cbs: true,
            filter: null
        };
        this.rootRef = react__WEBPACK_IMPORTED_MODULE_7__.createRef();
    }
    shouldComponentUpdate(nextProps, nextState) {
        return this.documentCache !== nextProps.slDocument ||
            this.state.fns != nextState.fns ||
            this.state.vars != nextState.vars ||
            this.state.types != nextState.types ||
            this.state.cbs != nextState.cbs ||
            this.state.filter != nextState.filter;
    }
    componentDidUpdate() {
        this.documentCache = this.props.slDocument;
        // const rect = this.rootRef.current.getBoundingClientRect();
        // just a rude hack
        // this.rootRef.current.style.height = `calc(100vh - ${Math.floor(rect.top) + 50}px)`;
    }
    render() {
        const { slDocument: analysis } = this.props;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(analysis)) {
            return null;
        }
        const root = analysis.root;
        const style = {
            height: 'calc(100vh - 205px)',
            overflowY: 'auto'
        };
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement("div", { ref: this.rootRef },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], { compact: true, basic: 'very' },
                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Body, null,
                    react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Row, null,
                        react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Cell, { collapsing: true },
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_12__["default"], { placeholder: 'Filter...', onChange: (e) => { this.setState({ filter: e.target.value }); } })),
                        react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Cell, { collapsing: true },
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"], { label: 'Fn', defaultChecked: true, onClick: (e, { checked }) => this.setState({ fns: checked }) }),
                            " \u00A0\u00A0",
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"], { label: 'Var', defaultChecked: true, onClick: (e, { checked }) => this.setState({ vars: checked }) }),
                            " \u00A0\u00A0",
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"], { label: 'Cb', defaultChecked: true, onClick: (e, { checked }) => this.setState({ cbs: checked }) }),
                            " \u00A0\u00A0",
                            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"], { label: 'Type', defaultChecked: true, onClick: (e, { checked }) => this.setState({ types: checked }) }),
                            " \u00A0\u00A0")))),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { style: style, selection: true, size: 'small', className: 'astlist' }, this.InstructionCollector(root))));
    }
    Unknown(instr) {
        if (!instr) {
            return null;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_Collector:
                return this.InstructionCollector(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_TypeDecl:
                return this.TypeDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_TypedefDecl:
                return this.TypedefDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ComplexType:
                return this.ComplexType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_Provide:
                return this.ProvideDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_CbufferDecl:
                return this.CbufferDecl(instr);
            // @deprecated    
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_TechniqueDecl:
                return this.Technique(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_Technique11Decl:
                return this.Technique11(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_VariableDecl:
                return this.VariableDecl(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_VariableType:
                return this.VariableType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_SystemType:
                return this.SystemType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_FunctionDecl:
                return this.FunctionDecl(instr);
            //
            // Expressions
            //
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_InitExpr:
                return this.InitExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_StateBlockExpr:
                return this.StateBlockExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_CompileShader11Expr:
                return this.CompileShader11Expr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_IdExpr:
                return this.IdExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_PostfixPointExpr:
                return this.PostfixPointExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_PostfixIndexExpr:
                return this.PostfixIndexExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_AssignmentExpr:
                return this.Assigment(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_PostfixArithmeticExpr:
                return this.PostfixArithmetic(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ConstructorCallExpr:
                return this.ConstructorCall(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_IntExpr:
                return this.Int(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_FloatExpr:
                return this.Float(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_StringExpr:
                return this.String(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_BoolExpr:
                return this.Bool(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ArithmeticExpr:
                return this.ArithmeticExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_BitwiseExpr:
                return this.BitwiseExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_CastExpr:
                return this.Cast(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ComplexExpr:
                return this.ComplexExpr(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_FunctionCallExpr:
                return this.FunctionCall(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_RelationalExpr:
                return this.Relational(instr);
            default:
                return this.NotImplemented(instr);
        }
    }
    InstructionCollector(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { ...this.bindProps(instr, true), name: 'Program' }, (instr.instructions || []).map((instr) => {
            const { vars, cbs, types, fns, filter } = this.state;
            if (filter) {
                if (!instr.name?.includes(filter)) {
                    return null;
                }
            }
            switch (instr.instructionType) {
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_VariableDecl:
                    if (!vars)
                        return null;
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_CbufferDecl:
                    if (!cbs)
                        return null;
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_TypeDecl:
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_TypedefDecl:
                    if (!types)
                        return null;
                    break;
                case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_FunctionDecl:
                    if (!fns)
                        return null;
                    break;
            }
            return this.Unknown(instr);
        })));
    }
    ProvideDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'moduleName', value: instr.moduleName })));
    }
    TypeDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), name: 'type' }, this.Unknown(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'name', value: instr.name })));
    }
    TypedefDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), name: 'type' }, this.Unknown(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'alias', value: instr.alias })));
    }
    CbufferDecl(instr) {
        const reg = _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.resolveRegister(instr);
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'size', value: instr.type.size }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'register', value: `${reg.type}${reg.index}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { ...this.bindProps(instr), name: 'fields' }, instr.type.fields.map((field) => this.Unknown(field)))));
    }
    ComplexType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'aligment', value: instr.aligment }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { ...this.bindProps(instr), name: 'fields' }, instr.fields.map((field) => this.Unknown(field))),
            this.typeInfo(instr)));
    }
    // todo: implement it properly
    SystemType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) }, this.typeInfo(instr)));
    }
    typeInfo(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { ...this.bindProps(instr, false), name: _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.types.signature(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'writable', value: `${instr.writable}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'readable', value: `${instr.readable}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'size', value: `${instr.size === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_SIZE ? 'undef' : instr.size} bytes` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'length', value: `${instr.length === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_LENGTH ? 'undef' : instr.length}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'array', value: `${instr.isArray()}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { name: 'complex', value: `${instr.isComplex()}` }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'element type' }, this.Unknown(instr.arrayElementType)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'methods' }, instr.methods.map(method => _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.fn.signatureEx(method.def, true))
                .map((signature, i) => react__WEBPACK_IMPORTED_MODULE_7__.createElement(SystemProperty, { key: `pv-uk-sp-${instr.instructionID}-${i}`, name: react__WEBPACK_IMPORTED_MODULE_7__.createElement("span", null, "\u00A0\u00A0"), value: signature })))));
    }
    /** @deprecated */
    Pass(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'name', value: instr.name })));
    }
    Pass11(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'impl' }, this.StmtBlock(instr.impl))));
    }
    /** @deprecated */
    Technique(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'passes' }, instr.passes?.map((pass) => this.Pass(pass)))));
    }
    Technique11(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'passes' }, instr.passes?.map((pass) => this.Pass11(pass)))));
    }
    VariableDecl(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr))
            return null;
        const isUniform = instr.isGlobal() && (!instr.type.isStatic() || instr.type.isUniform());
        const icCbuffer = !!(instr.usageFlags & _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_2__.EVariableUsageFlags.k_Cbuffer);
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'id', value: instr.id.toString() }),
            instr.isConstant() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'constant', value: 'true' }),
            instr.isGlobal() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'global', value: String(instr.isGlobal()) }),
            instr.isParameter() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'parameter', value: String(instr.isParameter()) }),
            isUniform && react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'uniform', value: String(isUniform) }),
            icCbuffer && react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'cbuffer', value: String(icCbuffer) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'type', opened: true }, this.VariableType(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'init', opened: true }, this.Unknown(instr.initExpr)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'annotations', opened: true }, this.Annotation(instr.annotation))));
    }
    FunctionDecl(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, false), value: instr.name },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'attributes' }, instr.attrs.map((attr) => this.Attribute(attr))),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'definition' }, this.FunctionDefinition(instr.def)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'implementation' }, this.StmtBlock(instr.impl))));
    }
    IdExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            this.Id(instr.id),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'declaration' }, this.Unknown(instr.decl))));
    }
    Id(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), name: 'name', value: instr.name }));
    }
    PostfixPointExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'element' }, this.Unknown(instr.element)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'postfix' }, this.Unknown(instr.postfix))));
    }
    PostfixIndexExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'element' }, this.Unknown(instr.element)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'index' }, this.Unknown(instr.index))));
    }
    Assigment(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'lval' }, this.Unknown(instr.left)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'rval' }, this.Unknown(instr.right))));
    }
    PostfixArithmetic(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    ConstructorCall(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'type' }, this.VariableType(instr.ctor)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'arguments' }, instr.args.map((arg) => this.Unknown(arg)))));
    }
    ArithmeticExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operands' },
                this.Unknown(instr.left),
                this.Unknown(instr.right))));
    }
    BitwiseExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operands' },
                this.Unknown(instr.left),
                this.Unknown(instr.right))));
    }
    Cast(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'type' }, this.Type(instr.type)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    ComplexExpr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'expr' }, this.Unknown(instr.expr))));
    }
    FunctionCall(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'declaration' }, this.FunctionDecl(instr.decl)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'callee' }, this.Unknown(instr.callee)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'arguments' }, instr.args.map((arg) => this.Unknown(arg)))));
    }
    Relational(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'lval' }, this.Unknown(instr.left)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'operator', value: instr.operator }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'rval' }, this.Unknown(instr.right))));
    }
    Int(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: String(instr) }));
    }
    Float(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: String(instr) }));
    }
    Bool(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: String(instr) }));
    }
    String(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), value: String(instr.value) }));
    }
    Attribute(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), name: instr.name }, instr.args?.map((arg) => this.Unknown(arg))));
    }
    FunctionDefinition(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'signature', value: _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.fn.signatureEx(instr, true) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'type', value: instr.returnType.name }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'numArgsRequired', value: String(_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.fn.numArgsRequired(instr)) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'semantic', value: instr.semantic }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'arguments' }, instr.params.map((param) => this.VariableDecl(param)))));
    }
    StmtBlock(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) }, instr.stmtList.map(stmt => this.Stmt(stmt))));
    }
    IfStmt(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'cond' }, this.Unknown(instr.cond)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'conseq' }, this.Stmt(instr.conseq)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'contrary' }, this.Stmt(instr.contrary))));
    }
    DrawStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'name', value: instr.name })));
    }
    Stmt(instr) {
        if (!instr) {
            return null;
        }
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_DeclStmt:
                return this.DeclStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ReturnStmt:
                return this.ReturnStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_StmtBlock:
                return this.StmtBlock(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ExprStmt:
                return this.ExprStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_ForStmt:
                return this.ForStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_SemicolonStmt:
                return this.SemicolonStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_IfStmt:
                return this.IfStmt(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_DrawStmt:
                return this.DrawStmt(instr);
            default:
                return this.NotImplemented(instr); // TODO: remove it
        }
    }
    Type(instr) {
        switch (instr.instructionType) {
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_VariableType:
                return this.VariableType(instr);
            case _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes.k_SystemType:
                return this.SystemType(instr);
            default:
                return this.NotImplemented(instr); // TODO: remove it
        }
    }
    DeclStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'declarations' }, instr.declList.map(decl => this.Unknown(decl)))));
    }
    ReturnStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'value' }, this.Unknown(instr.expr))));
    }
    ExprStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) }, this.Unknown(instr.expr)));
    }
    SemicolonStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) }));
    }
    ForStmt(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr, true) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'init' }, this.Unknown(instr.init)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'cond' }, this.Unknown(instr.cond)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'step' }, this.Unknown(instr.step)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'body' }, this.Stmt(instr.body))));
    }
    VariableType(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            instr.isConst() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'const', value: `${instr.isConst()}` }),
            instr.isStatic() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'static', value: String(instr.isStatic()) }),
            instr.isUniform() && react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'uniform', value: String(instr.isUniform()) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'usages', value: (instr.usages.join(' ') || null) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'padding', value: instr.padding === _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_1__.instruction.UNDEFINE_PADDING ? 'undef' : instr.padding }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'aligment', value: instr.aligment }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'subType', opened: true }, this.Unknown(instr.subType)),
            this.typeInfo(instr)));
    }
    InitExpr(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'const', value: String(instr.isConst()) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'array', value: String(instr.isArray()) }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'arguments' }, instr.args.map(arg => this.Unknown(arg)))));
    }
    StateBlockExpr(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'props' }, instr.props && Object.keys(instr.props).map((key, i) => react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { key: `pv-uk-sb-${instr.instructionID}-${i}`, name: key, value: String(instr.props[key]) }))),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(PropertyOpt, { name: 'blocks' }, instr.blocks && instr.blocks.map((block, i) => this.StateBlockExpr(block)))));
    }
    CompileShader11Expr(instr) {
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr) },
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'ver', value: instr.ver }),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'func' }, this.FunctionDecl(instr.func)),
            react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { name: 'args' }, instr.args.map((arg, i) => this.Unknown(arg)))));
    }
    Annotation(instr) {
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(instr)) {
            return null;
        }
        return instr.decls.map(arg => this.VariableDecl(arg));
    }
    NotImplemented(instr) {
        if (!instr) {
            return null;
        }
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(Property, { ...this.bindProps(instr), onClick: () => console.log(instr), name: react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"], { size: 'mini', color: 'red' },
                react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_7__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Header, null, "Not implemented"),
                    react__WEBPACK_IMPORTED_MODULE_7__.createElement("p", null, _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_4__.EInstructionTypes[instr.instructionType]))) }));
    }
    bindProps(instr, opened = false) {
        const { instrList } = this.state;
        const instrState = instrList[instr.instructionID];
        if (!instrState) {
            instrList[instr.instructionID] = { opened, selected: false };
            return this.bindProps(instr, opened);
        }
        return {
            name: `${prettifyEName(instr.instructionName)}`,
            key: `${instr.instructionID}`,
            onMouseOver: this.handleMouseOver.bind(this, instr),
            onMouseOut: this.handleMouseOut.bind(this, instr),
            onClick: this.handleMouseClick.bind(this, instr),
            selected: !!instrState.selected,
            opened: !!instrState.opened,
            parent: instr.parent && `I${instr.parent.instructionID}`,
            onParentMouseDown: this.handleParentMouseDown.bind(this, instr),
            onParentMouseUp: this.handleParentMouseUp.bind(this, instr),
            classes: this.props.classes
        };
    }
    handleParentMouseDown(instr, e) {
        e.stopPropagation();
        let parent = instr.parent;
        if (parent && parent.sourceNode)
            this.props.onNodeOver(parent);
    }
    handleParentMouseUp(instr, e) {
        e.stopPropagation();
        let parent = instr.parent;
        if (parent && parent.sourceNode)
            this.props.onNodeOut(parent);
    }
    handleMouseOver(instr, e) {
        e.stopPropagation();
        this.invertInstructionProperty(instr, 'selected');
        if (instr.sourceNode) {
            this.props.onNodeOver(instr);
        }
    }
    handleMouseOut(instr, e) {
        e.stopPropagation();
        this.invertInstructionProperty(instr, 'selected');
        if (instr.sourceNode) {
            this.props.onNodeOut(instr);
        }
    }
    handleMouseClick(instr, e) {
        e.stopPropagation();
        this.documentCache = null;
        this.invertInstructionProperty(instr, 'opened');
        if (instr.sourceNode) {
            this.props.onNodeClick(instr);
        }
    }
    invertInstructionProperty(instr, prop) {
        let { instrList } = this.state;
        let instrState = { opened: false, selected: false, ...instrList[instr.instructionID] };
        instrState[prop] = !instrState[prop];
        instrList = { ...instrList, [instr.instructionID]: instrState };
        this.setState({ instrList });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_8__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__.mapProps)(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getFileState), {})((0,react_jss__WEBPACK_IMPORTED_MODULE_15__["default"])(styles)(ProgramView)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "1t3V":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/BasicType.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/BoolInstruction */ "d+t4");
/* harmony import */ var _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ConstructorCallInstruction */ "RIdR");
/* harmony import */ var _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FloatInstruction */ "OsKO");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
/* harmony import */ var _lib_fx_analisys_instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/CastExprInstruction */ "KHnE");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_5__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







function producer(env) {
    const nodes = {};
    [
        'float', 'float2', 'float3', 'float4',
        'half', 'half2', 'half3', 'half4',
        'int', 'int2', 'int3', 'int4',
        'uint', 'uint2', 'uint3', 'uint4',
        'bool', 'bool2', 'bool3', 'bool4'
    ].forEach(typeName => {
        const match = typeName.match(/(float|half|bool|uint|int)(2|3|4)?/);
        const desc = [typeName[0].toUpperCase(), ...typeName.slice(1)].join('');
        const count = Number(match[2] || 1);
        const type = match[1];
        let prettify = (raw) => {
            const value = Number(raw);
            switch (type) {
                case 'bool': return !!value;
                case 'uint': return value >>> 0;
                case 'int': return value << 0;
                default: return value;
            }
        };
        class Node extends _GraphNode__WEBPACK_IMPORTED_MODULE_5__.CodeEmitterNode {
            constructor() {
                super(desc);
                this.inputNames = [];
                this.addOutput("out", typeName);
                [...'xyzw'].slice(0, count).forEach(name => {
                    if (count == 1) {
                        this.addInput(name, 'float,bool,int,uint,half');
                    }
                    else {
                        this.addInput(name, type);
                    }
                    this.inputNames.push(name);
                    if (type == 'bool')
                        this.addProperty(name, false, 'boolean');
                    else // int/uint/float/half
                        this.addProperty(name, 0.0, 'number');
                });
                this.size = [180, 25 * count];
            }
            compute(context, program) {
                return [...Array(count).keys()].map(i => this.getInputNode(i)?.compute(context, program) || []).flat();
            }
            exec(context, program, slot) {
                const sourceNode = null;
                const scope = program.currentScope;
                const type = scope.findType(typeName);
                const ctor = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_3__.VariableTypeInstruction({ type, scope: null });
                const args = [...Array(count).keys()].map(i => {
                    const input = this.getInputNode(i);
                    const name = this.inputNames[i];
                    if (!input) {
                        switch (match[1]) {
                            case 'bool':
                                return new _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_0__.BoolInstruction({ scope, sourceNode, value: !!this.properties[name] });
                            default:
                                return new _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_2__.FloatInstruction({ scope, sourceNode, value: prettify(this.properties[name]) });
                        }
                    }
                    return input.exec(context, program, this.getOriginalSlot(i));
                });
                // avoid float(float(t)) expressions
                if (count == 1) {
                    if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_4__.types.equals(type, args[0].type)) {
                        return args[0];
                    }
                }
                return new _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_1__.ConstructorCallInstruction({ scope, sourceNode, ctor, args });
            }
            updateInputNames() {
                for (let i in this.inputs) {
                    let input = this.inputs[i];
                    input.name = !input.link ? `${this.inputNames[i]} = ${prettify(this.properties[this.inputNames[i]])}` : this.inputNames[i];
                }
            }
            onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
                super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);
                this.updateInputNames();
            }
            onPropertyChanged(name, value, prevValue) {
                super.onPropertyChanged(name, value, prevValue);
                this.updateInputNames();
                return true;
            }
            getDocs() {
                return `Constructor of ${typeName}() type.`;
            }
            getTitle() {
                if (this.flags.collapsed && this.inputs.filter(i => i.link).length === 0) {
                    return `(${this.inputNames.map(name => prettify(this.properties[name])).join(' ,')})`;
                }
                return super.getTitle();
            }
        }
        Node.desc = desc;
        nodes[`constructors/${typeName}`] = Node;
        class Cast extends _GraphNode__WEBPACK_IMPORTED_MODULE_5__.CodeEmitterNode {
            constructor() {
                super(desc);
                this.inputNames = [];
                this.addOutput("out", typeName);
                this.addInput('x', 'float,bool,int,uint,half'.split(',').map(x => `${x}${count}`).join(','));
                this.size = this.computeSize();
            }
            compute(context, program) {
                return this.getInputNode(0)?.compute(context, program);
            }
            exec(context, program, slot) {
                const scope = program.currentScope;
                const type = scope.findType(typeName);
                const sourceExpr = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));
                if (_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_4__.types.equals(sourceExpr.type, type)) {
                    return sourceExpr;
                }
                return new _lib_fx_analisys_instructions_CastExprInstruction__WEBPACK_IMPORTED_MODULE_6__.CastExprInstruction({ scope, sourceExpr, type });
            }
            getDocs() {
                return `Cast to ${typeName}() type.`;
            }
        }
        Cast.desc = `${desc} (cast)`;
        nodes[`constructors/${typeName} (cast)`] = Cast;
    });
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "nqVC":
/*!******************************************************!*\
  !*** ./src/sandbox/components/graphEx/Decomposer.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./common */ "sVSU");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_9__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_9__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];










/** @deprecated */
function asGraphContext(ctx) {
    // temp hack for compartibility
    let varNum = 0;
    ctx.addLocal = () => `t${varNum++}`;
    return ctx;
}
function producer(env) {
    class Node extends _GraphNode__WEBPACK_IMPORTED_MODULE_9__.CodeEmitterNode {
        constructor() {
            super('Decomposer');
            this.addInput('in', null);
            this.size = [180, 25];
        }
        exec(context, program, slot) {
            const name = this.getOutputInfo(slot).name;
            const element = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));
            const scope = program.currentScope;
            const decl = element.type.getField(name);
            const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_1__.IdInstruction({ scope, name });
            const postfix = new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_0__.IdExprInstruction({ scope, id, decl });
            return new _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_2__.PostfixPointInstruction({ scope, element, postfix });
        }
        onConnectInput(inputIndex, outputType, outputSlot, outputNode, outputIndex) {
            const self = this;
            async function wrapper() {
                // part argument has been added in order to handle corner case related to 'fx' pipeline
                const source = `auto anonymous(${_common__WEBPACK_IMPORTED_MODULE_8__.PART_TYPE} ${_common__WEBPACK_IMPORTED_MODULE_8__.PART_LOCAL_NAME}, int partId) { return ($complexExpr); }`;
                const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_4__.createTextDocument)(`://decompose-node`, source);
                let type = null;
                // quick analisys inside of virtual enviroment in order to compute on fly expression type
                let documentEx = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__.extendSLDocument)(textDocument, env(), {
                    $complexExpr: (context, program, sourceNode) => {
                        const gctx = asGraphContext(context);
                        outputNode.onBeforeExecution(gctx, program);
                        outputNode.compute(gctx, program);
                        const expr = outputNode.exec(context, program, outputIndex);
                        type = expr.type;
                        return expr;
                    }
                });
                if (documentEx.diagnosticReport.errors) {
                    console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_6__.Diagnostics.stringify(documentEx.diagnosticReport));
                }
                if (type.isComplex()) {
                    type.fields.forEach(field => self.addOutput(field.name, field.type.name));
                    return true;
                }
                // IP: probably not really valid hack to handle variable decl type
                if (!type.isNotBaseArray() &&
                    type.baseType.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemType) {
                    type = type.baseType;
                }
                // corner case for system types    
                if (type.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_5__.EInstructionTypes.k_SystemType) {
                    const match = type.name.match(/(float|half|bool|uint|int)(2|3|4)/);
                    if (match) {
                        [...'xyzw'].slice(0, Number(match[2])).forEach(name => self.addOutput(name, match[1]));
                        return true;
                    }
                }
                console.error(`unsupported type for decomposition '${type.name}'`);
                self.dropInput();
                return false;
            }
            wrapper();
            return true;
        }
        dropInput() {
            this.disconnectInput(0);
        }
        dropOutputs() {
            while (this.outputs.length) {
                this.disconnectOutput(0);
                this.removeOutput(0);
            }
        }
        onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
            if (type == litegraph_js__WEBPACK_IMPORTED_MODULE_7__.LiteGraph.INPUT && !isConnected) {
                this.dropOutputs();
            }
        }
        onBeforeConnectInput(inputIndex) {
            this.dropOutputs();
            return inputIndex;
        }
        getTitle() {
            let outs = this.outputs.filter(out => out.links?.length);
            if (this.inputs.length && outs.length === 1) {
                return `*.${outs[0].name}`;
            }
            return super.getTitle();
        }
        getDocs() {
            return 'Auxiliary node to decompose complex ty to components.';
        }
    }
    Node.desc = 'Decomposer';
    return { [`helpers/decomposer`]: Node };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "cAsR":
/*!*************************************************!*\
  !*** ./src/sandbox/components/graphEx/Float.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FloatInstruction */ "OsKO");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_1__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


function producer(env) {
    class Float extends _GraphNode__WEBPACK_IMPORTED_MODULE_1__.CodeEmitterNode {
        constructor() {
            super("Float");
            this.addOutput("value", "float");
            this.addProperty("value", 0.0, "number");
            this.widget = this.addWidget("number", "value", 0, "value", { precision: 5 });
            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)
            this.size = this.computeSize();
        }
        exec(context, program, slot) {
            const scope = program.currentScope;
            return new _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_0__.FloatInstruction({ scope, value: Number(Number(this.properties["value"]).toFixed(3)) });
        }
        getTitle() {
            if (this.flags.collapsed) {
                return this.properties.value.toFixed(2);
            }
            return super.getTitle();
        }
        onDrawBackground(ctx, graphcanvas, canvas, mouse) {
            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);
            this.outputs[0].label = this.properties["value"].toFixed(2);
        }
    }
    Float.desc = "Float";
    return { [`constants/float`]: Float };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "B6UE":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/FuncNodes.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionCallInstruction */ "y57x");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_1__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


function producer(env) {
    const nodes = {};
    function loadLibrary(slDocument) {
        let scope = slDocument.root.scope; // scope => current global scope, scope.parent => system scope
        let nodes = [];
        while (scope) {
            for (let [name, funcList] of Object.entries(scope.functions)) {
                for (let func of funcList) {
                    let isSupported = func.def.params.every(p => p.type.usages.every(u => u != "inout" && u != "out" && u != "uniform"));
                    if (!isSupported) {
                        continue;
                    }
                    let inputs = func.def.params.map(p => ({ name: p.id.name, type: p.type.name }));
                    let outputs = [{ name: 'out', type: func.def.returnType.name }];
                    let desc = func.def.toCode();
                    let name = func.def.id.name;
                    nodes.push({ func, name, desc, inputs, outputs });
                }
            }
            scope = scope.parent;
        }
        return nodes;
    }
    function autogenNode(node) {
        class Node extends _GraphNode__WEBPACK_IMPORTED_MODULE_1__.CodeEmitterNode {
            constructor() {
                super(node.name);
                node.inputs.forEach(i => this.addInput(i.name, i.type));
                node.outputs.forEach(o => this.addOutput(o.name, o.type));
                this.size = [180, 25 * Math.max(node.inputs.length, node.outputs.length)];
            }
            compute(context, program) {
                if (this.locals ||
                    !this.inputs.every((x, i) => this.isInputConnected(i))) {
                    return [];
                }
                const deps = super.compute(context, program);
                const scope = program.currentScope;
                const decl = node.func;
                const type = decl.def.returnType;
                const args = node.inputs
                    .map((V, i) => this.getInputNode(i)?.exec(context, program, this.getOriginalSlot(i))) || null;
                const expr = new _lib_fx_analisys_instructions_FunctionCallInstruction__WEBPACK_IMPORTED_MODULE_0__.FunctionCallInstruction({ scope, type, decl, args });
                return [...deps, ...this.addLocal(context, program, type.name, expr)];
            }
            exec(context, program, slot) {
                if (!this.locals)
                    return null;
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_1__.AST)(context, program).idexpr(this.locals[slot]);
            }
        }
        Node.desc = node.desc;
        nodes[`functions/${node.desc}`] = Node;
    }
    loadLibrary(env()).forEach(node => autogenNode(node));
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "wEVW":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/GraphNode.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AST": () => (/* binding */ AST),
/* harmony export */   "CodeEmitterNode": () => (/* binding */ CodeEmitterNode),
/* harmony export */   "CodeEmitterParam": () => (/* binding */ CodeEmitterParam),
/* harmony export */   "CodeEmitterStmt": () => (/* binding */ CodeEmitterStmt),
/* harmony export */   "GraphContext": () => (/* binding */ GraphContext),
/* harmony export */   "PartRoutine": () => (/* binding */ PartRoutine)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/FxAnalyzer */ "rHPT");
/* harmony import */ var _lib_fx_analisys_instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/AssignmentExprInstruction */ "eck/");
/* harmony import */ var _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/BoolInstruction */ "d+t4");
/* harmony import */ var _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ConstructorCallInstruction */ "RIdR");
/* harmony import */ var _lib_fx_analisys_instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/DeclStmtInstruction */ "YZc1");
/* harmony import */ var _lib_fx_analisys_instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprStmtInstruction */ "ubxH");
/* harmony import */ var _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FloatInstruction */ "OsKO");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDeclInstruction */ "BLpd");
/* harmony import */ var _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/fx/analisys/instructions/FunctionDefInstruction */ "O1LO");
/* harmony import */ var _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IntInstruction */ "s0og");
/* harmony import */ var _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _lib_fx_analisys_instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ReturnStmtInstruction */ "UL2e");
/* harmony import */ var _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtBlockInstruction */ "fc3/");
/* harmony import */ var _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableDeclInstruction */ "k9uP");
/* harmony import */ var _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lib/fx/analisys/instructions/VariableTypeInstruction */ "6EL/");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_23__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_22__]);
_sandbox_actions__WEBPACK_IMPORTED_MODULE_22__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
























class GraphContext extends _lib_fx_analisys_FxAnalyzer__WEBPACK_IMPORTED_MODULE_1__.FxContext {
    constructor() {
        super(...arguments);
        this.varNum = 0;
    }
    addLocal() { return `t${this.varNum++}`; }
}
const AST = (context, program) => ({
    variable(name, typeName, usages = []) {
        const scope = program.currentScope;
        const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_11__.IdInstruction({ scope, name });
        const type = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__.VariableTypeInstruction({ scope, type: scope.findType(typeName), usages });
        const varDecl = new _lib_fx_analisys_instructions_VariableDeclInstruction__WEBPACK_IMPORTED_MODULE_16__.VariableDeclInstruction({ scope, type, id });
        scope.addVariable(varDecl);
        return varDecl;
    },
    stmt(declList) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_DeclStmtInstruction__WEBPACK_IMPORTED_MODULE_5__.DeclStmtInstruction({ scope, declList });
    },
    assigment(left, right) {
        const scope = program.currentScope;
        if (!right.type.readable) {
            context.error(right.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_20__.EAnalyzerErrors.InvalidTypeForReading);
        }
        const expr = new _lib_fx_analisys_instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_2__.AssignmentExprInstruction({ scope, left, right, operator: '=' });
        return new _lib_fx_analisys_instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_6__.ExprStmtInstruction({ scope, expr });
    },
    bool(value) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_3__.BoolInstruction({ scope, value });
    },
    int(value) {
        const scope = program.currentScope;
        const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_19__.parseUintLiteral)(value.toFixed(0));
        return new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_12__.IntInstruction({ scope, base, exp, signed, heximal });
    },
    float(x) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_FloatInstruction__WEBPACK_IMPORTED_MODULE_7__.FloatInstruction({ scope, value: x });
    },
    float2(x, y) {
        const scope = program.currentScope;
        const args = [...arguments].map(x => this.float(x));
        const ctor = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__.VariableTypeInstruction({ type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_18__[`T_FLOAT${args.length}`], scope: null });
        return new _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_4__.ConstructorCallInstruction({ scope, args, ctor });
    },
    float3(x, y, z) {
        const scope = program.currentScope;
        const args = [...arguments].map(x => this.float(x));
        const ctor = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__.VariableTypeInstruction({ type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_18__[`T_FLOAT${args.length}`], scope: null });
        return new _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_4__.ConstructorCallInstruction({ scope, args, ctor });
    },
    float4(x, y, z, w) {
        const scope = program.currentScope;
        const args = [...arguments].map(x => this.float(x));
        const ctor = new _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__.VariableTypeInstruction({ type: _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_18__[`T_FLOAT${args.length}`], scope: null });
        return new _lib_fx_analisys_instructions_ConstructorCallInstruction__WEBPACK_IMPORTED_MODULE_4__.ConstructorCallInstruction({ scope, args, ctor });
    },
    id(name) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_11__.IdInstruction({ scope, name });
    },
    idexpr(name) {
        const scope = program.currentScope;
        const decl = scope.findVariable(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });
            return null;
        }
        const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_11__.IdInstruction({ scope, name });
        return new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_10__.IdExprInstruction({ scope, id, decl });
    },
    postfixpoint(ppname) {
        const [elementName, fieldName] = ppname.split('.');
        const scope = program.currentScope;
        const element = this.idexpr(elementName);
        const postfix = new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_10__.IdExprInstruction({
            scope,
            id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_11__.IdInstruction({ scope, name: fieldName }),
            decl: element.type.getField(fieldName)
        });
        return new _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_13__.PostfixPointInstruction({ scope, element, postfix });
    },
    return(expr) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_ReturnStmtInstruction__WEBPACK_IMPORTED_MODULE_14__.ReturnStmtInstruction({
            scope,
            expr
        });
    },
    // bool foo(int x)
    func(signature, content) {
        const regex = /(?<typeName>\w+)\s(?<funcName>\w+)\(\s*(?<paramStr>.*)\)/mg;
        const match = regex.exec(signature);
        if (!match) {
            return null;
        }
        const ast = AST(context, program);
        const { funcName, typeName, paramStr } = match.groups;
        const paramList = paramStr
            .split(',')
            .map(x => x.trim())
            .map(p => p.split(/\s+/).reverse())
            .map(([name, type, usage]) => ast.variable(name, type, usage ? [usage] : []));
        const scope = program.currentScope;
        const globalScope = program.globalScope;
        program.push(_lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_21__.EScopeType.k_Default);
        const returnType = _lib_fx_analisys_instructions_VariableTypeInstruction__WEBPACK_IMPORTED_MODULE_17__.VariableTypeInstruction.wrap(scope.findType(typeName), _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_18__.SCOPE);
        const id = ast.id(funcName);
        const def = new _lib_fx_analisys_instructions_FunctionDefInstruction__WEBPACK_IMPORTED_MODULE_9__.FunctionDefInstruction({ scope, returnType, id, paramList });
        context.funcDef = def;
        const stmtList = [...content()];
        if (!stmtList.length || stmtList[stmtList.length - 1].instructionType != _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_21__.EInstructionTypes.k_ReturnStmt) {
            let returnExpr = null;
            switch (typeName) {
                case 'bool':
                    returnExpr = ast.bool(true);
                    break;
                case 'uint':
                case 'int':
                    returnExpr = ast.int(0);
                    break;
                case 'void':
                    break;
                default:
                    console.error('unsupported type of return expression');
            }
            stmtList.push(ast.return(returnExpr));
        }
        const impl = new _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_15__.StmtBlockInstruction({ scope, stmtList });
        program.pop();
        let func = new _lib_fx_analisys_instructions_FunctionDeclInstruction__WEBPACK_IMPORTED_MODULE_8__.FunctionDeclInstruction({ scope, def, impl });
        globalScope.addFunction(func);
        return func;
    }
});
class CodeEmitterNode extends litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LGraphNode {
    // constructor(name) {
    //     super(name);
    // }
    //
    // Helpers 
    //
    resolveInput(id) {
        let slot = -1;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(id)) {
            slot = this.inputs.findIndex(i => i.name == id);
        }
        else {
            slot = id;
        }
        return slot;
    }
    resolveOutput(id) {
        let slot = -1;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(id)) {
            slot = this.outputs.findIndex(i => i.name == id);
        }
        else {
            slot = id;
        }
        return slot;
    }
    getInputLink(id) {
        const ii = this.getInputInfo(id);
        if (!ii)
            return null;
        const link = ii.link;
        if (!link)
            return null;
        return this.graph.links[link];
    }
    getOutputLinks(id) {
        const ii = this.getOutputInfo(id);
        if (!ii)
            return null;
        const links = ii.links;
        if (!links)
            return null;
        return links.map(link => this.graph.links[link]);
    }
    getOriginalSlot(id) {
        let link = this.getInputLink(id);
        if (!link)
            return -1;
        return link.origin_slot;
    }
    getInputNode(id) {
        let slot = this.resolveInput(id);
        return super.getInputNode(slot);
    }
    getInputInfo(id) {
        let slot = this.resolveInput(id);
        return super.getInputInfo(slot);
    }
    getOutputInfo(id) {
        let slot = this.resolveOutput(id);
        return super.getOutputInfo(slot);
    }
    getOutputNodes(id) {
        let slot = this.resolveOutput(id);
        return super.getOutputNodes(slot);
    }
    // todo: move to litegraph.js
    getInputNodes() {
        return this.inputs
            .filter(i => i && i.link !== null) // filter valid inputs
            .map(i => this.graph.links[i.link]) // conver inputs to link infos
            .filter(li => !!li) // filter valid links
            .map(li => this.graph.getNodeById(li.origin_id));
    }
    //
    // Execution api
    //
    async run(env) {
        return null;
    }
    local(slot) {
        return this.locals[0];
    }
    localCache(slot) {
        return this.localsCache?.[0] || null;
    }
    addLocal(context, program, type, expr) {
        const t = context.addLocal();
        this.locals = [t];
        this.localsCache = [expr];
        const ast = AST(context, program);
        return [
            ast.stmt([ast.variable(t, type)]),
            ast.assigment(ast.idexpr(t), expr)
        ];
    }
    // be careful, this function cane be called more than once per node because of multiple connections
    // it has to be fixed
    onBeforeExecution(context, program) {
        this.locals = null; // clean up precached names
        this.localsCache = null;
        this.inputs.forEach((n, i) => n.type != litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LiteGraph.ACTION && this.getInputNode(i)?.onBeforeExecution(context, program));
        this.outputs.forEach((n, i) => n.type == litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LiteGraph.EVENT && this.getOutputNodes(i)?.forEach(node => node.onBeforeExecution(context, program)));
    }
    compute(context, program) {
        return this.inputs.map((n, i) => n.type == litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LiteGraph.ACTION
            ? []
            : this.getInputNode(i)?.compute(context, program) || []).flat();
    }
    exec(context, program, slot) {
        const scope = program.currentScope;
        return new _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_3__.BoolInstruction({ scope, value: false });
    }
    //
    // Docs api
    //
    getDocs() {
        return CodeEmitterNode.nodesDocs[this.title]?.desc || null;
    }
    getTitle() {
        const titleEx = CodeEmitterNode.nodesDocs[this.title];
        return titleEx?.title || this.title;
    }
    onSelected() {
        const docs = this.getDocs();
        if (docs) {
            (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_22__.nodesProvideDocs)(docs);
        }
    }
    onDeselected() {
        const docs = this.getDocs();
        if (docs) {
            (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_22__.nodesProvideDocs)(null);
        }
    }
    onPropertyChanged(name, value, prevValue) {
        (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_22__.nodesForceRecompile)();
        return true;
    }
    emitError(desc) {
        if (desc)
            console.error(desc);
        this.color = 'red';
    }
    emitNoError() {
        this.color = null;
    }
    onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
        this.emitNoError(); // clean up errors on every change
    }
    onDrawBackground(ctx, graphcanvas, canvas, mouse) {
        if (this.flags.collapsed)
            return;
        if (this.mouseOver) {
            const docs = this.getDocs();
            if (docs) {
                ctx.save();
                ctx.font = "12px sans-serif";
                ctx.fillStyle = "#AAA";
                ctx.fillText(this.getDocs(), 0, this.size[1] + 18);
                ctx.restore();
            }
        }
    }
    // IP: uncomment to render selection around hint
    // onBounding(rect) {
    //     if (!this.flags.collapsed && this.mouseOver) {
    //         const docs = this.getDocs();
    //         if (docs) {
    //             rect[3] = this.size[1] + 45;
    //         }
    //     }
    // }
    ////
    setOutputSlotType(type, slot) { }
    setInputSlotType(type, slot) { }
}
// docs provided outside from autogenDocumentation() method;
CodeEmitterNode.nodesDocs = {};
class CodeEmitterParam extends CodeEmitterNode {
    getName() { return null; }
    getType() { return null; }
}
class CodeEmitterStmt extends CodeEmitterNode {
    constructor() {
        super(...arguments);
        this.readyToAccept = false;
    }
    dependentNodes() {
        return this.getOutputNodes(0); // 'stmts' ?
    }
    update() {
        const dx = 7;
        const dy = 5;
        const dh_title = 35;
        const dh_notitle = 5;
        const dh_post = 10;
        let [w, h] = this.computeSize();
        let [x, y] = [dx, h - (this.inputs.find(i => i.pos?.[1] < 0) || this.outputs?.[0]?.visible === false ? 26 : 0)]; // fixme!!!
        const nodes = this.dependentNodes();
        if (nodes) {
            for (let node of nodes) {
                const noTitle = node.constructor.title_mode == litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LiteGraph.NO_TITLE;
                const px = this.pos[0] + x;
                const py = this.pos[1] + y + (noTitle ? dh_notitle : dh_title);
                if (node.pos[0] != px || node.pos[1] != py) {
                    node.pos = [px, py];
                    node.onReposition?.();
                }
                w = Math.max(w, node.size[0] + dx * 2);
                y = y +
                    node.size[1] +
                    (!noTitle ? litegraph_js__WEBPACK_IMPORTED_MODULE_23__.LiteGraph.NODE_TITLE_HEIGHT : 0) +
                    dy;
            }
        }
        w = Math.max(100, w);
        h = Math.max(30, y + dh_post);
        if (this.size[0] != w || this.size[1] != h) {
            this.size = [w, h];
            this.onResize();
        }
        return nodes;
    }
    onResize() {
        this.getInputNode("context")?.update?.();
    }
    onReposition() {
        this.getInputNode("context")?.update?.();
    }
    highlight(value) {
        this.readyToAccept = value;
    }
    onDropEnter(node) {
        this.highlight(true);
        this.update();
    }
    onDropLeave(node) {
        this.highlight(false);
        const graph = this.graph;
        const links = this.outputs[0].links || [];
        // trying to find incoming node within our connections
        // and disconnect if possible
        links.forEach(link_id => {
            let link = graph.links[link_id];
            let targetNode = graph.getNodeById(link.target_id);
            if (node == targetNode) {
                this.disconnectOutput(0, targetNode);
            }
        });
        this.update();
    }
    onDrag(graphcanvas) {
        const nodes = this.update();
        if (nodes) {
            nodes.forEach(node => {
                graphcanvas.bringToFront(node);
                if (node.onDrag)
                    node.onDrag(graphcanvas);
            });
        }
    }
    onConnectionsChange() {
        this.update();
        // force update parent twice in order to validate that all nodes in positions
        this.onResize();
    }
    onBringToFront(canvas) {
        const nodes = this.dependentNodes();
        if (nodes) {
            nodes.forEach(node => {
                canvas.bringToFront(node);
                if (node.onBringToFront)
                    node.onBringToFront(canvas);
            });
        }
    }
}
class PartRoutine extends CodeEmitterStmt {
    // static title_offset_x = 5;
    onDrawBackground(ctx /* CanvasRenderingContext2D */, gcanvas /* LGraphCanvas */, canvas /* HTMLCanvasElement */, mouse) {
        super.onDrawBackground(ctx, gcanvas, canvas, mouse);
        if (this.flags.collapsed)
            return;
        let [w, h] = this.size;
        if (this.readyToAccept) {
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'orange';
            ctx.roundRect(0, 0, w + 1, h, [0, 0, 0, 0], 0);
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }
    }
}
// render as fully transparent by default (only with custom design)
// static title_mode = LiteGraph.TRANSPARENT_TITLE;
// static color = 'transparent';
// static bgcolor = 'transparent';
PartRoutine.can_accept_drop = true;
PartRoutine.collapsable = false;

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "jEKi":
/*!**************************************************!*\
  !*** ./src/sandbox/components/graphEx/IfStmt.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IfStmtInstruction */ "AAir");
/* harmony import */ var _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtBlockInstruction */ "fc3/");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_3__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




function producer(env) {
    const desc = "Action"; // "If";
    const name = "Action"; // "If";
    const HIDDEN_CONNECTION = { visible: false };
    class If extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterStmt {
        // toggle: IWidget;
        constructor() {
            super(name);
            this.addInput("cond", "bool", { pos: [13, -13], label: "" });
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_2__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.addOutput("true", litegraph_js__WEBPACK_IMPORTED_MODULE_2__.LiteGraph.EVENT, HIDDEN_CONNECTION);
            this.addOutput("false", litegraph_js__WEBPACK_IMPORTED_MODULE_2__.LiteGraph.EVENT, HIDDEN_CONNECTION);
            // this.addProperty<boolean>("value", true, "boolean");
            // this.toggle = this.addWidget<IWidget>("toggle", null, true, "value", { on: "fwd", off: "bck" } );
            // (this.toggle as any).width = 100;
            // this.widgets_start_y = -13;
            // this.serialize_widgets = true;
            this.update();
        }
        dependentNodes() {
            return [...(this.getOutputNodes(0) || []), ...(this.getOutputNodes(1) || [])];
        }
        computeSize() {
            return [120, 26];
        }
        onDrawTitleBox(ctx, titleHeight, size, scale) {
            // skip render of title pin
        }
        onDrawBackground(ctx /* CanvasRenderingContext2D */, gcanvas /* LGraphCanvas */, canvas /* HTMLCanvasElement */, mouse) {
            super.onDrawBackground(ctx, gcanvas, canvas, mouse);
            if (this.flags.collapsed)
                return;
            let [w, h] = this.size;
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.readyToAccept ? 'orange' : 'rgba(255, 255, 255, 0)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 6;
            ctx.roundRect(0, 0, w + 1, h, [0, 0, 5, 5], 5);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }
        onDropLeave(node) {
            this.highlight(false);
            const graph = this.graph;
            for (let i of [0, 1]) {
                const links = this.outputs[i].links;
                if (links) {
                    // trying to find incoming node within our connections
                    // and disconnect if possible
                    links.forEach(link_id => {
                        let link = graph.links[link_id];
                        let targetNode = graph.getNodeById(link.target_id);
                        if (node == targetNode) {
                            this.disconnectOutput(i, targetNode);
                        }
                    });
                }
            }
            // true is disconnected and false is connected
            const conseq = this.outputs[0].links;
            const contrary = this.outputs[1].links;
            if (!conseq?.length && contrary?.length) {
                // move false to true
                let link = graph.links[contrary[0]];
                let contraryNode = graph.getNodeById(link.target_id);
                this.disconnectOutput(1);
                this.connect(0, contraryNode, 'context');
            }
            this.update();
        }
        onDrop(node) {
            // todo: validate node
            const slotName = this.isOutputConnected(0)
                ? this.isOutputConnected(1)
                    ? null
                    : 'false'
                : 'true';
            if (slotName) {
                this.connect(slotName, node, 'context');
            }
            this.highlight(false);
            this.update();
        }
        compute(context, program) {
            const deps = super.compute(context, program);
            const scope = program.currentScope;
            const cond = this.getInputNode('cond')?.exec(context, program, this.getOriginalSlot('cond')) ||
                this.exec(context, program, 0) /* false */;
            const conseqStmts = this.getOutputNodes('true')?.map(node => node.compute(context, program)).flat();
            const conseq = conseqStmts ? new _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtBlockInstruction({ scope, stmtList: conseqStmts }) : null;
            const contraryStmts = this.getOutputNodes('false')?.map(node => node.compute(context, program)).flat();
            const contrary = contraryStmts ? new _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtBlockInstruction({ scope, stmtList: contraryStmts }) : null;
            return [...deps, new _lib_fx_analisys_instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_0__.IfStmtInstruction({ scope, cond, conseq, contrary })];
        }
    }
    If.desc = desc;
    // render as fully transparent by default (only with custom design)
    // static title_mode = LiteGraph.TRANSPARENT_TITLE;
    If.color = 'transparent';
    If.bgcolor = 'transparent';
    If.can_be_dropped = true;
    If.can_accept_drop = true;
    If.collapsable = false;
    return { [`fx/${desc}`]: If };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "0N+1":
/*!***********************************************!*\
  !*** ./src/sandbox/components/graphEx/Int.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/BoolInstruction */ "d+t4");
/* harmony import */ var _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IntInstruction */ "s0og");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_3__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




// notes:
//  processNodeWidgets handles clicks and events
//  drawNodeWidgets handles drawning
function producer(env) {
    const nodes = {};
    class Int extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super("Int");
            this.addOutput("value", "int");
            this.addProperty("value", 0.0, "number");
            this.widget = this.addWidget("number", "value", 0, "value", { precision: 0, step: 10 });
            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)
            this.size = [150, 30];
        }
        exec(context, program) {
            let sourceNode = null;
            let scope = program.currentScope;
            // return new FloatInstruction({ scope, sourceNode, value: Number(this.properties["value"]) });
            let value = this.properties.value;
            let { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__.parseUintLiteral)(Math.abs(value).toFixed(0));
            if (value < 0)
                base = -base;
            return new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_1__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
        }
        getTitle() {
            if (this.flags.collapsed) {
                return this.properties.value.toFixed(0);
            }
            return super.getTitle();
        }
        onDrawBackground(ctx, graphcanvas, canvas, mouse) {
            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);
            this.outputs[0].label = this.properties["value"].toFixed(2);
        }
    }
    Int.desc = "Int";
    nodes[`constants/int`] = Int;
    class Uint extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super("Uint");
            this.addOutput("value", "uint");
            this.addProperty("value", 0.0, "number");
            this.widget = this.addWidget("number", "value", 0, "value", { precision: 0, step: 10, min: 0 });
            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)
            this.size = [150, 30];
        }
        exec(context, program) {
            let sourceNode = null;
            let scope = program.currentScope;
            let { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__.parseUintLiteral)(this.properties.value.toFixed(0));
            signed = false; // force "unsigned"
            return new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_1__.IntInstruction({ scope, sourceNode, base, exp, signed, heximal });
        }
        getTitle() {
            if (this.flags.collapsed) {
                return this.properties.value.toFixed(0);
            }
            return super.getTitle();
        }
        onDrawBackground(ctx, graphcanvas, canvas, mouse) {
            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);
            this.outputs[0].label = this.properties["value"].toFixed(2);
        }
    }
    Uint.desc = "Uint";
    nodes[`constants/uint`] = Uint;
    class Bool extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super("Bool");
            this.addOutput("value", "bool");
            this.addProperty("value", false, "bool");
            this.widget = this.addWidget("toggle", "value", false, "value");
            this.widgets_up = true; // draw number widget in the middle of node (by default it's placed under node)
            this.size = [150, 30];
        }
        exec(context, program) {
            let sourceNode = null;
            let scope = program.currentScope;
            let value = this.properties.value;
            return new _lib_fx_analisys_instructions_BoolInstruction__WEBPACK_IMPORTED_MODULE_0__.BoolInstruction({ scope, sourceNode, value });
        }
        getTitle() {
            if (this.flags.collapsed) {
                return this.properties.value;
            }
            return super.getTitle();
        }
        onDrawBackground(ctx, graphcanvas, canvas, mouse) {
            super.onDrawBackground(ctx, graphcanvas, canvas, mouse);
            this.outputs[0].label = this.properties["value"];
        }
    }
    Bool.desc = "Bool";
    nodes[`constants/bool`] = Bool;
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "dJ4L":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/Operators.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_Analyzer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/Analyzer */ "R35j");
/* harmony import */ var _lib_fx_analisys_instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ArithmeticExprInstruction */ "+tx1");
/* harmony import */ var _lib_fx_analisys_instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/RelationalExprInstruction */ "2i/b");
/* harmony import */ var _lib_fx_analisys_instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ConditionalExprInstruction */ "IsZF");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
/* harmony import */ var _lib_fx_analisys_instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/analisys/instructions/LogicalExprInstruction */ "Oxvu");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_5__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







function producer(env) {
    const nodes = {};
    class Operator extends _GraphNode__WEBPACK_IMPORTED_MODULE_5__.CodeEmitterNode {
        get a() {
            return this.getInputNode('a');
        }
        get b() {
            return this.getInputNode('b');
        }
    }
    const TYPES = ['float', 'int', 'uint', 'float3'];
    const ARITHMETIC = [
        { name: "Summ", operator: "+", search: "summ '+'" },
        { name: "Subtraction", operator: "-", search: "subtraction '-'" },
        { name: "Mult", operator: "*", search: "multiply '*'" },
        { name: "Div", operator: "/", search: "division '/'" },
        { name: "Mod", operator: "%", search: "modulo '%'" }
    ];
    const TYPE_LIST = TYPES.join(',');
    ARITHMETIC.forEach(desc => {
        class Arithmetic extends Operator {
            constructor() {
                super(desc.name);
                this.addInput("a", TYPE_LIST);
                this.addInput("b", TYPE_LIST);
                this.addOutput("value", TYPE_LIST);
                this.size = [100, 50];
                this.shape = litegraph_js__WEBPACK_IMPORTED_MODULE_4__.LiteGraph.ROUND_SHAPE;
            }
            compute(context, program) {
                if (this.locals ||
                    !this.inputs.every((x, i) => this.isInputConnected(i))) {
                    return [];
                }
                const deps = super.compute(context, program);
                const scope = program.currentScope;
                const operator = desc.operator;
                const left = this.a.exec(context, program, this.getOriginalSlot('a'));
                const right = this.b.exec(context, program, this.getOriginalSlot('b'));
                // IP: todo - calc proper type
                const type = _lib_fx_analisys_Analyzer__WEBPACK_IMPORTED_MODULE_0__.Analyzer.checkTwoOperandExprTypes(context, operator, left.type, right.type);
                for (const name of ['a', 'b']) {
                    this.getInputInfo(name).type = left.type.name;
                    this.getInputLink(name).type = left.type.name;
                }
                this.getOutputInfo('value').type = type.name;
                const expr = new _lib_fx_analisys_instructions_ArithmeticExprInstruction__WEBPACK_IMPORTED_MODULE_1__.ArithmeticExprInstruction({ scope, left, right, operator, type });
                return [...deps, ...this.addLocal(context, program, expr.type.name, expr)];
            }
            exec(context, program, slot) {
                let leftNode = this.a;
                let rightNode = this.b;
                if (!leftNode || !rightNode) {
                    this.emitError(`All inputs must be conected.`);
                    return null;
                }
                if (!this.locals)
                    return null;
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_5__.AST)(context, program).idexpr(this.locals[slot]);
            }
            getTitle() {
                const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;
                return this.flags.collapsed ? desc.operator : title;
            }
            getDocs() {
                return `Operator '${desc.search}'.`;
            }
            onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
                for (let name of ['a', 'b']) {
                    let slot = this.getInputInfo(name);
                    if (!slot.link)
                        slot.type = TYPE_LIST;
                }
                super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);
            }
        }
        Arithmetic.desc = desc.name;
        nodes[`operators/${desc.search}`] = Arithmetic;
    });
    const relations = [
        { name: "Equal", operator: "==", search: "equal '=='" },
        { name: "NotEqual", operator: "!=", search: "not equal '!='" },
        { name: "Less", operator: "<", search: "less '<'" },
        { name: "Greater", operator: ">", search: "greater '>'" },
        { name: "LessThan", operator: "<=", search: "less than '<='" },
        { name: "GreaterThan", operator: ">=", search: "greater than '>='" }
    ];
    // todo: add support of different types
    relations.forEach(desc => {
        class Relation extends Operator {
            constructor() {
                super(desc.name);
                this.addInput("a", TYPES.join(','));
                this.addInput("b", TYPES.join(','));
                this.addOutput("value", "bool");
                this.size = [100, 50];
            }
            compute(context, program) {
                if (this.locals ||
                    !this.inputs.every((x, i) => this.isInputConnected(i))) {
                    return [];
                }
                const deps = super.compute(context, program);
                const scope = program.currentScope;
                const operator = desc.operator;
                let leftNode = this.a;
                let rightNode = this.b;
                const left = leftNode.exec(context, program, this.getOriginalSlot('a'));
                const right = rightNode.exec(context, program, this.getOriginalSlot('b'));
                for (const name of ['a', 'b']) {
                    this.getInputInfo(name).type = left.type.name;
                    this.getInputLink(name).type = left.type.name;
                }
                const expr = new _lib_fx_analisys_instructions_RelationalExprInstruction__WEBPACK_IMPORTED_MODULE_2__.RelationalExprInstruction({ scope, left, right, operator });
                return [...deps, ...this.addLocal(context, program, expr.type.name, expr)];
            }
            exec(context, program, slot) {
                let leftNode = this.a;
                let rightNode = this.b;
                if (!leftNode || !rightNode) {
                    this.emitError(`All inputs must be conected.`);
                    return null;
                }
                if (!this.locals)
                    return null;
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_5__.AST)(context, program).idexpr(this.locals[slot]);
            }
            getTitle() {
                const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;
                return this.flags.collapsed ? desc.operator : title;
            }
            getDocs() {
                return `Operator '${desc.search}'.`;
            }
            onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
                for (let name of ['a', 'b']) {
                    let slot = this.getInputInfo(name);
                    if (!slot.link)
                        slot.type = TYPE_LIST;
                }
                super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);
            }
        }
        Relation.desc = desc.name;
        nodes[`operators/${desc.search}`] = Relation;
    });
    const logic = [
        { name: "And", operator: "&&", search: "and '&&'" },
        { name: "Or", operator: "||", search: "or '||'" },
    ];
    logic.forEach(desc => {
        class Logic extends Operator {
            constructor() {
                super(desc.name);
                this.addInput("a", 'bool');
                this.addInput("b", 'bool');
                this.addOutput("value", "bool");
                this.size = [100, 50];
            }
            compute(context, program) {
                if (this.locals ||
                    !this.inputs.every((x, i) => this.isInputConnected(i))) {
                    return [];
                }
                const deps = super.compute(context, program);
                const scope = program.currentScope;
                const operator = desc.operator;
                let leftNode = this.a;
                let rightNode = this.b;
                const left = leftNode.exec(context, program, this.getOriginalSlot('a'));
                const right = rightNode.exec(context, program, this.getOriginalSlot('b'));
                const expr = new _lib_fx_analisys_instructions_LogicalExprInstruction__WEBPACK_IMPORTED_MODULE_6__.LogicalExprInstruction({ scope, left, right, operator });
                return [...deps, ...this.addLocal(context, program, expr.type.name, expr)];
            }
            exec(context, program, slot) {
                let leftNode = this.a;
                let rightNode = this.b;
                if (!leftNode || !rightNode) {
                    this.emitError(`All inputs must be conected.`);
                    return null;
                }
                if (!this.locals)
                    return null;
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_5__.AST)(context, program).idexpr(this.locals[slot]);
            }
            getTitle() {
                const title = `${this.getInputInfo('a').name} ${desc.operator} ${this.getInputInfo('b').name}`;
                return this.flags.collapsed ? desc.operator : title;
            }
            getDocs() {
                return `Operator '${desc.search}'.`;
            }
        }
        Logic.desc = desc.name;
        nodes[`operators/${desc.search}`] = Logic;
    });
    class Conditional extends Operator {
        constructor() {
            super('Conditional');
            this.addInput("cond", 'bool');
            this.addInput("a", TYPE_LIST);
            this.addInput("b", TYPE_LIST);
            this.addOutput("value", TYPE_LIST);
            this.size = this.computeSize();
        }
        get cond() {
            return this.getInputNode('cond');
        }
        compute(context, program) {
            if (this.locals ||
                !this.inputs.every((x, i) => this.isInputConnected(i))) {
                return [];
            }
            const deps = super.compute(context, program);
            const scope = program.currentScope;
            let leftNode = this.a;
            let rightNode = this.b;
            let condNode = this.cond;
            const left = leftNode.exec(context, program, this.getOriginalSlot('a'));
            const right = rightNode.exec(context, program, this.getOriginalSlot('b'));
            const cond = condNode.exec(context, program, this.getOriginalSlot('cond'));
            const expr = new _lib_fx_analisys_instructions_ConditionalExprInstruction__WEBPACK_IMPORTED_MODULE_3__.ConditionalExprInstruction({ scope, cond, left, right });
            for (const name of ['a', 'b']) {
                this.getInputInfo(name).type = left.type.name;
                this.getInputLink(name).type = left.type.name;
            }
            this.getOutputInfo('value').type = expr.type.name;
            return [...deps, ...this.addLocal(context, program, expr.type.name, expr)];
        }
        exec(context, program, slot) {
            let leftNode = this.a;
            let rightNode = this.b;
            if (!leftNode || !rightNode) {
                this.emitError(`All inputs must be conected.`);
                return null;
            }
            if (!this.locals)
                return null;
            return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_5__.AST)(context, program).idexpr(this.locals[slot]);
        }
        getTitle() {
            const title = `${this.getInputInfo('cond').name} ? ${this.getInputInfo('a').name} : ${this.getInputInfo('b').name}`;
            return title;
        }
        getDocs() {
            return `Conditional operator '?'.`;
        }
        onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
            for (let name of ['a', 'b']) {
                let slot = this.getInputInfo(name);
                if (!slot.link)
                    slot.type = TYPE_LIST;
            }
            super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);
        }
    }
    Conditional.desc = 'Conditional';
    nodes[`operators/conditional '?'`] = Conditional;
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "Ca6S":
/*!****************************************************!*\
  !*** ./src/sandbox/components/graphEx/StmtList.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_1__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


function producer(env) {
    const desc = "Statements";
    const name = "Statements";
    const HIDDEN_CONNECTION = { visible: false };
    class StmtList extends _GraphNode__WEBPACK_IMPORTED_MODULE_1__.CodeEmitterStmt {
        constructor() {
            super(name);
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.addOutput("stmts", litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.EVENT, HIDDEN_CONNECTION);
            this.update();
        }
        computeSize() {
            return [120, 26];
        }
        onDrawTitleBox(ctx, titleHeight, size, scale) {
            // skip render of title pin
        }
        onDrawBackground(ctx /* CanvasRenderingContext2D */, gcanvas /* LGraphCanvas */, canvas /* HTMLCanvasElement */, mouse) {
            super.onDrawBackground(ctx, gcanvas, canvas, mouse);
            if (this.flags.collapsed)
                return;
            let [w, h] = this.size;
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.readyToAccept ? 'orange' : 'rgba(255, 255, 255, 0)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 6;
            ctx.roundRect(0, 0, w + 1, h, [0, 0, 5, 5], 5);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }
        onDrop(node) {
            this.connect('stmts', node, 'context');
            this.highlight(false);
            this.update();
        }
        compute(context, program) {
            const deps = super.compute(context, program);
            const scope = program.currentScope;
            const stmts = this.getOutputNodes('stmts')?.map(node => node.compute(context, program)).flat();
            return [...deps, ...stmts];
        }
    }
    StmtList.desc = desc;
    StmtList.color = 'transparent';
    StmtList.bgcolor = 'transparent';
    StmtList.can_be_dropped = true;
    StmtList.can_accept_drop = true;
    StmtList.collapsable = false;
    return { [`fx/${desc}`]: StmtList };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "teaP":
/*!****************************************************!*\
  !*** ./src/sandbox/components/graphEx/Uniforms.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_0__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

function producer(env) {
    const nodes = {};
    const vars = env().root.scope.variables;
    for (let name in vars) {
        let v = vars[name];
        if (v.type.isUniform()) {
            class Node extends _GraphNode__WEBPACK_IMPORTED_MODULE_0__.CodeEmitterNode {
                constructor() {
                    super(`${name}`);
                    this.addOutput('out', v.type.name, { label: '' });
                    this.size = this.computeSize();
                    this.size[1] = 0;
                    this.size[0] = Math.max(180, this.size[0]);
                    this.outputs[0].pos = [this.size[0] - 13, -13];
                }
                onDrawTitleBox(ctx, titleHeight, size, scale) {
                    // skip render of title pin
                }
                exec(context, program) {
                    return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_0__.AST)(context, program).idexpr(name);
                }
            }
            Node.desc = `Uniform '${name}'`;
            Node.collapsable = false;
            Node.color = 'transparent';
            nodes[`constants/${name} (uniform)`] = Node;
        }
    }
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "sVSU":
/*!**************************************************!*\
  !*** ./src/sandbox/components/graphEx/common.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PART_LOCAL_NAME": () => (/* binding */ PART_LOCAL_NAME),
/* harmony export */   "PART_TYPE": () => (/* binding */ PART_TYPE)
/* harmony export */ });
const PART_TYPE = "Part";
const PART_LOCAL_NAME = "part";


/***/ }),

/***/ "pqmu":
/*!**************************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/DefaultMaterial.ts ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_3__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




function producer(env) {
    const DEFAULT_MATERIAL = 'DefaultShaderInput';
    const type = env().root.scope.types[DEFAULT_MATERIAL];
    const inputs = type.fields.map((decl) => ({ name: decl.name, type: decl.type.name }));
    const desc = "DefaultMaterial";
    const name = "DefaultMaterial";
    class DefaultMaterial extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super(name);
            // float3 pos : POSITION;
            // float4 color : COLOR0;
            // float  size : SIZE;
            inputs.forEach(i => this.addInput(i.name, i.type));
            this.addInput('sort', 'int');
            this.size = [180, 25 * (inputs.length + 1) + 50 * 2];
            this.addProperty("Sorting", true, "bool");
            this.sortingWidget = this.addWidget("toggle", "Sorting", true, "value");
            this.addProperty("Geometry", "Box", "string");
            this.geometryWidget = this.addWidget("text", "Geometry", "Box", "value");
            this.serialize_widgets = true;
        }
        get sorting() {
            return this.sortingWidget.value;
        }
        get geometry() {
            return this.geometryWidget.value;
        }
        extend(env) {
            const uri = env.uri;
            const scope = env.root.scope;
            const program = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.ProgramScope(scope);
            const context = new _GraphNode__WEBPACK_IMPORTED_MODULE_3__.GraphContext(uri);
            this.onBeforeExecution(context, program);
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_3__.AST)(context, program);
            const execInput = id => this.getInputNode(id).exec(context, program, this.getOriginalSlot(id));
            const computeInput = id => this.getInputNode(id).compute(context, program);
            context.beginFunc();
            const fdecl = ast.func(`int PrerenderRoutine${this.id}(inout Part part, out DefaultShaderInput input)`, () => [
                ...computeInput('pos'),
                ...computeInput('size'),
                ...computeInput('color'),
                ...computeInput('sort'),
                ast.assigment(ast.postfixpoint('input.pos'), execInput('pos')),
                ast.assigment(ast.postfixpoint('input.size'), execInput('size')),
                ast.assigment(ast.postfixpoint('input.color'), execInput('color')),
                ast.return(execInput('sort'))
            ]);
            context.endFunc();
            const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__.Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);
            const instructions = env.root.instructions.concat([fdecl]);
            const root = new _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__.InstructionCollector({ scope: program.globalScope, instructions });
            return { root, diagnosticReport, uri };
        }
        async run(env) {
            return this.extend(env);
        }
        getTitle() { return 'Default Material'; }
        getDocs() { return 'Render particles with default material shader.'; }
    }
    DefaultMaterial.desc = desc;
    return { [`fx/${desc}`]: DefaultMaterial };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "H+Dh":
/*!***************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/Kill.ts ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_1__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


function producer(env) {
    const desc = "Kill";
    const name = "Kill";
    const HIDDEN_CONNECTION = { visible: false };
    class Kill extends _GraphNode__WEBPACK_IMPORTED_MODULE_1__.CodeEmitterNode {
        constructor() {
            super(name);
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_0__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.size = [100, 0];
        }
        compute(context, program) {
            const scope = program.currentScope;
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_1__.AST)(context, program);
            return [ast.return(ast.bool(false))];
        }
    }
    Kill.desc = desc;
    Kill.color = 'transparent';
    // static bgcolor = 'transparent';
    Kill.can_be_dropped = true;
    return { [`fx/${desc}`]: Kill };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "7U7x":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/KillBy.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IfStmtInstruction */ "AAir");
/* harmony import */ var _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/StmtBlockInstruction */ "fc3/");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_3__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




function producer(env) {
    const desc = "Kill By";
    const name = "Kill By";
    const HIDDEN_CONNECTION = { visible: false };
    class KillBy extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super(name);
            this.addInput("cond", "bool", { pos: [13, -13], label: "" });
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_2__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.size = [100, 0];
        }
        onDrawTitleBox(ctx, titleHeight, size, scale) {
            // skip render of title pin
        }
        compute(context, program) {
            const deps = super.compute(context, program);
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_3__.AST)(context, program);
            const scope = program.currentScope;
            const cond = this.getInputNode('cond')?.exec(context, program, this.getOriginalSlot('cond')) ||
                this.exec(context, program, 0) /* false */;
            const conseqStmts = [ast.return(ast.bool(false))];
            const conseq = conseqStmts ? new _lib_fx_analisys_instructions_StmtBlockInstruction__WEBPACK_IMPORTED_MODULE_1__.StmtBlockInstruction({ scope, stmtList: conseqStmts }) : null;
            return [...deps, new _lib_fx_analisys_instructions_IfStmtInstruction__WEBPACK_IMPORTED_MODULE_0__.IfStmtInstruction({ scope, cond, conseq })];
        }
    }
    KillBy.desc = desc;
    KillBy.color = 'transparent';
    KillBy.can_be_dropped = true;
    KillBy.collapsable = false;
    return { [`fx/${desc}`]: KillBy };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "zLQT":
/*!**********************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/LwiMaterial.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common */ "sVSU");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_4__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





function producer(env) {
    const layout = env().root.scope.types[_common__WEBPACK_IMPORTED_MODULE_3__.PART_TYPE];
    const desc = "LwiMaterial";
    const name = "Lwi Material";
    class LwiMaterial extends _GraphNode__WEBPACK_IMPORTED_MODULE_4__.CodeEmitterNode {
        constructor() {
            super(name);
            this.map = { transform: 0, template: 1 };
            this.addInput('transform', 'float3x4');
            this.addInput('template', 'int');
            this.size = [180, 25 * (2) + 50 * 2];
            this.addProperty("Sorting", true, "bool");
            this.sortingWidget = this.addWidget("toggle", "Sorting", true, "value");
            this.addProperty("Geometry", "Box", "string");
            this.geometryWidget = this.addWidget("text", "Geometry", "Box", "value");
            this.serialize_widgets = true;
            // this.widgets_up = true;
        }
        get sorting() {
            return this.sortingWidget.value;
        }
        get geometry() {
            return this.geometryWidget.value;
        }
        extend(env) {
            const uri = env.uri;
            const scope = env.root.scope;
            const program = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.ProgramScope(scope);
            const context = new _GraphNode__WEBPACK_IMPORTED_MODULE_4__.GraphContext(uri);
            this.onBeforeExecution(context, program);
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_4__.AST)(context, program);
            const execInput = id => this.getInputNode(id).exec(context, program, this.getOriginalSlot(id));
            context.beginFunc();
            const fdecl = ast.func(`int PrerenderRoutine${this.id}(inout Part part, inout LwiInstance input)`, () => [
                ...this.getInputNode('transform').compute(context, program),
                ...this.getInputNode('template').compute(context, program),
                // input.worldMatrPrev[0] = input.worldMatr[0];
                // input.worldMatrPrev[1] = input.worldMatr[1];
                // input.worldMatrPrev[2] = input.worldMatr[2];
                ast.assigment(ast.postfixpoint('input.worldMatrPrev'), ast.postfixpoint('input.worldMatr')),
                // input.worldMatr[0] = transform[0];
                // input.worldMatr[1] = transform[1];
                // input.worldMatr[2] = transform[2];
                ast.assigment(ast.postfixpoint('input.worldMatr'), execInput('transform')),
                ast.return(execInput('template'))
            ]);
            context.endFunc();
            const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__.Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);
            const instructions = env.root.instructions.concat([fdecl]);
            const root = new _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__.InstructionCollector({ scope: program.globalScope, instructions });
            return { root, diagnosticReport, uri };
        }
        async run(env) {
            return this.extend(env);
        }
        getDocs() { return 'Render particles as lwi templates.'; }
    }
    LwiMaterial.desc = desc;
    return { [`fx/${desc}`]: LwiMaterial };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "Ts+a":
/*!****************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/Param.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_0__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

function producer(env) {
    const nodes = {};
    let types = {};
    let scope = env().root.scope;
    while (scope) {
        types = { ...types, ...scope.types };
        scope = scope.parent;
    }
    for (let name in types) {
        let t = types[name];
        class Param extends _GraphNode__WEBPACK_IMPORTED_MODULE_0__.CodeEmitterParam {
            constructor() {
                super(`${name}`);
                this.addOutput('out', t.name);
                this.title = `${this.getType()} ${this.getName()}`;
                this.size = this.computeSize();
                this.size[1] = 0;
                this.outputs[0].pos = [this.size[0] - 13, -13];
                this.outputs[0].label = '';
            }
            onDrawTitleBox(ctx, titleHeight, size, scale) {
                // skip render of title pin
            }
            getName() {
                return `p${this.id}`;
            }
            getType() {
                return t.name;
            }
            exec(context, program) {
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_0__.AST)(context, program).idexpr(this.getName());
            }
        }
        Param.desc = `${name} param`;
        Param.title_color = `rgba(255, 170, 0, 0.7)`;
        Param.collapsable = false;
        Param.color = 'transparent';
        nodes[`params/${name}`] = Param;
    }
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "Xmng":
/*!***************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/Part.ts ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/AssignmentExprInstruction */ "eck/");
/* harmony import */ var _lib_fx_analisys_instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/ExprStmtInstruction */ "ubxH");
/* harmony import */ var _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/idl/EAnalyzerErrors */ "jeW/");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common */ "sVSU");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_9__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_9__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];










function producer(env) {
    const nodes = {};
    const type = env().root.scope.types[_common__WEBPACK_IMPORTED_MODULE_8__.PART_TYPE];
    const name = `${_common__WEBPACK_IMPORTED_MODULE_8__.PART_LOCAL_NAME}`;
    const desc = `${name} (previous value).`;
    function evaluatePartExpr(context, program) {
        const sourceNode = null;
        const callee = null;
        const scope = program.currentScope;
        const decl = scope.findVariable(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });
            // TODO: autogen graph error
            return null;
        }
        const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_4__.IdInstruction({ scope, sourceNode, name });
        return new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_3__.IdExprInstruction({ scope, sourceNode, id, decl });
    }
    const HIDDEN_CONNECTION = { visible: false };
    type.fields.forEach(field => {
        // todo: add suppor of complex types
        if (field.type.isComplex()) {
            return;
        }
        const name = `${_common__WEBPACK_IMPORTED_MODULE_8__.PART_LOCAL_NAME}.${field.name}`;
        const desc = `${name} (previous value).`;
        class Part extends _GraphNode__WEBPACK_IMPORTED_MODULE_9__.CodeEmitterNode {
            constructor() {
                super(name);
                this.addInput(name, field.type.name, { pos: [13, -13], label: "" });
                this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_7__.LiteGraph.ACTION, HIDDEN_CONNECTION);
                this.size = this.computeSize();
                this.size[1] = 0;
            }
            onDrawTitleBox(ctx, titleHeight, size, scale) {
                // skip render of title pin
            }
            compute(context, program) {
                if (!this.isInputConnected(0))
                    return [];
                const deps = super.compute(context, program);
                const scope = program.currentScope;
                const right = this.getInputNode(0).exec(context, program, this.getOriginalSlot(0));
                const element = evaluatePartExpr(context, program);
                const postfix = new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_3__.IdExprInstruction({
                    scope,
                    id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_4__.IdInstruction({ scope, name: field.name }),
                    decl: element.type.getField(field.name)
                });
                const left = new _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_5__.PostfixPointInstruction({ scope, element, postfix });
                const expr = new _lib_fx_analisys_instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_1__.AssignmentExprInstruction({ scope, left, right, operator: '=' });
                if (!right.type.readable) {
                    context.error(right.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_6__.EAnalyzerErrors.InvalidTypeForReading);
                }
                if (!left.type.writable) {
                    context.error(left.sourceNode, _lib_idl_EAnalyzerErrors__WEBPACK_IMPORTED_MODULE_6__.EAnalyzerErrors.InvalidTypeForWriting);
                }
                return [...deps, new _lib_fx_analisys_instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprStmtInstruction({ scope, expr })];
            }
        }
        Part.desc = desc;
        Part.color = 'transparent';
        Part.can_be_dropped = true;
        Part.collapsable = false;
        nodes[`fx/out ${name}`] = Part;
    });
    class Part extends _GraphNode__WEBPACK_IMPORTED_MODULE_9__.CodeEmitterNode {
        constructor() {
            super(name);
            type.fields.forEach(field => {
                // todo: add suppor of complex types
                if (field.type.isComplex()) {
                    return;
                }
                const name = `${field.name}`;
                this.addInput(name, field.type.name);
            });
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_7__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.size = this.computeSize();
        }
        compute(context, program) {
            if (!this.isInputConnected(0))
                return [];
            const deps = super.compute(context, program);
            const scope = program.currentScope;
            return [...deps, ...this.inputs
                    .map((v, i) => i)
                    .slice(0, -1)
                    .map((input, i) => {
                    const right = this.getInputNode(i).exec(context, program, this.getOriginalSlot(i));
                    const element = evaluatePartExpr(context, program);
                    const postfix = new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_3__.IdExprInstruction({
                        scope,
                        id: new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_4__.IdInstruction({ scope, name: type.fields[i].name }),
                        decl: element.type.getField(type.fields[i].name)
                    });
                    const left = new _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_5__.PostfixPointInstruction({ scope, element, postfix });
                    const expr = new _lib_fx_analisys_instructions_AssignmentExprInstruction__WEBPACK_IMPORTED_MODULE_1__.AssignmentExprInstruction({ scope, left, right, operator: '=' });
                    return new _lib_fx_analisys_instructions_ExprStmtInstruction__WEBPACK_IMPORTED_MODULE_2__.ExprStmtInstruction({ scope, expr });
                })];
        }
    }
    Part.desc = desc;
    Part.color = 'transparent';
    Part.can_be_dropped = true;
    Part.collapsable = false;
    nodes[`fx/out ${name}`] = Part;
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "H1jh":
/*!*****************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/PartId.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_0__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

function producer(env) {
    class PartId extends _GraphNode__WEBPACK_IMPORTED_MODULE_0__.CodeEmitterNode {
        constructor() {
            super('Part ID');
            this.addOutput('id', 'int', { label: '' });
            this.size = this.computeSize();
            this.size[1] = 0;
            this.size[0] = Math.max(180, this.size[0]);
            this.outputs[0].pos = [this.size[0] - 13, -13];
        }
        onDrawTitleBox(ctx, titleHeight, size, scale) {
            // skip render of title pin
        }
        exec(context, program, slot) {
            const scope = program.currentScope;
            const name = 'partId';
            const decl = scope.findVariable(name);
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_0__.AST)(context, program);
            if (!decl) {
                this.emitError(`Part ID has not been found.`);
                return null;
            }
            return ast.idexpr(name);
        }
    }
    PartId.desc = 'Autogenerated particle ID.';
    PartId.collapsable = false;
    PartId.color = 'transparent';
    return { [`fx/partId`]: PartId };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "4Und":
/*!*******************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/PartInit.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _sandbox_components_graphEx_fx_SpawnOp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/SpawnOp */ "gbPg");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_components_graphEx_fx_SpawnOp__WEBPACK_IMPORTED_MODULE_4__, _GraphNode__WEBPACK_IMPORTED_MODULE_5__]);
([_sandbox_components_graphEx_fx_SpawnOp__WEBPACK_IMPORTED_MODULE_4__, _GraphNode__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);






function producer(env) {
    const desc = "InitRoutine";
    const name = "Init Routine";
    const HIDDEN_CONNECTION = { visible: false };
    class PartInit extends _GraphNode__WEBPACK_IMPORTED_MODULE_5__.PartRoutine {
        constructor() {
            super(name);
            this.pure = false;
            this.operators = null;
            this.addOutput("stmts", litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.EVENT, HIDDEN_CONNECTION);
            this.update();
        }
        onDrop(node) {
            // todo: validate node
            if (this.connect('stmts', node, 'context')) {
                this.update();
                this.highlight(false);
            }
        }
        findParamsDependencies() {
            function filterParams(node, params = []) {
                let checkLink = (id, output) => {
                    let link = node.graph.links[id];
                    if (!link)
                        return;
                    let targetNode = node.graph.getNodeById(output ? link.target_id : link.origin_id);
                    filterParams(targetNode, params);
                    if (targetNode instanceof _GraphNode__WEBPACK_IMPORTED_MODULE_5__.CodeEmitterParam) {
                        params.push(targetNode);
                    }
                };
                node.inputs?.filter(slot => slot.type !== litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.ACTION && slot.link !== null).forEach(({ link }) => checkLink(link, false));
                node.outputs?.filter(slot => slot.type == litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.EVENT).forEach(({ links }) => links?.forEach(id => checkLink(id, true)));
                return params;
            }
            return [...new Set(filterParams(this))];
        }
        extend(env) {
            const uri = env.uri;
            const scope = env.root.scope;
            const program = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.ProgramScope(scope);
            const context = new _GraphNode__WEBPACK_IMPORTED_MODULE_5__.GraphContext(uri);
            this.onBeforeExecution(context, program);
            let params = this.findParamsDependencies().map(node => `${node.getType()} ${node.getName()}`).join(', ');
            params = params && `, ${params}`;
            // cache info whether we have dependencies (can be used as regular per frame routine)
            this.pure = !params;
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_5__.AST)(context, program);
            context.beginFunc();
            const fdecl = ast.func(`void InitRoutine${this.id}(out Part part, int partId ${params})`, () => (this.getOutputNodes(0) || []).map(node => node.compute(context, program)).flat());
            context.endFunc();
            const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__.Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);
            const instructions = env.root.instructions.concat([fdecl]);
            const root = new _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__.InstructionCollector({ scope: program.globalScope, instructions });
            return { root, diagnosticReport, uri };
        }
        async run(env) {
            return this.extend(env);
        }
        onAdded(graph) {
            this.operators = (0,_sandbox_components_graphEx_fx_SpawnOp__WEBPACK_IMPORTED_MODULE_4__["default"])(env, this);
            // register all available nodes
            Object.keys(this.operators).forEach(link => litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.registerNodeType(link, this.operators[link]));
        }
        onRemoved() {
            Object.keys(this.operators)
                .map(link => this.graph.findNodesByType(link))
                .flat()
                .forEach(node => this.graph.remove(node));
            Object.keys(this.operators).forEach(link => litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.unregisterNodeType(link));
        }
        getDocs() { return 'Determines initial state of each particle.'; }
    }
    PartInit.desc = desc;
    return { [`fx/${desc}`]: PartInit };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "cIOx":
/*!***********************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/PartPrevious.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/Analyzer */ "R35j");
/* harmony import */ var _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdExprInstruction */ "kBTl");
/* harmony import */ var _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IdInstruction */ "Muaz");
/* harmony import */ var _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/analisys/instructions/PostfixPointInstruction */ "++2t");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common */ "sVSU");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_6__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







function producer(env) {
    const nodes = {};
    const type = env().root.scope.types[_common__WEBPACK_IMPORTED_MODULE_5__.PART_TYPE];
    const name = `${_common__WEBPACK_IMPORTED_MODULE_5__.PART_LOCAL_NAME}`;
    const desc = `${name} (previous value).`;
    function evaluatePartExpr(context, program) {
        const sourceNode = null;
        const callee = null;
        const scope = program.currentScope;
        const decl = scope.findVariable(name);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(decl)) {
            //context.error(sourceNode, EErrors.UnknownVarName, { varName: name });
            // TODO: autogen graph error
            return null;
        }
        const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, sourceNode, name });
        return new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_2__.IdExprInstruction({ scope, sourceNode, id, decl });
    }
    type.fields.forEach(field => {
        // todo: add suppor of complex types
        if (field.type.isComplex()) {
            return;
        }
        const name = `${_common__WEBPACK_IMPORTED_MODULE_5__.PART_LOCAL_NAME}.${field.name}`;
        const desc = `${name} (previous value).`;
        class PartPrevous extends _GraphNode__WEBPACK_IMPORTED_MODULE_6__.CodeEmitterNode {
            constructor() {
                super(name);
                this.addOutput(name, field.type.name);
                this.size = this.computeSize();
                this.size[1] = 0;
                this.outputs[0].pos = [this.size[0] - 13, -13];
                this.outputs[0].label = '';
            }
            onDrawTitleBox(ctx, titleHeight, size, scale) {
                // skip render of title pin
            }
            exec(context, program, slot) {
                const sourceNode = null;
                const scope = program.currentScope;
                const element = evaluatePartExpr(context, program);
                const name = field.name;
                const decl = _lib_fx_analisys_Analyzer__WEBPACK_IMPORTED_MODULE_1__.Analyzer.createFieldDecl(element.type, name);
                const id = new _lib_fx_analisys_instructions_IdInstruction__WEBPACK_IMPORTED_MODULE_3__.IdInstruction({ scope, sourceNode, name });
                const postfix = new _lib_fx_analisys_instructions_IdExprInstruction__WEBPACK_IMPORTED_MODULE_2__.IdExprInstruction({ scope, sourceNode, id, decl });
                return new _lib_fx_analisys_instructions_PostfixPointInstruction__WEBPACK_IMPORTED_MODULE_4__.PostfixPointInstruction({ sourceNode, scope, element, postfix });
            }
        }
        PartPrevous.desc = desc;
        PartPrevous.collapsable = false;
        PartPrevous.color = 'transparent';
        nodes[`fx/${name}`] = PartPrevous;
    });
    class PartPrevous extends _GraphNode__WEBPACK_IMPORTED_MODULE_6__.CodeEmitterNode {
        constructor() {
            super(name);
            this.addOutput(_common__WEBPACK_IMPORTED_MODULE_5__.PART_LOCAL_NAME, _common__WEBPACK_IMPORTED_MODULE_5__.PART_TYPE);
            this.size = [100, 25];
        }
        exec(context, program, slot) {
            return evaluatePartExpr(context, program);
        }
    }
    PartPrevous.desc = desc;
    nodes[`fx/${name}`] = PartPrevous;
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "mGRc":
/*!********************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/PartSpawn.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_3__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




function spawnCode(env, plugs = {}) {
    return (`int SpawnRoutine() { return ${(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(plugs.count) ? String(plugs.count) : '$count'}; }`);
}
/** @deprecated */
function asGraphContext(ctx) {
    // temp hack for compartibility
    let varNum = 0;
    ctx.addLocal = () => `t${varNum++}`;
    return ctx;
}
function producer(env) {
    const desc = "SpawnRoutine";
    const name = "SpawnRoutine";
    const propName = 'count';
    class Node extends _GraphNode__WEBPACK_IMPORTED_MODULE_3__.CodeEmitterNode {
        constructor() {
            super(name);
            this.addInput(propName, "int");
            this.addProperty(propName, 1, "number");
            this.size = [180, 30];
            this.updateInputNames();
        }
        async run(env) {
            // hack to be compartible, this function must be rewritten same way as PartUpdate.
            this.onBeforeExecution(null, null);
            const inputNode = this.getInputNode(0);
            const plugs = {};
            if (!inputNode) {
                plugs.count = +this.properties[propName].toFixed(0);
            }
            const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)("://SpawnRoutine.hlsl", spawnCode(env, plugs));
            return (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_1__.extendSLDocument)(textDocument, env, {
                '$count': (context, program, sourceNode) => {
                    inputNode.compute(asGraphContext(context), program);
                    return inputNode.exec(context, program, this.getOriginalSlot(0));
                }
            });
        }
        getTitle() { return 'Spawn routine'; }
        getDocs() { return 'Determines number of particles spawnd per second.'; }
        updateInputNames() {
            const input = this.inputs[0];
            input.name = !input.link ? `${propName} = ${this.properties[propName]}` : propName;
        }
        onConnectionsChange(type, slotIndex, isConnected, link, ioSlot) {
            super.onConnectionsChange(type, slotIndex, isConnected, link, ioSlot);
            this.updateInputNames();
        }
        onPropertyChanged(name, value, prevValue) {
            super.onPropertyChanged(name, value, prevValue);
            this.updateInputNames();
            return true;
        }
    }
    Node.desc = desc;
    return { [`fx/${desc}`]: Node };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "0j9O":
/*!*********************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/PartUpdate.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/InstructionCollector */ "pjXG");
/* harmony import */ var _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/ProgramScope */ "zHDc");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_4__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





function producer(env) {
    const desc = "UpdateRoutine";
    const name = "UpdateRoutine";
    const HIDDEN_CONNECTION = { visible: false };
    class PartUpdate extends _GraphNode__WEBPACK_IMPORTED_MODULE_4__.PartRoutine {
        constructor() {
            super(name);
            this.addOutput("stmts", litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.EVENT, HIDDEN_CONNECTION);
            this.update();
        }
        onDrop(node) {
            // todo: validate node
            if (this.connect('stmts', node, 'context')) {
                this.update();
                this.highlight(false);
            }
        }
        extend(env) {
            const uri = env.uri;
            const scope = env.root.scope;
            const program = new _lib_fx_analisys_ProgramScope__WEBPACK_IMPORTED_MODULE_1__.ProgramScope(scope);
            const context = new _GraphNode__WEBPACK_IMPORTED_MODULE_4__.GraphContext(uri);
            this.onBeforeExecution(context, program);
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_4__.AST)(context, program);
            context.beginFunc();
            const fdecl = ast.func(`bool UpdateRoutine(inout Part part, int partId)`, () => (this.getOutputNodes(0) || []).map(node => node.compute(context, program)).flat());
            context.endFunc();
            const diagnosticReport = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_2__.Diagnostics.mergeReports([env.diagnosticReport, context.diagnostics.resolve()]);
            const instructions = env.root.instructions.concat([fdecl]);
            const root = new _lib_fx_analisys_instructions_InstructionCollector__WEBPACK_IMPORTED_MODULE_0__.InstructionCollector({ scope: program.globalScope, instructions });
            return { root, diagnosticReport, uri };
        }
        async run(env) {
            return this.extend(env);
        }
        getTitle() { return 'Update routine'; }
        getDocs() { return 'Determines state of particle after each update.'; }
    }
    PartUpdate.desc = desc;
    return { [`fx/${desc}`]: PartUpdate };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "gbPg":
/*!******************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/SpawnOp.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/instructions/IntInstruction */ "s0og");
/* harmony import */ var _lib_fx_analisys_instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/analisys/instructions/part/SpawnInstruction */ "sg/T");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_4__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





function def(type, ast) {
    switch (type.name) {
        case 'float': return ast.float(0);
        case 'float2': return ast.float2(0, 0);
        case 'float3': return ast.float3(0, 0, 0);
        case 'float4': return ast.float4(0, 0, 0, 0);
    }
    return null;
}
function producer(env, spawner) {
    const desc = `Spawn '${spawner.title} (${spawner.id})'`;
    const HIDDEN_CONNECTION = { visible: false };
    class SpawnOp extends _GraphNode__WEBPACK_IMPORTED_MODULE_4__.CodeEmitterStmt {
        constructor() {
            super(`Spawn '${spawner.title}'`);
            const params = spawner.findParamsDependencies();
            this.addInput('count', 'int');
            params.forEach(param => this.addInput(param.getName(), param.getType()));
            this.addInput("context", litegraph_js__WEBPACK_IMPORTED_MODULE_3__.LiteGraph.ACTION, HIDDEN_CONNECTION);
            this.update();
        }
        onBeforeExecution(context, program) {
            const inputs = this.inputs.slice(1, -1).map((f, i) => i).filter(i => this.isInputConnected(i));
            if (!inputs.length) {
                return;
            }
            super.onBeforeExecution(context, program);
        }
        compute(context, program) {
            const fields = spawner.findParamsDependencies();
            const inputs = fields.map((f, i) => i + 1).filter(i => this.isInputConnected(i));
            fields.forEach((field, i) => this.inputs[i + 1].name = fields[i].title);
            // if (!inputs.length) {
            //     return [];
            // }
            const deps = super.compute(context, program);
            const scope = program.currentScope;
            const ast = (0,_GraphNode__WEBPACK_IMPORTED_MODULE_4__.AST)(context, program);
            let count = this.getInputNode('count')?.exec(context, program, this.getOriginalSlot('count'));
            if (!count) {
                const { base, signed, heximal, exp } = (0,_lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__.parseUintLiteral)('1');
                count = new _lib_fx_analisys_instructions_IntInstruction__WEBPACK_IMPORTED_MODULE_0__.IntInstruction({ scope, base, exp, signed, heximal });
            }
            const name = `InitRoutine${spawner.id}`;
            const args = inputs.map(i => this.getInputNode(i)?.exec(context, program, this.getOriginalSlot(i)));
            const spawnStmt = new _lib_fx_analisys_instructions_part_SpawnInstruction__WEBPACK_IMPORTED_MODULE_1__.SpawnInstruction({ scope, name, args, count });
            const params = inputs.map(i => scope.findType(fields[i - 1].getType()));
            // spawnStmt.$resolve(null, scope.findFunction(name, [ /Part/, /int/, ...params ]));
            context.spawnStmts.push(spawnStmt);
            return [...deps, spawnStmt];
        }
        onDrawTitleBox(ctx, titleHeight, size, scale) {
            // skip render of title pin
        }
    }
    SpawnOp.desc = desc;
    SpawnOp.color = 'transparent';
    SpawnOp.can_be_dropped = true;
    SpawnOp.collapsable = false;
    return { [`fx/actions/${desc}`]: SpawnOp };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "FzSB":
/*!********************************************************!*\
  !*** ./src/sandbox/components/graphEx/fx/UserConst.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GraphNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GraphNode */ "wEVW");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GraphNode__WEBPACK_IMPORTED_MODULE_0__]);
_GraphNode__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

function producer(env, constants) {
    const nodes = {};
    for (let desc of constants) {
        const { name, type: typeName, value } = desc;
        class UserConst extends _GraphNode__WEBPACK_IMPORTED_MODULE_0__.CodeEmitterNode {
            constructor() {
                super(`${name} (user const)`);
                this.addOutput('out', typeName, { label: '' });
                this.size = this.computeSize();
                this.size[1] = 0;
                this.size[0] = Math.max(180, this.size[0]);
                this.outputs[0].pos = [this.size[0] - 13, -13];
            }
            // override onBeforeExecution(context: GraphContext, program: ProgramScope): void {
            //     super.onBeforeExecution(context, program);
            // }
            onDrawTitleBox(ctx, titleHeight, size, scale) {
                // skip render of title pin
            }
            exec(context, program) {
                return (0,_GraphNode__WEBPACK_IMPORTED_MODULE_0__.AST)(context, program).idexpr(name);
            }
        }
        UserConst.desc = `${name} (user const)`;
        UserConst.collapsable = false;
        UserConst.color = 'transparent';
        nodes[`user constants/${name}`] = UserConst;
    }
    return nodes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (producer);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "ia+x":
/*!***********************************************************!*\
  !*** ./src/sandbox/components/graphEx/utils/LibLoader.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LibLoader": () => (/* binding */ LibLoader)
/* harmony export */ });
/* harmony import */ var _lib_parser_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/parser/helpers */ "wKf3");

class LibLoader extends _lib_parser_helpers__WEBPACK_IMPORTED_MODULE_0__.CommentExtractor {
    constructor() {
        super(...arguments);
        this.nodes = {};
        this.node = null;
    }
    beginComment(content) {
        this.node = { name: null };
    }
    applyRule(rule, parts, loc) {
        let value = parts.slice(1).join(' ');
        switch (rule) {
            case '@node':
                {
                    this.node.name = value.match(/\{([^\{\}]*)\}/)[1].trim();
                    break;
                }
            case '@desc':
                {
                    this.node.desc = value.trim();
                    break;
                }
            case '@title':
                {
                    this.node.title = value.trim();
                    break;
                }
        }
    }
    endComment() {
        if (this.node.name) {
            this.nodes[this.node.name] = this.node;
        }
    }
}


/***/ }),

/***/ "Qk0k":
/*!******************************************************!*\
  !*** ./src/sandbox/components/graphEx/utils/docs.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _sandbox_components_graphEx_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/components/graphEx/GraphNode */ "wEVW");
/* harmony import */ var _LibLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LibLoader */ "ia+x");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_components_graphEx_GraphNode__WEBPACK_IMPORTED_MODULE_1__]);
_sandbox_components_graphEx_GraphNode__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



async function XHRResolveFile(uri) {
    try {
        const request = new XMLHttpRequest();
        request.open('GET', uri, false);
        request.send(null);
        if (request.status !== 200) {
            console.error(`unable to request file ''${uri}`);
            return null;
        }
        return (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_0__.createTextDocument)(uri, request.responseText);
    }
    catch (e) {
        console.error(e);
    }
    return null;
}
async function loader(lib) {
    const docs = [
        lib,
        // ...
    ];
    let ll = new _LibLoader__WEBPACK_IMPORTED_MODULE_2__.LibLoader();
    for (let doc of docs) {
        await ll.parse(doc, XHRResolveFile);
    }
    for (let node in ll.nodes) {
        _sandbox_components_graphEx_GraphNode__WEBPACK_IMPORTED_MODULE_1__.CodeEmitterNode.nodesDocs[node] = ll.nodes[node];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loader);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "YTDY":
/*!****************************************!*\
  !*** ./src/sandbox/containers/App.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "styles": () => (/* binding */ styles)
/* harmony export */ });
/* harmony import */ var _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/autotests */ "kaOZ");
/* harmony import */ var _lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/Visitors */ "q04y");
/* harmony import */ var _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/analisys/system/utils */ "BeyE");
/* harmony import */ var _lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/analisys/SystemScope */ "c0pO");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/bytecode */ "0jsi");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/translators/FxEmitter */ "h9Zj");
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/util/p4/p4 */ "kVxP");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_components_ASTView__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sandbox/components/ASTView */ "7071");
/* harmony import */ var _sandbox_components_CodeView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sandbox/components/CodeView */ "/Qnb");
/* harmony import */ var _sandbox_components_FileListView__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sandbox/components/FileListView */ "BJah");
/* harmony import */ var _sandbox_components_GraphConfigView__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sandbox/components/GraphConfigView */ "B87d");
/* harmony import */ var _sandbox_components_GraphView__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sandbox/components/GraphView */ "h7kT");
/* harmony import */ var _sandbox_components_MemoryView__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sandbox/components/MemoryView */ "87NW");
/* harmony import */ var _sandbox_components_PreprocessorView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @sandbox/components/PreprocessorView */ "qjqD");
/* harmony import */ var _sandbox_components_ProgramView__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @sandbox/components/ProgramView */ "/g6V");
/* harmony import */ var _sandbox_containers_BytecodeView__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sandbox/containers/BytecodeView */ "J1YF");
/* harmony import */ var _sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @sandbox/containers/editor/Editor */ "tFt3");
/* harmony import */ var _sandbox_containers_ParserParameters__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sandbox/containers/ParserParameters */ "u7fn");
/* harmony import */ var _sandbox_containers_playground_Playground__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sandbox/containers/playground/Playground */ "D8bm");
/* harmony import */ var _sandbox_containers_ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @sandbox/containers/ShaderTranslatorView */ "++iD");
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @sandbox/reducers/router */ "va7o");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! connected-react-router */ "qLko");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @sandbox/logic/nodesEx */ "q0SN");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! fs */ "Q/He");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! react-router */ "vpSu");
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! semantic-ui-react */ "OXt0");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! semantic-ui-react */ "g3Zx");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! semantic-ui-react */ "l9XU");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! semantic-ui-react */ "iXaK");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! semantic-ui-react */ "35Nk");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! semantic-ui-react */ "3GrG");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! semantic-ui-react */ "vrEI");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! semantic-ui-react */ "5+SC");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! semantic-ui-react */ "OcRK");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! semantic-ui-react */ "fbB6");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! semantic-ui-react */ "Uh+m");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! semantic-ui-react */ "UeIX");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! semantic-ui-react */ "21rH");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! semantic-ui-react */ "us11");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! semantic-ui-react */ "wi9p");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _ShaderTranslatorView11__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./ShaderTranslatorView11 */ "NX5m");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_4__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_9__, _sandbox_components_ASTView__WEBPACK_IMPORTED_MODULE_10__, _sandbox_components_GraphConfigView__WEBPACK_IMPORTED_MODULE_13__, _sandbox_components_MemoryView__WEBPACK_IMPORTED_MODULE_15__, _sandbox_components_PreprocessorView__WEBPACK_IMPORTED_MODULE_16__, _sandbox_components_ProgramView__WEBPACK_IMPORTED_MODULE_17__, _sandbox_containers_BytecodeView__WEBPACK_IMPORTED_MODULE_18__, _sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__, _sandbox_containers_ParserParameters__WEBPACK_IMPORTED_MODULE_20__, _sandbox_containers_playground_Playground__WEBPACK_IMPORTED_MODULE_21__, _sandbox_containers_ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_22__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_24__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_25__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__, _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_31__, _ShaderTranslatorView11__WEBPACK_IMPORTED_MODULE_38__]);
([_lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_4__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_9__, _sandbox_components_ASTView__WEBPACK_IMPORTED_MODULE_10__, _sandbox_components_GraphConfigView__WEBPACK_IMPORTED_MODULE_13__, _sandbox_components_MemoryView__WEBPACK_IMPORTED_MODULE_15__, _sandbox_components_PreprocessorView__WEBPACK_IMPORTED_MODULE_16__, _sandbox_components_ProgramView__WEBPACK_IMPORTED_MODULE_17__, _sandbox_containers_BytecodeView__WEBPACK_IMPORTED_MODULE_18__, _sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__, _sandbox_containers_ParserParameters__WEBPACK_IMPORTED_MODULE_20__, _sandbox_containers_playground_Playground__WEBPACK_IMPORTED_MODULE_21__, _sandbox_containers_ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_22__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_24__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_25__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__, _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_31__, _ShaderTranslatorView11__WEBPACK_IMPORTED_MODULE_38__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/* tslint:disable:max-func-body-length */
/* tslint:disable:typedef */
/* tslint:disable:no-single-line-block-comment */





























// global defines from webpack's config;
/// <reference path="../webpack.d.ts" />



 // << todo: remove
 // << todo: remove








const styles = {
    toastFontFix: {
        '& .icon:before': {
            fontFamily: `'Icons' !important`,
            fontSize: '200%'
        }
    },
    sidebarLeftHotfix: {
        width: `57px !important`,
        backgroundColor: '#1e1e1e !important',
        '& > .item': {
            minWidth: 'auto !important'
        }
    },
    mainContentHotfix: {
        marginLeft: `calc(57px)`
    },
    mainViewHeightHotfix: {
        marginBottom: '0 !important'
    },
    fileBrowserSidebarFix: {
        padding: '10px !important',
        background: 'rgba(255,255,255,0.95) !important',
        minWidth: '440px'
    },
    containerMarginFix: {
        border: '0px !important',
        padding: '0 !important'
    },
    topMenuFix: {
        '& > div:first-child': {
            marginBottom: '0',
            position: 'relative',
            zIndex: '2',
            // boxShadow: '0 2px 5px rgba(10,10,10, 0.1) !important',
            backgroundColor: 'white !important'
        },
        '& > .menu:first-child': {
            '& .item': {
                '&.active': {
                    border: '0 !important'
                }
            }
        }
    },
    rightColumnFix: {
        // boxShadow: '-5px 0 5px black',
        zIndex: 1,
        paddingLeft: '0 !important',
        backgroundColor: 'white',
        '& > .container': {
            paddingTop: '15px'
        }
    },
    leftColumnFix: {
        paddingRight: '0px !important'
    },
    versionFix: {
        padding: '5px !important',
        margin: '-5px !important'
    },
    tabHeaderFix: {
        marginTop: 0,
        boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.075)'
    },
    mainMenu: {
        '& > .item': {
            padding: '0 7px !important',
            margin: '0 !important',
            borderRight: '1px solid #ccc !important',
            borderRadius: '0 !important',
            minHeight: '40px'
        }
    },
    //
    // SourceCodeMenu
    //
    mebFix: {
        background: '#1e1e1e !important',
        position: 'relative',
        zIndex: 1,
        height: 'auto !important',
        minHeight: 'auto !important',
        '& .menu': {
            alignSelf: 'baseline !important'
        },
        '& .item': {
            opacity: '0.6 !important',
            alignSelf: 'baseline !important',
            paddingTop: '5px !important',
            paddingBottom: '5px !important',
            '&.active': {
                border: '0 !important',
                fontWeight: 'normal !important',
                opacity: '0.75 !important'
            }
        },
        '& .item.breadcrumb': {
            paddingRight: '0 !important',
            // '&:not(:first-child)': {
            //     paddingLeft: '0 !important'
            // },
            '&.active': {}
        }
    },
    ///
    dropdownItemFix: {
        '& i': {
            float: 'initial !important'
        },
    }
};
const Version = (props) => {
    return (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_39__["default"], { trigger: react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_40__["default"], { warning: "development" !== 'production', size: 'tiny', compact: true, className: props.classes.versionFix },
                "development",
                " | ",
                "develop",
                "-",
                "0.0.11.8b8be6a")), 
        // position='left center'
        size: 'small', content: "Wed Mar 08 2023 02:32:03 GMT+0300 (Moscow Standard Time)", inverted: true }));
};
const S3DStatus = (props) => (props.env &&
    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_40__["default"], { size: 'tiny', compact: true, className: props.classes.versionFix },
        "Saber / ",
        props.env.Get('game-name')));
const P4Status = ({ info, classes }) => {
    return (info &&
        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_39__["default"], { trigger: react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_40__["default"], { size: 'tiny', error: !info, success: !!info, compact: true, className: classes.versionFix }, info ? 'p4 is connected' : 'p4 is disconnected')), 
            // position='left center'
            size: 'small', content: info &&
                react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
                    "server: ",
                    info['Proxy address'],
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("br", null),
                    "client: ",
                    info['Client name']), inverted: true }));
};
class SourceCodeMenuRaw extends react__WEBPACK_IMPORTED_MODULE_34__.Component {
    constructor() {
        super(...arguments);
        this.state = {
            activeItem: 'vertexshader'
        };
        this.handleItemClick = (e, { name }) => this.setState({ activeItem: name });
    }
    get view() {
        return this.props.path.view;
    }
    get name() {
        return this.props.path.name;
    }
    handleGraphClick() {
        // view: "graph"
        // fx: "macro.fx"
        // name: "raw"
        const { path } = this.props;
        _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__.history.push(`/${path.view}/${path.fx}/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_KEYWORD}`);
    }
    handlePreprocessedClick() {
        // view: "preprocessor"
        // fx: "macro.fx"
        // name: "raw"
        const { path } = this.props;
        _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__.history.push(`/${path.view}/${path.fx}/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.RAW_KEYWORD}`);
    }
    handleFormattedClick() {
        const { path } = this.props;
        _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__.history.push(`/${path.view}/${path.fx}/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.CODE_KEYWORD}`);
    }
    handleEditorClick() {
        const { path } = this.props;
        _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__.history.push(`/${path.view}/${path.fx}`);
    }
    render() {
        const { state: { activeItem }, props: { path } } = this;
        const isEd = !this.name;
        const isFormatted = this.name === _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.CODE_KEYWORD;
        const isPP = this.name === _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.RAW_KEYWORD;
        const isGR = this.name === _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_KEYWORD;
        return (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { size: 'mini', pointing: true, secondary: true, inverted: true, attached: true, className: this.props.classes.mebFix },
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { className: 'breadcrumb', name: 'sourcecode', active: activeItem === 'sourcecode', onClick: this.handleItemClick }, "source code\u00A0\u00A0\u00A0\u00A0|"),
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { className: 'breadcrumb', name: 'vertexshader', active: activeItem === 'vertexshader', onClick: this.handleItemClick },
                path.name &&
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
                        path.name,
                        "\u00A0\u00A0\u00A0|\u00A0\u00A0\u00A0"),
                path.pass &&
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
                        `pass[${path.pass}]`,
                        "\u00A0\u00A0\u00A0|\u00A0\u00A0\u00A0"),
                path.property &&
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null, path.property)),
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { color: isEd ? 'yellow' : null, active: isEd, header: isEd, onClick: !isEd ? this.handleEditorClick : null }, "Editor"),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { color: isPP ? 'yellow' : null, active: isPP, header: isPP, onClick: !isPP ? this.handlePreprocessedClick : null }, "Preprocessed"),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { color: isFormatted ? 'yellow' : null, active: isFormatted, header: isFormatted, onClick: !isFormatted ? this.handleFormattedClick : null }, "Formatted"),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { color: isGR ? 'yellow' : null, active: isGR, header: isGR, onClick: !isGR ? this.handleGraphClick : null }, "Graph"))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], SourceCodeMenuRaw.prototype, "handleGraphClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], SourceCodeMenuRaw.prototype, "handlePreprocessedClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], SourceCodeMenuRaw.prototype, "handleFormattedClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], SourceCodeMenuRaw.prototype, "handleEditorClick", null);
let SourceCodeMenu = (0,react_jss__WEBPACK_IMPORTED_MODULE_42__["default"])(styles)(SourceCodeMenuRaw);
;
let App = class App extends react__WEBPACK_IMPORTED_MODULE_34__.Component {
    constructor(props) {
        super(props);
        this.expressionRef = react__WEBPACK_IMPORTED_MODULE_34__.createRef();
        //
        // Side pamel
        //
        this.handleShowFileBrowser = () => this.setState({ showFileBrowser: !this.state.showFileBrowser });
        this.hideFileBrowser = () => this.setState({ showFileBrowser: false });
        this.state = {
            showFileBrowser: false,
            testProcessing: false,
            confirmDialog: { open: false, title: null, message: null, onAccept: null, onReject: null },
            depotFilter: '',
            bytecodeDebuggerType: 'expression'
        };
    }
    static getDerivedStateFromProps(props, state) {
        const nextAnalysis = props.sourceFile.slDocument;
        const contentChanged = !(state.prevAnalysis === nextAnalysis);
        let stateDiff = null;
        if (contentChanged) {
            stateDiff = { prevAnalysis: nextAnalysis };
        }
        return stateDiff;
    }
    handleCreateNewEffect() {
        this.openFile(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.fromLocalPath(_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.DEFAULT_FILENAME));
    }
    setAutocompile(autocompile) {
        this.props.actions.specifyOptions({ autocompile });
    }
    setShaderFormat(format) {
        this.props.actions.setShaderFormat(format);
    }
    //
    // Runtime options
    //
    switchVMRuntime() {
        this.props.actions.specifyOptions({ wasm: !this.props.sourceFile.debugger.options.wasm });
    }
    switchEmitterRuntime() {
        this.props.actions.switchRuntime();
    }
    //
    // Bytecode tab functionality
    //
    async runAutotests() {
        this.setState({ testProcessing: true });
        // timeout for playing animation in UI
        setTimeout(async () => {
            const { content: source, uri } = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(this.props);
            const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__.createTextDocument)(uri, source);
            const autotests = await _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__.parse(textDocument);
            await _lib_fx_autotests__WEBPACK_IMPORTED_MODULE_0__.run(autotests);
            if (!autotests.passed) {
                console.warn(autotests);
            }
            autotests.tests.forEach((test, iTest) => {
                const testName = `${test.name}-${iTest}`;
                this.highlightTest(test.name, test.loc, false);
                this.highlightTest(test.name, test.loc, true, test.passed);
                test.cases.forEach((exam, iExam) => {
                    const examName = `${testName}-${iExam}`;
                    this.highlightTest(examName, exam.loc, false);
                    this.highlightTest(examName, exam.loc, true, exam.passed, exam.note);
                });
            });
            this.setState({ testProcessing: false });
        }, 10);
    }
    compile() {
        const { state, props, expressionRef } = this;
        // fixme: kinda hack!
        const input = expressionRef.current.inputRef.current;
        props.actions.compile(input.value || null, state.bytecodeDebuggerType);
    }
    //
    // Markers
    //
    setBytecodeColorization(colorize) {
        this.props.actions.specifyOptions({ colorize });
    }
    resolveLocation(src) {
        // if (src.source) {
        //     return this.resolveLocation(src.source);
        // }
        // return src;
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(this.props);
        const uri = file.uri;
        const slastDocument = file.slastDocument;
        if (!slastDocument) {
            return null;
        }
        const includes = slastDocument.includes;
        let dst = src;
        while (dst && String(uri) !== String(dst.start.file)) {
            dst = includes.get(String(dst.start.file));
        }
        return dst;
    }
    /** @deprecated */
    highlightTest(testName, loc, show = true, passed, tooltip) {
        const name = `autotest-${testName}`;
        if (show) {
            const range = this.resolveLocation(loc);
            const color = passed ? 10 : 14;
            this.props.actions.addMarker({ name, range, type: `line`, payload: { color } });
            if (!passed && tooltip) {
                this.props.actions.addMarker({ name: `${name}-error`, range, type: `error`, payload: { color }, tooltip });
            }
        }
        else {
            this.props.actions.removeMarker(`${name}`);
            this.props.actions.removeMarker(`${name}-error`);
        }
    }
    /** @deprecated */
    highlightInstruction(inst, show = true) {
        const markerName = `ast-range-${inst.instructionID}`;
        if (show) {
            const range = this.resolveLocation(inst.sourceNode.loc);
            this.props.actions.addMarker({
                name: markerName,
                range,
                type: `marker`
            });
        }
        else {
            this.props.actions.removeMarker(markerName);
        }
    }
    /** @deprecated */
    highlightPNode(id, pnode = null, show = true) {
        if (show) {
            const range = this.resolveLocation(pnode.loc);
            this.props.actions.addMarker({
                name: `ast-range-${id}`,
                range,
                type: 'marker'
            });
        }
        else {
            this.props.actions.removeMarker(`ast-range-${id}`);
        }
    }
    //
    // General functionality
    //
    openFile(file) {
        const doOpen = () => _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_26__.history.push(`/${this.props.match.params.view}/${encodeURIComponent(file)}`);
        if (!this.isEdited() || !_sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron()) {
            doOpen();
            return;
        }
        const message = 'Your current changes will be lost, do you want to continue?';
        const title = 'New file';
        const dialog = {
            title,
            message,
            onReject() { },
            onAccept: doOpen
        };
        this.openConfirmDialog(dialog);
    }
    reopenThisFile() {
        this.props.actions.openFile(this.currentUri());
    }
    //
    // General info
    //
    isEdited() {
        return this.props.sourceFile.revision > 1 || this.props.nodes.revision > 1;
    }
    currentUri() {
        return this.props.sourceFile?.uri;
    }
    isP4Connected() {
        return !!this.props.s3d.p4;
    }
    isEnv() {
        return !!this.props.s3d.env;
    }
    isExists() {
        const uri = this.currentUri();
        if (!uri) {
            return false;
        }
        if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron()) {
            // assume that we always able to edit effects in web version
            return true;
        }
        // todo: move to ipc
        const localPath = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(uri);
        return fs__WEBPACK_IMPORTED_MODULE_32__.existsSync(localPath);
    }
    isReadonly() {
        const uri = this.currentUri();
        if (!uri) {
            return false;
        }
        if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron()) {
            // assume that we always able to edit effects in web version
            return false;
        }
        // todo: move to ipc
        const localPath = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(uri);
        return (fs__WEBPACK_IMPORTED_MODULE_32__.statSync(localPath).mode & 146) == 0;
    }
    canCompile() {
        const { sourceFile } = this.props;
        return sourceFile.slDocument && sourceFile.slDocument.diagnosticReport.errors === 0;
    }
    //
    // Perforce 
    //
    onCheckout() {
        if (!this.isP4Connected()) {
            console.error('Perforce is not connected.');
            return;
        }
        const localPath = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(this.currentUri());
        if (this.isExists()) {
            // add to default changelist
            _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_8__.edit(0, localPath, () => this.forceUpdate());
            return;
        }
        const filename = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.sync.saveFileDialog({
            defaultPath: localPath,
            title: "Save FX",
            buttonLabel: "Save",
            filters: [
                { name: 'Source FX', extensions: ['fx'] },
                { name: 'Graph FX', extensions: ['xfx'] }
            ]
        }, this.props.sourceFile.content);
        if (filename) {
            _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_8__.add(0, filename, () => {
                // request depot update
                this.props.actions.rescan();
                this.openFile(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.fromLocalPath(filename));
            });
        }
    }
    onRevert() {
        if (!this.isP4Connected()) {
            console.error('Perforce is not connected.');
            return;
        }
        const doRevert = () => {
            _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_8__.revert(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(this.currentUri()), () => {
                console.assert(this.isReadonly(), 'Revert failed?!');
                // reopen file to drop revesion and other states/markers
                this.reopenThisFile();
            });
        };
        if (!this.isEdited()) {
            doRevert();
            return;
        }
        const dialog = {
            title: `Revert ${path__WEBPACK_IMPORTED_MODULE_33__.basename(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(this.currentUri()))}`,
            message: 'Drop unsaved changes?',
            onReject() { },
            onAccept: doRevert
        };
        this.openConfirmDialog(dialog);
    }
    onSave() {
        if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron()) {
            console.error('File can not be saved under web version.');
            return;
        }
        if (this.isReadonly()) {
            console.error('File is read only.');
            return;
        }
        const { sourceFile, nodes: { graph } } = this.props;
        const isGraph = path__WEBPACK_IMPORTED_MODULE_33__.extname(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(sourceFile.uri)) == '.xfx';
        const data = !isGraph ? sourceFile.content : (0,_sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_31__.packGraphToJSON)(this.props);
        if (_sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.sync.saveFile(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_29__.toLocalPath(this.currentUri()), data)) {
            this.reopenThisFile();
        }
    }
    //
    // Confirm dialog
    //
    openConfirmDialog(options) {
        this.setState({ confirmDialog: { ...options, open: true } });
    }
    closeConfirmDialog() {
        this.setState({ confirmDialog: { open: false } });
    }
    processConfirmDialog(decision) {
        decision ? this.state.confirmDialog.onAccept.apply(this)
            : this.state.confirmDialog.onReject.apply(this);
        this.closeConfirmDialog();
    }
    //
    // Render processing
    //
    /** @deprecated */
    buildShaderMenu() {
        const props = this.props;
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(props);
        if (!file.uri) {
            return [];
        }
        const links = [];
        const basepath = `/playground/${encodeURIComponent(file.uri)}`;
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getScope)(file);
        const list = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_25__.filterTechniques)(scope);
        for (const fx of list) {
            links.push(`${fx.name}`);
            links.push(...fx.passes
                .filter(pass => !!pass.vertexShader)
                .map((pass, i) => `${fx.name}/${pass.name || i}/VertexShader`));
            links.push(...fx.passes
                .filter(pass => !!pass.pixelShader)
                .map((pass, i) => `${fx.name}/${pass.name || i}/PixelShader`));
        }
        return links.map(name => ({ name, basepath, link: `${basepath}/${name}` }));
    }
    buildShaderMenu11() {
        const props = this.props;
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(props);
        if (!file.uri) {
            return [];
        }
        const links = [];
        const basepath = `/playground/${encodeURIComponent(file.uri)}`;
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getScope)(file);
        const list11 = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_25__.filterTechniques11)(scope);
        const knownShaders = [];
        for (const fx of list11) {
            links.push(`${fx.name}`);
            for (const pass of fx.passes) {
                (0,_lib_fx_Visitors__WEBPACK_IMPORTED_MODULE_1__.visitor)(pass, (instr, owner) => {
                    if (instr.instructionType === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_7__.EInstructionTypes.k_CompileShader11Expr) {
                        const cmpl = instr;
                        const SH_TYPE = {
                            'vs': 'VertexShader',
                            'ps': 'PixelShader',
                            'cs': 'ComputeShader',
                            'gs': 'GeometryShader'
                        };
                        const ext = cmpl.ver.substring(0, 2);
                        const type = SH_TYPE[ext];
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_37__.assert)((0,_lib_common__WEBPACK_IMPORTED_MODULE_37__.isString)(type), 'unknown type found');
                        const link = `${cmpl.func.name}/${type}`;
                        if (!knownShaders.includes(link)) {
                            knownShaders.push(link);
                        }
                    }
                    // todo: add support of global defined shaders
                });
            }
        }
        links.push(...knownShaders);
        return links.map(name => ({ name, basepath, link: `${basepath}/${name}` }));
    }
    render() {
        const { props, state, props: { sourceFile } } = this;
        const $debugger = sourceFile.debugger;
        const $pg = props.playground;
        const env = props.s3d.env;
        const shaderFormats = [
            { key: 1, text: 'GLSL', value: 'glsl' },
            { key: 2, text: 'HLSL', value: 'hlsl' },
        ];
        const showAutotestMenu = (sourceFile.content || '').substr(0, 40).indexOf('@autotests') !== -1;
        /** @deprecated */
        const shaderMenuList = this.buildShaderMenu();
        const shaderMenuList11 = this.buildShaderMenu11();
        const analysisResults = [
            {
                menuItem: {
                    as: 'a',
                    content: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null, "Playground")),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}`, key: "route-analysis-result" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"], { item: true, icon: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__["default"], { className: 'gear' }) },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Menu, null,
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, null,
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"], { className: props.classes.dropdownItemFix, text: 'Translation options (not supported)' },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Menu, null,
                                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, null,
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: "convolute", checked: true })),
                                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, null,
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: "gather ui", checked: true }))))),
                                shaderMenuList.length > 0 &&
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Divider, null),
                                shaderMenuList.map(item => (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: `ddmi-${item.name}`, href: `#${item.link}` }, item.name))),
                                shaderMenuList11.length > 0 &&
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Divider, null),
                                shaderMenuList11.map(item => (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: `ddmi-${item.name}`, href: `#${item.link}` }, item.name))))),
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' },
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"], { text: 'Shader Format', options: shaderFormats, value: $pg.shaderFormat, onChange: (e, data) => this.setShaderFormat(data.value) }),
                                "\u00A0\u00A0|\u00A0\u00A0",
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: 'WASM runtime', disabled: !true, checked: $pg.wasm, onChange: this.switchEmitterRuntime })))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'playground-view' },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_playground_Playground__WEBPACK_IMPORTED_MODULE_21__["default"], null))))
            },
            {
                menuItem: {
                    as: 'a',
                    content: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null,
                        "Bytecode",
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement("br", null),
                        "Debugger")),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.BYTECODE_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.BYTECODE_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.BYTECODE_VIEW}`, key: "route-bytecode-view" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' }, "Bytecode Debugger"))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'bytecode-view' },
                        showAutotestMenu &&
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_48__["default"], { color: 'orange' },
                                !this.state.testProcessing &&
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { onClick: this.runAutotests, width: '100%' },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement("span", null, "Run autotests!")),
                                this.state.testProcessing &&
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_50__["default"], { active: true, inline: true })),
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__["default"], { size: 'small', basic: 'very', compact: 'very' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__["default"].Body, null,
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__["default"].Row, { style: { paddingTop: 0 } },
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__["default"].Cell, null,
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_52__["default"], { fluid: true, size: 'small', placeholder: (this.state.bytecodeDebuggerType === 'expression'
                                                ? `${_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_ENTRY_POINT_NAME}()`
                                                : `technique11::pass`), value: $debugger.query || '', ref: this.expressionRef, label: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"], { defaultValue: 'expression', onChange: (e, data) => {
                                                    this.setState({ bytecodeDebuggerType: data.value });
                                                }, options: [
                                                    { key: 'expression', text: 'expression', value: 'expression' },
                                                    { key: 'pass', text: 'pass', value: 'pass' }
                                                ] }) })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_51__["default"].Cell, null,
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { disabled: ($debugger.options.autocompile || !this.canCompile()), onClick: this.compile, width: 10 }, "Compile"),
                                        "\u00A0",
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"], { text: 'Options', pointing: 'left' },
                                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Menu, null,
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: "ddmi-use-wasm" },
                                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: 'WASM runtime', size: 'small', disabled: !true, checked: $debugger.options.wasm, onMouseDown: this.switchVMRuntime })),
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: "ddmi-auto-compilation" },
                                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: 'auto compilation', size: 'small', checked: $debugger.options.autocompile, onMouseDown: e => this.setAutocompile(!$debugger.options.autocompile) })),
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: "ddmi-no-opt" },
                                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { disabled: true, label: 'no optimisations', size: 'small', checked: true })),
                                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_44__["default"].Item, { key: "ddmi-bytecode-colorization" },
                                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_46__["default"], { label: 'colorize', size: 'small', checked: $debugger.options.colorize, onMouseDown: e => this.setBytecodeColorization(!$debugger.options.colorize) })))))))),
                        $debugger.bcDocument?.program ? (react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", null,
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_MemoryView__WEBPACK_IMPORTED_MODULE_15__["default"], { bcDocumnet: $debugger.bcDocument }),
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_BytecodeView__WEBPACK_IMPORTED_MODULE_18__["default"], null))) : null)))
            },
            {
                menuItem: {
                    as: 'a',
                    content: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null,
                        "Semantic",
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement("br", null),
                        "Analyzer"),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PROGRAM_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PROGRAM_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PROGRAM_VIEW}`, key: "route-program-view" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' }, "Semantic Analisys"))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'program-view' },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_ProgramView__WEBPACK_IMPORTED_MODULE_17__["default"], { onNodeOver: inst => this.highlightInstruction(inst, true), onNodeOut: inst => this.highlightInstruction(inst, false), onNodeClick: inst => { } }))))
            },
            {
                menuItem: {
                    as: 'a',
                    content: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null,
                        "Syntax",
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement("br", null),
                        "Analyzer"),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.AST_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.AST_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.AST_VIEW}`, key: "route-ast-view" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' }, "Syntax Analysis"))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'ast-view' },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_ASTView__WEBPACK_IMPORTED_MODULE_10__["default"], { onNodeOver: (idx, node) => this.highlightPNode(idx, node, true), onNodeOut: idx => this.highlightPNode(idx, null, false) }))))
            },
            {
                menuItem: {
                    as: 'a',
                    content: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null,
                        "Pre",
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement("br", null),
                        "Processor"),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PREPROCESSOR_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PREPROCESSOR_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PREPROCESSOR_VIEW}`, key: "route-preprocessor-view" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' }, "Preprocessor Summary"))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'preprocessor-view' },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_PreprocessorView__WEBPACK_IMPORTED_MODULE_16__["default"]
                        // onNodeOver={(idx, node) => this.highlightPNode(idx, node, true)}
                        // onNodeOut={idx => this.highlightPNode(idx, null, false)}
                        , null))))
            },
            {
                menuItem: {
                    as: 'a',
                    content: react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Header, null, "Graph"),
                    href: `#/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_VIEW}/${props.match.params.fx}`,
                    key: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_VIEW
                },
                pane: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_VIEW}`, key: "route-graph-view" },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { secondary: true, borderless: true, attached: 'top', className: props.classes.tabHeaderFix },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Menu, { position: 'right' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: 'ui right aligned category search item' }, "Graph Configuration"))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { attached: 'bottom', key: 'graph-view' },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_GraphConfigView__WEBPACK_IMPORTED_MODULE_13__["default"], null))))
            }
        ];
        const defaultActiveIndex = analysisResults.findIndex(pane => {
            return !!(0,react_router__WEBPACK_IMPORTED_MODULE_43__.matchPath)(window.location.pathname, {
                path: pane.menuItem.href,
                exact: false
            });
        });
        const add = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() && !this.isExists();
        const checkout = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() && this.isExists() && this.isReadonly();
        const revert = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() && this.isExists() && !this.isReadonly();
        const panes = [
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { key: "source-file-item" },
                    !add &&
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_39__["default"], { trigger: react__WEBPACK_IMPORTED_MODULE_34__.createElement("span", null, path__WEBPACK_IMPORTED_MODULE_33__.basename(props.sourceFile.uri || '') + (this.isEdited() ? '*' : '')), content: props.sourceFile.uri, basic: true }),
                    "\u00A0",
                    this.isP4Connected() && (add || checkout) &&
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"].Group, { size: 'mini' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { positive: true, onClick: this.onCheckout }, this.isExists() ? 'Checkout' : 'Add')),
                    this.isP4Connected() && (revert) &&
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"].Group, { size: 'mini' },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { onClick: this.onRevert }, "Revert"),
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"].Or, null),
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { positive: true, onClick: this.onSave, disabled: !this.isEdited() }, "Save")))),
                render: () => (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { key: 'source', className: `${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}` },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_53__["default"], { divided: false },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_53__["default"].Row, { columns: 2 },
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_53__["default"].Column, { computer: '10', tablet: '8', mobile: '6', className: props.classes.leftColumnFix },
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(SourceCodeMenu, { path: props.match.params }),
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Switch, null,
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${props.match.params.view}/:fx/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_KEYWORD}` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_GraphView__WEBPACK_IMPORTED_MODULE_14__["default"], { graph: props.nodes.graph, onChange: () => this.props.actions.changed(), onExecute: () => this.props.actions.recompile() })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${props.match.params.view}/:fx/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.CODE_KEYWORD}` }, props.match.params.fx && props.match.params.name === _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.CODE_KEYWORD &&
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_CodeView__WEBPACK_IMPORTED_MODULE_11__["default"], { content: _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_6__.FxEmitter.translateDocument((0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(this.props).slDocument) })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${props.match.params.view}/:fx/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.RAW_KEYWORD}` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_CodeView__WEBPACK_IMPORTED_MODULE_11__["default"], { content: (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getRawContent)((0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_27__.getFileState)(this.props)) })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}/:fx/:name/:pass/(vertexshader|pixelshader)` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_22__["default"], { name: 'shader-translator-view' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}/:fx/:name/(vertexshader|pixelshader)` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_ShaderTranslatorView11__WEBPACK_IMPORTED_MODULE_38__["default"], { name: 'shader-translator-view' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}/:fx/:name` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_ShaderTranslatorView__WEBPACK_IMPORTED_MODULE_22__["default"], { name: 'shader-translator-view' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PLAYGROUND_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__["default"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.BYTECODE_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__["default"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PROGRAM_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__["default"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.AST_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__["default"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.PREPROCESSOR_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_editor_Editor__WEBPACK_IMPORTED_MODULE_19__["default"], { name: 'source-code' })),
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_router__WEBPACK_IMPORTED_MODULE_43__.Route, { exact: true, path: `/${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.GRAPH_VIEW}/:fx` },
                                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_GraphView__WEBPACK_IMPORTED_MODULE_14__["default"], { graph: props.nodes.graph, onChange: () => this.props.actions.changed(), onExecute: () => this.props.actions.recompile() })))),
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_53__["default"].Column, { computer: '6', tablet: '8', mobile: '10', className: props.classes.rightColumnFix },
                                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_54__["default"], null,
                                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"], { defaultActiveIndex: defaultActiveIndex, menu: {
                                            attached: false, secondary: true, pointing: false,
                                            size: 'mini', className: props.classes.mainMenu
                                        }, panes: analysisResults, renderActiveOnly: false })))))))
            },
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { key: "grammar-item", style: { marginBottom: _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() ? '-1px' : '-4px' } },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("span", null, "Grammar"))),
                render: () => (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { key: 'grammar', className: `${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}` },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_containers_ParserParameters__WEBPACK_IMPORTED_MODULE_20__["default"], null)))
            },
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { key: "system-scope-item", style: { marginBottom: _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() ? '-1px' : '-4px' } },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("span", null, "System Scope"))),
                render: () => (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"].Pane, { key: 'system-scope', className: `${props.classes.containerMarginFix} ${props.classes.mainViewHeightHotfix}` },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_CodeView__WEBPACK_IMPORTED_MODULE_11__["default"], { content: _lib_fx_analisys_system_utils__WEBPACK_IMPORTED_MODULE_2__.debugPrint(_lib_fx_analisys_SystemScope__WEBPACK_IMPORTED_MODULE_3__.SCOPE) })))
            },
            {
                menuItem: (react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { key: 'ver', position: 'right', inverted: "true", disabled: true, color: 'red' },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(P4Status, { classes: props.classes, info: props.s3d.p4 }),
                    "\u00A0 \u00A0",
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(S3DStatus, { classes: props.classes, env: props.s3d.env }),
                    "\u00A0 \u00A0",
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(Version, { classes: props.classes }))),
                render: () => null
            }
        ];
        return (react__WEBPACK_IMPORTED_MODULE_34__.createElement("div", { className: props.classes.mainContentHotfix },
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_55__["default"], { onClose: () => this.closeConfirmDialog(), onOpen: () => null, open: this.state.confirmDialog.open },
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_56__["default"], { icon: true }, this.state.confirmDialog.title),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_55__["default"].Content, null,
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement("p", null, this.state.confirmDialog.message)),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_55__["default"].Actions, null,
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { onClick: () => this.processConfirmDialog(false) },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__["default"], { name: 'remove' }),
                        " No"),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_49__["default"], { onClick: () => this.processConfirmDialog(true) },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__["default"], { name: 'checkmark' }),
                        " Yes"))),
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_57__["default"].Pushable, null,
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_57__["default"], { as: semantic_ui_react__WEBPACK_IMPORTED_MODULE_48__["default"], animation: 'overlay', vertical: true, visible: this.state.showFileBrowser, className: this.props.classes.fileBrowserSidebarFix },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_58__["default"], { style: { marginBottom: '10px' } },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_58__["default"].Field, null,
                            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_52__["default"], { size: 'small', iconPosition: 'left', placeholder: 'Filter...', onChange: (e) => { this.setState({ depotFilter: e.target.value }); } }))),
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(_sandbox_components_FileListView__WEBPACK_IMPORTED_MODULE_12__["default"], { root: this.props.depot.root, onFileClick: this.openFile, desc: env?.Get('game-name') || 'Development', expanded: true, filters: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_23__.EXT_FILTER, search: this.state.depotFilter })),
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_57__["default"].Pusher, { dimmed: this.state.showFileBrowser },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_47__["default"], { menu: { secondary: true, pointing: true }, panes: panes, renderActiveOnly: true, size: 'tiny', className: props.classes.topMenuFix }))),
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"], { size: 'mini', vertical: true, icon: 'labeled', color: 'black', inverted: true, fixed: 'left', className: props.classes.sidebarLeftHotfix },
                react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { name: 'depot', onClick: this.handleShowFileBrowser },
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__["default"], { className: 'three bars' }),
                    "Depot"),
                _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.isElectron() &&
                    react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_41__["default"].Item, { name: 'create', onClick: this.handleCreateNewEffect },
                        react__WEBPACK_IMPORTED_MODULE_34__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_45__["default"], { className: 'plus' }),
                        "New")),
            react__WEBPACK_IMPORTED_MODULE_34__.createElement(react_semantic_toasts__WEBPACK_IMPORTED_MODULE_36__.SemanticToastContainer, { position: 'bottom-right', animation: 'fade down', className: props.classes.toastFontFix })));
    }
    async componentDidMount() {
        // custom request to hide prevew window and show main when it's completely ready
        _sandbox_ipc__WEBPACK_IMPORTED_MODULE_30__.async.notifyAppReady();
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "handleCreateNewEffect", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "switchVMRuntime", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "switchEmitterRuntime", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "runAutotests", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "compile", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "openFile", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "onCheckout", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "onRevert", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_28__["default"]
], App.prototype, "onSave", null);
App = __decorate([
    react_router__WEBPACK_IMPORTED_MODULE_43__.withRouter // << NOTE: known issue with TS decorators :/
], App);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_35__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_24__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_24__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_9__.mapActions)({
    ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_9__.sourceCode,
    ...connected_react_router__WEBPACK_IMPORTED_MODULE_59__.routerActions,
    ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_9__.playground,
    ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_9__.depot,
    ..._sandbox_actions__WEBPACK_IMPORTED_MODULE_9__.nodes
}))((0,react_jss__WEBPACK_IMPORTED_MODULE_42__["default"])(styles)(App)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "J1YF":
/*!*************************************************!*\
  !*** ./src/sandbox/containers/BytecodeView.tsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/bytecode */ "0jsi");
/* harmony import */ var _lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/common */ "4eqb");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bytecode/EOperations */ "/9BJ");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/util/DistinctColor */ "aBMm");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! semantic-ui-react */ "35Nk");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! semantic-ui-react */ "OXt0");
/* harmony import */ var _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/fx/bytecode/Bytecode */ "dnVx");
/* harmony import */ var _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/fx/bytecode/VM/ts/bundle */ "8VxU");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_6__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_7__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_8__, _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__]);
([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_0__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__, _sandbox_actions__WEBPACK_IMPORTED_MODULE_6__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_7__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_8__, _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__, _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// tslint:disable:typedef
// tslint:disable:max-func-body-length
// tslint:disable:cyclomatic-complexity












// todo: don't use TS specific bundle helpers



function minWidth(str, len = 0, char = ' ') {
    for (let i = 0, slen = str.length; i < Math.max(0, len - slen); ++i) {
        str = char + str;
    }
    return str;
}
const REG_NAMES = {
    [0x100]: 'rax' // todo: get register adresses from bytecode generator
};
const constant = (v) => `"${v}"`;
const float = (v) => String(v).indexOf('.') === -1 ? `${v}.f` : `${v}f`;
const fixPrecision = (v, precision = 2) => Math.floor(v * Math.pow(10, 2)) / Math.pow(10, 2);
const hex2 = (v) => `0x${minWidth(v.toString(16), 2, '0')}`;
const hex4 = (v) => `0x${minWidth(v.toString(16), 4, '0')}`;
const reg = (v) => REG_NAMES[v] || `[${hex2(v >>> 0)}]`; // register address;
const addr = (v) => `%${hex4(v >>> 0)}%`; // global memory address;
const any4 = (v) => `${minWidth(String(v), 4, ' ')}`;
const scode = (c) => {
    let s = String(_lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation[c]);
    s = s.substr(2);
    let v = '';
    for (const char of s) {
        if (char === char.toUpperCase() && (char < '0' || char > '9') && v.length > 0) {
            v += '_';
        }
        v += char.toLowerCase();
    }
    switch (c) {
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32SetConst: return 'i32_set';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegister: return 'i32_load';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegistersPointer: return 'i32_load*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreRegisterPointer: return 'i32_store*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadInputPointer: return 'i32_load_input*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreInputPointer: return 'i32_store_input*';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32GreaterThanEqual: return 'i32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LessThan: return 'i32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_U32GreaterThanEqual: return 'u32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_U32LessThan: return 'u32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32GreaterThanEqual: return 'f32_ge';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32LessThan: return 'f32_lt';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Not: return 'i32_not';
        case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32NotEqual: return 'i32_ne';
        default:
            return v;
    }
};
class BytecodeView extends react__WEBPACK_IMPORTED_MODULE_9__.Component {
    constructor() {
        super(...arguments);
        this.state = {
            count: 0,
            cdlView: null,
            externs: null,
            ilist: null
        };
    }
    static getDerivedStateFromProps(props, state) {
        const count = 0;
        const program = props.bcDocument.program;
        if (!program) {
            return { count, cdlView: null, externs: null, ilist: null };
        }
        const cdlView = (0,_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_0__.cdlview)(program.cdl);
        const chunks = _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__.decodeChunks(program.code);
        const externs = _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__.decodeExternsChunk(chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EChunkType.k_Externs]);
        const ilist = _lib_fx_bytecode_VM_ts_bundle__WEBPACK_IMPORTED_MODULE_12__.decodeCodeChunk(chunks[_lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_3__.EChunkType.k_Code]);
        return { count, cdlView, externs, ilist };
    }
    render() {
        const { props, state } = this;
        const { program } = props.bcDocument;
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_13__.isDefAndNotNull)(program)) {
            return null;
        }
        const { code, cdl } = program;
        if (!(0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_13__.isDefAndNotNull)(code)) {
            return null;
        }
        return (
        // fixed
        react__WEBPACK_IMPORTED_MODULE_9__.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"], { size: 'small', unstackable: true, basic: true, compact: true, style: { fontFamily: 'consolas, monospace', whiteSpace: 'pre' } },
                react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Body, { style: {
                        maxHeight: 'calc(100vh - 432px)',
                        overflowY: 'auto',
                        display: 'block'
                    } }, this.renderOpList(state.ilist)),
                props.options.disableOptimizations &&
                    react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Footer, null,
                        react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Row, null,
                            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Cell, { colSpan: 5, inverted: 1, warning: true, textAlign: 'center', style: { padding: '2px', fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif' } }, "optimizations are disabled")))),
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"], { animated: true, onClick: async () => {
                    const bundle = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.make("[evaluate]", code);
                    if (!bundle) {
                        alert(`[ERROR] Could not evaluate bundle.`);
                        return;
                    }
                    // force bind shadow constant buffer 
                    bundle.setConstant("@", new Uint8Array()); // temp hack for CPP VM setup
                    const result = _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.asNativeViaCDL(bundle.play(), cdl);
                    alert(JSON.stringify(result, null, '   '));
                } },
                react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"].Content, { visible: true }, "Run"),
                react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"].Content, { hidden: true },
                    react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_16__["default"], { className: 'rocket' })))));
    }
    renderOpList(ilist) {
        const list = [];
        for (let i = 0; i < ilist.length; i += 5) {
            list.push(this.renderOp(ilist.subarray(i, i + 5)));
        }
        return list;
    }
    renderOp(op) {
        const code = op[0];
        const args = [op[1], op[2], op[3], op[4]];
        switch (op[3]) {
            default:
                return this.renderOpInternal(code, args);
        }
    }
    showSourceLine(pc) {
        // console.log(this.state.cdlView.resolveFileLocation(pc));
    }
    hideSourceLine(oc) {
    }
    // tslint:disable-next-line:max-func-body-length:
    // tslint:disable-next-line:cyclomatic-complexity
    renderOpInternal(code, args) {
        const i = this.state.count++;
        const { cdlView } = this.state;
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32SetConst:
                args.length = 3;
                // op, const, hint
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegister:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegistersPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreRegisterPointer:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadInput:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreInput:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadInputPointer:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreInputPointer:
                args.length = 4;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32TextureLoad:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32ExternCall:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Not:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Equal:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32NotEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_U32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_U32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32GreaterThanEqual:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32LessThan:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LogicalOr:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LogicalAnd:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32ToI32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32ToF32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32ToU32:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_U32ToF32:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Mul:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32Max:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Add:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Sub:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Div:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Mul:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Sin:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Cos:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Frac:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Sqrt:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Floor:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Ceil:
                args.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Max:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Min:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_F32Pow:
                args.length = 3;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_JumpIf:
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_Jump:
                args.length = 1;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_Ret:
                args.length = 0;
                break;
            default:
        }
        // tslint:disable-next-line:switch-default
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32SetConst:
                args[1] = args[2] === 1 ? fixPrecision((0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.u32Asf32)(args[1])) : (0,_lib_fx_bytecode_common__WEBPACK_IMPORTED_MODULE_1__.u32Asi32)(args[1]);
        }
        //
        // Convert all arguments to strings
        //
        let sArgs = args.map(String);
        const pointer = (x) => `%${x}`;
        const register = (x) => `r${x}`;
        const shaderRegister = (x) => {
            if (x >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.CBUFFER0_REGISTER && x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.CBUFFER0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.CBUFFER_TOTAL)
                return `b${x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.CBUFFER0_REGISTER}`;
            if (x >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.SRV0_REGISTER && x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.SRV0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.SRV_TOTAL)
                return `t${x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.SRV0_REGISTER}`;
            if (x >= _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.UAV0_REGISTER && x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.UAV0_REGISTER < _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.UAV_TOTAL)
                return `u${x - _lib_fx_bytecode_Bytecode__WEBPACK_IMPORTED_MODULE_11__.UAV0_REGISTER}`;
            console.error(`invalid slot: ${x}`);
            return `${x}`;
        };
        // tslint:disable-next-line:switch-default
        switch (code) {
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32SetConst:
                sArgs[0] = register(args[0]);
                if (args[2] === 1) { // is float
                    sArgs[1] = float(args[1]);
                }
                sArgs[1] = constant(sArgs[1]);
                sArgs.length = 2;
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegister:
                sArgs[0] = register(args[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadRegistersPointer:
                sArgs[0] = register(args[0]);
                sArgs[1] = pointer(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreRegisterPointer:
                sArgs[0] = pointer(args[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadInput:
                // sArgs[0] = shaderRegister(args[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreInput:
                sArgs[2] = register(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32LoadInputPointer:
                sArgs[0] = shaderRegister(args[0]);
                sArgs[1] = register(args[1]);
                sArgs[2] = pointer(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32StoreInputPointer:
                sArgs[1] = pointer(args[1]);
                sArgs[2] = register(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32TextureLoad:
                sArgs[0] = register(args[0]);
                sArgs[1] = pointer(args[1]);
                sArgs[2] = register(args[2]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32ExternCall:
                sArgs[0] = constant(sArgs[0]);
                sArgs[1] = register(args[1]);
                break;
            case _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_Jump:
                sArgs[0] = hex2(args[0] /* / InstructionList.STRIDE*/);
                break;
            default:
                sArgs = args.map(register);
        }
        sArgs = sArgs.map(any4);
        let specColor = null;
        if (this.props.options.colorize) {
            specColor = {
                padding: '0.2em 0',
                opacity: 0.5,
                background: _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_5__["default"].make(cdlView.resolvePcColor(i)).toRGBAString(),
                width: '4px'
            };
        }
        return (react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Row, { key: `op-${code}-${i}`, style: { width: '100%', display: 'table', tableLayout: 'fixed', borderBottom: 'none' }, onMouseOver: () => this.showSourceLine(i), onMouseOut: () => this.hideSourceLine(i) },
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Cell, { style: specColor }),
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Cell, { style: { padding: '0.2em 0.7em', width: '50px' } }, hex4(i)),
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Cell, { style: { padding: '0.2em 0.7em' } }, scode(code)),
            react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Cell, { colSpan: 2, style: { padding: '0.2em 0.7em' } }, (() => {
                if (code === _lib_idl_bytecode_EOperations__WEBPACK_IMPORTED_MODULE_4__.EOperation.k_I32ExternCall) {
                    return (react__WEBPACK_IMPORTED_MODULE_9__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__["default"], { content: this.state.externs[args[0]].name, trigger: react__WEBPACK_IMPORTED_MODULE_9__.createElement("span", { style: { borderBottom: '1px dotted gray' } }, sArgs.join(' ') + ' ') }));
                }
                return sArgs.join(' ');
            })())));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_10__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_7__.mapProps)(_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_8__.getDebugger), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__.mapActions)(_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__.sourceCode))(BytecodeView));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "u7fn":
/*!*****************************************************!*\
  !*** ./src/sandbox/containers/ParserParameters.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/bf/bf */ "/ig4");
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers/parserParams */ "0VSY");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! semantic-ui-react */ "fbB6");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semantic-ui-react */ "5+SC");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! semantic-ui-react */ "wi9p");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










const setFlags = (dest, src, value) => {
    return value ? _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__.setFlags(dest, src) : _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__.clearFlags(dest, src);
};
class ParserParameters extends react__WEBPACK_IMPORTED_MODULE_6__.Component {
    UNSAFE_componentWillMount() {
        this.setState(this.props);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        this.setState(nextProps);
    }
    // tslint:disable-next-line:max-func-body-length
    render() {
        const { type, flags, grammar, parsingFlags } = this.state;
        return (react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], null,
            react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Row, { columns: 2 },
                react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Column, { computer: "10", tablet: "8", mobile: "6" },
                    react__WEBPACK_IMPORTED_MODULE_6__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_7__["default"], { language: "powershell", theme: "vs", value: grammar || '', width: "100%", height: "calc(100vh - 41px)" // todo: fixme
                        , options: {
                            selectOnLineNumbers: true,
                            fontSize: 12,
                            lineNumbers: "on",
                            lineHeight: 14,
                            automaticLayout: true
                        }, onChange: grammar => this.setState({ grammar }) })),
                react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Column, { computer: "6", tablet: "8", mobile: "10" },
                    react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_10__["default"], { style: { marginTop: '1em', marginRight: '2em' } },
                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"], null,
                            react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"], { columns: 'equal', divided: true, padded: true },
                                react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Column, null,
                                    react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Group, { grouped: true },
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement("label", null, "Parser type:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Radio, { label: 'LR0', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LR0], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LR0, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[value] }), disabled: true }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Radio, { label: 'LR1', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LR1], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LR1, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[value] }) }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Radio, { label: 'LALR', name: 'radioParserType', value: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[_lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LALR], checked: this.state.type === _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType.k_LALR, onChange: (e, { value }) => this.setState({ type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserType[value] }) }))),
                                react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_9__["default"].Column, null,
                                    react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Group, { grouped: true },
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement("label", null, "Parser flags:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowAddMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowAddMode), label: 'Allow `--add` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowExposeMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowExposeMode), label: 'Allow `--expose` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowSkipMode), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowSkipMode), label: 'Allow `--skip` mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_ForceAppendAll), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_ForceAppendAll), label: 'Force create all nodes' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(flags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_Debug), onChange: this.handleParserFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_Debug), label: 'Debug mode' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement("label", null, "Parsing flags:"),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(parsingFlags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.IASTDocumentFlags.k_Optimize), onChange: this.handleParsingFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.IASTDocumentFlags.k_Optimize), label: 'Created nodes if it has more than one child' }),
                                        react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Checkbox, { checked: !!(parsingFlags & _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.IASTDocumentFlags.k_DeveloperMode), onChange: this.handleParsingFlags.bind(this, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.IASTDocumentFlags.k_DeveloperMode), label: 'Developer mode' })))),
                            react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_11__["default"].Button, { onClick: this.reinit }, "Reinit parser")))))));
    }
    reinit() {
        const { type, flags, grammar, parsingFlags } = this.state;
        this.props.actions.setParams(type, flags);
        this.props.actions.setGrammar(grammar);
        this.props.actions.setParsingParams(parsingFlags);
    }
    handleParserFlags(flag, event, { checked: value }) {
        let { flags } = this.state;
        switch (flag) {
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowAddMode:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowExposeMode:
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowSkipMode:
                if (value) {
                    flags = _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__.clearFlags(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_ForceAppendAll);
                }
                break;
            case _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_ForceAppendAll:
                if (value) {
                    flags = _lib_bf_bf__WEBPACK_IMPORTED_MODULE_0__.clearFlags(flags, _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowExposeMode |
                        _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowAddMode | _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_1__.EParserFlags.k_AllowSkipMode);
                }
                break;
            default:
        }
        flags = setFlags(flags, flag, value);
        this.setState({ flags });
    }
    handleParsingFlags(flag, event, { checked: value }) {
        let { parsingFlags } = this.state;
        parsingFlags = setFlags(parsingFlags, flag, value);
        this.setState({ parsingFlags });
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "reinit", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "handleParserFlags", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_5__["default"]
], ParserParameters.prototype, "handleParsingFlags", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_8__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_3__.mapProps)(_sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_4__.getParser), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.mapActions)(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.parser))(ParserParameters));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "lF6j":
/*!*********************************************!*\
  !*** ./src/sandbox/containers/PartView.tsx ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! semantic-ui-react */ "l9XU");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! semantic-ui-react */ "3GrG");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! semantic-ui-react */ "a49q");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




const style = {
    height: 'calc(100vh)',
    width: 'calc(100vw)',
    position: 'relative',
    left: '0',
    right: '0',
    margin: '0',
    background: 'rgba(255, 0, 0, 0.5)'
};
const monofont = {
    fontFamily: 'consolas, monospace',
    width: '100%'
};
;
function renderValue(value) {
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(value)) {
        return value ? 'true' : 'false';
    }
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        return value.map(x => renderValue(x));
    }
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {
        if (Number(value) !== Math.floor(value))
            return (react__WEBPACK_IMPORTED_MODULE_2__.createElement("span", null,
                " ",
                Number(value).toFixed(2)));
    }
    return value;
}
function sortByColumn(data, column) {
    if (!column)
        return data;
    return data.sort((a, b) => {
        if (a[column] < b[column]) {
            return -1;
        }
        if (a[column] > b[column]) {
            return 1;
        }
        return 0;
    });
}
function reducer(state, action) {
    switch (action.type) {
        case 'CHANGE_SORT':
            if (state.column === action.column) {
                return {
                    ...state,
                    data: state.data.slice().reverse(),
                    direction: state.direction === 'ascending' ? 'descending' : 'ascending',
                };
            }
            return {
                column: action.column,
                // data: _.sortBy(state.data, [action.column]),
                data: state.data.sort((a, b) => {
                    if (a[action.column] < b[action.column]) {
                        return -1;
                    }
                    if (a[action.column] > b[action.column]) {
                        return 1;
                    }
                    return 0;
                }),
                direction: 'ascending',
            };
        default:
            throw new Error();
    }
}
class TableSortable extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
    constructor(props) {
        super(props);
        this.state = {
            column: null,
            data: props.tableData,
            direction: null,
            counter: 0
        };
    }
    reduce(action) {
        this.setState(reducer(this.state, action));
    }
    // shouldComponentUpdate(nextProps: Readonly<{ tableData: Array<Object>; }>, nextState: Readonly<{}>, nextContext: any): boolean {
    //     console.log('yeah!');
    //     return true;
    // }
    // componentDidUpdate() {
    //     this.setState({ ...this.state });
    // }
    static getDerivedStateFromProps(props, state) {
        return { ...state, data: sortByColumn(props.tableData, state.column) };
    }
    render() {
        const { column, data, direction } = this.state;
        if (!data) {
            return null;
        }
        const columns = Object.keys(data[0]);
        return (react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"], { attached: 'bottom', sortable: true, celled: true, fixed: true, compact: true, unstackable: true, style: monofont },
            react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Header, null,
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Row, null, columns.map(name => react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].HeaderCell, { sorted: column === name ? direction : null, onClick: () => this.reduce({ type: 'CHANGE_SORT', column: name }) }, name)))),
            react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Body, null, data.map(part => react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Row, null, columns.map(name => react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_3__["default"].Cell, null, renderValue(part[name]))))))));
    }
}
class PartView extends react__WEBPACK_IMPORTED_MODULE_2__.Component {
    constructor(props) {
        super(props);
        this.bc = new BroadcastChannel(PartView.CHANNEL);
        this.particles = null;
        this.updateInterval = null;
        this.bc.onmessage = (event) => this.updateContent(event.data);
        window.addEventListener('beforeunload', this.disconnected);
        this.state = {
            autoUpdate: false,
            updateInterval: 100
        };
        this.setAutoUpdate(this.state.autoUpdate, this.state.updateInterval);
    }
    requestUpdate() {
        this.bc.postMessage(PartView.UPDATE_EVENT);
    }
    connected() {
        this.bc.postMessage(PartView.CONNECT_EVENT);
    }
    disconnected() {
        this.bc.postMessage(PartView.DISCONNECT_EVENT);
    }
    updateContent(particles) {
        this.particles = particles;
        this.forceUpdate();
    }
    componentDidMount() {
        this.connected();
    }
    componentWillUnmount() {
        this.disconnected();
    }
    setAutoUpdate(isset, int) {
        if (!isset) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
        else {
            this.updateInterval = setInterval(this.requestUpdate, int);
        }
    }
    onAutoUpdate(isset) {
        this.setAutoUpdate(isset, this.state.updateInterval);
        this.setState({ autoUpdate: isset });
    }
    onIntervalUpdate(int) {
        this.setAutoUpdate(this.state.autoUpdate, int);
        this.setState({ updateInterval: int });
    }
    render() {
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isArray)(this.particles) || !this.particles.length) {
            return (react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", { style: style }, "No data has been provided."));
        }
        return (react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", null,
            react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"], { attached: 'top', size: 'tiny', style: { width: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_4__["default"].Item, null,
                    react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_5__["default"], { checked: this.state.autoUpdate, label: 'Update\u00A0every', onChange: (e, data) => this.onAutoUpdate(data.checked) }),
                    "\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0",
                    react__WEBPACK_IMPORTED_MODULE_2__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_6__["default"], { defaultValue: this.state.updateInterval, onChange: (e, data) => this.onIntervalUpdate(Number(data.value)) }),
                    "\u00A0ms")),
            react__WEBPACK_IMPORTED_MODULE_2__.createElement(TableSortable, { tableData: this.particles })));
    }
}
PartView.CHANNEL = 'part-view-debugger';
PartView.CONNECT_EVENT = 'connected';
PartView.DISCONNECT_EVENT = 'disconnected';
PartView.UPDATE_EVENT = 'update';
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_1__["default"]
], PartView.prototype, "requestUpdate", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_1__["default"]
], PartView.prototype, "connected", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_1__["default"]
], PartView.prototype, "disconnected", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PartView);


/***/ }),

/***/ "++iD":
/*!*********************************************************!*\
  !*** ./src/sandbox/containers/ShaderTranslatorView.tsx ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "GU3W");
/* harmony import */ var _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/translators/CodeConvolutionEmitter */ "jYc8");
/* harmony import */ var _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/translators/FxEmitter */ "h9Zj");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");
/* harmony import */ var _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/translators/GlslEmitter */ "elBL");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var _sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/reducers/translatorParams */ "RSd/");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-router */ "vpSu");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_6__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__]);
([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_6__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};














// function cutSourceRange(content: string, range: IRange): string {
//     const { start, end } = range;
//     // console.log(range);
//     const lines = content.split('\n').slice(start.line, end.line + 1);
//     lines[0] = lines[0].substr(start.column);
//     lines[lines.length - 1] = lines[lines.length - 1].substr(0, end.column);
//     return lines.join('\n');
// }
const diffOptions = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: false,
    // theme: 'vs-dark',
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: false,
    fontLigatures: true,
    // diff specific options
    occurrencesHighlight: false,
    renderLineHighlight: 'none',
    // renderIndentGuides: false,
    readOnly: true,
    renderControlCharacters: false,
    ignoreTrimWhitespace: true
};
/** @deprecated Use ShaderTranslatorView11 instead. */
let ShaderTranslatorView = class ShaderTranslatorView extends react__WEBPACK_IMPORTED_MODULE_10__.Component {
    editorDidMount(editor) {
        const { modified, original } = editor.getModel();
        modified.updateOptions({ tabSize: 4 });
        original.updateOptions({ tabSize: 4 });
    }
    // shouldComponentUpdate(nextProps: IShaderTranslatorViewProps) {
    //     return getFileState(this.props).content !== getFileState(nextProps).content;
    // }
    // tslint:disable-next-line:typedef
    render() {
        // console.log('ShaderTranslatorView::render()');
        const { props } = this;
        const match = (0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__.matchLocation)(props);
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__.getFileState)(props);
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__.getScope)(file);
        const pg = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_6__.getPlaygroundState)(props);
        if (!scope) {
            return null;
        }
        const fxList = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_6__.filterTechniques)(scope);
        const fx = fxList.find(tech => tech.name === match.params.name);
        if (!fx) {
            console.warn(`<${match.params.name}> effect has not been found!`);
            return null;
        }
        let original;
        let value;
        const convolute = true;
        const convPack = convolute
            ? (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_7__.asConvolutionPack)(props)
            // provide no sources for convolution
            : { textDocument: null, slastDocument: null };
        const translatorOpts = (0,_sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_8__.asFxTranslatorOprions)(props);
        // TODO: sync translation with Bundle generation (!)
        if (match.params.pass) {
            const pass = fx.passes.find((instr, i) => /^[0-9]+$/.test(match.params.pass)
                ? i === Number(match.params.pass)
                : instr.name === match.params.pass);
            if (!pass) {
                return (react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", null, "Ooops!..."));
            }
            const mode = match.params.property === 'VertexShader' ? 'vs' : 'ps';
            const shader = mode === 'vs' ? pass.vertexShader : pass.pixelShader;
            original = _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_0__.CodeEmitter.translate(shader, new _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_0__.CodeContext({ mode }));
            switch (pg.shaderFormat) {
                case 'glsl':
                    // todo: show final shader instead of direct translation
                    value = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_4__.GLSLEmitter.translate(shader, new _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_4__.GLSLContext({ mode }));
                    break;
                case 'hlsl':
                    // todo: show final shader instead of direct translation
                    value = _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_1__.CodeConvolutionEmitter.translate(shader, new _lib_fx_translators_CodeConvolutionEmitter__WEBPACK_IMPORTED_MODULE_1__.CodeConvolutionContext({ ...convPack, mode }));
                    break;
            }
        }
        else {
            original = _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_2__.FxEmitter.translate(fx, new _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_2__.FxConvolutionContext({ ...convPack }));
            value = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslator.translate(fx, new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_3__.FxTranslatorContext({ ...convPack, ...translatorOpts }));
        }
        return (react__WEBPACK_IMPORTED_MODULE_10__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_11__.MonacoDiffEditor, { ref: 'monaco', original: original, value: value, width: '100%', height: 'calc(100vh - 63px)' // todo: fixme
            , options: diffOptions, editorDidMount: this.editorDidMount }));
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_9__["default"]
], ShaderTranslatorView.prototype, "editorDidMount", null);
ShaderTranslatorView = __decorate([
    react_router__WEBPACK_IMPORTED_MODULE_13__.withRouter
], ShaderTranslatorView);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_12__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_5__.getCommon), null)(ShaderTranslatorView));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "NX5m":
/*!***********************************************************!*\
  !*** ./src/sandbox/containers/ShaderTranslatorView11.tsx ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/translators/FxEmitter */ "h9Zj");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var _sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/translatorParams */ "RSd/");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-router */ "vpSu");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__]);
([_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













const diffOptions = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: false,
    // theme: 'vs-dark',
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: false,
    fontLigatures: true,
    // diff specific options
    occurrencesHighlight: false,
    renderLineHighlight: 'none',
    // renderIndentGuides: false,
    readOnly: true,
    renderControlCharacters: false,
    ignoreTrimWhitespace: true
};
let ShaderTranslatorView = class ShaderTranslatorView extends react__WEBPACK_IMPORTED_MODULE_7__.Component {
    editorDidMount(editor) {
        const { modified, original } = editor.getModel();
        modified.updateOptions({ tabSize: 4 });
        original.updateOptions({ tabSize: 4 });
    }
    // tslint:disable-next-line:typedef
    render() {
        const { props } = this;
        const match = (0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.matchLocation)(props);
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__.getFileState)(props);
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__.getScope)(file);
        const pg = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_3__.getPlaygroundState)(props);
        if (!scope) {
            return null;
        }
        const entryFunc = scope.findFunction(match.params.name, null);
        if (!entryFunc) {
            console.warn(`<${match.params.name}> entry function has not been found!`);
            return null;
        }
        let original;
        let value;
        const convolute = true;
        const convPack = convolute
            ? (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_4__.asConvolutionPack)(props)
            // provide no sources for convolution
            : { textDocument: null, slastDocument: null };
        const translatorOpts = (0,_sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_5__.asFxTranslatorOprions)(props);
        // huck way to get type, because all the request
        // like /playground/:name/:fx/:pass/:property is being redirected to 
        // deprectaed ShaderTranslatorView
        // only requests like /playground/:name/:fx/(vertexshader|pixelshader) is being 
        // intercepted by ShaderTranslatorView11
        const shType = match.params.pass;
        const SH_MODE = {
            'VertexShader': 'vs',
            'PixelShader': 'ps'
        };
        const mode = SH_MODE[shType];
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_10__.assert)((0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_11__.isString)(mode));
        original = _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_0__.FxEmitter.translate(entryFunc, new _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_0__.FxConvolutionContext({ ...convPack, mode }));
        value = _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__.FxTranslator.translate(entryFunc, new _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__.FxTranslatorContext({ ...convPack, ...translatorOpts, mode }));
        return (react__WEBPACK_IMPORTED_MODULE_7__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_8__.MonacoDiffEditor, { ref: 'monaco', original: original, value: value, width: '100%', height: 'calc(100vh - 63px)' // todo: fixme
            , options: diffOptions, editorDidMount: this.editorDidMount }));
    }
};
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_6__["default"]
], ShaderTranslatorView.prototype, "editorDidMount", null);
ShaderTranslatorView = __decorate([
    react_router__WEBPACK_IMPORTED_MODULE_12__.withRouter
], ShaderTranslatorView);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_9__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_2__.getCommon), null)(ShaderTranslatorView));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "tFt3":
/*!**************************************************!*\
  !*** ./src/sandbox/containers/editor/Editor.tsx ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode/DebugLayout */ "prdm");
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/DistinctColor */ "aBMm");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/parserParams */ "0VSY");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! comlink */ "ZIrC");
/* harmony import */ var monaco_editor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! monaco-editor */ "ngga");
/* harmony import */ var monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! monaco-languageclient/lib/monaco-converter */ "Idrp");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_jss__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! react-jss */ "qIB2");
/* harmony import */ var react_monaco_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-monaco-editor */ "Pn81");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vscode-languageserver-types */ "+C5w");
/* harmony import */ var _LanguageServiceWorker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./LanguageServiceWorker */ "45qh");
/* harmony import */ var _styles_jss__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./styles.jss */ "fAge");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:no-for-in */
/* tslint:disable:forin */
/* tslint:disable:typedef */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

















// tslint:disable-next-line:no-submodule-imports
// import LanguageServiceWorker from 'worker-loader!./LanguageServiceProvider';



const m2p = new monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_9__.MonacoToProtocolConverter(monaco_editor__WEBPACK_IMPORTED_MODULE_8__); // FIXME
const p2m = new monaco_languageclient_lib_monaco_converter__WEBPACK_IMPORTED_MODULE_9__.ProtocolToMonacoConverter(monaco_editor__WEBPACK_IMPORTED_MODULE_8__); // FIXME
const provider = comlink__WEBPACK_IMPORTED_MODULE_17__.wrap(new _LanguageServiceWorker__WEBPACK_IMPORTED_MODULE_15__.LanguageServiceWorker());
function defer() {
    const deferred = {
        promise: null,
        resolve: null,
        reject: null
    };
    // tslint:disable-next-line:promise-must-complete
    deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
const LANGUAGE_ID = 'hlsl';
async function loadLanguage(def) {
    const mod = await def.loader();
    monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.setMonarchTokensProvider(def.id, mod.language);
    monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.setLanguageConfiguration(def.id, mod.conf);
}
function registerLanguage(def) {
    monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.register(def);
    monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.onLanguage(def.id, () => { loadLanguage(def); });
}
// register the HLSL language with Monaco
registerLanguage({
    id: LANGUAGE_ID,
    extensions: ['.fx', '.vsh', '.psh', '.hsh', '.dsh', '.csh'],
    aliases: ['HLSL', 'hlsl', 'openhlsl'],
    mimetypes: ['application/hlsl'],
    loader: () => __webpack_require__.e(/*! import() */ "src_sandbox_containers_editor_hlsl_ts").then(__webpack_require__.bind(__webpack_require__, /*! ./hlsl */ "EtXx"))
});
const options = {
    selectOnLineNumbers: true,
    fontSize: 12,
    renderWhitespace: 'none',
    lineHeight: 14,
    minimap: {
        enabled: false
    },
    automaticLayout: true,
    glyphMargin: true,
    theme: 'vs-dark',
    language: LANGUAGE_ID,
    lineDecorationsWidth: 0,
    cursorSmoothCaretAnimation: true,
    fontLigatures: true,
};
class SourceEditor extends react__WEBPACK_IMPORTED_MODULE_10__.Component {
    constructor() {
        super(...arguments);
        this.codeLensProvider = null;
        this.hoverProvider = null;
        this.completionProvider = null;
        this.documentSymbolProvider = null;
        this.signatureHelpProvider = null;
        this.mouseDownEvent = null;
        // cache for previously set decorations/breakpoints
        this.decorations = [];
        this.pendingValidationRequests = new Map();
        this.deferredRequests = [];
        // cache for params
        this.parserParamsCache = {};
    }
    setupDecorations() {
        const { props } = this;
        const { classes } = props;
        const decorations = [];
        const cls = {
            error: classes.errorMarker,
            warning: classes.warningMarker
        };
        const file = this.getFile();
        for (const key in file.markers) {
            const { range, type, tooltip, range: { start, end }, payload } = file.markers[key];
            if (!tooltip && type === 'marker') {
                decorations.push({
                    range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(start.line + 1, start.column + 1, end.line + 1, end.column + 1),
                    options: { inlineClassName: classes.yellowMarker }
                });
            }
            else {
                switch (type) {
                    case 'error':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(start.line + 1, start.column + 1, end.line + 1, end.column + 1),
                            options: { className: cls[type], hoverMessage: { value: tooltip } },
                        });
                        break;
                    case 'line':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(start.line + 1, 0, start.line + 1, 0),
                            options: {
                                isWholeLine: true,
                                className: classes[`dc_${_lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_2__["default"].resolveColor(payload['color'])}`]
                                // inlineClassName
                            }
                        });
                        break;
                    case 'unreachable-code':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(start.line + 1, 0, end.line, 0),
                            options: {
                                isWholeLine: true,
                                inlineClassName: classes.unreachanbleCode
                            }
                        });
                        break;
                    case 'deprecated':
                        decorations.push({
                            range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(start.line + 1, start.column + 1, end.line + 1, end.column + 1),
                            options: {
                                inlineClassName: classes.deprecated,
                                hoverMessage: { value: tooltip }
                            },
                        });
                        break;
                    default:
                }
            }
        }
        // fixme: clumsy code :/
        for (const key in file.breakpoints) {
            const lineNumber = file.breakpoints[key] + 1;
            decorations.push({
                range: new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(lineNumber, 1, lineNumber, 1),
                options: { glyphMarginClassName: classes.breakpoint },
            });
        }
        return decorations;
    }
    // handle content's update from outside of the editor
    UNSAFE_componentWillUpdate(nextProps) {
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getFileState)(nextProps);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.content)) {
            return;
        }
        if (file.content !== this.getContent()) {
            this.validate(file.content, file.uri);
            this.getEditor().setValue(file.content);
            console.log('%c force reload content from outside', 'background: #ffd1c9; color: #ff3714');
        }
    }
    componentDidUpdate() {
        this.updateDecorations();
        // TEMP: temp solution for parser param sync
        this.validateParser(this.props);
    }
    componentDidMount() {
        // TEMP: temp solution for parser param sync
        this.validateParser(this.props);
    }
    validateParser(stateNext) {
        const parserStateNext = (0,_sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_5__.getParser)(stateNext);
        const parserProps = ['flags', 'type', 'grammar', 'parsingFlags'];
        const paramsChanges = !parserProps.every(propName => this.parserParamsCache[propName] === parserStateNext[propName]);
        const defines = stateNext.sourceFile.defines.map(name => ({ name }));
        if (paramsChanges) {
            parserProps.forEach(propName => this.parserParamsCache[propName] = parserStateNext[propName]);
            const { grammar, flags, type, parsingFlags } = parserStateNext;
            if (grammar) {
                provider.init({ grammar, flags, type }, parsingFlags, comlink__WEBPACK_IMPORTED_MODULE_17__.proxy((name) => {
                    // IP: don't use closure here?
                    return _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_13__.makeResolver((0,_sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_13__.getDepot)(this.props))(name);
                }), defines);
            }
        }
    }
    editorWillMount(editor) { }
    pendingValidations() {
        const def = defer();
        if (this.pendingValidationRequests.size > 0) {
            this.deferredRequests.push(def);
            return def.promise;
        }
        def.resolve();
        return def.promise;
    }
    // tslint:disable-next-line:max-func-body-length
    editorDidMount(editor) {
        editor.getModel()
            .updateOptions({ tabSize: 4 });
        //
        // naive breakpoints implementation
        //
        this.mouseDownEvent = editor.onMouseDown((e) => {
            if (e.target.type !== monaco_editor__WEBPACK_IMPORTED_MODULE_8__.editor.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                return;
            }
            const file = this.getFile();
            const { props } = this;
            const { breakpoints } = file;
            let { lineNumber } = e.target.position;
            lineNumber = (0,_lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_1__.cdlview)(file.debugger.bcDocument.program?.cdl)
                .resolveBreakpointLocation(lineNumber - 1);
            if (lineNumber === -1) {
                return;
            }
            if (breakpoints.indexOf(lineNumber) === -1) {
                props.actions.addBreakpoint(lineNumber);
            }
            else {
                props.actions.removeBreakpoint(lineNumber);
            }
        });
        const self = this;
        this.codeLensProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.registerCodeLensProvider(LANGUAGE_ID, {
            async provideCodeLenses(model, token) {
                // validation should always be done before any other requests
                await self.pendingValidations();
                return p2m.asCodeLensList(await provider.provideFxCodeLenses(self.asTextDocumentIdentifier()));
            }
        });
        this.completionProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.registerCompletionItemProvider(LANGUAGE_ID, {
            triggerCharacters: ['(', ',', '=', '+'],
            provideCompletionItems(model, position, context, token) {
                // const document = self.createDocument(model);
                const wordUntil = model.getWordUntilPosition(position);
                const defaultRange = new monaco_editor__WEBPACK_IMPORTED_MODULE_8__.Range(position.lineNumber, wordUntil.startColumn, position.lineNumber, wordUntil.endColumn);
                // return jsonService.doComplete(document,
                // m2p.asPosition(position.lineNumber, position.column), jsonDocument).then((list) => {
                //     return p2m.asCompletionResult(list, defaultRange);
                // });
                // console.log('provideCompletionItems', defaultRange, wordUntil);
                return null;
            },
            resolveCompletionItem(item, token) {
                // return jsonService.doResolve(m2p.asCompletionItem(item)).then(result => p2m.asCompletionItem(result, item.range));
                console.log('resolveCompletionItem', m2p.asCompletionItem(item));
                return null;
            }
        });
        // TODO: do not pass whole document
        this.signatureHelpProvider = monaco_editor__WEBPACK_IMPORTED_MODULE_8__.languages.registerSignatureHelpProvider(LANGUAGE_ID, {
            signatureHelpTriggerCharacters: ['('],
            signatureHelpRetriggerCharacters: [','],
            async provideSignatureHelp(model, position, token, context) {
                // validation should always be done before any other requests
                await self.pendingValidations();
                const signatureHelp = await provider.provideSignatureHelp(self.asTextDocumentIdentifier(), m2p.asPosition(position.lineNumber, position.column));
                return signatureHelp && p2m.asSignatureHelpResult(signatureHelp); // TODO: fixme, wrong type?
            }
        });
        // this.documentSymbolProvider = monaco.languages.registerDocumentSymbolProvider(
        //     LANGUAGE_ID, 
        //     {
        //     provideDocumentSymbols(model, token): monaco.languages.DocumentSymbol[] | monaco.Thenable<monaco.languages.DocumentSymbol[]> {
        //         const document = self.createDocument(model);
        //         // const jsonDocument = jsonService.parseJSONDocument(document);
        //         // return p2m.asSymbolInformations(jsonService.findDocumentSymbols(document, jsonDocument));
        //         // return p2m.asSymbolInformations();
        //     }
        // });
        // // const self = this;
        // this.hoverProvider = monaco.languages.registerHoverProvider(
        //     LANGUAGE_ID,
        //     {
        //         provideHover(model, position, token): monaco.languages.Hover | monaco.Thenable<monaco.languages.Hover> {
        //             // const document = self.createDocument(model);
        //             // const jsonDocument = jsonService.parseJSONDocument(document);
        //             // console.log(model, position, token);
        //             return null;
        //         }
        //     });
    }
    asTextDocumentIdentifier() {
        return {
            uri: this.getFile().uri
        };
    }
    cleanPendingValidation(document) {
        const request = this.pendingValidationRequests.get(document.uri);
        if (request !== undefined) {
            clearTimeout(request);
            this.pendingValidationRequests.delete(document.uri);
        }
    }
    validate(newContent, newUri) {
        const document = this.createDocument(this.getModel(), newContent, newUri);
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(document.uri)) {
            return;
        }
        this.cleanPendingValidation(document);
        this.pendingValidationRequests.set(document.uri, setTimeout(async () => {
            await this.doValidate(document);
            this.pendingValidationRequests.delete(document.uri);
        }));
    }
    // tslint:disable-next-line:member-ordering
    static asMarker(diag) {
        const { code, message, range: { start, end }, severity, source } = diag;
        const severities = {
            [vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_14__.DiagnosticSeverity.Error]: monaco_editor__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity.Error,
            [vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_14__.DiagnosticSeverity.Warning]: monaco_editor__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity.Warning
        };
        return {
            severity: severities[severity],
            code: code,
            message,
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    async doValidate(document) {
        if (document.getText().length === 0) {
            this.cleanDiagnostics();
            return;
        }
        // const messages = await LanguageService.validate(document);
        const diagnostics = await provider.validate(document);
        monaco_editor__WEBPACK_IMPORTED_MODULE_8__.editor.setModelMarkers(this.getModel(), 'default', diagnostics.map(diag => SourceEditor.asMarker(diag)));
        this.deferredRequests.forEach(def => def.resolve());
        this.deferredRequests = [];
        // const unreachanbleCode = await provider.provideUnreachableCodeBlocks(document);
    }
    cleanDiagnostics() {
        monaco_editor__WEBPACK_IMPORTED_MODULE_8__.editor.setModelMarkers(this.getModel(), 'default', []);
    }
    async onChange(content, e) {
        this.validate(content);
        this.props.actions.setContent(content);
    }
    getEditor() {
        // don't know better way :/
        return this.refs.monaco.editor;
    }
    getModel() {
        // tslint:disable-next-line:newline-per-chained-call
        return this.getEditor().getModel();
    }
    getContent() {
        // tslint:disable-next-line:newline-per-chained-call
        return this.getModel().getValue();
    }
    createDocument(model, newContent, newUri) {
        return vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_14__.TextDocument.create(newUri || this.getFile().uri, "0" /*model.getModeId()*/, model.getVersionId(), newContent || model.getValue());
    }
    updateDecorations() {
        this.decorations = this.getEditor().deltaDecorations(this.decorations, this.setupDecorations());
        return this.decorations;
    }
    shouldComponentUpdate(nextProps) {
        const src = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getFileState)(this.props);
        const dst = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getFileState)(nextProps);
        return this.getContent() !== dst.content ||
            !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(src.markers, dst.markers) ||
            !(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(src.breakpoints, dst.breakpoints);
    }
    componentWillUnmount() {
        if (this.codeLensProvider) {
            this.codeLensProvider.dispose();
        }
        if (this.hoverProvider) {
            this.hoverProvider.dispose();
        }
    }
    // componentWillMount() {
    //     const file = this.getFile();
    //     const uri = monaco.Uri.parse(`inmemory://${file.filename}`);
    //     this.model = monaco.editor.createModel(file.content, LANGUAGE_ID, uri);
    // }
    render() {
        const file = this.getFile();
        // const uri = monaco.Uri.parse(`inmemory://${file.filename}`);
        const content = file.content;
        return (react__WEBPACK_IMPORTED_MODULE_10__.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_11__["default"], { ref: 'monaco', value: content, width: '100%', height: 'calc(100vh - 63px)' // todo: fixme
            , options: { ...options }, onChange: this.onChange, editorDidMount: this.editorDidMount, editorWillMount: this.editorWillMount }));
    }
    getFile() {
        return (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getFileState)(this.props);
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "editorWillMount", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "editorDidMount", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], SourceEditor.prototype, "onChange", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_12__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__.mapActions)(_sandbox_actions__WEBPACK_IMPORTED_MODULE_3__.sourceCode))((0,react_jss__WEBPACK_IMPORTED_MODULE_18__["default"])(_styles_jss__WEBPACK_IMPORTED_MODULE_16__["default"])(SourceEditor)));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "fAge":
/*!*****************************************************!*\
  !*** ./src/sandbox/containers/editor/styles.jss.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/util/DistinctColor */ "aBMm");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    yellowMarker: {
        backgroundColor: 'rgba(255,255,0,0.3)'
    },
    errorMarker: {
        top: '1px',
        background: `url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E") repeat-x bottom left`
    },
    warningMarker: {
        top: '1px',
        filter: 'hue-rotate(45deg)',
        background: `url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23f48771'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E") repeat-x bottom left`
    },
    breakpoint: {
        background: 'red'
    },
    unreachanbleCode: {
        // color: '#666 !important'
        opacity: '0.35'
    },
    deprecated: {
        textDecoration: 'line-through'
    },
    ..._lib_util_DistinctColor__WEBPACK_IMPORTED_MODULE_0__["default"].buildVariousClasses('dc')
});


/***/ }),

/***/ "ZhYP":
/*!*******************************************************!*\
  !*** ./src/sandbox/containers/playground/FxScene.tsx ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! semantic-ui-react */ "GWf2");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var _lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM/native */ "1fdM");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/techniques */ "LvoO");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_UniformHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/UniformHelper */ "bVKE");
/* harmony import */ var _shaders_fx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shaders/fx */ "5byo");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var _utils_adjacency__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/adjacency */ "I0Lu");
/* harmony import */ var _utils_deps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/deps */ "KeJm");
/* harmony import */ var _utils_gui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/gui */ "eK+6");
/* harmony import */ var _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/GroupedUniforms */ "KPdV");
/* harmony import */ var _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/SingleUniforms */ "O6BO");
/* harmony import */ var _sandbox_styles_custom_dat_gui_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sandbox/styles/custom/dat-gui.css */ "zwOj");
/* harmony import */ var _HDRScene__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./HDRScene */ "JRfj");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__, _utils_deps__WEBPACK_IMPORTED_MODULE_11__, _utils_gui__WEBPACK_IMPORTED_MODULE_12__]);
([_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__, _utils_deps__WEBPACK_IMPORTED_MODULE_11__, _utils_gui__WEBPACK_IMPORTED_MODULE_12__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



















let desc = `
struct PartLight {
    float3 pos;
    float radius;
    float3 color;
    float attenuation;
    float viewZ;
    int camIdx;
    bool isFpView;
    bool isAdaptiveIntensity;
 };
`;
const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_5__.createTextDocument)('://raw', desc);
const slDocument = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_3__.createSLDocument)(textDocument);
const PartLightT = (0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__.typeAstToTypeLayout)(slDocument.root.scope.findType('PartLight'));
const Shaders = (id) => _shaders_fx__WEBPACK_IMPORTED_MODULE_7__[id];
const statsStyleFix = {
    position: 'absolute',
    color: 'white',
    padding: '2px 5px',
    fontFamily: 'consolas, monospace',
    fontSize: '10px',
    right: '0',
    lineHeight: '11px',
    textShadow: '0 0 1px grey',
    whiteSpace: 'pre'
};
const progressStyleFix = {
    background: '#eee',
    borderRadius: '0'
};
function UnpackCanvasImageSource(img) {
    const width = img.width;
    const height = img.height;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    canvas.getContext('2d').drawImage(img, 0, 0, width, height);
    return canvas.getContext('2d').getImageData(0, 0, width, height).data;
}
function setUniformValue(helper, name, type, value) {
    switch (type) {
        case 'int':
        case 'uint':
            helper.set(name).int(value);
            break;
        case 'float':
            helper.set(name).float(value);
            break;
        case 'float2':
            let v2 = value;
            helper.set(name).float2(v2.x, v2.y);
            break;
        case 'float3':
            let v3 = value;
            helper.set(name).float3(v3.x, v3.y, v3.z);
            break;
        case 'float4':
            let v4 = value;
            helper.set(name).float4(v4.x, v4.y, v4.z, v4.w);
            break;
        case 'color':
            let color = value;
            helper.set(name).float4(color.r, color.g, color.b, color.a);
            break;
    }
}
// prerecord uniforms for bytecode bundle
function prerecordUniforms(camera, timeline, controls, presetName) {
    const constants = timeline.getConstants();
    const helper = (0,_lib_fx_UniformHelper__WEBPACK_IMPORTED_MODULE_6__["default"])();
    helper.set('elapsedTime').float(constants.elapsedTime);
    helper.set('elapsedTimeLevel').float(constants.elapsedTimeLevel);
    helper.set('elapsedTimeThis').float(constants.elapsedTimeLevel);
    helper.set('parentPosition').float3(0, 0, 0);
    helper.set('cameraPosition').float3.apply(null, camera.position.toArray());
    helper.set('instanceTotal').int(2);
    helper.set('frameNumber').int(constants.frameNumber);
    if (controls) {
        if (presetName) {
            const preset = controls?.presets.find(p => p.name == presetName);
            preset?.data.forEach(entry => setUniformValue(helper, entry.name, entry.type, entry.value));
        }
        for (const name in controls.values) {
            const type = controls.controls[name].type;
            const value = controls.values[name];
            setUniformValue(helper, name, type, value);
        }
    }
    return helper.finish();
}
class TriangleGeometry extends three__WEBPACK_IMPORTED_MODULE_17__.BufferGeometry {
    constructor() {
        super();
        this.type = 'TriangleGeometry';
        const indices = [0, 1, 2];
        const vertices = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        const normals = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        const uvs = [0, 0, 0, 0, 0, 0];
        this.setIndex(indices);
        this.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_17__.Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_17__.Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_17__.Float32BufferAttribute(uvs, 2));
    }
}
class FxScene extends _HDRScene__WEBPACK_IMPORTED_MODULE_16__["default"] {
    constructor(props) {
        super(props);
        this.env = null;
        this.helperGeom = [];
        this.gui = new _utils_gui__WEBPACK_IMPORTED_MODULE_12__.GuiView;
        this.uniformGroups = new _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_13__.GroupedUniforms;
        this.deps = new _utils_deps__WEBPACK_IMPORTED_MODULE_11__.Deps;
        this.state = {
            emitter: null,
            loading: null,
            nParticles: 0,
            time: '0.00',
            ...this.stateInitials()
        };
    }
    componentDidMount() {
        super.componentDidMount();
        this.gui.mount(this.mount);
        this.gui.create(this.props.controls);
        this.uniformGroups.create9(this.props.emitter);
        this.uniforms = _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_14__.SingleUniforms.create(this.props.controls, this.deps);
        this.createEmitter(this.props.emitter);
        this.start();
    }
    shouldComponentUpdate(nextProps, nextState) {
        return this.state.emitter !== nextProps.emitter
            || this.state.nParticles !== nextState.nParticles
            || this.state.time !== nextState.time;
    }
    // this function is called because of ant state change
    // including part count
    componentDidUpdate(prevProps, prevState) {
        super.componentDidUpdate?.(prevProps, prevState);
        // loading still in process - nothing todo
        if (this.state.loading === this.props.emitter) {
            return;
        }
        // new emitter has been passed - reload required
        if (this.props.emitter !== this.state.emitter) {
            // reload emitter
            this.createEmitter(this.props.emitter);
            return;
        }
        // if emitter is just loaded or update
        const isLoaded = prevState.loading == this.state.emitter;
        const isUpdated = prevState.emitter === this.state.emitter;
        // ....
    }
    componentWillUnmount() {
        this.removeEmitter();
        super.componentWillUnmount();
    }
    render() {
        return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { style: this.props.style, ref: (mount) => { this.mount = mount; } },
            react__WEBPACK_IMPORTED_MODULE_1__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"], { value: this.state.nParticles, total: this.props.emitter.getCapacity(), attached: 'top', size: 'medium', indicating: true, style: progressStyleFix }),
            react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", { style: statsStyleFix },
                "\u00A0\u00A0\u00A0\u00A0\u00A0count: ",
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, this.state.nParticles),
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("br", null),
                "simulation: CPU",
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("br", null),
                "\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0fps: ",
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, Math.round(this.state.fps.value)),
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("br", null),
                "\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0time: ",
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("span", null, this.state.time),
                react__WEBPACK_IMPORTED_MODULE_1__.createElement("br", null))));
    }
    addPassLine(pass, passId) {
        const geometry = new three__WEBPACK_IMPORTED_MODULE_17__.BufferGeometry();
        const instanceData = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.memoryToF32Array(pass.getData());
        const desc = pass.getDesc();
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedInterleavedBuffer(new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), desc.stride);
        //
        // Instance data
        //
        desc.instanceLayout.forEach(attr => {
            const interleavedAttr = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, attr.size, attr.offset);
            geometry.setAttribute(attr.name, interleavedAttr);
        });
        const uniforms = this.uniforms;
        const material = new three__WEBPACK_IMPORTED_MODULE_17__.RawShaderMaterial({
            uniforms,
            vertexShader: desc.vertexShader,
            fragmentShader: desc.pixelShader,
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_17__.NormalBlending,
            depthTest: false,
            // wireframeLinewidth: 5
        });
        material.uniformsGroups = this.uniformGroups.data()[passId];
        geometry.setDrawRange(0, pass.getNumRenderedParticles());
        const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.LineSegments(geometry, material);
        this.scene.add(mesh);
        this.passes.push({ meshes: [mesh], instancedBuffer });
    }
    addPass(pass, passId) {
        const desc = pass.getDesc();
        const instanceData = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.memoryToF32Array(pass.getData());
        if (desc.geometry === "line") {
            this.addPassLine(pass, passId);
            return;
        }
        const { stride, instanceLayout, vertexShader, pixelShader, renderStates } = desc;
        // tslint:disable-next-line:max-line-length
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedInterleavedBuffer(new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), stride);
        const attrs = instanceLayout.map(attr => {
            return {
                name: attr.name,
                data: new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, attr.size, attr.offset)
            };
        });
        const uniforms = this.uniforms;
        const material = new three__WEBPACK_IMPORTED_MODULE_17__.RawShaderMaterial({
            uniforms,
            vertexShader: vertexShader,
            fragmentShader: pixelShader,
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_17__.NormalBlending,
            depthTest: false,
            // TODO: do not use for billboards
            side: three__WEBPACK_IMPORTED_MODULE_17__.DoubleSide
        });
        // todo: add support to technique.cpp
        if (renderStates?.[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_8__.ERenderStates.ZENABLE]) {
            material.depthTest = renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_8__.ERenderStates.ZENABLE] === _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_9__.ERenderStateValues.TRUE;
        }
        // todo: add support to technique.cpp
        if (renderStates?.[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_8__.ERenderStates.BLENDENABLE]) {
            material.transparent = renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_8__.ERenderStates.BLENDENABLE] === _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_9__.ERenderStateValues.TRUE;
        }
        material.uniformsGroups = this.uniformGroups.data()[passId];
        const meshes = this.createInstinceGeometry(desc.geometry).map(instanceGeometry => {
            const geometry = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedBufferGeometry();
            attrs.forEach(({ name, data }) => { geometry.setAttribute(name, data); });
            // FIXME: do not use hardcoded layout
            const geometryFixedLayout = {
                a_position0: instanceGeometry.attributes.position,
                a_normal0: instanceGeometry.attributes.normal,
                a_texcoord0: instanceGeometry.attributes.uv
            };
            if (instanceGeometry.index) {
                geometry.setIndex(instanceGeometry.index);
            }
            else {
                geometry.setIndex(Array(instanceGeometry.attributes.position.array.length / 3).fill(0).map((x, i) => i));
            }
            // geometry.index = instanceGeometry.index;
            for (const attrName in geometryFixedLayout) {
                geometry.attributes[attrName] = geometryFixedLayout[attrName];
            }
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geometry, material);
            mesh.name = `pass-${passId}-${desc.geometry}`;
            return mesh;
        });
        this.scene.add(...meshes);
        this.passes.push({ meshes, instancedBuffer });
    }
    showEnv() {
        if (!this.env)
            this.addEnv();
        Object.keys(this.env).forEach(objName => (this.env[objName].visible = true));
    }
    hideEnv() {
        if (!this.env)
            return;
        Object.keys(this.env).forEach(objName => (this.env[objName].visible = false));
    }
    addEnv() {
        if (this.env) {
            return;
        }
        this.env = {};
        const scene = this.scene;
        this.env.floor = (_ => {
            const geo = new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry(20, 20);
            const mat = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({ shininess: 10, color: "#fff" });
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geo, mat);
            mesh.rotation.x = Math.PI * -.5;
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        })();
        this.env.leftWall = (_ => {
            const geo = new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry(20, 15);
            const mat = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({ shininess: 10, color: "#fff" });
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geo, mat);
            mesh.rotation.y = Math.PI * 0.5;
            mesh.position.set(-10, 7.5, 0);
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        })();
        this.env.rightWall = (_ => {
            const geo = new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry(20, 15);
            const mat = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({ shininess: 10, color: "#fff" });
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geo, mat);
            mesh.rotation.y = Math.PI * -0.5;
            mesh.position.set(10, 7.5, 0);
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        })();
        this.env.backWall = (_ => {
            const geo = new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry(15, 20);
            const mat = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({ shininess: 10, color: "#fff" });
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geo, mat);
            mesh.rotation.z = Math.PI * -0.5;
            mesh.position.set(0, 7.5, -10);
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        })();
        this.env.ceiling = (_ => {
            const geo = new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry(20, 20);
            const mat = new three__WEBPACK_IMPORTED_MODULE_17__.MeshPhongMaterial({ shininess: 10, color: "#fff" });
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geo, mat);
            mesh.rotation.x = Math.PI * 0.5;
            mesh.position.set(0, 15, 0);
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        })();
    }
    addPassLight(passId) {
        this.showEnv();
        this.passes.push({ meshes: null, instancedBuffer: null });
    }
    addPassLWI(pass, passId) {
        const desc = pass.getDesc();
        const instanceData = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.memoryToF32Array(pass.getData());
        // desc.instanceName == "LwiInstance" || desc.instanceName == "LwiColoredInstance"
        const GLSLMat = {
            "LwiInstance": {
                vertexShader: Shaders('lwiMatVS'),
                fragmentShader: Shaders('lwiMatFS')
            },
            "LwiColoredInstance": {
                vertexShader: Shaders('lwiColoredMatVS'),
                fragmentShader: Shaders('lwiColoredMatFS')
            },
        };
        // tslint:disable-next-line:max-line-length
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedInterleavedBuffer(new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), desc.stride);
        instancedBuffer.setUsage(three__WEBPACK_IMPORTED_MODULE_17__.DynamicDrawUsage);
        const a_dynData_0 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 0);
        const a_dynData_1 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 4);
        const a_worldMat_0 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 8);
        const a_worldMat_1 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 12);
        const a_worldMat_2 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 16);
        const a_worldMatPrev_0 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 20);
        const a_worldMatPrev_1 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 24);
        const a_worldMatPrev_2 = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 28);
        const uniforms = this.uniforms;
        const material = new three__WEBPACK_IMPORTED_MODULE_17__.RawShaderMaterial({
            uniforms,
            ...GLSLMat[desc.instanceName],
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_17__.NormalBlending,
            depthTest: true,
            // TODO: do not use for billboards
            side: three__WEBPACK_IMPORTED_MODULE_17__.DoubleSide
        });
        material.uniformsGroups = this.uniformGroups.data()[passId];
        const meshes = this.createInstinceGeometry(desc.geometry, "box").map(instanceGeometry => {
            const geometry = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedBufferGeometry();
            geometry.index = instanceGeometry.index;
            geometry.attributes.position = instanceGeometry.attributes.position;
            geometry.attributes.normal = instanceGeometry.attributes.normal;
            geometry.attributes.uv = instanceGeometry.attributes.uv;
            geometry.attributes.a_dynData_0 = a_dynData_0;
            geometry.attributes.a_dynData_1 = a_dynData_1;
            geometry.attributes.a_worldMat_0 = a_worldMat_0;
            geometry.attributes.a_worldMat_1 = a_worldMat_1;
            geometry.attributes.a_worldMat_2 = a_worldMat_2;
            geometry.attributes.a_worldMatPrev_0 = a_worldMatPrev_0;
            geometry.attributes.a_worldMatPrev_1 = a_worldMatPrev_1;
            geometry.attributes.a_worldMatPrev_2 = a_worldMatPrev_2;
            geometry.instanceCount = pass.getNumRenderedParticles();
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geometry, material);
            mesh.name = `pass-lwi-${passId}-${desc.geometry}`;
            return mesh;
        });
        this.scene.add(...meshes);
        this.passes.push({ meshes: meshes, instancedBuffer });
    }
    addPassDefaultMat(pass, passId) {
        const desc = pass.getDesc();
        const instanceData = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.memoryToF32Array(pass.getData());
        // tslint:disable-next-line:max-line-length
        const instancedBuffer = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedInterleavedBuffer(new Float32Array(instanceData.buffer, instanceData.byteOffset, instanceData.byteLength >> 2), desc.stride);
        instancedBuffer.setUsage(three__WEBPACK_IMPORTED_MODULE_17__.DynamicDrawUsage);
        // instancedBuffer.setDynamic(true);
        // todo: remove hardcoded layout or check it's validity.
        const offset = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 3, 0);
        const color = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 4, 3);
        const size = new three__WEBPACK_IMPORTED_MODULE_17__.InterleavedBufferAttribute(instancedBuffer, 1, 7);
        const uniforms = this.uniforms;
        const material = new three__WEBPACK_IMPORTED_MODULE_17__.RawShaderMaterial({
            uniforms,
            vertexShader: Shaders('defMatVS'),
            fragmentShader: Shaders('defMatFS'),
            transparent: true,
            blending: three__WEBPACK_IMPORTED_MODULE_17__.NormalBlending,
            depthTest: false
        });
        material.uniformsGroups = this.uniformGroups.data()[passId];
        const meshes = this.createInstinceGeometry(desc.geometry).map(instanceGeometry => {
            const geometry = new three__WEBPACK_IMPORTED_MODULE_17__.InstancedBufferGeometry();
            geometry.index = instanceGeometry.index;
            geometry.attributes.position = instanceGeometry.attributes.position;
            geometry.attributes.normal = instanceGeometry.attributes.normal;
            geometry.attributes.uv = instanceGeometry.attributes.uv;
            geometry.attributes.offset = offset;
            geometry.attributes.color = color;
            geometry.attributes.size = size;
            geometry.instanceCount = pass.getNumRenderedParticles();
            const mesh = new three__WEBPACK_IMPORTED_MODULE_17__.Mesh(geometry, material);
            mesh.name = `pass-def-${passId}-${desc.geometry}`;
            return mesh;
        });
        this.scene.add(...meshes);
        this.passes.push({ meshes, instancedBuffer });
    }
    createInstinceGeometry(geometry, fallback = "billboard") {
        let instanceGeometry = null;
        switch (geometry) {
            case "box":
                instanceGeometry = [new three__WEBPACK_IMPORTED_MODULE_17__.BoxGeometry()];
                break;
            case "sphere":
                instanceGeometry = [new three__WEBPACK_IMPORTED_MODULE_17__.SphereGeometry(0.5)];
                break;
            case "cylinder":
                instanceGeometry = [new three__WEBPACK_IMPORTED_MODULE_17__.CylinderGeometry(0.5, 0.5, 1.0)];
                break;
            case "line":
                console.assert(false, "line should have been handled using different code branch");
                break;
            case "billboard":
                instanceGeometry = [new three__WEBPACK_IMPORTED_MODULE_17__.PlaneGeometry()];
                break;
            case "triangle":
                instanceGeometry = [new TriangleGeometry()];
                break;
            default:
                let objName = Object.keys(this.deps.models).find(name => name.includes(geometry));
                if (objName) {
                    let meshes = this.deps.models[objName];
                    if (meshes) {
                        return meshes.map(mesh => mesh.geometry);
                    }
                }
                return this.createInstinceGeometry(fallback);
        }
        return instanceGeometry;
    }
    removeEmitter() {
        this.passes?.forEach(pass => {
            if (pass.meshes) {
                this.scene.remove(...pass.meshes);
            }
            // verbose('emitter\'s pass removed.');
        });
        Object.values(this.textures || {}).forEach(tex => {
            _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.destroyTexture(tex);
        });
        Object.values(this.meshes || {}).forEach(mesh => {
            _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.destroyTrimesh(mesh);
        });
        this.meshes = {};
        this.textures = {};
    }
    createPasses(emitter) {
        this.passes = [];
        // tslint:disable-next-line:max-func-body-length
        let nPass = emitter.getPassCount();
        this.hideEnv();
        for (let i = 0; i < nPass; ++i) {
            let pass = emitter.getPass(i);
            let desc = pass.getDesc();
            if (desc.vertexShader && desc.pixelShader) {
                this.addPass(pass, i);
            }
            else if (desc.instanceName == "DefaultShaderInput") {
                this.addPassDefaultMat(pass, i);
            }
            else if (desc.instanceName == "LwiInstance" || desc.instanceName == "LwiColoredInstance") {
                this.addPassLWI(pass, i);
            }
            else if (desc.instanceName == "PartLight") {
                this.addPassLight(i);
            }
        }
        this.setState({ emitter, loading: null });
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`emitter '${emitter.getName()}' has been loaded.`);
    }
    createEmitter(emitter) {
        this.removeEmitter();
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDefAndNotNull)(emitter)) {
            return;
        }
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`emitter '${emitter.getName()}' loading in process...`);
        this.setState({ loading: emitter, emitter: null });
        const controls = this.props.controls;
        const doLoadTexture = true; //Object.values(controls?.controls).map(ctrl => ctrl.type).includes('texture2d');
        const doLoadMeshes = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('mesh');
        this.deps.resolve(doLoadTexture, doLoadMeshes, (deps) => {
            this.createPasses(emitter);
        });
    }
    // setup resource for simulation
    // all except uniforms
    setupResources() {
        const emitter = this.state.emitter;
        const createTextureFromSource = (dep) => {
            let img = dep.source.data;
            let width = img.width;
            let height = img.height;
            let data = null;
            // return Techniques.createTexture({ width: 1, height: 1 }, new Uint8Array([0,0,0,0]));
            if (img instanceof HTMLImageElement) {
                data = UnpackCanvasImageSource(img);
            }
            else {
                data = img.data;
            }
            return _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.createTexture({ width, height }, data);
        };
        const createMeshFromSource = (dep) => {
            const { geometry } = dep[0];
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(geometry);
            const { vertCount, faceCount, vertices, faces, indicesAdj, facesAdj } = (0,_utils_adjacency__WEBPACK_IMPORTED_MODULE_10__.prepareTrimesh)(geometry);
            return _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.createTrimesh({
                vertCount,
                faceCount
            }, new Float32Array(vertices), new Uint32Array(faces), new Uint32Array(indicesAdj), new Uint32Array(facesAdj));
        };
        const controls = this.props.controls;
        for (const name in controls.values) {
            // todo: skip textrues and meshes
            const type = controls.controls[name].type;
            const value = controls.values[name];
            if (type == 'texture2d') {
                // all the sources must be preloaded in advance (!)
                const source = this.deps.textures[value];
                // if (!source) {
                //     const value = 'TEXTURE_PLACEHOLDER_WHITE_1X1';
                //     if (!this.textures[value]) {
                //         this.textures[value] = createTextureFromSource(TEXTURE_PLACEHOLDER_WHITE_1X1);
                //     }
                //     emitter.setTexture(name, this.textures[value]);
                //     continue;
                // }
                if (!this.textures[value]) {
                    this.textures[value] = createTextureFromSource(source);
                }
                emitter.setTexture(name, this.textures[value]);
            }
            if (type == 'mesh') {
                // all the sources must be preloaded in advance (!)
                const source = this.deps.models[value];
                if (!this.meshes[value]) {
                    this.meshes[value] = createMeshFromSource(source);
                }
                // temp solution until geom is not rendered from effect
                if (this.gui.debugDraw()[name]) {
                    this.helperGeom.push(...source.map(obj => {
                        const mesh = obj.clone();
                        // mesh.material = new THREE.MeshBasicMaterial({ 
                        //     color: 0xFF0000, 
                        //     wireframe: true, 
                        //     wireframeLinewidth: 3, 
                        //     transparent: true,
                        //     opacity: 0.25
                        // });
                        mesh.material = new three__WEBPACK_IMPORTED_MODULE_17__.MeshNormalMaterial();
                        // mesh.material = new THREE.MeshStandardMaterial({ map: this.deps.textures['skull.jpg'] });
                        return mesh;
                    }));
                    //     {
                    //         const color = 0xFFFFFF;
                    //         const intensity = 0.2;
                    //         const light = new THREE.AmbientLight(color, intensity);
                    //         this.helperGeom.push(light);
                    //     }
                    //     {
                    //         const color = 0xFFFFFF;
                    //         const intensity = 0.8;
                    //         const light = new THREE.PointLight(color, intensity, 10);
                    //         light.position.set(3, 3, 3);
                    //         this.helperGeom.push(light);
                    //     }
                }
                emitter.setTrimesh(name, this.meshes[value]);
            }
        }
    }
    createLights() {
        const emitter = this.state.emitter;
        const lights = [];
        for (let iPass = 0; iPass < this.passes.length; ++iPass) {
            const rendPass = this.passes[iPass];
            const emitPass = emitter.getPass(iPass);
            const passDesc = emitPass.getDesc();
            if (!rendPass.meshes) {
                console.assert(emitPass.getDesc().instanceName == "PartLight");
                // is light pass
                const instanceData = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.memoryToU8Array(emitPass.getData());
                for (let iPart = 0; iPart < emitPass.getNumRenderedParticles(); ++iPart) {
                    const pl = (0,_lib_fx_bytecode_VM_native__WEBPACK_IMPORTED_MODULE_2__.asNativeRaw)(instanceData.subarray(PartLightT.size * iPart, (iPart + 1) * PartLightT.size), PartLightT);
                    const ci = Math.max(...pl.color);
                    const c = Math.floor(pl.color[0] / ci * 255) | (Math.floor(pl.color[1] / ci * 255) << 8) | (Math.floor(pl.color[2] / ci * 255) << 16);
                    const light = new three__WEBPACK_IMPORTED_MODULE_17__.PointLight(c, 10, pl.radius, pl.attenuation == 0 ? 4 : pl.attenuation);
                    const helper = new three__WEBPACK_IMPORTED_MODULE_17__.PointLightHelper(light);
                    light.position.set(...pl.pos);
                    lights.push(light, helper);
                    // console.log(`${iPart}/${emitPass.getNumRenderedParticles()}`, partLight);
                }
                continue;
            }
        }
        return lights;
    }
    // update instance count for every pass geometry
    setGeometryInstanceCouts() {
        const emitter = this.state.emitter;
        for (let iPass = 0; iPass < this.passes.length; ++iPass) {
            const rendPass = this.passes[iPass];
            const emitPass = emitter.getPass(iPass);
            const passDesc = emitPass.getDesc();
            if (rendPass.instancedBuffer)
                rendPass.instancedBuffer.needsUpdate = true;
            rendPass.meshes?.forEach(mesh => {
                const geometry = mesh.geometry;
                if (passDesc.geometry === "line") {
                    geometry.setDrawRange(0, emitPass.getNumRenderedParticles());
                }
                else {
                    geometry.instanceCount = emitPass.getNumRenderedParticles();
                }
            });
            // emitPass.dump();
        }
    }
    beginFrame() {
        const emitter = this.state.emitter;
        const timeline = this.props.timeline;
        const controls = this.props.controls;
        const tech9 = this.props.emitter;
        const camera = this.camera;
        const viewport = this.mount;
        const deps = this.deps;
        const preset = this.gui.preset();
        if (!emitter) {
            return;
        }
        // IP: including textures
        this.uniformGroups.update9(camera, viewport, controls, timeline, deps, tech9);
        _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_14__.SingleUniforms.update(controls, timeline, deps, this.uniforms);
        // dedicated way to setup bytecode bundle resource
        // todo: generalize with uniforms?
        this.setupResources();
        const uniforms = prerecordUniforms(camera, timeline, controls, preset);
        if (!timeline.isStopped() && !timeline.isPaused()) {
            timeline.tick();
            emitter.simulate(uniforms);
        }
        emitter.prerender(uniforms);
        // do nothing if there is no sorting
        emitter.serialize(); // feed render buffer with instance data
        this.setGeometryInstanceCouts();
        this.helperGeom.push(...this.createLights());
        if (this.helperGeom.length)
            this.scene.add(...this.helperGeom);
        this.setState({
            nParticles: emitter.getNumParticles(),
            time: timeline.getConstants().elapsedTimeLevel.toFixed(2)
        });
        // emitter.dump();
        // do not call beginFrame() here (!)
        // super.beginFrame();
    }
    endFrame() {
        this.scene.remove(...this.helperGeom);
        this.helperGeom = [];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FxScene);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "JRfj":
/*!********************************************************!*\
  !*** ./src/sandbox/containers/playground/HDRScene.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dat.gui */ "2U48");
/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ "I2Sm");
/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ "CMPq");
/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ "gY7i");
/* harmony import */ var three_examples_jsm_postprocessing_SMAAPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/postprocessing/SMAAPass */ "6rN7");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var _ThreeScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ThreeScene */ "G13E");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









function dumpHdrParams(params) {
    Object.keys(params).forEach(prop => localStorage[prop] = params[prop]);
}
function size(div, pixelRatio) {
    return {
        width: (div.clientWidth * pixelRatio),
        height: (div.clientHeight * pixelRatio), // + 0.5) >>> 0,
    };
}
function restoreHdrParams() {
    const params = {
        bloom: true,
        toneMappingType: 'Linear',
        toneMappingExposure: 1.0,
        bloomStrength: 2.0,
        bloomThreshold: 1.0,
        bloomRadius: 1.0
    };
    params.bloom = (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isString)(localStorage.bloom) ? localStorage.bloom === 'true' : params.bloom;
    params.toneMappingType = localStorage.toneMappingType || 'ACESFilmic';
    params.toneMappingExposure = Number(localStorage.toneMappingExposure || params.toneMappingExposure);
    params.bloomThreshold = Number(localStorage.bloomThreshold || params.bloomThreshold);
    params.bloomStrength = Number(localStorage.bloomStrength || params.bloomStrength);
    params.bloomRadius = Number(localStorage.bloomRadius || params.bloomRadius);
    return params;
}
class HDRScene extends _ThreeScene__WEBPACK_IMPORTED_MODULE_3__["default"] {
    createRenderer(width, height) {
        const renderer = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true // screenshots
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        // renderer.outputEncoding = THREE.sRGBEncoding;
        // renderer.toneMapping = ReinhardToneMapping;
        // renderer.toneMapping = THREE.ACESFilmicToneMapping;
        return renderer;
    }
    createSceneControls(bloomPass, renderer) {
        const params = this.hdrParams;
        const gui = new dat_gui__WEBPACK_IMPORTED_MODULE_0__.GUI({ autoPlace: false });
        // gui.name = 'Tonemapping';
        dat_gui__WEBPACK_IMPORTED_MODULE_0__.GUI.TEXT_OPEN = 'Show Options';
        this.mount.appendChild(gui.domElement);
        gui.domElement.style.position = 'absolute';
        gui.domElement.style.bottom = '20px';
        let tonemap = gui.addFolder('tonemapping');
        tonemap.add(params, 'bloom').onChange(value => {
            dumpHdrParams(this.hdrParams);
        });
        tonemap.add(params, 'toneMappingExposure', 0.1, 2.0).onChange((value) => {
            renderer.toneMappingExposure = Math.pow(value, 4.0);
            dumpHdrParams(this.hdrParams);
        }).name('exposure');
        tonemap.add(params, 'bloomThreshold', 0.0, 1.0).onChange((value) => {
            bloomPass.threshold = Number(value);
            dumpHdrParams(this.hdrParams);
        });
        tonemap.add(params, 'bloomStrength', 0.0, 3.0).onChange((value) => {
            bloomPass.strength = Number(value);
            dumpHdrParams(this.hdrParams);
        });
        tonemap.add(params, 'bloomRadius', 0.0, 1.0).step(0.01).onChange((value) => {
            bloomPass.radius = Number(value);
            dumpHdrParams(this.hdrParams);
        });
        // tonemap.add(params, 'toneMappingType', [ "No", "Linear", "Reinhard", "Cineon", "ACESFilmic", "Custom" ])
        // .name('type').onChange((value) => {
        //     this.renderer.toneMapping = THREE[`${value}ToneMapping`];
        //     dumpHdrParams(this.hdrParams);
        // });
        tonemap.open();
        gui.close();
        return gui;
    }
    componentDidMount() {
        super.componentDidMount({ grid: true, fog: true });
        // this.scene.background = new THREE.Color(0x333333);
        // this.fog.color = new THREE.Color(0x333333);
        const scene = this.scene;
        const camera = this.camera;
        const renderer = this.renderer;
        const mount = this.mount;
        const pixelRatio = this.renderer.getPixelRatio();
        const { width, height } = size(mount, pixelRatio);
        const renderScene = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);
        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(width, height), 1.5, 0.4, 0.85);
        const smaaPass = new three_examples_jsm_postprocessing_SMAAPass__WEBPACK_IMPORTED_MODULE_7__.SMAAPass(width, height);
        // const fxaaPass = new ShaderPass(FXAAShader);
        // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / width;
        // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / height;
        this.hdrParams = restoreHdrParams();
        this.renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_4__[`${this.hdrParams.toneMappingType}ToneMapping`];
        renderer.toneMappingExposure = this.hdrParams.toneMappingExposure;
        bloomPass.threshold = this.hdrParams.bloomThreshold;
        bloomPass.strength = this.hdrParams.bloomStrength;
        bloomPass.radius = this.hdrParams.bloomRadius;
        const parameters = {
            minFilter: three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter,
            magFilter: three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter,
            format: three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat,
            type: three__WEBPACK_IMPORTED_MODULE_4__.FloatType
        };
        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderTarget(width, height, parameters);
        this.composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_8__.EffectComposer(renderer, renderTarget);
        const composer = this.composer;
        composer.setPixelRatio(pixelRatio);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        // composer.addPass(new ShaderPass(GammaCorrectionShader));
        composer.addPass(smaaPass);
        // composer.addPass(fxaaPass);
        this.hdrControls = this.createSceneControls(bloomPass, renderer);
    }
    renderFrame() {
        if (this.hdrParams.bloom) {
            this.composer.render();
        }
        else {
            super.renderFrame();
        }
    }
    onWindowResize() {
        super.onWindowResize(); // << update renderer size and camera aspect
        const { mount, renderer } = this;
        const { width, height } = size(mount, renderer.getPixelRatio());
        this.composer.setSize(width, height);
        // todo: change resolution of bloom pass here?
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_2__["default"]
], HDRScene.prototype, "onWindowResize", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HDRScene);


/***/ }),

/***/ "D8bm":
/*!**********************************************************!*\
  !*** ./src/sandbox/containers/playground/Playground.tsx ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/IInstruction */ "vIQR");
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/path/path */ "U50j");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/reducers */ "YJtB");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! semantic-ui-react */ "g3Zx");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! semantic-ui-react */ "hML2");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! semantic-ui-react */ "OXt0");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! semantic-ui-react */ "fbB6");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! semantic-ui-react */ "WUUJ");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! semantic-ui-react */ "35Nk");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! semantic-ui-react */ "c9HL");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! semantic-ui-react */ "3GrG");
/* harmony import */ var _PartView__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../PartView */ "lF6j");
/* harmony import */ var _FxScene__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./FxScene */ "ZhYP");
/* harmony import */ var _Technique9Scene__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Technique9Scene */ "yp34");
/* harmony import */ var _Technique11Scene__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Technique11Scene */ "tUQ4");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__, _FxScene__WEBPACK_IMPORTED_MODULE_11__, _Technique9Scene__WEBPACK_IMPORTED_MODULE_12__, _Technique11Scene__WEBPACK_IMPORTED_MODULE_13__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__, _FxScene__WEBPACK_IMPORTED_MODULE_11__, _Technique9Scene__WEBPACK_IMPORTED_MODULE_12__, _Technique11Scene__WEBPACK_IMPORTED_MODULE_13__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:typedef */
/* tslint:disable:forin */
/* tslint:disable:no-for-in */
/* tslint:disable:newline-per-chained-call */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};















const ipcRenderer = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__.isElectron() ? (__webpack_require__(/*! electron */ "vCZ/").ipcRenderer) : null;
function downloadByteBuffer(data, fileName, mimeType) {
    downloadBlob(new Blob([data], { type: mimeType }), fileName);
}
;
function downloadBlob(blob, fileName) {
    let url;
    url = window.URL.createObjectURL(blob);
    downloadURL(url, fileName);
    setTimeout(() => window.URL.revokeObjectURL(url), 1000);
}
;
function downloadURL(data, fileName) {
    let a;
    a = document.createElement('a');
    a.href = data;
    a.download = fileName;
    document.body.appendChild(a);
    a.style = 'display: none';
    a.click();
    a.remove();
}
;
// TODO: remove it
const threeStylesHotfix = {
    height: 'calc(100vh - 245px - 1em)',
    position: 'relative',
    left: '0',
    right: '0',
    margin: '1em -20px -20px -20px'
};
const textAlignCenter = {
    textAlign: 'center'
};
class Playground extends react__WEBPACK_IMPORTED_MODULE_8__.Component {
    constructor(props) {
        super(props);
        this.techniqueName = null;
        // techniqueType: string = null;
        this.techniqueID = null;
        this.debugView = null;
        this.debugViewChannel = new BroadcastChannel(_PartView__WEBPACK_IMPORTED_MODULE_10__["default"].CHANNEL); // consumed by PartView.tsx
        this.debugViewer = null;
        this.canvasRef = null;
        this.debugViewChannel.onmessage = (event) => {
            switch (event.data) {
                case _PartView__WEBPACK_IMPORTED_MODULE_10__["default"].CONNECT_EVENT:
                    this.onParticleDebugViewerConnected();
                    break;
                case _PartView__WEBPACK_IMPORTED_MODULE_10__["default"].DISCONNECT_EVENT:
                    this.onParticleDebugViewerDisconnected();
                    break;
                case _PartView__WEBPACK_IMPORTED_MODULE_10__["default"].UPDATE_EVENT:
                    this.onParticleDebugViewerUpdate();
                    break;
            }
        };
    }
    // static getDerivedStateFromProps(props: IPlaygroundProps, state: IPlaygroundState) {
    //     return null;
    // }
    handlePlayClick() {
        const props = this.props;
        if (props.playground.technique) {
            props.playground.timeline.unpause();
            this.forceUpdate();
        }
    }
    handlePauseClick() {
        const props = this.props;
        if (props.playground.technique) {
            props.playground.timeline.pause();
            this.forceUpdate();
        }
    }
    handleResetClick() {
        const props = this.props;
        const tech = props.playground.technique;
        if (props.playground.technique) {
            props.playground.timeline.stop();
            props.playground.timeline.start();
            this.forceUpdate();
        }
        // todo: add reset support for materials
        if (this.ranAsEmitter()) {
            tech.reset();
        }
    }
    async handleAutosaveClick() {
        this.props.actions.setAutosave(!this.props.playground.autosave);
    }
    async handleDownloadDataClick(savePackedData = true, saveScreenshot = true) {
        if (savePackedData) {
            this.props.actions.saveFileAs();
        }
        if (saveScreenshot) {
            // hack to get global webgl/three.js canvas (from ThreeScene.ts)
            const canvas = document.getElementById('playground-main-canvas');
            const exportName = _lib_path_path__WEBPACK_IMPORTED_MODULE_1__.parse(this.props.sourceFile.uri);
            exportName.ext = "jpeg";
            // const resizedCanvas = document.createElement("canvas") as HTMLCanvasElement;
            // const resizedContext = resizedCanvas.getContext("2d");
            // resizedCanvas.height = 512;
            // resizedCanvas.width = 512;
            // resizedContext.drawImage(canvas, 0, 0, resizedCanvas.width, resizedCanvas.height);
            // downloadURL(resizedCanvas.toDataURL('image/jpeg'), exportName.basename);
            downloadURL(canvas.toDataURL('image/jpeg'), exportName.basename);
        }
    }
    async handleParticleDebugView() {
        if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__.isElectron()) {
            // todo: not tested!
            if (this.debugView && !this.debugView.closed) {
                this.debugView.focus();
                console.log('view already exist');
                return;
            }
            this.debugView = window.open('./part-view.html');
        }
        else {
            ipcRenderer?.send('show-part-view-debug');
        }
        this.dumpParticles();
    }
    onParticleDebugViewerUpdate() {
        this.dumpParticles();
    }
    onParticleDebugViewerConnected() {
        let emitter = this.props.playground.technique;
        this.debugViewer = emitter.createDebugViewer();
        this.dumpParticles();
    }
    onParticleDebugViewerDisconnected() {
        this.debugViewer = null;
    }
    dumpParticles() {
        if (this.debugViewer) {
            this.debugViewer.dump();
            this.debugViewChannel.postMessage(this.debugViewer.readParticlesJSON());
        }
    }
    pickEffect(active) {
        this.props.actions.selectEffect(active);
    }
    shouldComponentUpdate(nextProps) {
        return nextProps.playground.exportName !== this.props.playground.exportName ||
            nextProps.playground.autosave !== this.props.playground.autosave ||
            nextProps.playground.technique !== this.props.playground.technique ||
            (this.props.playground.technique && this.techniqueName !== this.props.playground.technique.getName());
    }
    UNSAFE_componentWillUpdate(nextProps, nextState) {
        const nextTechnique = nextProps.playground.technique;
        const prevTechnique = this.props.playground.technique;
        const bEffectChanged = this.techniqueID !== nextProps.sourceFile.uri;
        if (bEffectChanged) {
            this.dropSnapshot();
            return;
        }
        // do snapshot if next effect is broken
        if (!nextTechnique && prevTechnique) {
            this.makeSnapshot();
        }
    }
    backupProps() {
        const technique = this.props.playground.technique;
        const sourceFile = this.props.sourceFile;
        if (technique) {
            this.techniqueName = technique.getName();
            // this.techniqueType = technique.getType();
        }
        else {
            this.techniqueName = null;
        }
        this.techniqueID = sourceFile.uri;
    }
    componentDidUpdate() {
        this.backupProps();
    }
    componentDidMount() {
        this.backupProps();
    }
    /** @deprecated */
    ranAsMaterial() {
        return this.props.playground.technique?.getType() === 'material';
    }
    ranAsEmitter() {
        return this.props.playground.technique?.getType() === 'emitter';
    }
    ranAsTechnique11() {
        return this.props.playground.technique?.getType() === 'technique11';
    }
    dropSnapshot() {
        this.canvasSnapshot = null;
        console.log(`Snapshot has been dropped.`);
    }
    makeSnapshot() {
        if (!this.canvasRef) {
            return;
        }
        const content = this.canvasRef.toDataURL('image/png', 1);
        const w = this.canvasRef.clientWidth;
        const h = this.canvasRef.clientHeight;
        this.canvasSnapshot = { w, h, content };
        console.log(`Snapshot has been made.`);
    }
    render() {
        const props = this.props;
        const playground = props.playground;
        const technique = playground.technique;
        const timeline = playground.timeline;
        const controls = playground.controls;
        const snapshot = this.canvasSnapshot;
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_6__.getScope)(props.sourceFile);
        /** @deprecated */
        const list = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__.filterTechniques)(scope);
        const list11 = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__.filterTechniques11)(scope);
        const active = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_5__.getEmitterName)(playground);
        return (react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", null,
            !list.length && !list11.length &&
                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"], { info: true, style: textAlignCenter },
                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"].Content, null, "No effects found :/")),
            (technique || 1) &&
                react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", null,
                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"], { bulleted: true, horizontal: true },
                        list.map(fx => (react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"].Item, { key: `li-${fx.name}`, disabled: (fx.type === _lib_idl_IInstruction__WEBPACK_IMPORTED_MODULE_0__.ETechniqueType.k_PartFx && !fx.isValid()), as: (fx.name === active ? 'b' : 'a'), onClick: () => this.pickEffect(fx.name) }, fx.name))),
                        list11.map(fx => (react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_16__["default"], { inverted: true, key: `li-${fx.name}`, content: react__WEBPACK_IMPORTED_MODULE_8__.createElement("span", null, fx.name), trigger: react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"].Item, { disabled: !fx.isValid(), as: (fx.name === active ? 'b' : 'a'), onClick: () => this.pickEffect(fx.name) }, fx.name.substring(0, Math.min(fx.name.length, 10)) + (fx.name.length > 10 ? `..` : ``)) })))),
                    react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", null,
                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__["default"], { verticalAlign: "middle" },
                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__["default"].Row, null,
                                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__["default"].Column, { width: 6 },
                                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"].Group, { compact: true },
                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_19__["default"], { className: 'playback pause' }), color: (timeline.isPaused() ? 'black' : null), disabled: timeline.isPaused(), onClick: this.handlePauseClick }),
                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_19__["default"], { className: 'sync' }), onClick: this.handleResetClick }),
                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_19__["default"], { className: 'playback play' }), color: (!timeline.isPaused() ? 'black' : null), disabled: !timeline.isPaused(), onClick: this.handlePlayClick }))),
                                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_17__["default"].Column, { width: 10 },
                                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__["default"], { unstackable: true, basic: 'very' },
                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__["default"].Body, null,
                                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__["default"].Row, null,
                                                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__["default"].Cell, { collapsing: true, style: { width: '100%', textAlign: 'right' } },
                                                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_16__["default"], { content: playground.exportName || '[save file manually for the first time]', trigger: react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_21__["default"], { style: { marginRight: '-10px' }, label: `auto`, checked: playground.autosave, disabled: !_sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__.isElectron() || !playground.exportName, onClick: this.handleAutosaveClick }) })),
                                                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_20__["default"].Cell, null,
                                                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"].Group, { compact: true },
                                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"]
                                                        // save packed version only
                                                        , { 
                                                            // save packed version only
                                                            onClick: this.handleDownloadDataClick.bind(this, true, false) }, "export"),
                                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"], { animated: 'vertical', onClick: this.handleParticleDebugView },
                                                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"].Content, { visible: true }, "debug"),
                                                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"].Content, { hidden: true }, "view")),
                                                        react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_18__["default"]
                                                        // save screenshot only
                                                        , { 
                                                            // save screenshot only
                                                            onClick: this.handleDownloadDataClick.bind(this, false, true) }, "screenshot"))))))))),
                        this.ranAsEmitter() &&
                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(_FxScene__WEBPACK_IMPORTED_MODULE_11__["default"], { style: threeStylesHotfix, emitter: technique, timeline: timeline, controls: controls, canvasRef: (canvas) => this.canvasRef = canvas }),
                        this.ranAsMaterial() &&
                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(_Technique9Scene__WEBPACK_IMPORTED_MODULE_12__["default"], { style: threeStylesHotfix, timeline: timeline, controls: controls, material: technique, canvasRef: (canvas) => this.canvasRef = canvas }),
                        this.ranAsTechnique11() &&
                            react__WEBPACK_IMPORTED_MODULE_8__.createElement(_Technique11Scene__WEBPACK_IMPORTED_MODULE_13__["default"], { style: threeStylesHotfix, timeline: timeline, controls: controls, technique: technique, canvasRef: (canvas) => this.canvasRef = canvas }),
                        !this.ranAsEmitter() && !this.ranAsTechnique11() && !this.ranAsMaterial() && snapshot &&
                            react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", { style: {
                                    backgroundImage: `linear-gradient(rgba(0, 0, 0, 0.63), rgba(0, 0, 0, 0.623)), url(${snapshot.content})`,
                                    backgroundAttachment: 'fixed',
                                    backgroundPosition: 'center',
                                    backgroundRepeat: 'no-repeat',
                                    backgroundSize: 'cover',
                                    filter: 'saturate(0)',
                                    height: 'calc(100vh - 245px - 1em)',
                                    position: 'relative',
                                    left: '0',
                                    right: '0',
                                    margin: '1em -20px -20px -20px',
                                    width: 'calc(100% + 40px)',
                                } })))));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handlePlayClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handlePauseClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handleResetClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handleAutosaveClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handleDownloadDataClick", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "handleParticleDebugView", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "onParticleDebugViewerUpdate", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_7__["default"]
], Playground.prototype, "onParticleDebugViewerConnected", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_redux__WEBPACK_IMPORTED_MODULE_9__.connect)((0,_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__.mapProps)(_sandbox_reducers__WEBPACK_IMPORTED_MODULE_4__.getCommon), (0,_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.mapActions)(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.playground))(Playground));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "tUQ4":
/*!****************************************************************!*\
  !*** ./src/sandbox/containers/playground/Technique11Scene.tsx ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/SLDocument */ "7Nqm");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/translators/GlslEmitter */ "elBL");
/* harmony import */ var _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/idl/bytecode */ "Evaj");
/* harmony import */ var _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/idl/ITechnique9 */ "UHT2");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! semantic-ui-react */ "GWf2");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ "Qn1W");
/* harmony import */ var _HDRScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HDRScene */ "JRfj");
/* harmony import */ var _utils_deps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/deps */ "KeJm");
/* harmony import */ var _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/GroupedUniforms */ "KPdV");
/* harmony import */ var _utils_gui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/gui */ "eK+6");
/* harmony import */ var _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/SingleUniforms */ "O6BO");
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_deps__WEBPACK_IMPORTED_MODULE_8__, _utils_gui__WEBPACK_IMPORTED_MODULE_10__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_12__]);
([_utils_deps__WEBPACK_IMPORTED_MODULE_8__, _utils_gui__WEBPACK_IMPORTED_MODULE_10__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_12__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
















const progressStyleFix = {
    background: '#eee',
    borderRadius: '0'
};
const makeCRCTable = () => {
    let c;
    let crcTable = [];
    for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};
const CRC_TABLE = makeCRCTable();
const crc32 = (str) => {
    let crc = 0 ^ (-1);
    for (let i = 0; i < str.length; i++) {
        crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ str.charCodeAt(i)) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
};
function calcPsoHash(pso) {
    const dss = pso.depthStencilState;
    return crc32(`${pso.vs?.name}:${pso.vs?.args.map(a => `${a.value}`)}:` +
        `${pso.ps?.name}:${pso.ps?.args.map(a => `${a.value}`)}:` +
        `${dss?.DepthEnable}:${dss?.DepthFunc}:${dss?.DepthWriteMask}`);
}
function threeDepthFuncFromDSState(depthStencilState) {
    switch (depthStencilState.DepthFunc) {
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_Always: return three__WEBPACK_IMPORTED_MODULE_13__.AlwaysDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_Equal: return three__WEBPACK_IMPORTED_MODULE_13__.EqualDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_Greater: return three__WEBPACK_IMPORTED_MODULE_13__.GreaterDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_GreaterEqual: return three__WEBPACK_IMPORTED_MODULE_13__.GreaterEqualDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_Less: return three__WEBPACK_IMPORTED_MODULE_13__.LessDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_LessEqual: return three__WEBPACK_IMPORTED_MODULE_13__.LessEqualDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_Never: return three__WEBPACK_IMPORTED_MODULE_13__.NeverDepth;
        case _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EComparisonFunc.k_NotEqual: return three__WEBPACK_IMPORTED_MODULE_13__.NotEqualDepth;
    }
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
    return three__WEBPACK_IMPORTED_MODULE_13__.LessEqualDepth;
}
const scanCbuffer = (sharedCbufs, bundleCbs, usage) => {
    for (let { name, slot, size, fields } of bundleCbs) {
        // skip same name buffers
        const cbuf = sharedCbufs[`${name}`] ||= {
            name: `${name}`,
            slot,
            size,
            usage,
            fields: fields.map(({ name, semantic, size, padding, type: { length } }) => ({
                name: `${name}`,
                semantic: `${semantic || name}`,
                size,
                padding,
                length
            }))
        };
        cbuf.usage |= usage;
    }
};
class Technique11Scene extends _HDRScene__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor(props) {
        super(props);
        this.params = { model: 'probe' };
        this.graphicsPso = {
            vs: null,
            ps: null,
            depthStencilState: null
        };
        this.materials = {}; // by pso hash
        this.cbuffers = {}; // by pso hash
        this.uniformGroups = {};
        this.uniforms = {};
        this.gui = new _utils_gui__WEBPACK_IMPORTED_MODULE_10__.GuiView;
        this.deps = new _utils_deps__WEBPACK_IMPORTED_MODULE_8__.Deps;
        this.state = {
            // todo
            ...this.stateInitials()
        };
    }
    reloadModel() {
        const loader = new three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_14__.OBJLoader();
        const params = this.params;
        const passCount = this.props.technique.getPassCount();
        const scene = this.scene;
        this.scene.remove(...(this.groups || []));
        switch (params.model) {
            case 'plane':
                {
                    const geom = new three__WEBPACK_IMPORTED_MODULE_13__.PlaneGeometry(2, 2);
                    const mesh = new three__WEBPACK_IMPORTED_MODULE_13__.Mesh(geom, null);
                    const group = new three__WEBPACK_IMPORTED_MODULE_13__.Group();
                    group.add(mesh);
                    this.groups = [group];
                    scene.add(...this.groups);
                    return;
                }
                break;
        }
        loader.load(`${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_12__.ASSETS_PATH}/models/${params.model}.obj`, (group) => {
            this.groups = Array(passCount).fill(null).map(x => group.clone(true));
            this.groups.forEach(g => {
                g.children.forEach(c => {
                    const m = c;
                    const g = m.geometry;
                    // prepareTrimesh(g);
                });
            });
            scene.add(...this.groups);
        }, (xhr) => {
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        }, (error) => {
            console.log('An error happened');
            this.groups = null;
        });
    }
    setVertexShader(pass, shader) {
        if (!shader) {
            this.graphicsPso.vs = null;
            return;
        }
        this.graphicsPso.vs = shader;
    }
    setPixelShader(pass, shader) {
        if (!shader) {
            this.graphicsPso.ps = null;
            return;
        }
        this.graphicsPso.ps = shader;
    }
    setGeometryShader(pass, shader) {
        if (!shader) {
            // todo: reset shader
            return;
        }
        // console.log(pass.shaders.find(({ entryName }) => { return entryName === shader.name }));
    }
    setDepthStencilState(pass, state, stencilRef) {
        // todo: apply stencilRef ?
        this.graphicsPso.depthStencilState = state;
    }
    bindTechnique(tech) {
        const passNum = tech.getPassCount();
        for (let i = 0; i < passNum; ++i) {
            const pass = tech.getPass(i);
            const render = pass.render;
            for (const { name, id } of render.getExterns()) {
                switch (name) {
                    case 'SetVertexShader':
                        render.setExtern(id, this.setVertexShader.bind(this, pass));
                        break;
                    case 'SetPixelShader':
                        render.setExtern(id, this.setPixelShader.bind(this, pass));
                        break;
                    case 'SetGeometryShader':
                        render.setExtern(id, this.setGeometryShader.bind(this, pass));
                        break;
                    case 'SetDepthStencilState':
                        render.setExtern(id, this.setDepthStencilState.bind(this, pass));
                        break;
                }
            }
        }
    }
    /** @deprecated */
    unbindTechnique(tech) {
    }
    async componentDidMount() {
        super.componentDidMount();
        this.gui.mount(this.mount);
        // hack
        this.hdrControls.add(this.params, 'model', ['probe', 'cube', 'plane']).onChange((value) => {
            this.reloadModel();
        });
        this.reloadModel();
        this.bindTechnique(this.props.technique);
        const controls = this.props.controls;
        const doLoadTexture = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('texture2d');
        const doLoadMeshes = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('mesh');
        this.deps.resolve(doLoadTexture, doLoadMeshes);
        this.start();
    }
    shouldComponentUpdate(nextProps, nexState) {
        return this.props.technique !== nextProps.technique;
    }
    componentDidUpdate(prevProps, prevState) {
        super.componentDidUpdate?.(prevProps, prevState);
        const props = this.props;
        const passNum = props.technique.getPassCount();
        ;
        this.scene.remove(...this.groups);
        if (passNum > 0) {
            this.groups = Array(passNum).fill(null).map(x => this.groups[0].clone(true) || null);
            this.scene.add(...this.groups);
        }
        this.unbindTechnique(prevProps.technique);
        this.bindTechnique(props.technique);
    }
    findCbuffers(csh, shaders) {
        return shaders.find(sh => sh.entryName == csh.name).cbuffers;
    }
    async precompileShader(csh, shaders) {
        const sh = shaders.find(sh => sh.entryName == csh.name);
        console.assert(sh, 'cannot find requested shader ?!');
        const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)('://raw', sh.code);
        const slDocument = await (0,_lib_fx_SLDocument__WEBPACK_IMPORTED_MODULE_1__.createSLDocument)(textDocument);
        const scope = slDocument.root.scope;
        const ctx = new _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_3__.GLSLContext({ mode: csh.ver.substring(0, 2) });
        const codeGLSL = _lib_fx_translators_GlslEmitter__WEBPACK_IMPORTED_MODULE_3__.GLSLEmitter.translate(scope.findFunction(csh.name, null), ctx);
        // console.log(sh.code);
        // console.log(codeGLSL);
        return codeGLSL;
    }
    createUniforms(csh, shaders) {
        const sh = shaders.find(sh => sh.entryName == csh.name);
    }
    async beginFrame() {
        const { timeline, controls, technique } = this.props;
        const { deps, camera, mount } = this;
        const passNum = technique.getPassCount();
        for (let i = 0; i < passNum; ++i) {
            const { render, shaders } = technique.getPass(i);
            const psoHashPrev = calcPsoHash(this.graphicsPso);
            if (!timeline.isStopped() && !timeline.isPaused()) {
                render.play();
            }
            const psoHash = calcPsoHash(this.graphicsPso);
            if (!this.materials[psoHash]) {
                const { depthStencilState, vs, ps } = this.graphicsPso;
                // merge VS & PS constant buffer into shared list 
                // it's guaranteed by translator that buffers with the same name are the same
                const cbufs = {};
                scanCbuffer(cbufs, this.findCbuffers(vs, shaders), _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__.EUsage.k_Vertex);
                scanCbuffer(cbufs, this.findCbuffers(ps, shaders), _lib_idl_ITechnique9__WEBPACK_IMPORTED_MODULE_5__.EUsage.k_Pixel);
                const cbuffers = Object.values(cbufs);
                const ugroups = _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_9__.GroupedUniforms.create(cbuffers);
                const uniforms = _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_11__.SingleUniforms.create(controls, deps);
                const vertexShader = await this.precompileShader(vs, shaders);
                const fragmentShader = await this.precompileShader(ps, shaders);
                const mat = new three__WEBPACK_IMPORTED_MODULE_13__.RawShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    uniforms,
                    blending: three__WEBPACK_IMPORTED_MODULE_13__.NormalBlending,
                    transparent: false,
                    depthTest: depthStencilState.DepthEnable,
                    depthWrite: depthStencilState.DepthWriteMask == _lib_idl_bytecode__WEBPACK_IMPORTED_MODULE_4__.EDepthWriteMask.k_All,
                    depthFunc: threeDepthFuncFromDSState(depthStencilState)
                });
                mat.uniformsGroups = ugroups;
                this.materials[psoHash] = mat;
                this.cbuffers[psoHash] = cbuffers;
                this.uniformGroups[psoHash] = ugroups;
                this.uniforms[psoHash] = uniforms;
                console.log(`New PSO <${psoHash}> has been created.`);
            }
            if (psoHash !== psoHashPrev) {
                console.log(`switch pso <${psoHashPrev}> => <${psoHash}>`);
                this.gui.remove();
                this.gui.create(controls);
            }
            const groups = this.uniformGroups[psoHash];
            const cbuffers = this.cbuffers[psoHash];
            const uniforms = this.uniforms[psoHash];
            if (groups) {
                _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_9__.GroupedUniforms.update(camera, mount, controls, timeline, deps, groups, cbuffers);
                _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_11__.SingleUniforms.update(controls, timeline, deps, uniforms);
            }
            // todo: do not change material every frame (!)
            {
                const material = this.materials[psoHash];
                const group = this.groups?.[i];
                if (group) {
                    for (const object of group.children) {
                        const mesh = object;
                        mesh.material = material;
                        // IP: hack to support default geom layout like:
                        // struct Geometry {
                        //  float3 position: POSITION0;
                        //  float3 normal: NORMAL0;
                        //  float2 uv: TEXCOORD0;
                        // };
                        // console.log(mesh.geometry.attributes);
                        // sandbox
                        mesh.geometry.attributes['a_position0'] = mesh.geometry.attributes.position;
                        mesh.geometry.attributes['a_normal0'] = mesh.geometry.attributes.normal;
                        mesh.geometry.attributes['a_texcoord0'] = mesh.geometry.attributes.uv;
                        mesh.geometry.attributes['a_position'] = mesh.geometry.attributes.position;
                        mesh.geometry.attributes['a_normal'] = mesh.geometry.attributes.normal;
                        mesh.geometry.attributes['a_texcoord'] = mesh.geometry.attributes.uv;
                        // husky
                        mesh.geometry.attributes['a_v_position'] = mesh.geometry.attributes.position;
                        mesh.geometry.attributes['a_v_normal'] = mesh.geometry.attributes.normal;
                        mesh.geometry.attributes['a_v_texcoord0'] = mesh.geometry.attributes.uv;
                    }
                }
            }
        }
        // promote timeline
        super.beginFrame();
    }
    endFrame() {
        // todo
    }
    render() {
        return (react__WEBPACK_IMPORTED_MODULE_6__.createElement("div", { style: this.props.style, ref: (mount) => { this.mount = mount; } },
            react__WEBPACK_IMPORTED_MODULE_6__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_15__["default"], { value: 100, total: 100, attached: 'top', size: 'medium', indicating: true, style: progressStyleFix })));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Technique11Scene);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "yp34":
/*!***************************************************************!*\
  !*** ./src/sandbox/containers/playground/Technique9Scene.tsx ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ "Qn1W");
/* harmony import */ var _lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/ERenderStates */ "Y4FD");
/* harmony import */ var _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/idl/ERenderStateValues */ "HS1/");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var _HDRScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HDRScene */ "JRfj");
/* harmony import */ var _utils_deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/deps */ "KeJm");
/* harmony import */ var _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/GroupedUniforms */ "KPdV");
/* harmony import */ var _utils_gui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/gui */ "eK+6");
/* harmony import */ var _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/SingleUniforms */ "O6BO");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_deps__WEBPACK_IMPORTED_MODULE_3__, _utils_gui__WEBPACK_IMPORTED_MODULE_5__]);
([_utils_deps__WEBPACK_IMPORTED_MODULE_3__, _utils_gui__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);









/** @deprecated */
class Technique9Scene extends _HDRScene__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(props) {
        super(props);
        this.params = { model: 'probe' };
        this.gui = new _utils_gui__WEBPACK_IMPORTED_MODULE_5__.GuiView;
        this.uniformGroups = new _utils_GroupedUniforms__WEBPACK_IMPORTED_MODULE_4__.GroupedUniforms;
        this.deps = new _utils_deps__WEBPACK_IMPORTED_MODULE_3__.Deps;
        this.state = {
            // todo
            ...this.stateInitials()
        };
    }
    reloadModel() {
        const loader = new three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_7__.OBJLoader();
        const params = this.params;
        const passCount = this.props.material.getPassCount();
        const scene = this.scene;
        this.scene.remove(...(this.groups || []));
        switch (params.model) {
            case 'plane':
                {
                    const geom = new three__WEBPACK_IMPORTED_MODULE_8__.PlaneGeometry(2, 2);
                    const mesh = new three__WEBPACK_IMPORTED_MODULE_8__.Mesh(geom, null);
                    const group = new three__WEBPACK_IMPORTED_MODULE_8__.Group();
                    group.add(mesh);
                    this.groups = [group];
                    scene.add(...this.groups);
                    this.reloadMaterial();
                    return;
                }
                break;
        }
        loader.load(`./assets/models/${params.model}.obj`, (group) => {
            this.groups = Array(passCount).fill(null).map(x => group.clone(true));
            this.groups.forEach(g => {
                g.children.forEach(c => {
                    const m = c;
                    const g = m.geometry;
                    // prepareTrimesh(g);
                });
            });
            scene.add(...this.groups);
            this.reloadMaterial();
        }, (xhr) => {
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        }, (error) => {
            console.log('An error happened');
            this.groups = null;
        });
    }
    componentDidMount() {
        super.componentDidMount();
        this.gui.mount(this.mount);
        this.gui.create(this.props.controls);
        this.hdrControls.add(this.params, 'model', ['probe', 'cube', 'plane']).onChange((value) => {
            this.reloadModel();
        });
        this.uniforms = _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_6__.SingleUniforms.create(this.props.controls, this.deps);
        this.uniformGroups.create9(this.props.material);
        this.reloadModel();
        this.start();
    }
    shouldComponentUpdate(nextProps, nexState) {
        return this.props.material !== nextProps.material;
    }
    componentDidUpdate(prevProps, prevState) {
        super.componentDidUpdate(prevProps, prevState);
        this.gui.create(this.props.controls);
        const passCount = this.props.material.getPassCount();
        this.scene.remove(...this.groups);
        if (passCount > 0) {
            this.groups = Array(passCount).fill(null).map(x => this.groups[0].clone(true) || null);
            this.scene.add(...this.groups);
        }
        this.reloadMaterial();
    }
    reloadMaterial() {
        const groups = this.groups;
        const controls = this.props.controls;
        const doLoadTexture = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('texture2d');
        const doLoadMeshes = Object.values(controls?.controls).map(ctrl => ctrl.type).includes('mesh');
        this.deps.resolve(doLoadTexture, doLoadMeshes);
        this.uniformGroups.create9(this.props.material); // hack to avoid error: GL_INVALID_OPERATION: It is undefined behaviour to use a uniform buffer that is too small.
        for (let p = 0; p < this.props.material.getPassCount(); ++p) {
            const group = groups[p];
            const { vertexShader, pixelShader, renderStates } = this.props.material.getPass(p).getDesc();
            const uniforms = this.uniforms;
            const material = new three__WEBPACK_IMPORTED_MODULE_8__.RawShaderMaterial({
                uniforms,
                vertexShader: vertexShader,
                fragmentShader: pixelShader,
                blending: three__WEBPACK_IMPORTED_MODULE_8__.NormalBlending,
                transparent: false,
                depthTest: true
            });
            material.uniformsGroups = this.uniformGroups.data()[p];
            if (renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.ZENABLE]) {
                material.depthTest = renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.ZENABLE] === _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__.ERenderStateValues.TRUE;
            }
            if (renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.BLENDENABLE]) {
                material.transparent = renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.BLENDENABLE] === _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__.ERenderStateValues.TRUE;
            }
            if (renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.CULLFACE]) {
                switch (renderStates[_lib_idl_ERenderStates__WEBPACK_IMPORTED_MODULE_0__.ERenderStates.CULLFACE]) {
                    case _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__.ERenderStateValues.FRONT:
                        material.side = three__WEBPACK_IMPORTED_MODULE_8__.FrontSide;
                        break;
                    case _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__.ERenderStateValues.BACK:
                        material.side = three__WEBPACK_IMPORTED_MODULE_8__.BackSide;
                        break;
                    case _lib_idl_ERenderStateValues__WEBPACK_IMPORTED_MODULE_1__.ERenderStateValues.FRONT_AND_BACK:
                        material.side = three__WEBPACK_IMPORTED_MODULE_8__.DoubleSide;
                        break;
                }
            }
            for (const object of group.children) {
                const mesh = object;
                mesh.material = material;
                // IP: hack to support default geom layout like:
                // struct Geometry {
                //  float3 position: POSITION0;
                //  float3 normal: NORMAL0;
                //  float2 uv: TEXCOORD0;
                // };
                // console.log(mesh.geometry.attributes);
                // sandbox
                mesh.geometry.attributes['a_position0'] = mesh.geometry.attributes.position;
                mesh.geometry.attributes['a_normal0'] = mesh.geometry.attributes.normal;
                mesh.geometry.attributes['a_texcoord0'] = mesh.geometry.attributes.uv;
                // husky
                mesh.geometry.attributes['a_v_position'] = mesh.geometry.attributes.position;
                mesh.geometry.attributes['a_v_normal'] = mesh.geometry.attributes.normal;
                mesh.geometry.attributes['a_v_texcoord0'] = mesh.geometry.attributes.uv;
            }
        }
    }
    beginFrame() {
        const { timeline, controls, material } = this.props;
        const { deps, camera, mount } = this;
        _utils_SingleUniforms__WEBPACK_IMPORTED_MODULE_6__.SingleUniforms.update(controls, timeline, deps, this.uniforms);
        this.uniformGroups.update9(camera, mount, controls, timeline, deps, material);
        super.beginFrame();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Technique9Scene);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "G13E":
/*!**********************************************************!*\
  !*** ./src/sandbox/containers/playground/ThreeScene.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _three_ts_orbit_controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @three-ts/orbit-controls */ "izR9");
/* harmony import */ var _three_ts_orbit_controls__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_three_ts_orbit_controls__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var autobind_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! autobind-decorator */ "nt2h");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "y9Bw");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class ThreeScene extends react__WEBPACK_IMPORTED_MODULE_3__.Component {
    constructor() {
        super(...arguments);
        this.frames = 0; // fps stats
        this.prevTime = 0; // fps stats
        this.start = () => {
            if (!this.frameId) {
                this.frameId = requestAnimationFrame(this.animate);
            }
        };
        this.stop = () => {
            cancelAnimationFrame(this.frameId);
        };
    }
    stateInitials() {
        return {
            fps: { min: 0, max: 0, value: 0 }
        };
    }
    componentDidMount({ grid, fog } = { grid: true, fog: true }) {
        const width = this.mount.clientWidth;
        const height = this.mount.clientHeight;
        this.scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();
        this.scene.background = new three__WEBPACK_IMPORTED_MODULE_4__.Color(0xCCCCCC);
        this.camera = this.createCamera(width, height);
        this.fog = null;
        if (fog) {
            const color = 0xCCCCCC; // white
            this.fog = new three__WEBPACK_IMPORTED_MODULE_4__.FogExp2(color, 0.035);
        }
        this.scene.fog = this.fog;
        this.renderer = this.createRenderer(width, height);
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.domElement.id = "playground-main-canvas";
        // FIXME: remove this ui hack
        this.renderer.domElement.style.borderBottomLeftRadius = '3px';
        this.renderer.domElement.style.borderBottomRightRadius = '3px';
        this.mount.appendChild(this.renderer.domElement);
        this.props.canvasRef?.(this.renderer.domElement);
        this.orbitControls = new _three_ts_orbit_controls__WEBPACK_IMPORTED_MODULE_1__.OrbitControls(this.camera, this.renderer.domElement);
        this.orbitControls.enabled = false;
        // temp solution in order to not moving text cursor during movement
        this.orbitControls.enableKeys = false;
        if (grid) {
            this.createGridHelper();
        }
        window.addEventListener('resize', this.onWindowResize, false);
        // small hack for disabling arrow keys actings during the typing
        this.canvas.addEventListener('mouseover', e => { this.orbitControls.enabled = true; });
        this.canvas.addEventListener('mouseout', e => { this.orbitControls.enabled = false; });
        document.addEventListener("visibilitychange", this.handleVisibilityChange, false);
    }
    componentWillUnmount() {
        this.stop();
        this.mount.removeChild(this.renderer.domElement);
        window.removeEventListener('resize', this.onWindowResize, false);
        document.removeEventListener("visibilitychange", this.handleVisibilityChange, false);
    }
    handleVisibilityChange() {
        const timeline = this.props.timeline;
        if (document["hidden"]) {
            timeline.pause();
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)('pause timeline');
        }
        else {
            timeline.unpause();
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)('unpause timeline');
        }
    }
    get canvas() {
        return this.renderer.domElement;
    }
    createCamera(width, height) {
        const camera = new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, width / height, 0.1, 10000);
        camera.position.z = 3;
        camera.position.y = 2;
        camera.position.x = 2;
        camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0));
        return camera;
    }
    createRenderer(width, height) {
        // let WEBGL_DEBUG = false;
        // if (WEBGL_DEBUG) {
        //     let WebGLDebugUtils = require('webgl-debug');
        //     function throwOnGLError(err, funcName, args) {
        //         throw WebGLDebugUtils.glEnumToString(err)
        //         + "was caused by call to "
        //         + funcName;
        //     };
        //     const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas') as HTMLCanvasElement;
        //     canvas.style.display = 'block';
        //     const contextAttributes: WebGLContextAttributes = {
        //         alpha: true,
        //         antialias: true,
        //         depth: true,
        //         failIfMajorPerformanceCaveat: false,
        //         powerPreference: "default",
        //         premultipliedAlpha: true,
        //         preserveDrawingBuffer: true,
        //         stencil: true
        //     };
        //     let context = canvas.getContext("webgl2", contextAttributes);
        //     // context = WebGLDebugUtils.makeDebugContext(context, throwOnGLError);
        //     const renderer = new THREE.WebGLRenderer({
        //         context,
        //         canvas,
        //         antialias: true,
        //         preserveDrawingBuffer: true /* to be able to save screenshots */
        //     });
        //     // console.log(context, renderer.getContext());
        //     return renderer;
        // }
        return new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true /* to be able to save screenshots */
        });
    }
    createGridHelper(size = 200, divisions = 200) {
        const gridHelper = new three__WEBPACK_IMPORTED_MODULE_4__.GridHelper(size, divisions);
        this.scene.add(gridHelper);
    }
    onWindowResize() {
        this.camera.aspect = this.mount.clientWidth / this.mount.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.mount.clientWidth, this.mount.clientHeight);
    }
    begin() {
        // nothing todo
    }
    end() {
        this.frames++;
        const time = (performance || Date).now();
        if (time > this.prevTime + 1000) {
            this.updateFps((this.frames * 1000) / (time - this.prevTime), 100);
            this.prevTime = time;
            this.frames = 0;
        }
        return time;
    }
    updateFps(value, maxValue) {
        const fps = this.state.fps;
        const min = Math.min(fps.min, value);
        const max = Math.max(fps.max, value);
        this.setState({ fps: { min, max, value } });
    }
    animate(time) {
        this.begin();
        this.orbitControls.update();
        this.beginFrame();
        this.renderFrame();
        this.endFrame();
        this.frameId = requestAnimationFrame(this.animate);
        this.end();
    }
    beginFrame() {
        const timeline = this.props.timeline;
        timeline.tick();
    }
    renderFrame() { this.renderer.render(this.scene, this.camera); }
    endFrame() { }
    render() {
        return (react__WEBPACK_IMPORTED_MODULE_3__.createElement("div", { style: this.props.style, ref: (mount) => { this.mount = mount; } }));
    }
}
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_2__["default"]
], ThreeScene.prototype, "handleVisibilityChange", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_2__["default"]
], ThreeScene.prototype, "onWindowResize", null);
__decorate([
    autobind_decorator__WEBPACK_IMPORTED_MODULE_2__["default"]
], ThreeScene.prototype, "animate", null);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThreeScene);


/***/ }),

/***/ "KPdV":
/*!********************************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/GroupedUniforms.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroupedUniforms": () => (/* binding */ GroupedUniforms)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controls */ "ei2b");
/* harmony import */ var _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/translators/FxTranslator */ "3KVU");



function copyVec4({ padding }, v, group) {
    const pos = (padding / 16) >>> 0; // in vector
    const pad = (padding % 16) / 4;
    group.uniforms[pos + 0].value.fromArray(v.toArray(), 0);
}
function copyVec3({ padding }, src, group) {
    const pos = (padding / 16) >>> 0; // in vector
    const pad = (padding % 16) / 4;
    const dst = group.uniforms[pos + 0].value;
    src.toArray().forEach((x, i) => dst.setComponent(pad + i, x));
}
function copyVec2({ padding }, { x, y }, group) {
    const pos = (padding / 16) >>> 0; // in vector
    const pad = (padding % 16) / 4;
    console.assert(pad == 0, 'non zero paddings are not supported');
    group.uniforms[pos + 0].value.fromArray([x, y], 0);
}
function copyMat4x4({ padding }, mat, group) {
    const pos = (padding / 16) >>> 0; // in vector
    group.uniforms[pos + 0].value.fromArray(mat.elements, 0);
    group.uniforms[pos + 1].value.fromArray(mat.elements, 4);
    group.uniforms[pos + 2].value.fromArray(mat.elements, 8);
    group.uniforms[pos + 3].value.fromArray(mat.elements, 12);
}
function copyMat4x3({ padding }, mat, group) {
    const pos = (padding / 16) >>> 0; // in vector
    group.uniforms[pos + 0].value.fromArray(mat.elements, 0);
    group.uniforms[pos + 1].value.fromArray(mat.elements, 4);
    group.uniforms[pos + 2].value.fromArray(mat.elements, 8);
}
/** Write constan buffer entry to uniform group. */
function copyControl(state, field, i, deps, group) {
    const name = `${field.name}${i >= 0 ? `[${i}]` : ``}`;
    let offset = 0;
    if (field.length != -1) {
        const step = (field.size / field.length) >>> 0;
        console.assert(step * field.length === field.size, 'padding?!');
        offset = step * i;
    }
    const pos = ((field.padding + offset) / 16) >>> 0;
    const pad = ((field.padding + offset) % 16) / 4;
    const ctrl = state.controls[name];
    const val = state.values[name];
    if (['uint', 'int', 'uint', 'float'].indexOf(ctrl.type) !== -1) {
        const f32Num = (0,_controls__WEBPACK_IMPORTED_MODULE_0__.typedNumberToF32Num)((0,_controls__WEBPACK_IMPORTED_MODULE_0__.controlValueToThreeValue)(val, ctrl.type, deps), ctrl.type);
        group.uniforms[pos].value.setComponent(pad, f32Num);
    }
    else {
        group.uniforms[pos].value = (0,_controls__WEBPACK_IMPORTED_MODULE_0__.controlValueToThreeValue)(val, ctrl.type, deps);
    }
}
function copyFloat32({ padding }, value, group) {
    const pos = (padding / 16) >>> 0;
    const pad = (padding % 16) / 4;
    group.uniforms[pos].value.setComponent(pad, value);
}
function transpose(mat) {
    return (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).copy(mat).transpose();
}
class GroupedUniforms {
    data() {
        return this.uniformGroups;
    }
    /** @deprecated */
    create9(tech9) {
        this.uniformGroups?.forEach(gs => gs.forEach(g => g.dispose()));
        this.uniformGroups = [];
        // create uniform groups for each pass
        for (let i = 0; i < tech9.getPassCount(); ++i) {
            const cbuffers = tech9.getPass(i).getDesc().cbuffers;
            this.uniformGroups.push(GroupedUniforms.create(cbuffers));
        }
    }
    static create(cbuffers) {
        const groups = [];
        for (let cbuf of cbuffers) {
            let { name, size, usage } = cbuf;
            const nVec4 = size / 16;
            const group = new three__WEBPACK_IMPORTED_MODULE_2__.UniformsGroup();
            group.setName(name);
            for (let i = 0; i < nVec4; ++i) {
                group.add(new three__WEBPACK_IMPORTED_MODULE_2__.Uniform(new three__WEBPACK_IMPORTED_MODULE_2__.Vector4(0, 0, 0, 0)));
            }
            groups.push(group);
        }
        return groups;
    }
    /** @deprecated */
    update9(camera, viewport, controls, timeline, deps, tech9) {
        for (let iPass = 0; iPass < tech9.getPassCount(); ++iPass) {
            const cbuffers = tech9.getPass(iPass).getDesc().cbuffers;
            const groups = this.uniformGroups[iPass];
            GroupedUniforms.update(camera, viewport, controls, timeline, deps, groups, cbuffers);
        }
    }
    static update(camera, viewport, controls, timeline, deps, groups, cbuffers) {
        /*
        uniform mat4 modelMatrix;       // = object.matrixWorld
        uniform mat4 modelViewMatrix;   // = camera.matrixWorldInverse * object.matrixWorld
        uniform mat4 projectionMatrix;  // = camera.projectionMatrix
        uniform mat4 viewMatrix;        // = camera.matrixWorldInverse
        uniform mat3 normalMatrix;      // = inverse transpose of modelViewMatrix
        uniform vec3 cameraPosition;    // = camera position in world space
        */
        const identityMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
        // todo: move out model matrix from global uniforms
        const modelMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).copy(identityMatrix);
        const viewMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).copy(camera.matrixWorldInverse);
        const projMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).copy(camera.projectionMatrix);
        const modelViewMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).multiplyMatrices(viewMatrix, modelMatrix);
        const modelViewProjMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).multiplyMatrices(projMatrix, modelViewMatrix);
        const viewProjMatrix = (new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4).multiplyMatrices(projMatrix, viewMatrix);
        const { clientWidth, clientHeight } = viewport;
        const constants = timeline.getConstants();
        for (let c = 0; c < cbuffers.length; ++c) {
            let cbuf = cbuffers[c];
            let group = groups[c];
            let { name, size, usage } = cbuf;
            switch (name) {
                case _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__.AUTOGEN_CONTROLS:
                    {
                        for (let field of cbuf.fields) {
                            if (field.length == -1) {
                                copyControl(controls, field, -1, deps, group);
                            }
                            else {
                                for (let i = 0; i < field.length; ++i) {
                                    copyControl(controls, field, i, deps, group);
                                }
                            }
                        }
                    }
                    break;
                case _lib_fx_translators_FxTranslator__WEBPACK_IMPORTED_MODULE_1__.AUTOGEN_GLOBALS:
                    for (let field of cbuf.fields) {
                        switch (field.semantic) {
                            case 'ELAPSED_TIME_LEVEL':
                                copyFloat32(field, constants.elapsedTimeLevel, group);
                                break;
                            case 'ELAPSED_TIME':
                                copyFloat32(field, constants.elapsedTime, group);
                                break;
                            case 'FRAME_NUMBER':
                                copyFloat32(field, constants.frameNumber, group);
                                break;
                            // todo: move to locals
                            case 'MODEL_MATRIX':
                                copyMat4x4(field, modelMatrix, group);
                                break;
                            // todo: move to locals
                            case 'MODEL_VIEW_MATRIX':
                                copyMat4x4(field, modelViewMatrix, group);
                                break;
                            case 'MODEL_VIEW_PROJECTION_MATRIX':
                                // TODO: fixme me, the only one user is technique11.fx at the moment (!)
                                copyMat4x4(field, transpose(modelViewProjMatrix), group);
                                break;
                            case 'VIEW_MATRIX':
                                copyMat4x4(field, viewMatrix, group);
                                break;
                            case 'PROJECTION_MATRIX':
                                copyMat4x4(field, projMatrix, group);
                                break;
                            case 'CAMERA_POSITION':
                                copyVec3(field, camera.position, group);
                                break;
                            default:
                                // todo: emit once (!)
                                console.error(`GLOBAL_UNIFORMS: unknown semantic <${field.semantic}> found.`);
                        }
                    }
                    break;
                default:
                    for (let field of cbuf.fields) {
                        switch (field.semantic) {
                            case 'COMMON_VIEWPROJ_MATRIX':
                                // note: husky uses transposed matrices (!)
                                copyMat4x4(field, transpose(viewProjMatrix), group);
                                break;
                            case 'COMMON_VP_PARAMS':
                                {
                                    const pos = (field.padding / 16) >>> 0; // in vector
                                    group.uniforms[pos + 0].value.fromArray([1.0 / clientWidth, 1.0 / clientHeight, 0.5 / clientWidth, 0.5 / clientHeight]);
                                }
                                break;
                            case 'VS_REG_COMMON_OBJ_WORLD_MATRIX_DEBUG':
                                copyMat4x3(field, identityMatrix, group);
                                break;
                        }
                    }
            }
        }
    }
}


/***/ }),

/***/ "O6BO":
/*!*******************************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/SingleUniforms.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SingleUniforms": () => (/* binding */ SingleUniforms)
/* harmony export */ });
/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controls */ "ei2b");

class SingleUniforms {
    static create(controls, deps) {
        const uniforms = {
            elapsedTime: { value: 0 },
            elapsedTimeLevel: { value: 0 },
            // elapsedTimeThis: { value: 0 }
        };
        if (controls) {
            for (let name in controls.values) {
                let value = controls.values[name];
                let ctrl = controls.controls[name];
                uniforms[name] = { value: (0,_controls__WEBPACK_IMPORTED_MODULE_0__.controlValueToThreeValue)(value, ctrl.type, deps) };
            }
        }
        return uniforms;
    }
    static update(controls, timeline, deps, uniforms) {
        const constants = timeline.getConstants();
        uniforms.elapsedTime.value = constants.elapsedTime;
        uniforms.elapsedTimeLevel.value = constants.elapsedTimeLevel;
        if (controls) {
            for (let name in controls.values) {
                let val = controls.values[name];
                let ctrl = controls.controls[name];
                if (uniforms[name])
                    uniforms[name].value = (0,_controls__WEBPACK_IMPORTED_MODULE_0__.controlValueToThreeValue)(val, ctrl.type, deps);
            }
        }
    }
}


/***/ }),

/***/ "I0Lu":
/*!**************************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/adjacency.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConvertPointRepsToAdjacencyImpl": () => (/* binding */ ConvertPointRepsToAdjacencyImpl),
/* harmony export */   "GeneratePointReps": () => (/* binding */ GeneratePointReps),
/* harmony export */   "prepareTrimesh": () => (/* binding */ prepareTrimesh)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "y9Bw");


const UNUSED32 = -1 >>> 0;
class vertexHashEntry {
}
;
// <algorithm> std::make_heap doesn't match D3DX10 so we use the same algorithm here
function MakeXHeap(positions, nVerts) {
    const index = new Array(nVerts);
    const pos = vert => new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);
    for (let vert = 0; vert < nVerts; ++vert) {
        index[vert] = vert;
    }
    if (nVerts > 1) {
        // Create the heap
        let iulLim = nVerts >>> 0;
        for (let vert = (nVerts >> 1) >>> 0; ((--vert) >>> 0) != (-1 >>> 0);) {
            // Percolate down
            let iulI = vert;
            let iulJ = vert + vert + 1;
            const ulT = index[iulI];
            while (iulJ < iulLim) {
                let ulJ = index[iulJ];
                if (iulJ + 1 < iulLim) {
                    const ulJ1 = index[iulJ + 1];
                    if (pos(ulJ1).x <= pos(ulJ).x) {
                        iulJ++;
                        ulJ = ulJ1;
                    }
                }
                if (pos(ulJ).x > pos(ulT).x)
                    break;
                index[iulI] = index[iulJ];
                iulI = iulJ;
                iulJ += iulJ + 1;
            }
            index[iulI] = ulT;
        }
        // Sort the heap
        while (((--iulLim) >>> 0) != (-1 >>> 0)) {
            const ulT = index[iulLim];
            index[iulLim] = index[0];
            // Percolate down
            let iulI = 0;
            let iulJ = 1;
            while (iulJ < iulLim) {
                let ulJ = index[iulJ];
                if (iulJ + 1 < iulLim) {
                    const ulJ1 = index[iulJ + 1];
                    if (pos(ulJ1).x <= pos(ulJ).x) {
                        iulJ++;
                        ulJ = ulJ1;
                    }
                }
                if (pos(ulJ).x > pos(ulT).x)
                    break;
                index[iulI] = index[iulJ];
                iulI = iulJ;
                iulJ += iulJ + 1;
            }
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(iulI < nVerts);
            index[iulI] = ulT;
        }
    }
    return index;
}
function GeneratePointReps(indices, nFaces, positions, nVerts, epsilon = 0) {
    const pointRep = new Array(nVerts);
    const vertexToCorner = new Array(nVerts);
    const vertexCornerList = (new Array(nFaces * 3));
    vertexToCorner.fill(UNUSED32);
    vertexCornerList.fill(UNUSED32);
    // build initial lists and validate indices
    for (let j = 0; j < (nFaces * 3); ++j) {
        let k = indices[j];
        if (k === -1)
            continue;
        if (k >= nVerts) {
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
            return null;
        }
        vertexCornerList[j] = vertexToCorner[k];
        vertexToCorner[k] = j;
    }
    const hashTable = {};
    const pos = vert => new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);
    if (epsilon == 0) {
        for (let vert = 0; vert < nVerts; ++vert) {
            let px = pos(vert).x;
            let py = pos(vert).y;
            let pz = pos(vert).z;
            const hashKey = `${px.toFixed(3)}:${py.toFixed(3)}:${pz.toFixed(3)}`;
            let found = UNUSED32;
            for (let current = hashTable[hashKey]; current != null; current = current.next) {
                if (current.v.x == pos(vert).x
                    && current.v.y == pos(vert).y
                    && current.v.z == pos(vert).z) {
                    let head = vertexToCorner[vert];
                    let ispresent = false;
                    while (head != UNUSED32) {
                        const face = head / 3;
                        if ((indices[face * 3] == current.index) || (indices[face * 3 + 1] == current.index) || (indices[face * 3 + 2] == current.index)) {
                            ispresent = true;
                            break;
                        }
                        head = vertexCornerList[head];
                    }
                    if (!ispresent) {
                        found = current.index;
                        break;
                    }
                }
            }
            if (found != UNUSED32) {
                pointRep[vert] = found;
            }
            else {
                let newEntry = new vertexHashEntry;
                newEntry.v = pos(vert);
                newEntry.index = vert;
                newEntry.next = hashTable[hashKey];
                hashTable[hashKey] = newEntry;
                pointRep[vert] = vert;
            }
        }
    }
    else {
        const xorder = MakeXHeap(positions, nVerts);
        pointRep.fill(UNUSED32);
        const vepsilon = epsilon * epsilon;
        let head = 0;
        let tail = 0;
        while (tail < nVerts) {
            // move head until just out of epsilon
            while ((head < nVerts)
                && ((pos(tail).x - pos(head).x) <= epsilon)) {
                ++head;
            }
            // check new tail against all points up to the head
            let tailIndex = xorder[tail];
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(tailIndex < nVerts);
            if (pointRep[tailIndex] == UNUSED32) {
                pointRep[tailIndex] = tailIndex;
                const outer = pos(tailIndex);
                for (let current = tail + 1; current < head; ++current) {
                    let curIndex = xorder[current];
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(curIndex < nVerts);
                    // if the point is already assigned, ignore it
                    if (pointRep[curIndex] == UNUSED32) {
                        const inner = pos(curIndex);
                        const diff = inner.sub(outer).lengthSq();
                        if (diff < vepsilon) {
                            let headvc = vertexToCorner[tailIndex];
                            let ispresent = false;
                            while (headvc != UNUSED32) {
                                const face = headvc / 3;
                                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(face < nFaces);
                                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)((indices[face * 3] == tailIndex) || (indices[face * 3 + 1] == tailIndex) || (indices[face * 3 + 2] == tailIndex));
                                if ((indices[face * 3] == curIndex) || (indices[face * 3 + 1] == curIndex) || (indices[face * 3 + 2] == curIndex)) {
                                    ispresent = true;
                                    break;
                                }
                                headvc = vertexCornerList[headvc];
                            }
                            if (!ispresent) {
                                pointRep[curIndex] = tailIndex;
                            }
                        }
                    }
                }
            }
            ++tail;
        }
    }
    return pointRep;
}
class edgeHashEntry {
}
;
//---------------------------------------------------------------------------------
// Convert PointRep to Adjacency
//---------------------------------------------------------------------------------
function ConvertPointRepsToAdjacencyImpl(indices, nFaces, positions, nVerts, pointRep) {
    const adjacency = new Array(nFaces * 3);
    const hashTable = {};
    const pos = vert => new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[vert * 3 + 0], positions[vert * 3 + 1], positions[vert * 3 + 2]);
    // add face edges to hash table and validate indices
    for (let face = 0; face < nFaces; ++face) {
        let i0 = indices[face * 3];
        let i1 = indices[face * 3 + 1];
        let i2 = indices[face * 3 + 2];
        if (i0 == -1
            || i1 == -1
            || i2 == -1)
            continue;
        if (i0 >= nVerts
            || i1 >= nVerts
            || i2 >= nVerts)
            return null;
        const v1 = pointRep[i0];
        const v2 = pointRep[i1];
        const v3 = pointRep[i2];
        // filter out degenerate triangles
        if (v1 == v2 || v1 == v3 || v2 == v3)
            continue;
        for (let point = 0; point < 3; ++point) {
            const va = pointRep[indices[face * 3 + point]];
            const vb = pointRep[indices[face * 3 + ((point + 1) % 3)]];
            const vOther = pointRep[indices[face * 3 + ((point + 2) % 3)]];
            const hashKey = `${va}`;
            let newEntry = new edgeHashEntry;
            newEntry.v1 = va;
            newEntry.v2 = vb;
            newEntry.vOther = vOther;
            newEntry.face = face;
            newEntry.next = hashTable[hashKey];
            hashTable[hashKey] = newEntry;
        }
    }
    adjacency.fill(UNUSED32);
    for (let face = 0; face < nFaces; ++face) {
        let i0 = indices[face * 3];
        let i1 = indices[face * 3 + 1];
        let i2 = indices[face * 3 + 2];
        // filter out unused triangles
        if (i0 == -1
            || i1 == -1
            || i2 == -1)
            continue;
        const v1 = pointRep[i0];
        const v2 = pointRep[i1];
        const v3 = pointRep[i2];
        // filter out degenerate triangles
        if (v1 == v2 || v1 == v3 || v2 == v3)
            continue;
        for (let point = 0; point < 3; ++point) {
            if (adjacency[face * 3 + point] != UNUSED32)
                continue;
            // see if edge already entered, if not then enter it
            const va = pointRep[indices[face * 3 + ((point + 1) % 3)]];
            const vb = pointRep[indices[face * 3 + point]];
            const vOther = pointRep[indices[face * 3 + ((point + 2) % 3)]];
            const hashKey = `${va}`;
            let current = hashTable[hashKey];
            let prev = null;
            let foundFace = UNUSED32;
            while (current != null) {
                if ((current.v2 == vb) && (current.v1 == va)) {
                    foundFace = current.face;
                    break;
                }
                prev = current;
                current = current.next;
            }
            let found = current;
            let foundPrev = prev;
            let bestDiff = -2.0;
            // Scan for additional matches
            if (current) {
                prev = current;
                current = current.next;
                // find 'better' match
                while (current != null) {
                    if ((current.v2 == vb) && (current.v1 == va)) {
                        const pB1 = pos(vb);
                        const pB2 = pos(va);
                        const pB3 = pos(vOther);
                        let v12 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pB1, pB2);
                        let v13 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pB1, pB3);
                        const bnormal = v12.cross(v13).normalize();
                        if (bestDiff == -2.0) {
                            const pA1 = pos(found.v1);
                            const pA2 = pos(found.v2);
                            const pA3 = pos(found.vOther);
                            v12 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pA1, pA2);
                            v13 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pA1, pA3);
                            const anormal = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).crossVectors(v12, v13).normalize();
                            bestDiff = anormal.dot(bnormal);
                        }
                        const pA1 = pos(current.v1);
                        const pA2 = pos(current.v2);
                        const pA3 = pos(current.vOther);
                        v12 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pA1, pA2);
                        v13 = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).subVectors(pA1, pA3);
                        const anormal = (new three__WEBPACK_IMPORTED_MODULE_1__.Vector3).crossVectors(v12, v13).normalize();
                        const diff = anormal.dot(bnormal);
                        // if face normals are closer, use new match
                        if (diff > bestDiff) {
                            found = current;
                            foundPrev = prev;
                            foundFace = current.face;
                            bestDiff = diff;
                        }
                    }
                    prev = current;
                    current = current.next;
                }
            }
            if (foundFace != UNUSED32) {
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(found != null);
                // remove found face from hash table
                if (foundPrev != null) {
                    foundPrev.next = found.next;
                }
                else {
                    hashTable[hashKey] = found.next;
                }
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(adjacency[face * 3 + point] == UNUSED32);
                adjacency[face * 3 + point] = foundFace;
                // Check for other edge
                const hashKey2 = `${vb}`;
                current = hashTable[hashKey2];
                prev = null;
                while (current != null) {
                    if ((current.face == face) && (current.v2 == va) && (current.v1 == vb)) {
                        // trim edge from hash table
                        if (prev != null) {
                            prev.next = current.next;
                        }
                        else {
                            hashTable[hashKey2] = current.next;
                        }
                        break;
                    }
                    prev = current;
                    current = current.next;
                }
                // mark neighbor to point back
                let linked = false;
                for (let point2 = 0; point2 < point; ++point2) {
                    if (foundFace == adjacency[face * 3 + point2]) {
                        linked = true;
                        adjacency[face * 3 + point] = UNUSED32;
                        break;
                    }
                }
                if (!linked) {
                    let point2 = 0;
                    for (; point2 < 3; ++point2) {
                        let k = indices[foundFace * 3 + point2];
                        if (k == -1)
                            continue;
                        if (pointRep[k] == va)
                            break;
                    }
                    if (point2 < 3) {
                        // update neighbor to point back to this face match edge
                        adjacency[foundFace * 3 + point2] = face;
                    }
                }
            }
        }
    }
    return adjacency;
}
function GenerateGSAdjacencyImpl(indices, nFaces, pointRep, adjacency, nVerts) {
    const indicesAdj = new Array(nFaces * 6);
    let inputi = 0;
    let outputi = 0;
    for (let face = 0; face < nFaces; ++face) {
        for (let point = 0; point < 3; ++point) {
            indicesAdj[outputi] = indices[inputi];
            ++outputi;
            ++inputi;
            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(outputi < (nFaces * 6));
            const a = adjacency[face * 3 + point];
            if (a == UNUSED32) {
                indicesAdj[outputi] = indices[face * 3 + ((point + 2) % 3)];
            }
            else {
                let v1 = indices[face * 3 + point];
                let v2 = indices[face * 3 + ((point + 1) % 3)];
                if (v1 == -1 || v2 == -1) {
                    indicesAdj[outputi] = -1;
                }
                else {
                    if (v1 >= nVerts || v2 >= nVerts) {
                        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
                        return null;
                    }
                    v1 = pointRep[v1];
                    v2 = pointRep[v2];
                    let vOther = UNUSED32;
                    // find other vertex
                    for (let k = 0; k < 3; ++k) {
                        const ak = indices[a * 3 + k];
                        if (ak == -1)
                            break;
                        if (ak >= nVerts) {
                            (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(false);
                            return null;
                        }
                        if (pointRep[ak] == v1)
                            continue;
                        if (pointRep[ak] == v2)
                            continue;
                        vOther = ak;
                    }
                    if (vOther == UNUSED32) {
                        indicesAdj[outputi] = indices[face * 3 + ((point + 2) % 3)];
                    }
                    else {
                        indicesAdj[outputi] = vOther;
                    }
                }
            }
            ++outputi;
        }
    }
    return indicesAdj;
}
function prepareTrimesh(g) {
    // g.setIndex(Array(g.attributes.position.count).fill(0).map((x, i) => i < g.attributes.position.count / 2 ? i : 0));
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(g.attributes.position);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(g.attributes.normal);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(g.attributes.uv);
    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!g.index);
    const positions = g.attributes.position.array;
    const normals = g.attributes.normal.array;
    const uvs = g.attributes.uv.array;
    const vertCount = g.attributes.position.count;
    const faceCount = vertCount / 3;
    const indices = Array(vertCount).fill(0).map((x, i) => i);
    const pointReps = GeneratePointReps(indices, faceCount, positions, vertCount); //, 0.0001);
    const facesAdj = ConvertPointRepsToAdjacencyImpl(indices, faceCount, positions, vertCount, pointReps);
    const indicesAdj = GenerateGSAdjacencyImpl(indices, faceCount, pointReps, facesAdj, vertCount);
    // console.log(pointReps, adjacency);
    // pos, norm, uv
    const vertices = new Array(vertCount * (3 + 3 + 2));
    for (let i = 0; i < vertCount; ++i) {
        for (let j = 0; j < 3; ++j) {
            vertices[8 * i + 0 + j] = positions[3 * i + j];
        }
        for (let j = 0; j < 3; ++j) {
            vertices[8 * i + 3 + j] = normals[3 * i + j];
        }
        for (let j = 0; j < 2; ++j) {
            vertices[8 * i + 6 + j] = uvs[2 * i + j];
        }
    }
    const faces = indices;
    return {
        vertCount,
        faceCount,
        vertices,
        faces,
        facesAdj,
        indicesAdj
    };
    // let ind = [];
    // [3].forEach(iFace => {
    //     let i0 = adjacency[iFace * 3 + 0];
    //     let i1 = adjacency[iFace * 3 + 1];
    //     let i2 = adjacency[iFace * 3 + 2];
    //     //ind.push(indices[iFace * 3 + 0], indices[iFace * 3 + 1], indices[iFace * 3 + 2]);
    //     [i0, i1, i2].filter(i => i != UNUSED32).forEach(iFace => {
    //         ind.push(indices[iFace * 3 + 0], indices[iFace * 3 + 1], indices[iFace * 3 + 2]);
    //     });
    // });
    // g.setIndex(ind);
}


/***/ }),

/***/ "ei2b":
/*!*************************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/controls.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXTURE_PLACEHOLDER_WHITE_1X1": () => (/* binding */ TEXTURE_PLACEHOLDER_WHITE_1X1),
/* harmony export */   "controlValueToThreeValue": () => (/* binding */ controlValueToThreeValue),
/* harmony export */   "typedNumberToF32Num": () => (/* binding */ typedNumberToF32Num)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "y9Bw");

function createPlaceholderTexture(width = 512, height = 512) {
    const size = width * height;
    const data = new Uint8Array(4 * size);
    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0xffffff);
    const r = Math.floor(color.r * 255);
    const g = Math.floor(color.g * 255);
    const b = Math.floor(color.b * 255);
    for (let i = 0; i < size; i++) {
        const stride = i * 4;
        data[stride] = r;
        data[stride + 1] = g;
        data[stride + 2] = b;
        data[stride + 3] = 255;
    }
    // used the buffer to create a DataTexture
    const texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(data, width, height);
    texture.needsUpdate = true;
    return texture;
}
const TEXTURE_PLACEHOLDER_WHITE_1X1 = createPlaceholderTexture(1, 1);
function controlValueToThreeValue(ctrl, type, deps) {
    let ab = new ArrayBuffer(4);
    let dv = new DataView(ab);
    switch (type) {
        case 'color': {
            const { r, g, b, a } = ctrl;
            return new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(r, g, b, a);
        }
        case 'float4': {
            const { x, y, z, w } = ctrl;
            return new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(x, y, z, w);
        }
        case 'float3': {
            const { x, y, z } = ctrl;
            return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);
        }
        case 'float2': {
            const { x, y } = ctrl;
            return new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);
        }
        case 'mesh':
            // nothing todo: meshes are not supported in vs/ps shaders
            return null;
        case 'texture2d':
            return deps.textures[ctrl] || TEXTURE_PLACEHOLDER_WHITE_1X1;
        case 'uint':
        case 'int':
        case 'float':
            return ctrl;
        default:
            console.error('unsupported type found');
    }
    return null;
}
function typedNumberToF32Num(num, type) {
    let ab = new ArrayBuffer(4);
    let dv = new DataView(ab);
    switch (type) {
        case 'float':
            return num;
        case 'int':
            dv.setInt32(0, num);
            return dv.getFloat32(0);
        case 'uint':
            dv.setUint32(0, num);
            return dv.getFloat32(0);
        default:
            console.error('unsupported type found');
    }
    return null;
}


/***/ }),

/***/ "KeJm":
/*!*********************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/deps.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deps": () => (/* binding */ Deps),
/* harmony export */   "GetAssetsModels": () => (/* binding */ GetAssetsModels),
/* harmony export */   "GetAssetsTextures": () => (/* binding */ GetAssetsTextures)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "Q/He");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ "y9Bw");
/* harmony import */ var three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ "Qn1W");
/* harmony import */ var three_examples_jsm_loaders_TGALoader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/loaders/TGALoader */ "WH/H");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__]);
_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];








function GetAssetsTexturesPath() {
    return `${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__.ASSETS_PATH}/textures`;
}
function GetAssetsModelsPath() {
    return `${_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__.ASSETS_PATH}/models`;
}
function currentPath() {
    if (window.navigator.platform.includes('Mac')) {
        return window.location.pathname;
    }
    return window.location.pathname.substr(1);
}
function GetAssetsTextures() {
    if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_1__.isElectron()) {
        return Object.values(_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__.ASSETS_MANIFEST.textures)
            .filter(file => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(file))
            .map(file => path__WEBPACK_IMPORTED_MODULE_4__.basename(file))
            .sort();
    }
    else {
        const sandboxPath = path__WEBPACK_IMPORTED_MODULE_4__.dirname(currentPath());
        const texturePath = path__WEBPACK_IMPORTED_MODULE_4__.join(sandboxPath, GetAssetsTexturesPath());
        return fs__WEBPACK_IMPORTED_MODULE_3__.readdirSync(texturePath);
    }
}
function GetAssetsModels() {
    if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_1__.isElectron()) {
        return Object.values(_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_2__.ASSETS_MANIFEST.models)
            .filter(file => (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString)(file))
            .map(file => path__WEBPACK_IMPORTED_MODULE_4__.basename(file))
            .sort();
    }
    else {
        const sandboxPath = path__WEBPACK_IMPORTED_MODULE_4__.dirname(currentPath());
        const texturePath = path__WEBPACK_IMPORTED_MODULE_4__.join(sandboxPath, GetAssetsModelsPath());
        return fs__WEBPACK_IMPORTED_MODULE_3__.readdirSync(texturePath).filter(fname => path__WEBPACK_IMPORTED_MODULE_4__.extname(fname) === '.obj');
    }
}
function loadObjModel(name) {
    const loader = new three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_5__.OBJLoader();
    return new Promise((resolve, reject) => {
        loader.load(`${GetAssetsModelsPath()}/${name}`, (group) => {
            console.log(`model '${GetAssetsModelsPath()}/${name}.obj' is loaded.`);
            resolve(group.children);
        }, (xhr) => {
            // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        }, (error) => {
            console.log('An error happened');
            reject();
        });
    });
}
function loadTGATexture(name) {
    const loader = new three_examples_jsm_loaders_TGALoader__WEBPACK_IMPORTED_MODULE_6__.TGALoader();
    return new Promise((resolve, reject) => {
        loader.load(`${GetAssetsTexturesPath()}/${name}`, (texture) => {
            console.log(`texture '${GetAssetsTexturesPath()}/${name}' is loaded.`);
            resolve(texture);
        }, (xhr) => {
            // console.log( `${GetAssetsTexturesPath()}/${name}` + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        }, (error) => {
            console.log('An error happened');
            reject();
        });
    });
}
function loadTexture(name) {
    if (path__WEBPACK_IMPORTED_MODULE_4__.extname(name) === '.tga')
        return loadTGATexture(name);
    const loader = new three__WEBPACK_IMPORTED_MODULE_7__.TextureLoader();
    return new Promise((resolve, reject) => {
        loader.load(`${GetAssetsTexturesPath()}/${name}`, (texture) => {
            // texture.encoding = THREE.sRGBEncoding;
            console.log(`texture '${GetAssetsTexturesPath()}/${name}' is loaded.`);
            resolve(texture);
        }, (xhr) => {
            // console.log( `${GetAssetsTexturesPath()}/${name}` + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        }, (error) => {
            console.log('An error happened');
            reject();
        });
    });
}
function resolveExternalDependencies(preloadTextures, preloadMeshes, deps, onComplete) {
    const geoms = new Set();
    const textures = new Set();
    if (preloadTextures) {
        // IP: quick solution - request all possible textures as sub resources
        // if resource requires at least one texture.
        GetAssetsTextures().forEach(fname => textures.add(fname));
    }
    if (preloadMeshes || true /* ?? */) {
        // IP: quick solution - request all possible textures as sub resources
        // if resource requires at least one texture.
        GetAssetsModels().forEach(fname => geoms.add(fname));
    }
    let depNum = 1;
    let tryFinish = () => {
        depNum--;
        if (depNum == 0) {
            onComplete?.(deps);
        }
    };
    for (let name of geoms.values()) {
        if (!deps.models[name]) {
            depNum++;
            loadObjModel(name).then(meshes => {
                deps.models[name] = meshes;
                tryFinish();
            });
        }
    }
    for (let name of textures.values()) {
        if (!deps.textures[name]) {
            depNum++;
            loadTexture(name).then(texture => {
                deps.textures[name] = texture;
                tryFinish();
            });
        }
    }
    tryFinish();
}
class Deps {
    constructor() {
        this.models = {};
        this.textures = {};
    }
    resolve(preloadTextures, preloadMeshes, onComplete) {
        resolveExternalDependencies(preloadTextures, preloadMeshes, this, onComplete);
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "eK+6":
/*!********************************************************!*\
  !*** ./src/sandbox/containers/playground/utils/gui.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuiView": () => (/* binding */ GuiView)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bundles/utils */ "GUxJ");
/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dat.gui */ "2U48");
/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ "KeJm");
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! copy-to-clipboard */ "Krap");
/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_deps__WEBPACK_IMPORTED_MODULE_3__]);
_deps__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];






class GuiView {
    constructor() {
        this.gui = null;
        this.presetName = null;
        this.meshDebugDraw = {};
    }
    mount(el) {
        this.mountEl = el;
    }
    detach() {
        this.mountEl.removeChild(this.gui.domElement);
    }
    attach() {
        this.mountEl.appendChild(this.gui.domElement);
    }
    debugDraw() {
        return this.meshDebugDraw;
    }
    preset() {
        return this.presetName;
    }
    static hash(controls) {
        return JSON.stringify(controls.controls) +
            JSON.stringify(controls.presets) +
            // IP: hack to handle update of textures
            JSON.stringify(Object.values(controls.values).filter(_lib_common__WEBPACK_IMPORTED_MODULE_0__.isString));
    }
    remove() {
        if (this.gui) {
            this.detach();
            this.gui.destroy();
            this.gui = null;
            this.hash = null;
        }
    }
    create(controls) {
        if (!controls) {
            return;
        }
        const hash = GuiView.hash(controls);
        if (this.hash != hash) {
            this.remove();
        }
        if (Object.keys(controls.values).length == 0) {
            // empty controls are valid ?
            return null;
        }
        if (this.gui) {
            // nothing todo, same controls have been requested
            return;
        }
        // remove active preset if it doesn't exist anymore
        if (this.presetName && !controls.presets.find(p => p.name === this.presetName)) {
            this.presetName = null;
        }
        const gui = new dat_gui__WEBPACK_IMPORTED_MODULE_2__.GUI({ autoPlace: false });
        for (let name in controls.values) {
            let ctrl = controls.controls[name];
            let viewType = ctrl.properties["__type"] || ctrl.type;
            let caption = ctrl.properties["__caption"] || ctrl.name;
            let guiCtrl = null;
            switch (viewType) {
                case 'int':
                case 'uint':
                case 'float':
                    guiCtrl = gui.add(controls.values, name);
                    break;
                case 'slider':
                    let min = ctrl.properties["__min"];
                    let max = ctrl.properties["__max"];
                    let step = ctrl.properties["__step"];
                    guiCtrl = gui.add(controls.values, name, min, max, step);
                    break;
                case 'color':
                    let colorFolder = gui.addFolder(caption);
                    let clr = controls.values[name];
                    colorFolder.addColor({ color: (0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__.colorToUint)(clr) }, 'color').onChange(value => (0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__.uintToColor)(value, clr));
                    colorFolder.add({ opacity: clr.a }, 'opacity', 0, 1).onChange(value => clr.a = value);
                    colorFolder.open();
                    break;
                case 'float2':
                    let vec2Folder = gui.addFolder(caption);
                    vec2Folder.add(controls.values[name], 'x');
                    vec2Folder.add(controls.values[name], 'y');
                    vec2Folder.close();
                    break;
                case 'float3':
                    let vec3Folder = gui.addFolder(caption);
                    vec3Folder.add(controls.values[name], 'x');
                    vec3Folder.add(controls.values[name], 'y');
                    vec3Folder.add(controls.values[name], 'z');
                    vec3Folder.close();
                    break;
                case 'float4':
                    let vec4Folder = gui.addFolder(caption);
                    vec4Folder.add(controls.values[name], 'x');
                    vec4Folder.add(controls.values[name], 'y');
                    vec4Folder.add(controls.values[name], 'z');
                    vec4Folder.add(controls.values[name], 'w');
                    vec4Folder.close();
                    break;
                case 'texture2d':
                    {
                        const list = (0,_deps__WEBPACK_IMPORTED_MODULE_3__.GetAssetsTextures)();
                        let def = controls.values[name];
                        if (!list.includes(def)) {
                            def = list[0];
                        }
                        // override initial value if it does not suit available resources
                        gui.add(controls.values, name, list).setValue(def);
                    }
                    break;
                case 'mesh':
                    {
                        let def = controls.values[name];
                        const list = (0,_deps__WEBPACK_IMPORTED_MODULE_3__.GetAssetsModels)();
                        if (!list.includes(def)) {
                            def = list[0];
                        }
                        // override initial value if it does not suit available resources
                        const folder = gui.addFolder(caption);
                        folder.add(controls.values, name, list).setValue(def);
                        {
                            this.meshDebugDraw[name] ||= false;
                            folder.add(this.meshDebugDraw, name).name('show (debug)');
                        }
                        folder.open();
                    }
                    break;
            }
            if (guiCtrl) {
                guiCtrl.name(caption);
            }
        }
        if (controls.presets?.length) {
            gui.add(this, 'presetName', ['', ...controls.presets.map(p => p.name)]).onChange(name => {
                console.log('apply preset', name);
                const preset = controls.presets.find(p => p.name == name);
                if (preset) {
                    preset.data.forEach(entry => {
                        let control = controls.controls[entry.name];
                        if (control) {
                            controls.values[entry.name] = (0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__.cloneValue)(entry.type, entry.value);
                        }
                    });
                    setTimeout(() => {
                        this.remove();
                        this.create(controls);
                    }, 10);
                }
            }).name('preset');
        }
        const copyToClipboard = '<center>copy to clipboard</center>';
        // todo: show notification
        gui.add({
            [copyToClipboard]: () => {
                copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5___default()((0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__.encodePlaygroundControlsToString)(controls), { debug: true });
                (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_4__.toast)({
                    size: 'tiny',
                    type: 'info',
                    title: `Copied to clipboard`,
                    animation: 'bounce',
                    time: 2000
                });
            }
        }, copyToClipboard);
        // gui.close();
        gui.open();
        gui.domElement.style.position = 'absolute';
        gui.domElement.style.top = '2px';
        this.gui = gui;
        this.hash = hash;
        this.attach();
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "FJDS":
/*!****************************!*\
  !*** ./src/sandbox/ipc.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "async": () => (/* binding */ async),
/* harmony export */   "isElectron": () => (/* binding */ isElectron),
/* harmony export */   "sync": () => (/* binding */ sync)
/* harmony export */ });
/* harmony import */ var is_electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-electron */ "s0+s");
/* harmony import */ var is_electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_electron__WEBPACK_IMPORTED_MODULE_0__);

function isElectron() {
    return is_electron__WEBPACK_IMPORTED_MODULE_0___default()();
}
;
const ipcRenderer = isElectron() ? (__webpack_require__(/*! electron */ "vCZ/").ipcRenderer) : null;
const sync = {
    argv() {
        return ipcRenderer?.sendSync('argv', {});
    },
    // returns saved file name
    saveFile(name, data) {
        return ipcRenderer?.sendSync('process-save-file-silent', { name, data });
    },
    // save file using file dialog
    // returns saved file name
    saveFileDialog(options, data) {
        options = {
            title: "Save File",
            defaultPath: "",
            buttonLabel: "Save",
            filters: [],
            ...options
        };
        return ipcRenderer?.sendSync('process-save-file-dialog', { data, options });
    },
    // readFile(name: string): string {
    // }
};
const async = {
    notifyAppReady() {
        ipcRenderer?.send('app-ready', {});
    }
};


/***/ }),

/***/ "Ctio":
/*!*************************************!*\
  !*** ./src/sandbox/logic/common.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASSETS_MANIFEST": () => (/* binding */ ASSETS_MANIFEST),
/* harmony export */   "ASSETS_PATH": () => (/* binding */ ASSETS_PATH),
/* harmony export */   "AST_VIEW": () => (/* binding */ AST_VIEW),
/* harmony export */   "BYTECODE_VIEW": () => (/* binding */ BYTECODE_VIEW),
/* harmony export */   "CODE_KEYWORD": () => (/* binding */ CODE_KEYWORD),
/* harmony export */   "DEFAULT_FILENAME": () => (/* binding */ DEFAULT_FILENAME),
/* harmony export */   "EXT_FILTER": () => (/* binding */ EXT_FILTER),
/* harmony export */   "GRAPH_KEYWORD": () => (/* binding */ GRAPH_KEYWORD),
/* harmony export */   "GRAPH_VIEW": () => (/* binding */ GRAPH_VIEW),
/* harmony export */   "LIB_PATH": () => (/* binding */ LIB_PATH),
/* harmony export */   "LOCAL_SESSION_AUTOSAVE": () => (/* binding */ LOCAL_SESSION_AUTOSAVE),
/* harmony export */   "LOCAL_SESSION_ID": () => (/* binding */ LOCAL_SESSION_ID),
/* harmony export */   "LOCATION_NOT_FOUND": () => (/* binding */ LOCATION_NOT_FOUND),
/* harmony export */   "LOCATION_PATTERN": () => (/* binding */ LOCATION_PATTERN),
/* harmony export */   "PLAYGROUND_VIEW": () => (/* binding */ PLAYGROUND_VIEW),
/* harmony export */   "PREPROCESSOR_VIEW": () => (/* binding */ PREPROCESSOR_VIEW),
/* harmony export */   "PROGRAM_VIEW": () => (/* binding */ PROGRAM_VIEW),
/* harmony export */   "RAW_KEYWORD": () => (/* binding */ RAW_KEYWORD),
/* harmony export */   "SUPPORTED_VIEWS": () => (/* binding */ SUPPORTED_VIEWS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/path/path */ "U50j");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/router */ "va7o");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! connected-react-router */ "qLko");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-router */ "vpSu");
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var react_semantic_toasts_styles_react_semantic_alert_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-semantic-toasts/styles/react-semantic-alert.css */ "/lOe");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__]);
_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];












// hack to resolve unexisting files
const fetchVirtual = (fname) => {
    if (fname === _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(DEFAULT_FILENAME))
        return { status: 200, async text() { return `/* created: ${new Date()} */\n\n`; } };
    return null;
};
const readFile = fname => {
    return fetchVirtual(fname) || fetch(fname);
};
const fetchSourceFileLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_9__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_REQUEST,
    latest: true,
    async process({ getState, action }, dispatch, done) {
        // drop autosave params
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_DROP_STATE });
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.PLAYGROUND_EFFECT_HAS_BEEN_DROPPED, payload: {} });
        const filename = action.payload.filename;
        try {
            const response = await readFile(filename);
            if (response.status !== 200) {
                console.warn(`Could not find file ${filename}.`);
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_LOADING_FAILED, payload: {} });
            }
            else {
                const ext = _lib_path_path__WEBPACK_IMPORTED_MODULE_0__.ext(filename);
                const content = await response.text();
                if (ext === 'xfx') {
                    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.GRAPH_LOADED, payload: { filename, content } });
                }
                else {
                    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_LOADED, payload: { filename, content } });
                }
            }
        }
        catch (error) {
            console.warn(`Could not find file ${filename}.`);
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_LOADING_FAILED, payload: { error } });
        }
        finally {
            done();
        }
    }
});
const LOCATION_NOT_FOUND = '/NotFound';
const LOCATION_PATTERN = '/:view/:fx?/:name?/:pass?/:property?';
const DEFAULT_FILENAME = 'unnamed';
const PLAYGROUND_VIEW = 'playground';
const BYTECODE_VIEW = 'bytecode';
const PROGRAM_VIEW = 'program';
const AST_VIEW = 'ast';
const PREPROCESSOR_VIEW = 'preprocessor';
const GRAPH_VIEW = 'graph';
const RAW_KEYWORD = '@preprocessed';
const CODE_KEYWORD = '@formatted';
const GRAPH_KEYWORD = '@graph';
const LOCAL_SESSION_ID = 'last-session-id';
const LOCAL_SESSION_AUTOSAVE = 'local-session-autosave';
const EXT_FILTER = ['.fx', '.xfx', '.vsh', '.psh', '.csh', '.vs', '.ps', '.hlsl'];
const ASSETS_PATH = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__.isElectron() ? './assets' : '/assets';
const LIB_PATH = `${ASSETS_PATH}/graph`; // todo: move to more suitable place
// manifest.json is auto generated file created by webpack.sandbox
let ASSETS_MANIFEST = await (await fetch(`${ASSETS_PATH}/manifest.json`)).json();
const SUPPORTED_VIEWS = [PLAYGROUND_VIEW, BYTECODE_VIEW, PROGRAM_VIEW, AST_VIEW, PREPROCESSOR_VIEW, GRAPH_VIEW];
const navigationLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_9__["default"])({
    type: connected_react_router__WEBPACK_IMPORTED_MODULE_10__.LOCATION_CHANGE,
    latest: true,
    debounce: 10,
    async process({ getState, action }, dispatch, done) {
        const location = action.payload.location.pathname;
        const { sourceFile, depot } = getState();
        const defaultFilename = localStorage.getItem(LOCAL_SESSION_ID) || DEFAULT_FILENAME;
        if (location === '/') {
            if (defaultFilename !== DEFAULT_FILENAME)
                setTimeout(() => {
                    (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_7__.toast)({
                        type: 'warning',
                        title: `Last session`,
                        description: `Last session has been loaded.`,
                        animation: 'fade up',
                        time: 2000
                    });
                }, 2000);
            _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(`/${PLAYGROUND_VIEW}/${defaultFilename}`);
            return done();
        }
        const match = (0,react_router__WEBPACK_IMPORTED_MODULE_11__.matchPath)(location, {
            path: LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx, name } = match.params;
            const supportedViews = SUPPORTED_VIEWS;
            if (supportedViews.indexOf(view) !== -1) {
                if (!fx) {
                    _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(`/${view}/${DEFAULT_FILENAME}`);
                    return done();
                }
                const fxRequest = await _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_5__.resolveName(depot, fx);
                if (sourceFile.uri !== fxRequest) {
                    dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.sourceCode.openFile(fxRequest));
                }
            }
            return done();
        }
        if (location !== LOCATION_NOT_FOUND) {
            _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(LOCATION_NOT_FOUND);
        }
        done();
    }
});
/**
 * Redirect to default source (DEFAULT_FILENAME) if requested file was not found.
 */
const sourceFileNotFoundLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_9__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_3__.SOURCE_FILE_LOADING_FAILED,
    async process({ getState }, dispatch, done) {
        const location = getState().router.location.pathname;
        const match = (0,react_router__WEBPACK_IMPORTED_MODULE_11__.matchPath)(location, {
            path: LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx } = match.params;
            if (!fx) {
                // something went wrong
                _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(`/${view}/${DEFAULT_FILENAME}`);
            }
            else {
                // show special page if request fx is not found
                _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(LOCATION_NOT_FOUND);
            }
        }
        return done();
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    fetchSourceFileLogic,
    navigationLogic,
    sourceFileNotFoundLogic
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "/KxH":
/*!************************************!*\
  !*** ./src/sandbox/logic/depot.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "Q/He");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ "Ctio");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/common */ "cOQ3");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common__WEBPACK_IMPORTED_MODULE_5__]);
_common__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];








async function feedFakeDepot(root) {
    let demos = depotNode();
    demos.files = Object.values(_common__WEBPACK_IMPORTED_MODULE_5__.ASSETS_MANIFEST.fx.demos)
        .filter(file => (0,_lib_common__WEBPACK_IMPORTED_MODULE_6__.isString)(file))
        .map(file => `/${file}`)
        .sort();
    demos.path = '/demos';
    demos.totalFiles = demos.files.length;
    let graph = depotNode();
    graph.files = Object.values(_common__WEBPACK_IMPORTED_MODULE_5__.ASSETS_MANIFEST.graph)
        .filter(file => (0,_lib_common__WEBPACK_IMPORTED_MODULE_6__.isString)(file))
        .map(file => `/${file}`)
        .sort();
    graph.path = '/graph';
    graph.totalFiles = graph.files.length;
    root.folders = [demos, graph];
    root.path = '/';
    root.totalFiles = demos.totalFiles + graph.totalFiles;
}
function scan(dir, node, filters, excludes) {
    try {
        node.path = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(dir);
        let stats = fs__WEBPACK_IMPORTED_MODULE_3__.statSync(dir);
        if (!stats.isDirectory()) {
            return;
        }
        if (excludes?.includes(path__WEBPACK_IMPORTED_MODULE_4__.basename(dir))) {
            return;
        }
        fs__WEBPACK_IMPORTED_MODULE_3__.readdirSync(dir).forEach(async (filename) => {
            let filepath = path__WEBPACK_IMPORTED_MODULE_4__.join(dir, filename);
            let filestats = fs__WEBPACK_IMPORTED_MODULE_3__.statSync(filepath);
            if (filestats.isFile()) {
                if (!filters || filters.indexOf(path__WEBPACK_IMPORTED_MODULE_4__.extname(filename)) != -1) {
                    node.files = node.files || [];
                    node.files.push(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(filepath));
                    node.totalFiles++;
                }
            }
            if (filestats.isDirectory()) {
                node.folders = node.folders || [];
                let subfolder = { path: _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(filepath), totalFiles: 0 };
                scan(filepath, subfolder, filters, excludes);
                node.folders.push(subfolder);
                node.totalFiles += subfolder.totalFiles;
            }
        });
    }
    catch (e) {
        console.log(e);
    }
}
const depotNode = () => ({ path: null, files: [], folders: [], totalFiles: 0 });
function currentPath() {
    // mac locations looks like:
    //  '/influx/dist/electron/sandbox-electron.html'
    if (window.navigator.platform.includes('Mac')) {
        return window.location.pathname;
    }
    // windows locations looks like:
    //  '/C:/Influx/dist/electron/sandbox-electron.html'
    return window.location.pathname.substr(1);
}
const depotUpdateRequestLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_7__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.DEPOT_UPDATE_REQUEST,
    latest: true,
    async process({ getState, action }, dispatch, done) {
        const { s3d: { env } } = getState();
        const root = depotNode();
        const sandboxPath = path__WEBPACK_IMPORTED_MODULE_4__.dirname(currentPath());
        if (!_sandbox_ipc__WEBPACK_IMPORTED_MODULE_2__.isElectron()) {
            await feedFakeDepot(root);
        }
        else {
            if (env) {
                let sfxFolder = depotNode();
                await scan(env.Get('influx-sfx-dir'), sfxFolder, _common__WEBPACK_IMPORTED_MODULE_5__.EXT_FILTER);
                let shaderFolder = depotNode();
                await scan(env.Get('sdrproj-dir'), shaderFolder, _common__WEBPACK_IMPORTED_MODULE_5__.EXT_FILTER, ['maya_fx', 'deploy_test', 'nrd']);
                let libFolder = depotNode();
                let sandboxLibPath = path__WEBPACK_IMPORTED_MODULE_4__.join(sandboxPath, _common__WEBPACK_IMPORTED_MODULE_5__.LIB_PATH);
                await scan(sandboxLibPath, libFolder, _common__WEBPACK_IMPORTED_MODULE_5__.EXT_FILTER);
                root.path = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(path__WEBPACK_IMPORTED_MODULE_4__.dirname(env.Get('project-dir')));
                root.folders = [sfxFolder, shaderFolder, libFolder];
                root.totalFiles = sfxFolder.totalFiles + shaderFolder.totalFiles;
            }
            else {
                let rootPath = path__WEBPACK_IMPORTED_MODULE_4__.join(sandboxPath, `${_common__WEBPACK_IMPORTED_MODULE_5__.ASSETS_PATH}/fx/demos`);
                await scan(rootPath, root, _common__WEBPACK_IMPORTED_MODULE_5__.EXT_FILTER);
            }
            root.files.push(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_1__.fromLocalPath(_common__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_FILENAME));
        }
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.DEPOT_UPDATE_COMPLETE, payload: { root } });
        done();
    }
});
const depotUpdateCompleteLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_7__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.DEPOT_UPDATE_COMPLETE,
    async process({ getState, action }, dispatch, done) {
        // ...
        done();
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    depotUpdateRequestLogic,
    depotUpdateCompleteLogic
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "5FPh":
/*!****************************************!*\
  !*** ./src/sandbox/logic/fxRuntime.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bundles_Bundle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bundles/Bundle */ "BNML");
/* harmony import */ var _lib_fx_bundles_Bundle11__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bundles/Bundle11 */ "uI6s");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/techniques */ "LvoO");
/* harmony import */ var _lib_path_path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/path/path */ "U50j");
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var _lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lib/fx/bundles/utils */ "GUxJ");
/* harmony import */ var _sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sandbox/reducers/translatorParams */ "RSd/");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var react_semantic_toasts_styles_react_semantic_alert_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! react-semantic-toasts/styles/react-semantic-alert.css */ "/lOe");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bundles_Bundle__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bundles_Bundle11__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__]);
([_lib_fx_bundles_Bundle__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bundles_Bundle11__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// tslint:disable:no-for-in
// tslint:disable:forin


















function downloadByteBuffer(data, fileName, mimeType) {
    downloadBlob(new Blob([data], { type: mimeType }), fileName);
}
;
function downloadBlob(blob, fileName) {
    let url;
    url = window.URL.createObjectURL(blob);
    downloadURL(url, fileName);
    setTimeout(() => window.URL.revokeObjectURL(url), 1000);
}
;
function downloadURL(data, fileName) {
    let a;
    a = document.createElement('a');
    a.href = data;
    a.download = fileName;
    document.body.appendChild(a);
    a.style = 'display: none';
    a.click();
    a.remove();
}
;
async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
const playgroundUpdateLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_17__["default"])({
    type: [
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.SOURCE_CODE_ANALYSIS_COMPLETE,
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SELECT_EFFECT,
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SWITCH_VM_RUNTIME,
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME
    ],
    async process({ getState, action }, dispatch, done) {
        const state = getState();
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__.getFileState)(state);
        const playground = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.getPlaygroundState)(state);
        const timeline = playground.timeline;
        const depot = _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_9__.getDepot(state);
        const translator = (0,_sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_13__.asFxTranslatorOprions)(state);
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__.getScope)(file);
        /** @deprecated */
        const list = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.filterTechniques)(scope);
        const list11 = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.filterTechniques11)(scope);
        let active = action.type === _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SELECT_EFFECT ? action.payload.name : null;
        let technique = playground.technique;
        let controls = playground.controls;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(technique) && (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(active)) {
            if (list.map(fx => fx.name).indexOf(technique.getName()) !== -1) {
                active = technique.getName();
            }
        }
        /** @deprecated */
        if (!active) {
            for (const fx of list) {
                if (fx.isValid()) {
                    active = fx.name;
                    break;
                }
            }
        }
        if (!active) {
            for (const fx of list11) {
                if (fx.isValid()) {
                    active = fx.name;
                    break;
                }
            }
        }
        async function destroy(technique) {
            _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.destroyTechnique(technique);
            // verbose('previous technique has been dropped.');
        }
        async function copy(next, prev) {
            _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.copyTechnique(next, prev);
        }
        async function create11(forceRestart = true) {
            const i = list11.map(fx => fx.name).indexOf(active);
            if (i == -1) {
                return [null, null];
            }
            const bundle = await _lib_fx_bundles_Bundle11__WEBPACK_IMPORTED_MODULE_2__.createBundle(list11[i], { translator });
            const tech = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.createTechnique(bundle);
            const controls = (0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_12__.decodeBundleControls)(bundle);
            if (tech) {
                if (forceRestart)
                    timeline.start();
                // verbose('next technique has been created.');
            }
            return [tech, controls];
        }
        /** @deprecated */
        async function create(forceRestart = true) {
            const i = list.map(fx => fx.name).indexOf(active);
            if (i == -1) {
                return create11(forceRestart);
            }
            const bundle = await _lib_fx_bundles_Bundle__WEBPACK_IMPORTED_MODULE_1__.createBundle(list[i], { translator, omitHLSL: true });
            const tech = _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.createTechnique(bundle);
            const controls = (0,_lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_12__.decodeBundleControls)(bundle);
            if (tech) {
                if (forceRestart)
                    timeline.start();
                // verbose('next technique has been created.');
            }
            return [tech, controls];
        }
        async function drop() {
            await destroy(technique);
            [technique, controls] = [null, null];
        }
        async function forceReload() {
            await destroy(technique);
            [technique, controls] = await create();
        }
        // fixme: move technique to playground
        async function $hackDestroyResources() {
            // IP: hack to notify plathground to destroy all the resources
            // literally set null technique and thus call release of all dependent resources
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_TECHNIQUE_UPDATE, payload: { technique, controls } });
            await sleep(10);
            return;
        }
        async function switchVMRuntime() {
            await drop(); // destroy current technique
            await $hackDestroyResources(); // wait for release of all it's resources
            _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__.switchRuntime();
            [technique, controls] = await create();
        }
        async function switchTechniqueRuntime() {
            await drop(); // destroy current technique
            await $hackDestroyResources(); // wait for release of all it's resources
            _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_4__.switchRuntime();
            [technique, controls] = await create();
        }
        async function softReload() {
            if (!technique) {
                await forceReload();
                return;
            }
            // controls stay unchanged
            let [next, ctrlsNext] = await create(false);
            let prev = technique;
            await copy(next, prev);
            await destroy(prev);
            technique = next;
            controls = ctrlsNext;
        }
        switch (action.type) {
            case _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SWITCH_VM_RUNTIME:
                await switchVMRuntime();
                break;
            case _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME:
                await switchTechniqueRuntime();
                break;
            default:
                if (!file.slDocument || file.slDocument.diagnosticReport.errors > 0) {
                    await drop();
                }
                else {
                    await softReload();
                }
        }
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_TECHNIQUE_UPDATE, payload: { technique, controls } });
        if (playground.autosave) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST, payload: {} });
        }
        // construct default export name if possible
        if (!playground.exportName) {
            const uri = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.parse(file.uri);
            if (uri.protocol == 'file') {
                const filename = _lib_path_path__WEBPACK_IMPORTED_MODULE_5__.parse(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.toLocalPath(uri)).replaceExt('bfx');
                // dispatch fake event to update export name
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_HAS_BEEN_SAVED, payload: { filename: _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.fromLocalPath(filename) } });
            }
        }
        done();
    }
});
const playgroundSaveFileAsLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_17__["default"])({
    type: [
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_SAVE_REQUEST
    ],
    async process({ getState, action }, dispatch, done) {
        const state = getState();
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__.getFileState)(state);
        const playground = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.getPlaygroundState)(state);
        const scope = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__.getScope)(file);
        const list = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.filterTechniques)(scope);
        const translator = (0,_sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_13__.asFxTranslatorOprions)(state);
        const tech = playground.technique;
        const exportName = _lib_path_path__WEBPACK_IMPORTED_MODULE_5__.parse(file.uri);
        exportName.ext = "bfx"; // binary fx
        // download packed version of single (! active only !) technique
        // -----------------------------------
        let options = {
            packed: true,
            meta: {
                source: file.uri,
                author: state.s3d?.p4?.['User name']
            },
            omitGLSL: false,
            omitHLSL: false,
            translator
        };
        const techInstr = list.find((fx => fx.name == tech.getName()));
        const data = await _lib_fx_bundles_Bundle__WEBPACK_IMPORTED_MODULE_1__.createBundle(techInstr, options, (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_11__.asConvolutionPack)(state));
        // download unpacked version
        // -----------------------------------
        // const bundles = new BundleCollectionT(await Promise.all(list.map(async fx => await FxBundle.createPartFxBundle(fx))));
        // let fbb = new flatbuffers.Builder(1);
        // let size = bundles.pack(fbb);
        if (_sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__.isElectron()) {
            let filename = null;
            // reqest to make silent auto save using known local file path
            if (action.payload.silent) {
                filename = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__.sync.saveFile(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.toLocalPath(playground.exportName), data);
            }
            else {
                filename = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__.sync.saveFileDialog({
                    defaultPath: _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.toLocalPath(playground.exportName),
                    title: "Save binary FX",
                    buttonLabel: "Save",
                    filters: [
                        { name: 'Binary FX', extensions: ['bfx'] },
                    ]
                }, data);
            }
            if (filename) {
                // URI.fromLocalPath(fromLocalPath)
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_HAS_BEEN_SAVED, payload: { filename: _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.fromLocalPath(filename) } });
                (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`Effect '${filename}' has been exported successfully.`);
                (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_15__.toast)({
                    size: 'tiny',
                    type: 'info',
                    title: `${action.payload.silent ? 'Autoexport' : 'Export'} complete`,
                    description: `Effect '${filename}' has been exported successfully.`,
                    animation: 'bounce',
                    time: 2000
                });
            }
        }
        // web browser
        else {
            // download packed version of single (! active only !) technique
            // -----------------------------------
            downloadByteBuffer(data, exportName.basename, 'application/octet-stream');
            // download unpacked version
            // -----------------------------------
            // downloadByteBuffer(fbb.asUint8Array(), exportName.basename, 'application/octet-stream');   
        }
        let fxDir = state.s3d?.env?.Get('fx-dir');
        if (fxDir) {
            let fileName = path__WEBPACK_IMPORTED_MODULE_14___default().basename(playground.exportName);
            let sourcePath = fxDir + '\\' + fileName;
            let sourceResourcePath = sourcePath + '.resource';
            let destinationPath = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.toLocalPath(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.fromLocalPath(sourcePath));
            let destinationResourcePath = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.toLocalPath(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_6__.fromLocalPath(sourceResourcePath));
            _sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__.sync.saveFile(destinationPath, data);
            _sandbox_ipc__WEBPACK_IMPORTED_MODULE_8__.sync.saveFile(destinationResourcePath, '__type: res_desc_bfx\nlinks: []\nbfx: ' + fileName + '\n');
        }
        done();
    }
});
// on technique update complete
const playgroundTechniqueUpdateLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_17__["default"])({
    type: [
        _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST
    ],
    latest: true,
    debounce: 1000,
    async process({ getState, action }, dispatch, done) {
        const playground = (0,_sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__.getPlaygroundState)(getState());
        if (playground.exportName && playground.technique) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_SAVE_REQUEST, payload: { silent: true } });
        }
        done();
    }
});
// on technique update complete
const playgroundSetOptionAutosave = (0,redux_logic__WEBPACK_IMPORTED_MODULE_17__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_SET_OPTION_AUTOSAVE],
    latest: true,
    debounce: 100,
    async process({ getState, action }, dispatch, done) {
        if (action.payload.enabled) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.PLAYGROUND_EFFECT_AUTOSAVE_REQUEST, payload: {} });
        }
        done();
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    playgroundUpdateLogic,
    playgroundSaveFileAsLogic,
    playgroundTechniqueUpdateLogic,
    playgroundSetOptionAutosave
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "q0SN":
/*!**************************************!*\
  !*** ./src/sandbox/logic/nodesEx.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "packGraphToJSON": () => (/* binding */ packGraphToJSON),
/* harmony export */   "unpackGraphFromJSON": () => (/* binding */ unpackGraphFromJSON)
/* harmony export */ });
/* harmony import */ var _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/analisys/helpers */ "pEQR");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "sg/z");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/translators/FxEmitter */ "h9Zj");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
/* harmony import */ var _lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/util/s3d/type */ "z3nI");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/reducers/router */ "va7o");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! react-router-dom */ "vpSu");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./common */ "Ctio");
/* harmony import */ var _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lib/fx/translators/CodeEmitter */ "GU3W");
/* harmony import */ var _sandbox_components_graphEx_utils_docs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sandbox/components/graphEx/utils/docs */ "Qk0k");
/* harmony import */ var _sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sandbox/components/graphEx/common */ "sVSU");
/* harmony import */ var _sandbox_components_graphEx_BasicType__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sandbox/components/graphEx/BasicType */ "1t3V");
/* harmony import */ var _sandbox_components_graphEx_Decomposer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sandbox/components/graphEx/Decomposer */ "nqVC");
/* harmony import */ var _sandbox_components_graphEx_Float__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @sandbox/components/graphEx/Float */ "cAsR");
/* harmony import */ var _sandbox_components_graphEx_FuncNodes__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @sandbox/components/graphEx/FuncNodes */ "B6UE");
/* harmony import */ var _sandbox_components_graphEx_IfStmt__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sandbox/components/graphEx/IfStmt */ "jEKi");
/* harmony import */ var _sandbox_components_graphEx_Int__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @sandbox/components/graphEx/Int */ "0N+1");
/* harmony import */ var _sandbox_components_graphEx_Operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sandbox/components/graphEx/Operators */ "dJ4L");
/* harmony import */ var _sandbox_components_graphEx_StmtList__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sandbox/components/graphEx/StmtList */ "Ca6S");
/* harmony import */ var _sandbox_components_graphEx_Uniforms__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @sandbox/components/graphEx/Uniforms */ "teaP");
/* harmony import */ var _sandbox_components_graphEx_fx_DefaultMaterial__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/DefaultMaterial */ "pqmu");
/* harmony import */ var _sandbox_components_graphEx_fx_Kill__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/Kill */ "H+Dh");
/* harmony import */ var _sandbox_components_graphEx_fx_KillBy__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/KillBy */ "7U7x");
/* harmony import */ var _sandbox_components_graphEx_fx_LwiMaterial__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/LwiMaterial */ "zLQT");
/* harmony import */ var _sandbox_components_graphEx_fx_Param__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/Param */ "Ts+a");
/* harmony import */ var _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/Part */ "Xmng");
/* harmony import */ var _sandbox_components_graphEx_fx_PartId__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/PartId */ "H1jh");
/* harmony import */ var _sandbox_components_graphEx_fx_PartInit__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/PartInit */ "4Und");
/* harmony import */ var _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/PartPrevious */ "cIOx");
/* harmony import */ var _sandbox_components_graphEx_fx_PartSpawn__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/PartSpawn */ "mGRc");
/* harmony import */ var _sandbox_components_graphEx_fx_PartUpdate__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/PartUpdate */ "0j9O");
/* harmony import */ var _sandbox_components_graphEx_fx_UserConst__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @sandbox/components/graphEx/fx/UserConst */ "FzSB");
/* harmony import */ var _sandbox_components_graphEx_lib_template_json__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @sandbox/components/graphEx/lib/template.json */ "0xhk");
/* harmony import */ var _sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @sandbox/reducers/nodes */ "qLCU");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__, _common__WEBPACK_IMPORTED_MODULE_10__, _sandbox_components_graphEx_utils_docs__WEBPACK_IMPORTED_MODULE_12__, _sandbox_components_graphEx_BasicType__WEBPACK_IMPORTED_MODULE_14__, _sandbox_components_graphEx_Decomposer__WEBPACK_IMPORTED_MODULE_15__, _sandbox_components_graphEx_Float__WEBPACK_IMPORTED_MODULE_16__, _sandbox_components_graphEx_FuncNodes__WEBPACK_IMPORTED_MODULE_17__, _sandbox_components_graphEx_IfStmt__WEBPACK_IMPORTED_MODULE_18__, _sandbox_components_graphEx_Int__WEBPACK_IMPORTED_MODULE_19__, _sandbox_components_graphEx_Operators__WEBPACK_IMPORTED_MODULE_20__, _sandbox_components_graphEx_StmtList__WEBPACK_IMPORTED_MODULE_21__, _sandbox_components_graphEx_Uniforms__WEBPACK_IMPORTED_MODULE_22__, _sandbox_components_graphEx_fx_DefaultMaterial__WEBPACK_IMPORTED_MODULE_23__, _sandbox_components_graphEx_fx_Kill__WEBPACK_IMPORTED_MODULE_24__, _sandbox_components_graphEx_fx_KillBy__WEBPACK_IMPORTED_MODULE_25__, _sandbox_components_graphEx_fx_LwiMaterial__WEBPACK_IMPORTED_MODULE_26__, _sandbox_components_graphEx_fx_Param__WEBPACK_IMPORTED_MODULE_27__, _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__, _sandbox_components_graphEx_fx_PartId__WEBPACK_IMPORTED_MODULE_29__, _sandbox_components_graphEx_fx_PartInit__WEBPACK_IMPORTED_MODULE_30__, _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__, _sandbox_components_graphEx_fx_PartSpawn__WEBPACK_IMPORTED_MODULE_32__, _sandbox_components_graphEx_fx_PartUpdate__WEBPACK_IMPORTED_MODULE_33__, _sandbox_components_graphEx_fx_UserConst__WEBPACK_IMPORTED_MODULE_34__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__, _common__WEBPACK_IMPORTED_MODULE_10__, _sandbox_components_graphEx_utils_docs__WEBPACK_IMPORTED_MODULE_12__, _sandbox_components_graphEx_BasicType__WEBPACK_IMPORTED_MODULE_14__, _sandbox_components_graphEx_Decomposer__WEBPACK_IMPORTED_MODULE_15__, _sandbox_components_graphEx_Float__WEBPACK_IMPORTED_MODULE_16__, _sandbox_components_graphEx_FuncNodes__WEBPACK_IMPORTED_MODULE_17__, _sandbox_components_graphEx_IfStmt__WEBPACK_IMPORTED_MODULE_18__, _sandbox_components_graphEx_Int__WEBPACK_IMPORTED_MODULE_19__, _sandbox_components_graphEx_Operators__WEBPACK_IMPORTED_MODULE_20__, _sandbox_components_graphEx_StmtList__WEBPACK_IMPORTED_MODULE_21__, _sandbox_components_graphEx_Uniforms__WEBPACK_IMPORTED_MODULE_22__, _sandbox_components_graphEx_fx_DefaultMaterial__WEBPACK_IMPORTED_MODULE_23__, _sandbox_components_graphEx_fx_Kill__WEBPACK_IMPORTED_MODULE_24__, _sandbox_components_graphEx_fx_KillBy__WEBPACK_IMPORTED_MODULE_25__, _sandbox_components_graphEx_fx_LwiMaterial__WEBPACK_IMPORTED_MODULE_26__, _sandbox_components_graphEx_fx_Param__WEBPACK_IMPORTED_MODULE_27__, _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__, _sandbox_components_graphEx_fx_PartId__WEBPACK_IMPORTED_MODULE_29__, _sandbox_components_graphEx_fx_PartInit__WEBPACK_IMPORTED_MODULE_30__, _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__, _sandbox_components_graphEx_fx_PartSpawn__WEBPACK_IMPORTED_MODULE_32__, _sandbox_components_graphEx_fx_PartUpdate__WEBPACK_IMPORTED_MODULE_33__, _sandbox_components_graphEx_fx_UserConst__WEBPACK_IMPORTED_MODULE_34__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);















// import all factories
























async function loadEnv(layout) {
    // todo: don't reload library every time
    const includeResolver = async (name) => (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)(name, await (await fetch(name)).text());
    const libraryPath = `${_common__WEBPACK_IMPORTED_MODULE_10__.LIB_PATH}/lib.hlsl`;
    const libText = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)("", `#include "${libraryPath}"`);
    const lib = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_1__.createFXSLDocument)(libText, { includeResolver });
    // extract and fill graph node documentation database
    // todo: move to statics
    (0,_sandbox_components_graphEx_utils_docs__WEBPACK_IMPORTED_MODULE_12__["default"])(libText);
    const partTex = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)('://part-layout', layout);
    return (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_1__.extendFXSLDocument)(partTex, lib, null, { includeResolver });
}
function packGraphToJSON(state) {
    const { nodes: { graph, env, constants, capacity }, sourceFile } = state;
    const type = env.root.scope.findType(_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_TYPE);
    const layout = _lib_fx_translators_CodeEmitter__WEBPACK_IMPORTED_MODULE_11__.CodeEmitter.translate(type);
    const source = sourceFile.content;
    const content = {
        layout,
        graph: graph.serialize(),
        constants,
        capacity,
        source
    };
    const fx = { type: 'part', content };
    return JSON.stringify(fx, null, '    ');
}
function unpackGraphFromJSON(data) {
    let json = null;
    try {
        json = JSON.parse(data);
    }
    catch (e) {
        console.error('could not parse XFX data');
        json = _sandbox_components_graphEx_lib_template_json__WEBPACK_IMPORTED_MODULE_35__;
    }
    console.assert(json.type === 'part');
    return json.content;
}
function produceNodes(env, ...list) {
    let nodeList = {};
    list.forEach(prod => { nodeList = { ...nodeList, ...prod(env) }; });
    return nodeList;
}
//
// 
//
const graphLoadedLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_LOADED],
    latest: true,
    debounce: 500,
    async transform({ getState, action }, next) {
        const unpacked = unpackGraphFromJSON(action.payload.content);
        action.payload.env = await loadEnv(unpacked.layout);
        action.payload.constants = unpacked.constants || [];
        action.payload.capacity = unpacked.capacity || 4096;
        // pass unpacked json as meta so as not to double the unpacking
        next({ ...action, meta: unpacked });
    },
    async process({ getState, action, action$ }, dispatch, done) {
        // const uri = getState().sourceFile.uri;
        const graph = getState().nodes.graph;
        const { graph: content } = action.meta;
        const { env, constants } = action.payload;
        console.assert((0,_lib_util_s3d_type__WEBPACK_IMPORTED_MODULE_5__.isDefAndNotNull)(env));
        graph.clear();
        // todo: unregister previous nodes
        // reload graph infrastructure
        // produce nodes
        let nodeList = produceNodes(() => (0,_sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_36__.getEnv)(getState()), _sandbox_components_graphEx_Operators__WEBPACK_IMPORTED_MODULE_20__["default"], _sandbox_components_graphEx_Float__WEBPACK_IMPORTED_MODULE_16__["default"], _sandbox_components_graphEx_Int__WEBPACK_IMPORTED_MODULE_19__["default"], _sandbox_components_graphEx_IfStmt__WEBPACK_IMPORTED_MODULE_18__["default"], _sandbox_components_graphEx_FuncNodes__WEBPACK_IMPORTED_MODULE_17__["default"], _sandbox_components_graphEx_BasicType__WEBPACK_IMPORTED_MODULE_14__["default"], _sandbox_components_graphEx_fx_Kill__WEBPACK_IMPORTED_MODULE_24__["default"], _sandbox_components_graphEx_fx_KillBy__WEBPACK_IMPORTED_MODULE_25__["default"], _sandbox_components_graphEx_Decomposer__WEBPACK_IMPORTED_MODULE_15__["default"], _sandbox_components_graphEx_Uniforms__WEBPACK_IMPORTED_MODULE_22__["default"], _sandbox_components_graphEx_StmtList__WEBPACK_IMPORTED_MODULE_21__["default"], _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__["default"], _sandbox_components_graphEx_fx_PartId__WEBPACK_IMPORTED_MODULE_29__["default"], _sandbox_components_graphEx_fx_PartUpdate__WEBPACK_IMPORTED_MODULE_33__["default"], _sandbox_components_graphEx_fx_PartSpawn__WEBPACK_IMPORTED_MODULE_32__["default"], _sandbox_components_graphEx_fx_PartInit__WEBPACK_IMPORTED_MODULE_30__["default"], _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__["default"], _sandbox_components_graphEx_fx_LwiMaterial__WEBPACK_IMPORTED_MODULE_26__["default"], _sandbox_components_graphEx_fx_DefaultMaterial__WEBPACK_IMPORTED_MODULE_23__["default"], _sandbox_components_graphEx_fx_Param__WEBPACK_IMPORTED_MODULE_27__["default"]);
        nodeList = { ...nodeList, ...(0,_sandbox_components_graphEx_fx_UserConst__WEBPACK_IMPORTED_MODULE_34__["default"])(() => (0,_sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_36__.getEnv)(getState()), constants) };
        litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.clearRegisteredTypes();
        // register all available nodes
        Object.keys(nodeList).forEach(link => litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.registerNodeType(link, nodeList[link]));
        // load serialized graph
        // todo: validate that all serialized nodes are available
        graph.configure(content);
        dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__.nodes.recompile());
        const location = getState().router.location.pathname;
        const match = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_38__.matchPath)(location, {
            path: _common__WEBPACK_IMPORTED_MODULE_10__.LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { fx, view } = match.params;
            _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_8__.history.push(`/${view}/${fx}/${_common__WEBPACK_IMPORTED_MODULE_10__.GRAPH_KEYWORD}`);
        }
        done();
    }
});
function makeFxTemplate(env, plug) {
    let passes = plug.passes.map((plug, i) => `   pass P${i} {
        Sorting = ${plug.sorting};
        PrerenderRoutine = compile PrerenderRoutine${plug.id}();
        Geometry = "${plug.geometry.toLowerCase()}";
    }`).join("\n\n");
    return (`
partFx G {
    Capacity = ${plug.capacity};
    SpawnRoutine = compile SpawnRoutine();
    InitRoutine = compile InitRoutine${plug.initId}();
    UpdateRoutine = compile UpdateRoutine();

${passes}
}

`);
}
const compileLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_COMPILE],
    latest: true,
    debounce: 500,
    async process({ getState, action }, dispatch, done) {
        const state = getState();
        const { nodes } = state;
        const { graph, env, constants, capacity } = nodes;
        // IP: hack to find all spawners/initializer by type
        const InitInstance = litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.registered_node_types["fx/InitRoutine"];
        let spawn = graph.findNodeByTitle("SpawnRoutine");
        let update = graph.findNodeByTitle("UpdateRoutine");
        let inits = graph.findNodesByClass(InitInstance);
        let prerender = [];
        prerender = [...prerender, ...graph.findNodesByTitle("DefaultMaterial")];
        prerender = [...prerender, ...graph.findNodesByTitle("LwiMaterial")];
        let constDoc = null;
        if (constants.length) {
            constDoc = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)('://user-constants', constants.map(({ name, type, value }) => `static const ${type} ${name} = ${value};`).join('\n') + '\n\n');
        }
        let doc = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_1__.extendFXSLDocument)(constDoc, env);
        doc = await spawn.run(doc);
        for (let init of inits) {
            doc = await init.run(doc);
        }
        doc = await update.run(doc);
        let plugs = [];
        for (let i in prerender) {
            let { id, sorting, geometry } = prerender[i];
            doc = await prerender[i].run(doc);
            plugs.push({ id, sorting, geometry });
        }
        doc = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_1__.extendFXSLDocument)(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_2__.createTextDocument)("://fx-template", makeFxTemplate(env, { passes: plugs, initId: inits.find(init => init.pure).id, capacity })), doc);
        let content = _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_4__.Diagnostics.stringify(doc.diagnosticReport);
        console.log(content);
        graph.list_of_graphcanvas.forEach(canvas => canvas.draw(true, true));
        dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__.sourceCode.setContent(_lib_fx_translators_FxEmitter__WEBPACK_IMPORTED_MODULE_3__.FxEmitter.translateTechnique(doc, 'G')));
        done();
    }
});
const changeLayoutLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_CHANGE_LAYOUT],
    async validate({ getState, action }, allow, reject) {
        let envNew;
        let typeNew;
        try {
            envNew = await loadEnv(action.payload.layout);
            typeNew = envNew.root.scope.findType(_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_TYPE);
            if (!typeNew) {
                reject({ type: 'graph-change-layout-error' });
                return;
            }
        }
        catch (e) {
            reject({ type: 'graph-change-layout-error' });
            return;
        }
        const { env, graph } = getState().nodes;
        const type = env.root.scope.findType(_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_TYPE);
        //
        // Aux
        //
        function nodeRebuilder(type) {
            return graph.findNodesByType(type).map(node => {
                let [x, y] = node.pos;
                graph.remove(node);
                return () => {
                    node = litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.createNode(type);
                    graph.add(node);
                    node.pos = [x, y];
                };
            });
        }
        ;
        function remove(type) {
            let cbs = nodeRebuilder(type);
            return () => cbs.forEach(cb => cb());
        }
        const restore = (cb) => cb();
        //
        // todo: skip if no changes
        // if (type.fields.length == typeNew.fields.length) {
        //     // no changes, nothing todo.
        //     console.warn('no layout changes found');
        //     allow({ ...action, payload: { env } });
        //     return;
        // }
        // same name but diff type
        const toRecreateField = type.fields
            .filter(p => typeNew.fields.find(n => n.name == p.name &&
            !_lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.compare(n.type, p.type)))
            .map(v => v.name);
        // name no more exists
        const toRemoveField = type.fields
            .filter(p => !typeNew.fields.find(n => n.name == p.name))
            .map(v => v.name);
        // same name and type but diff input index
        const toReconnectField = type.fields
            .filter((p, pi) => typeNew.fields.find((n, ni) => pi != ni &&
            n.name == p.name && _lib_fx_analisys_helpers__WEBPACK_IMPORTED_MODULE_0__.types.compare(n.type, p.type)))
            .map(v => v.name);
        // toCreate?
        console.log('remove:', toRemoveField);
        console.log('recreate:', toRecreateField);
        console.log('reconnect:', toReconnectField);
        //
        // Remove all no more existring nodes
        //
        toRemoveField.forEach(fieldName => {
            // sync with PartPrev.ts
            const name = `${_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_LOCAL_NAME}.${fieldName}`;
            let nodes = graph.findNodesByType(`fx/${name}`);
            nodes.forEach(node => graph.remove(node));
            nodes = graph.findNodesByType(`fx/out ${name}`);
            nodes.forEach(node => graph.remove(node));
        });
        //
        // Remove nodes with changed types and remember list of recreation routines
        //
        // sync with PartPrev.ts, PartInit.ts etc.
        let partRemoved = remove(`fx/${_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_LOCAL_NAME}`);
        let fieldsRemoved = toRecreateField.map(f => remove(`fx/${_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_LOCAL_NAME}.${f}`));
        let partRemovedOut = remove(`fx/out ${_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_LOCAL_NAME}`);
        let fieldsRemovedOut = toRecreateField.map(f => remove(`fx/out ${_sandbox_components_graphEx_common__WEBPACK_IMPORTED_MODULE_13__.PART_LOCAL_NAME}.${f}`));
        //
        // Unlink prev types
        //
        let nodeList = produceNodes(() => env, _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__["default"], // part in
        _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__["default"] // part out
        );
        Object.keys(nodeList).forEach(type => litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.unregisterNodeType(type));
        //
        // Link new types
        //
        nodeList = produceNodes(() => envNew, _sandbox_components_graphEx_fx_PartPrevious__WEBPACK_IMPORTED_MODULE_31__["default"], // part in
        _sandbox_components_graphEx_fx_Part__WEBPACK_IMPORTED_MODULE_28__["default"] // part out
        );
        Object.keys(nodeList).forEach(type => litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.registerNodeType(type, nodeList[type]));
        //
        // Process recreation routines
        //
        // todo: restore connections!
        restore(partRemoved);
        fieldsRemoved.forEach(field => restore(field));
        restore(partRemovedOut);
        fieldsRemovedOut.forEach(field => restore(field));
        allow({ ...action, payload: { env: envNew } });
    },
});
const addConstantlogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_ADD_CONSTANT],
    async process({ getState, action }, dispatch, done) {
        const { env, graph, constants } = getState().nodes;
        const nodeList = (0,_sandbox_components_graphEx_fx_UserConst__WEBPACK_IMPORTED_MODULE_34__["default"])(() => (0,_sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_36__.getEnv)(getState()), [action.payload.value]);
        Object.keys(nodeList).forEach(link => litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.registerNodeType(link, nodeList[link]));
        done();
    }
});
const removeConstantlogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_REMOVE_CONSTANT],
    async process({ getState, action }, dispatch, done) {
        const { env, graph, constants } = getState().nodes;
        const nodeType = `user constants/${action.payload.name}`;
        graph.findNodesByType(nodeType).forEach(node => graph.remove(node));
        litegraph_js__WEBPACK_IMPORTED_MODULE_9__.LiteGraph.unregisterNodeType(nodeType);
        done();
    }
});
const updateParamsLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_SET_CONSTANT, _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_SET_CAPACITY],
    async process({ getState, action }, dispatch, done) {
        dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_6__.nodes.recompile());
        done();
    }
});
const resetLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_37__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_7__.GRAPH_RESET],
    async process({ getState, action }, dispatch, done) {
        // const parserParams = getState().parserParams;
        console.log('graph reset!');
        done();
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    resetLogic,
    compileLogic,
    graphLoadedLogic,
    changeLayoutLogic,
    addConstantlogic,
    removeConstantlogic,
    updateParamsLogic
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "6LMl":
/*!**************************************!*\
  !*** ./src/sandbox/logic/parsing.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bytecode */ "0jsi");
/* harmony import */ var _lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/DebugLayout */ "prdm");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/fx/FXSLDocument */ "sg/z");
/* harmony import */ var _lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/fx/SLASTDocument */ "s/Ev");
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/SLParser */ "/oCY");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");
/* harmony import */ var _lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lib/parser/Preprocessor */ "nYIV");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! connected-react-router */ "qLko");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! react-router-dom */ "vpSu");
/* harmony import */ var react_semantic_toasts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-semantic-toasts */ "ls5I");
/* harmony import */ var react_semantic_toasts_styles_react_semantic_alert_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-semantic-toasts/styles/react-semantic-alert.css */ "/lOe");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./common */ "Ctio");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
/* harmony import */ var _lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @lib/util/Diagnostics */ "0mZ+");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__, _common__WEBPACK_IMPORTED_MODULE_13__]);
([_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__, _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__, _common__WEBPACK_IMPORTED_MODULE_13__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* tslint:disable:typedef */



















// IP: proposal for future switching to async parsing
// import * as Comlink from 'comlink';
// import { ParsingeWorker } from './parsing/ParsingWorker'
// import { IParsingProvider } from './parsing/ParsingProvider';
// const provider = Comlink.wrap<IParsingProvider>(new ParsingeWorker());
// provider.createDefaultSLParser();
const DEBUGGER_COLORIZATION_PREFIX = 'debug-ln-clr';
function cleanupMarkersBatch(state, prefix) {
    return Object
        .keys(state.sourceFile.markers)
        .filter(name => name.startsWith(`${prefix}-`));
}
function cleanupMarkers(dispatch, batch) {
    if (batch.length > 0) {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_REMOVE_MARKER_BATCH, payload: { batch } });
    }
}
function emitMarkersBatch(list, type, prefix) {
    return list.map((desc, i) => {
        const { loc, message, payload } = desc;
        return {
            name: `${prefix}-${message}-${i}`,
            range: loc,
            type,
            tooltip: message,
            payload
        };
    });
}
function emitMarkers(dispatch, batch) {
    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_ADD_MARKER_BATCH, payload: { batch } });
}
const emitDebuggerColorization = (list) => emitMarkersBatch(list, 'line', DEBUGGER_COLORIZATION_PREFIX);
const cleanupDebuggerColorization = (state) => cleanupMarkersBatch(state, DEBUGGER_COLORIZATION_PREFIX);
async function processParsing(state, dispatch) {
    const { depot, parserParams: { parsingFlags: flags }, sourceFile: { content: source, uri, defines } } = state;
    // if (matchLocation(state).params.view !== PLAYGROUND_VIEW) {
    //     return;
    // }
    if (!source) {
        return;
    }
    const includeResolver = _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_14__.makeResolver(depot);
    const textDocument = await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_7__.createTextDocument)(uri, source);
    const slastDocument = await (0,_lib_fx_SLASTDocument__WEBPACK_IMPORTED_MODULE_5__.createSLASTDocument)(textDocument, { flags, includeResolver, defines: defines.map(def => ({ name: def })) });
    const unreachableCode = slastDocument.unreachableCode.filter(loc => String(loc.start.file) === String(slastDocument.uri));
    // TODO: move it to language service
    cleanupMarkers(dispatch, cleanupMarkersBatch(state, 'unreachable-code'));
    emitMarkers(dispatch, emitMarkersBatch(unreachableCode.map(loc => ({ loc, payload: {} })), 'unreachable-code', 'unreachable-code'));
    if (true) {
        // verbose(Diagnostics.stringify(diag));
    }
    if (slastDocument.diagnosticReport.errors > 0) {
        (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_11__.toast)({
            type: 'error',
            title: `Parsing failed.`,
            animation: 'scale',
            size: 'tiny',
            time: 2000
        });
    }
    // if (!diag.errors)
    {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_PARSING_COMPLETE, payload: { slastDocument } });
    }
}
async function processAnalyze(state, dispatch) {
    const { slastDocument } = state.sourceFile;
    if (!slastDocument) {
        return;
    }
    const slDocument = await (0,_lib_fx_FXSLDocument__WEBPACK_IMPORTED_MODULE_4__.createFXSLDocument)(slastDocument);
    if (true) {
        // verbose(Diagnostics.stringify(diag));
    }
    if (slDocument.diagnosticReport.errors > 0) {
        (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_11__.toast)({
            type: 'error',
            title: `Analysis failed.`,
            animation: 'scale',
            size: 'tiny',
            time: 2000
        });
    }
    if (slDocument.diagnosticReport.warnings > 0) {
        // pass only deprecations as editor's decorators to use custom styling
        // note: by default warnings and errors are provided by LanguageServiceProvider validation
        emitMarkers(dispatch, emitMarkersBatch(slDocument.diagnosticReport.messages
            .filter(msg => msg.code === `A3008`) // EAnalyzerWarnings.Deprecated
            .map(({ start, end, content }) => ({ loc: { start, end }, message: '@deprecated', payload: {} })), 'deprecated', 'deprecated'));
    }
    // if (!diag.errors)
    {
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_ANALYSIS_COMPLETE, payload: { result: slDocument } });
    }
}
const updateParserLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.GRAMMAR_CONTENT_SPECIFIED, _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.PARSER_PARAMS_CHANGED],
    async process({ getState, action }, dispatch, done) {
        const parserParams = getState().parserParams;
        const { grammar, type, flags } = parserParams;
        /**
         * !!! note: all inline functionality inside analyze.ts depends on this setup
         */
        console.log('%c Creating parser...', 'background: #222; color: #bada55');
        try {
            (0,_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_6__.createDefaultSLParser)({ grammar, type, flags });
            console.log('%c [ DONE ]', 'background: #222; color: #bada55');
        }
        catch (e) {
            console.error('could not initialize parser.');
            return null;
        }
        // todo: add support for failed setup
        done();
    }
});
const dropSourceFileLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_FILE_DROP_STATE,
    async process({ getState, action }) {
        localStorage.removeItem(_common__WEBPACK_IMPORTED_MODULE_13__.LOCAL_SESSION_ID);
    }
});
const updateSourceContentLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_MODIFED, _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_FILE_LOADED],
    latest: true,
    debounce: 500,
    async process({ getState, action, action$ }, dispatch, done) {
        const $debugger = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState());
        if (!$debugger.options.autocompile) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_RESET });
        }
        await processParsing(getState(), dispatch);
        // TODO: move to separate routine
        const location = getState().router.location.pathname;
        const match = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_17__.matchPath)(location, {
            path: _common__WEBPACK_IMPORTED_MODULE_13__.LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx, name } = match.params;
            if (fx && name === _common__WEBPACK_IMPORTED_MODULE_13__.RAW_KEYWORD) {
                await processRaw(getState(), dispatch);
            }
            // Is new file loaded?
            if (action.type === _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_FILE_LOADED) {
                if (localStorage.getItem(_common__WEBPACK_IMPORTED_MODULE_13__.LOCAL_SESSION_ID) !== fx) {
                    localStorage.setItem(_common__WEBPACK_IMPORTED_MODULE_13__.LOCAL_SESSION_ID, fx);
                    (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.verbose)(`Last sesstion data has been updated. (${localStorage.getItem(_common__WEBPACK_IMPORTED_MODULE_13__.LOCAL_SESSION_ID)})`);
                    (0,react_semantic_toasts__WEBPACK_IMPORTED_MODULE_11__.toast)({
                        type: 'info',
                        title: 'Session update.',
                        description: `Last sesstion data has been updated.`,
                        animation: 'fade up',
                        size: 'tiny',
                        time: 2000
                    });
                }
            }
        }
        done();
    }
});
const parsingCompleteLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_PARSING_COMPLETE],
    async process({ getState, action, action$ }, dispatch, done) {
        await processAnalyze(getState(), dispatch);
        done();
    }
});
function buildDebuggerSourceColorization(debuggerState, fileState) {
    // const fn = fileState.slDocument.root.scope.findFunction(debuggerState.query, null);
    const locList = [];
    if (debuggerState.bcDocument?.program) {
        // const from = fn.sourceNode.loc.start.line;
        // const to = fn.sourceNode.loc.end.line;
        const from = 0;
        const to = fileState.content.split('\n').length;
        const cdl = (0,_lib_fx_bytecode_DebugLayout__WEBPACK_IMPORTED_MODULE_2__.cdlview)(debuggerState.bcDocument.program.cdl);
        for (let ln = from; ln <= to; ++ln) {
            const color = cdl.resolveLineColor(ln, fileState.uri);
            if (color !== -1) {
                const loc = { start: { file: null, line: ln, column: 0 }, end: null };
                locList.push({ loc, payload: { color } });
            }
        }
    }
    return locList;
}
const debuggerCompileLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_COMPILE,
    cancelType: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_RESET,
    latest: true,
    async process({ getState, action }, dispatch, done) {
        const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(getState());
        const debuggerState = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState());
        const type = action?.payload?.type || 'expression';
        let query = action?.payload?.query || debuggerState.query;
        if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isNull)(file.slDocument)) {
            const scope = file.slDocument.root.scope;
            let func = null;
            if (type === 'expression') {
                query ||= `${_lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ENTRY_POINT_NAME}()`;
                func = scope.findFunction(query, null);
            }
            if (type === 'pass') {
                if (!query) {
                    const tech = Object.values(scope.techniques11).find(tech => tech.passes.length > 0);
                    const pass = tech?.passes[0];
                    query = `${tech?.name}::${pass?.name}`;
                }
                const [, techName, passName,] = query.match(/([\w\.]+)::([\w]+)/);
                func = scope.findTechnique11(techName).passes.find(p => p.name === passName);
            }
            // workaround for debug purposes (interpretations of the expressions string as function name)
            let bcDocument = null;
            if (func) {
                bcDocument = _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__.translate(func);
            }
            else {
                bcDocument = await _lib_fx_bytecode__WEBPACK_IMPORTED_MODULE_1__.translateExpression(query, file.slDocument);
            }
            if (bcDocument.diagnosticReport.errors > 0) {
                console.error(_lib_util_Diagnostics__WEBPACK_IMPORTED_MODULE_15__.Diagnostics.stringify(bcDocument.diagnosticReport));
                alert(`could not evaluate query '${query}', see console log for details`);
            }
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_START_DEBUG, payload: { query, bcDocument } });
        }
        else {
            console.error('invalid compile request!');
        }
        done();
    }
});
async function processRaw(state, dispatch) {
    const file = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(state);
    const includeResolver = _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_14__.makeResolver(state.depot);
    const defines = file.defines.map(name => ({ name }));
    const document = await (0,_lib_parser_Preprocessor__WEBPACK_IMPORTED_MODULE_8__.createPPDocument)(await (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_7__.createTextDocument)(file.uri, file.content), { includeResolver, defines });
    dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_PREPROCESSING_COMPLETE, payload: { document } });
}
const navigationLogicHook = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: connected_react_router__WEBPACK_IMPORTED_MODULE_18__.LOCATION_CHANGE,
    latest: true,
    debounce: 10,
    async process({ getState, action }, dispatch, done) {
        const location = action.payload.location.pathname;
        const sourceFile = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(getState());
        const match = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_17__.matchPath)(location, {
            path: _common__WEBPACK_IMPORTED_MODULE_13__.LOCATION_PATTERN,
            exact: false
        });
        if (match) {
            const { view, fx, name } = match.params;
            if (fx && name === _common__WEBPACK_IMPORTED_MODULE_13__.RAW_KEYWORD) {
                await processRaw(getState(), dispatch);
            }
        }
        done();
    }
});
// const markersAddLogic = createLogic<IStoreState>({
//     type: evt.SOURCE_CODE_ADD_MARKER_BATCH,
//     debounce: 10000,
//     process: ({ getState, action }, dispatch, done) => done()
// });
// const markersDelLogic = createLogic<IStoreState>({
//     type: evt.SOURCE_CODE_REMOVE_MARKER_BATCH,
//     debounce: 500,
//     process: ({ getState, action }, dispatch, done) => done()
// });
const debuggerResetLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_RESET,
    async process({ getState, action }, dispatch, done) {
        const $debugger = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState());
        if ($debugger.options.colorize) {
            cleanupMarkers(dispatch, cleanupDebuggerColorization(getState()));
        }
        done();
    }
});
const debuggerOptionsChangedLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_OPTIONS_CHANGED,
    async process({ getState, action }, dispatch, done) {
        const { autocompile, colorize, wasm } = action.payload.options;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(autocompile) && autocompile === true) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_COMPILE });
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(colorize) && colorize === false) {
            cleanupMarkers(dispatch, cleanupDebuggerColorization(getState()));
        }
        else {
            const markers = buildDebuggerSourceColorization((0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState()), (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(getState()));
            emitMarkers(dispatch, emitDebuggerColorization(markers));
        }
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(wasm) && wasm != _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_3__.isWASM()) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.PLAYGROUND_SWITCH_VM_RUNTIME });
        }
        done();
    }
});
const debuggerStartLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_START_DEBUG,
    async process({ getState, action }, dispatch, done) {
        const fileState = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(getState());
        const debuggerState = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState());
        if (debuggerState.options.colorize) {
            const markers = buildDebuggerSourceColorization(debuggerState, fileState);
            emitMarkers(dispatch, emitDebuggerColorization(markers));
        }
        done();
    }
});
const debuggerAutocompileLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_ANALYSIS_COMPLETE,
    process({ getState }, dispatch, done) {
        const debuggerState = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getDebugger)(getState());
        if (debuggerState.options.autocompile) {
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.DEBUGGER_COMPILE });
        }
        done();
    }
});
const defineLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_16__["default"])({
    type: [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_SET_DEFINE, _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_REMOVE_DEFINE],
    process({ getState }, dispatch, done) {
        const state = getState();
        const { content } = (0,_sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_10__.getFileState)(state);
        // cleanupMarkers(<IDispatch>dispatch, cleanupMarkersBatch(state, 'line'));
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_9__.SOURCE_CODE_MODIFED, payload: { content } });
        done();
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    dropSourceFileLogic,
    updateParserLogic,
    updateSourceContentLogic,
    parsingCompleteLogic,
    debuggerCompileLogic,
    debuggerResetLogic,
    debuggerOptionsChangedLogic,
    debuggerStartLogic,
    debuggerAutocompileLogic,
    // markersAddLogic,
    // markersDelLogic
    navigationLogicHook,
    defineLogic
]);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "pM37":
/*!**********************************!*\
  !*** ./src/sandbox/logic/s3d.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! redux-logic */ "M2zF");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_util_s3d_prjenv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/util/s3d/prjenv */ "Ia0v");
/* harmony import */ var _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/util/p4/p4 */ "kVxP");





const initEnvLogic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_4__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_INIT_ENV,
    process({ getState, action }, dispatch, done) {
        const projectRoot = action.payload.projectRoot;
        if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isString)(projectRoot)) {
            const prjenv = new _lib_util_s3d_prjenv__WEBPACK_IMPORTED_MODULE_2__.ProjectEnv(projectRoot);
            // console.log(prjenv.Get('game-name'));
            // console.log(prjenv.Get('project-prebuild-dir'));
            // console.log(prjenv.Get('pic-dir'));
            // console.log(prjenv.Get('common-prebuild-dir'));
            // console.log(prjenv.Get('common-assets-dir'));
            // console.log(prjenv.Get('project-assets-dir'));
            // todo: use more strict check
            if (prjenv.Get('game-name')) {
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_INIT_ENV_SUCCESSED, payload: { env: prjenv } });
                dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_CONNECT_P4, payload: {} });
                return done();
            }
        }
        dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_INIT_ENV_FAILED, payload: {} });
        return done();
    }
});
const connectP4Logic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_4__["default"])({
    type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_CONNECT_P4,
    async process({ getState, action }, dispatch, done) {
        const connect = getState().s3d.env.Get('perforce-settings');
        try {
            await _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_3__.run(`set P4PORT=${connect['server']}`);
            await _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_3__.run(`set P4USER=${connect['login']}`);
            await _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_3__.run(`set P4CLIENT=${connect['workspace']}`);
            const stdout = await _lib_util_p4_p4__WEBPACK_IMPORTED_MODULE_3__.run('info');
            let info = {};
            stdout.split('\n').forEach((note) => {
                let v = note.split(':');
                let field = v[0];
                let value = v[1];
                info[field] = value;
            });
            dispatch({ type: _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.S3D_CONNECT_P4_SUCCESSED, payload: { info } });
            done();
        }
        finally {
            done();
        }
    }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    initEnvLogic,
    connectP4Logic
]);


/***/ }),

/***/ "cxbA":
/*!***************************************!*\
  !*** ./src/sandbox/reducers/depot.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getDepot": () => (/* binding */ getDepot),
/* harmony export */   "makeResolver": () => (/* binding */ makeResolver),
/* harmony export */   "resolveName": () => (/* binding */ resolveName)
/* harmony export */ });
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "Q46b");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "HzQp");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ "Q/He");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lib/uri/uri */ "CWQE");
/* harmony import */ var _lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lib/fx/TextDocument */ "E5ji");







const initialState = {
    root: null,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_0__.handleActions)({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.DEPOT_UPDATE_COMPLETE]: (state, action) => ({ ...state, root: { ...state.root, ...action.payload.root } }),
}, initialState));
const debug = (message) => { }; //console.log(message);
async function resolveName(depot, name) {
    debug(`Request to resolve filename "${name}".`);
    name = decodeURIComponent(name);
    const uri = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__.parse(name);
    // early exit for web version
    if (uri.protocol !== 'file') {
        return name;
    }
    console.assert(_sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__.isElectron());
    if (fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__.toLocalPath(uri))) {
        debug(`Direct include has been resolved "${name}".`);
        return name;
    }
    //
    // Attempt to find any folder including basename of target name
    //
    const reduceFolder = (node, name) => {
        let file = node?.files?.find(file => path__WEBPACK_IMPORTED_MODULE_2___default().normalize(file).indexOf(path__WEBPACK_IMPORTED_MODULE_2___default().normalize(name)) != -1);
        if (!file)
            if (node.folders)
                for (let folder of node.folders) {
                    file = reduceFolder(folder, name);
                    if (file)
                        break;
                }
        return file;
    };
    name = reduceFolder(depot.root, path__WEBPACK_IMPORTED_MODULE_2___default().basename(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__.toLocalPath(uri)));
    if (name) {
        debug(`Indirect include has been resolved "${name}".`);
        return name;
    }
    debug(`Filename has not been resolved "${arguments[1]}".`);
    return null;
}
// import { store } from '@sandbox/store';
function makeResolver(depot) {
    return async (name) => {
        if (typeof name !== 'string')
            debugger;
        const fullname = await resolveName(depot, name);
        const uri = _lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__.parse(fullname);
        if (!fullname) {
            return null;
        }
        switch (uri.protocol) {
            case 'file':
                console.assert(_sandbox_ipc__WEBPACK_IMPORTED_MODULE_3__.isElectron());
                // todo: move readFile to ipc
                return (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_6__.createTextDocument)(String(uri), (await fs__WEBPACK_IMPORTED_MODULE_4__.promises.readFile(_lib_uri_uri__WEBPACK_IMPORTED_MODULE_5__.toLocalPath(uri))).toString());
            default:
                try {
                    return (0,_lib_fx_TextDocument__WEBPACK_IMPORTED_MODULE_6__.createTextDocument)(fullname, await (await fetch(fullname)).text());
                }
                catch (e) {
                    console.error(`Can't resolve file "${name}"`);
                    return null;
                }
        }
    };
}
const getDepot = (store) => store.depot;


/***/ }),

/***/ "Q46b":
/*!***********************************************!*\
  !*** ./src/sandbox/reducers/handleActions.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleActions": () => (/* binding */ handleActions)
/* harmony export */ });
function handleActions(map, initialState) {
    return (state, action) => {
        state = state ? state : initialState;
        if (map.hasOwnProperty(action.type)) {
            return map[action.type](state, action);
        }
        return state;
    };
}


/***/ }),

/***/ "YJtB":
/*!***************************************!*\
  !*** ./src/sandbox/reducers/index.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCommon": () => (/* binding */ getCommon),
/* harmony export */   "getLocation": () => (/* binding */ getLocation),
/* harmony export */   "mapProps": () => (/* binding */ mapProps),
/* harmony export */   "matchLocation": () => (/* binding */ matchLocation)
/* harmony export */ });
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router */ "vpSu");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__]);
_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


/**
 * selectors
 */
// most common selector;
// markers are very expensive for react update :/
const getCommon = (state) => state;
// ({ ...state, sourceFile: { ...state.sourceFile, markers: null } });
const getLocation = (state) => state.router.location.pathname;
const matchLocation = (state) => (0,react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(getLocation(state), { path: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__.LOCATION_PATTERN, exact: false });
// helper function in order to get proper props from state using custom selector;
function mapProps(selector) {
    return (state) => selector(state);
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "qLCU":
/*!***************************************!*\
  !*** ./src/sandbox/reducers/nodes.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getEnv": () => (/* binding */ getEnv)
/* harmony export */ });
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "Q46b");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! litegraph.js */ "5Ao9");
/* harmony import */ var litegraph_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(litegraph_js__WEBPACK_IMPORTED_MODULE_2__);



const initialState = {
    docs: null,
    graph: new litegraph_js__WEBPACK_IMPORTED_MODULE_2__.LGraph,
    revision: 0,
    env: null,
    constants: [],
    capacity: 4096
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_1__.handleActions)({
    // hack to reset graph along with source file
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.SOURCE_FILE_DROP_STATE]: (state, action) => ({
        ...state,
        revision: 0
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_MODIFIED]: (state, action) => ({ ...state, revision: state.revision + 1 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_LOADED]: (state, { payload }) => ({ ...state, env: payload.env, constants: payload.constants, capacity: payload.capacity }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_NODE_DOCS_PROVIDED]: (state, { payload }) => ({ ...state, docs: payload.docs }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_CHANGE_LAYOUT]: (state, { payload }) => ({ ...state, env: payload.env }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_ADD_CONSTANT]: (state, { payload }) => ({ ...state, constants: [...state.constants, payload.value], revision: state.revision + 1 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_SET_CONSTANT]: (state, { payload }) => ({ ...state, constants: state.constants.map(c => c.name === payload.name ? ({ ...c, value: payload.value }) : c),
        revision: state.revision + 1 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_REMOVE_CONSTANT]: (state, { payload }) => ({ ...state, constants: state.constants.filter(desc => desc.name != payload.name), revision: state.revision + 1 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_0__.GRAPH_SET_CAPACITY]: (state, { payload }) => ({ ...state, capacity: payload.value, revision: state.revision + 1 }),
}, initialState));
const getEnv = (state) => state.nodes.env;


/***/ }),

/***/ "0VSY":
/*!**********************************************!*\
  !*** ./src/sandbox/reducers/parserParams.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getParser": () => (/* binding */ getParser)
/* harmony export */ });
/* harmony import */ var _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/idl/parser/IParser */ "Y0AG");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _handleActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handleActions */ "Q46b");



const initialState = {
    filename: null,
    grammar: null,
    type: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserType.k_LALR,
    flags: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserFlags.k_Default,
    // TODO: rename option (or move it out of this scope)
    parsingFlags: _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.IASTDocumentFlags.k_Optimize
};
if (true) {
    initialState.flags |= _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.EParserFlags.k_Debug;
    initialState.parsingFlags |= _lib_idl_parser_IParser__WEBPACK_IMPORTED_MODULE_0__.IASTDocumentFlags.k_DeveloperMode;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_handleActions__WEBPACK_IMPORTED_MODULE_2__.handleActions)({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.GRAMMAR_CONTENT_SPECIFIED]: (state, action) => ({ ...state, grammar: action.payload.content }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PARSER_PARAMS_CHANGED]: (state, action) => {
        const { flags, type } = action.payload;
        return { ...state, flags, type };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.PARSING_PARAMS_CHANGED]: (state, action) => {
        const { flags } = action.payload;
        return { ...state, parsingFlags: flags };
    }
}, initialState));
//- Selectors
const getParser = (state) => state.parserParams;


/***/ }),

/***/ "R46Y":
/*!********************************************!*\
  !*** ./src/sandbox/reducers/playground.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "filterTechniques": () => (/* binding */ filterTechniques),
/* harmony export */   "filterTechniques11": () => (/* binding */ filterTechniques11),
/* harmony export */   "getEmitterName": () => (/* binding */ getEmitterName),
/* harmony export */   "getPlaygroundState": () => (/* binding */ getPlaygroundState)
/* harmony export */ });
/* harmony import */ var _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/fx/techniques */ "LvoO");
/* harmony import */ var _lib_fx_timeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/timeline */ "QlGU");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "Q46b");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_techniques__WEBPACK_IMPORTED_MODULE_0__]);
_lib_fx_techniques__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const initialState = {
    technique: null,
    timeline: _lib_fx_timeline__WEBPACK_IMPORTED_MODULE_1__.make(),
    controls: { controls: {}, values: {}, presets: [] },
    presets: {},
    revision: 0,
    wasm: _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_0__.isWASM(),
    shaderFormat: 'glsl',
    exportName: null,
    autosave: false
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_3__.handleActions)({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_TECHNIQUE_UPDATE]: (state, { payload }) => ({ ...state, technique: payload.technique, controls: payload.controls, revision: state.revision + 1 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_SWITCH_TECHNIQUE_RUNTIME]: (state, action) => ({ ...state, wasm: !state.wasm }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_EFFECT_HAS_BEEN_SAVED]: (state, action) => ({ ...state, exportName: action.payload.filename }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_EFFECT_HAS_BEEN_DROPPED]: (state, action) => ({ ...state, exportName: null, technique: null }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_SET_OPTION_AUTOSAVE]: (state, action) => ({ ...state, autosave: action.payload.enabled }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_2__.PLAYGROUND_SET_SHADER_FORMAT]: (state, action) => ({ ...state, shaderFormat: action.payload.format })
}, initialState));
const getEmitterName = (playground) => playground.technique ? playground.technique.getName() : null;
/** @deprecated */
function filterTechniques(scope) {
    if (!scope) {
        return [];
    }
    const map = scope.techniques;
    return Object.keys(map).map(name => map[name]);
}
function filterTechniques11(scope) {
    if (!scope) {
        return [];
    }
    const map = scope.techniques11;
    return Object.keys(map).map(name => map[name]);
}
const getPlaygroundState = (state) => state.playground;

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "va7o":
/*!****************************************!*\
  !*** ./src/sandbox/reducers/router.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "history": () => (/* binding */ history)
/* harmony export */ });
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! connected-react-router */ "/Fnw");
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! history */ "51aD");


const history = (0,history__WEBPACK_IMPORTED_MODULE_0__.createHashHistory)();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,connected_react_router__WEBPACK_IMPORTED_MODULE_1__.connectRouter)(history));


/***/ }),

/***/ "fq7q":
/*!*************************************!*\
  !*** ./src/sandbox/reducers/s3d.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _handleActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handleActions */ "Q46b");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");


const initialState = {
    env: null,
    p4: null
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_handleActions__WEBPACK_IMPORTED_MODULE_0__.handleActions)({
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.S3D_INIT_ENV_SUCCESSED]: (state, action) => ({ ...state, env: action.payload.env }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.S3D_INIT_ENV_FAILED]: (state, action) => ({ ...state, env: null }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_1__.S3D_CONNECT_P4_SUCCESSED]: (state, action) => ({ ...state, p4: action.payload.info }),
}, initialState));


/***/ }),

/***/ "J7+d":
/*!********************************************!*\
  !*** ./src/sandbox/reducers/sourceFile.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asConvolutionPack": () => (/* binding */ asConvolutionPack),
/* harmony export */   "asSLASTDocument": () => (/* binding */ asSLASTDocument),
/* harmony export */   "asTextDocument": () => (/* binding */ asTextDocument),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getDebugger": () => (/* binding */ getDebugger),
/* harmony export */   "getFileState": () => (/* binding */ getFileState),
/* harmony export */   "getRawContent": () => (/* binding */ getRawContent),
/* harmony export */   "getScope": () => (/* binding */ getScope)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/bundles/utils */ "GUxJ");
/* harmony import */ var _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lib/fx/bytecode/VM */ "ZLcK");
/* harmony import */ var _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lib/fx/techniques */ "LvoO");
/* harmony import */ var _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lib/util/StringRef */ "Cx6u");
/* harmony import */ var _sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/actions/ActionTypeKeys */ "ceAs");
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "Q46b");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_3__]);
([_lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__, _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);








const initialState = {
    revision: 0,
    uri: null,
    content: '',
    error: null,
    markers: {},
    breakpoints: [],
    slastDocument: null,
    slDocument: null,
    rawDocument: null,
    defines: [],
    debugger: {
        query: null,
        bcDocument: null,
        options: {
            colorize: true,
            disableOptimizations: true,
            autocompile: false,
            wasm: _lib_fx_bytecode_VM__WEBPACK_IMPORTED_MODULE_2__.isWASM()
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_6__.handleActions)({
    // hack: intercept filename of graph as main filename
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.GRAPH_LOADED]: (state, action) => ({ ...state, uri: action.payload.filename }),
    // don't update uri separatly from content (!)
    // [evt.SOURCE_FILE_REQUEST]: (state, action: ISourceFileRequest) =>
    //     ({ ...state, uri: action.payload.filename }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_FILE_LOADED]: (state, action) => ({ ...state, uri: action.payload.filename, content: action.payload.content, revision: 0 }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_FILE_LOADING_FAILED]: (state, action) => ({
        ...state,
        error: action.payload.error,
        // NOTE: temp solution (clean up all info about prev file)
        content: null,
        debugger: { ...state.debugger, bcDocument: null },
        breakpoints: [],
        slastDocument: null,
        slDocument: null,
        revision: 0,
        wasm: _lib_fx_techniques__WEBPACK_IMPORTED_MODULE_3__.isWASM()
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_FILE_DROP_STATE]: (state, action) => ({
        ...state,
        error: null,
        content: null,
        debugger: { ...state.debugger, bcDocument: null },
        markers: {},
        breakpoints: [],
        slastDocument: null,
        slDocument: null,
        revision: 0
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_MODIFED]: (state, action) => ({
        ...state, markers: {},
        content: action.payload.content,
        uri: action.payload.filename || state.uri,
        revision: state.revision + 1
        // , debugger: { entryPoint: null, runtime: null, ...state.debugger } =
    }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_PARSING_COMPLETE]: (state, action) => ({ ...state, slastDocument: action.payload.slastDocument }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_ANALYSIS_COMPLETE]: (state, action) => ({ ...state, slDocument: action.payload.result }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_PREPROCESSING_COMPLETE]: (state, action) => ({ ...state, rawDocument: action.payload.document }),
    //
    // markers
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_ADD_MARKER]: (state, action) => ({ ...state, markers: { ...state.markers, [action.payload.name]: action.payload } }),
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_REMOVE_MARKER]: (state, action) => {
        const markers = { ...state.markers };
        delete markers[action.payload.name];
        return { ...state, markers };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_ADD_MARKER_BATCH]: (state, action) => {
        const markers = { ...state.markers };
        action.payload.batch.forEach(desc => markers[desc.name] = desc);
        return { ...state, markers };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_REMOVE_MARKER_BATCH]: (state, action) => {
        const markers = { ...state.markers };
        action.payload.batch.forEach(name => {
            delete markers[name];
        });
        return { ...state, markers };
    },
    //
    // breakpoints
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_ADD_BREAKPOINT]: (state, action) => {
        (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.assert)(state.breakpoints.indexOf(action.payload.line) === -1);
        return ({ ...state, breakpoints: [...state.breakpoints, action.payload.line] });
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_REMOVE_BREAKPOINT]: (state, action) => {
        return { ...state, breakpoints: state.breakpoints.filter(ln => ln !== action.payload.line) };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_SET_DEFINE]: (state, { payload: { name } }) => {
        return { ...state, defines: [name, ...state.defines.filter(def => def != name)] };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.SOURCE_CODE_REMOVE_DEFINE]: (state, { payload: { name } }) => {
        return { ...state, defines: state.defines.filter(def => def != name) };
    },
    //
    // debugger
    //
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.DEBUGGER_START_DEBUG]: (state, action) => {
        const options = state.debugger.options;
        const { query, bcDocument } = action.payload;
        return { ...state, debugger: { query, bcDocument, options } };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.DEBUGGER_RESET]: (state) => {
        const { debugger: { options } } = state;
        return { ...state, debugger: { query: null, bcDocument: null, options, layout: 'i32' } };
    },
    [_sandbox_actions_ActionTypeKeys__WEBPACK_IMPORTED_MODULE_5__.DEBUGGER_OPTIONS_CHANGED]: (state, action) => {
        const options = { ...state.debugger.options, ...action.payload.options };
        const $debugger = { ...state.debugger, options };
        // console.log(JSON.stringify(options, null, '\t'));
        return { ...state, debugger: $debugger };
    },
}, initialState));
//- Selectors
// export const getFileStateNoMarkers = (state: IStoreState): IFileState => ({ ...state.sourceFile, markers: null });
const getFileState = (state) => state.sourceFile;
const getDebugger = (state) => getFileState(state).debugger;
const getScope = (file) => file.slDocument ? file.slDocument.root.scope : null;
const getRawContent = (file) => file.rawDocument ? file.rawDocument.source : null;
const asTextDocument = ({ uri, content }) => ({ uri: _lib_util_StringRef__WEBPACK_IMPORTED_MODULE_4__.StringRef.make(uri), source: content });
const asSLASTDocument = (file) => file.slastDocument;
const asConvolutionPack = (state) => {
    const file = state.sourceFile;
    const depot = state.depot;
    const textDocument = asTextDocument(file);
    const slastDocument = asSLASTDocument(file);
    const includeResolver = _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_7__.makeResolver(depot);
    const defines = file.defines;
    return new _lib_fx_bundles_utils__WEBPACK_IMPORTED_MODULE_1__.ConvolutionPackEx(textDocument, slastDocument, includeResolver, defines);
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "RSd/":
/*!**************************************************!*\
  !*** ./src/sandbox/reducers/translatorParams.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asFxTranslatorOprions": () => (/* binding */ asFxTranslatorOprions),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/reducers/handleActions */ "Q46b");

const initialState = {
    uiControlsGatherToDedicatedConstantBuffer: true,
    uiControlsConstantBufferRegister: 10,
    globalUniformsGatherToDedicatedConstantBuffer: true,
    globalUniformsConstantBufferRegister: 11
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_sandbox_reducers_handleActions__WEBPACK_IMPORTED_MODULE_0__.handleActions)({}, initialState));
//- Selectors
const asFxTranslatorOprions = (state) => {
    return { ...state.translatorParams };
};


/***/ }),

/***/ "0172":
/*!*********************************!*\
  !*** ./src/sandbox/sandbox.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lib/common */ "cOQ3");
/* harmony import */ var _lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lib/fx/SLParser */ "/oCY");
/* harmony import */ var _sandbox_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/actions */ "b/L/");
/* harmony import */ var _sandbox_containers_App__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/containers/App */ "YTDY");
/* harmony import */ var _sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/ipc */ "FJDS");
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/router */ "va7o");
/* harmony import */ var _sandbox_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/store */ "t4A9");
/* harmony import */ var connected_react_router__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! connected-react-router */ "/Fnw");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "ynia");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-dom */ "7wdh");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-redux */ "1tbJ");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-router */ "vpSu");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! semantic-ui-react */ "UeIX");
/* harmony import */ var semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! semantic-ui-react */ "21rH");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_containers_App__WEBPACK_IMPORTED_MODULE_3__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_5__, _sandbox_store__WEBPACK_IMPORTED_MODULE_7__]);
([_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__, _sandbox_containers_App__WEBPACK_IMPORTED_MODULE_3__, _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_5__, _sandbox_store__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);














__webpack_require__(/*! semantic-ui-less/semantic.less */ "ITMc");
if (_sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__.isElectron()) {
    const { project } = _sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__.sync.argv();
    if ((0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isDef)(project)) {
        _sandbox_store__WEBPACK_IMPORTED_MODULE_7__.store.dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.s3d.initEnv(project));
    }
}
// fetch filesystem
_sandbox_store__WEBPACK_IMPORTED_MODULE_7__.store.dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.depot.rescan());
// make grammar available for editing
_sandbox_store__WEBPACK_IMPORTED_MODULE_7__.store.dispatch(_sandbox_actions__WEBPACK_IMPORTED_MODULE_2__.parser.setGrammar((0,_lib_fx_SLParser__WEBPACK_IMPORTED_MODULE_1__.defaultSLGrammar)()));
const goHome = () => _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.push(`/`);
const LocationNotFound = () => (react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", null,
    "Location not found. \u00A0",
    react__WEBPACK_IMPORTED_MODULE_8__.createElement("a", { href: '#', style: { cursor: 'pointer', textDecoration: 'none' }, onClick: goHome }, "Ok :("),
    react__WEBPACK_IMPORTED_MODULE_8__.createElement("br", null),
    react__WEBPACK_IMPORTED_MODULE_8__.createElement("small", null, _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history.location.pathname)));
react_dom__WEBPACK_IMPORTED_MODULE_9__.render(react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_10__.Provider, { store: _sandbox_store__WEBPACK_IMPORTED_MODULE_7__.store },
    react__WEBPACK_IMPORTED_MODULE_8__.createElement(connected_react_router__WEBPACK_IMPORTED_MODULE_11__.ConnectedRouter, { history: _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_6__.history },
        react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_router__WEBPACK_IMPORTED_MODULE_12__.Switch, null,
            react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_router__WEBPACK_IMPORTED_MODULE_12__.Route, { exact: true, path: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_5__.LOCATION_NOT_FOUND },
                react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"], { open: true, basic: true },
                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_14__["default"], { icon: 'archive', content: react__WEBPACK_IMPORTED_MODULE_8__.createElement(LocationNotFound, null) }),
                    react__WEBPACK_IMPORTED_MODULE_8__.createElement(semantic_ui_react__WEBPACK_IMPORTED_MODULE_13__["default"].Content, null))),
            react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_router__WEBPACK_IMPORTED_MODULE_12__.Route, { path: _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_5__.LOCATION_PATTERN, component: _sandbox_containers_App__WEBPACK_IMPORTED_MODULE_3__["default"] })))), document.getElementById('app'));
/// <reference path="./webpack.d.ts" />
console.log(`%c This is ${_sandbox_ipc__WEBPACK_IMPORTED_MODULE_4__.isElectron() ? 'electron' : 'a web browser'}!!!`, 'background: #222; color: #bada55');
console.log(`%c ver: ${"0.0.11.8b8be6a"} (${"8b8be6a117aac880cbb0455eed6bbaa0bf71fd55"}, ${"develop"}), mode=${"development"}, production=${false}, timestamp=${"Wed Mar 08 2023 02:32:03 GMT+0300 (Moscow Standard Time)"}, %cwasm=${true}`, `background: #222; color: #bada55`, `background: ${ true ? 'green' : 0}; color: #bada55`);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "t4A9":
/*!************************************!*\
  !*** ./src/sandbox/store/index.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "store": () => (/* binding */ store)
/* harmony export */ });
/* harmony import */ var _sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sandbox/logic/common */ "Ctio");
/* harmony import */ var _sandbox_logic_depot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sandbox/logic/depot */ "/KxH");
/* harmony import */ var _sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sandbox/logic/fxRuntime */ "5FPh");
/* harmony import */ var _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sandbox/logic/nodesEx */ "q0SN");
/* harmony import */ var _sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sandbox/logic/parsing */ "6LMl");
/* harmony import */ var _sandbox_logic_s3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sandbox/logic/s3d */ "pM37");
/* harmony import */ var _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sandbox/reducers/depot */ "cxbA");
/* harmony import */ var _sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sandbox/reducers/nodes */ "qLCU");
/* harmony import */ var _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sandbox/reducers/parserParams */ "0VSY");
/* harmony import */ var _sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sandbox/reducers/translatorParams */ "RSd/");
/* harmony import */ var _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sandbox/reducers/playground */ "R46Y");
/* harmony import */ var _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sandbox/reducers/router */ "va7o");
/* harmony import */ var _sandbox_reducers_s3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sandbox/reducers/s3d */ "fq7q");
/* harmony import */ var _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sandbox/reducers/sourceFile */ "J7+d");
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! redux */ "n6ze");
/* harmony import */ var redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! redux-immutable-state-invariant */ "b2X+");
/* harmony import */ var redux_logger__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! redux-logger */ "jANQ");
/* harmony import */ var redux_logger__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(redux_logger__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var redux_logic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! redux-logic */ "HXKy");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__, _sandbox_logic_depot__WEBPACK_IMPORTED_MODULE_1__, _sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__, _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_3__, _sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_13__]);
([_sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__, _sandbox_logic_depot__WEBPACK_IMPORTED_MODULE_1__, _sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__, _sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_3__, _sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_4__, _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__, _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_13__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/// <reference path="../webpack.d.ts" />
// import ActionTypes from '@sandbox/actions/ActionTypes';



// import graphLogic from '@sandbox/logic/nodes';















const reducer = (0,redux__WEBPACK_IMPORTED_MODULE_16__.combineReducers)({
    sourceFile: _sandbox_reducers_sourceFile__WEBPACK_IMPORTED_MODULE_13__["default"],
    parserParams: _sandbox_reducers_parserParams__WEBPACK_IMPORTED_MODULE_8__["default"],
    translatorParams: _sandbox_reducers_translatorParams__WEBPACK_IMPORTED_MODULE_9__["default"],
    router: _sandbox_reducers_router__WEBPACK_IMPORTED_MODULE_11__["default"],
    playground: _sandbox_reducers_playground__WEBPACK_IMPORTED_MODULE_10__["default"],
    nodes: _sandbox_reducers_nodes__WEBPACK_IMPORTED_MODULE_7__["default"],
    s3d: _sandbox_reducers_s3d__WEBPACK_IMPORTED_MODULE_12__["default"],
    depot: _sandbox_reducers_depot__WEBPACK_IMPORTED_MODULE_6__["default"]
});
const logic = (0,redux_logic__WEBPACK_IMPORTED_MODULE_17__["default"])([
    ..._sandbox_logic_common__WEBPACK_IMPORTED_MODULE_0__["default"],
    ..._sandbox_logic_parsing__WEBPACK_IMPORTED_MODULE_4__["default"],
    ..._sandbox_logic_fxRuntime__WEBPACK_IMPORTED_MODULE_2__["default"],
    ..._sandbox_logic_nodesEx__WEBPACK_IMPORTED_MODULE_3__["default"],
    ..._sandbox_logic_s3d__WEBPACK_IMPORTED_MODULE_5__["default"],
    ..._sandbox_logic_depot__WEBPACK_IMPORTED_MODULE_1__["default"]
]);
const logger = (0,redux_logger__WEBPACK_IMPORTED_MODULE_15__.createLogger)({
    collapsed: true,
    diff: false
});
const reduxImmutableState = (0,redux_immutable_state_invariant__WEBPACK_IMPORTED_MODULE_14__["default"])({
    ignore: [
        'sourceFile.slastDocument',
        'sourceFile.slDocument',
        'sourceFile.debugger.bcDocument',
        'playground.technique',
        'playground.timeline',
        'playground.controls',
        'nodes.graph',
        'nodes.env',
        's3d.env'
    ]
});
// todo: add support for retail configuration
const middleware =  true ?
    [/*thunk, */ logic, logger, reduxImmutableState] :
    0;
const store = (0,redux__WEBPACK_IMPORTED_MODULE_16__.createStore)(reducer, (0,redux__WEBPACK_IMPORTED_MODULE_16__.applyMiddleware)(...middleware));
//
// IP: hack to preserved some of user-set options
//
const BACKUP_DEFINES = "store-backup-defines";
// const BACKUP_SHADER_FORMAT = "store-backup-shader-format";
store.subscribe(() => {
    const state = store.getState();
    localStorage[BACKUP_DEFINES] = JSON.stringify(state.sourceFile.defines);
    // localStorage[BACKUP_SHADER_FORMAT] = state.playground.shaderFormat;
});
// store.dispatch({ type: "playground-set-shader-format", payload: { format: localStorage[BACKUP_SHADER_FORMAT] } });
JSON.parse(localStorage[BACKUP_DEFINES] || "[]").forEach(name => store.dispatch({ type: "source-code-set-define", payload: { name } }));

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "aBBW":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js!./src/sandbox/containers/editor/LanguageServiceProvider.ts ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Worker_fn)
/* harmony export */ });
function Worker_fn() {
  return new Worker(__webpack_require__.p + "LanguageServiceProvider.904af4e6f0129f42227d.worker.js");
}


/***/ }),

/***/ "xmIN":
/*!***********************************************!*\
  !*** ./src/lib/fx/bytecode/VM/cpp/module.cpp ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Module = (() => {
  var _scriptDir = "file:///C:/Husky/streams2/tools/code/Influx/src/lib/fx/bytecode/VM/cpp/module.cpp";
  
  return (
function(Module) {
  Module = Module || {};



// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = true;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// This gives correct answers for everything less than 2^{14} = 16384
// I hope nobody is contemplating functions with 16384 arguments...
function uleb128Encode(n) {
  if (n < 128) {
    return [n];
  }
  return [(n % 128) | 128, n >> 7];
}

// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function == "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64',
      'p': 'i32',
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'p': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection = typeSection.concat(uleb128Encode(sigParam.length));
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the section code and overall length of the type section into the
  // section header
  typeSection = [0x01 /* Type section code */].concat(
    uleb128Encode(typeSection.length),
    typeSection
  );

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implemenation here for now.
    abort(text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') {
      
      return UTF8ToString(ret);
    }
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 2097152;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
var wasmBinaryFile;
if (Module['locateFile']) {
  wasmBinaryFile = 'C:/Husky/streams2/tools/code/Influx/webpack-addons/module-7937ca9cc6f8782be9620f24a283f5b5.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
} else {
  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.
  wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! ./webpack-addons/module-7937ca9cc6f8782be9620f24a283f5b5.wasm */ "0Wsb"), __webpack_require__.b).toString();
}

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmMemory = Module['asm']['memory'];
    updateGlobalBufferAndViews(wasmMemory.buffer);

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // If instantiation fails, reject the module ready promise.
  instantiateAsync().catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            getWasmTableEntry(func)();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            getWasmTableEntry(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  
    /** @param {number} ptr
        @param {string} type
        @param {number|boolean=} noSafe */
  function getValue(ptr, type = 'i8', noSafe) {
      if (type.endsWith('*')) type = 'u32';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP32[((ptr)>>2)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return Number(HEAPF64[((ptr)>>3)]);
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only
        // populated if an Error object is thrown, so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  
    /** @param {number} ptr
        @param {number} value
        @param {string} type
        @param {number|boolean=} noSafe */
  function setValue(ptr, value, type = 'i8', noSafe) {
      if (type.endsWith('*')) type = 'u32';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped
      // functions so we need to call it here to retrieve the potential wrapper correctly
      // instead of just storing 'func' directly into wasmTableMirror
      wasmTableMirror[idx] = wasmTable.get(idx);
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  function ___cxa_allocate_exception(size) {
      // Thrown object is prepended by exception metadata block
      return _malloc(size + 24) + 24;
    }

  /** @constructor */
  function ExceptionInfo(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
  
      this.set_type = function(type) {
        HEAPU32[(((this.ptr)+(4))>>2)] = type;
      };
  
      this.get_type = function() {
        return HEAPU32[(((this.ptr)+(4))>>2)];
      };
  
      this.set_destructor = function(destructor) {
        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;
      };
  
      this.get_destructor = function() {
        return HEAPU32[(((this.ptr)+(8))>>2)];
      };
  
      this.set_refcount = function(refcount) {
        HEAP32[((this.ptr)>>2)] = refcount;
      };
  
      this.set_caught = function (caught) {
        caught = caught ? 1 : 0;
        HEAP8[(((this.ptr)+(12))>>0)] = caught;
      };
  
      this.get_caught = function () {
        return HEAP8[(((this.ptr)+(12))>>0)] != 0;
      };
  
      this.set_rethrown = function (rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;
      };
  
      this.get_rethrown = function () {
        return HEAP8[(((this.ptr)+(13))>>0)] != 0;
      };
  
      // Initialize native structure fields. Should be called once after allocated.
      this.init = function(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
        this.set_refcount(0);
        this.set_caught(false);
        this.set_rethrown(false);
      }
  
      this.add_ref = function() {
        var value = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = value + 1;
      };
  
      // Returns true if last reference released.
      this.release_ref = function() {
        var prev = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = prev - 1;
        return prev === 1;
      };
  
      this.set_adjusted_ptr = function(adjustedPtr) {
        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;
      };
  
      this.get_adjusted_ptr = function() {
        return HEAPU32[(((this.ptr)+(16))>>2)];
      };
  
      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted
      // when the pointer is casted to some of the exception object base classes (e.g. when virtual
      // inheritance is used). When a pointer is thrown this method should return the thrown pointer
      // itself.
      this.get_exception_ptr = function() {
        // Work around a fastcomp bug, this code is still included for some reason in a build without
        // exceptions support.
        var isPointer = ___cxa_is_pointer_type(this.get_type());
        if (isPointer) {
          return HEAPU32[((this.excPtr)>>2)];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0) return adjusted;
        return this.excPtr;
      };
    }
  
  var exceptionLast = 0;
  
  var uncaughtExceptionCount = 0;
  function ___cxa_throw(ptr, type, destructor) {
      var info = new ExceptionInfo(ptr);
      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      throw ptr;
    }

  var structRegistrations = {};
  
  function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    }
  
  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }
  
  var awaitingDependencies = {};
  
  var registeredTypes = {};
  
  var typeDependencies = {};
  
  var char_0 = 48;
  
  var char_9 = 57;
  function makeLegalFunctionName(name) {
      if (undefined === name) {
        return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return '_' + name;
      }
      return name;
    }
  function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }
  function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
  
          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };
  
      return errorClass;
    }
  var InternalError = undefined;
  function throwInternalError(message) {
      throw new InternalError(message);
    }
  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });
  
      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }
  function __embind_finalize_value_object(structType) {
      var reg = structRegistrations[structType];
      delete structRegistrations[structType];
  
      var rawConstructor = reg.rawConstructor;
      var rawDestructor = reg.rawDestructor;
      var fieldRecords = reg.fields;
      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).
                concat(fieldRecords.map((field) => field.setterArgumentType));
      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {
        var fields = {};
        fieldRecords.forEach((field, i) => {
          var fieldName = field.fieldName;
          var getterReturnType = fieldTypes[i];
          var getter = field.getter;
          var getterContext = field.getterContext;
          var setterArgumentType = fieldTypes[i + fieldRecords.length];
          var setter = field.setter;
          var setterContext = field.setterContext;
          fields[fieldName] = {
            read: (ptr) => {
              return getterReturnType['fromWireType'](
                  getter(getterContext, ptr));
            },
            write: (ptr, o) => {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
              runDestructors(destructors);
            }
          };
        });
  
        return [{
          name: reg.name,
          'fromWireType': function(ptr) {
            var rv = {};
            for (var i in fields) {
              rv[i] = fields[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          },
          'toWireType': function(destructors, o) {
            // todo: Here we have an opportunity for -O3 level "unsafe" optimizations:
            // assume all fields are present without checking.
            for (var fieldName in fields) {
              if (!(fieldName in o)) {
                throw new TypeError('Missing field:  "' + fieldName + '"');
              }
            }
            var ptr = rawConstructor();
            for (fieldName in fields) {
              fields[fieldName].write(ptr, o[fieldName]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: rawDestructor,
        }];
      });
    }

  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}

  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }
  
  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }
  var embind_charCodes = undefined;
  function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
  
  var BindingError = undefined;
  function throwBindingError(message) {
      throw new BindingError(message);
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }
  
      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }
      if (!(other instanceof ClassHandle)) {
        return false;
      }
  
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
  
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
  
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
  
      return leftClass === rightClass && left === right;
    }
  
  function shallowCopyInternalPointer(o) {
      return {
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType,
      };
    }
  
  function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }
  
  var finalizationRegistry = false;
  
  function detachFinalizer(handle) {}
  
  function runDestructor($$) {
      if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }
  function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    }
  
  function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (undefined === desiredClass.baseClass) {
        return null; // no conversion
      }
  
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
          return null;
      }
      return desiredClass.downcast(rv);
    }
  
  var registeredPointers = {};
  
  function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
  
  function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
          }
      }
      return rv;
    }
  
  var deletionQueue = [];
  function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj['delete']();
      }
    }
  
  var delayFunction = undefined;
  function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }
  function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }
  var registeredInstances = {};
  
  function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    }
  function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
  
  function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
        $$: {
            value: record,
        },
      }));
    }
  function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)
  
      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
  
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
        // JS object has been neutered, time to repopulate it
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance['clone']();
        } else {
          // else, just increment reference count on existing object
          // it already has a reference to the smart pointer
          var rv = registeredInstance['clone']();
          this.destructor(ptr);
          return rv;
        }
      }
  
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: rawPointer,
            smartPtrType: this,
            smartPtr: ptr,
          });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this,
            ptr: ptr,
          });
        }
      }
  
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
  
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
          return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
          smartPtrType: this,
          smartPtr: ptr,
        });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
        });
      }
    }
  function attachFinalizer(handle) {
      if ('undefined' === typeof FinalizationRegistry) {
          attachFinalizer = (handle) => handle;
          return handle;
      }
      // If the running environment has a FinalizationRegistry (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationRegistry
      // at run-time, not build-time.
      finalizationRegistry = new FinalizationRegistry((info) => {
          releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle) => {
        var $$ = handle.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          // We should not call the destructor on raw pointers in case other code expects the pointee to live
          var info = { $$: $$ };
          finalizationRegistry.register(handle, info, handle);
        }
        return handle;
      };
      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);
      return attachFinalizer(handle);
    }
  function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this;
      } else {
        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
          $$: {
            value: shallowCopyInternalPointer(this.$$),
          }
        }));
  
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone;
      }
    }
  
  function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
  
      detachFinalizer(this);
      releaseClassHandle(this.$$);
  
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = undefined;
        this.$$.ptr = undefined;
      }
    }
  
  function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
  
  function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }
  function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }
  function ClassHandle() {
    }
  
  function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function() {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
              throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
          }
          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }
  /** @param {number=} numArguments */
  function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError("Cannot register public name '" + name + "' twice");
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module.hasOwnProperty(numArguments)) {
            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      }
      else {
        Module[name] = value;
        if (undefined !== numArguments) {
          Module[name].numArguments = numArguments;
        }
      }
    }
  
  /** @constructor */
  function RegisteredClass(name,
                               constructor,
                               instancePrototype,
                               rawDestructor,
                               baseClass,
                               getActualType,
                               upcast,
                               downcast) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
  
  function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }
  function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
  
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
  
      if (this.isSmartPointer) {
        // TODO: this is not strictly true
        // We could support BY_EMVAL conversions from raw pointers to smart pointers
        // because the smart pointer can hold a reference to the handle
        if (undefined === handle.$$.smartPtr) {
          throwBindingError('Passing raw pointer to smart pointer is illegal');
        }
  
        switch (this.sharingPolicy) {
          case 0: // NONE
            // no upcasting
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
            }
            break;
  
          case 1: // INTRUSIVE
            ptr = handle.$$.smartPtr;
            break;
  
          case 2: // BY_EMVAL
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle['clone']();
              ptr = this.rawShare(
                ptr,
                Emval.toHandle(function() {
                  clonedHandle['delete']();
                })
              );
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
  
          default:
            throwBindingError('Unsupporting sharing policy');
        }
      }
      return ptr;
    }
  
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
  
  function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }
  
  function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle['delete']();
      }
    }
  function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }
  /** @constructor
      @param {*=} pointeeType,
      @param {*=} sharingPolicy,
      @param {*=} rawGetPointee,
      @param {*=} rawConstructor,
      @param {*=} rawShare,
      @param {*=} rawDestructor,
       */
  function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
  
      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
  
      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
  
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this['toWireType'] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this['toWireType'] = genericPointerToWireType;
        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
        //       craftInvokerFunction altogether.
      }
    }
  
  /** @param {number=} numArguments */
  function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistant public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      }
      else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    }
  
  function dynCallLegacy(sig, ptr, args) {
      var f = Module["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
  /** @param {Object=} args */
  function dynCall(sig, ptr, args) {
      // Without WASM_BIGINT support we cannot directly call function with i64 as
      // part of thier signature, so we rely the dynCall functions generated by
      // wasm-emscripten-finalize
      if (sig.includes('j')) {
        return dynCallLegacy(sig, ptr, args);
      }
      return getWasmTableEntry(ptr).apply(null, args)
    }
  function getDynCaller(sig, ptr) {
      var argCache = [];
      return function() {
        argCache.length = 0;
        Object.assign(argCache, arguments);
        return dynCall(sig, ptr, argCache);
      };
    }
  function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
  
      function makeDynCaller() {
        if (signature.includes('j')) {
          return getDynCaller(signature, rawFunction);
        }
        return getWasmTableEntry(rawFunction);
      }
  
      var fp = makeDynCaller();
      if (typeof fp != "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }
      return fp;
    }
  
  var UnboundTypeError = undefined;
  
  function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }
  function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
    }
  function __embind_register_class(rawType,
                                     rawPointerType,
                                     rawConstPointerType,
                                     baseClassRawType,
                                     getActualTypeSignature,
                                     getActualType,
                                     upcastSignature,
                                     upcast,
                                     downcastSignature,
                                     downcast,
                                     name,
                                     destructorSignature,
                                     rawDestructor) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
  
      exposePublicSymbol(legalFunctionName, function() {
        // this code cannot run if baseClassRawType is zero
        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });
  
      whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        function(base) {
          base = base[0];
  
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
  
          var constructor = createNamedFunction(legalFunctionName, function() {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name);
            }
            if (undefined === registeredClass.constructor_body) {
              throw new BindingError(name + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[arguments.length];
            if (undefined === body) {
              throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
            }
            return body.apply(this, arguments);
          });
  
          var instancePrototype = Object.create(basePrototype, {
            constructor: { value: constructor },
          });
  
          constructor.prototype = instancePrototype;
  
          var registeredClass = new RegisteredClass(name,
                                                    constructor,
                                                    instancePrototype,
                                                    rawDestructor,
                                                    baseClass,
                                                    getActualType,
                                                    upcast,
                                                    downcast);
  
          var referenceConverter = new RegisteredPointer(name,
                                                         registeredClass,
                                                         true,
                                                         false,
                                                         false);
  
          var pointerConverter = new RegisteredPointer(name + '*',
                                                       registeredClass,
                                                       false,
                                                       false,
                                                       false);
  
          var constPointerConverter = new RegisteredPointer(name + ' const*',
                                                            registeredClass,
                                                            false,
                                                            true,
                                                            false);
  
          registeredPointers[rawType] = {
            pointerType: pointerConverter,
            constPointerType: constPointerConverter
          };
  
          replacePublicSymbol(legalFunctionName, constructor);
  
          return [referenceConverter, pointerConverter, constPointerConverter];
        }
      );
    }

  function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
      }
      /*
       * Previously, the following line was just:
       *   function dummy() {};
       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even
       * though at creation, the 'dummy' has the correct constructor name.  Thus,
       * objects created with IMVU.new would show up in the debugger as 'dummy',
       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the
       * issue.  Doublely-unfortunately, there's no way to write a test for this
       * behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;
  
      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = false;
  
      for (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
          needsDestructorStack = true;
          break;
        }
      }
  
      var returns = (argTypes[0].name !== "void");
  
      var argsList = "";
      var argsListWired = "";
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i!==0?", ":"")+"arg"+i;
        argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
      }
  
      var invokerFnBody =
          "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
          "if (arguments.length !== "+(argCount - 2)+") {\n" +
              "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
          "}\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
  
      if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
      }
  
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
        args1.push("argType"+i);
        args2.push(argTypes[i+2]);
      }
  
      if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
  
      invokerFnBody +=
          (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
            args1.push(paramName+"_dtor");
            args2.push(argTypes[i].destructorFunction);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = retType.fromWireType(rv);\n" +
                         "return ret;\n";
      } else {
      }
  
      invokerFnBody += "}\n";
  
      args1.push(invokerFnBody);
  
      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction;
    }
  
  function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array;
    }
  function __embind_register_class_class_function(rawClassType,
                                                    methodName,
                                                    argCount,
                                                    rawArgTypesAddr,
                                                    invokerSignature,
                                                    rawInvoker,
                                                    fn) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
  
        function unboundTypesHandler() {
          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
        }
  
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
  
        var proto = classType.registeredClass.constructor;
        if (undefined === proto[methodName]) {
          // This is the first function to be registered with this name.
          unboundTypesHandler.argCount = argCount-1;
          proto[methodName] = unboundTypesHandler;
        } else {
          // There was an existing function with the same name registered. Set up
          // a function overload routing table.
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount-1] = unboundTypesHandler;
        }
  
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          // Replace the initial unbound-types-handler stub with the proper
          // function. If multiple overloads are registered, the function handlers
          // go into an overload table.
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          var func = craftInvokerFunction(humanName, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn);
          if (undefined === proto[methodName].overloadTable) {
            func.argCount = argCount-1;
            proto[methodName] = func;
          } else {
            proto[methodName].overloadTable[argCount-1] = func;
          }
          return [];
        });
        return [];
      });
    }

  function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      var args = [rawConstructor];
      var destructors = [];
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = 'constructor ' + classType.name;
  
        if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
        };
  
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          // Insert empty slot for context type (argTypes[1]).
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    }

  function __embind_register_class_function(rawClassType,
                                              methodName,
                                              argCount,
                                              rawArgTypesAddr, // [ReturnType, ThisType, Args...]
                                              invokerSignature,
                                              rawInvoker,
                                              context,
                                              isPureVirtual) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
  
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
  
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
  
        function unboundTypesHandler() {
          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
        }
  
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {
          // This is the first overload to be registered, OR we are replacing a
          // function in the base class with a function in the derived class.
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          // There was an existing function with the same name registered. Set up
          // a function overload routing table.
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
  
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
  
          // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
          if (undefined === proto[methodName].overloadTable) {
            // Set argCount in case an overload is registered later
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
  
          return [];
        });
        return [];
      });
    }

  var emval_free_list = [];
  
  var emval_handle_array = [{},{value:undefined},{value:null},{value:true},{value:false}];
  function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
        emval_handle_array[handle] = undefined;
        emval_free_list.push(handle);
      }
    }
  
  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          ++count;
        }
      }
      return count;
    }
  
  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          return emval_handle_array[i];
        }
      }
      return null;
    }
  function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }
  var Emval = {toValue:(handle) => {
        if (!handle) {
            throwBindingError('Cannot use deleted val. handle = ' + handle);
        }
        return emval_handle_array[handle].value;
      },toHandle:(value) => {
        switch (value) {
          case undefined: return 1;
          case null: return 2;
          case true: return 3;
          case false: return 4;
          default:{
            var handle = emval_free_list.length ?
                emval_free_list.pop() :
                emval_handle_array.length;
  
            emval_handle_array[handle] = {refcount: 1, value: value};
            return handle;
          }
        }
      }};
  function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        'fromWireType': function(handle) {
          var rv = Emval.toValue(handle);
          __emval_decref(handle);
          return rv;
        },
        'toWireType': function(destructors, value) {
          return Emval.toHandle(value);
        },
        'argPackAdvance': 8,
        'readValueFromPointer': simpleReadValueFromPointer,
        destructorFunction: null, // This type does not need a destructor
  
        // TODO: do we need a deleteObject here?  write a test where
        // emval is passed into JS via an interface
      });
    }

  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }
  
  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }
  function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
               return value;
          },
          'toWireType': function(destructors, value) {
              // The VM will perform JS to Wasm value conversion, according to the spec:
              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }
  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }
  
      var shift = getShiftFromSize(size);
  
      var fromWireType = (value) => value;
  
      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = (value) => (value << bitshift) >>> bitshift;
      }
  
      var isUnsignedType = (name.includes('unsigned'));
      var checkAssertions = (value, toTypeName) => {
      }
      var toWireType;
      if (isUnsignedType) {
          toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value >>> 0;
          }
      } else {
          toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              // The VM will perform JS to Wasm value conversion, according to the spec:
              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
              return value;
          }
      }
      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': toWireType,
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        handle = handle >> 2;
        var heap = HEAPU32;
        var size = heap[handle]; // in elements
        var data = heap[handle + 1]; // byte offset into emscripten heap
        return new TA(buffer, data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        'fromWireType': decodeMemoryView,
        'argPackAdvance': 8,
        'readValueFromPointer': decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");
  
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];
  
              var str;
              if (stdStringIsUTF8) {
                  var decodeStartPtr = value + 4;
                  // Looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                      var currentBytePtr = value + 4 + i;
                      if (i == length || HEAPU8[currentBytePtr] == 0) {
                          var maxRead = currentBytePtr - decodeStartPtr;
                          var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                          if (str === undefined) {
                              str = stringSegment;
                          } else {
                              str += String.fromCharCode(0);
                              str += stringSegment;
                          }
                          decodeStartPtr = currentBytePtr + 1;
                      }
                  }
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }
  
              var getLength;
              var valueIsOfTypeString = (typeof value == 'string');
  
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = () => lengthBytesUTF8(value);
              } else {
                  getLength = () => value.length;
              }
  
              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if (valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        getHeap = () => HEAPU16;
        shift = 1;
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        getHeap = () => HEAPU32;
        shift = 2;
      }
      registerType(rawType, {
        name: name,
        'fromWireType': function(value) {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[value >> 2];
          var HEAP = getHeap();
          var str;
  
          var decodeStartPtr = value + 4;
          // Looping here to support possible embedded '0' bytes
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === undefined) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
  
          _free(value);
  
          return str;
        },
        'toWireType': function(destructors, value) {
          if (!(typeof value == 'string')) {
            throwBindingError('Cannot pass non-string to C++ string type ' + name);
          }
  
          // assumes 4-byte alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[ptr >> 2] = length >> shift;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        'argPackAdvance': 8,
        'readValueFromPointer': simpleReadValueFromPointer,
        destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_value_object(
      rawType,
      name,
      constructorSignature,
      rawConstructor,
      destructorSignature,
      rawDestructor
    ) {
      structRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
        fields: [],
      };
    }

  function __embind_register_value_object_field(
      structType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) {
      structRegistrations[structType].fields.push({
        fieldName: readLatin1String(fieldName),
        getterReturnType: getterReturnType,
        getter: embind__requireFunction(getterSignature, getter),
        getterContext: getterContext,
        setterArgumentType: setterArgumentType,
        setter: embind__requireFunction(setterSignature, setter),
        setterContext: setterContext,
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }

  function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }
  function __emval_as(handle, returnType, destructorsRef) {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, 'emval::as');
      var destructors = [];
      var rd = Emval.toHandle(destructors);
      HEAP32[destructorsRef >> 2] = rd;
      return returnType['toWireType'](destructors, handle);
    }

  function __emval_allocateDestructors(destructorsRef) {
      var destructors = [];
      HEAP32[destructorsRef >> 2] = Emval.toHandle(destructors);
      return destructors;
    }
  
  var emval_symbols = {};
  function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return readLatin1String(address);
      }
      return symbol;
    }
  
  var emval_methodCallers = [];
  function __emval_call_method(caller, handle, methodName, destructorsRef, args) {
      caller = emval_methodCallers[caller];
      handle = Emval.toValue(handle);
      methodName = getStringOrSymbol(methodName);
      return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);
    }

  function __emval_call_void_method(caller, handle, methodName, args) {
      caller = emval_methodCallers[caller];
      handle = Emval.toValue(handle);
      methodName = getStringOrSymbol(methodName);
      caller(handle, methodName, null, args);
    }


  function __emval_addMethodCaller(caller) {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    }
  
  function __emval_lookupTypes(argCount, argTypes) {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i],
                                     "parameter " + i);
      }
      return a;
    }
  
  var emval_registeredMethods = [];
  function __emval_get_method_caller(argCount, argTypes) {
      var types = __emval_lookupTypes(argCount, argTypes);
      var retType = types[0];
      var signatureName = retType.name + "_$" + types.slice(1).map(function (t) { return t.name; }).join("_") + "$";
      var returnId = emval_registeredMethods[signatureName];
      if (returnId !== undefined) {
        return returnId;
      }
  
      var params = ["retType"];
      var args = [retType];
  
      var argsList = ""; // 'arg0, arg1, arg2, ... , argN'
      for (var i = 0; i < argCount - 1; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        params.push("argType" + i);
        args.push(types[1 + i]);
      }
  
      var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
      var functionBody =
          "return function " + functionName + "(handle, name, destructors, args) {\n";
  
      var offset = 0;
      for (var i = 0; i < argCount - 1; ++i) {
          functionBody +=
          "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? ("+"+offset) : "") + ");\n";
          offset += types[i + 1]['argPackAdvance'];
      }
      functionBody +=
          "    var rv = handle[name](" + argsList + ");\n";
      for (var i = 0; i < argCount - 1; ++i) {
          if (types[i + 1]['deleteObject']) {
              functionBody +=
              "    argType" + i + ".deleteObject(arg" + i + ");\n";
          }
      }
      if (!retType.isVoid) {
          functionBody +=
          "    return retType.toWireType(destructors, rv);\n";
      }
      functionBody +=
          "};\n";
  
      params.push(functionBody);
      var invokerFunction = new_(Function, params).apply(null, args);
      returnId = __emval_addMethodCaller(invokerFunction);
      emval_registeredMethods[signatureName] = returnId;
      return returnId;
    }

  function __emval_get_property(handle, key) {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    }

  function __emval_incref(handle) {
      if (handle > 4) {
        emval_handle_array[handle].refcount += 1;
      }
    }

  function __emval_new_array() {
      return Emval.toHandle([]);
    }

  function __emval_new_cstring(v) {
      return Emval.toHandle(getStringOrSymbol(v));
    }

  function __emval_run_destructors(handle) {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    }

  function __emval_take_value(type, argv) {
      type = requireRegisteredType(type, '_emval_take_value');
      var v = type['readValueFromPointer'](argv);
      return Emval.toHandle(v);
    }

  function _abort() {
      abort('');
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function getHeapMax() {
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      return 2147483648;
    }
  
  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("randomDevice"); };
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      abort();
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              get: function() { return this.shared.flags; },
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              get function() { return this.shared.position; },
              set: function(val) { this.shared.position = val; },
            },
          };
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // Call musl-internal function to close all stdio streams, so nothing is
        // left in internal buffers.
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
      }
      return ret;
    }
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function convertI32PairToI53Checked(lo, hi) {
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
      }
      return ret;
    }
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _setTempRet0(val) {
      setTempRet0(val);
    }

  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    }
  
  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];
  function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }
  function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
      };
  
      var pattern = UTF8ToString(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
        // Modified Conversion Specifiers
        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
        '%EY': '%Y',                      // Replaced by the full alternative year representation.
        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value == 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      }
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      }
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        }
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      }
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      }
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear()-1;
          }
      }
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
          // January 4th, which is also the week that includes the first Thursday of the year, and
          // is also the first week that contains at least four days in the year.
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
          // the last week of the preceding year; thus, for Saturday 2nd January 1999,
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
          // or 31st is a Monday, it and any following days are part of week 1 of the following year.
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
  
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          var twelveHour = date.tm_hour;
          if (twelveHour == 0) twelveHour = 12;
          else if (twelveHour > 12) twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          return date.tm_wday || 7;
        },
        '%U': function(date) {
          var days = date.tm_yday + 7 - date.tm_wday;
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week)
          // as a decimal number [01,53]. If the week containing 1 January has four
          // or more days in the new year, then it is considered week 1.
          // Otherwise, it is the last week of the previous year, and the next week is week 1.
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);
          // If 1 Jan is just 1-3 days past Monday, the previous week
          // is also in this year.
          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {
            val++;
          }
          if (!val) {
            val = 52;
            // If 31 December of prev year a Thursday, or Friday of a
            // leap year, then the prev year has 53 weeks.
            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;
            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {
              val++;
            }
          } else if (val == 53) {
            // If 1 January is not a Thursday, and not a Wednesday of a
            // leap year, then this year has only 52 weeks.
            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;
            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))
              val = 1;
          }
          return leadingNulls(val, 2);
        },
        '%w': function(date) {
          return date.tm_wday;
        },
        '%W': function(date) {
          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
  
      // Replace %% with a pair of NULLs (which cannot occur in a C string), then
      // re-inject them after processing.
      pattern = pattern.replace(/%%/g, '\0\0')
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.includes(rule)) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
      pattern = pattern.replace(/\0\0/g, '%')
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }
  function _strftime_l(s, maxsize, format, tm) {
      return _strftime(s, maxsize, format, tm); // no locale support yet
    }
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
init_ClassHandle();
init_embind();;
init_RegisteredPointer();
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
init_emval();;

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


var asmLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__cxa_allocate_exception": ___cxa_allocate_exception,
  "__cxa_throw": ___cxa_throw,
  "_embind_finalize_value_object": __embind_finalize_value_object,
  "_embind_register_bigint": __embind_register_bigint,
  "_embind_register_bool": __embind_register_bool,
  "_embind_register_class": __embind_register_class,
  "_embind_register_class_class_function": __embind_register_class_class_function,
  "_embind_register_class_constructor": __embind_register_class_constructor,
  "_embind_register_class_function": __embind_register_class_function,
  "_embind_register_emval": __embind_register_emval,
  "_embind_register_float": __embind_register_float,
  "_embind_register_integer": __embind_register_integer,
  "_embind_register_memory_view": __embind_register_memory_view,
  "_embind_register_std_string": __embind_register_std_string,
  "_embind_register_std_wstring": __embind_register_std_wstring,
  "_embind_register_value_object": __embind_register_value_object,
  "_embind_register_value_object_field": __embind_register_value_object_field,
  "_embind_register_void": __embind_register_void,
  "_emval_as": __emval_as,
  "_emval_call_method": __emval_call_method,
  "_emval_call_void_method": __emval_call_void_method,
  "_emval_decref": __emval_decref,
  "_emval_get_method_caller": __emval_get_method_caller,
  "_emval_get_property": __emval_get_property,
  "_emval_incref": __emval_incref,
  "_emval_new_array": __emval_new_array,
  "_emval_new_cstring": __emval_new_cstring,
  "_emval_run_destructors": __emval_run_destructors,
  "_emval_take_value": __emval_take_value,
  "abort": _abort,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "setTempRet0": _setTempRet0,
  "strftime_l": _strftime_l
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___getTypeName = Module["___getTypeName"] = function() {
  return (___getTypeName = Module["___getTypeName"] = Module["asm"]["__getTypeName"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
  return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["__embind_register_native_and_builtin_types"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
  return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["__cxa_is_pointer_type"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viijii = Module["dynCall_viijii"] = function() {
  return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["dynCall_viijii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
  return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["dynCall_iiiiij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
  return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["dynCall_iiiiijj"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
  return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["dynCall_iiiiiijj"]).apply(null, arguments);
};





// === Auto-generated postamble setup entry stuff ===



var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();







  return Module.ready
}
);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);

/***/ }),

/***/ "3fZ9":
/*!**********************************************!*\
  !*** ./src/lib/fx/techniques/cpp/module.cpp ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Module = (() => {
  var _scriptDir = "file:///C:/Husky/streams2/tools/code/Influx/src/lib/fx/techniques/cpp/module.cpp";
  
  return (
function(Module) {
  Module = Module || {};



// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = true;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// This gives correct answers for everything less than 2^{14} = 16384
// I hope nobody is contemplating functions with 16384 arguments...
function uleb128Encode(n) {
  if (n < 128) {
    return [n];
  }
  return [(n % 128) | 128, n >> 7];
}

// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function == "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64',
      'p': 'i32',
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'p': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection = typeSection.concat(uleb128Encode(sigParam.length));
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the section code and overall length of the type section into the
  // section header
  typeSection = [0x01 /* Type section code */].concat(
    uleb128Encode(typeSection.length),
    typeSection
  );

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implemenation here for now.
    abort(text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') {
      
      return UTF8ToString(ret);
    }
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 2097152;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
var wasmBinaryFile;
if (Module['locateFile']) {
  wasmBinaryFile = 'C:/Husky/streams2/tools/code/Influx/webpack-addons/module-e32e6b96488546f5db0e12945a440365.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
} else {
  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.
  wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! ./webpack-addons/module-e32e6b96488546f5db0e12945a440365.wasm */ "MlWm"), __webpack_require__.b).toString();
}

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmMemory = Module['asm']['memory'];
    updateGlobalBufferAndViews(wasmMemory.buffer);

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // If instantiation fails, reject the module ready promise.
  instantiateAsync().catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            getWasmTableEntry(func)();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            getWasmTableEntry(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  
    /** @param {number} ptr
        @param {string} type
        @param {number|boolean=} noSafe */
  function getValue(ptr, type = 'i8', noSafe) {
      if (type.endsWith('*')) type = 'u32';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP32[((ptr)>>2)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return Number(HEAPF64[((ptr)>>3)]);
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only
        // populated if an Error object is thrown, so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  
    /** @param {number} ptr
        @param {number} value
        @param {string} type
        @param {number|boolean=} noSafe */
  function setValue(ptr, value, type = 'i8', noSafe) {
      if (type.endsWith('*')) type = 'u32';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped
      // functions so we need to call it here to retrieve the potential wrapper correctly
      // instead of just storing 'func' directly into wasmTableMirror
      wasmTableMirror[idx] = wasmTable.get(idx);
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  function ___cxa_allocate_exception(size) {
      // Thrown object is prepended by exception metadata block
      return _malloc(size + 24) + 24;
    }

  /** @constructor */
  function ExceptionInfo(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 24;
  
      this.set_type = function(type) {
        HEAPU32[(((this.ptr)+(4))>>2)] = type;
      };
  
      this.get_type = function() {
        return HEAPU32[(((this.ptr)+(4))>>2)];
      };
  
      this.set_destructor = function(destructor) {
        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;
      };
  
      this.get_destructor = function() {
        return HEAPU32[(((this.ptr)+(8))>>2)];
      };
  
      this.set_refcount = function(refcount) {
        HEAP32[((this.ptr)>>2)] = refcount;
      };
  
      this.set_caught = function (caught) {
        caught = caught ? 1 : 0;
        HEAP8[(((this.ptr)+(12))>>0)] = caught;
      };
  
      this.get_caught = function () {
        return HEAP8[(((this.ptr)+(12))>>0)] != 0;
      };
  
      this.set_rethrown = function (rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;
      };
  
      this.get_rethrown = function () {
        return HEAP8[(((this.ptr)+(13))>>0)] != 0;
      };
  
      // Initialize native structure fields. Should be called once after allocated.
      this.init = function(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
        this.set_refcount(0);
        this.set_caught(false);
        this.set_rethrown(false);
      }
  
      this.add_ref = function() {
        var value = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = value + 1;
      };
  
      // Returns true if last reference released.
      this.release_ref = function() {
        var prev = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = prev - 1;
        return prev === 1;
      };
  
      this.set_adjusted_ptr = function(adjustedPtr) {
        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;
      };
  
      this.get_adjusted_ptr = function() {
        return HEAPU32[(((this.ptr)+(16))>>2)];
      };
  
      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted
      // when the pointer is casted to some of the exception object base classes (e.g. when virtual
      // inheritance is used). When a pointer is thrown this method should return the thrown pointer
      // itself.
      this.get_exception_ptr = function() {
        // Work around a fastcomp bug, this code is still included for some reason in a build without
        // exceptions support.
        var isPointer = ___cxa_is_pointer_type(this.get_type());
        if (isPointer) {
          return HEAPU32[((this.excPtr)>>2)];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0) return adjusted;
        return this.excPtr;
      };
    }
  
  var exceptionLast = 0;
  
  var uncaughtExceptionCount = 0;
  function ___cxa_throw(ptr, type, destructor) {
      var info = new ExceptionInfo(ptr);
      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      throw ptr;
    }

  var structRegistrations = {};
  
  function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    }
  
  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }
  
  var awaitingDependencies = {};
  
  var registeredTypes = {};
  
  var typeDependencies = {};
  
  var char_0 = 48;
  
  var char_9 = 57;
  function makeLegalFunctionName(name) {
      if (undefined === name) {
        return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return '_' + name;
      }
      return name;
    }
  function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }
  function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
  
          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };
  
      return errorClass;
    }
  var InternalError = undefined;
  function throwInternalError(message) {
      throw new InternalError(message);
    }
  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });
  
      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }
  function __embind_finalize_value_object(structType) {
      var reg = structRegistrations[structType];
      delete structRegistrations[structType];
  
      var rawConstructor = reg.rawConstructor;
      var rawDestructor = reg.rawDestructor;
      var fieldRecords = reg.fields;
      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).
                concat(fieldRecords.map((field) => field.setterArgumentType));
      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {
        var fields = {};
        fieldRecords.forEach((field, i) => {
          var fieldName = field.fieldName;
          var getterReturnType = fieldTypes[i];
          var getter = field.getter;
          var getterContext = field.getterContext;
          var setterArgumentType = fieldTypes[i + fieldRecords.length];
          var setter = field.setter;
          var setterContext = field.setterContext;
          fields[fieldName] = {
            read: (ptr) => {
              return getterReturnType['fromWireType'](
                  getter(getterContext, ptr));
            },
            write: (ptr, o) => {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
              runDestructors(destructors);
            }
          };
        });
  
        return [{
          name: reg.name,
          'fromWireType': function(ptr) {
            var rv = {};
            for (var i in fields) {
              rv[i] = fields[i].read(ptr);
            }
            rawDestructor(ptr);
            return rv;
          },
          'toWireType': function(destructors, o) {
            // todo: Here we have an opportunity for -O3 level "unsafe" optimizations:
            // assume all fields are present without checking.
            for (var fieldName in fields) {
              if (!(fieldName in o)) {
                throw new TypeError('Missing field:  "' + fieldName + '"');
              }
            }
            var ptr = rawConstructor();
            for (fieldName in fields) {
              fields[fieldName].write(ptr, o[fieldName]);
            }
            if (destructors !== null) {
              destructors.push(rawDestructor, ptr);
            }
            return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: rawDestructor,
        }];
      });
    }

  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}

  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }
  
  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }
  var embind_charCodes = undefined;
  function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
  
  var BindingError = undefined;
  function throwBindingError(message) {
      throw new BindingError(message);
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }
  
      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }
      if (!(other instanceof ClassHandle)) {
        return false;
      }
  
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
  
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
  
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
  
      return leftClass === rightClass && left === right;
    }
  
  function shallowCopyInternalPointer(o) {
      return {
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType,
      };
    }
  
  function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }
  
  var finalizationRegistry = false;
  
  function detachFinalizer(handle) {}
  
  function runDestructor($$) {
      if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }
  function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    }
  
  function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (undefined === desiredClass.baseClass) {
        return null; // no conversion
      }
  
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
          return null;
      }
      return desiredClass.downcast(rv);
    }
  
  var registeredPointers = {};
  
  function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
  
  function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
          }
      }
      return rv;
    }
  
  var deletionQueue = [];
  function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj['delete']();
      }
    }
  
  var delayFunction = undefined;
  function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }
  function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }
  var registeredInstances = {};
  
  function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    }
  function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
  
  function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
        $$: {
            value: record,
        },
      }));
    }
  function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)
  
      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
  
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
        // JS object has been neutered, time to repopulate it
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance['clone']();
        } else {
          // else, just increment reference count on existing object
          // it already has a reference to the smart pointer
          var rv = registeredInstance['clone']();
          this.destructor(ptr);
          return rv;
        }
      }
  
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: rawPointer,
            smartPtrType: this,
            smartPtr: ptr,
          });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this,
            ptr: ptr,
          });
        }
      }
  
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
  
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
          return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
          smartPtrType: this,
          smartPtr: ptr,
        });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
        });
      }
    }
  function attachFinalizer(handle) {
      if ('undefined' === typeof FinalizationRegistry) {
          attachFinalizer = (handle) => handle;
          return handle;
      }
      // If the running environment has a FinalizationRegistry (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationRegistry
      // at run-time, not build-time.
      finalizationRegistry = new FinalizationRegistry((info) => {
          releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle) => {
        var $$ = handle.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          // We should not call the destructor on raw pointers in case other code expects the pointee to live
          var info = { $$: $$ };
          finalizationRegistry.register(handle, info, handle);
        }
        return handle;
      };
      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);
      return attachFinalizer(handle);
    }
  function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this;
      } else {
        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
          $$: {
            value: shallowCopyInternalPointer(this.$$),
          }
        }));
  
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone;
      }
    }
  
  function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
  
      detachFinalizer(this);
      releaseClassHandle(this.$$);
  
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = undefined;
        this.$$.ptr = undefined;
      }
    }
  
  function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
  
  function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }
  function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }
  function ClassHandle() {
    }
  
  function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function() {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
              throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
          }
          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }
  /** @param {number=} numArguments */
  function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError("Cannot register public name '" + name + "' twice");
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module.hasOwnProperty(numArguments)) {
            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      }
      else {
        Module[name] = value;
        if (undefined !== numArguments) {
          Module[name].numArguments = numArguments;
        }
      }
    }
  
  /** @constructor */
  function RegisteredClass(name,
                               constructor,
                               instancePrototype,
                               rawDestructor,
                               baseClass,
                               getActualType,
                               upcast,
                               downcast) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
  
  function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }
  function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
  
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
  
      if (this.isSmartPointer) {
        // TODO: this is not strictly true
        // We could support BY_EMVAL conversions from raw pointers to smart pointers
        // because the smart pointer can hold a reference to the handle
        if (undefined === handle.$$.smartPtr) {
          throwBindingError('Passing raw pointer to smart pointer is illegal');
        }
  
        switch (this.sharingPolicy) {
          case 0: // NONE
            // no upcasting
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
            }
            break;
  
          case 1: // INTRUSIVE
            ptr = handle.$$.smartPtr;
            break;
  
          case 2: // BY_EMVAL
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle['clone']();
              ptr = this.rawShare(
                ptr,
                Emval.toHandle(function() {
                  clonedHandle['delete']();
                })
              );
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
  
          default:
            throwBindingError('Unsupporting sharing policy');
        }
      }
      return ptr;
    }
  
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
      }
  
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
  
  function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }
  
  function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle['delete']();
      }
    }
  function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }
  /** @constructor
      @param {*=} pointeeType,
      @param {*=} sharingPolicy,
      @param {*=} rawGetPointee,
      @param {*=} rawConstructor,
      @param {*=} rawShare,
      @param {*=} rawDestructor,
       */
  function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
  
      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
  
      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
  
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this['toWireType'] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this['toWireType'] = genericPointerToWireType;
        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
        //       craftInvokerFunction altogether.
      }
    }
  
  /** @param {number=} numArguments */
  function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistant public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      }
      else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    }
  
  function dynCallLegacy(sig, ptr, args) {
      var f = Module["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
  /** @param {Object=} args */
  function dynCall(sig, ptr, args) {
      // Without WASM_BIGINT support we cannot directly call function with i64 as
      // part of thier signature, so we rely the dynCall functions generated by
      // wasm-emscripten-finalize
      if (sig.includes('j')) {
        return dynCallLegacy(sig, ptr, args);
      }
      return getWasmTableEntry(ptr).apply(null, args)
    }
  function getDynCaller(sig, ptr) {
      var argCache = [];
      return function() {
        argCache.length = 0;
        Object.assign(argCache, arguments);
        return dynCall(sig, ptr, argCache);
      };
    }
  function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
  
      function makeDynCaller() {
        if (signature.includes('j')) {
          return getDynCaller(signature, rawFunction);
        }
        return getWasmTableEntry(rawFunction);
      }
  
      var fp = makeDynCaller();
      if (typeof fp != "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }
      return fp;
    }
  
  var UnboundTypeError = undefined;
  
  function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }
  function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
    }
  function __embind_register_class(rawType,
                                     rawPointerType,
                                     rawConstPointerType,
                                     baseClassRawType,
                                     getActualTypeSignature,
                                     getActualType,
                                     upcastSignature,
                                     upcast,
                                     downcastSignature,
                                     downcast,
                                     name,
                                     destructorSignature,
                                     rawDestructor) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
  
      exposePublicSymbol(legalFunctionName, function() {
        // this code cannot run if baseClassRawType is zero
        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });
  
      whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        function(base) {
          base = base[0];
  
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
  
          var constructor = createNamedFunction(legalFunctionName, function() {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name);
            }
            if (undefined === registeredClass.constructor_body) {
              throw new BindingError(name + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[arguments.length];
            if (undefined === body) {
              throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
            }
            return body.apply(this, arguments);
          });
  
          var instancePrototype = Object.create(basePrototype, {
            constructor: { value: constructor },
          });
  
          constructor.prototype = instancePrototype;
  
          var registeredClass = new RegisteredClass(name,
                                                    constructor,
                                                    instancePrototype,
                                                    rawDestructor,
                                                    baseClass,
                                                    getActualType,
                                                    upcast,
                                                    downcast);
  
          var referenceConverter = new RegisteredPointer(name,
                                                         registeredClass,
                                                         true,
                                                         false,
                                                         false);
  
          var pointerConverter = new RegisteredPointer(name + '*',
                                                       registeredClass,
                                                       false,
                                                       false,
                                                       false);
  
          var constPointerConverter = new RegisteredPointer(name + ' const*',
                                                            registeredClass,
                                                            false,
                                                            true,
                                                            false);
  
          registeredPointers[rawType] = {
            pointerType: pointerConverter,
            constPointerType: constPointerConverter
          };
  
          replacePublicSymbol(legalFunctionName, constructor);
  
          return [referenceConverter, pointerConverter, constPointerConverter];
        }
      );
    }

  function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array;
    }
  function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      var args = [rawConstructor];
      var destructors = [];
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = 'constructor ' + classType.name;
  
        if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
        };
  
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          // Insert empty slot for context type (argTypes[1]).
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    }

  function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
      }
      /*
       * Previously, the following line was just:
       *   function dummy() {};
       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even
       * though at creation, the 'dummy' has the correct constructor name.  Thus,
       * objects created with IMVU.new would show up in the debugger as 'dummy',
       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the
       * issue.  Doublely-unfortunately, there's no way to write a test for this
       * behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;
  
      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = false;
  
      for (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
          needsDestructorStack = true;
          break;
        }
      }
  
      var returns = (argTypes[0].name !== "void");
  
      var argsList = "";
      var argsListWired = "";
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i!==0?", ":"")+"arg"+i;
        argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
      }
  
      var invokerFnBody =
          "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
          "if (arguments.length !== "+(argCount - 2)+") {\n" +
              "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
          "}\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
  
      if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
      }
  
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
        args1.push("argType"+i);
        args2.push(argTypes[i+2]);
      }
  
      if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
  
      invokerFnBody +=
          (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
            args1.push(paramName+"_dtor");
            args2.push(argTypes[i].destructorFunction);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = retType.fromWireType(rv);\n" +
                         "return ret;\n";
      } else {
      }
  
      invokerFnBody += "}\n";
  
      args1.push(invokerFnBody);
  
      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction;
    }
  function __embind_register_class_function(rawClassType,
                                              methodName,
                                              argCount,
                                              rawArgTypesAddr, // [ReturnType, ThisType, Args...]
                                              invokerSignature,
                                              rawInvoker,
                                              context,
                                              isPureVirtual) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
  
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
  
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
  
        function unboundTypesHandler() {
          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
        }
  
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {
          // This is the first overload to be registered, OR we are replacing a
          // function in the base class with a function in the derived class.
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          // There was an existing function with the same name registered. Set up
          // a function overload routing table.
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
  
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
  
          // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
          if (undefined === proto[methodName].overloadTable) {
            // Set argCount in case an overload is registered later
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
  
          return [];
        });
        return [];
      });
    }

  var emval_free_list = [];
  
  var emval_handle_array = [{},{value:undefined},{value:null},{value:true},{value:false}];
  function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
        emval_handle_array[handle] = undefined;
        emval_free_list.push(handle);
      }
    }
  
  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          ++count;
        }
      }
      return count;
    }
  
  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          return emval_handle_array[i];
        }
      }
      return null;
    }
  function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }
  var Emval = {toValue:(handle) => {
        if (!handle) {
            throwBindingError('Cannot use deleted val. handle = ' + handle);
        }
        return emval_handle_array[handle].value;
      },toHandle:(value) => {
        switch (value) {
          case undefined: return 1;
          case null: return 2;
          case true: return 3;
          case false: return 4;
          default:{
            var handle = emval_free_list.length ?
                emval_free_list.pop() :
                emval_handle_array.length;
  
            emval_handle_array[handle] = {refcount: 1, value: value};
            return handle;
          }
        }
      }};
  function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        'fromWireType': function(handle) {
          var rv = Emval.toValue(handle);
          __emval_decref(handle);
          return rv;
        },
        'toWireType': function(destructors, value) {
          return Emval.toHandle(value);
        },
        'argPackAdvance': 8,
        'readValueFromPointer': simpleReadValueFromPointer,
        destructorFunction: null, // This type does not need a destructor
  
        // TODO: do we need a deleteObject here?  write a test where
        // emval is passed into JS via an interface
      });
    }

  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }
  
  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }
  function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
               return value;
          },
          'toWireType': function(destructors, value) {
              // The VM will perform JS to Wasm value conversion, according to the spec:
              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker);
  
      exposePublicSymbol(name, function() {
          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, function(argTypes) {
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);
          return [];
      });
    }

  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }
  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }
  
      var shift = getShiftFromSize(size);
  
      var fromWireType = (value) => value;
  
      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = (value) => (value << bitshift) >>> bitshift;
      }
  
      var isUnsignedType = (name.includes('unsigned'));
      var checkAssertions = (value, toTypeName) => {
      }
      var toWireType;
      if (isUnsignedType) {
          toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              return value >>> 0;
          }
      } else {
          toWireType = function(destructors, value) {
              checkAssertions(value, this.name);
              // The VM will perform JS to Wasm value conversion, according to the spec:
              // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
              return value;
          }
      }
      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': toWireType,
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        handle = handle >> 2;
        var heap = HEAPU32;
        var size = heap[handle]; // in elements
        var data = heap[handle + 1]; // byte offset into emscripten heap
        return new TA(buffer, data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        'fromWireType': decodeMemoryView,
        'argPackAdvance': 8,
        'readValueFromPointer': decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");
  
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];
  
              var str;
              if (stdStringIsUTF8) {
                  var decodeStartPtr = value + 4;
                  // Looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                      var currentBytePtr = value + 4 + i;
                      if (i == length || HEAPU8[currentBytePtr] == 0) {
                          var maxRead = currentBytePtr - decodeStartPtr;
                          var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                          if (str === undefined) {
                              str = stringSegment;
                          } else {
                              str += String.fromCharCode(0);
                              str += stringSegment;
                          }
                          decodeStartPtr = currentBytePtr + 1;
                      }
                  }
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }
  
              var getLength;
              var valueIsOfTypeString = (typeof value == 'string');
  
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = () => lengthBytesUTF8(value);
              } else {
                  getLength = () => value.length;
              }
  
              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if (valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        getHeap = () => HEAPU16;
        shift = 1;
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        getHeap = () => HEAPU32;
        shift = 2;
      }
      registerType(rawType, {
        name: name,
        'fromWireType': function(value) {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[value >> 2];
          var HEAP = getHeap();
          var str;
  
          var decodeStartPtr = value + 4;
          // Looping here to support possible embedded '0' bytes
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === undefined) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
  
          _free(value);
  
          return str;
        },
        'toWireType': function(destructors, value) {
          if (!(typeof value == 'string')) {
            throwBindingError('Cannot pass non-string to C++ string type ' + name);
          }
  
          // assumes 4-byte alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[ptr >> 2] = length >> shift;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        'argPackAdvance': 8,
        'readValueFromPointer': simpleReadValueFromPointer,
        destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_value_object(
      rawType,
      name,
      constructorSignature,
      rawConstructor,
      destructorSignature,
      rawDestructor
    ) {
      structRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
        fields: [],
      };
    }

  function __embind_register_value_object_field(
      structType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) {
      structRegistrations[structType].fields.push({
        fieldName: readLatin1String(fieldName),
        getterReturnType: getterReturnType,
        getter: embind__requireFunction(getterSignature, getter),
        getterContext: getterContext,
        setterArgumentType: setterArgumentType,
        setter: embind__requireFunction(setterSignature, setter),
        setterContext: setterContext,
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }

  function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }
  function __emval_as(handle, returnType, destructorsRef) {
      handle = Emval.toValue(handle);
      returnType = requireRegisteredType(returnType, 'emval::as');
      var destructors = [];
      var rd = Emval.toHandle(destructors);
      HEAP32[destructorsRef >> 2] = rd;
      return returnType['toWireType'](destructors, handle);
    }

  function __emval_allocateDestructors(destructorsRef) {
      var destructors = [];
      HEAP32[destructorsRef >> 2] = Emval.toHandle(destructors);
      return destructors;
    }
  
  var emval_symbols = {};
  function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return readLatin1String(address);
      }
      return symbol;
    }
  
  var emval_methodCallers = [];
  function __emval_call_method(caller, handle, methodName, destructorsRef, args) {
      caller = emval_methodCallers[caller];
      handle = Emval.toValue(handle);
      methodName = getStringOrSymbol(methodName);
      return caller(handle, methodName, __emval_allocateDestructors(destructorsRef), args);
    }

  function __emval_call_void_method(caller, handle, methodName, args) {
      caller = emval_methodCallers[caller];
      handle = Emval.toValue(handle);
      methodName = getStringOrSymbol(methodName);
      caller(handle, methodName, null, args);
    }


  function emval_get_global() {
      if (typeof globalThis == 'object') {
        return globalThis;
      }
      return (function(){
        return Function;
      })()('return this')();
    }
  function __emval_get_global(name) {
      if (name===0) {
        return Emval.toHandle(emval_get_global());
      } else {
        name = getStringOrSymbol(name);
        return Emval.toHandle(emval_get_global()[name]);
      }
    }

  function __emval_addMethodCaller(caller) {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    }
  
  function __emval_lookupTypes(argCount, argTypes) {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i],
                                     "parameter " + i);
      }
      return a;
    }
  
  var emval_registeredMethods = [];
  function __emval_get_method_caller(argCount, argTypes) {
      var types = __emval_lookupTypes(argCount, argTypes);
      var retType = types[0];
      var signatureName = retType.name + "_$" + types.slice(1).map(function (t) { return t.name; }).join("_") + "$";
      var returnId = emval_registeredMethods[signatureName];
      if (returnId !== undefined) {
        return returnId;
      }
  
      var params = ["retType"];
      var args = [retType];
  
      var argsList = ""; // 'arg0, arg1, arg2, ... , argN'
      for (var i = 0; i < argCount - 1; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        params.push("argType" + i);
        args.push(types[1 + i]);
      }
  
      var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
      var functionBody =
          "return function " + functionName + "(handle, name, destructors, args) {\n";
  
      var offset = 0;
      for (var i = 0; i < argCount - 1; ++i) {
          functionBody +=
          "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? ("+"+offset) : "") + ");\n";
          offset += types[i + 1]['argPackAdvance'];
      }
      functionBody +=
          "    var rv = handle[name](" + argsList + ");\n";
      for (var i = 0; i < argCount - 1; ++i) {
          if (types[i + 1]['deleteObject']) {
              functionBody +=
              "    argType" + i + ".deleteObject(arg" + i + ");\n";
          }
      }
      if (!retType.isVoid) {
          functionBody +=
          "    return retType.toWireType(destructors, rv);\n";
      }
      functionBody +=
          "};\n";
  
      params.push(functionBody);
      var invokerFunction = new_(Function, params).apply(null, args);
      returnId = __emval_addMethodCaller(invokerFunction);
      emval_registeredMethods[signatureName] = returnId;
      return returnId;
    }

  function __emval_get_property(handle, key) {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    }

  function __emval_incref(handle) {
      if (handle > 4) {
        emval_handle_array[handle].refcount += 1;
      }
    }

  function __emval_new_array() {
      return Emval.toHandle([]);
    }

  function __emval_new_cstring(v) {
      return Emval.toHandle(getStringOrSymbol(v));
    }

  function __emval_new_object() {
      return Emval.toHandle({});
    }

  function __emval_run_destructors(handle) {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    }

  function __emval_set_property(handle, key, value) {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      value = Emval.toValue(value);
      handle[key] = value;
    }

  function __emval_take_value(type, argv) {
      type = requireRegisteredType(type, '_emval_take_value');
      var v = type['readValueFromPointer'](argv);
      return Emval.toHandle(v);
    }

  function _abort() {
      abort('');
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function getHeapMax() {
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      return 2147483648;
    }
  
  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("randomDevice"); };
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      abort();
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              get: function() { return this.shared.flags; },
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              get function() { return this.shared.position; },
              set: function(val) { this.shared.position = val; },
            },
          };
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // Call musl-internal function to close all stdio streams, so nothing is
        // left in internal buffers.
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
      }
      return ret;
    }
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function convertI32PairToI53Checked(lo, hi) {
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
      }
      return ret;
    }
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _setTempRet0(val) {
      setTempRet0(val);
    }

  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    }
  
  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];
  function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }
  function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
      };
  
      var pattern = UTF8ToString(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
        // Modified Conversion Specifiers
        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
        '%EY': '%Y',                      // Replaced by the full alternative year representation.
        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value == 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      }
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      }
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        }
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      }
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      }
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear()-1;
          }
      }
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
          // January 4th, which is also the week that includes the first Thursday of the year, and
          // is also the first week that contains at least four days in the year.
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
          // the last week of the preceding year; thus, for Saturday 2nd January 1999,
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
          // or 31st is a Monday, it and any following days are part of week 1 of the following year.
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
  
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          var twelveHour = date.tm_hour;
          if (twelveHour == 0) twelveHour = 12;
          else if (twelveHour > 12) twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          return date.tm_wday || 7;
        },
        '%U': function(date) {
          var days = date.tm_yday + 7 - date.tm_wday;
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week)
          // as a decimal number [01,53]. If the week containing 1 January has four
          // or more days in the new year, then it is considered week 1.
          // Otherwise, it is the last week of the previous year, and the next week is week 1.
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);
          // If 1 Jan is just 1-3 days past Monday, the previous week
          // is also in this year.
          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {
            val++;
          }
          if (!val) {
            val = 52;
            // If 31 December of prev year a Thursday, or Friday of a
            // leap year, then the prev year has 53 weeks.
            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;
            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {
              val++;
            }
          } else if (val == 53) {
            // If 1 January is not a Thursday, and not a Wednesday of a
            // leap year, then this year has only 52 weeks.
            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;
            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))
              val = 1;
          }
          return leadingNulls(val, 2);
        },
        '%w': function(date) {
          return date.tm_wday;
        },
        '%W': function(date) {
          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
  
      // Replace %% with a pair of NULLs (which cannot occur in a C string), then
      // re-inject them after processing.
      pattern = pattern.replace(/%%/g, '\0\0')
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.includes(rule)) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
      pattern = pattern.replace(/\0\0/g, '%')
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }
  function _strftime_l(s, maxsize, format, tm) {
      return _strftime(s, maxsize, format, tm); // no locale support yet
    }
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
init_ClassHandle();
init_embind();;
init_RegisteredPointer();
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
init_emval();;

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


var asmLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__cxa_allocate_exception": ___cxa_allocate_exception,
  "__cxa_throw": ___cxa_throw,
  "_embind_finalize_value_object": __embind_finalize_value_object,
  "_embind_register_bigint": __embind_register_bigint,
  "_embind_register_bool": __embind_register_bool,
  "_embind_register_class": __embind_register_class,
  "_embind_register_class_constructor": __embind_register_class_constructor,
  "_embind_register_class_function": __embind_register_class_function,
  "_embind_register_emval": __embind_register_emval,
  "_embind_register_float": __embind_register_float,
  "_embind_register_function": __embind_register_function,
  "_embind_register_integer": __embind_register_integer,
  "_embind_register_memory_view": __embind_register_memory_view,
  "_embind_register_std_string": __embind_register_std_string,
  "_embind_register_std_wstring": __embind_register_std_wstring,
  "_embind_register_value_object": __embind_register_value_object,
  "_embind_register_value_object_field": __embind_register_value_object_field,
  "_embind_register_void": __embind_register_void,
  "_emval_as": __emval_as,
  "_emval_call_method": __emval_call_method,
  "_emval_call_void_method": __emval_call_void_method,
  "_emval_decref": __emval_decref,
  "_emval_get_global": __emval_get_global,
  "_emval_get_method_caller": __emval_get_method_caller,
  "_emval_get_property": __emval_get_property,
  "_emval_incref": __emval_incref,
  "_emval_new_array": __emval_new_array,
  "_emval_new_cstring": __emval_new_cstring,
  "_emval_new_object": __emval_new_object,
  "_emval_run_destructors": __emval_run_destructors,
  "_emval_set_property": __emval_set_property,
  "_emval_take_value": __emval_take_value,
  "abort": _abort,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "setTempRet0": _setTempRet0,
  "strftime_l": _strftime_l
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___getTypeName = Module["___getTypeName"] = function() {
  return (___getTypeName = Module["___getTypeName"] = Module["asm"]["__getTypeName"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
  return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["__embind_register_native_and_builtin_types"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
  return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["__cxa_is_pointer_type"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viijii = Module["dynCall_viijii"] = function() {
  return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["dynCall_viijii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
  return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["dynCall_iiiiij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
  return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["dynCall_iiiiijj"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
  return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["dynCall_iiiiiijj"]).apply(null, arguments);
};





// === Auto-generated postamble setup entry stuff ===



var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();







  return Module.ready
}
);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);

/***/ }),

/***/ "ScS0":
/*!**********************************************************************************************************!*\
  !*** data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw== ***!
  \**********************************************************************************************************/
/***/ ((module) => {

module.exports = "data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==";

/***/ }),

/***/ "ngQa":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII= ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=";

/***/ }),

/***/ "6e1k":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjNDI0MjQyIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg== ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjNDI0MjQyIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";

/***/ }),

/***/ "uFmn":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjQzVDNUM1Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg== ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjQzVDNUM1Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";

/***/ }),

/***/ "nU2I":
/*!********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Bold.eot ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "0a05d0db5c325aaeaad2.eot";

/***/ }),

/***/ "hm/n":
/*!********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Bold.ttf ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "dfda0d04b1e6e74eb051.ttf";

/***/ }),

/***/ "phpT":
/*!*********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Bold.woff ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "fa869de7dcd1fc13d9ed.woff";

/***/ }),

/***/ "KISA":
/*!**************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-BoldItalic.eot ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "7462ad4a4df95d8e62de.eot";

/***/ }),

/***/ "hxng":
/*!**************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-BoldItalic.ttf ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "0dabe18564cd6f22f6d5.ttf";

/***/ }),

/***/ "vjGn":
/*!***************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-BoldItalic.woff ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1c32e94eda5a3440abd8.woff";

/***/ }),

/***/ "ByKz":
/*!*************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBold.eot ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "2a1594e9817647416bc1.eot";

/***/ }),

/***/ "X0ru":
/*!*************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBold.ttf ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "6895d918cfdb6eb12a4a.ttf";

/***/ }),

/***/ "5hm/":
/*!**************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBold.woff ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "5a28ff1356ba339994a1.woff";

/***/ }),

/***/ "k000":
/*!*******************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBoldItalic.eot ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "fa33eb2a6f9c707ee609.eot";

/***/ }),

/***/ "ASCZ":
/*!*******************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBoldItalic.ttf ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "d6e72d9afb78ef77a23e.ttf";

/***/ }),

/***/ "8wxu":
/*!********************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-ExtraBoldItalic.woff ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "2c128727e812636a0c81.woff";

/***/ }),

/***/ "TmKA":
/*!**********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Italic.eot ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "9a1eecee6364bf687561.eot";

/***/ }),

/***/ "EH0b":
/*!**********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Italic.ttf ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "fe765814cb2a18549fb8.ttf";

/***/ }),

/***/ "vib5":
/*!***********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Italic.woff ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "69e722dfb542e5d4f68f.woff";

/***/ }),

/***/ "S5Bv":
/*!*********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Light.eot ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "7be98f7b48f357a4f0ff.eot";

/***/ }),

/***/ "go9E":
/*!*********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Light.ttf ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1fc8a45c2ca9eae91b75.ttf";

/***/ }),

/***/ "wf1j":
/*!**********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Light.woff ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "eb2482ea07e77b95c4b3.woff";

/***/ }),

/***/ "Y/V/":
/*!***************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-LightItalic.eot ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "56e94b60acb1ee45def6.eot";

/***/ }),

/***/ "unS+":
/*!***************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-LightItalic.ttf ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1e04e43a4b782a61c00c.ttf";

/***/ }),

/***/ "cG71":
/*!****************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-LightItalic.woff ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "ead1bfce6b28f2b858c9.woff";

/***/ }),

/***/ "FEm/":
/*!***********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Regular.eot ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "123bd5006a1d902d17da.eot";

/***/ }),

/***/ "B9Gu":
/*!***********************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Regular.ttf ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1c0a329c683d91fc91aa.ttf";

/***/ }),

/***/ "YUzg":
/*!************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-Regular.woff ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "229564cad5daae8ae40b.woff";

/***/ }),

/***/ "8371":
/*!************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBold.eot ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "44cfe251d2dba74352c5.eot";

/***/ }),

/***/ "X6xQ":
/*!************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBold.ttf ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "55174aa1f4f5a88ec5eb.ttf";

/***/ }),

/***/ "O0ak":
/*!*************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBold.woff ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "c7a3ffd87605fb2f5cab.woff";

/***/ }),

/***/ "TWab":
/*!******************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBoldItalic.eot ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "54e0870a5b5072060f2f.eot";

/***/ }),

/***/ "iTsd":
/*!******************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBoldItalic.ttf ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "0d59c11a94448b1b63a5.ttf";

/***/ }),

/***/ "ytbO":
/*!*******************************************************************************!*\
  !*** ./src/sandbox/styles/custom/fonts/OpenSans/OpenSans-SemiBoldItalic.woff ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "3bd3ebb9f302c0642123.woff";

/***/ }),

/***/ "0Wsb":
/*!*********************************************************************!*\
  !*** ./webpack-addons/module-7937ca9cc6f8782be9620f24a283f5b5.wasm ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "c0c39f7d09137a7eb48c.wasm";

/***/ }),

/***/ "MlWm":
/*!*********************************************************************!*\
  !*** ./webpack-addons/module-e32e6b96488546f5db0e12945a440365.wasm ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "1dc3b069f6dbc166a540.wasm";

/***/ }),

/***/ "Zvko":
/*!****************************!*\
  !*** ./src/lib/fx/HLSL.gr ***!
  \****************************/
/***/ ((module) => {

module.exports = "S : Program\r\nProgram : --add\r\nProgram : Decls\r\n\r\nDecls : Decl --expose\r\nDecls : Decls Decl\r\n\r\nDecl : ';'\r\nDecl : TypeDecl\r\nDecl : VariableDecl\r\nDecl : VarStructDecl\r\nDecl : FunctionDecl\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    Decl : TechniqueDecl\r\n#endif\r\nDecl : Technique11Decl\r\nDecl : UseDecl\r\n#if FX_PART\r\n    Decl : ImportDecl\r\n    Decl : ProvideDecl\r\n#endif\r\nDecl : CbufferDecl\r\nDecl : TbufferDecl\r\nDecl : ERROR\r\n\r\n#if FX_PART\r\n    Decl : PartFxDecl\r\n    ImportDecl : T_KW_IMPORT String ';'\r\n    ProvideDecl : T_KW_PROVIDE ComplexNameOpt ';'\r\n# ProvideDecl : T_KW_PROVIDE ComplexNameOpt T_KW_AS ComplexNameOpt ';'\r\n#endif \r\n\r\nUseDecl : T_KW_USE Mode\r\nMode : T_KW_STRICT\r\n\r\nUsages : Usage --expose\r\nUsages : Usages Usage\r\nUsage : T_KW_STATIC --add\r\nUsage : T_KW_NOINTERPOLATION\r\nUsage : T_KW_CENTROID\r\nUsage : T_KW_NOPERSPECTIVE\r\nUsage : T_KW_UNIFORM\r\nUsage : T_KW_EXTERN\r\nUsage : T_KW_VOLATILE\r\nUsage : T_KW_INLINE\r\nUsage : T_KW_UNSIGNED\r\nUsage : T_KW_PRECISE\r\nUsage : ConstUsage\r\n\r\nConstUsages : ConstUsage --expose\r\nConstUsages : ConstUsages ConstUsage\r\nConstUsage : T_KW_CONST\r\nConstUsage : T_KW_ROW_MAJOR\r\nConstUsage : T_KW_COLUMN_MAJOR\r\n\r\nUsageType : Type --add\r\nUsageType : Usages Type\r\n\r\nUsageStructDecl : StructDecl --add\r\nUsageStructDecl : Usages StructDecl\r\n\r\nTypeDecl : T_KW_TYPEDEF ConstType TypeDefs --F addTypeDef ';' --add\r\nTypeDecl : T_KW_TYPEDEF ConstStructDecl TypeDefs --F addTypeDef ';'\r\nTypeDecl : StructDecl ';'\r\nTypeDefs : VariableDim\r\nTypeDefs : VariableDim ',' TypeDefs\r\n\r\nType : BaseType --add\r\nType : Struct\r\nType : TypeId\r\nType : T_KW_STRUCT TypeId\r\n\r\nConstType : Type --add\r\nConstType : ConstUsages Type\r\nConstTypeDim : ConstType --expose\r\nConstTypeDim : ConstTypeDim '[' ConstantExpr ']'\r\n\r\nBaseType : T_KW_VOID --add\r\nBaseType : ScalarType\r\nBaseType : VectorType\r\nBaseType : MatrixType\r\nBaseType : ObjectType\r\n\r\nScalarType : T_KW_BOOL --add\r\nScalarType : T_KW_INT\r\n# ScalarType : T_KW_UNSIGNED T_KW_INT\r\nScalarType : T_KW_UINT\r\nScalarType : T_KW_HALF\r\nScalarType : T_KW_FLOAT\r\nScalarType : T_KW_DOUBLE\r\n\r\nVectorType : T_KW_VECTOR --add\r\nVectorType : T_KW_VECTOR '<' ScalarType ',' AddExpr '>'\r\n\r\nMatrixType : T_KW_MATRIX --add\r\nMatrixType : T_KW_MATRIX '<' ScalarType ',' ConstantExpr ',' AddExpr '>'\r\n\r\nObjectType : T_KW_STRING --add\r\nObjectType : T_KW_TEXTURE\r\nObjectType : T_KW_TEXTURE1D\r\nObjectType : T_KW_TEXTURE2D\r\nObjectType : T_KW_TEXTURE2D '<' Type '>'\r\n#if FX_PART\r\n    ObjectType : T_KW_TRIMESH '<' Type '>'\r\n#endif\r\nObjectType : T_KW_TEXTURE2DARRAY\r\nObjectType : T_KW_TEXTURE3D\r\nObjectType : T_KW_TEXTURE3D '<' Type '>'\r\nObjectType : T_KW_TEXTURECUBE\r\nObjectType : T_KW_TEXTURECUBEARRAY\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectType : T_KW_SAMPLER\r\n    # ObjectType : T_KW_SAMPLER1D\r\n    # ObjectType : T_KW_SAMPLER2D\r\n    # ObjectType : T_KW_SAMPLER3D\r\n    # ObjectType : T_KW_SAMPLERCUBE\r\n    # ObjectType : T_KW_STATEBLOCK\r\n#endif\r\nObjectType : T_KW_SAMPLER_STATE\r\nObjectType : T_KW_SAMPLER_COMPARISON_STATE\r\nObjectType : T_KW_DEPTH_STENCIL_STATE\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectType : T_KW_PIXELSHADER\r\n    # ObjectType : T_KW_VERTEXSHADER\r\n    # ObjectType : T_KW_PIXELFRAGMENT\r\n    # ObjectType : T_KW_VERTEXFRAGMENT\r\n#endif\r\nObjectType : T_KW_RWTEXTURE1D '<' Type '>'\r\nObjectType : T_KW_RWTEXTURE2D '<' Type '>'\r\nObjectType : T_KW_RWTEXTURE3D '<' Type '>'\r\nObjectType : T_KW_BUFFER '<' Type '>'\r\nObjectType : T_KW_RWBUFFER '<' Type '>'\r\nObjectType : T_KW_RWSTRUCTUREDBUFFER '<' Type '>'\r\nObjectType : T_KW_STRUCTUREDBUFFER '<' Type '>'\r\nObjectType : T_KW_APPENDSTRUCTUREDBUFFER '<' Type '>'\r\n\r\nStruct : T_KW_STRUCT '{' '}' --add\r\nStruct : T_KW_STRUCT '{' StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id --F addType '{' '}' --add\r\nStructDecl : T_KW_STRUCT Id --F addType '{' UseDecl StructDecls '}'\r\nStructDecl : T_KW_STRUCT Id --F addType '{' StructDecls '}'\r\n\r\nConstStructDecl : StructDecl\r\nConstStructDecl : ConstUsages StructDecl\r\n\r\nStructDecls : VariableDecl --expose \r\nStructDecls : VarStructDecl --expose \r\nStructDecls : VariableDecl StructDecls\r\nStructDecls : VarStructDecl StructDecls\r\n\r\nSemantic : ':' Id --add\r\nSemantic : ':' T_KW_REGISTER '(' Register ')'\r\nSemantics : Semantic\r\nSemantics : Semantics Semantic\r\nSemanticsOpt :\r\nSemanticsOpt : Semantics\r\n\r\nRegister : Id\r\nRegister : Target ',' Id\r\n\r\nAnnotation : AnnotationBegin AnnotationEnd  --add\r\nAnnotation : AnnotationBegin AnnotationDecls AnnotationEnd\r\nAnnotationOpt :\r\nAnnotationOpt : Annotation\r\nAnnotationBegin : '<'\r\nAnnotationDecls : VariableDecl\r\nAnnotationDecls : VariableDecl AnnotationDecls\r\nAnnotationEnd : '>'\r\n\r\nInitializer : '=' AssignmentExpr --add\r\nInitializer : '=' ERROR --add\r\nInitializer : '=' '{' InitExprs '}'\r\nInitializer : '=' '{' InitExprs ',' '}'\r\nInitializer : StateBlock\r\n\r\nVariableDecl : UsageType Variables ';' --add\r\nVariableDecl : UsageType Variables ERROR --add\r\nVarStructDecl : UsageStructDecl Variables ';' --add\r\n\r\nVariables : Variable --expose\r\nVariables : Variables ',' Variable\r\n# Variables : Variables ERROR Variable\r\nVariables : Variables ',' ERROR\r\nVariable : VariableDim SemanticsOpt AnnotationOpt Initializer --add\r\nVariable : VariableDim SemanticsOpt AnnotationOpt --add\r\nVariableDim : NonTypeId --add\r\nVariableDim : VariableDim '[' ConstantExpr ']'\r\n\r\n\r\nFunctionDecl : Attributes FunctionDef ';' --add\r\nFunctionDecl : FunctionDef ';' --add\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt StmtBlock\r\nFunctionDecl : FunctionDef AnnotationOpt StmtBlock\r\n\r\n# TODO: remove it;\r\nFunctionDecl : Attributes FunctionDef AnnotationOpt ERROR\r\nFunctionDecl : FunctionDef AnnotationOpt ERROR\r\n\r\nFunctionDef : UsageType NonTypeId ParamList SemanticsOpt\r\n\r\nAttribute : '[' Id '(' ArgumentsOpt ')' ']'\r\nAttribute : '[' Id ']'\r\nAttributes : Attribute --expose\r\nAttributes : Attributes Attribute\r\nAttributesOpt : --expose\r\nAttributesOpt : Attributes\r\n\r\nParamList : '(' ')'\r\nParamList : '(' T_KW_VOID ')'\r\nParamList : '(' ParameterDecls ')'\r\n\r\nParameterDecls : ParameterDecl --expose\r\nParameterDecls : ParameterDecls ',' ParameterDecl\r\nParameterDecls : ParameterDecls ERROR ParameterDecl\r\nParameterDecls : ParameterDecls ',' ERROR\r\nParameterDecls : ERROR\r\nParameterDecl : ParamUsageType Variable\r\n\r\nParamUsageType : Type --add\r\nParamUsageType : ParamUsages Type\r\n\r\nParamUsages : ParamUsage --expose\r\nParamUsages : ParamUsages ParamUsage\r\nParamUsage : T_KW_IN --add\r\nParamUsage : T_KW_OUT\r\nParamUsage : T_KW_INOUT\r\nParamUsage : T_KW_UNIFORM\r\nParamUsage : ConstUsage\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    TechniqueDecl : T_KW_TECHNIQUE ComplexNameOpt SemanticsOpt AnnotationOpt TechniqueBody --add\r\n    TechniqueBody : '{' '}'  --add\r\n    TechniqueBody : '{' PassDecls '}'\r\n#endif \r\n\r\nTechnique11Decl : T_KW_TECHNIQUE11 ComplexNameOpt SemanticsOpt AnnotationOpt Technique11Body --add\r\nTechnique11Body : '{' '}'  --add\r\nTechnique11Body : '{' Pass11Decls '}'\r\n\r\nCbufferDecl : T_KW_CBUFFER IdOpt SemanticsOpt AnnotationOpt '{' StructDecls '}' ';' --add\r\nCbufferDecl : T_KW_CBUFFER IdOpt SemanticsOpt AnnotationOpt '{' '}' ';' --add\r\nTbufferDecl : T_KW_TBUFFER IdOpt SemanticsOpt AnnotationOpt '{' StructDecls '}' ';' --add\r\nTbufferDecl : T_KW_TBUFFER IdOpt SemanticsOpt AnnotationOpt '{' '}' ';' --add\r\n\r\nComplexNameOpt : ComplexName --add\r\nComplexName : Id --expose\r\nComplexName : ComplexName '.' Id\r\n\r\n#if PRESETS_EX\r\n    PresetDecl : T_KW_PRESET Id AnnotationOpt PassStateBlock --add\r\n#endif\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassDecls : PassDecl --expose\r\n    PassDecls : PassDecls PassDecl\r\n    PassDecl : T_KW_PASS IdOpt AnnotationOpt PassStateBlock --add\r\n    #if PRESETS_EX\r\n    PassDecl : PresetDecl\r\n    #endif\r\n    PassDecl : ';'\r\n#endif\r\n\r\nPass11Decls : Pass11Decl --expose\r\nPass11Decls : Pass11Decls Pass11Decl\r\nPass11Decl : T_KW_PASS IdOpt AnnotationOpt StmtBlock --add\r\nPass11Decl : ';'\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassStateBlock : '{' '}' --add\r\n    PassStateBlock : '{' PassStates '}'\r\n    PassStates : PassState --expose\r\n    PassStates : PassStates PassState\r\n\r\n    PassState : Id StateIndex '=' PassStateExpr ';' --add\r\n#endif\r\n\r\n# todo: move all particles declarations to separate grammar!\r\n#if FX_PART\r\n    PartFxDecl : T_KW_FXPART ComplexNameOpt SemanticsOpt AnnotationOpt PartFxBody --add\r\n\r\n    PartFxBody : '{' '}' \r\n    PartFxBody : '{' PartFxProperties '}'\r\n\r\n    PartFxProperties : PartFxProperty --expose\r\n    PartFxProperties : PartFxProperties PartFxProperty\r\n    PartFxProperty : PassState\r\n    PartFxProperty : PassDecl\r\n#endif // FX_PART\r\n\r\nStateBlock : '{' '}' --add\r\nStateBlock : '{' States '}'\r\nStateBlock : '{' StateBlockItems '}'\r\nStateBlockItems : StateBlock  --expose\r\nStateBlockItems : StateBlock ',' StateBlockItems\r\nState : Id StateIndex '=' StateExpr ';' --add\r\nStates : State --expose\r\nStates : States State\r\n\r\nStateIndex :\r\nStateIndex : '[' Uint ']'\r\n\r\nStmtBlock : '{' '}' --add\r\nStmtBlock : '{' Stmts '}'  \r\n\r\nStmts : Stmt --expose\r\nStmts : Stmts Stmt\r\n\r\n# SimpleStmt : ERROR ';' \r\n# SimpleStmt : ';' --add\r\n\r\nSimpleStmt : Expr ';'\r\nSimpleStmt : Expr ERROR\r\nSimpleStmt : T_KW_RETURN ';'\r\nSimpleStmt : T_KW_RETURN Expr ';'\r\nSimpleStmt : T_KW_RETURN ERROR ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' Expr ')' ';'\r\nSimpleStmt : T_KW_DO Stmt T_KW_WHILE '(' ERROR ')' ';'\r\nSimpleStmt : StmtBlock\r\nSimpleStmt : T_KW_DISCARD ';'\r\nSimpleStmt : TypeDecl\r\nSimpleStmt : VariableDecl --add\r\nSimpleStmt : VarStructDecl\r\nSimpleStmt : T_KW_BREAK ';'\r\nSimpleStmt : T_KW_BREAK ERROR\r\nSimpleStmt : T_KW_CONTINUE ';'\r\nSimpleStmt : T_KW_CONTINUE ERROR\r\n\r\n#if FX_PART\r\n    SimpleStmt : T_KW_SPAWN '(' Expr ')' NonTypeId '(' ArgumentsOpt ')' ';'\r\n    SimpleStmt : T_KW_DRAW NonTypeId '(' ArgumentsOpt ')' ';'\r\n#endif\r\n\r\n\r\nNonIfStmt : SimpleStmt --add\r\nNonIfStmt : ';'\r\nNonIfStmt : WhileStmt NonIfStmt\r\nNonIfStmt : ForStmt NonIfStmt\r\n\r\nStmt : SimpleStmt --add\r\nStmt : UseDecl\r\nStmt : WhileStmt Stmt\r\nStmt : ForStmt Stmt\r\nStmt : IfStmt Stmt\r\nStmt : IfStmt NonIfStmt T_KW_ELSE Stmt\r\nStmt : ERROR\r\nStmt : ';'\r\n\r\nIfStmt : AttributesOpt T_KW_IF '(' Expr ')' --expose\r\nIfStmt : AttributesOpt T_KW_IF '(' ERROR ')' --expose\r\n\r\nWhileStmt : T_KW_WHILE '(' Expr ')' --expose\r\nWhileStmt : T_KW_WHILE '(' ERROR ')' --expose\r\n\r\nForStmt : AttributesOpt For '(' ForInit ForCond ForStep ')' --expose\r\nForStmt : AttributesOpt For ERROR --expose\r\n\r\nFor : T_KW_FOR\r\n\r\nForInit : ';' --add\r\nForInit : Expr ';'\r\nForInit : VariableDecl\r\nForInit : ERROR ';'\r\n\r\nForCond : ';' --add\r\nForCond : Expr ';'\r\nForCond : ERROR ';'\r\n\r\nForStep : --add\r\nForStep : Expr\r\nForStep : ERROR\r\n\r\nDwordExpr : Dword\r\nDwordExpr : Dword '|' DwordExpr\r\n\r\nDwordExprSeq : DwordExpr --expose\r\nDwordExprSeq : DwordExpr ',' DwordExprSeq\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    PassStateExpr : DwordExpr --add\r\n    PassStateExpr : ComplexExpr\r\n    PassStateExpr : String\r\n    PassStateExpr : '{' DwordExprSeq '}'\r\n#endif\r\n\r\nStateExpr : DwordExpr --add\r\nStateExpr : ComplexExpr\r\nStateExpr : '{' InitExprs '}'\r\nStateExpr : '{' InitExprs ',' '}'\r\nStateExpr : '<' RelationalExpr '>'\r\n\r\nSimpleExpr : T_KW_TRUE\r\nSimpleExpr : T_KW_FALSE\r\nSimpleExpr : Uint\r\nSimpleExpr : Float\r\nSimpleExpr : String\r\nSimpleExpr : NonTypeId\r\n\r\nComplexExpr : '(' Expr ')'\r\nComplexExpr : TypeId '(' ArgumentsOpt ')'\r\nComplexExpr : BaseType '(' ArgumentsOpt ')' \r\nComplexExpr : NonTypeId '(' ArgumentsOpt ')'\r\nComplexExpr : PostfixPointExpr '(' ArgumentsOpt ')'\r\nComplexExpr : ObjectExpr\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    ObjectExpr : T_KW_COMPILE NonTypeId '(' ArgumentsOpt ')'\r\n    ObjectExpr : T_KW_COMPILE_FRAGMENT Target NonTypeId '(' ArgumentsOpt ')'\r\n#endif\r\n\r\nObjectExpr : T_KW_COMPILE_SHADER '(' ArgumentsOpt ')'\r\n\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # ObjectExpr : T_KW_SAMPLER_STATE StateBlock\r\n    # ObjectExpr : T_KW_STATEBLOCK_STATE StateBlocStateBlockk\r\n#endif\r\n\r\nPrimaryExpr : ComplexExpr\r\nPrimaryExpr : SimpleExpr\r\nPostfixExpr : PrimaryExpr\r\nPostfixExpr : PostfixExpr '[' Expr ']'\r\nPostfixExpr : PostfixExpr '[' ERROR ']'\r\nPostfixExpr : PostfixExpr '.' Id\r\nPostfixExpr : PostfixExpr T_OP_INC\r\nPostfixExpr : PostfixExpr T_OP_DEC\r\n\r\nPostfixPointExpr : PostfixExpr '.' Id\r\n\r\nUnaryExpr : PostfixExpr\r\nUnaryExpr : T_OP_INC UnaryExpr\r\nUnaryExpr : T_OP_DEC UnaryExpr\r\n# UnaryExpr : T_OP_INC ERROR\r\n# UnaryExpr : T_OP_DEC ERROR\r\nUnaryExpr : '!' CastExpr\r\nUnaryExpr : '~' CastExpr\r\n# UnaryExpr : '!' ERROR\r\nUnaryExpr : '-' CastExpr\r\nUnaryExpr : '+' CastExpr\r\n\r\nCastExpr : UnaryExpr\r\nCastExpr : '(' ConstTypeDim ')' CastExpr\r\nCastExpr : '(' ERROR ')' CastExpr\r\n\r\nMulExpr : CastExpr\r\nMulExpr : MulExpr '*' CastExpr\r\nMulExpr : MulExpr '/' CastExpr\r\nMulExpr : MulExpr '%' CastExpr\r\n\r\nMulExpr : ERROR '*' CastExpr\r\nMulExpr : ERROR '/' CastExpr\r\nMulExpr : ERROR '%' CastExpr\r\nMulExpr : MulExpr '*' ERROR\r\nMulExpr : MulExpr '/' ERROR\r\nMulExpr : MulExpr '%' ERROR\r\n# MulExpr : ERROR '*' ERROR\r\n# MulExpr : ERROR '/' ERROR\r\n# MulExpr : ERROR '%' ERROR\r\n\r\nAddExpr : MulExpr\r\nAddExpr : AddExpr '+' MulExpr\r\nAddExpr : AddExpr '-' MulExpr\r\n\r\nAddExpr : AddExpr '+' ERROR\r\nAddExpr : AddExpr '-' ERROR\r\n\r\nShiftExpr : AddExpr\r\nShiftExpr : ShiftExpr T_OP_SL AddExpr\r\nShiftExpr : ShiftExpr T_OP_SR AddExpr\r\n\r\nShiftExpr : ShiftExpr T_OP_SR ERROR\r\nShiftExpr : ShiftExpr T_OP_SL ERROR\r\n\r\nRelationalExpr : ShiftExpr\r\nRelationalExpr : RelationalExpr '<' ShiftExpr\r\nRelationalExpr : RelationalExpr '>' ShiftExpr\r\nRelationalExpr : RelationalExpr T_OP_LE ShiftExpr\r\nRelationalExpr : RelationalExpr T_OP_GE ShiftExpr\r\n\r\nRelationalExpr : ERROR '<' ShiftExpr\r\nRelationalExpr : RelationalExpr '<' ERROR\r\nRelationalExpr : ERROR '<' ERROR\r\n\r\nRelationalExpr : RelationalExpr '>' ERROR\r\nRelationalExpr : ERROR '>' ShiftExpr\r\nRelationalExpr : ERROR '>' ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_LE ERROR\r\nRelationalExpr : ERROR T_OP_LE ShiftExpr\r\nRelationalExpr : ERROR T_OP_LE ERROR\r\n\r\nRelationalExpr : RelationalExpr T_OP_GE ERROR\r\nRelationalExpr : ERROR T_OP_GE ShiftExpr\r\nRelationalExpr : ERROR T_OP_GE ERROR\r\n\r\nEqualityExpr : RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE RelationalExpr\r\nEqualityExpr : ERROR T_OP_EQ RelationalExpr\r\nEqualityExpr : EqualityExpr T_OP_NE ERROR\r\nEqualityExpr : ERROR T_OP_NE ERROR\r\n\r\nAndExpr : EqualityExpr\r\nAndExpr : AndExpr '&' EqualityExpr\r\nAndExpr : ERROR '&' EqualityExpr\r\nAndExpr : AndExpr '&' ERROR\r\n\r\nExclusiveOrExpr : AndExpr\r\nExclusiveOrExpr : ExclusiveOrExpr '^' AndExpr\r\nExclusiveOrExpr : ERROR '^' AndExpr\r\nExclusiveOrExpr : ExclusiveOrExpr '^' ERROR\r\n\r\nInclusiveOrExpr : ExclusiveOrExpr\r\nInclusiveOrExpr : InclusiveOrExpr '|' ExclusiveOrExpr\r\nInclusiveOrExpr : ERROR '|' ExclusiveOrExpr\r\nInclusiveOrExpr : InclusiveOrExpr '|' ERROR\r\n\r\nLogicalAndExpr : InclusiveOrExpr\r\nLogicalAndExpr : LogicalAndExpr T_OP_AND InclusiveOrExpr\r\nLogicalAndExpr : ERROR T_OP_AND InclusiveOrExpr\r\nLogicalAndExpr : LogicalAndExpr T_OP_AND ERROR\r\n\r\nLogicalOrExpr : LogicalAndExpr\r\nLogicalOrExpr : LogicalOrExpr T_OP_OR LogicalAndExpr\r\nLogicalOrExpr : ERROR T_OP_OR LogicalAndExpr\r\nLogicalOrExpr : LogicalOrExpr T_OP_OR ERROR\r\n\r\nConditionalExpr : LogicalOrExpr\r\nConditionalExpr : LogicalOrExpr '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : ERROR '?' AssignmentExpr ':' ConditionalExpr\r\nConditionalExpr : LogicalOrExpr '?' ERROR ':' ConditionalExpr\r\nConditionalExpr : LogicalOrExpr '?' AssignmentExpr ':' ERROR\r\nConditionalExpr : LogicalOrExpr '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ERROR\r\nConditionalExpr : ERROR '?' ERROR ':' ConditionalExpr\r\n\r\nAssignmentExpr : ConditionalExpr\r\nAssignmentExpr : CastExpr '=' AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_ME AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_DE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_RE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_AE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_BORE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_BANDE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_XORE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SRE AssignmentExpr\r\nAssignmentExpr : CastExpr T_OP_SLE AssignmentExpr\r\n\r\nArguments : AssignmentExpr --expose\r\nArguments : Arguments ',' AssignmentExpr\r\nArguments : Arguments ERROR AssignmentExpr\r\nArguments : Arguments ',' ERROR\r\nArgumentsOpt : --expose\r\nArgumentsOpt : Arguments\r\n\r\nInitExpr : AssignmentExpr --add\r\nInitExpr : '{' InitExprs '}'\r\nInitExpr : '{' InitExprs ',' '}'\r\nInitExprs : InitExpr --expose\r\nInitExprs : InitExprs ',' InitExpr\r\n\r\nConstantExpr : AssignmentExpr\r\nExpr : AssignmentExpr\r\nExpr : Expr ',' AssignmentExpr\r\nExpr : Expr ',' ERROR\r\nExpr : ERROR ',' ERROR\r\nExpr : ERROR ',' AssignmentExpr\r\n\r\nDword : Uint\r\nDword : '-' Uint\r\nDword : Float\r\nDword : '-' Float\r\nDword : DwordId\r\nDword : Uint DwordId\r\nDwordId : Id\r\nDwordId : T_KW_TRUE\r\nDwordId : T_KW_FALSE\r\nDwordId : T_KW_TEXTURE\r\n\r\nId : TypeId\r\nId : NonTypeId\r\nIdOpt :\r\nIdOpt : Id\r\n\r\nTarget : NonTypeId\r\n\r\nUint : T_UINT\r\nFloat : T_FLOAT\r\n\r\nStrings : String\r\nStrings : Strings String\r\nString : T_STRING\r\n\r\nTypeId : T_TYPE_ID\r\nNonTypeId : T_NON_TYPE_ID\r\n\r\nLineTerminator : T_LINE_TERMINATOR\r\n\r\nAsmDecl : T_KW_DECL '{'\r\nAsm : T_KW_ASM '{'\r\nAsmFragment : T_KW_ASM_FRAGMENT '{'\r\n\r\n--LEXER--\r\n\r\nT_KW_UNSIGNED : \"unsigned\"\r\nT_KW_PRECISE : \"precise\"\r\nT_KW_STATIC : \"static\"\r\nT_KW_NOINTERPOLATION : \"nointerpolation\"\r\nT_KW_CENTROID : \"centroid\"\r\nT_KW_NOPERSPECTIVE : \"noperspective\"\r\nT_KW_UNIFORM : \"uniform\"\r\nT_KW_EXTERN : \"extern\"\r\nT_KW_VOLATILE : \"volatile\"\r\nT_KW_INLINE : \"inline\"\r\nT_KW_CONST : \"const\"\r\nT_KW_ROW_MAJOR : \"row_major\"\r\nT_KW_COLUMN_MAJOR : \"column_major\"\r\nT_KW_TYPEDEF : \"typedef\"\r\nT_KW_STRUCT : \"struct\"\r\nT_KW_VOID : \"void\"\r\nT_KW_BOOL : \"bool\"\r\nT_KW_INT : \"int\"\r\nT_KW_UINT : \"uint\"\r\nT_KW_HALF : \"half\"\r\nT_KW_FLOAT : \"float\"\r\nT_KW_DOUBLE : \"double\"\r\nT_KW_VECTOR : \"vector\"\r\nT_KW_MATRIX : \"matrix\"\r\nT_KW_STRING : \"string\"\r\nT_KW_TEXTURE : \"Texture\"\r\nT_KW_TEXTURE1D : \"Texture1D\"\r\nT_KW_TEXTURE2D : \"Texture2D\"\r\nT_KW_TEXTURE2DARRAY : \"Texture2DArray\"\r\nT_KW_TEXTURE3D : \"Texture3D\"\r\nT_KW_TEXTURECUBE : \"TextureCube\"\r\nT_KW_TEXTURECUBEARRAY : \"TextureCubeArray\"\r\nT_KW_CBUFFER : \"cbuffer\"\r\nT_KW_TBUFFER : \"tbuffer\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # T_KW_SAMPLER : \"sampler\"\r\n    # T_KW_SAMPLER1D : \"sampler1D\"\r\n    # T_KW_SAMPLER2D : \"sampler2D\"\r\n    # T_KW_SAMPLER3D : \"sampler3D\"\r\n    # T_KW_SAMPLERCUBE : \"samplerCUBE\"\r\n    # T_KW_STATEBLOCK : \"stateblock\"\r\n    # T_KW_STATEBLOCK_STATE : \"stateblock_state\"\r\n#endif\r\nT_KW_SAMPLER_STATE : \"SamplerState\"\r\nT_KW_SAMPLER_COMPARISON_STATE : \"SamplerComparisonState\"\r\nT_KW_DEPTH_STENCIL_STATE : \"DepthStencilState\"\r\nT_KW_BLEND_STATE : \"BlendState\"\r\nT_KW_RASTERIZER_STATE : \"RasterizerState\"\r\nT_KW_BUFFER : \"Buffer\"\r\nT_KW_RWTEXTURE1D : \"RWTexture1D\"\r\nT_KW_RWTEXTURE2D : \"RWTexture2D\"\r\nT_KW_RWTEXTURE3D : \"RWTexture3D\"\r\nT_KW_RWBUFFER : \"RWBuffer\"\r\nT_KW_STRUCTUREDBUFFER : \"StructuredBuffer\"\r\nT_KW_RWSTRUCTUREDBUFFER : \"RWStructuredBuffer\"\r\nT_KW_APPENDSTRUCTUREDBUFFER : \"AppendStructuredBuffer\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    # T_KW_PIXELSHADER : \"pixelshader\"\r\n    # T_KW_VERTEXSHADER : \"vertexshader\"\r\n    # T_KW_PIXELFRAGMENT : \"pixelfragment\"\r\n    # T_KW_VERTEXFRAGMENT : \"vertexfragment\"\r\n#endif\r\nT_KW_REGISTER : \"register\"\r\nT_KW_IN : \"in\"\r\nT_KW_OUT : \"out\"\r\nT_KW_INOUT : \"inout\"\r\nT_KW_TECHNIQUE : \"technique\"\r\nT_KW_TECHNIQUE11 : \"technique11\"\r\n#if PRESETS_EX\r\n    T_KW_PRESET : \"preset\"\r\n#endif\r\n#if FX_PART\r\n    T_KW_FXPART : \"partFx\"\r\n    T_KW_TRIMESH : \"TriMesh\"\r\n#endif\r\nT_KW_PASS : \"pass\"\r\nT_KW_RETURN : \"return\"\r\nT_KW_DO : \"do\"\r\nT_KW_DISCARD : \"discard\"\r\nT_KW_WHILE : \"while\"\r\nT_KW_IF : \"if\"\r\nT_KW_ELSE : \"else\"\r\nT_KW_FOR : \"for\"\r\nT_KW_TRUE : \"true\"\r\nT_KW_FALSE : \"false\"\r\n#if TECHNIQUE9_DEPRECATED_SUPPORT\r\n    T_KW_COMPILE : \"compile\"\r\n    T_KW_COMPILE_SHADER : \"CompileShader\"\r\n#endif\r\nT_KW_COMPILE_FRAGMENT : \"compile_fragment\"\r\nT_KW_DECL : \"decl\"\r\nT_KW_ASM : \"asm\"\r\nT_KW_ASM_FRAGMENT : \"asm_fragment\"\r\nT_KW_USE : \"use\"\r\nT_KW_STRICT : \"strict\"\r\n#id FX_PART\r\n    T_KW_IMPORT : \"import\"\r\n    T_KW_PROVIDE : \"provide\"\r\n#endif\r\nT_KW_SWITCH : \"switch\"\r\nT_KW_CASE : \"case\"\r\nT_KW_DEFAULT : \"default\"\r\nT_KW_BREAK : \"break\"\r\n#if FX_PART\r\n    T_KW_SPAWN : \"spawn\"\r\n    T_KW_DRAW : \"draw\"\r\n#endif\r\nT_KW_CONTINUE : \"continue\"\r\n# T_KW_AS : \"as\"\r\nT_OP_INC : \"++\"\r\nT_OP_DEC : \"--\"\r\nT_OP_LE : \">=\"\r\nT_OP_GE : \"<=\"\r\nT_OP_EQ : \"==\"\r\nT_OP_NE : \"!=\"\r\nT_OP_AND : \"&&\"\r\nT_OP_OR : \"||\"\r\nT_OP_ME : \"*=\"\r\nT_OP_DE : \"/=\"\r\nT_OP_RE : \"%=\"\r\nT_OP_AE : \"+=\"\r\nT_OP_SE : \"-=\"\r\nT_OP_SR : \">>\"\r\nT_OP_SL : \"<<\"\r\nT_OP_BORE : \"|=\"\r\nT_OP_BANDE : \"&=\"\r\nT_OP_XORE : \"^=\"\r\nT_OP_SRE : \">>=\"\r\nT_OP_SLE : \"<<=\"\r\n";

/***/ }),

/***/ "//+9":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "vCZ/":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("electron");

/***/ }),

/***/ "Q/He":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "71Pi":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "HzQp":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "E9s6":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "0xhk":
/*!**********************************************************!*\
  !*** ./src/sandbox/components/graphEx/lib/template.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"type":"part","content":{"layout":"struct Part\\n{\\n\\tfloat3 pos;\\n\\tfloat timelife;\\n};","graph":{"last_node_id":21,"last_link_id":4,"nodes":[{"id":19,"type":"fx/SpawnRoutine","pos":{"0":504,"1":102,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0},"size":[180,30],"flags":{},"order":0,"mode":0,"inputs":[{"name":"count = 1","type":"int","link":null}],"outputs":[],"title":"SpawnRoutine","properties":{"count":1}},{"id":20,"type":"fx/UpdateRoutine","pos":{"0":503,"1":218,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0},"size":[140,30],"flags":{},"order":1,"mode":0,"inputs":[],"outputs":[{"name":"stmts","type":-1,"links":null,"visible":false}],"title":"UpdateRoutine","properties":{}},{"id":21,"type":"fx/InitRoutine","pos":{"0":504,"1":319,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0},"size":[140,30],"flags":{},"order":2,"mode":0,"inputs":[],"outputs":[{"name":"stmts","type":-1,"links":null,"visible":false}],"title":"Init Routine","properties":{}}],"links":[],"groups":[],"config":{},"extra":{},"version":0.4}}}');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["vendors"], () => (__webpack_exec__("0172")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=sandbox.5d23753f67a525dcfa63.js.map